%======================================================================
000000  %       C X - S I N 0 - G E N
000000  %======================================================================
000000  STGPA=*
000000
000000  "8SCSI 7D1U0 -8ZSCS
000000  175777/8ZSCS
176000
176000  "7D1U0+7D1U1+7D1U2+7D1U3
176000  % SCSI DISK 1 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D2U0+7D2U1+7D2U2+7D2U3
176000  % SCSI DISK 2 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D3U0+7D3U1+7D3U2+7D3U3
176000  % SCSI DISK 3 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D4U0+7D4U1+7D4U2+7D4U3
176000  % SCSI DISK 4 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D5U0+7D5U1+7D5U2+7D5U3
176000  % SCSI DISK 5 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D6U0+7D6U1+7D6U2+7D6U3
176000  % SCSI DISK 6 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D7U0+7D7U1+7D7U2+7D7U3
176000  % SCSI DISK 7 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7D8U0+7D8U1+7D8U2+7D8U3
176000  % SCSI DISK 8 PREREQUISITES
176000  175777/8SCSI
176000
176000  "7S1U0+7S2U0
176000  % SCSI STREAMER PREREQUISITES
176000  175777/7S1U0; 8SCSI
176001
176001  "7O1U0+7O1U1+7O1U2+7O1U3
176001  % OPTICAL DISK 1 PREREQUISITES
176001  175777/7O1U0
176000
176000  "7O2U0+7O2U1+7O2U2+7O2U3
176000  % OPTICAL DISK 2 PREREQUISITES
176000  175777/7O2U0
176000
176000  "7O1U0+7O2U0+7O3U0+7O4U0
176000  % OPTICAL DISK GENERAL PREREQUISITES
176000  175777/8SCSI; 8SCOD       % SCSI OPTICAL DISK
176001
176001  "9M1U0+9M2U0+9M3U0+9M4U0
176001  % OPTICAL MAGTAPE PREREQUISITES
176001  175777/8SCSI; 8SCMT       % SCSI MAGTAPE
176001
176001  "8SCSI
176001  % GENERATE 8VSX0 LIBRARY MARK TO GET STANDARD SYSTEM
176001  175777/8VSX0; 8STRD; 8SCS1
176002
176002  "8N500 8STRD 8SIBA+8SIBX+8SIBM+8SIBN
176002  175777/8MTRA     % 5MTRANS IF SIBAS
176000  175777/8F5UD     % AND FAST UDMA OPTION
176000  "
176000  %---------------------------------
176000  % Having Only one debugger does not work, only 0 or >= 2 are okay values.
176000
176000  % STANDARD SYSTEM, FORCE NEW-SYSTEM TO ASK FOR CPU-NUMBER
176000  "8VSX0
176000  )KILL 33CPU 33CPN
176000  33CPU=0; 33CPN=0
176000  "
176000
176000  % --
176000
176000  "8HDM1+8HDM2+8HDM3+8HDM4+8HDM5+8HDM6
176000  175777/8HDMA
176000  "
176000  "8BD1
176000  175777/8ZBDI             % SWAPPING ON SMD DISK
176000  "8WD1+8MD1
176000  175777/8ZWDI             % SWAPPING ON ST-506 DISK
176000
176000  "8ZSCS
176000  175777/8SCSI; 7D1U0      % SWAPPING ON SCSI DISK
176001  "7O1U0+7O1U1+7O1U2+7O1U3+7O2U0+7O2U1+7O2U2+7O2U3+7O3U0+7O3U1+7O3U2+7O3U3+7O4U0+7O4U1+7O4U2+7O4U3
176001  175777/8SCSI; 8SCOD      % SCSI OPTICAL DISK
176001  "9M1U0+9M2U0+9M3U0+9M4U0
176001  175777/8SCSI; 8SCMT      % SCSI MAGTAPE
176001  "8SCSI
176001  % GENERATE 8VSX0 LIBRARY MARK TO GET STANDARD SYSTEM
176001  175777/8VSX0; 8STRD
176001  "
176001  "8N500-8PR01-8PR02-8PR03-8PR04-8PR05-8PR06-8PR07-8PR08-8PR09
176001  175777/8PR10                    % 10 ND-500 PROCS ARE DEFAULT
176000
176000  "8XON; 175777/8RON              % READER-ON IF X-ON
176000  "8XMSG;175777/99ENS 8ALME;"     % ENTSG AND FIXC5 (ALLOCATE MEMORY AREA) WHEN XMSG
176000
176000  "8N500;175777/8EXAD 8STRN       % ALWAYS EXTENDED ADDRESS MODE AND INSTR/OUTST WHEN ND-500
176000  "
176000
176000  "8SMO1+8SMO2+8SMO3+8SMO4+8SMO5+8SMO6+8SMO7+8SMO8+8SMO9+9SMO1+9SMO2+9SMO3+9SMO4+9SMO5+9SMO6+9SMO7
176000  175777/8MODI
176000  "
176000
176000
176000  %%%    LIBRARY MARKS TO EASY REFERENCES TO MAGTAPE-FIELDS
176000
176000  % CONVERSION FROM 'OLD' TO 'NEW' FOR CONTROLLER 1
176000  "99TM1+99HM1+99SM1; 175777/8MT1;"
176000  %CONVERSION FROM 'OLD' TO 'NEW' FOR CONTROLLER 2
176000  "99TM2+99HM2+99SM2; 175777/8MT2;"
176000  % TO ENSURE 8MT3
176000  "8CP54; 8CP53; *-1/
176000  "8CP53; 8CP52; *-1/
176000  "8N500; 8CP51; *-1/
176000
176000  "8P128;8P127; *-1/
176000  "8P127;8P126; *-1/
176000  "8P126;8P125; *-1/
176000  "8P125;8P124; *-1/
176000  "8P124;8P123; *-1/
176000  "8P123;8P122; *-1/
176000  "8P122;8P121; *-1/
176000  "8P121;8P120; *-1/
176000  "8P120;8P119; *-1/
176000  "8P119;8P118; *-1/
176000  "8P118;8P117; *-1/
176000  "8P117;8P116; *-1/
176000  "8P116;8P115; *-1/
176000  "8P115;8P114; *-1/
176000  "8P114;8P113; *-1/
176000  "8P113;8P112; *-1/
176000  "8P112;8P111; *-1/
176000  "8P111;8P110; *-1/
176000  "8P110;8P109; *-1/
176000  "8P109;8P108; *-1/
176000  "8P108;8P107; *-1/
176000  "8P107;8P106; *-1/
176000  "8P106;8P105; *-1/
176000  "8P105;8P104; *-1/
176000  "8P104;8P103; *-1/
176000  "8P103;8P102; *-1/
176000  "8P102;8P101; *-1/
176000  "8P101;8P100; *-1/
176000  "8P100;8PR99; *-1/
176000  "8PR99;8PR98; *-1/
176000  "8PR98;8PR97; *-1/
176000  "8PR97;8PR96; *-1/
176000  "8PR96;8PR95; *-1/
176000  "8PR95;8PR94; *-1/
176000  "8PR94;8PR93; *-1/
176000  "8PR93;8PR92; *-1/
176000  "8PR92;8PR91; *-1/
176000  "8PR91;8PR90; *-1/
176000  "8PR90;8PR89; *-1/
176000  "8PR89;8PR88; *-1/
176000  "8PR88;8PR87; *-1/
176000  "8PR87;8PR86; *-1/
176000  "8PR86;8PR85; *-1/
176000  "8PR85;8PR84; *-1/
176000  "8PR84;8PR83; *-1/
176000  "8PR83;8PR82; *-1/
176000  "8PR82;8PR81; *-1/
176000  "8PR81;8PR80; *-1/
176000  "8PR80;8PR79; *-1/
176000  "8PR79;8PR78; *-1/
176000  "8PR78;8PR77; *-1/
176000  "8PR77;8PR76; *-1/
176000  "8PR76;8PR75; *-1/
176000  "8PR75;8PR74; *-1/
176000  "8PR74;8PR73; *-1/
176000  "8PR73;8PR72; *-1/
176000  "8PR72;8PR71; *-1/
176000  "8PR71;8PR70; *-1/
176000  "8PR70;8PR69; *-1/
176000  "8PR69;8PR68; *-1/
176000  "8PR68;8PR67; *-1/
176000  "8PR67;8PR66; *-1/
176000  "8PR66;8PR65; *-1/
176000  "8PR65;8PR64; *-1/
176000  "8PR64;8PR63; *-1/
176000  "8PR63;8PR62; *-1/
176000  "8PR62;8PR61; *-1/
176000  "8PR61;8PR60; *-1/
176000  "8PR60;8PR59; *-1/
176000  "8PR59;8PR58; *-1/
176000  "8PR58;8PR57; *-1/
176000  "8PR57;8PR56; *-1/
176000  "8PR56;8PR55; *-1/
176000  "8PR55;8PR54; *-1/
176000  "8PR54;8PR53; *-1/
176000  "8PR53;8PR52; *-1/
176000  "8PR52;8PR51; *-1/
176000  "8PR51;8PR50; *-1/
176000  "8PR50;8PR49; *-1/
176000  "8PR49;8PR48; *-1/
176000  "8PR48;8PR47; *-1/
176000  "8PR47;8PR46; *-1/
176000  "8PR46;8PR45; *-1/
176000  "8PR45;8PR44; *-1/
176000  "8PR44;8PR43; *-1/
176000  "8PR43;8PR42; *-1/
176000  "8PR42;8PR41; *-1/
176000  "8PR41;8PR40; *-1/
176000  "8PR40;8PR39; *-1/
176000  "8PR39;8PR38; *-1/
176000  "8PR38;8PR37; *-1/
176000  "8PR37;8PR36; *-1/
176000  "8PR36;8PR35; *-1/
176000  "8PR35;8PR34; *-1/
176000  "8PR34;8PR33; *-1/
176000  "8PR33;8PR32; *-1/
176000  "8PR32;8PR31; *-1/
176000  "8PR31;8PR30; *-1/
176000  "8PR30;8PR29; *-1/
176000  "8PR29;8PR28; *-1/
176000  "8PR28;8PR27; *-1/
176000  "8PR27;8PR26; *-1/
176000  "8PR26;8PR25; *-1/
176000  "8PR25;8PR24; *-1/
176000  "8PR24;8PR23; *-1/
176000  "8PR23;8PR22; *-1/
176000  "8PR22;8PR21; *-1/
176000  "8PR21;8PR20; *-1/
176000  "8PR20;8PR19; *-1/
176000  "8PR19;8PR18; *-1/
176000  "8PR18;8PR17; *-1/
176000  "8PR17;8PR16; *-1/
176000  "8PR16;8PR15; *-1/
176000  "8PR15;8PR14; *-1/
176000  "8PR14;8PR13; *-1/
176000  "8PR13;8PR12; *-1/
176000  "8PR12;8PR11; *-1/
176000  "8PR11;8PR10; *-1/
176000  "8PR10;8PR09; *-1/
176000  "8PR09;8PR08; *-1/
176000  "8PR08;8PR07; *-1/
176000  "8PR07;8PR06; *-1/
176000  "8PR06;8PR05; *-1/
176000  "8PR05;8PR04; *-1/
176000  "8PR04;8PR03; *-1/
176000  "8PR03;8PR02; *-1/
176000  "8PR02;8PR01; *-1/
176000  "
176000
176000
176000
176000  "BAD70
176000   BADAD; *-1/
176000   BAD01 BAD02 BAD03 BAD04 BAD05 BAD06 BAD07 BAD08 BAD09 BAD10; *-1/
176000   BAD11 BAD12 BAD13 BAD14 BAD15 BAD16 BAD17 BAD18 BAD19 BAD20; *-1/
176000   BAD21 BAD22 BAD23 BAD24 BAD25 BAD26 BAD27 BAD28 BAD29 BAD30; *-1/
176000   BAD31 BAD32 BAD33 BAD34 BAD35 BAD36 BAD37 BAD38 BAD39 BAD40; *-1/
176000   BAD41 BAD42 BAD43 BAD44 BAD45 BAD46 BAD47 BAD48 BAD49 BAD50; *-1/
176000   BAD51 BAD52 BAD53 BAD54 BAD55 BAD56 BAD57 BAD58 BAD59 BAD60; *-1/
176000   BAD61 BAD62 BAD63 BAD64 BAD65 BAD66 BAD67 BAD68 BAD69; *-1/
176000
176000  "
176000
176000  "8PC04; 8PC03; *-1/          % PIOC 4 UNDEF PIOC 3
176000  "8PC03; 8PC02; *-1/          % PIOC 3 UNDEF PIOC 2
176000  "8PC02; 8PC01; *-1/          % PIOC 2 UNDEF PIOC 1
176000  "
176000  175777/
175777  "8SG50; 8SG49; *-1/
175777  "8SG49; 8SG48; *-1/
175777  "8SG48; 8SG47; *-1/
175777  "8SG47; 8SG46; *-1/
175777  "8SG46; 8SG45; *-1/
175777  "8SG45; 8SG44; *-1/
175777  "8SG44; 8SG43; *-1/
175777  "8SG43; 8SG42; *-1/
175777  "8SG42; 8SG41; *-1/
175777  "8SG41; 8SG40; *-1/
175777  "8SG40; 8SG39; *-1/
175777  "8SG39; 8SG38; *-1/
175777  "8SG38; 8SG37; *-1/
175777  "8SG37; 8SG36; *-1/
175777  "8SG36; 8SG35; *-1/
175777  "8SG35; 8SG34; *-1/
175777  "8SG34; 8SG33; *-1/
175777  "8SG33; 8SG32; *-1/
175777  "8SG32; 8SG31; *-1/
175777  "8SG31; 8SG30; *-1/
175777  "8SG30; 8SG29; *-1/
175777  "8SG29; 8SG28; *-1/
175777  "8SG28; 8SG27; *-1/
175777  "8SG27; 8SG26; *-1/
175777  "8SG26; 8SG25; *-1/
175777  "8SG25; 8SG24; *-1/
175777  "8SG24; 8SG23; *-1/
175777  "8SG23; 8SG22; *-1/
175777  "8SG22; 8SG21; *-1/
175777  "8SG21; 8SG20; *-1/
175777  "8SG20; 8SG19; *-1/
175777  "8SG19; 8SG18; *-1/
175777  "8SG18; 8SG17; *-1/
175777  "8SG17; 8SG16; *-1/
175777  "8SG16; 8SG15; *-1/
175777  "8SG15; 8SG14; *-1/
175777  "8SG14; 8SG13; *-1/
175777  "8SG13; 8SG12; *-1/
175777  "8SG12; 8SG11; *-1/
175777  "8SG11; 8SG10; *-1/
175777  "8SG10; 8SG09; *-1/
175777  "8SG09; 8SG08; *-1/
175777  "8SG08; 8SG07; *-1/
175777  "8SG07; 8SG06; *-1/
175777  "8SG06; 8SG05; *-1/
175777  "8SG05; 8SG04; *-1/
175777  "8SG04; 8SG03; *-1/
175777  "8SG03; 8SG02; *-1/
175777
175777  % -8BUFF DEFAULT IF NO BUFFER NUMBER SPECIFIED:
175777  175777/"
175777  "8BEX2; 175777/8BEX1
176000  "
176000
176000

176000  %==============================================================================
176000  % 28.1       G E N E R A T I N G   P A R A M E T E R S
176000  %
176000  % SINTRAN III SYSTEM GENERATING PARAMETERS
176000  %
176000
176000  %----PAGE DISPLACEMENT FROM BEGINNING OF SINTRAN:DATA------------
176000
176000  5FYFS=144                    % FILESYSTEM SAVE-AREA
176000  5FYRL=502                    % RT-LOADER
176000  5FYSP=534                    % SPOOLING
176000  5FCRL=32+77                  % ND-NET FILECOPY
176000  5FYER=136                    % ERROR PROGRAM
176000  5FYOP=77                     % COMMAND SEGMENT
176000
176000  %----------------------------------------------------------------
176000
176000  5NASE=517
176000
176000  FLBPA=100                    % FIRST LOGICAL PAGE IN BACKGROUND SEGMENT
176000  LOADR=200                    % LENGTH OF BACKGROUND SEGMENT
176000
176000
176000  SEMSE=1204
176000  XDASA=10
176000  MACD=153777
176000  N5ADR=100000
176000
176000  BUF=0
176000  CURRR=*
176000  "    % 30/60/90 MB DISC (DSKTYPE=40000)
176000  CURRR/; )KILL CURRR
176000
176000  LIDTE=140040-1               % IDENT CODE OF TERMINAL 65 (-1)
176000  HIDTE=140437-1               % IDENT CODE OF TERMINAL 256 (-1)
176000
176000  % DEFAULT VALUES:
176000  SPSGL;"SPSGL;SPSGL=4;"       % LENGTH OF SPOOLING QUEUE SEGMENT
176001  LBSEG;"
176002  LOADR;
176003  IDBUS;"IDBUS;IDBUS=40;"
176004  TERMC;"TERMC;TERMC=-1;"
176005  MIBU1;"MIBU1;MIBU1=2114;"
176006  MOBU1;"MOBU1;MOBU1=344;"
176007  MIBU2;"MIBU2;MIBU2=2114;"
176010  MOBU2;"MOBU2;MOBU2=344;"
176011  MIBU3;"MIBU3;MIBU3=2114;"
176012  MOBU3;"MOBU3;MOBU3=344;"
176013  MIBU4;"MIBU4;MIBU4=2114;"
176014  MOBU4;"MOBU4;MOBU4=344;"
176015  MIBU5;"MIBU5;MIBU5=2114;"
176016  MOBU5;"MOBU5;MOBU5=344;"
176017  MIBU6;"MIBU6;MIBU6=2114;"
176020  MOBU6;"MOBU6;MOBU6=344;"
176021  MIBU7;"MIBU7;MIBU7=2114
176022  MOBU7;"MOBU7;MOBU7=344
176023  MIBU8;"MIBU8;MIBU8=2114
176024  MOBU8;"MOBU8;MOBU8=344
176025  MIBU9;"MIBU9;MIBU9=2114
176026  MOBU9;"MOBU9;MOBU9=344
176027  MIB10;"MIB10;MIB10=2114
176030  MOB10;"MOB10;MOB10=344
176031  MIB11;"MIB11;MIB11=2114
176032  MOB11;"MOB11;MOB11=344
176033  MIB12;"MIB12;MIB12=2114
176034  MOB12;"MOB12;MOB12=344
176035  MIB13;"MIB13;MIB13=2114
176036  MOB13;"MOB13;MOB13=344
176037  MIB14;"MIB14;MIB14=2114
176040  MOB14;"MOB14;MOB14=344
176041  MIB15;"MIB15;MIB15=2114
176042  MOB15;"MOB15;MOB15=344
176043  MIB16;"MIB16;MIB16=2114
176044  MOB16;"MOB16;MOB16=344
176045  DR1SI;"DR1SI;DR1SI=2000;"
176046  DR2SI;"DR2SI;DR2SI=2000;"
176047  5SSSZ;"5SSSZ;5SSSZ=5;"
176050  GNSTA;"GNSTA;GNSTA=5SSSZ@12+BGSYS;"
176051
176051  "8LAMU;MXLPR; "MXLPR;MXLPR=2       % NUMBER OF LAMUS PER PROGRAM
176052  "8LAMU;MXLAM; "MXLAM;MXLAM=40      % NUMBER OF LAMUS IN THE SYSTEM
176053  "8LAMU;MXSYL; "   % NUMBER OF SYSTEM LAMUS IN THE SYSTEM
176054
176054  FLDNO; "FLDNO;FLDNO=277;"           % DEVICE NUMBER OF INTERNAL DEVICE FOR "FTX" ERROR HANDLER
176055
176055  "SLP1;SLD1; "          % SPOOLING INDEX 1 DEFAULT LOG NO 5
176056  "SLP2;SLD2; "         % SPOOLING INDEX 2 DEFAULT LOG NO 15
176057
176057  CCNO
176060  "         % 6K RTCOMMON IF 12 SIBAS PROCESSES
176060  "         % 3K RTCOMMON IF 6 SIBAS PROCESSES
176060  "         % 2K RTCO
MMON IF 3 SIBAS PROCESSES
176060  "                % ELSE 0 K RTCOMMON
176060  CCNO:000006
176060
176060  NULDN;"NULDN;NULDN=10;"       % NUMBER OF USER RESERVED LOGICAL  DEVICE NUMBERS
176061                                % LDN'S STARTS FROM 2300
176061
176061  XTIME;"XTIME;XTIME=6;"        % NUMBER OF EXTRA ENTRIES IN TIMER TABLE
176062  XID10;"XID10;XID10=12;"       % NUMBER OF EXTRA ENTRIES IN EXT. IDENT TABLE, LEVEL 10
176063  XID11;"XID11;XID11=12;"       % NUMBER OF EXTRA ENTRIES IN EXT. IDENT TABLE, LEVEL 11
176064  XID12;"XID12;XID12=12;"       % NUMBER OF EXTRA ENTRIES IN EXT. IDENT TABLE, LEVEL 12
176065  XID13;"XID13;XID13=4;"        % NUMBER OF EXTRA ENTRIES IN EXT. IDENT TABLE, LEVEL 13
176066
176066  8RTN;"            % 24 RT DESCRIPTIONS
176067  8SGN;"            % 40 SEGMENTS
176070  CADEV;"CADEV;CADEV=700;"
176071  8IOXT;"8IOXT;8IOXT=10;"
176072  NALME;"   % DEFAULT MAX # OF MEMORY BUFFER TO BE ALLOCATED
176073  "
176073
176073  XIBNX=0; YIBNY=0
176073  "-8ALOA;XALOF=0
176073  "BADAD
176073  BADM=110001
176073
176073  "
176073  EOGPA=*          % END OF GENERATION DEFAULTS
176073  )LINE
010773   @DEV (S-S-L)DP-P2-VARIABLES:NPL
010773

010773   %-----------------------------------------------------------------------------
010773   % SERVER PARAMETER ARRAY
010773   %-----------------------------------------------------------------------------
010773   @ICR;
010773   INTEGER ARRAY SERVARRAY:=(XSERV,    0,XSERV,    0,XSERV,MTSPA,DPFLG,    0,
011003                                 0,    0,    0,    0,    0,    0,    0,    0);
011013   @CR;
011013   %=============================================================================
011013   % NUCLEUS MTAD DATAFIELD
011013   %=============================================================================
011013   *MTNSP; *-1/ "MTNSP; MTNSP=10       % NUMBER OF NUCLEUS MTAD CLIENTS
"011013   INTEGER ARRAY MTNKDF(7)             % STANDARD DATAFIELD PART (USED AS NUCLEUS OWNER ID)
011022   *MTNKD/0;0;0;2;0;0;MTNUC            % MFUNC POINTS TO DRIVER ROUTINE
011022   INTEGER       MTNKPORT              % OWN NUCLEUS PORT
011023   **<*+MTNSP; )ZERO
011023   DOUBLE ARRAY MTSRE(0)               % NUCL. SEND REF. AND LAMU PAGE FOR EACH CLIENT
011023   **+MTNSP+MTNSP/
011043   INTEGER ARRAY MTSPA:=(MTNKDF,MTNKPO,MTCHK,MTSRE) % PARAMETER LIST FOR MTSERV
011047
011047   *"8BACS
"011047   % =============================================================================
011047   %       ( D )    D A T A    F O R    9 B P T M O U T
011047   %
011047   @DEC
011047   DATA(10000,1000,100,10,1); INTEGER ARRAY BCONST(0)
011054   @OCT
011054   INTEGER B1COUNT,BCINDX,B5TU1,B5TU2,BCD1TI,BCD2TI
011062   DOUBLE BD5TUSE=B5TU1,BCDTINT=BCD1TI
011062   INTEGER BVALUE,BXVALUE,BCBYTP,CCBPTERM,CBPRFLG,CBBPROC,CTTMCOUNT,CBPLOGDV
011072   DOUBLE DCCBPTERM=CCBPTERM
011072   *"
"011072
011072   % =============================================================================
011072   %       ( D )    D A T A    F O R    M O N    P E R F O R M A N C E
011072   %
011072   INTEGER ACTMPERFORM                 % ><0 when measurement is running
011073   *"8MPRF
"011073   INTEGER MPERFREQUENCY               % Sample rate
011074   INTEGER M13FREQUENCY                % Counter on level 13
011075   INTEGER M2FREQUENCY                 % Counter on level 2, monitor level
011076   INTEGER BUFREQUIREMENTS             % Buffer required for paramter block
011077   INTEGER XBUFREQUIREMENTS            % Additional buffers for spesific option codes
011100   INTEGER MBUFINDEX:=-1               % "allocate-area" index of paramter-blocks buffer
011101   INTEGER BUFPAGE                     % First phys. page of of paramter-blocks buffer
011102   INTEGER MBUFXINDEX:=-1              % "allocate-area" index of extra parameter block buffer
011103   INTEGER XBUFPAGE                    % First phys. page of extra parameter block buffer
011104   INTEGER XBUBANK                     % Memory bank of extra parameter block buffer
011105   INTEGER NPRIACTIVE                  % Number of active primitives
011106   DOUBLE  DBUPHYSADDR                 % Physical memory addr of start of "xbuffer"
011110   INTEGER MPHMESS                     % Physical addr of nd-500 histogram mail box within
011111                                       % Memory bank 5mbbank.
011111   INTEGER M344BSTATE                  % Saved bstate for background progr. using mon perf.
011112   INTEGER M344FLAGB                   % Saved flagb for background progr. using mon perf.
011113   INTEGER ARRAY DFMPE:=(0,0,DFMPE,0)
011117   * *+40/
011157
011157   *"8N500
"011157
011157   % =============================================================================
011157   %       ( D )    D A T A    F O R    5 M T R A N S
011157   %
011157   *"8N500 8MTRA
"011157   INTEGER XC5CP                       % Address of 500 CPU datafield
011160   INTEGER CMSGA                       % Address of current 500 message
011161   INTEGER DDFAD                       % Address of disk datafield
011162   INTEGER NWAIT                       % Nowait mode
011163   INTEGER 5MFNC                       % 5MTRANS function
011164   INTEGER DISID                       % Disk ID
011165   INTEGER CUREL                       % Current queue element
011166   DOUBLE  NWFUN=NWAIT
011166
011166   INTEGER READY                       % Head of ready queue elements
011167   DOUBLE  5MWQU                       % Message queue waiting for disk access queue elements
011171   INTEGER 5DSKC                       % Disk type code: SMD,SCSI-100=0 / DOMINO=1
011172
011172   INTEGER CNBANK                      % Bank no for table of files opend for direct transfer
011173   INTEGER CNSTART                     % Start address within bank
011174   INTEGER CNEND                       % End of table of file opened for direct transfer
011175
011175   *"8N500
"011175
011175   %===============================================================================
011175   %       ( D )    R O U T I N E    V E C T O R
011175   %  Used by the routine CALLROUT to call a routine on aonother pit
011175   @ICR;
011175   INTEGER ARRAY GOVECTOR:=(
011175            NMPIT,XKICK500,
011177            NMPIT,XTER500,
011201            NMPIT,XACT500,
011203            NMPIT,XACTRDY,
011205            NMPIT,XRSTARTALL,
011207            NRPIT,XIBMOVE,
011211            NRPIT,XCLEAN,
011213            NRPIT,XMSINIT,
011215            NRPIT,X5ERACTIVATE,
011217            NRPIT,X5PRACTIVATE,
011221            NRPIT,X5XGBUFF,
011223            NRPIT,X5GBUFF,
011225            NRPIT,XX5CONOMD);
011227
011227   INTEGER ARRAY RETVECTOR:=(0,0,0,0,0,R5PIT,0,0,RRPIT,0,RMPIT,0,0,0,0,0);
011247   @CR;
011247
011247   %===============================================================================
011247   %       ( D )    N E W   S Y S T E M   V A R I A B L E S
011247   %
011247
011247   INTEGER N5CPU                      % Number of CPUs alive
011250   INTEGER NSAMSON                    % Number of Samson CPUs
011251   INTEGER 5FPFUDMA                   % First page of fast udma capability tables
011252   INTEGER 5FPACCPBUF                 % First page of accp buffers
011253   INTEGER 5FPHWBUF                   % First page of transmission buffers
011254   INTEGER 5SWPROC                    % Swapper process number
011255   INTEGER 5SSEGSIZE                  % Size of Swapper's Segment Table Entry
011256   INTEGER BMMSIZE                    % Size of Swapper's Memory Map Element in bytes
011257   INTEGER DUMMESS                    % Address of dummy msg
011260   INTEGER N5MESSAGE                  % Current message handled on driver level
011261   DOUBLE  IMBDTDFPHPAGE              % Used by RIBMOVE
011263   INTEGER IBMLREG                    % Return address
011264
011264   INTEGER ARRAY 5SWESTATUS(12)       % ABSTR parameters when last error occured
011276   INTEGER ARRAY 5SWEMESSAGE(55MESSIZE)% Saved message of process being served when
011476                                      % 5SWAP gets error return from ABSTR
011476
011476   % FILE-TRANSFER:
011476   INTEGER 5FP5FTRANS                 % Phys page addr of dev.buf headers
011477   INTEGER 5NP5FTRANS                 % No. of pages for dev.buf headers
011500   INTEGER 5DVBSTART:=162000          % Log.addr of start of dev.buf headers
011501   INTEGER 5DVBEND:=163777-DBLEN
011502   INTEGER 5DVBWAIT(0); *0;0;*-2;2    % Wait-for-dev-buf-header lock
011506   INTEGER 5DVBFREE                   % Dev-buf-header free liste
011507
011507   %============================================================================
011507   %       ( D )    X S E M S
011507   %
011507   % POINTER TO ND-500 LOCKS
011507   @ICR;
011507   INTEGER ARRAY XSEMS:=(5NAMSEM,CSSEM,PLSSEM,FIXSEM,CSSEM,PLSSEM,SYDSEG,SWORKA,WEMSEM,WEMSEM,
011521                         CPU51,CPU52,CPU53,CPU54,CPU55,CPU56,CPU57,CPU58);
011531   @CR;
011531
011531   % NEW ND-500 SEMAPHORES
011531   INTEGER WEMSE:=(0,0,WEMSE,2)  % GENERAL LOCK
011535
011535   %==============================================================================
011535   %     ( D )
011535   % Datafield used in connection with reveiving octobus error messeages
011535   DATA          (5OMBR,5OMBR)
011537   INTEGER LMDF:=(0,0,LMDF,0,0,0)
011545
011545   % Field to hold octobus error message
011545   INTEGER ARRAY LMFIELD(40)
011605
011605   %============================================================================
011605   %       ( D )    Addtional datafields for each nd5000 cpu
011605   %
011605   *"8CP51
"011605   INTEGER CPU51:=(0,0,CPU51,2,0,0,0)
011614   *"8CP52
"011614   INTEGER CPU52:=(0,0,CPU52,2,0,0,0)
011623   *"8CP53
"011623   INTEGER CPU53:=(0,0,CPU53,2,0,0,0)
011632   *"8CP54
"011632   INTEGER CPU54:=(0,0,CPU54,2,0,0,0)
011641   *"8CP55
"011641
011641   % Patch tables:  (each table has 5 free elements for patching)
011641   %
011641
011641   @ICR;
011641   INTEGER ARRAY NNTAB:=(
011641   %           mudom        -mudom
011641   %     pit  instr  table instr  table
011641          MPIT,124001,MNATAB,124001,MNJTAB,
011646          MPIT,124002,MNTTAB,124003,MNCTAB,
011653          RPIT,124002,RNTTAB,124003,RNCTAB,
011660          5PIT,124002,5NTTAB,124003,5NCTAB);
011665
011665   INTEGER ENNTAB(0);
011665
011665   % - Common & Mpit: branch table
011665   INTEGER ARRAY MNATAB:=(-1);
011666
011666   % - Common & Mpit: branch table
011666   INTEGER ARRAY MNJTAB:=(
011666          NNJ00,NNJ01,NNJ02,NNJ03,NNJ04,NNJ05,NNJ06,NNJ07,NNJ08,NNJ09,NNJ10,
011701          NNJ11,NNJ12,NNJ13,NNJ14,
011705          0,0,0,0,0,-1);
011713
011713   % - Common & Mpit: terminate-500 table
011713   INTEGER ARRAY MNTTAB:=(
011713          NNT01,NNT02,NNT03,NNT04,NNT05,NNT06,NNT07,NNT08,NNT09,NNT10,
011725          NNT11,NNT12,NNT13,NNT14,NNT15,NNT16,NNT17,
011734          NNT50,NNT51,NNT52,                            % Perf moncall
011737          0,0,0,0,0,-1);
011745
011745   % - Rpit: terminate-500 table
011745   INTEGER ARRAY RNTTAB:=(
011745          NNT30,NNT31,NNT32,NNT33,NNT34,NNT35,NNT36,NNT37,
011755          0,0,0,0,0,-1);
011763
011763   % - 5pit: terminate-500 table
011763   INTEGER ARRAY 5NTTAB:=(
011763          NNT40,NNT41,
011765          0,0,0,0,0,-1);
011773
011773   % - Common & Mpit: convert-address table
011773   INTEGER ARRAY MNCTAB:=(
011773          NNC01,NNC02,NNC03,NNC04,NNC05,NNC06,NNC07,NNC08,NNC09,NNC10,
012005          NNC11,NNC12,NNC13,NNC14,NNC15,NNC16,NNC17,NNC18,NNC19,NNC20,
012017          NNC21,NNC22,NNC23,NNC24,NNC25,NNC26,NNC27,
012026          NNC50,NNC51,NNC52,NNC53,NNC54,NNC55,          % Perf moncall
012034          0,0,0,0,0,-1);
012042
012042   % - Rpit: convert-address table
012042   INTEGER ARRAY RNCTAB:=(
012042          NNC30,NNC31,NNC32,NNC33,NNC34,NNC35,NNC36,NNC37,NNC38,NNC39,
012054          0,0,0,0,0,-1);
012062
012062   % - 5pit: convert-address table
012062   INTEGER 5NCTAB:=(
012062          NNC40,
012063          0,0,0,0,0,-1);
012071   @CR;
012071   @DEV 1
012071   @EOF
012071
%%%%%%%%%%%%   M A C R O E S  -  R T D E S  -  G E N  %%%%%%%%%%%%%%%%%%%%%
012071
012071  % MACRO FOR BACKGROUND PROGRAMS
012071
012071  )MCDEF BBP $NAM
$NAM ,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
       0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
       0;0;0;0;0
]
012071
012071  )MCDEF ACRTP
       NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
]
012071
012071  "8F5UD
012071  % MACRO  UDMA RT-PROG   (FAST UDMA FROM ND-500)
012071  )MCDEF GUDRT $NO
UDR$NO , 0;1002;100;100;0;0;0;0;URT$NO ;0;0
       0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;UDR$NO  %
       0;0;0;0;0
)FILL
]
012071  "
012071  )LINE
%==============================================================================
012071  % 29.5       R T - D E S C R I P T I O N  T A B L E
012071  %
012071  % RT-PROGRAMS
012071
012071  NXRTP=0
012071  DUMMY, 0;2;0;0;0;0;0;0;DMSTR;0;0
012104         BEXQU-5BWLI;0;0;NRPIT+ADPIT+ERNG2+ALEVB;NRPIT+ADPIT+ERNG2+ALEVB;DUMMY
012112         0;0;0;0;0
012117
012117  ACRTP

012117         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012117  STSIN, 0;2;377;377;0;0;0;0;START;27;5 %START PROGRAM
012132         DUMMY;27;5;NSPIT+ADPIT+ERNG2+ALEVB;NSPIT+ADPIT+ERNG2+ALEVB;STSIN
012140         0;0;0;0;0
012145
012145  ACRTP

012145         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012145  RTERR, 0;3;100;100;0;0;0;0;SRTER;14;5
012160         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;RTERR
012166         0;0;0;0;0
012173
012173  ACRTP

012173         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012173
012173  1SWAP, 0;2;277;277;0;0;0;0;SSSWP;0;0
012206         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;NRPIT+ADPIT+ERNG2+ALEVB;1SWAP
012214         0;0;0;0;0
012221
012221  ACRTP

012221         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012221
012221  TIMRT, 0;2;200;200;0;0;0;62;TIMER;0;0
012234         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;TIMRT
012242         0;0;0;0;0
012247  ACRTP

012247         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012247
012247
012247  "8DILG
012247  RTDIL, 0;2;300;300;0;0;0;0;DILRT;0;0
012262         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;RTDIL
012270         0;0;0;0;0
012275  ACRTP

012275         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012275
012275
012275  "8DIMI
012275  DIMWD, 0;2;100;100;0;0;0;0;4000;73;0
012310         0;0;0;NUPIN+ADPIT+ERNG2+ALEVB;0;DMWDP
012316         0;0;0;0;0
012323  ACRTP

012323         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012323
012323
012323  "8BACS
012323  BPTMP, 0;2;77;77;0;0;0;0;9BPTM;0;0
012336         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;BPTMP
012344         0;0;0;0;0
012351  ACRTP

012351         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012351  "
012351
012351  RTSLI, 0;2;200;200;0;0;0;0;STSLI;0;0
012364         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;RTSLI
012372         0;0;0;0;0
012377
012377  ACRTP

012377         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012377
012377  ACCRT, 0;2;100;100;0;0;0;0;RTACR;0;5
012412         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;ACCRT
012420         0;0;0;0;0
012425  ACRTP

012425         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012425
012425  TERMP, 0;2;200;200;0;0;0;0;STERM;0;0
012440         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;NRPIT+ADPIT+ERNG2+ALEVB;TERMP
012446         0;0;0;0;0
012453  ACRTP

012453         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012453  "8N500
012453  5SWAP, 0;2;100;100;0;0;0;0;5SWRT;0;0          % ND-500 SWAPPER
012466         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;5SWAP
012474         0;0;0;0;0
012501
012501  ACRTP

012501         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012501
012501  "
012501
012501  RWRT1, 0;2;100;100;0;0;0;0;COMMO;0;5
012514         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT1
012522         0;0;0;0;0
012527
012527  ACRTP

012527         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012527  RWRT2, 0;2;100;100;0;0;0;0;COMMO;0;5
012542         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT2
012550         0;0;0;0;0
012555
012555  ACRTP

012555         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012555  "8MT1
012555  RWRT3, 0;2;100;100;0;0;0;0;COMMO;0;5
012570         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT3
012576         0;0;0;0;0
012603
012603  ACRTP

012603         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012603  "8DMVC
012603  RWRT5, 0;2;100;100;0;0;0;0;COMMO;0;5
012616         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT5
012624         0;0;0;0;0
012631
012631  ACRTP

012631         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012631  "8MT2
012631  RWRT7, 0;2;100;100;0;0;0;0;COMMO;0;5
012644         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT7
012652         0;0;0;0;0
012657
012657  ACRTP

012657         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012657  "8DMV2
012657  RWRT8, 0;2;100;100;0;0;0;0;COMMO;0;5
012672         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT8
012700         0;0;0;0;0
012705
012705  ACRTP

012705         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012705
012705
012705  "8FDI1+8BFD1
012705  RWRT9, 0;2;100;100;0;0;0;0;COMMO;0;5
012720         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWRT9
012726         0;0;0;0;0
012733  ACRTP

012733         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012733  "8RFAC
012733  RTRFA, 0;2;100;100;0;0;0;0;SRRT1;0;5
012746         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RTRFA
012754         0;0;0;0;0
012761  ACRTP

012761         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
012761  % ***********
012761  "SLP1+SLP2+CSP12+SLP3+SLP4+SLP5+SLP6+SLP7+SLP8+SLP9+SLP10+SLP11+SLP12+SLP13+SLP14+SLP15+8COSP+SLP16+SLP17+CSP18+SLP19+SLP20
012761  DUMM2, 0;2;000;000;0;0;0;0;1;0;0
012774         0;0;0;0;0;DUMM2
013002         0;0;0;0;0
013007  ACRTP

013007         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013007  "SLP1
013007  SPRT1, 0;2;054;054;0;0;0;0;SPORT;SPSG1;0
013022         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT1
013030         0;0;0;0;0
013035  ACRTP

013035         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013035  "SLP2
013035  SPRT2, 0;2;054;054;0;0;0;0;SPORT;SPSG2;0
013050         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT2
013056         0;0;0;0;0
013063  ACRTP

013063         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013063  "SLP3
013063  SPRT3, 0;2;054;054;0;0;0;0;SPORT;SPSG3;0
013076         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT3
013104         0;0;0;0;0
013111  ACRTP

013111         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013111  "SLP4
013111  SPRT4, 0;2;054;054;0;0;0;0;SPORT;SPSG4;0
013124         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT4
013132         0;0;0;0;0
013137  ACRTP

013137         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013137  "SLP5
013137  SPRT5, 0;2;054;054;0;0;0;0;SPORT;SPSG5;0
013152         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT5
013160         0;0;0;0;0
013165  ACRTP

013165         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013165  "SLP6
013165  SPRT6, 0;2;054;054;0;0;0;0;SPORT;SPSG6;0
013200         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT6
013206         0;0;0;0;0
013213  ACRTP

013213         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013213  "SLP7
013213  SPRT7, 0;2;054;054;0;0;0;0;SPORT;SPSG7;0
013226         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT7
013234         0;0;0;0;0
013241  ACRTP

013241         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013241  "SLP8
013241  SPRT8, 0;2;054;054;0;0;0;0;SPORT;SPSG8;0
013254         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT8
013262         0;0;0;0;0
013267  ACRTP

013267         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013267  "SLP9
013267  SPRT9, 0;2;054;054;0;0;0;0;SPORT;SPSG9;0
013302         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPRT9
013310         0;0;0;0;0
013315  ACRTP

013315         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013315  "SLP10
013315  SPR10, 0;2;054;054;0;0;0;0;SPORT;SPS10;0
013330         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR10
013336         0;0;0;0;0
013343  ACRTP

013343         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013343  "SLP11
013343  SPR11, 0;2;054;054;0;0;0;0;SPORT;SPS11;0
013356         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR11
013364         0;0;0;0;0
013371  ACRTP

013371         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013371  "SLP12
013371  SPR12, 0;2;054;054;0;0;0;0;SPORT;SPS12;0
013404         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR12
013412         0;0;0;0;0
013417  ACRTP

013417         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013417  "SLP13
013417  SPR13, 0;2;054;054;0;0;0;0;SPORT;SPS13;0
013432         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR13
013440         0;0;0;0;0
013445  ACRTP

013445         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013445  "SLP14
013445  SPR14, 0;2;054;054;0;0;0;0;SPORT;SPS14;0
013460         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR14
013466         0;0;0;0;0
013473  ACRTP

013473         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013473  "SLP15
013473  SPR15, 0;2;054;054;0;0;0;0;SPORT;SPS15;0
013506         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR15
013514         0;0;0;0;0
013521  ACRTP

013521         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013521  "SLP16
013521  SPR16, 0;2;054;054;0;0;0;0;SPORT;SPS16;0
013534         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR16
013542         0;0;0;0;0
013547  ACRTP

013547         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013547  "SLP17
013547  SPR17, 0;2;054;054;0;0;0;0;SPORT;SPS17;0
013562         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR17
013570         0;0;0;0;0
013575  ACRTP

013575         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013575  "SLP18
013575  SPR18, 0;2;054;054;0;0;0;0;SPORT;SPS18;0
013610         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR18
013616         0;0;0;0;0
013623  ACRTP

013623         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013623  "SLP19
013623  SPR19, 0;2;054;054;0;0;0;0;SPORT;SPS19;0
013636         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR19
013644         0;0;0;0;0
013651  ACRTP

013651         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013651  "SLP20
013651  SPR20, 0;2;054;054;0;0;0;0;SPORT;SPS20;0
013664         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR20
013672         0;0;0;0;0
013677  ACRTP

013677         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013677  "SLP21
013677  SPR21, 0;2;054;054;0;0;0;0;SPORT;SPS21;0
013712         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR21
013720         0;0;0;0;0
013725  ACRTP

013725         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013725  "SLP22
013725  SPR22, 0;2;054;054;0;0;0;0;SPORT;SPS22;0
013740         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;NFPIT+ADPIT+ERNG2+ALEVB;SPR22
013746         0;0;0;0;0
013753  ACRTP

013753         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
013753  "
013753  "8COSP
013753  COSPO, 0;1002;054;054;0;0;0;0;COSPS;0;0
013766         0;0;0;NMPIT+ADPIT+ERNG2+ALEVB;NUPIN+AUPIN+ERNG2+ALEVB;COSPO
013774         0;0;0;0;0
014001  ACRTP

014001         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014001  "
014001  % ***********
014001
014001
014001  "8FDI2+8BFD2
014001  RWR10, 0;2;100;100;0;0;0;0;COMMO;0;5
014014         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR10
014022         0;0;0;0;0
014027  ACRTP

014027         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014027  "8DLP1+8DVE1+8NLP1
014027  RWR11, 0;2;100;100;0;0;0;0;COMMO;0;5
014042         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR11
014050         0;0;0;0;0
014055  ACRTP

014055         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014055
014055  "8DLP2+8DVE2+8NLP2
014055  RWR12, 0;2;100;100;0;0;0;0;COMMO;0;5
014070         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR12
014076         0;0;0;0;0
014103  ACRTP

014103         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014103
014103  "IBL01
014103  RWR13, 0;2;100;100;0;0;0;0;COMMO;0;5
014116         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR13
014124         0;0;0;0;0
014131  ACRTP

014131         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014131
014131  RWR20, 0;2;100;100;0;0;0;0;COMMO;0;5
014144         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR20
014152         0;0;0;0;0
014157  ACRTP

014157         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014157
014157  "IBL02
014157  RWR14, 0;2;100;100;0;0;0;0;COMMO;0;5
014172         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR14
014200         0;0;0;0;0
014205  ACRTP

014205         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014205
014205  RWR21, 0;2;100;100;0;0;0;0;COMMO;0;5
014220         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR21
014226         0;0;0;0;0
014233  ACRTP

014233         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014233
014233  "8HDM1
014233  RWR25, 0;2;100;100;0;0;0;0;COMMO;0;5
014246         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR25
014254         0;0;0;0;0
014261  ACRTP

014261         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014261
014261  RWR26, 0;2;100;100;0;0;0;0;COMMO;0;5
014274         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR26
014302         0;0;0;0;0
014307  ACRTP

014307         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014307
014307  "7S1U0
014307  RWR41, 0;2;100;100;0;0;0;0;COMMO;0;5
014322         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR41
014330         0;0;0;0;0
014335  ACRTP

014335         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014335
014335  "7S1U0
014335  RWR42, 0;2;100;100;0;0;0;0;COMMO;0;5
014350         0;0;0;NFPIT+ADPIT+ERNG2+ALEVB;0;RWR42
014356         0;0;0;0;0
014363  ACRTP

014363         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014363
014363  "BADAD
014363  % TAD ADMINISTRATOR RT-DESCRIPTION
014363  TADAD, 0;2;040;040;0;0;0;0;110000;5BADM;0
014376         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;NSPIT+ADPIT+ERNG2+ALEVB;TADAD
014404         0;0;0;0;0
014411  ACRTP

014411         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014411
014411
014411  "
014411  "8F5UD;                               % RT-PROG FOR FAST UDMA FROM ND-500
014411  9FPUD=*
014411  "8UD01+8VI01 8F5UD;GUDRT 01

014411  UDR01, 0;1002;100;100;0;0;0;0;URT01;0;0
014424         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;UDR01 %
014432         0;0;0;0;0
014437  )FILL
014437
014437  ACRTP

014437         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014437  "8UD02+8VI02 8F5UD;GUDRT 02

014437  UDR02, 0;1002;100;100;0;0;0;0;URT02;0;0
014452         0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;UDR02 %
014460         0;0;0;0;0
014465  )FILL
014465
014465  ACRTP

014465         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014465  "8F5UD
014465  9LPUD=*
014465  "
014465  XROUT,0;2;100;100;0;0;0;0;0;5XROS;5XMKS
014500        0;0;0;NUPIA+AUPIA+ERNG2+ALEVB;0;XROUT
014506        0;0;0;0;0
014513  ACRTP

014513         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014513  XTRAC,0;2;100;100;0;0;0;0;2;5XROS;5XMKS
014526        0;0;0;NUPIA+AUPIA+ERNG2+ALEVB;0;XTRAC
014534        0;0;0;0;0
014541  ACRTP

014541         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014541  XMFID,0;2;36;36;0;0;0;0;0;5XMFI;0
014554        0;0;0;NUPIN+AUPIN+4+ALEVB;0;XMFID
014562        0;0;0;0;0
014567  ACRTP

014567         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014567
014567  NKSER,0;2;36;36;0;0;0;0;SPSRS;5NKSE;0
014602        0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;0
014610        0;0;0;0;0
014615  ACRTP

014615         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014615
014615  NKNAM,0;2;36;36;0;0;0;0;20;5NKNA;0
014630        0;0;0;NUPIN+AUPIN+ERNG1+ALEVB;0;0
014636        0;0;0;0;0
014643  ACRTP

014643         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014643
014643  ERSWD,0;2;36;36;0;0;0;0;0;5WDCS;5WDDS
014656        0;0;0;NUPIN+AUPIA+ERNG2+ALEVB;0;ERSWD
014664        0;0;0;0;0
014671  ACRTP

014671         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014671
014671  PROMA,0;2;36;36;0;0;0;0;SPSRS;5PROM;0
014704        0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;0
014712        0;0;0;0;0
014717  ACRTP

014717         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014717
014717  EVMES,0;2;36;36;0;0;0;0;SPSRS;5EVME;0
014732        0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;0
014740        0;0;0;0;0
014745  ACRTP

014745         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014745
014745  BOPCO,0;2;36;36;0;0;0;0;SPSRS;5BOPC;0
014760        0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;0
014766        0;0;0;0;0
014773  ACRTP

014773         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
014773
014773  MTSER,0;2;36;36;0;0;0;0;SPSRS;5MTSE;0
015006        0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;0
015014        0;0;0;0;0
015021  ACRTP

015021         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
015021
015021  "8BDIO
015021  RTREC,0;2;36;36;0;0;0;0;RECST;0;5
015034        0;0;0;NRPIT+ADPIT+ERNG2+ALEVB;0;0
015042        0;0;0;0;0
015047  ACRTP

015047         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
015047  "
015047
015047  NZRTP=NXRTP  % NUMBER OR SYSTEM RT-PROGRAMS BEFORE USER RT-PROGRAMS (ACCOUNTING).
015047  % USER RT-PROGRAMS
015047
015047  RTBES=*
015047  8RT2=8RTN@2+8RTN@1+8RTN@1               % (8RTN*26B)
015047  *+8RT2/
024637  %

024637  9FBPR=*          % FIRST BACKGROUND PROGRAM
024637  %----------------------------------------------------------------------
024637  %       B A C K G R O U N D   P R O G R A M S
024637  BBP BAK01

024637
024637  BAK01,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
024652         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
024660         0;0;0;0;0
024665
024665  ACRTP

024665         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
024665  "8BP2
024665  BBP BAK02

024665
024665  BAK02,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
024700         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
024706         0;0;0;0;0
024713
024713  ACRTP

024713         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
024713  "8BP3
024713  BBP BAK03

024713
024713  BAK03,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
024726         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
024734         0;0;0;0;0
024741
024741  ACRTP

024741         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
024741  "8BP4
024741  BBP BAK04

024741
024741  BAK04,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
024754         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
024762         0;0;0;0;0
024767
024767  ACRTP

024767         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
024767  "8BP5 -9SMO1
024767  BBP BAK05

024767
024767  BAK05,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025002         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025010         0;0;0;0;0
025015
025015  ACRTP

025015         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025015  "8BP6
025015  BBP BAK06

025015
025015  BAK06,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025030         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025036         0;0;0;0;0
025043
025043  ACRTP

025043         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025043  "8BP7
025043  BBP BAK07

025043
025043  BAK07,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025056         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025064         0;0;0;0;0
025071
025071  ACRTP

025071         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025071  "8BP8
025071  BBP BAK08

025071
025071  BAK08,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025104         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025112         0;0;0;0;0
025117
025117  ACRTP

025117         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025117  "8BP9 -9SMO2
025117  BBP BAK09

025117
025117  BAK09,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025132         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025140         0;0;0;0;0
025145
025145  ACRTP

025145         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025145  "8BP10
025145  BBP BAK10

025145
025145  BAK10,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025160         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025166         0;0;0;0;0
025173
025173  ACRTP

025173         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025173  "8BP11
025173  BBP BAK11

025173
025173  BAK11,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025206         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025214         0;0;0;0;0
025221
025221  ACRTP

025221         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025221  "8BP12
025221  BBP BAK12

025221
025221  BAK12,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025234         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025242         0;0;0;0;0
025247
025247  ACRTP

025247         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025247  "8BP13 -9SMO3
025247  BBP BAK13

025247
025247  BAK13,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025262         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025270         0;0;0;0;0
025275
025275  ACRTP

025275         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025275  "8BP14
025275  BBP BAK14

025275
025275  BAK14,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025310         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025316         0;0;0;0;0
025323
025323  ACRTP

025323         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025323  "8BP15
025323  BBP BAK15

025323
025323  BAK15,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025336         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025344         0;0;0;0;0
025351
025351  ACRTP

025351         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025351  "8BP16
025351  BBP BAK16

025351
025351  BAK16,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025364         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025372         0;0;0;0;0
025377
025377  ACRTP

025377         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025377  "8BP17 -9SMO4
025377  BBP BAK17

025377
025377  BAK17,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025412         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025420         0;0;0;0;0
025425
025425  ACRTP

025425         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025425  "8BP18
025425  BBP BAK18

025425
025425  BAK18,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025440         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025446         0;0;0;0;0
025453
025453  ACRTP

025453         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025453  "8BP19
025453  BBP BAK19

025453
025453  BAK19,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025466         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025474         0;0;0;0;0
025501
025501  ACRTP

025501         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025501  "8BP20
025501  BBP BAK20

025501
025501  BAK20,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025514         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025522         0;0;0;0;0
025527
025527  ACRTP

025527         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025527  "8BP21 -9SMO5
025527  BBP BAK21

025527
025527  BAK21,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025542         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025550         0;0;0;0;0
025555
025555  ACRTP

025555         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025555  "8BP22
025555  BBP BAK22

025555
025555  BAK22,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025570         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025576         0;0;0;0;0
025603
025603  ACRTP

025603         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025603  "8BP23
025603  BBP BAK23

025603
025603  BAK23,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025616         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025624         0;0;0;0;0
025631
025631  ACRTP

025631         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025631  "8BP24
025631  BBP BAK24

025631
025631  BAK24,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025644         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025652         0;0;0;0;0
025657
025657  ACRTP

025657         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025657  "8BP25 -8SMO9
025657  BBP BAK25

025657
025657  BAK25,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025672         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025700         0;0;0;0;0
025705
025705  ACRTP

025705         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025705  "8BP26
025705  BBP BAK26

025705
025705  BAK26,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025720         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025726         0;0;0;0;0
025733
025733  ACRTP

025733         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025733  "8BP27
025733  BBP BAK27

025733
025733  BAK27,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025746         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
025754         0;0;0;0;0
025761
025761  ACRTP

025761         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
025761  "8BP28
025761  BBP BAK28

025761
025761  BAK28,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
025774         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026002         0;0;0;0;0
026007
026007  ACRTP

026007         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026007  "8BP29 -9SMO6
026007  BBP BAK29

026007
026007  BAK29,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026022         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026030         0;0;0;0;0
026035
026035  ACRTP

026035         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026035  "8BP30 -9SMO7
026035  BBP BAK30

026035
026035  BAK30,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026050         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026056         0;0;0;0;0
026063
026063  ACRTP

026063         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026063  "8BP31
026063  BBP BAK31

026063
026063  BAK31,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026076         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026104         0;0;0;0;0
026111
026111  ACRTP

026111         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026111  "8BP32
026111  BBP BAK32

026111
026111  BAK32,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026124         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026132         0;0;0;0;0
026137
026137  ACRTP

026137         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026137  "8BP33
026137  BBP BAK33

026137
026137  BAK33,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026152         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026160         0;0;0;0;0
026165
026165  ACRTP

026165         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026165  "8BP34
026165  BBP BAK34

026165
026165  BAK34,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026200         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026206         0;0;0;0;0
026213
026213  ACRTP

026213         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026213  "8BP35 -8SMO7;BBP BAK35

026213
026213  BAK35,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026226         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026234         0;0;0;0;0
026241
026241  ACRTP

026241         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026241  "8BP36 -8SMO8;BBP BAK36

026241
026241  BAK36,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026254         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026262         0;0;0;0;0
026267
026267  ACRTP

026267         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026267  "8BP37 -8SMO9;BBP BAK37

026267
026267  BAK37,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026302         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026310         0;0;0;0;0
026315
026315  ACRTP

026315         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026315  "8BP38 -9SMO1;BBP BAK38

026315
026315  BAK38,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026330         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026336         0;0;0;0;0
026343
026343  ACRTP

026343         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026343  "8BP39 -9SMO2;BBP BAK39

026343
026343  BAK39,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026356         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026364         0;0;0;0;0
026371
026371  ACRTP

026371         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026371  "8BP40 -9SMO3;BBP BAK40

026371
026371  BAK40,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026404         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026412         0;0;0;0;0
026417
026417  ACRTP

026417         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026417  "8BP41 -9SMO4;BBP BAK41

026417
026417  BAK41,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026432         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026440         0;0;0;0;0
026445
026445  ACRTP

026445         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026445  "8BP42 -9SMO5;BBP BAK42

026445
026445  BAK42,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026460         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026466         0;0;0;0;0
026473
026473  ACRTP

026473         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026473  "8BP43 -9SMO6;BBP BAK43

026473
026473  BAK43,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026506         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026514         0;0;0;0;0
026521
026521  ACRTP

026521         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026521  "8BP44 -9SMO7;BBP BAK44

026521
026521  BAK44,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026534         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026542         0;0;0;0;0
026547
026547  ACRTP

026547         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026547  "8BP45;BBP BAK45

026547
026547  BAK45,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026562         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026570         0;0;0;0;0
026575
026575  ACRTP

026575         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026575  "8BP46;BBP BAK46

026575
026575  BAK46,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026610         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026616         0;0;0;0;0
026623
026623  ACRTP

026623         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026623  "8BP47;BBP BAK47

026623
026623  BAK47,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026636         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026644         0;0;0;0;0
026651
026651  ACRTP

026651         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026651  "8BP48;BBP BAK48

026651
026651  BAK48,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026664         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026672         0;0;0;0;0
026677
026677  ACRTP

026677         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026677  "8BP49;BBP BAK49

026677
026677  BAK49,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026712         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026720         0;0;0;0;0
026725
026725  ACRTP

026725         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026725  "8BP50;BBP BAK50

026725
026725  BAK50,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026740         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026746         0;0;0;0;0
026753
026753  ACRTP

026753         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
026753  "8BP51;BBP BAK51

026753
026753  BAK51,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
026766         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
026774         0;0;0;0;0
027001
027001  ACRTP

027001         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027001  "8BP52;BBP BAK52

027001
027001  BAK52,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027014         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027022         0;0;0;0;0
027027
027027  ACRTP

027027         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027027  "8BP53 8BACS ;BBP BAK53

027027
027027  BAK53,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027042         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027050         0;0;0;0;0
027055
027055  ACRTP

027055         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027055  "8BP54 8BACS;BBP BAK54

027055
027055  BAK54,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027070         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027076         0;0;0;0;0
027103
027103  ACRTP

027103         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027103  "8BP55 8BACS;BBP BAK55

027103
027103  BAK55,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027116         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027124         0;0;0;0;0
027131
027131  ACRTP

027131         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027131  "8BP56 8BACS;BBP BAK56

027131
027131  BAK56,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027144         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027152         0;0;0;0;0
027157
027157  ACRTP

027157         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027157  "8BP57 8BACS;BBP BAK57

027157
027157  BAK57,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027172         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027200         0;0;0;0;0
027205
027205  ACRTP

027205         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027205  "8BP58 8BACS;BBP BAK58

027205
027205  BAK58,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027220         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027226         0;0;0;0;0
027233
027233  ACRTP

027233         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027233  "8BP59 8BACS;BBP BAK59

027233
027233  BAK59,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027246         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027254         0;0;0;0;0
027261
027261  ACRTP

027261         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027261  "8BP60 8BACS;BBP BAK60

027261
027261  BAK60,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027274         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027302         0;0;0;0;0
027307
027307  ACRTP

027307         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027307  "8BP61 8BACS;BBP BAK61

027307
027307  BAK61,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027322         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027330         0;0;0;0;0
027335
027335  ACRTP

027335         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027335  "8BP62 8BACS;BBP BAK62

027335
027335  BAK62,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027350         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027356         0;0;0;0;0
027363
027363  ACRTP

027363         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027363  "8BP63 8BACS;BBP BAK63

027363
027363  BAK63,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027376         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027404         0;0;0;0;0
027411
027411  ACRTP

027411         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027411  "8BP64 8BACS;BBP BAK64

027411
027411  BAK64,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027424         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027432         0;0;0;0;0
027437
027437  ACRTP

027437         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027437  "8BP65;BBP BAK65

027437
027437  BAK65,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027452         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027460         0;0;0;0;0
027465
027465  ACRTP

027465         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027465  "8BP66;BBP BAK66

027465
027465  BAK66,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027500         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027506         0;0;0;0;0
027513
027513  ACRTP

027513         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027513  "8BP67;BBP BAK67

027513
027513  BAK67,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027526         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027534         0;0;0;0;0
027541
027541  ACRTP

027541         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027541  "8BP68;BBP BAK68

027541
027541  BAK68,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027554         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027562         0;0;0;0;0
027567
027567  ACRTP

027567         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027567  "8BP69;BBP BAK69

027567
027567  BAK69,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027602         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027610         0;0;0;0;0
027615
027615  ACRTP

027615         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027615  "8BP70;BBP BAK70

027615
027615  BAK70,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027630         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027636         0;0;0;0;0
027643
027643  ACRTP

027643         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027643  "8BP71;BBP BAK71

027643
027643  BAK71,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027656         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027664         0;0;0;0;0
027671
027671  ACRTP

027671         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027671  "8BP72;BBP BAK72

027671
027671  BAK72,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027704         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027712         0;0;0;0;0
027717
027717  ACRTP

027717         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027717  "8BP73;BBP BAK73

027717
027717  BAK73,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027732         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027740         0;0;0;0;0
027745
027745  ACRTP

027745         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027745  "8BP74;BBP BAK74

027745
027745  BAK74,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
027760         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
027766         0;0;0;0;0
027773
027773  ACRTP

027773         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
027773  "8BP75;BBP BAK75

027773
027773  BAK75,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030006         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030014         0;0;0;0;0
030021
030021  ACRTP

030021         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030021  "8BP76;BBP BAK76

030021
030021  BAK76,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030034         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030042         0;0;0;0;0
030047
030047  ACRTP

030047         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030047  "8BP77;BBP BAK77

030047
030047  BAK77,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030062         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030070         0;0;0;0;0
030075
030075  ACRTP

030075         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030075  "8BP78;BBP BAK78

030075
030075  BAK78,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030110         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030116         0;0;0;0;0
030123
030123  ACRTP

030123         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030123  "8BP79;BBP BAK79

030123
030123  BAK79,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030136         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030144         0;0;0;0;0
030151
030151  ACRTP

030151         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030151  "8BP80;BBP BAK80

030151
030151  BAK80,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030164         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030172         0;0;0;0;0
030177
030177  ACRTP

030177         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030177  "8BP81;BBP BAK81

030177
030177  BAK81,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030212         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030220         0;0;0;0;0
030225
030225  ACRTP

030225         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030225  "8BP82;BBP BAK82

030225
030225  BAK82,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030240         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030246         0;0;0;0;0
030253
030253  ACRTP

030253         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030253  "8BP83;BBP BAK83

030253
030253  BAK83,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030266         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030274         0;0;0;0;0
030301
030301  ACRTP

030301         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030301  "8BP84;BBP BAK84

030301
030301  BAK84,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030314         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030322         0;0;0;0;0
030327
030327  ACRTP

030327         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030327  "8BP85;BBP BAK85

030327
030327  BAK85,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030342         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030350         0;0;0;0;0
030355
030355  ACRTP

030355         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030355  "8BP86;BBP BAK86

030355
030355  BAK86,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030370         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030376         0;0;0;0;0
030403
030403  ACRTP

030403         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030403  "8BP87;BBP BAK87

030403
030403  BAK87,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030416         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030424         0;0;0;0;0
030431
030431  ACRTP

030431         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030431  "8BP88;BBP BAK88

030431
030431  BAK88,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030444         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030452         0;0;0;0;0
030457
030457  ACRTP

030457         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030457  "8BP89;BBP BAK89

030457
030457  BAK89,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030472         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030500         0;0;0;0;0
030505
030505  ACRTP

030505         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030505  "8BP90;BBP BAK90

030505
030505  BAK90,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030520         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030526         0;0;0;0;0
030533
030533  ACRTP

030533         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030533  "8BP91;BBP BAK91

030533
030533  BAK91,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030546         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030554         0;0;0;0;0
030561
030561  ACRTP

030561         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030561  "8BP92;BBP BAK92

030561
030561  BAK92,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030574         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030602         0;0;0;0;0
030607
030607  ACRTP

030607         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030607  "8BP93;BBP BAK93

030607
030607  BAK93,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030622         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030630         0;0;0;0;0
030635
030635  ACRTP

030635         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030635  "8BP94;BBP BAK94

030635
030635  BAK94,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030650         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030656         0;0;0;0;0
030663
030663  ACRTP

030663         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030663  "8BP95;BBP BAK95

030663
030663  BAK95,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030676         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030704         0;0;0;0;0
030711
030711  ACRTP

030711         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030711  "8BP96;BBP BAK96

030711
030711  BAK96,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030724         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030732         0;0;0;0;0
030737
030737  ACRTP

030737         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030737  "8BP97;BBP BAK97

030737
030737  BAK97,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
030752         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
030760         0;0;0;0;0
030765
030765  ACRTP

030765         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
030765  "8BP98;BBP BAK98

030765
030765  BAK98,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031000         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031006         0;0;0;0;0
031013
031013  ACRTP

031013         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031013  "8BP99;BBP BAK99

031013
031013  BAK99,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031026         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031034         0;0;0;0;0
031041
031041  ACRTP

031041         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031041  "9BP00;BBP BK100

031041
031041  BK100,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031054         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031062         0;0;0;0;0
031067
031067  ACRTP

031067         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031067  "9BP01;BBP BK101

031067
031067  BK101,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031102         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031110         0;0;0;0;0
031115
031115  ACRTP

031115         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031115  "9BP02;BBP BK102

031115
031115  BK102,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031130         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031136         0;0;0;0;0
031143
031143  ACRTP

031143         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031143  "9BP03;BBP BK103

031143
031143  BK103,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031156         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031164         0;0;0;0;0
031171
031171  ACRTP

031171         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031171  "9BP04;BBP BK104

031171
031171  BK104,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031204         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031212         0;0;0;0;0
031217
031217  ACRTP

031217         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031217  "9BP05;BBP BK105

031217
031217  BK105,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031232         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031240         0;0;0;0;0
031245
031245  ACRTP

031245         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031245  "9BP06;BBP BK106

031245
031245  BK106,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031260         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031266         0;0;0;0;0
031273
031273  ACRTP

031273         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031273  "9BP07;BBP BK107

031273
031273  BK107,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031306         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031314         0;0;0;0;0
031321
031321  ACRTP

031321         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031321  "9BP08;BBP BK108

031321
031321  BK108,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031334         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031342         0;0;0;0;0
031347
031347  ACRTP

031347         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031347  "9BP09;BBP BK109

031347
031347  BK109,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031362         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031370         0;0;0;0;0
031375
031375  ACRTP

031375         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031375  "9BP10;BBP BK110

031375
031375  BK110,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031410         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031416         0;0;0;0;0
031423
031423  ACRTP

031423         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031423  "9BP11;BBP BK111

031423
031423  BK111,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031436         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031444         0;0;0;0;0
031451
031451  ACRTP

031451         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031451  "9BP12;BBP BK112

031451
031451  BK112,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031464         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031472         0;0;0;0;0
031477
031477  ACRTP

031477         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031477  "9BP13;BBP BK113

031477
031477  BK113,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031512         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031520         0;0;0;0;0
031525
031525  ACRTP

031525         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031525  "9BP14;BBP BK114

031525
031525  BK114,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031540         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031546         0;0;0;0;0
031553
031553  ACRTP

031553         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031553  "9BP15;BBP BK115

031553
031553  BK115,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031566         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031574         0;0;0;0;0
031601
031601  ACRTP

031601         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031601  "9BP16;BBP BK116

031601
031601  BK116,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031614         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031622         0;0;0;0;0
031627
031627  ACRTP

031627         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031627  "9BP17;BBP BK117

031627
031627  BK117,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031642         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031650         0;0;0;0;0
031655
031655  ACRTP

031655         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031655  "9BP18;BBP BK118

031655
031655  BK118,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031670         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031676         0;0;0;0;0
031703
031703  ACRTP

031703         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031703  "9BP19;BBP BK119

031703
031703  BK119,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031716         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031724         0;0;0;0;0
031731
031731  ACRTP

031731         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031731  "9BP20;BBP BK120

031731
031731  BK120,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031744         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
031752         0;0;0;0;0
031757
031757  ACRTP

031757         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
031757  "9BP21;BBP BK121

031757
031757  BK121,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
031772         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032000         0;0;0;0;0
032005
032005  ACRTP

032005         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032005  "9BP22;BBP BK122

032005
032005  BK122,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032020         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032026         0;0;0;0;0
032033
032033  ACRTP

032033         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032033  "9BP23;BBP BK123

032033
032033  BK123,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032046         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032054         0;0;0;0;0
032061
032061  ACRTP

032061         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032061  "9BP24;BBP BK124

032061
032061  BK124,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032074         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032102         0;0;0;0;0
032107
032107  ACRTP

032107         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032107  "9BP25;BBP BK125

032107
032107  BK125,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032122         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032130         0;0;0;0;0
032135
032135  ACRTP

032135         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032135  "9BP26;BBP BK126

032135
032135  BK126,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032150         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032156         0;0;0;0;0
032163
032163  ACRTP

032163         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032163  "9BP27;BBP BK127

032163
032163  BK127,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032176         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032204         0;0;0;0;0
032211
032211  ACRTP

032211         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032211  "9BP28;BBP BK128

032211
032211  BK128,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032224         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032232         0;0;0;0;0
032237
032237  ACRTP

032237         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032237  "9BP29;BBP BK129

032237
032237  BK129,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032252         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032260         0;0;0;0;0
032265
032265  ACRTP

032265         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032265  "9BP30;BBP BK130

032265
032265  BK130,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032300         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032306         0;0;0;0;0
032313
032313  ACRTP

032313         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032313  "9BP31;BBP BK131

032313
032313  BK131,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032326         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032334         0;0;0;0;0
032341
032341  ACRTP

032341         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032341  "9BP32;BBP BK132

032341
032341  BK132,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032354         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032362         0;0;0;0;0
032367
032367  ACRTP

032367         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032367  "9BP33;BBP BK133

032367
032367  BK133,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032402         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032410         0;0;0;0;0
032415
032415  ACRTP

032415         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032415  "9BP34;BBP BK134

032415
032415  BK134,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032430         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032436         0;0;0;0;0
032443
032443  ACRTP

032443         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032443  "9BP35;BBP BK135

032443
032443  BK135,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032456         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032464         0;0;0;0;0
032471
032471  ACRTP

032471         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032471  "9BP36;BBP BK136

032471
032471  BK136,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032504         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032512         0;0;0;0;0
032517
032517  ACRTP

032517         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032517  "9BP37;BBP BK137

032517
032517  BK137,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032532         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032540         0;0;0;0;0
032545
032545  ACRTP

032545         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032545  "9BP38;BBP BK138

032545
032545  BK138,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032560         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032566         0;0;0;0;0
032573
032573  ACRTP

032573         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032573  "9BP39;BBP BK139

032573
032573  BK139,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032606         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032614         0;0;0;0;0
032621
032621  ACRTP

032621         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032621  "9BP40;BBP BK140

032621
032621  BK140,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032634         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032642         0;0;0;0;0
032647
032647  ACRTP

032647         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032647  "9BP41;BBP BK141

032647
032647  BK141,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032662         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032670         0;0;0;0;0
032675
032675  ACRTP

032675         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032675  "9BP42;BBP BK142

032675
032675  BK142,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032710         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032716         0;0;0;0;0
032723
032723  ACRTP

032723         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032723  "9BP43;BBP BK143

032723
032723  BK143,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032736         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032744         0;0;0;0;0
032751
032751  ACRTP

032751         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032751  "9BP44;BBP BK144

032751
032751  BK144,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
032764         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
032772         0;0;0;0;0
032777
032777  ACRTP

032777         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
032777  "9BP45;BBP BK145

032777
032777  BK145,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033012         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033020         0;0;0;0;0
033025
033025  ACRTP

033025         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033025  "9BP46;BBP BK146

033025
033025  BK146,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033040         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033046         0;0;0;0;0
033053
033053  ACRTP

033053         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033053  "9BP47;BBP BK147

033053
033053  BK147,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033066         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033074         0;0;0;0;0
033101
033101  ACRTP

033101         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033101  "9BP48;BBP BK148

033101
033101  BK148,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033114         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033122         0;0;0;0;0
033127
033127  ACRTP

033127         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033127  "9BP49;BBP BK149

033127
033127  BK149,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033142         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033150         0;0;0;0;0
033155
033155  ACRTP

033155         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033155  "9BP50;BBP BK150

033155
033155  BK150,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033170         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033176         0;0;0;0;0
033203
033203  ACRTP

033203         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033203  "9BP51;BBP BK151

033203
033203  BK151,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033216         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033224         0;0;0;0;0
033231
033231  ACRTP

033231         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033231  "
033231  9LTBP=*                 % LAST "TERMINAL" BACKGROUND PROGRAM
033231
033231
033231
033231
033231  2THSS=*
033231  "8BCH1
033231  BBP BCH01

033231
033231  BCH01,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033244         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033252         0;0;0;0;0
033257
033257  ACRTP

033257         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033257  "8BCH2
033257  BBP BCH02

033257
033257  BCH02,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033272         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033300         0;0;0;0;0
033305
033305  ACRTP

033305         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033305  "8BCH3
033305  BBP BCH03

033305
033305  BCH03,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033320         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033326         0;0;0;0;0
033333
033333  ACRTP

033333         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033333  "8BCH4
033333  BBP BCH04

033333
033333  BCH04,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033346         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033354         0;0;0;0;0
033361
033361  ACRTP

033361         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033361  "8BCH5
033361  BBP BCH05

033361
033361  BCH05,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033374         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033402         0;0;0;0;0
033407
033407  ACRTP

033407         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033407  "8BCH6
033407  BBP BCH06

033407
033407  BCH06,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033422         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033430         0;0;0;0;0
033435
033435  ACRTP

033435         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033435  "8BCH7
033435  BBP BCH07

033435
033435  BCH07,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033450         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033456         0;0;0;0;0
033463
033463  ACRTP

033463         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033463  "8BCH8
033463  BBP BCH08

033463
033463  BCH08,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033476         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033504         0;0;0;0;0
033511
033511  ACRTP

033511         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033511  "8BCH9
033511  BBP BCH09

033511
033511  BCH09,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033524         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033532         0;0;0;0;0
033537
033537  ACRTP

033537         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033537  "8BC10
033537  BBP BCH10

033537
033537  BCH10,  0;7;100;100;0;0;0;0;9ENTO;5OPSE;0
033552         0;0;0;NSPIT+ADPIT+ERNG2+ALEVB;0;*-20
033560         0;0;0;0;0
033565
033565  ACRTP

033565         NYRTP=NXRTP; )KILL NXRTP; NXRTP=NYRTP+1; )KILL NYRTP
033565  "
033565
033565  9LBPR=*      % LAST BACKGROUND PROGRAM
033565  THISS=*      % TO SEPERATE BC-PROGRAMS FROM RU-PROGRAMS IN TESTS. (NORD-NET)
033565
033565
033565  %%RTBES=*
033565  %%8RT2=8RTN@2+8RTN@1+8RTN@1               % (8RTN*26B)
033565  %%*+8RT2/
033565
033565  ERTBS=*                                % END OF RT-DESCRIPTION TABLE
033565
033565  XYZ=NXRTP+8RTN
033565  )KILL NXRTP
033565  NXRTP=XYZ                 % NUMBER OF RT-DESCRIPTION ENTRIES
033565  )KILL XYZ
033565
033565
033565  %-----------------------------------------------------------------------
033565  %%     PREVIOUSLY USED MACROES ARE KILLED
033565  )KILL BBP ACRTP GUDRT
033565  %-----------------------------------------------------------------------
033565  )LINE
%------------------------------------------------------------
033565  %
033565  %  DISK LAYOUT:
033565  %      SECWO, SECTR, SECSY, MAXCY, POLSY, REFOR, RESCY, DISPN
033565  %          SECWO = WORDS   / SECTOR.
033565  %          SECTR = SECTORS / TRACK.
033565  %          SECSY = SECTORS / CYLINDER.
033565  %          MAXCY = VALUE OF MAX CYLINDER.
033565  %          POLSY = VALUE OF FIRST CYLINDER IN POOL.
033565  %          REFOR = FORMAT TYPE:
033565  %                     0 = TRACK OR NO REALLOCATION.
033565  %                    10 = TRACK OR NO REALLOCATION + TEST SECTOR ADDRESS
033565  %                    20 = SECTOR REALLOCATION.
033565  %          RESCY = VALUE OF FIRST RESERVED CYLINDER.
033565  %          ALTFO = ALTERNATIVE FORMAT (ADDRESS OF DTxxx OR 0)
033565  %          DISPN = INDEX FOR THIS ENTRY(FORMAT).
033565  %
033565
033565  "8WD1+8WD2+8MD1+8MD2
033565
033565  DT014, 1000; 14;   44;  577; 1124;  0;    0;     0; 10 % DISC-14MB
033576  DT021, 1000; 14;   44; 1134; 1124;  0;    0;     0; 11 % DISC-21MB
033607  DT023, 1000; 11;   33; 1475; 1462;  0;    0;     0; 12 % DISC-23MB
033620  DT045, 1000; 11;   66; 1475; 1462;  0;    0;     0; 13 % DISC-45MB
033631  DT028, 1000; 11;   33; 1775; 1763;  0; 1776;     0; 14 % DISC-28MB
033642  DT074, 1000; 11;  110; 1775; 1763;  0; 1776;     0; 15 % DISC-74MB
033653
033653  "8BD1+8BD2+8BD3+8BD4
033653
033653  DT030, 1000; 22;   22; 1466; 1465; 10;    0;     0; 20 % DISC-30/60/90MB
033664  DT037, 1000; 22;  132;  632;    0; 10;    0;     0; 21 % DISC-38MB
033675  DT070, 1000; 22;  132; 1466; 1434; 10; 1465;     0; 22 % DISC-70MB
033706  DT075, 1000; 22;  132; 1466; 1465; 10;    0;     0; 23 % DISC-75MB
033717  DT140, 1000; 22;  264; 1466; 1441; 10; 1465; DT135; 24 % DISC-140MB-F
033730  DT135, 1000; 21;  252; 1466; 1462; 20; 1465; DT140; 25 % DISC-140MB-S
033741  DT160, 1000; 22;  264; 1466; 1465; 10;    0;     0; 26 % DISC-2-75MB
033752  DT288, 1000; 22;  526; 1466; 1465; 10;    0;     0; 27 % DISC-288MB-R
033763  DT285, 1000; 21;  630; 1306; 1303; 20; 1305; DT300; 30 % DISC-288MB-S
033774  DT300, 1000; 22;  660; 1306; 1260; 10; 1305; DT285; 31 % DISC-288MB-F
034005  DT450, 1000; 32; 1160; 1306; 1303; 20; 1305; DT460; 32 % DISC-450MB-S
034016  DT460, 1000; 33; 1210; 1306; 1260; 10; 1305; DT450; 33 % DISC-450MB-F
034027  DT310, 1000; 32;  404; 2300; 2267; 20; 2277;     0; 17 % DISC-288MB-E
034040  DT470, 1000; 37; 1115; 1367; 1363; 20; 1366;     0; 34 % DISC-450MB-N
034051  DT290, 1000; 43;  536; 1466; 1460; 20; 1465;     0; 35 % DISC-288MB-N
034062  "8SCSI
034062  DTSSS, 1000;  0;    0;    0;    0;  0;    0;     0; 36 % SCSI DISK
034073  DTOD1, 1000; 36;    0;    0;    0;  0;    0;     0; 40 % OPTICAL DISK (RS=1024)
034104  DTOD2, 2000; 36;    0;    0;    0;  0;    0;     0; 41 % OPTICAL DISK (RS=2048)
034115  "
034115  %      END LAYOUT
034115
034115  DILEZ=11                     % DISC LAYOUT TABLE ELEMENT SIZE
034115
034115  %------------------------------------------------------------
034115  %
034115  %   DISC TYPE POINTER     ==> Optional
034115  %
034115  %          0      1      2      3      4      5      6      7
034115  DISPE,     0; DT010; DT033; DT066;     0;     0;     0;     0 % 00 - 07
034125         DT014; DT021; DT023; DT045; DT028; DT074;     0; DT310 % 10 - 17
034135         DT030; DT037; DT070; DT075; DT140; DT135; DT160; DT288 % 20 - 27
034145         DT285; DT300; DT450; DT460; DT470; DT290; DTSSS;     0 % 30 - 37
034155         DTOD1; DTOD2;     0;     0;     0;     0;     0;     0 % 40 - 47
034165  MAXDI=47                     % MAX DISC TYPE INDEX
034165
034165  )LINE
%%%%%%%%%%%%  M A C R O E S  -  D I S K  -  G E N  %%%%%%%%%%%%%%%%%%%%%
034165
034165  %%     MACROES USED ON DISK-GEN
034165  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
034165
034165  % MACRO FOR HTABL POINTER DEF ON SMD
034165  )MCDEF MHTDS $C,$U
"3C$C U$U ; XXUN$U =DT030   % CONT $C ; UNIT $U : BIG CARTRIDGE
"6C$C U$U ; XXUN$U =DT030   % CONT $C ; UNIT $U : BIG CARTRIDGE
"9C$C U$U ; XXUN$U =DT030   % CONT $C ; UNIT $U : BIG CARTRIDGE
"4B$C U$U ; XXUN$U =DT037   % CONT $C ; UNIT $U : 38MB
"2E$C U$U ; XXUN$U =DT070   % CONT $C ; UNIT $U : 70MB
"7B$C U$U ; XXUN$U =DT075   % CONT $C ; UNIT $U : 75MB
"5E$C U$U ; XXUN$U =DT135   % CONT $C ; UNIT $U : DI-140MB-F , DI-2-70MB-F
"3E$C U$U ; XXUN$U =DT135   % CONT $C ; UNIT $U : DI-140MB-F , DI-2-70MB-F
"2D$C U$U ; XXUN$U =DT160   % CONT $C ; UNIT $U :160MB
"2B$C U$U ; XXUN$U =DT288   % CONT $C ; UNIT $U :288MB
"3D$C U$U ; XXUN$U =DT288   % CONT $C ; UNIT $U :288MB
"1E$C U$U ; XXUN$U =DT288   % CONT $C ; UNIT $U :288MB
"8E$C U$U ; XXUN$U =DT285   % CONT $C ; UNIT $U : DI-288MB-F, DI-4-70MB-F
"7E$C U$U ; XXUN$U =DT285   % CONT $C ; UNIT $U : DI-288MB-F, DI-4-70MB-F
"GE$C U$U ; XXUN$U =DT450   % CONT $C ; UNIT $U : DI-450MB-F, DI-6-70MB-F, DI-2-225MB-F
"EE$C U$U ; XXUN$U =DT450   % CONT $C ; UNIT $U : DI-450MB-F, DI-6-70MB-F, DI-2-225MB-F
"FE$C U$U ; XXUN$U =DT450   % CONT $C ; UNIT $U : DI-450MB-F, DI-6-70MB-F, DI-2-225MB-F
"HE$C U$U ; XXUN$U =DT288   % CONT $C ; UNIT $U : DI-225-1-R
"EM$C U$U ; XXUN$U =DT310   % CONT $C ; UNIT $U : DI-288MB-E, DI-4-70MB-E
"4E$C U$U ; XXUN$U =DT310   % CONT $C ; UNIT $U : DI-288MB-E, DI-4-70MB-E
"GN$C U$U ; XXUN$U =DT470   % CONT $C ; UNIT $U : DI-450MB-N, DI-6-70MB-N, DI-2-225MB-N
"FN$C U$U ; XXUN$U =DT470   % CONT $C ; UNIT $U : DI-450MB-N, DI-6-70MB-N, DI-2-225MB-N
"EN$C U$U ; XXUN$U =DT470   % CONT $C ; UNIT $U : DI-450MB-N, DI-6-70MB-N, DI-2-225MB-N
"1N$C U$U ; XXUN$U =DT290   % CONT $C ; UNIT $U : DI-288MB-N, DI-4-70MB-N
"4N$C U$U ; XXUN$U =DT290   % CONT $C ; UNIT $U : DI-288MB-N, DI-4-70MB-N
"8BD$C ; CURR=*; XXUN$U ;"8BD$C  -XXUN$U ;176777/8B$C U$U ;
"8BD$C ; CURR/;)KILL CURR
]
034165
034165  % MACRO TO GENERATE PHOENIX FLAG ON SMD
034165  )MCDEF MPHFL $C
XXXUN=0
"3C$C U0+6C$C U0+9C$C U0
YYUN=XXXUN+1; )KILL XXXUN; XXXUN=YYUN; )KILL YYUN
"3C$C U1+6C$C U1+9C$C U1
YYUN=XXXUN+2; )KILL XXXUN; XXXUN=YYUN; )KILL YYUN
"3C$C U2+6C$C U2+9C$C U2
YYUN=XXXUN+4; )KILL XXXUN; XXXUN=YYUN; )KILL YYUN
"3C$C U3+6C$C U3+9C$C U3
YYUN=XXXUN+10; )KILL XXXUN; XXXUN=YYUN; )KILL YYUN
"8BD$C      %
]
034165
034165  % MACRO FOR HTABL POINTER DEF ON WINCHESTER
034165  )MCDEF MHTDW $C
"4M$C U0 ; XXUN0=DT045   % CONT $C ; UNIT 0: 45MB
"2M$C U0 ; XXUN0=DT023   % CONT $C ; UNIT 0: 23MB
"1M$C U0 ; XXUN0=DT023   % CONT $C ; UNIT 0: 16MB
"2W$C U0 ; XXUN0=DT021   % CONT $C ; UNIT 0: 21MB
"1W$C U0 ; XXUN0=DT014   % CONT $C ; UNIT 0: 14MB
"3M$C U0 ; XXUN0=DT028   % CONT $C ; UNIT 0: 28MB
"7M$C U0 ; XXUN0=DT074   % CONT $C ; UNIT 0: 74MB
"4M$C U1 ; XXUN1=DT045   % CONT $C ; UNIT 1: 45MB
"2M$C U1 ; XXUN1=DT023   % CONT $C ; UNIT 1: 23MB
"1M$C U1 ; XXUN1=DT023   % CONT $C ; UNIT 1: 16MB
"2W$C U1 ; XXUN1=DT021   % CONT $C ; UNIT 1: 21MB
"1W$C U1 ; XXUN1=DT014   % CONT $C ; UNIT 1: 14MB
"3M$C U1 ; XXUN1=DT028   % CONT $C ; UNIT 1: 28MB
"7M$C U1 ; XXUN1=DT074   % CONT $C ; UNIT 1: 74MB
"8WD$C +8MD$C    %
]
034165
034165  %MACRO FOR BIG DISK (SMD) DATAFIELD
034165  )MCDEF MBSMD $NAM,$NO,$HDE
% BIG DISC DATAFIELD
       0;0;0;0;0;0;0;0;0;0;0               % DED01 ==> DED13
       0;0;0;0                             % SPBU1,SPBU2,SVLWK,OSVWK
       DPITB;*-5;0;0;0;0;0;0;0;0           % NWLBB,NWLBA,OCMD1,OCMD2,OSVBA,OSVBB,OSVCO,OSVWC,SPACO,SPAFL
       0;0;0;0;0;0;360;0;0                 % CORCU,SLONG,ECCFL,CPAT1,CDISP,CPAT2,TYPEC,SVLBB,SVLBA,
       -4;-34;0;0;0;0;0;0                  % ERRC1,ERRC2,SRTRY,SWTRY,SMARG,SVLCO,SCADR,MARGC,
       0;0;0;0;0;0;0;0;0;0;0               % BUSFL,SVLCA,SVLWC,TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
       0;0;0;0;-4;0                        % ERCNT,SERRB,TRGIN,AERRB,TACNS,TACOUNT
       0;1000;BDISK;BUSYE;COOPT;PFEIL      % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
       MTMRS;0;-4;$HDE ;SSTDI;0            % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
$NAM , 0;0;*-2;2;0;0;STRET;0               % RESLINK,RTRES,BWLINK,TYPRING,STPRW,MLINK,MFUNC,TRLREG
       0;DTRNS;DRTRA;STRDI;0;0;0;0         % HSTAT,MTRAN,M5TRA,DODMA,ABFUN,MEMA1,MEMA2,ABP21
       0;0;0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2
       XXXUN;XXUN0;XXUN1;XXUN2;XXUN3;0     % M2UNTYP,HTABL(4),DUMMY
       0;DEDF$NO ;0;0;-1                      % DIFTC,DEDFA,PARDF,CTRLR DIREE
       D$NO DF0;D$NO DF1;D$NO DF2;D$NO DF3;0;0;0;0;0;0 % PSTRA SRETF NSEEK STIMC SUNGL SNOIQ
       0;0;0;5;1                           % SNMIQ SUNIH FREE STMOU STREN
)KILL XXUN0 XXUN1 XXUN2 XXUN3 XXXUN
]
034165
034165  % MACRO FOR WINCHESTER (ST506)  DATAFIELD
034165  )MCDEF MDWIN $NAM,$NO,$HDE
% 14/16/21/39/45/74 MB DISK DATAFIELD (WINCHESTER)

       0;0;0;0;-5;0;0;0;0;0;0% DED01 ==> DED13 (IRETR:= -5)
       0;0;0;0               % NOT USED
       DPITB;*+1             % NWLBB NWLBA
       0;0;0;0;0;0;          % SPARE BUFF(2), FREE(4)
       0;0;0;0;0;0;0;0;0     % ADMIA,ADMIS,ALTPO,BADDR,BADIP,BADTR,WANKN,NOSEC,RTZFL
       0;0;-4;0;0;0;0;0;0;0  % SVLBB,SEEKF,ERRC1,SHEAD,SSEC,SSTEP,TRTZ,SVLCO,LCYLI(2)
       0;0;0;0;0;0;0;0;0;0;0 % BUSFL,SVLCA,SVLWC,TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
       0;0;0;0;-4;0          % ERCNT,SERRB,TRGIN,AERRB,TACNS,TACOUNT
       0;1000;WIDIS;BUSYE;COOPT;PFEIL      % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
       MTMRS;0;-4;$HDE ;SSTDI;0            % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
$NAM , 0;0;*-2;2;0;0;STRET;0               % RESLINK,RTRES,BWLINK,TYPRING,STPRW,MLINK,MFUNC,TRLREG
       0;DTRNS;DRTRA;STRDI;0;0;0;0         % HSTAT,MTRAN,M5TRA,DODMA,ABFUN,MEMA1,MEMA2,ABP21
       0;0;0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2
       0;XXUN0;XXUN1;0;0;0                 % FREE,HTABL(2),DUMMY(3)
       0;DEDF$NO ;0;0;-1                      % DIFTC,DEDFA,PARDF,CTRLR,DIREE
       W$NO DF0;W$NO DF1;0;0; 0;0;0;0;0;0 % PSTRA SRETF NSEEK STIMC SUNGL SNOIQ
       0;0;0;10;0                          % SNMIQ SUNIH             STREN
)KILL XXUN0 XXUN1
]
034165
034165  % MACRO FOR SMD/WINCHESTER UNIT DF
034165  )MCDEF MUSMW $NAME,$U
XXXFE=*; )KILL XXXFE
$NAME , XXXFE;0;0;0;0;1; 0;0; 0; $U ;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
]
034165
034165  % MACRO FOR DISK ACCESS QUE DF
034165  )MCDEF MFQUE $NO
       0;0;0;0;0;0;0
       XXXFE=*;)KILL XXXFE
FRE$NO , 0;0;FRE$NO ; 0;0;XXXFE;0;0;0;0;  0;0
       0; 0;0; 0;0; 0;0; 0;0;
       0;0;0;
)KILL FRE$NO ; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
]
034165
034165  )LINE
%==============================================================================
034165  %            DP-P2-DISK-GEN:MAC
034165  %
034165  %------------------------------------------------------------------------------
034165  %  DISK DATAFIELS
034165  %------------------------------------------------------------------------------
034165
034165  9BBHD=*          % LOWER ADDR OF "DISC DATAFIELD", USED BY HARD DISKS
034165  9FDFD=*          % LOWER ADDR OF "DISC DATAFIELD", USED BY RT-PROGRAM LOG
034165  9FSTR=*          % LOWER ADDR OF "DISC DATAFIELD" WHICH USE STREN
034165
034165  "8BD1;% BIG DISC 1 DATAFIELD
034165  MBSMD BIGDI,1,1540

034165  % BIG DISC DATAFIELD
034165         0;0;0;0;0;0;0;0;0;0;0               % DED01 ==> DED13
034200         0;0;0;0                             % SPBU1,SPBU2,SVLWK,OSVWK
034204         DPITB;*-5;0;0;0;0;0;0;0;0           % NWLBB,NWLBA,OCMD1,OCMD2,OSVBA,OSVBB,OSVCO,OSVWC,SPACO,SPAFL
034216         0;0;0;0;0;0;360;0;0                 % CORCU,SLONG,ECCFL,CPAT1,CDISP,CPAT2,TYPEC,SVLBB,SVLBA,
034227         -4;-34;0;0;0;0;0;0                  % ERRC1,ERRC2,SRTRY,SWTRY,SMARG,SVLCO,SCADR,MARGC,
034237         0;0;0;0;0;0;0;0;0;0;0               % BUSFL,SVLCA,SVLWC,TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
034252         0;0;0;0;-4;0                        % ERCNT,SERRB,TRGIN,AERRB,TACNS,TACOUNT
034260         0;1000;BDISK;BUSYE;COOPT;PFEIL      % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
034266         MTMRS;0;-4;1540;SSTDI;0            % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
034274  BIGDI, 0;0;*-2;2;0;0;STRET;0               % RESLINK,RTRES,BWLINK,TYPRING,STPRW,MLINK,MFUNC,TRLREG
034304         0;DTRNS;DRTRA;STRDI;0;0;0;0         % HSTAT,MTRAN,M5TRA,DODMA,ABFUN,MEMA1,MEMA2,ABP21
034314         0;0;0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2
034323         XXXUN;XXUN0;XXUN1;XXUN2;XXUN3;0     % M2UNTYP,HTABL(4),DUMMY
034331         0;DEDF1;0;0;-1                      % DIFTC,DEDFA,PARDF,CTRLR DIREE
034336         D1DF0;D1DF1;D1DF2;D1DF3;0;0;0;0;0;0 % PSTRA SRETF NSEEK STIMC SUNGL SNOIQ
034350         0;0;0;5;1                           % SNMIQ SUNIH FREE STMOU STREN
034355  )KILL XXUN0 XXUN1 XXUN2 XXUN3 XXXUN
034355
034355  "8BD1;              MUSMW D1DF0,0

034355  XXXFE=*; )KILL XXXFE
034355  D1DF0, XXXFE;0;0;0;0;1; 0;0; 0; 0;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034370
034370  "8BD1 8VSX0+8B1U1;  MUSMW D1DF1,1

034370  XXXFE=*; )KILL XXXFE
034370  D1DF1, XXXFE;0;0;0;0;1; 0;0; 0; 1;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034403
034403  "8BD1 8VSX0+8B1U2;  MUSMW D1DF2,2

034403  XXXFE=*; )KILL XXXFE
034403  D1DF2, XXXFE;0;0;0;0;1; 0;0; 0; 2;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034416
034416  "8BD1 8VSX0+8B1U3;  MUSMW D1DF3,3;
034416  XXXFE=*; )KILL XXXFE
034416  D1DF3, XXXFE;0;0;0;0;1; 0;0; 0; 3;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034431
034431  ";)KILL XXXFE
034431
034431  "8BD2; % BIG DISC 2 DATAFIELD
034431  MBSMD BIGD2,2,1550

034431  % BIG DISC DATAFIELD
034431         0;0;0;0;0;0;0;0;0;0;0               % DED01 ==> DED13
034444         0;0;0;0                             % SPBU1,SPBU2,SVLWK,OSVWK
034450         DPITB;*-5;0;0;0;0;0;0;0;0           % NWLBB,NWLBA,OCMD1,OCMD2,OSVBA,OSVBB,OSVCO,OSVWC,SPACO,SPAFL
034462         0;0;0;0;0;0;360;0;0                 % CORCU,SLONG,ECCFL,CPAT1,CDISP,CPAT2,TYPEC,SVLBB,SVLBA,
034473         -4;-34;0;0;0;0;0;0                  % ERRC1,ERRC2,SRTRY,SWTRY,SMARG,SVLCO,SCADR,MARGC,
034503         0;0;0;0;0;0;0;0;0;0;0               % BUSFL,SVLCA,SVLWC,TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
034516         0;0;0;0;-4;0                        % ERCNT,SERRB,TRGIN,AERRB,TACNS,TACOUNT
034524         0;1000;BDISK;BUSYE;COOPT;PFEIL      % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
034532         MTMRS;0;-4;1550;SSTDI;0            % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
034540  BIGD2, 0;0;*-2;2;0;0;STRET;0               % RESLINK,RTRES,BWLINK,TYPRING,STPRW,MLINK,MFUNC,TRLREG
034550         0;DTRNS;DRTRA;STRDI;0;0;0;0         % HSTAT,MTRAN,M5TRA,DODMA,ABFUN,MEMA1,MEMA2,ABP21
034560         0;0;0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2
034567         XXXUN;XXUN0;XXUN1;XXUN2;XXUN3;0     % M2UNTYP,HTABL(4),DUMMY
034575         0;DEDF2;0;0;-1                      % DIFTC,DEDFA,PARDF,CTRLR DIREE
034602         D2DF0;D2DF1;D2DF2;D2DF3;0;0;0;0;0;0 % PSTRA SRETF NSEEK STIMC SUNGL SNOIQ
034614         0;0;0;5;1                           % SNMIQ SUNIH FREE STMOU STREN
034621  )KILL XXUN0 XXUN1 XXUN2 XXUN3 XXXUN
034621
034621  "8BD2;              MUSMW D2DF0,0

034621  XXXFE=*; )KILL XXXFE
034621  D2DF0, XXXFE;0;0;0;0;1; 0;0; 0; 0;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034634
034634  "8BD2 8VSX0+8B2U1;  MUSMW D2DF1,1

034634  XXXFE=*; )KILL XXXFE
034634  D2DF1, XXXFE;0;0;0;0;1; 0;0; 0; 1;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034647
034647  "8BD2 8VSX0+8B2U2;  MUSMW D2DF2,2

034647  XXXFE=*; )KILL XXXFE
034647  D2DF2, XXXFE;0;0;0;0;1; 0;0; 0; 2;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034662
034662  "8BD2 8VSX0+8B2U3;  MUSMW D2DF3,3;
034662  XXXFE=*; )KILL XXXFE
034662  D2DF3, XXXFE;0;0;0;0;1; 0;0; 0; 3;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
034675
034675  ";)KILL XXXFE
034675
034675  ;)KILL XXXFE
034675
034675  ;)KILL XXXFE
034675
034675
034675  %-----------------------------------------------------------------------
034675  %    S T  5 0 6
034675  %-----------------------------------------------------------------------
034675  "8WD1+8MD1 % WINCHESTER) DATAFIELD  1
034675  MDWIN WIGDI,1,500

034675  % 14/16/21/39/45/74 MB DISK DATAFIELD (WINCHESTER)
034675
034675         0;0;0;0;-5;0;0;0;0;0;0% DED01 ==> DED13 (IRETR:= -5)
034710         0;0;0;0               % NOT USED
034714         DPITB;*+1             % NWLBB NWLBA
034716         0;0;0;0;0;0;          % SPARE BUFF(2), FREE(4)
034724         0;0;0;0;0;0;0;0;0     % ADMIA,ADMIS,ALTPO,BADDR,BADIP,BADTR,WANKN,NOSEC,RTZFL
034735         0;0;-4;0;0;0;0;0;0;0  % SVLBB,SEEKF,ERRC1,SHEAD,SSEC,SSTEP,TRTZ,SVLCO,LCYLI(2)
034747         0;0;0;0;0;0;0;0;0;0;0 % BUSFL,SVLCA,SVLWC,TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
034762         0;0;0;0;-4;0          % ERCNT,SERRB,TRGIN,AERRB,TACNS,TACOUNT
034770         0;1000;WIDIS;BUSYE;COOPT;PFEIL      % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
034776         MTMRS;0;-4;500;SSTDI;0            % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
035004  WIGDI, 0;0;*-2;2;0;0;STRET;0               % RESLINK,RTRES,BWLINK,TYPRING,STPRW,MLINK,MFUNC,TRLREG
035014         0;DTRNS;DRTRA;STRDI;0;0;0;0         % HSTAT,MTRAN,M5TRA,DODMA,ABFUN,MEMA1,MEMA2,ABP21
035024         0;0;0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2
035033         0;XXUN0;XXUN1;0;0;0                 % FREE,HTABL(2),DUMMY(3)
035041         0;DEDF1;0;0;-1                      % DIFTC,DEDFA,PARDF,CTRLR,DIREE
035046         W1DF0;W1DF1;0;0; 0;0;0;0;0;0 % PSTRA SRETF NSEEK STIMC SUNGL SNOIQ
035060         0;0;0;10;0                          % SNMIQ SUNIH             STREN
035065  )KILL XXUN0 XXUN1
035065
035065  MUSMW W1DF0,0

035065  XXXFE=*; )KILL XXXFE
035065  W1DF0, XXXFE;0;0;0;0;1; 0;0; 0; 0;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
035100
035100  MUSMW W1DF1,1;
035100  XXXFE=*; )KILL XXXFE
035100  W1DF1, XXXFE;0;0;0;0;1; 0;0; 0; 1;0  % ULINK SCLIN PLHAD PLELE SLINK MOVME CHAD CHAD SUNOP SUNIT SUMAX
035113   )KILL XXXFE
035113
035113  "
035113  9ESTR=*          % UPPER ADDR OF "DISC DATAFIELD" WHICH USE STREN
035113
035113  %==============================================================================
035113  %       D I S C   Q U E U E   D A T A F I E L D
035113
035113  % FREE QUEUE HEADER
035113  QP100,0;0;*-2;2;0;FRE01;FQELN;FRES1
035123        FRES1;FRES5;FRES5;FQ5MT;    0
035130
035130  BFQUE=*                % BEG. OF FREE QUEUE ELEMENTS
035130  XXFF=0
035130  MFQUE 01

035130         0;0;0;0;0;0;0
035137         XXXFE=*;)KILL XXXFE
035137  FRE01, 0;0;FRE01; 0;0;XXXFE;0;0;0;0;  0;0
035153         0; 0;0; 0;0; 0;0; 0;0;
035164         0;0;0;
035167  )KILL FRE01; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035167
035167  MFQUE 02

035167         0;0;0;0;0;0;0
035176         XXXFE=*;)KILL XXXFE
035176  FRE02, 0;0;FRE02; 0;0;XXXFE;0;0;0;0;  0;0
035212         0; 0;0; 0;0; 0;0; 0;0;
035223         0;0;0;
035226  )KILL FRE02; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035226
035226  MFQUE 03

035226         0;0;0;0;0;0;0
035235         XXXFE=*;)KILL XXXFE
035235  FRE03, 0;0;FRE03; 0;0;XXXFE;0;0;0;0;  0;0
035251         0; 0;0; 0;0; 0;0; 0;0;
035262         0;0;0;
035265  )KILL FRE03; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035265
035265  MFQUE 04

035265         0;0;0;0;0;0;0
035274         XXXFE=*;)KILL XXXFE
035274  FRE04, 0;0;FRE04; 0;0;XXXFE;0;0;0;0;  0;0
035310         0; 0;0; 0;0; 0;0; 0;0;
035321         0;0;0;
035324  )KILL FRE04; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035324
035324  MFQUE 05

035324         0;0;0;0;0;0;0
035333         XXXFE=*;)KILL XXXFE
035333  FRE05, 0;0;FRE05; 0;0;XXXFE;0;0;0;0;  0;0
035347         0; 0;0; 0;0; 0;0; 0;0;
035360         0;0;0;
035363  )KILL FRE05; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035363
035363  MFQUE 06

035363         0;0;0;0;0;0;0
035372         XXXFE=*;)KILL XXXFE
035372  FRE06, 0;0;FRE06; 0;0;XXXFE;0;0;0;0;  0;0
035406         0; 0;0; 0;0; 0;0; 0;0;
035417         0;0;0;
035422  )KILL FRE06; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035422
035422  MFQUE 07

035422         0;0;0;0;0;0;0
035431         XXXFE=*;)KILL XXXFE
035431  FRE07, 0;0;FRE07; 0;0;XXXFE;0;0;0;0;  0;0
035445         0; 0;0; 0;0; 0;0; 0;0;
035456         0;0;0;
035461  )KILL FRE07; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035461
035461  MFQUE 10

035461         0;0;0;0;0;0;0
035470         XXXFE=*;)KILL XXXFE
035470  FRE10, 0;0;FRE10; 0;0;XXXFE;0;0;0;0;  0;0
035504         0; 0;0; 0;0; 0;0; 0;0;
035515         0;0;0;
035520  )KILL FRE10; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035520
035520  MFQUE 11

035520         0;0;0;0;0;0;0
035527         XXXFE=*;)KILL XXXFE
035527  FRE11, 0;0;FRE11; 0;0;XXXFE;0;0;0;0;  0;0
035543         0; 0;0; 0;0; 0;0; 0;0;
035554         0;0;0;
035557  )KILL FRE11; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035557
035557  MFQUE 12

035557         0;0;0;0;0;0;0
035566         XXXFE=*;)KILL XXXFE
035566  FRE12, 0;0;FRE12; 0;0;XXXFE;0;0;0;0;  0;0
035602         0; 0;0; 0;0; 0;0; 0;0;
035613         0;0;0;
035616  )KILL FRE12; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035616
035616  MFQUE 13

035616         0;0;0;0;0;0;0
035625         XXXFE=*;)KILL XXXFE
035625  FRE13, 0;0;FRE13; 0;0;XXXFE;0;0;0;0;  0;0
035641         0; 0;0; 0;0; 0;0; 0;0;
035652         0;0;0;
035655  )KILL FRE13; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035655
035655  MFQUE 14

035655         0;0;0;0;0;0;0
035664         XXXFE=*;)KILL XXXFE
035664  FRE14, 0;0;FRE14; 0;0;XXXFE;0;0;0;0;  0;0
035700         0; 0;0; 0;0; 0;0; 0;0;
035711         0;0;0;
035714  )KILL FRE14; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035714
035714  MFQUE 15

035714         0;0;0;0;0;0;0
035723         XXXFE=*;)KILL XXXFE
035723  FRE15, 0;0;FRE15; 0;0;XXXFE;0;0;0;0;  0;0
035737         0; 0;0; 0;0; 0;0; 0;0;
035750         0;0;0;
035753  )KILL FRE15; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
035753
035753  MFQUE 16

035753         0;0;0;0;0;0;0
035762         XXXFE=*;)KILL XXXFE
035762  FRE16, 0;0;FRE16; 0;0;XXXFE;0;0;0;0;  0;0
035776         0; 0;0; 0;0; 0;0; 0;0;
036007         0;0;0;
036012  )KILL FRE16; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036012
036012  MFQUE 17

036012         0;0;0;0;0;0;0
036021         XXXFE=*;)KILL XXXFE
036021  FRE17, 0;0;FRE17; 0;0;XXXFE;0;0;0;0;  0;0
036035         0; 0;0; 0;0; 0;0; 0;0;
036046         0;0;0;
036051  )KILL FRE17; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036051
036051  MFQUE 20

036051         0;0;0;0;0;0;0
036060         XXXFE=*;)KILL XXXFE
036060  FRE20, 0;0;FRE20; 0;0;XXXFE;0;0;0;0;  0;0
036074         0; 0;0; 0;0; 0;0; 0;0;
036105         0;0;0;
036110  )KILL FRE20; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036110
036110  MFQUE 21

036110         0;0;0;0;0;0;0
036117         XXXFE=*;)KILL XXXFE
036117  FRE21, 0;0;FRE21; 0;0;XXXFE;0;0;0;0;  0;0
036133         0; 0;0; 0;0; 0;0; 0;0;
036144         0;0;0;
036147  )KILL FRE21; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036147
036147  MFQUE 22

036147         0;0;0;0;0;0;0
036156         XXXFE=*;)KILL XXXFE
036156  FRE22, 0;0;FRE22; 0;0;XXXFE;0;0;0;0;  0;0
036172         0; 0;0; 0;0; 0;0; 0;0;
036203         0;0;0;
036206  )KILL FRE22; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036206
036206  MFQUE 23

036206         0;0;0;0;0;0;0
036215         XXXFE=*;)KILL XXXFE
036215  FRE23, 0;0;FRE23; 0;0;XXXFE;0;0;0;0;  0;0
036231         0; 0;0; 0;0; 0;0; 0;0;
036242         0;0;0;
036245  )KILL FRE23; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036245
036245  MFQUE 24

036245         0;0;0;0;0;0;0
036254         XXXFE=*;)KILL XXXFE
036254  FRE24, 0;0;FRE24; 0;0;XXXFE;0;0;0;0;  0;0
036270         0; 0;0; 0;0; 0;0; 0;0;
036301         0;0;0;
036304  )KILL FRE24; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036304
036304  MFQUE 25

036304         0;0;0;0;0;0;0
036313         XXXFE=*;)KILL XXXFE
036313  FRE25, 0;0;FRE25; 0;0;XXXFE;0;0;0;0;  0;0
036327         0; 0;0; 0;0; 0;0; 0;0;
036340         0;0;0;
036343  )KILL FRE25; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036343
036343  MFQUE 26

036343         0;0;0;0;0;0;0
036352         XXXFE=*;)KILL XXXFE
036352  FRE26, 0;0;FRE26; 0;0;XXXFE;0;0;0;0;  0;0
036366         0; 0;0; 0;0; 0;0; 0;0;
036377         0;0;0;
036402  )KILL FRE26; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036402
036402  MFQUE 27

036402         0;0;0;0;0;0;0
036411         XXXFE=*;)KILL XXXFE
036411  FRE27, 0;0;FRE27; 0;0;XXXFE;0;0;0;0;  0;0
036425         0; 0;0; 0;0; 0;0; 0;0;
036436         0;0;0;
036441  )KILL FRE27; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036441
036441  MFQUE 30

036441         0;0;0;0;0;0;0
036450         XXXFE=*;)KILL XXXFE
036450  FRE30, 0;0;FRE30; 0;0;XXXFE;0;0;0;0;  0;0
036464         0; 0;0; 0;0; 0;0; 0;0;
036475         0;0;0;
036500  )KILL FRE30; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036500
036500  FQELN= XXFF;    FQELN:000030                       % NO OF FREE QUEUE ELEMENTS
036500  )KILL XXFF
036500
036500
036500  XXFF=0
036500  "8N500 8MTRA 8SIBA+8SIBX+8SIBM+8SIBN
036500  % QUEUE ELEMENTS FOR 5MTRANS
036500  MFQUE 31

036500         0;0;0;0;0;0;0
036507         XXXFE=*;)KILL XXXFE
036507  FRE31, 0;0;FRE31; 0;0;XXXFE;0;0;0;0;  0;0
036523         0; 0;0; 0;0; 0;0; 0;0;
036534         0;0;0;
036537  )KILL FRE31; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036537
036537  MFQUE 32

036537         0;0;0;0;0;0;0
036546         XXXFE=*;)KILL XXXFE
036546  FRE32, 0;0;FRE32; 0;0;XXXFE;0;0;0;0;  0;0
036562         0; 0;0; 0;0; 0;0; 0;0;
036573         0;0;0;
036576  )KILL FRE32; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036576
036576  MFQUE 33

036576         0;0;0;0;0;0;0
036605         XXXFE=*;)KILL XXXFE
036605  FRE33, 0;0;FRE33; 0;0;XXXFE;0;0;0;0;  0;0
036621         0; 0;0; 0;0; 0;0; 0;0;
036632         0;0;0;
036635  )KILL FRE33; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036635
036635  MFQUE 34

036635         0;0;0;0;0;0;0
036644         XXXFE=*;)KILL XXXFE
036644  FRE34, 0;0;FRE34; 0;0;XXXFE;0;0;0;0;  0;0
036660         0; 0;0; 0;0; 0;0; 0;0;
036671         0;0;0;
036674  )KILL FRE34; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036674
036674  MFQUE 35

036674         0;0;0;0;0;0;0
036703         XXXFE=*;)KILL XXXFE
036703  FRE35, 0;0;FRE35; 0;0;XXXFE;0;0;0;0;  0;0
036717         0; 0;0; 0;0; 0;0; 0;0;
036730         0;0;0;
036733  )KILL FRE35; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036733
036733  MFQUE 36

036733         0;0;0;0;0;0;0
036742         XXXFE=*;)KILL XXXFE
036742  FRE36, 0;0;FRE36; 0;0;XXXFE;0;0;0;0;  0;0
036756         0; 0;0; 0;0; 0;0; 0;0;
036767         0;0;0;
036772  )KILL FRE36; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
036772
036772  "8N500 8MTRA 8SIBX+8SIBM+8SIBN
036772  MFQUE 37

036772         0;0;0;0;0;0;0
037001         XXXFE=*;)KILL XXXFE
037001  FRE37, 0;0;FRE37; 0;0;XXXFE;0;0;0;0;  0;0
037015         0; 0;0; 0;0; 0;0; 0;0;
037026         0;0;0;
037031  )KILL FRE37; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037031
037031  MFQUE 40

037031         0;0;0;0;0;0;0
037040         XXXFE=*;)KILL XXXFE
037040  FRE40, 0;0;FRE40; 0;0;XXXFE;0;0;0;0;  0;0
037054         0; 0;0; 0;0; 0;0; 0;0;
037065         0;0;0;
037070  )KILL FRE40; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037070
037070  MFQUE 41

037070         0;0;0;0;0;0;0
037077         XXXFE=*;)KILL XXXFE
037077  FRE41, 0;0;FRE41; 0;0;XXXFE;0;0;0;0;  0;0
037113         0; 0;0; 0;0; 0;0; 0;0;
037124         0;0;0;
037127  )KILL FRE41; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037127
037127  MFQUE 42

037127         0;0;0;0;0;0;0
037136         XXXFE=*;)KILL XXXFE
037136  FRE42, 0;0;FRE42; 0;0;XXXFE;0;0;0;0;  0;0
037152         0; 0;0; 0;0; 0;0; 0;0;
037163         0;0;0;
037166  )KILL FRE42; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037166
037166  MFQUE 43

037166         0;0;0;0;0;0;0
037175         XXXFE=*;)KILL XXXFE
037175  FRE43, 0;0;FRE43; 0;0;XXXFE;0;0;0;0;  0;0
037211         0; 0;0; 0;0; 0;0; 0;0;
037222         0;0;0;
037225  )KILL FRE43; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037225
037225  MFQUE 44

037225         0;0;0;0;0;0;0
037234         XXXFE=*;)KILL XXXFE
037234  FRE44, 0;0;FRE44; 0;0;XXXFE;0;0;0;0;  0;0
037250         0; 0;0; 0;0; 0;0; 0;0;
037261         0;0;0;
037264  )KILL FRE44; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037264
037264  "8N500 8MTRA 8SIBM+8SIBN
037264  MFQUE 45

037264         0;0;0;0;0;0;0
037273         XXXFE=*;)KILL XXXFE
037273  FRE45, 0;0;FRE45; 0;0;XXXFE;0;0;0;0;  0;0
037307         0; 0;0; 0;0; 0;0; 0;0;
037320         0;0;0;
037323  )KILL FRE45; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037323
037323  MFQUE 46

037323         0;0;0;0;0;0;0
037332         XXXFE=*;)KILL XXXFE
037332  FRE46, 0;0;FRE46; 0;0;XXXFE;0;0;0;0;  0;0
037346         0; 0;0; 0;0; 0;0; 0;0;
037357         0;0;0;
037362  )KILL FRE46; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037362
037362  MFQUE 47

037362         0;0;0;0;0;0;0
037371         XXXFE=*;)KILL XXXFE
037371  FRE47, 0;0;FRE47; 0;0;XXXFE;0;0;0;0;  0;0
037405         0; 0;0; 0;0; 0;0; 0;0;
037416         0;0;0;
037421  )KILL FRE47; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037421
037421  MFQUE 50

037421         0;0;0;0;0;0;0
037430         XXXFE=*;)KILL XXXFE
037430  FRE50, 0;0;FRE50; 0;0;XXXFE;0;0;0;0;  0;0
037444         0; 0;0; 0;0; 0;0; 0;0;
037455         0;0;0;
037460  )KILL FRE50; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037460
037460  MFQUE 51

037460         0;0;0;0;0;0;0
037467         XXXFE=*;)KILL XXXFE
037467  FRE51, 0;0;FRE51; 0;0;XXXFE;0;0;0;0;  0;0
037503         0; 0;0; 0;0; 0;0; 0;0;
037514         0;0;0;
037517  )KILL FRE51; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037517
037517  MFQUE 52

037517         0;0;0;0;0;0;0
037526         XXXFE=*;)KILL XXXFE
037526  FRE52, 0;0;FRE52; 0;0;XXXFE;0;0;0;0;  0;0
037542         0; 0;0; 0;0; 0;0; 0;0;
037553         0;0;0;
037556  )KILL FRE52; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037556
037556  MFQUE 53

037556         0;0;0;0;0;0;0
037565         XXXFE=*;)KILL XXXFE
037565  FRE53, 0;0;FRE53; 0;0;XXXFE;0;0;0;0;  0;0
037601         0; 0;0; 0;0; 0;0; 0;0;
037612         0;0;0;
037615  )KILL FRE53; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037615
037615  MFQUE 54

037615         0;0;0;0;0;0;0
037624         XXXFE=*;)KILL XXXFE
037624  FRE54, 0;0;FRE54; 0;0;XXXFE;0;0;0;0;  0;0
037640         0; 0;0; 0;0; 0;0; 0;0;
037651         0;0;0;
037654  )KILL FRE54; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037654
037654  MFQUE 55

037654         0;0;0;0;0;0;0
037663         XXXFE=*;)KILL XXXFE
037663  FRE55, 0;0;FRE55; 0;0;XXXFE;0;0;0;0;  0;0
037677         0; 0;0; 0;0; 0;0; 0;0;
037710         0;0;0;
037713  )KILL FRE55; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037713
037713  MFQUE 56

037713         0;0;0;0;0;0;0
037722         XXXFE=*;)KILL XXXFE
037722  FRE56, 0;0;FRE56; 0;0;XXXFE;0;0;0;0;  0;0
037736         0; 0;0; 0;0; 0;0; 0;0;
037747         0;0;0;
037752  )KILL FRE56; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
037752
037752  MFQUE 57

037752         0;0;0;0;0;0;0
037761         XXXFE=*;)KILL XXXFE
037761  FRE57, 0;0;FRE57; 0;0;XXXFE;0;0;0;0;  0;0
037775         0; 0;0; 0;0; 0;0; 0;0;
040006         0;0;0;
040011  )KILL FRE57; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
040011
040011  MFQUE 60

040011         0;0;0;0;0;0;0
040020         XXXFE=*;)KILL XXXFE
040020  FRE60, 0;0;FRE60; 0;0;XXXFE;0;0;0;0;  0;0
040034         0; 0;0; 0;0; 0;0; 0;0;
040045         0;0;0;
040050  )KILL FRE60; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
040050
040050  "
040050  FQ5MT= XXFF;    FQ5MT:000030                       % NO OF 5MTRANS QUEUE ELEMENTS
040050
040050  XXXFE=-1; )KILL XXXFE                      % END OF QUEUE
040050
040050  % ND 100 SWAPPER QUE ELEMENT
040050  MFQUE S1

040050         0;0;0;0;0;0;0
040057         XXXFE=*;)KILL XXXFE
040057  FRES1, 0;0;FRES1; 0;0;XXXFE;0;0;0;0;  0;0
040073         0; 0;0; 0;0; 0;0; 0;0;
040104         0;0;0;
040107  )KILL FRES1; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
040107
040107  XXXFE=-1; )KILL XXXFE                      % END OF QUE
040107  % ND 500 SWAPPER QUE ELEMENT
040107  MFQUE S5

040107         0;0;0;0;0;0;0
040116         XXXFE=*;)KILL XXXFE
040116  FRES5, 0;0;FRES5; 0;0;XXXFE;0;0;0;0;  0;0
040132         0; 0;0; 0;0; 0;0; 0;0;
040143         0;0;0;
040146  )KILL FRES5; XX=XXFF+1;)KILL XXFF;XXFF=XX;)KILL XX
040146
040146  XXXFE=-1; )KILL XXXFE                      % END OF QUE
040146  )KILL  XXFF
040146
040146  EFQUE=*                % END. OF FREE QUE ELEMENTS
040146
040146  )LINE
%%%%%%%%%%%%  M A C R O E S  -  M A S S  -  G E N  %%%%%%%%%%%%%%%%%%%%%
040146
040146  %%    KILL  MACROES USED ON DISK-GEN
040146  )KILL MHTDS MPHFL MHTDW MBSMD MDWIN
040146  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
040146
040146
040146
040146  % MACRO FOR SCSI DISK DEVICE DATAFIELDS:
040146  )MCDEF MSDEV $DNU
       -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
       0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
       SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
SCD$DNU , 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
       DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
       0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
       0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
       -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
]
040146
040146  % MACRO FOR SCSI UNIT
040146  )MCDEF MSUNI $DNU,$NUM
       -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
       SDIL$NUM ;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
SDIU$NUM , SCD$DNU ;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
       0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
       0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
)KILL  SDIU$NUM                                 %
]
040146
040146  % MACRO FOR SCSI DISK  LUN DATAFIELDS
040146  )MCDEF MSLUN $NUM
SDIL$NUM , $NUM ; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
       0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
       077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
       0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
       0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
       0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
)KILL SDIL$NUM                                  %
YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
]
040146
040146  % MACRO FOR SCSI OPTICAL DISK  DATAFIELD
040146  )MCDEF MSODV $NUM
       -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
       0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
       SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
SCOD$NUM , 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
       DTRNS;DRTRA;SCOPT                    % MTRANS,M5TRA,DODMA
       0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
       0;DTOD1;DTOD1;DTOD1;DTOD1;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
       -1;SODU0;SODU1;SODU2;SODU3           % FREE,PUNDF

]
040146
040146  % MACRO FOR SCSI OPTICAL DISK UNIT DATAFIELD
040146  )MCDEF MSOUN $DNU,$NUM
       -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
       SODL$NUM ;0;0;0;0;0                      % SCDFA,TMR,TTMR,OPSTA,STDRIV,DRIVER
SODU$NUM , SCOD$DNU ;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
       0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
       0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
)KILL SODU$NUM                                  %
]
040146
040146  % MACRO FOR SCSI OPTICAL DISK 2 LUN DATAFIELDS
040146  )MCDEF MSOLU $NUM
SODL$NUM , $NUM ; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
       0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
       077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
       0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
       0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
       0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
)KILL SODL$NUM                                  %
YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
]
040146
040146
040146  )LINE
%==============================================================================
040146  %            DP-P2-MASS-GEN:MAC
040146  %
040146  %------------------------------------------------------------------------------
040146  %    S C S I  D A T A F I E L D S
040146  %-----------------------------------------------------------------------
040146  "8SCSI
040146  SCDDB=*            % BEGINNING OF SCSI DISK DATAFIELDS
040146  "8ZSCS
040146  % SCSI DISK 1 DATAFIELD (ALSO USED BY BOOTING)
040146         DPITB;*+1
040150         0;0;0;0;0;0
040156         0;0;0;0;0;0;0;0
040166         0;0;0;0;0;0;0;0
040176         0;0;0;0;0;0;0;0
040206  "8ZSCS+7D1U0+7D1U1
040206         0;0;0;0;0;0;0;0                      % TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
040216         0;0;0;0                              % ERCNT,SEERB,WERRB,AERRD
040222         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
040226         SCDTR;0;0;0                          % TRANSF,SCULI,FINISH,SCUDF
040232         SDIND;0;YBOOT;144300;SSTDI;0         % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
040240  SCDI1, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
040251         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA,DODMA
040254         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040267         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
040301         -1;SDIU0;SDIU1;SDIU2;SDIU3           % DIREE,PUNDF
040306  "8ZSCS+7D1U0
040306  % SCSI DISK 1 UNIT 0 DATAFIELD
040306         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRANSF,SCULI,FINISH,SCUDF
040316         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
040324  SDIU0, SCDI1;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
040334         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
040340         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040353
040353  "8ZSCS+7D1U0+7D1U1+7D1U2+7D1U3; )KILL XXXX; XXXX=1
040353  SDIND, NXLUN                                % NUMBER OF UNITS
040354  SDIL0, 000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0   % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
040370         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
040377         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
040407         0;0;0;0;0;SCSI1                      % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
040415         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
040421         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
040425  "8ZSCS; XBOOT=SDIND; YBOOT=44040
040425  "8ZSCS+7D1U0+7D1U1
040425  NXLUN=XXXX
040425  "8ZSCS+8SCS1+7D1U0+7D1U1+7D1U2+7D1U3
040425  )KILL SDIU0 SDIU1 SDIU2 SDIU3
040425  )KILL SDIND SDIL0 SDIL1 SDIL2 SDIL3 XXXX NXLUN YBOOT
040425
040425
040425  "7D2U0+7D2U1+7D2U2+7D2U3
040425  % ---------------------------------------- SCSI DISK 2 DATAFIELD
040425  MSDEV I2

040425         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
040431         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
040435         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
040443  SCDI2, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
040454         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
040457         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040472         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
040504         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
040511
040511  % SCSI DISK 2 UNIT  DATAFIELDS
040511  "7D2U0; MSUNI I2,0

040511         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
040521         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
040527  SDIU0, SCDI2;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
040537         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
040543         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040556  )KILL  SDIU0                                %
040556
040556  "7D2U0+7D2U1+7D2U2+7D2U3; )KILL CXLUN;CXLUN=0
040556  % SCSI DISK 2 LUN DATAFIELDS
040556  SDIND, NXLUN                               % NUMBER OF UNITS
040557                      MSLUN 0

040557  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
040573         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
040602         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
040612         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
040620         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
040624         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
040630  )KILL SDIL0                                 %
040630  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
040630
040630  "7D2U0+7D2U1+7D2U2+7D2U3
040630  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
040630
040630  "7D3U0+7D3U1+7D3U2+7D3U3
040630  % ---------------------------------------- SCSI DISK 3 DATAFIELD
040630  MSDEV I3

040630         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
040634         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
040640         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
040646  SCDI3, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
040657         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
040662         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040675         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
040707         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
040714
040714  % SCSI DISK 3 UNIT  DATAFIELDS
040714  "7D3U0; MSUNI I3,0

040714         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
040724         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
040732  SDIU0, SCDI3;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
040742         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
040746         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
040761  )KILL  SDIU0                                %
040761
040761  "7D3U0+7D3U1+7D3U2+7D3U3; )KILL CXLUN;CXLUN=0
040761  % SCSI DISK 3 LUN DATAFIELDS
040761  SDIND, NXLUN                               % NUMBER OF UNITS
040762                      MSLUN 0

040762  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
040776         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
041005         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
041015         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
041023         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
041027         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
041033  )KILL SDIL0                                 %
041033  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
041033
041033  "7D3U0+7D3U1+7D3U2+7D3U3
041033  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
041033
041033  "7D4U0+7D4U1+7D4U2+7D4U3
041033  % ---------------------------------------- SCSI DISK 4 DATAFIELD
041033  MSDEV I4

041033         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
041037         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
041043         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
041051  SCDI4, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
041062         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
041065         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041100         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
041112         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
041117
041117  % SCSI DISK 4 UNIT  DATAFIELDS
041117  "7D4U0; MSUNI I4,0

041117         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
041127         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
041135  SDIU0, SCDI4;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
041145         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
041151         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041164  )KILL  SDIU0                                %
041164
041164  "7D4U0+7D4U1+7D4U2+7D4U3; )KILL CXLUN;CXLUN=0
041164  % SCSI DISK 4 LUN DATAFIELDS
041164  SDIND, NXLUN                               % NUMBER OF UNITS
041165                      MSLUN 0

041165  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
041201         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
041210         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
041220         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
041226         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
041232         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
041236  )KILL SDIL0                                 %
041236  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
041236
041236  "7D4U0+7D4U1+7D4U2+7D4U3
041236  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
041236
041236  "7D5U0+7D5U1+7D5U2+7D5U3
041236  % ---------------------------------------- SCSI DISK 5 DATAFIELD
041236  MSDEV I5

041236         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
041242         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
041246         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
041254  SCDI5, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
041265         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
041270         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041303         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
041315         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
041322
041322  % SCSI DISK 5 UNIT  DATAFIELDS
041322  "7D5U0; MSUNI I5,0

041322         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
041332         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
041340  SDIU0, SCDI5;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
041350         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
041354         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041367  )KILL  SDIU0                                %
041367
041367  "7D5U0+7D5U1+7D5U2+7D5U3; )KILL CXLUN;CXLUN=0
041367  % SCSI DISK 5 LUN DATAFIELDS
041367  SDIND, NXLUN                               % NUMBER OF UNITS
041370                      MSLUN 0

041370  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
041404         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
041413         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
041423         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
041431         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
041435         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
041441  )KILL SDIL0                                 %
041441  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
041441
041441  "7D5U0+7D5U1+7D5U2+7D5U3
041441  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
041441
041441  "7D6U0+7D6U1+7D6U2+7D6U3
041441  % ---------------------------------------- SCSI DISK 6 DATAFIELD
041441  MSDEV I6

041441         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
041445         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
041451         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
041457  SCDI6, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
041470         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
041473         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041506         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
041520         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
041525
041525  % SCSI DISK 6 UNIT  DATAFIELDS
041525  "7D6U0; MSUNI I6,0

041525         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
041535         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
041543  SDIU0, SCDI6;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
041553         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
041557         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041572  )KILL  SDIU0                                %
041572
041572  "7D6U0+7D6U1+7D6U2+7D6U3; )KILL CXLUN;CXLUN=0
041572  % SCSI DISK 6 LUN DATAFIELDS
041572  SDIND, NXLUN                               % NUMBER OF UNITS
041573                      MSLUN 0

041573  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
041607         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
041616         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
041626         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
041634         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
041640         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
041644  )KILL SDIL0                                 %
041644  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
041644
041644  "7D6U0+7D6U1+7D6U2+7D6U3
041644  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
041644
041644  "7D7U0+7D7U1+7D7U2+7D7U3
041644  % ---------------------------------------- SCSI DISK 7 DATAFIELD
041644  MSDEV I7

041644         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
041650         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
041654         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
041662  SCDI7, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
041673         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
041676         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041711         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
041723         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
041730
041730  % SCSI DISK 7 UNIT  DATAFIELDS
041730  "7D7U0; MSUNI I7,0

041730         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
041740         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
041746  SDIU0, SCDI7;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
041756         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
041762         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
041775  )KILL  SDIU0                                %
041775
041775  "7D7U0+7D7U1+7D7U2+7D7U3; )KILL CXLUN;CXLUN=0
041775  % SCSI DISK 7 LUN DATAFIELDS
041775  SDIND, NXLUN                               % NUMBER OF UNITS
041776                      MSLUN 0

041776  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
042012         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
042021         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
042031         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
042037         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
042043         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
042047  )KILL SDIL0                                 %
042047  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
042047
042047  "7D7U0+7D7U1+7D7U2+7D7U3
042047  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
042047
042047  "7D8U0+7D8U1+7D8U2+7D8U3
042047  % ---------------------------------------- SCSI DISK 8 DATAFIELD
042047  MSDEV I8

042047         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
042053         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
042057         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
042065  SCDI8, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
042076         DTRNS;DRTRA;SCSDI                    % MTRANS,M5TRA;DODMA
042101         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042114         0;DTSSS;DTSSS;DTSSS;DTSSS;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
042126         -1; SDIU0;SDIU1;SDIU2;SDIU3          % DIREA,PUNDF
042133
042133  % SCSI DISK 8 UNIT  DATAFIELDS
042133  "7D8U0; MSUNI I8,0

042133         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
042143         SDIL0;0;0;0; 0;0                     % SCDFA,TMR,TTMR,NPART,UHLIM
042151  SDIU0, SCDI8;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
042161         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
042165         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042200  )KILL  SDIU0                                %
042200
042200  "7D8U0+7D8U1+7D8U2+7D8U3; )KILL CXLUN;CXLUN=0
042200  % SCSI DISK 8 LUN DATAFIELDS
042200  SDIND, NXLUN                               % NUMBER OF UNITS
042201                      MSLUN 0

042201  SDIL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
042215         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
042224         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
042234         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
042242         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
042246         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
042252  )KILL SDIL0                                 %
042252  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
042252
042252  "7D8U0+7D8U1+7D8U2+7D8U3
042252  NXLUN=CXLUN; NXLUN:000001  ; )KILL CXLUN NXLUN SDIND
042252
042252  "
042252  SCDDE=*            % END OF SCSI DISK DATAFIELDS
042252  SCODB=*            % BEGINNING OF SCSI OPTICAL DISK DATAFIELDS
042252
042252  "7O1U0+7O1U1+7O1U2+7O1U3
042252  % ---------------------------------------- SCSI OPTICAL DISK 1 DATAFIELD
042252  MSODV 1

042252         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
042256         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
042262         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
042270  SCOD1, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
042301         DTRNS;DRTRA;SCOPT                    % MTRANS,M5TRA,DODMA
042304         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042317         0;DTOD1;DTOD1;DTOD1;DTOD1;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
042331         -1;SODU0;SODU1;SODU2;SODU3           % FREE,PUNDF
042336
042336
042336  "7O1U0
042336  % SCSI OPTICAL DISK 1 UNIT 0 DATAFIELD
042336  MSOUN 1,0

042336         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
042346         SODL0;0;0;0;0;0                      % SCDFA,TMR,TTMR,OPSTA,STDRIV,DRIVER
042354  SODU0, SCOD1;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
042364         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
042370         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042403  )KILL SODU0                                 %
042403
042403  "7O1U0+7O1U1+7O1U2+7O1U3;)KILL CXLUN;CXLUN=0
042403  % SCSI OPTICAL DISK 1 LUN DATAFIELDS
042403  SDIND, NXLUN                               % NUMBER OF UNITS
042404  "7O1U0+7O1U1+7O1U2+7O1U3;MSOLU 0

042404  SODL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
042420         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
042427         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
042437         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
042445         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
042451         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
042455  )KILL SODL0                                 %
042455  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
042455
042455  "7O1U0+7O1U1+7O1U2+7O1U3;
042455  NXLUN=CXLUN;NXLUN:000001  ;)KILL CXLUN NXLUN SDIND
042455
042455  "7O2U0+7O2U1+7O2U2+7O2U3
042455  % ---------------------------------------- SCSI OPTICAL DISK 2 DATAFIELD
042455  MSODV 2

042455         -4;0;0;0                             % TACNS,TACOU,SCTRG,SCOCW
042461         0;0;0;0                              % TRNSF,SCULI,FINISH,SCUDF
042465         SDIND;0;0;144300;SSTDI;0             % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
042473  SCOD2, 0;0;*-2;2;0;0;STRET;0;0              % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
042504         DTRNS;DRTRA;SCOPT                    % MTRANS,M5TRA,DODMA
042507         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042522         0;DTOD1;DTOD1;DTOD1;DTOD1;0;0;0;0;0  % CLEDE,HTABL,DIFTC,DEDFA,PARDF,CTRLR
042534         -1;SODU0;SODU1;SODU2;SODU3           % FREE,PUNDF
042541
042541
042541  "7O2U0
042541  % SCSI OPTICAL DISK 2 UNIT 0 DATAFIELD
042541  MSOUN 2,0

042541         -4;0;0;0;0;0;0;0                     % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH,SCUDF
042551         SODL0;0;0;0;0;0                      % SCDFA,TMR,TTMR,OPSTA,STDRIV,DRIVER
042557  SODU0, SCOD2;0;0;0;0;1; 0;0                 % ULINK,SCLINK,PLHAD,PLELE,SLINK,MOVME,CHADD
042567         0;0;0;0                              % SUNOP,SUNIT,SUMAX,FREE
042573         0; 0;0; 0;0; 0;0; 0;0; 0;0           % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
042606  )KILL SODU0                                 %
042606
042606  "7O2U0+7O2U1+7O2U2+7O2U3;)KILL CXLUN;CXLUN=0
042606  % SCSI OPTICAL DISK 2 LUN DATAFIELDS
042606  SDIND, NXLUN                               % NUMBER OF UNITS
042607  "7O2U0+7O2U1+7O2U2+7O2U3;MSOLU 0

042607  SODL0, 0; 0;0; 0;0; 0;0; 0;0; 0;0; 0        % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
042623         0; 0;0; 0;0; 0;0                     % ABFUN,MEMAD,ABPA2,ABPA3
042632         077400;0;0;0;0;0;0;0                 % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
042642         0;0;0;0;0;0                          % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
042650         0; 0;0; 0                            % SURSZ,SMBPA,SUDBR
042654         0;0;0;0                              % SUTLR,SURTC,SUSCO,SUSTR
042660  )KILL SODL0                                 %
042660  YYYY=CXLUN+1; )KILL CXLUN; CXLUN=YYYY; )KILL YYYY
042660
042660  "7O2U0+7O2U1+7O2U2+7O2U3;
042660  NXLUN=CXLUN;NXLUN:000001  ;)KILL CXLUN NXLUN SDIND
042660
042660  "
042660  SCODE=*          % END OF SCSI OPTICAL DISK DATAFIELDS
042660  9EDFD=*          % UPPER ADDR OF "DISC DATAFIELD", USED BY RT-PROGRAM-LOG
042660
042660
042660  )LINE
%%%%%%%%%%%%  M A C R O E S  -  B D I O  -  G E N  %%%%%%%%%%%%%%%%%%%%%
042660
042660  %%     MACROES USED ON BDIO-GEN
042660  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
042660
042660  % MACRO FOR BDIO POOL DATAFIELDS:
042660  )MCDEF BDDOM $DNU
       BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
DOM$DNU , 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
       0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
       0;2257  $DNU ;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
       0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
       0 ; 0                                % FREE FREE
]
042660
042660  )LINE
%==============================================================================
042660  %            DP-P2-BDIO-GEN:MAC
042660  %
042660  %------------------------------------------------------------------------------
042660  "8BDIO
042660  %==============================================================================
042660  %       D O M I N O    D A T A F I E L D  (WITH MESSAGE BUFFER)
042660  %
042660                       0;0
042662  DOMDF, 0;0;*-2;2;0;0;REBDI;0
042672         0;0;0;0;0;0;0;0
042702         0;0;0;0;0;0;0;0
042712         0;0;0;0;0;0;0;0
042722         0;0;0;0;0;0;0;0
042732         0;0;0;0;0;0;0;0
042742         0;0;
042744  ADOML, 0;0;*-2;2          % ALLOCATION LOCK/ MESSAGE BUFFER LOCK
042750  NKMBU=*                   % BUFFER FOR DOMINO MESSAGE
042750  *+160/
043130
043130  %==============================================================================
043130  %       D O M I N O    P O O L   D A T A F I E L D S
043130  %
043130  BDDOM 01

043130         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043136  DOM01, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043146         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043152         0;2257  01;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043157         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043165         0 ; 0                                % FREE FREE
043167
043167  BDDOM 02

043167         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043175  DOM02, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043205         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043211         0;2257  02;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043216         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043224         0 ; 0                                % FREE FREE
043226
043226  BDDOM 03

043226         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043234  DOM03, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043244         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043250         0;2257  03;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043255         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043263         0 ; 0                                % FREE FREE
043265
043265  BDDOM 04

043265         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043273  DOM04, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043303         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043307         0;2257  04;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043314         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043322         0 ; 0                                % FREE FREE
043324
043324  BDDOM 05

043324         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043332  DOM05, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043342         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043346         0;2257  05;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043353         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043361         0 ; 0                                % FREE FREE
043363
043363  BDDOM 06

043363         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043371  DOM06, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043401         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043405         0;2257  06;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043412         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043420         0 ; 0                                % FREE FREE
043422
043422  BDDOM 07

043422         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043430  DOM07, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043440         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043444         0;2257  07;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043451         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043457         0 ; 0                                % FREE FREE
043461
043461  BDDOM 10

043461         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043467  DOM10, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043477         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043503         0;2257  10;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043510         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043516         0 ; 0                                % FREE FREE
043520
043520  BDDOM 11

043520         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043526  DOM11, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043536         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043542         0;2257  11;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043547         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043555         0 ; 0                                % FREE FREE
043557
043557  BDDOM 12

043557         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043565  DOM12, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043575         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043601         0;2257  12;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043606         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043614         0 ; 0                                % FREE FREE
043616
043616  BDDOM 13

043616         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043624  DOM13, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043634         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043640         0;2257  13;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043645         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043653         0 ; 0                                % FREE FREE
043655
043655  BDDOM 14

043655         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043663  DOM14, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043673         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043677         0;2257  14;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043704         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043712         0 ; 0                                % FREE FREE
043714
043714  BDDOM 15

043714         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043722  DOM15, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043732         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043736         0;2257  15;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
043743         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
043751         0 ; 0                                % FREE FREE
043753
043753  BDDOM 16

043753         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
043761  DOM16, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
043771         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
043775         0;2257  16;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
044002         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
044010         0 ; 0                                % FREE FREE
044012
044012  BDDOM 17

044012         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
044020  DOM17, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
044030         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
044034         0;2257  17;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
044041         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
044047         0 ; 0                                % FREE FREE
044051
044051  BDDOM 20

044051         BDTMU;0;-12;0;SSBDI;0                % TMSUB,TMR,TTMR,BDTMR,STDRIV,DRIVER
044057  DOM20, 0;0;*-2;2;0;0;BDMFU;0                % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG
044067         0;BDMTR;BDTRA;STRBD                  % HSTAT,MTRANS,M5TRA;DODMA
044073         0;2257  20;0; 0;0                    % RSFLA,PLDNO,DRPRT,DIPOO,
044100         0;0; 0;0; -1; 0                      % OPAIX,ARESZ; DIBRE, DSTSD
044106         0 ; 0                                % FREE FREE
044110
044110
044110  "
044110  9EEHD=*          % UPPER ADDR OF "DISC DATAFIELD", USED BY HARD DISKS
044110  )LINE

044110  %%%%%%%%%%%%  M A C R O E S  -  S I N 1  -  G E N  %%%%%%%%%%%%%%%%%%%%%
044110
044110  %%     MACROES USED ON MASS-GEN
044110  )KILL FELEM NELEM MSDEV MSUNI MSLUN MSODV MSOUN MSOLU
044110  )KILL MTHDS
044110  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
044110
044110
044110  % MACROES FOR "DF" DATAFIELDS:
044110
044110  )MCDEF DFFLD $NUM
DF$NUM , 0;0;*-2;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;RWRT$NUM ;
       0;0;0;0
       0;0;0;0
       0;0;0
]
044110  )MCDEF DFFL2 $NUM
DF$NUM , 0;0;*-2;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;RWR$NUM ;
       0;0;0;0
       0;0;0;0
       0;0;0
]
044110
044110  % MACRO FOR TERMINAL-ACCESS-DEVICE (TAD) VSX
044110  )MCDEF BADDV $NAM
       TAD$NAM ;3;410;0
BD$NAM R,  0;0;33;114020;0;0;IORES

       0;0;0;0
BD$NAM W,  0;0;*-2;114020;0;0;IORES
]
044110
044110  )MCDEF HDDMA $LNR,$HNO,$ICTR,$OCTR

       $ICTR ;0;0;0
       0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0
       0;0;HDMID;HDIBU;HDIFI;HDIFE
       HITMR;0;-6;IOX $HNO ;CTRID;0
HDMI$LNR , 0;0;*-2;202;0;0;RETRA;0;0;HITRN;0;0
       0;0;0;0;0;0;0;0;0            % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32

       $OCTR ;0;0;0
       0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0
       0;0;HDMOD;HDOBU;HDOFI;HDOFE
       HOTMR;0;-12;IOX $HNO ;CTROD;0
HDMO$LNR , 0;0;*-2;202;0;0;RETRA;0;0;HOTRN;0;0
       0;0;0;0;0;0;0;0;0            % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32

]
044110
044110
044110  % MACRO FOR BSC/DMA - IO-DATAFIELD
044110
044110  )MCDEF HDIO $LNR

       0
HDFI$LNR , 0;0;*-2;12200;0;0;IORES
       TEXIT;TEXIT;TEXIT;HDFO$LNR ;0
       0;0;0;0;0;0
       1303+XHDNX;1305+XHDNX;0

       0
HDFO$LNR , 0;0;*-2;12200;0;0;IORES
       TEXIT;TEXIT;TEXIT;HDFI$LNR ;0
       0;0;0;0;0;0
       1304+XHDNX;1306+XHDNX;0

YHDNX=XHDNX+4;)KILL XHDNX;XHDNX=YHDNX;)KILL YHDNX

]
044110
044110  % MACRO FOR GENERAL TERMINAL 1-99
044110
044110  )MCDEF GTERM $NAM,$HNO
       BAK$NAM ;$HNO ;XOFF@10+XON;1
DT$NAM R, 0;0;33;114040;210;44005;IORES

       0;$HNO +4;XOFF@10+XON;0
DT$NAM W, 0;0;*-2;114044;0;0;IORES
XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
]
044110
044110  % MACRO FOR GENERAL TERMINAL  100-128
044110
044110  )MCDEF GXTRM $NAM,$HNO
       BK$NAM ;$HNO ;XOFF@10+XON;1
T$NAM R, 0;0;33;114040;210;44005;IORES

       0;$HNO +4;XOFF@10+XON;0
T$NAM W, 0;0;*-2;114044;0;0;IORES
XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
]
044110
044110  % MACRO FOR TELEFIX TERMINAL PAIR 1-7
044110
044110  )MCDEF TPAIR $NAM
%------------------------------------------
       TFB$NAM ;0;0;1
TB$NAM R, 0;0;33;114040;0;TR$NAM W;IORES

       10000;0;0;0
TB$NAM W, 0;0;*-2;114044;2;TR$NAM R;IORES

       0;0;0;1
TR$NAM R, 0;0;33;114040;0;TB$NAM W;IORES

       10000;0;0;0
TR$NAM W, 0;0;*-2;114044;1;TB$NAM R;IORES
%----------------------------------------
]
044110
044110
044110  % MACRO FOR NOTS CONTROLLER DATAFIELDS
044110  )MCDEF MBNIU $NO,$HDN
%-------------------------------------------------------------------------------
% MBNIU CONTROLLER DATAFIELD, CONTROLLER $NO
%
       MNCTI;0;0;$HDN ;ERRFA;MNMAI        % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
MNDF$NO , 0;0;0;0;0;0;0;1;MNNA$NO ;2;MNID$NO ;MNOD$NO  % NA,NA,NA,TYPRING,MNCFL,MNOUT,MNCBNK,MNCNTREG,MNNAP,MNLNG,MNIDF,MNODF
MNNA$NO , 'ND                  '              % MBNIU NAME
MNID$NO , 0;0;0;0;0;0;0;0                     % TERMINAL INPUT DATAFIELDS
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
MNOD$NO , 0;0;0;0;0;0;0;0                     % TERMINAL OUTPUT DATAFIELDS
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0;0;0;0;0;0
]
044110
044110  % MACRO FOR BIG (NEW/DMA) FLOPPY-DISC  DATAFIELD
044110  )MCDEF GBFLO $NO,$HDN,$MAXU

       0                               % CFLUN
       0                               % USED BY NEW FLOPPY/STREAMER
       0;0;0;0                         % DOORL(4)
       1;1;1;1                         % STEPR(4) (FOR NEW DRIVE, NEW CONTR., 0)
       0;0;0;0                         % PRECP(4)
       1;1;1;1                         % DTRCK(4)
       0;0;0;0;0;0;0;0;0;0;0;0         % FCOMF(14)

       0;0;0;0;0;0                     % FRETURN,FDIMOD,FDIFORM(4)
       1150;2203;3722;  -1             % LFADDR(20)   FORMAT  0- 3
       2320;4406;7644;  -1             %                      4- 7
       2203;3722;  -1;1150             %                     10-13
       4540;7644;  -1;2320             %                     14-17
        400; 200; 100;  -1             % WDSCT(20)
        400; 200; 100;  -1
        400; 200;  -1;1000
        400; 200;  -1;1000
       0;0;0;0;0;0;0;0                 % NFDIADR(4),SHSTAT(4)
       0;$MAXU                          % CERRCODE,MAXUNIT
       0;0;0;0;0;0                     % UNUSED,UNUSED,UNUSED,BUSFL,UNUSED,CFLRG
       0;0;0;0;0;0;0;0                 % TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
       0;0;0;0;-12;0                   % ERCNT,SERRB,WERRB,AERRB,TACNS,TACOUNT
       0;0;BFDIS;FDIBU;FDIFI;FDIFE     % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
       FDTMS;0;-10;$HDN ;TFDIS;0    % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
FDI$NO , 0;0;*-2;402;0;0;RETRA           % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC
       0;0;MTRNS;0;0                   % TRLREG,HSTAT,MTRANS,MRTREF,BREGC
       0;0;0;0;0                       % ABFUN,MEMA1,MEMA2,ABP21,ABP22,
       0;0;0;0;0;0;0                   % ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2,CLEDEV
]
044110
044110  )LINE

044110  %=============================================================================
044110  %      S I N 1 - G E N
044110  %=============================================================================
044110  % ***************        S E  H E R     ***************************
044110  %
044110  % =====>      SE OGS] DP-P2-MASS-GEN:MAC    <==========
044110  %
044110  %                DISKER OG QUE DF FLYTTET DIT
044110  %==============================================================================
044110  % 28.2       S T A N D A R D   D A T A F I E L D S
044110  %
044110
044110  % DATAFIELDS
044110
044110  DEMFI, 0;0;*-2;2;0;0;0;0
044120         0;0;0;0;0;0;0;0
044130         0;0;0;0;0;0;0;0
044140         0;0;0;0;0;0;0;0
044150         0;0;0
044153  "CXCPU
044153         0;0;0;0;0;0;0;0      % USED BY MON FIXC5
044163         0;0;0;0;0;0
044171  "
044171
044171
044171
044171  CLFIE, 0;0;*-2;2             % SWAPPING SEMAPHORE
044175
044175
044175         ENT13
044176  CLCFI, 0;0;0;0;0;0;ICLK      % CLOCK
044205
044205  % ERROR MESSAGE INTERNAL DEVICE
044205  "CXCPU
044205  OERRF, 0;0;*-2;110002;0;0;IORES;TTWPU;OSTDV;CLBUF;IERRF;0
044221
044221  IERRF, 0;0;*-2;110002;0;0;IORES;TTWGE;ISTDV;CLBUF;OERRF;0
044235         BUF;200;0;0;200;0;0;0;5;0;-1;0
044251  "
044251
044251  % INTERNAL DEVICE USED BY ERS (LOG.NO 276)
044251
044251  ERSIN, 0;0;*-2;112100;0;0;IORES;XGTCH;ISTDV;CLBUF
044263         IDXUT;0;BUF;100+100;0;0;100+100;0
044273         0;0;1;0;-1;0
044301
044301  ERSUT, 0;0;*-2;112100;0;0;IORES;XPTCH;OSTDV;INIOS;IDXIN;0
044315         0;0;0;0;0;0
044323         0;0;0;0
044327
044327  % INTERNAL DEVICE USED BY "FTX" ERROR HANDLER (LOG.NO 277)
044327
044327  IDXIN, 0;0;*-2;112100;0;0;IORES;IGTCH;ISTDV;CLBUF
044341         IDXUT;0;BUF;100+100;0;0;100+100;0
044351         0;0;1;0;-1;0
044357
044357  IDXUT, 0;0;*-2;112100;0;0;IORES;IPTCH;OSTDV;INIOS;IDXIN;0
044373         0;0;0;0;0;0
044401         0;0;0;0
044405
044405  3ERRB=*          % BUFFER FOR ERROR MESSAGES FROM FILE SYSTEM TO ERROR DEVICE
044405  *+120/
044525
044525  DPFLG, 0         % DOMINO NAME SERVER SYSTEM RESTART FLAG
044526
044526  %==============================================================================
044526  % 28.3       D F  D A T A F I E L D S
044526  %
044526  % RWFILE FIELD
044526
044526  DFFLD 1

044526  DF1, 0;0;*-2;0;0;0;0;0
044536         0;0;0;0;0;0;0;0
044546         0;0;0;0;0;0;0;0
044556         0;0;0;RWRT1;
044562         0;0;0;0
044566         0;0;0;0
044572         0;0;0
044575
044575  DFFLD 2

044575  DF2, 0;0;*-2;0;0;0;0;0
044605         0;0;0;0;0;0;0;0
044615         0;0;0;0;0;0;0;0
044625         0;0;0;RWRT2;
044631         0;0;0;0
044635         0;0;0;0
044641         0;0;0
044644
044644
044644  "8M1U0
044644  89NMT=0
044644  "8M1U1
044644  )KILL 89NMT; 89NMT=1
044644  "8M1U2
044644  )KILL 89NMT; 89NMT=2
044644  "8M1U3
044644  )KILL 89NMT; 89NMT=3
044644  "8MT1 -8XTRA
044644  DFFLD 3

044644  DF3, 0;0;*-2;0;0;0;0;0
044654         0;0;0;0;0;0;0;0
044664         0;0;0;0;0;0;0;0
044674         0;0;0;RWRT3;
044700         0;0;0;0
044704         0;0;0;0
044710         0;0;0
044713
044713
044713  "8M2U0
044713  99NMT=0
044713  "8M2U1
044713  )KILL 99NMT; 99NMT=1
044713  "8M2U2
044713  )KILL 99NMT; 99NMT=2
044713  "8M2U3
044713  )KILL 99NMT; 99NMT=3
044713  "8MT2 -8XTRA
044713
044713  DFFLD 7

044713  DF7, 0;0;*-2;0;0;0;0;0
044723         0;0;0;0;0;0;0;0
044733         0;0;0;0;0;0;0;0
044743         0;0;0;RWRT7;
044747         0;0;0;0
044753         0;0;0;0
044757         0;0;0
044762
044762  "8DMVC -8XTRA
044762
044762  89NDV=0
044762  DVEBZ=400
044762  DFFLD 5

044762  DF5, 0;0;*-2;0;0;0;0;0
044772         0;0;0;0;0;0;0;0
045002         0;0;0;0;0;0;0;0
045012         0;0;0;RWRT5;
045016         0;0;0;0
045022         0;0;0;0
045026         0;0;0
045031
045031
045031  "8DMV2 -8XTRA
045031  DVBZ2=400
045031  99NDV=0
045031  DFFLD 8

045031  DF8, 0;0;*-2;0;0;0;0;0
045041         0;0;0;0;0;0;0;0
045051         0;0;0;0;0;0;0;0
045061         0;0;0;RWRT8;
045065         0;0;0;0
045071         0;0;0;0
045075         0;0;0
045100
045100
045100  "8F1U0
045100  99NFD=0
045100  "8F1U1
045100  )KILL 99NFD; 99NFD=1
045100  "8F1U2
045100  )KILL 99NFD; 99NFD=2
045100  "8FDI1+8BFD1 -8XTRA
045100
045100  DFFLD 9

045100  DF9, 0;0;*-2;0;0;0;0;0
045110         0;0;0;0;0;0;0;0
045120         0;0;0;0;0;0;0;0
045130         0;0;0;RWRT9;
045134         0;0;0;0
045140         0;0;0;0
045144         0;0;0
045147
045147
045147  "8F2U0
045147  98NFD=0
045147  "8F2U1
045147  )KILL 98NFD; 98NFD=1
045147  "8F2U2
045147  )KILL 98NFD; 98NFD=2
045147
045147  "8FDI2+8BFD2 -8XTRA
045147
045147  DFFL2 10

045147  DF10, 0;0;*-2;0;0;0;0;0
045157         0;0;0;0;0;0;0;0
045167         0;0;0;0;0;0;0;0
045177         0;0;0;RWR10;
045203         0;0;0;0
045207         0;0;0;0
045213         0;0;0
045216
045216
045216  "8DLP1+8DVE1+8NLP1 -8XTRA
045216
045216  DFFL2 11

045216  DF11, 0;0;*-2;0;0;0;0;0
045226         0;0;0;0;0;0;0;0
045236         0;0;0;0;0;0;0;0
045246         0;0;0;RWR11;
045252         0;0;0;0
045256         0;0;0;0
045262         0;0;0
045265
045265
045265  "8DLP2+8DVE2+8NLP2 -8XTRA
045265
045265  DFFL2 12

045265  DF12, 0;0;*-2;0;0;0;0;0
045275         0;0;0;0;0;0;0;0
045305         0;0;0;0;0;0;0;0
045315         0;0;0;RWR12;
045321         0;0;0;0
045325         0;0;0;0
045331         0;0;0
045334
045334
045334  "IBL01 -8XTRA
045334  DFFL2 13

045334  DF13, 0;0;*-2;0;0;0;0;0
045344         0;0;0;0;0;0;0;0
045354         0;0;0;0;0;0;0;0
045364         0;0;0;RWR13;
045370         0;0;0;0
045374         0;0;0;0
045400         0;0;0
045403
045403
045403  DFFL2 20

045403  DF20, 0;0;*-2;0;0;0;0;0
045413         0;0;0;0;0;0;0;0
045423         0;0;0;0;0;0;0;0
045433         0;0;0;RWR20;
045437         0;0;0;0
045443         0;0;0;0
045447         0;0;0
045452
045452
045452  "IBL02 -8XTRA
045452  DFFL2 14

045452  DF14, 0;0;*-2;0;0;0;0;0
045462         0;0;0;0;0;0;0;0
045472         0;0;0;0;0;0;0;0
045502         0;0;0;RWR14;
045506         0;0;0;0
045512         0;0;0;0
045516         0;0;0
045521
045521
045521  DFFL2 21

045521  DF21, 0;0;*-2;0;0;0;0;0
045531         0;0;0;0;0;0;0;0
045541         0;0;0;0;0;0;0;0
045551         0;0;0;RWR21;
045555         0;0;0;0
045561         0;0;0;0
045565         0;0;0
045570
045570
045570  "8HDM1 -8XTRA
045570
045570  DFFL2 25

045570  DF25, 0;0;*-2;0;0;0;0;0
045600         0;0;0;0;0;0;0;0
045610         0;0;0;0;0;0;0;0
045620         0;0;0;RWR25;
045624         0;0;0;0
045630         0;0;0;0
045634         0;0;0
045637
045637
045637  DFFL2 26

045637  DF26, 0;0;*-2;0;0;0;0;0
045647         0;0;0;0;0;0;0;0
045657         0;0;0;0;0;0;0;0
045667         0;0;0;RWR26;
045673         0;0;0;0
045677         0;0;0;0
045703         0;0;0
045706
045706
045706  "8M3U0
045706  87NMT=0
045706  "7S1U0
045706
045706  DFFL2 41

045706  DF41, 0;0;*-2;0;0;0;0;0
045716         0;0;0;0;0;0;0;0
045726         0;0;0;0;0;0;0;0
045736         0;0;0;RWR41;
045742         0;0;0;0
045746         0;0;0;0
045752         0;0;0
045755
045755
045755  "7S2U0
045755
045755  DFFL2 42

045755  DF42, 0;0;*-2;0;0;0;0;0
045765         0;0;0;0;0;0;0;0
045775         0;0;0;0;0;0;0;0
046005         0;0;0;RWR42;
046011         0;0;0;0
046015         0;0;0;0
046021         0;0;0
046024
046024  "
046024  "8RFAC
046024  %    DF DATAFIELD FOR REMOTE FILE ACCESS FROM RT-PROGRAMS
046024  DFRRT, 0;0;*-2;0;0;0;0;0
046034         0;0;0;0;0;0;0;0
046044         0;0;0;0;0;0;0;0
046054         0;0;0;RTRFA;0;0;0;0
046064         0;0;0;0
046070  "8RFAC CXCPU
046070         0;0
046072  "
046072  "8DILG
046072

046072  %==============================================================================
046072  %       D I S C   A C C E S S   L O G   D A T A F I E L D
046072  %
046072  % DISC ACCESS LOG DATAFIELD
046072
046072         DVDIL;DVDIL
046074  DFDIL, 0;0;*-2;2;0;0;RETRA;0
046104         0;MTRNS;0;0;0;0;0;0
046114         0;0;0;0;0;0;0;0;0
046125         0;0;0;0;0;0;0;0
046135         0;0;0;0;0;0;0;0
046145         0;0;0;0;0;0
046153  DALM1, *-5;*-5;*-4;*+1; 2    % PARAMETER LIST FOR MON ABSTR  WHEN WRITING
046160                               % TO DISC LOG FILE
046160  XP131, *+2;*+2               % PARAMETER LIST FOR MON ABSTR WHEN UPDATING
046162                               % DISC ACCESS LOG DATAFIELD
046162  XDILF, 0
046163  DPITB;DILBU+DPITP            % PHYSICAL ADDRESS OF DILBU
046165  DILBU=*; *+16/               % MON ABSTR FROM S-S-P TRANSFERS THIS FIELD TO
046203                               % DFDIL
046203
046203  XDILD, 0;MLDIL               % DATAFIELD FOR LINKING INTO MONITOR QUEUE
046205
046205
046205  "99TM1
046205
046205  % TANDBERG MAG.TAPE DATAFIELD
046205
046205         0;0;0;0;0;0
046213         0;0;0;0;0;0;0;0
046223         0;89NMT;0;0;2;0;4;0
046233         0;0;0;0;0;0;0;0
046243         0;5200;0;0;-4;0
046251         -2;2000;TMAGT;MBUSY;MFINI;MFEIL
046257         MGTMR;0;-10;520;CTRMA;0
046265  TMMT1, 0;0;*-2;1006;0;0;RETRA;0
046275         0;MTRNS;0;0;0;0;0;0
046305         0;0;0;0;0;0;0
046314         MTCLD;100
046316         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
046336         0;0
046340
046340  "99SM1
046340
046340  % STC MAG.TAPE DATAFIELD
046340         0;0;0;0;0;0
046346         0;0;0;0;0;0;0;0
046356         0;89NMT;0;0;2;0;4;0
046366         0;0;0;0;0;0;0;0
046376         0;1610;0;0;-4;0
046404         -2;2000;SMAGT;MBUSY;MFINI;MFEIL
046412         MTMRS;0;-2;520;CTRMA;0
046420  STMT1, 0;0;*-2;1006;0;0;RETRA;0
046430         0;MTRNS;0;0;0;0;0;0
046440         0;0;0;0;0;0;0
046447         MTCLD;6100;0;0;0;0;0;0
046457         0;0;0;0;0;0;0;0
046467         0;0;0;0;0;0;0;0
046477         0;0;0;0;0;0;0;MTDI1
046507         MTDI2;MTDI3;MTDI4;0;0
046514         0;0;0;0;0;0;0;0
046524         0;0;0;0;0;0;0;0
046534         0
046535  )FILL
046535
046535  "99TM2
046535
046535  % TANDBERG MAGTAPE CONTROLLER 2 DATAFIELD
046535
046535         0;0;0;0;0;0
046543         0;0;0;0;0;0;0;0
046553         0;99NMT;0;0;2;0;4;0
046563         0;0;0;0;0;0;0;0
046573         0;5200;0;0;-4;0
046601         -2;2000;TMAGT;MBUSY;MFINI;MFEIL
046607         MGTMR;0;-10;530;CTRMA;0
046615  TMMT2, 0;0;*-2;1006;0;0;RETRA;0;0;MTRNS;0;0
046631         0;0;0;0
046635         0;0;0;0;0;0;0
046644         MTCLD;100
046646         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
046666         0;0
046670
046670  "99SM2
046670
046670  % STC MAG.TAPE CONTROLLER 2 DATAFIELD
046670
046670         0;0;0;0;0;0
046676         0;0;0;0;0;0;0;0
046706         0;99NMT;0;0;2;0;4;0
046716         0;0;0;0;0;0;0;0
046726         0;1610;0;0;-4;0
046734         -2;2000;SMAGT;MBUSY;MFINI;MFEIL
046742         MTMRS;0;-2;530;CTRMA;0
046750  STMT2, 0;0;*-2;1006;0;0;RETRA;0
046760         0;MTRNS;0;0;0;0;0;0
046770         0;0;0;0;0;0;0
046777         MTCLD;6100;0;0;0;0;0;0
047007         0;0;0;0;0;0;0;0
047017         0;0;0;0;0;0;0;0
047027         0;0;0;0;0;0;0;M2DI1
047037         M2DI2;M2DI3;M2DI4;0;0
047044         0;0;0;0;0;0;0;0
047054         0;0;0;0;0;0;0;0
047064         0
047065  )FILL
047065
047065  "99SM1 8M1U0
047065         STMRS;0;-2;0;0
047072  "8M1U0
047072
047072         0
047073  MTDI1, 0;0;*-2;113000;0;0;IORES
047102         CBGET;TEXIT;CAICL;MTDO1;0
047107         0;4000;0;0;4000;0
047115         560;526;0;0;0;0;0
047124         (0;*+3;*-6;*-4;0;0;0;40
047134
047134         0
047135  MTDO1, 0;0;*-2;113000;0;0;IORES
047144         CBPUT;TEXIT;CAOCL;MTDI1;0
047151         0;4000;0;0;4000;0
047157         560;526;0;0;0;0;2000
047166         (1;*+3;*-6;*-4;0;0;0;40
047176
047176  )FILL
047200
047200  "99SM1 8M1U1
047200         STMRS;0;-2;0;0
047205  "8M1U1
047205         0
047206  MTDI2, 0;0;*-2;113000;0;0;IORES
047215         CBGET;TEXIT;CAICL;MTDO2;0
047222         0;4000;0;0;4000;0
047230         560;526;0;1;0;0;0
047237         (0;*+3;*-6;*-4;0;0;0;41
047247
047247         0
047250  MTDO2, 0;0;*-2;113000;0;0;IORES
047257         CBPUT;TEXIT;CAOCL;MTDI2;0
047264         0;4000;0;0;4000;0
047272         560;526;0;1;0;0;2000
047301         (1;*+3;*-6;*-4;0;0;0;41
047311
047311  )FILL
047313
047313
047313  "99SM1 8M1U2
047313         STMRS;0;-2;0;0
047320  "8M1U2
047320         0
047321  MTDI3, 0;0;*-2;113000;0;0;IORES
047330         CBGET;TEXIT;CAICL;MTDO3;0
047335         0;4000;0;0;4000;0
047343         560;526;0;2;0;0;0
047352         (0;*+3;*-6;*-4;0;0;0;25
047362
047362         0
047363  MTDO3, 0;0;*-2;113000;0;0;IORES
047372         CBPUT;TEXIT;CAOCL;MTDI3;0
047377         0;4000;0;0;4000;0
047405         560;526;0;2;0;0;2000
047414         (1;*+3;*-6;*-4;0;0;0;25
047424
047424  )FILL
047426
047426  "99SM1 8M1U3
047426         STMRS;0;-2;0;0
047433  "8M1U3
047433
047433         0
047434  MTDI4, 0;0;*-2;113000;0;0;IORES
047443         CBGET;TEXIT;CAICL;MTDO4;0
047450         0;4000;0;0;4000;0
047456         560;526;0;3;0;0;0
047465         (0;*+3;*-6;*-4;0;0;0;33
047475
047475         0
047476  MTDO4, 0;0;*-2;113000;0;0;IORES
047505         CBPUT;TEXIT;CAOCL;MTDI4;0
047512         0;4000;0;0;4000;0
047520         560;526;0;3;0;0;2000
047527         (1;*+3;*-6;*-4;0;0;0;33
047537
047537  )FILL
047541
047541  "8M2U0
047541  % I/O (UNIT) DATAFIELDS FOR MAG.TAPE CONTROLLER 2
047541
047541  "99SM2 8M2U0
047541         STMRS;0;-2;0;0
047546  "8M2U0
047546         0
047547  M2DI1, 0;0;*-2;113000;0;0;IORES
047556         CBGET;TEXIT;CAICL;M2DO1;0
047563         0;4000;0;0;4000;0
047571         1111;1116;0;0;0;0;0
047600         (0;*+3;*-6;*-4;0;0;0;32
047610
047610         0
047611  M2DO1, 0;0;*-2;113000;0;0;IORES
047620         CBPUT;TEXIT;CAOCL;M2DI1;0
047625         0;4000;0;0;4000;0
047633         1111;1116;0;0;0;0;2000
047642         (1;*+3;*-6;*-4;0;0;0;32
047652  )FILL
047654
047654  "99SM2 8M2U1
047654         STMRS;0;-2;0;0
047661  "8M2U1
047661
047661         0
047662  M2DI2, 0;0;*-2;113000;0;0;IORES
047671         CBGET;TEXIT;CAICL;M2DO2;0
047676         0;4000;0;0;4000;0
047704         1111;1116;0;1;0;0;0
047713         (0;*+3;*-6;*-4;0;0;0;34
047723  )FILL
047724
047724         0
047725  M2DO2, 0;0;*-2;113000;0;0;IORES
047734         CBPUT;TEXIT;CAOCL;M2DI2;0
047741         0;4000;0;0;4000;0
047747         1111;1116;0;1;0;0;2000
047756         (1;*+3;*-6;*-4;0;0;0;34
047766  )FILL
047767  "99SM2 8M2U2
047767         STMRS;0;-2;0;0
047774  "8M2U2
047774         0
047775  M2DI3, 0;0;*-2;113000;0;0;IORES
050004         CBGET;TEXIT;CAICL;M2DO3;0
050011         0;4000;0;0;4000;0
050017         1111;1116;0;2;0;0;0
050026         (0;*+3;*-6;*-4;0;0;0;563
050036
050036         0
050037  M2DO3, 0;0;*-2;113000;0;0;IORES
050046         CBPUT;TEXIT;CAOCL;M2DI3;0
050053         0;4000;0;0;4000;0
050061         1111;1116;0;2;0;0;2000
050070         (1;*+3;*-6;*-4;0;0;0;563
050100  )FILL
050102
050102  "99SM2 8M2U3
050102         STMRS;0;-2;0;0
050107  "8M2U3
050107
050107         0
050110  M2DI4, 0;0;*-2;113000;0;0;IORES
050117         CBGET;TEXIT;CAICL;M2DO4;0
050124         0;4000;0;0;4000;0
050132         1111;1116;0;3;0;0;0
050141         (0;*+3;*-6;*-4;0;0;0;564
050151  )FILL
050152
050152         0
050153  M2DO4, 0;0;*-2;113000;0;0;IORES
050162         CBPUT;TEXIT;CAOCL;M2DI4;0
050167         0;4000;0;0;4000;0
050175         1111;1116;0;3;0;0;2000
050204         (1;*+3;*-6;*-4;0;0;0;564
050214  )FILL
050215
050215  "8M3U0
050215         0
050216  M3DI1, 0;0;*-2;113000;0;0;IORES
050225         CBGET;TEXIT;CAICL;M3DO1;0
050232         0;4000;0;0;4000;0
050240         1231;1127;0;0;0;0;0
050247         (0;*+3;*-6;*-4;0;0;0;1232
050257
050257         0
050260  M3DO1, 0;0;*-2;113000;0;0;IORES
050267         CBPUT;TEXIT;CAOCL;M3DI1;0
050274         0;4000;0;0;4000;0
050302         1231;1127;0;0;0;0;2000
050311         (1;*+3;*-6;*-4;0;0;0;1232
050321  )FILL
050323
050323  "8SCSI
050323  %
050323  %  TO CHANGE SCSI DEVICE NUMBER THE FOLLOWING LOCATIONS MUST BE UPDATED:
050323  %
050323  %     SCDVD(y) IN SCSIx MUST POINT TO NODE DATAFIELD
050323  %     (ADDRESS FOUND IN LOCATION SCDFA IN DEVICE DATAFIELD)
050323  %
050323  %     SCIDN IN DEVICE DATAFIELD MUST CONTAIN THE FOLLOWING:
050323  %        BIT 0- 3: NODE NUMBER
050323  %        BIT 4-17: DEVICE NUMBER OF CORRESPONDING BUS DATAFIELD
050323  %
050323  %     SUDDF IN LUN DATAFIELD MUST POINT TO BUS DATAFIELD
050323  %
050323  %     SUDLU IN LUN DATAFIELD MUST CONTAIN NODE IN BIT 17-14
050323  %
050323  %     x = HOST INTERFACE NUMBER, y = SCSI DEVICE NUMBER
050323  %
050323  SCFQP, 0                               % SCSI LEVEL 11 FINISHED QUEUE
050324  SCRSQ, 0                               % SCSI LEVEL 11 DRIVER RESTART QUEUE
050325
050325  SCCLR, TRR CCLR                        % CLEAR CACHE INSTRUCTION FOR ND-100
050326
050326  SRTMR, -5                              % RESET DEVICE SETTLE TIME
050327  SLTMR, -74                             % POWER DOWN DEVICE START TIME
050330
050330
050330  "8SCS1+8ZSCS
050330  % SCSI HOST INTERFACE 1 DATAFIELD
050330         0;0; 0;0;0;-1;0;0;310           % SCPMB,SCSSR,SCNIS,SCCCW,SCEIM,SCISR,WATFS
050341         XBOOT;0;0;0;0;0;0;0             % SCDVD
050351         0;0;0;0;0;0                     % LMSGO,CMSGO,CMSGI,SCCSU,SCWAQ,SCTQP
050357         0;0; 0;0; SWT11;0;0;0           % SCCDP,SCCBC,SCWTI,SCRSL,NCROK,SCRCO
050367         0;0;0;0;0                       % SCRLR,SCRXR,SCEM1,SCEM2,SCEM3
050374         0;0;0;0;0;0;0;0                 % SCBTU,BUSFL
050404         0;0;0;0;0;0;0;0
050414         20;0;-2;0;0;1000;0;0
050424         0;0;SCTRS;0;-6;144300;CTRSC;SCINT
050434  SCSI1, 0;0;*-2;1006;0;0;RETRA;0
050444         0;MSTRN;0;0;0;0;0;0             % HSTAT,MTRAN,MRTRE,BREGC,ABFUN,MEMA1,MEMA2,ABP21 ABP22
050454         0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32
050461  )KILL XBOOT                            % DEFINED IN SIN1-GEN
050461  "8SCS2
050461  % SCSI HOST INTERFACE 2 DATAFIELD
050461         0;0; 0;0;0;-1;0;0;310           % SCPMB,SCSSR,SCNIS,SCCCW,SCEIM,SCISR,WATFS
050472         0;0;0;0;0;0;0;0                 % SCDVD
050502         0;0;0;0;0;0                     % LMSGO,CMSGO,CMSGI,SCCSU,SCWAQ,SCTQP
050510         0;0; 0;0; SWT11;0;0;0           % SCCDP,SCCBC,SCWTI,SCRSL,NCROK,SCRCO
050520         0;0;0;0;0                       % SCRLR,SCRXR,SCEM1,SCEM2,SCEM3
050525         0;0;0;0;0;0;0;0                 % SCBTU,BUSFL
050535         0;0;0;0;0;0;0;0
050545         20;0;-2;0;0;1000;0;0
050555         0;0;SCTRS;0;-6;144400;CTRSC;SCINT
050565  SCSI2, 0;0;*-2;1006;0;0;RETRA;0
050575         0;MSTRN;0;0;0;0;0;0             % HSTAT,MTRAN,MRTRE,BREGC,ABFUN,MEMA1,MEMA2,ABP21 ABP22
050605         0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32
050612  "8SCS3
050612  % SCSI HOST INTERFACE 3 DATAFIELD
050612         0;0; 0;0;0;-1;0;0;310           % SCPMB,SCSSR,SCNIS,SCCCW,SCEIM,SCISR,WATFS
050623         0;0;0;0;0;0;0;0                 % SCDVD
050633         0;0;0;0;0;0                     % LMSGO,CMSGO,CMSGI,SCCSU,SCWAQ,SCTQP
050641         0;0; 0;0; SWT11;0;0;0           % SCCDP,SCCBC,SCWTI,SCRSL,NCROK,SCRCO
050651         0;0;0;0;0                       % SCRLR,SCRXR,SCEM1,SCEM2,SCEM3
050656         0;0;0;0;0;0;0;0                 % SCBTU,BUSFL
050666         0;0;0;0;0;0;0;0
050676         20;0;-2;0;0;1000;0;0
050706         0;0;SCTRS;0;-6;144500;CTRSC;SCINT
050716  SCSI3, 0;0;*-2;1006;0;0;RETRA;0
050726         0;MSTRN;0;0;0;0;0;0             % HSTAT,MTRAN,MRTRE,BREGC,ABFUN,MEMA1,MEMA2,ABP21 ABP22
050736         0;0;0;0;0                       % ABP22,ABP31,ABP32,ABA31,ABA32
050743  "8SCSI
050743  SCSDB=*            % BEGINNING OF SCSI STREAMER DATAFIELDS
050743  "7S1U0
050743  % SCSI STREAMER 1 DATAFIELD
050743         0;0;0;0;0                           % SRERS,SRERC,SWERS,SWERC,CERRCODE
050750         0;0;0;0;0;0                         % CPFUN,CPDEV,CPSTS,CPBLS,CPAM1,CPAM2
050756         0; 0;0; 0;0; 0;0                    % EXTRA ABSTR PARAMETER BLOCK
050765         0;0;0;0;0;0                         % OPSTA,CUROP,STSTA,P3LUN,CFORM,REWST
050773         -10;0;0;0;0;0;0;0                   % TACNS,TACOU,,
051003         SST1N;0;0;0;SCSTR;0                 % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
051011  SCST1, 0;0;*-2;1002;0;0;RETRA;0;0          % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
051022         MSTRN;0;0                           % MTRANS,MRTREF,BREGC
051025         0; 0;0; 0;0; 0;0; 0;0; 0;0          % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
051040         0
051041
051041         0
051042  SS1I0, 0;0;*-2;002000;0;0;IORES
051051         CBGET;TEXIT;CAICL;SS1O0;0
051056         0;0;0;0;0;0
051064         2206;2230;0;0;0;0;1000
051073         (0;*+3;*-6;*-4;0;0;0;40
051103
051103         0
051104  SS1O0, 0;0;*-2;002000;0;0;IORES
051113         CBPUT;TEXIT;CAOCL;SS1I0;0
051120         0;0;0;0;0;0
051126         2206;2230;0;0;0;0;1000
051135         (1;*+3;*-6;*-4;0;0;0;40
051145
051145  S1U0R, (2226; S000; SDUMM                  % RESERVATION PARAMETER LIST
051150  )FILL
051153
051153
051153  % SCSI STREAMER 1 LUN DATAFIELDS
051153  SST1N, 1                                   % MAX NUMBER OF LUNS
051154         000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0  % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
051170         0; 0;0; 0;0; 0;0                    % ABFUN,MEMAD,ABPA2,ABPA3
051177         077400;0;0;0;0;0;0;0                % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
051207         0;0;0;0;0;0                         % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
051215         0; 0;0; 0                           % SURSZ,SMBPA,SUDBR
051221         0;0;0;0                             % SUTLR,SURTC,SUSCO,SUSTR
051225
051225  )KILL SST1N
051225
051225
051225  "7S2U0
051225  % SCSI STREAMER 2 DATAFIELD
051225         0;0;0;0;0                           % SRERS,SRERC,SWERS,SWERC,CERRCODE
051232         0;0;0;0;0;0                         % CPFUN,CPDEV,CPSTS,CPBLS,CPAM1,CPAM2
051240         0; 0;0; 0;0; 0;0                    % EXTRA ABSTR PARAMETER BLOCK
051247         0;0;0;0;0;0                         % OPSTA,CUROP,STSTA,P3LUN,CFORM,REWST
051255         -10;0;0;0;0;0;0;0                   % TACNS,TACOU,,
051265         SST2N;0;0;0;SCSTR;0                 % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
051273  SCST2, 0;0;*-2;1002;0;0;RETRA;0;0          % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
051304         MSTRN;0;0                           % MTRANS,MRTREF,BREGC
051307         0; 0;0; 0;0; 0;0; 0;0; 0;0          % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
051322         0
051323
051323         0
051324  SS2I0, 0;0;*-2;002000;0;0;IORES
051333         CBGET;TEXIT;CAICL;SS2O0;0
051340         0;0;0;0;0;0
051346         2207;2231;0;0;0;0;1000
051355         (0;*+3;*-6;*-4;0;0;0;40
051365
051365         0
051366  SS2O0, 0;0;*-2;002000;0;0;IORES
051375         CBPUT;TEXIT;CAOCL;SS2I0;0
051402         0;0;0;0;0;0
051410         2207;2231;0;0;0;0;1000
051417         (1;*+3;*-6;*-4;0;0;0;40
051427
051427  S2U0R, (2227; S000; SDUMM                  % RESERVATION PARAMETER LIST
051432  )FILL
051435
051435  % SCSI STREAMER 2 LUN DATAFIELDS
051435  SST2N, 1                                   % MAX NUMBER OF LUNS
051436         000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0  % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
051452         0; 0;0; 0;0; 0;0                    % ABFUN,MEMAD,ABPA2,ABPA3
051461         077400;0;0;0;0;0;0;0                % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
051471         0;0;0;0;0;0                         % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
051477         0; 0;0; 0                           % SURSZ,SMBPA,SUDBR
051503         0;0;0;0                             % SUTLR,SURTC,SUSCO,SUSTR
051507
051507  )KILL SST2N
051507  "8SCSI
051507  SCSDE=*            % END OF SCSI STREAMER DATAFIELDS
051507  SCMDB=*            % BEGINNING OF SCSI MAGTAPE DATAFIELDS
051507
051507  "9M1U0
051507  % SCSI MAGTAPE 1 DATAFIELD
051507         0                                   % CERRCODE
051510         0;0;0;0;0;0                         % CPFUN,CPDEV,CPSTS,CPBLS,CPAM1,CPAM2
051516         0; 0;0; 0;0; 0;0                    % EXTRA ABSTR PARAMETER BLOCK
051525         0;0;0;0;0;0                         % OPSTA,CUROP,STSTA,P3LUN,CFORM,REWST
051533         -10;0;0;0;SCLLD;0;0;0               % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH
051543         SMT1N;0;0;0;SCMAG;0                 % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
051551  SCMT1, 0;0;*-2;1006;0;0;RETRA;0;0          % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
051562         MSTRN;0;0                           % MTRANS,MRTREF,BREGC
051565         0; 0;0; 0;0; 0;0; 0;0; 0;0          % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
051600         SCCLD;0                             % CLEDEV,BADTAPE
051602         0;0;0;0; 0;0;0;0; 0;0;0;0; 0;0;0;0  % RHSTAT,RERRCOUNT,WHSTAT,WERRCOUNT
051622
051622  % SCSI MAGTAPE 1 LUN DATAFIELDS
051622  SMT1N, 1                                   % MAX NUMBER OF LUNS
051623         000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0  % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
051637         0; 0;0; 0;0; 0;0                    % ABFUN,MEMAD,ABPA2,ABPA3
051646         077400;0;0;0;0;0;0;0                % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
051656         0;0;0;0;0;0                         % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
051664         0; 0;0; 0                           % SURSZ,SMBPA,SUDBR
051670         0;0;0;0                             % SUTLR,SURTC,SUSCO,SUSTR
051674
051674  )KILL SMT1N
051674
051674  "9M2U0
051674  % SCSI MAGTAPE 2 DATAFIELD
051674         0                                   % CERRCODE
051675         0;0;0;0;0;0                         % CPFUN,CPDEV,CPSTS,CPBLS,CPAM1,CPAM2
051703         0; 0;0; 0;0; 0;0                    % EXTRA ABSTR PARAMETER BLOCK
051712         0;0;0;0;0;0                         % OPSTA,CUROP,STSTA,P3LUN,CFORM,REWST
051720         -10;0;0;0;SCLLD;0;0;0               % TACNS,TACOU,SCTRG,SCOCW,TRANSF,SCULI,FINISH
051730         SMT2N;0;0;0;SCMAG;0                 % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
051736  SCMT2, 0;0;*-2;1006;0;0;RETRA;0;0          % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
051747         MSTRN;0;0                           % MTRANS,MRTREF,BREGC
051752         0; 0;0; 0;0; 0;0; 0;0; 0;0          % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
051765         SCCLD;0                             % CLEDEV,BADTAPE
051767         0;0;0;0; 0;0;0;0; 0;0;0;0; 0;0;0;0  % RHSTAT,RERRCOUNT,WHSTAT,WERRCOUNT
052007
052007  % SCSI MAGTAPE 2 LUN DATAFIELDS
052007  SMT2N, 1                                   % MAX NUMBER OF LUNS
052010         000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0  % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
052024         0; 0;0; 0;0; 0;0                    % ABFUN,MEMAD,ABPA2,ABPA3
052033         077400;0;0;0;0;0;0;0                % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
052043         0;0;0;0;0;0                         % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
052051         0; 0;0; 0                           % SURSZ,SMBPA,SUDBR
052055         0;0;0;0                             % SUTLR,SURTC,SUSCO,SUSTR
052061
052061  )KILL SMT2N
052061
052061  "9M3U0
052061  % SCSI MAGTAPE 3 DATAFIELD
052061         0                                   % CERRCODE
052062         0;0;0;0;0;0                         % CPFUN,CPDEV,CPSTS,CPBLS,CPAM1,CPAM2
052070         0; 0;0; 0;0; 0;0                    % EXTRA ABSTR PARAMETER BLOCK
052077         0;0;0;0;0;0                         % OPSTA,CUROP,STSTA,P3LUN,CFORM,REWST
052105         -10;0;0;0;SCLLD;0;0;0               % TACNS,TACOU,SCTRG,SCOCW,TRNSF,SCULI,FINISH
052115         SMT3N;0;0;0;SCMAG;0                 % SCDFA,TMR,SCIDN,HDEV,STDRIV,DRIVER
052123  SCMT3, 0;0;*-2;1006;0;0;RETRA;0;0          % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC,TRLREG,HSTAT
052134         MSTRN;0;0                           % MTRANS,MRTREF,BREGC
052137         0; 0;0; 0;0; 0;0; 0;0; 0;0          % ABFUN,MEMAD,ABPA2,ABPA3,ABAD3,CMADR
052152         SCCLD;0                             % CLEDEV,BADTAPE
052154         0;0;0;0; 0;0;0;0; 0;0;0;0; 0;0;0;0  % RHSTAT,RERRCOUNT,WHSTAT,WERRCOUNT
052174
052174  % SCSI MAGTAPE 3 LUN DATAFIELDS
052174  SMT3N, 1                                   % MAX NUMBER OF LUNS
052175         000000; 0;0; 0;0; 0;0; 0;0; 0;0; 0  % SUDLU,SUIDP,SUIBC,SUCMA,SUSDP,SUSBP,SUSTA
052211         0; 0;0; 0;0; 0;0                    % ABFUN,MEMAD,ABPA2,ABPA3
052220         077400;0;0;0;0;0;0;0                % SUTYP,SUSI1,SUSI2,SUSI3,SULINK,SUCON,SUTHS,SULRG
052230         0;0;0;0;0;0                         % SUTRG,SUDAQ,SUTMR,SUICO,SUWQP,SUDDF
052236         0; 0;0; 0                           % SURSZ,SMBPA,SUDBR
052242         0;0;0;0                             % SUTLR,SURTC,SUSCO,SUSTR
052246
052246  )KILL SMT3N
052246
052246  "8SCSI
052246  SCMDE=*            % END OF SCSI MAGTAPE DATAFIELDS
052246
052246  SCBDF, 2202; SCSI1; 2203; SCSI2            % HOST INTERFACE (BUS) DATAFIELDS
052252         2204; SCSI3; 2205; SCSI4
052256
052256  SCDDF, 2210; SCDI1; 2211; SCDI2            % DISK DATAFIELDS
052262         2212; SCDI3; 2213; SCDI4
052266         2214; SCDI5; 2215; SCDI6
052272         2216; SCDI7; 2217; SCDI8
052276         2220; SCDI9; 2221; SCD10
052302         2222; SCD11; 2223; SCD12
052306         2224; SCD13; 2225; SCD14
052312
052312  SCODF, 2232; SCOD1; 2233; SCOD2            % OPTICAL DISK DATAFIELDS
052316         2234; SCOD3; 2235; SCOD4
052322
052322  SCSDF, 2206; SCST1; 2207; SCST2            % STREAMER DATAFIELDS
052326
052326  SCTDF,  560; SCMT1; 1111; SCMT2            % MAGTAPE DATAFIELDS
052332         1231; SCMT3; 1224; SCMT4
052336
052336         -1                                  % END MARKER
052337  "
052337
052337
052337  "8DMVC
052337
052337  % DATAFIELD FOR VERSATEC - DMA
052337
052337         6000;0;*-2
052342         0;0;0;0;0;0;0;0
052352         0;89NDV;0;0;0;0;0;0
052362         0;0;0;0;0;0;0;0
052372         0;0;0;0;-5;0
052400         0;DVEBZ;VERDR;BUSYV;FINIV;FEILV
052406         VETMR;0;-200;600;CTRVE;0
052414  VEFIE, 0;0;*-2;6;0;0;RETRA;0;0;MTRNS;0;0
052430         0;0;0;0
052434         0;0;0;0;0;0;0
052443         VDMAC;VEDO1+37
052445
052445  % OUTBT DATAFIELDS FOR VERSATEC - DMA
052445
052445         0
052446  VEDO1, 0;0;*-2;112000;0;0;IORES
052455         CBPUT;TEXIT;VEICL;0;0
052462         0;DVEBZ+DVEBZ;0;0;DVEBZ+DVEBZ;0
052470         577;576;0;0;0;0;DVEBZ
052477         (1;*+3;*-6;*-4;0;0;11;22
052507  )FILL
052510
052510
052510
052510
052510  "8DMV2
052510
052510  % DATAFIELD FOR VERSATEC CONTROLLER 2 - DMA
052510
052510         6000;0;*-2
052513         0;0;0;0;0;0;0;0
052523         0;99NDV;0;0;0;0;0;0
052533         0;0;0;0;0;0;0;0
052543         0;0;0;0;-5;0
052551         0;DVBZ2;VERDR;BUSYV;FINIV;FEILV
052557         VETMR;0;-200;1600;CTRVE;0
052565  VE2FI, 0;0;*-2;6;0;0;RETRA;0;0;MTRNS;0;0
052601         0;0;0;0
052605         0;0;0;0;0;0;0
052614         VDMAC; VEDO2+37
052616
052616         0
052617  VEDO2, 0;0;*-2;112000;0;0;IORES
052626         CBPUT;TEXIT;VEICL;0;0
052633         0;DVBZ2+DVBZ2;0;0;DVBZ2+DVBZ2;0
052641         1125;1126;0;0;0;0;DVBZ2
052650         (1;*+3;*-6;*-4;0;0;11;23
052660  )FILL
052661
052661  "8BFD1
052661  % NEW FLOPPY DISC 1 DATAFIELD
052661  GBFLO D1,IOX 1560,99NFD

052661
052661         0                               % CFLUN
052662         0                               % USED BY NEW FLOPPY/STREAMER
052663         0;0;0;0                         % DOORL(4)
052667         1;1;1;1                         % STEPR(4) (FOR NEW DRIVE, NEW CONTR., 0)
052673         0;0;0;0                         % PRECP(4)
052677         1;1;1;1                         % DTRCK(4)
052703         0;0;0;0;0;0;0;0;0;0;0;0         % FCOMF(14)
052717
052717         0;0;0;0;0;0                     % FRETURN,FDIMOD,FDIFORM(4)
052725         1150;2203;3722;  -1             % LFADDR(20)   FORMAT  0- 3
052731         2320;4406;7644;  -1             %                      4- 7
052735         2203;3722;  -1;1150             %                     10-13
052741         4540;7644;  -1;2320             %                     14-17
052745          400; 200; 100;  -1             % WDSCT(20)
052751          400; 200; 100;  -1
052755          400; 200;  -1;1000
052761          400; 200;  -1;1000
052765         0;0;0;0;0;0;0;0                 % NFDIADR(4),SHSTAT(4)
052775         0;99NFD                         % CERRCODE,MAXUNIT
052777         0;0;0;0;0;0                     % UNUSED,UNUSED,UNUSED,BUSFL,UNUSED,CFLRG
053005         0;0;0;0;0;0;0;0                 % TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
053015         0;0;0;0;-12;0                   % ERCNT,SERRB,WERRB,AERRB,TACNS,TACOUNT
053023         0;0;BFDIS;FDIBU;FDIFI;FDIFE     % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
053031         FDTMS;0;-10;IOX 1560;TFDIS;0    % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
053037  FDID1, 0;0;*-2;402;0;0;RETRA           % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC
053046         0;0;MTRNS;0;0                   % TRLREG,HSTAT,MTRANS,MRTREF,BREGC
053053         0;0;0;0;0                       % ABFUN,MEMA1,MEMA2,ABP21,ABP22,
053060         0;0;0;0;0;0;0                   % ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2,CLEDEV
053067
053067  "8F1U0
053067
053067         0
053070  F1U0I, 0;0;*-2;112400;0;0;IORES
053077         CBGET;TEXIT;CAICL;F1U0O;0
053104         0;0;0;0;0;0
053112         1145;1146;0;0;0;0;0
053121         (0;*+3;*+6;*-4;0;0;0;1000;0
053132
053132         0
053133  F1U0O, 0;0;*-2;112400;0;0;IORES
053142         CBPUT;TEXIT;CAOCL;F1U0I;0
053147         0;0;0;0;0;0
053155         1145;1146;0;0;0;0;0
053164         (1;*+3;*+6;*-4;0;0;0;1000;0
053175  )FILL
053177
053177  "8F1U1
053177         0
053200  F1U1I, 0;0;*-2;112400;0;0;IORES
053207         CBGET;TEXIT;CAICL;F1U1O;0
053214         0;0;0;0;0;0
053222         1145;1146;0;1;0;0;0
053231         (100;*+3;*+6;*-4;0;0;0;1001;0
053242
053242         0
053243  F1U1O, 0;0;*-2;112400;0;0;IORES
053252         CBPUT;TEXIT;CAOCL;F1U1I;0
053257         0;0;0;0;0;0
053265         1145;1146;0;1;0;0;0
053274         (101;*+3;*+6;*-4;0;0;0;1001;0
053305  )FILL
053307
053307  "8F1U2
053307
053307         0
053310  F1U2I, 0;0;*-2;112400;0;0;IORES
053317         CBGET;TEXIT;CAICL;F1U2O;0
053324         0;0;0;0;0;0
053332         1145;1146;0;2;0;0;0
053341         (200;*+3;*+6;*-4;0;0;0;1002;0
053352
053352         0
053353  F1U2O, 0;0;*-2;112400;0;0;IORES
053362         CBPUT;TEXIT;CAOCL;F1U2I;0
053367         0;0;0;0;0;0
053375         1145;1146;0;2;0;0;0
053404         (201;*+3;*+6;*-4;0;0;0;1002;0
053415  )FILL
053417
053417  "8BFD2
053417  % NEW FLOPPY DISC 2 DATAFIELDS
053417  GBFLO D2,IOX 1570,98NFD

053417
053417         0                               % CFLUN
053420         0                               % USED BY NEW FLOPPY/STREAMER
053421         0;0;0;0                         % DOORL(4)
053425         1;1;1;1                         % STEPR(4) (FOR NEW DRIVE, NEW CONTR., 0)
053431         0;0;0;0                         % PRECP(4)
053435         1;1;1;1                         % DTRCK(4)
053441         0;0;0;0;0;0;0;0;0;0;0;0         % FCOMF(14)
053455
053455         0;0;0;0;0;0                     % FRETURN,FDIMOD,FDIFORM(4)
053463         1150;2203;3722;  -1             % LFADDR(20)   FORMAT  0- 3
053467         2320;4406;7644;  -1             %                      4- 7
053473         2203;3722;  -1;1150             %                     10-13
053477         4540;7644;  -1;2320             %                     14-17
053503          400; 200; 100;  -1             % WDSCT(20)
053507          400; 200; 100;  -1
053513          400; 200;  -1;1000
053517          400; 200;  -1;1000
053523         0;0;0;0;0;0;0;0                 % NFDIADR(4),SHSTAT(4)
053533         0;98NFD                         % CERRCODE,MAXUNIT
053535         0;0;0;0;0;0                     % UNUSED,UNUSED,UNUSED,BUSFL,UNUSED,CFLRG
053543         0;0;0;0;0;0;0;0                 % TRG,ARG,DRG,XRG,CTRG,CARG,CDRG,CXRG
053553         0;0;0;0;-12;0                   % ERCNT,SERRB,WERRB,AERRB,TACNS,TACOUNT
053561         0;0;BFDIS;FDIBU;FDIFI;FDIFE     % COMFL,BLSZ,TRNSF,BUSY,FINISH,ERROR
053567         FDTMS;0;-10;IOX 1570;TFDIS;0    % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
053575  FDID2, 0;0;*-2;402;0;0;RETRA           % RESLINK,RTRES,BWLINK,TYPRING,ISTATE,MLINK,MFUNC
053604         0;0;MTRNS;0;0                   % TRLREG,HSTAT,MTRANS,MRTREF,BREGC
053611         0;0;0;0;0                       % ABFUN,MEMA1,MEMA2,ABP21,ABP22,
053616         0;0;0;0;0;0;0                   % ABP31,ABP32,ABA31,ABA32,CMAD1,CMAD2,CLEDEV
053625
053625  "8F2U0
053625
053625         0
053626  F2U0I, 0;0;*-2;112400;0;0;IORES
053635         CBGET;TEXIT;CAICL;F2U0O;0
053642         0;0;0;0;0;0
053650         1156;1157;0;0;0;0;0
053657         (0;*+3;*+6;*-4;0;0;0;1003;0
053670
053670         0
053671  F2U0O, 0;0;*-2;112400;0;0;IORES
053700         CBPUT;TEXIT;CAOCL;F2U0I;0
053705         0;0;0;0;0;0
053713         1156;1157;0;0;0;0;0
053722         (1;*+3;*+6;*-4;0;0;0;1003;0
053733  )FILL
053735
053735  "8F2U1
053735
053735         0
053736  F2U1I, 0;0;*-2;112400;0;0;IORES
053745         CBGET;TEXIT;CAICL;F2U1O;0
053752         0;0;0;0;0;0
053760         1156;1157;0;1;0;0;0
053767         (100;*+3;*+6;*-4;0;0;0;1004;0
054000
054000         0
054001  F2U1O, 0;0;*-2;112400;0;0;IORES
054010         CBPUT;TEXIT;CAOCL;F2U1I;0
054015         0;0;0;0;0;0
054023         1156;1157;0;1;0;0;0
054032         (101;*+3;*+6;*-4;0;0;0;1004;0
054043  )FILL
054045
054045  "8F2U2
054045
054045         0
054046  F2U2I, 0;0;*-2;112400;0;0;IORES
054055         CBGET;TEXIT;CAICL;F2U2O;0
054062         0;0;0;0;0;0
054070         1156;1157;0;2;0;0;0
054077         (200;*+3;*+6;*-4;0;0;0;1005;0
054110
054110         0
054111  F2U2O, 0;0;*-2;112400;0;0;IORES
054120         CBPUT;TEXIT;CAOCL;F2U2I;0
054125         0;0;0;0;0;0
054133         1156;1157;0;2;0;0;0
054142         (201;*+3;*+6;*-4;0;0;0;1005;0
054153  )FILL
054155
054155  "
054155
054155  "8N500
054155

054155  %==========================================================================
054155  %       N D - 5 0 0
054155  %
054155  %      MACRO FOR ND-500 CPU SPECIFIC DATA FIELD                      %M5
054155
054155  )MCDEF M5CPU $NO,$500DV

)KILL E5CPU
ZXC=*; N500D-24/$NO ;ZXC/
)KILL ZXC
       0
       $NO ;0;ENDCC;-1
       0;0;N500T;0;-3;$500DV ;N500;N500
E5CPU=*
5CPU$NO , 0;0;*-2;2;0;0;0;0
       0;1@$NO ;200;0;-1;0;0;0
       0;-1;-1;-10;0;0;0;0
       0
]
054155
054155  %=============================================================================
054155  %
054155  %      N 5 0 0   D A T A F I E L D                         %M5
054155
054155         0;-1;-1;0
054161         0;0;-1;-1;0;0;0;0;
054171         0;0;0;0;0;21;0;0
054201         0;0;0;S500S;0;0;62;0
054211  N500D, 0;0;*-2;2;0;0;0;0
054221         0;0;0;0;0;0;0;0
054231         0;0;0;0;0;0;0;0
054241         0;0;0;0;0;0;0;0
054251         0;0;0;0;0;0;0;0
054261         0;0;0;0;0;0;0;0
054271         -1;0;0;0;0;0;0;0
054301         0;0;0;0;0;0;0;0
054311         0;0;0;0;0;0;0;0
054321         0;-1;100;104;0;0;0;0
054331         0;0;0;0
054335         5GNSE;RESNA;RELNA;ROBJE;WOBJE
054342         5PUTL;SETIO;ACTDR;DIRTA;NAMTA;5GETL;LOGPH;5ATRA
054352         MERRC;ESCON;ESCOF;CUSER;TTNO;F5DSG;GUSEN;MDEAB
054362         WORKA;FSYSI;SEGMO;TTIFI;BCHFL;PASST;GFILI;GFIAC
054372         DIRUN;CCTAB;GETCA;GPUPI;MX5PR;5GDSE;5GSYD;XDEAB
054402         RSGMO;1INSE;CPNT;TS3CO;CLADB;5DFRE;5DLRE;CT500
054412         XLOCK;XUNLO;5S1TS;5R1TS;S5TSL;WBACK;RSTAR;RTPWO
054422         5DTUP;5DBFL;NINIT;ENPCA;DISPC
054427
054427
054427  %=============================================================================
054427  %
054427  %       N D - 5 0 0   C P U   D A T A F I E L D S
054427  %
054427  S5CPU=*+15
054427  E5CPU=*
054427  "8CP51; M5CPU 1,60

054427
054427  )KILL E5CPU
054427  ZXC=*; N500D-24/1;ZXC/
054427  )KILL ZXC
054427         0
054430         1;0;ENDCC;-1
054434         0;0;N500T;0;-3;60;N500;N500
054444  E5CPU=*
054444  5CPU1, 0;0;*-2;2;0;0;0;0
054454         0;1@1;200;0;-1;0;0;0
054464         0;-1;-1;-10;0;0;0;0
054474         0
054475
054475  "8CP52; M5CPU 2,1060

054475
054475  )KILL E5CPU
054475  ZXC=*; N500D-24/2;ZXC/
054475  )KILL ZXC
054475         0
054476         2;0;ENDCC;-1
054502         0;0;N500T;0;-3;1060;N500;N500
054512  E5CPU=*
054512  5CPU2, 0;0;*-2;2;0;0;0;0
054522         0;1@2;200;0;-1;0;0;0
054532         0;-1;-1;-10;0;0;0;0
054542         0
054543
054543  "8CP53; M5CPU 3,660

054543
054543  )KILL E5CPU
054543  ZXC=*; N500D-24/3;ZXC/
054543  )KILL ZXC
054543         0
054544         3;0;ENDCC;-1
054550         0;0;N500T;0;-3;660;N500;N500
054560  E5CPU=*
054560  5CPU3, 0;0;*-2;2;0;0;0;0
054570         0;1@3;200;0;-1;0;0;0
054600         0;-1;-1;-10;0;0;0;0
054610         0
054611
054611  "8CP54; M5CPU 4,760

054611
054611  )KILL E5CPU
054611  ZXC=*; N500D-24/4;ZXC/
054611  )KILL ZXC
054611         0
054612         4;0;ENDCC;-1
054616         0;0;N500T;0;-3;760;N500;N500
054626  E5CPU=*
054626  5CPU4, 0;0;*-2;2;0;0;0;0
054636         0;1@4;200;0;-1;0;0;0
054646         0;-1;-1;-10;0;0;0;0
054656         0
054657
054657  "8N500
054657  )KILL M5CPU
054657  "
054657
054657  %============================================================================
054657  %            D A T A F I E L D S   F O R   E X A B S T R
054657  %
054657  "CXCPU
054657  FPL3A=*
054657         0;0;*-2;2;0;0;0;0
054667         0;0;0;0;0;0;0;0
054677         0;0;0;0;0;*-21;*-21;*-7;*-6
054710         0;0;0;0;0
054715
054715         0;0;*-2;2;0;0;0;0
054725         0;0;0;0;0;0;0;0
054735         0;0;0;0;0;*-21;*-21;*-7;*-6
054746         0;0;0;0;0
054753
054753         0;0;*-2;2;0;0;0;0
054763         0;0;0;0;0;0;0;0
054773         0;0;0;0;0;*-21;*-21;*-7;*-6
055004         0;0;0;0;0
055011
055011         0;0;*-2;2;0;0;0;0
055021         0;0;0;0;0;0;0;0
055031         0;0;0;0;0;*-21;*-21;*-7;*-6
055042         0;0;0;0;0
055047
055047         0;0;*-2;2;0;0;0;0
055057         0;0;0;0;0;0;0;0
055067         0;0;0;0;0;*-21;*-21;*-7;*-6
055100         0;0;0;0;0
055105
055105  LPL3A=*
055105         0;0;*-2;2
055111  "
055111  %=============================================================================
055111  "8HDM1+8HDM2+8HDM3+8HDM4+8HDM5+8HDM6 CXCPU
055111  XHDNX=0
055111  "8HDM1
055111
055111  % DATAFIELD FOR BSC-DMA
055111
055111  HDDMA 1,560,100,100

055111
055111         100;0;0;0
055115         0;0;0;0;0;0
055123         0;0;0;0;0;0;0;0
055133         0;0;0;0;0;0
055141         0;0;HDMID;HDIBU;HDIFI;HDIFE
055147         HITMR;0;-6;IOX 560;CTRID;0
055155  HDMI1, 0;0;*-2;202;0;0;RETRA;0;0;HITRN;0;0
055171         0;0;0;0;0;0;0;0;0            % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32
055202
055202         100;0;0;0
055206         0;0;0;0;0;0
055214         0;0;0;0;0;0;0;0
055224         0;0;0;0;0;0
055232         0;0;HDMOD;HDOBU;HDOFI;HDOFE
055240         HOTMR;0;-12;IOX 560;CTROD;0
055246  HDMO1, 0;0;*-2;202;0;0;RETRA;0;0;HOTRN;0;0
055262         0;0;0;0;0;0;0;0;0            % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32
055273
055273
055273
055273  HDIO 1

055273
055273         0
055274  HDFI1, 0;0;*-2;12200;0;0;IORES
055303         TEXIT;TEXIT;TEXIT;HDFO1;0
055310         0;0;0;0;0;0
055316         1303+XHDNX;1305+XHDNX;0
055321
055321         0
055322  HDFO1, 0;0;*-2;12200;0;0;IORES
055331         TEXIT;TEXIT;TEXIT;HDFI1;0
055336         0;0;0;0;0;0
055344         1304+XHDNX;1306+XHDNX;0
055347
055347  YHDNX=XHDNX+4;)KILL XHDNX;XHDNX=YHDNX;)KILL YHDNX
055347
055347
055347
055347  "
055347
055347

055347  "CXCPU
055347  %============================================================================
055347  %      TUNING VARIABLES FOR TERMINAL OUTPUT DRIVER
055347
055347  NWR10, 100;24;30;23    % ARRAY NWR100  MAX NO OF CHARS. IN CORR. MODE ND-100
055353  "8N500 CXCPU
055353  C5LFI, 0               % C5LFIFO  IF ><0 STATES MAX NO OF CHAR. TO COPY
055354  C5LPL, 0               % C5LPLAIN IF ><0 STATES MAX NO OF CHAR. TO COPY
055355  NWR50, 100;34;44;30    % ARRAY NWR500  MAX NO OF CHARS. IN CORR. MODE ND-500
055361  "CXCPU
055361  %-----------------------------------------------------------------------------
055361  %      VARIABLES USED BY TERMINAL OUTPUT DRIVER
055361
055361  WRCH,  0                       % NUMER OF CHARACTERS TO WRITE
055362  EBHO,  0                       % NO OF CHARACTERS TRANSFERED
055363  CBHOL, 0                       % NUMBER OF BYTES/WORDS TO WRITE
055364  TRMOD, 0                       % TERMINAL MODE (0-3)
055365  "
055365  %==============================================================================
055365  %            N O T S   C O N T R O L L E R   D A T A F I E L D S
055365  %
055365  "8NIU0; MBNIU 0,144700

055365  %-------------------------------------------------------------------------------
055365  % MBNIU CONTROLLER DATAFIELD, CONTROLLER 0
055365  %
055365         MNCTI;0;0;144700;ERRFA;MNMAI        % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
055373  MNDF0, 0;0;0;0;0;0;0;1;MNNA0;2;MNID0;MNOD0 % NA,NA,NA,TYPRING,MNCFL,MNOUT,MNCBNK,MNCNTREG,MNNAP,MNLNG,MNIDF,MNODF
055407  MNNA0, 'ND                  '              % MBNIU NAME
055422  MNID0, 0;0;0;0;0;0;0;0                     % TERMINAL INPUT DATAFIELDS
055432         0;0;0;0;0;0;0;0
055442         0;0;0;0;0;0;0;0
055452         0;0;0;0;0;0;0;0
055462  MNOD0, 0;0;0;0;0;0;0;0                     % TERMINAL OUTPUT DATAFIELDS
055472         0;0;0;0;0;0;0;0
055502         0;0;0;0;0;0;0;0
055512         0;0;0;0;0;0;0;0
055522
055522  "8NIU1; MBNIU 1,144720

055522  %-------------------------------------------------------------------------------
055522  % MBNIU CONTROLLER DATAFIELD, CONTROLLER 1
055522  %
055522         MNCTI;0;0;144720;ERRFA;MNMAI        % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
055530  MNDF1, 0;0;0;0;0;0;0;1;MNNA1;2;MNID1;MNOD1 % NA,NA,NA,TYPRING,MNCFL,MNOUT,MNCBNK,MNCNTREG,MNNAP,MNLNG,MNIDF,MNODF
055544  MNNA1, 'ND                  '              % MBNIU NAME
055557  MNID1, 0;0;0;0;0;0;0;0                     % TERMINAL INPUT DATAFIELDS
055567         0;0;0;0;0;0;0;0
055577         0;0;0;0;0;0;0;0
055607         0;0;0;0;0;0;0;0
055617  MNOD1, 0;0;0;0;0;0;0;0                     % TERMINAL OUTPUT DATAFIELDS
055627         0;0;0;0;0;0;0;0
055637         0;0;0;0;0;0;0;0
055647         0;0;0;0;0;0;0;0
055657
055657  "8NIU2; MBNIU 2,144740

055657  %-------------------------------------------------------------------------------
055657  % MBNIU CONTROLLER DATAFIELD, CONTROLLER 2
055657  %
055657         MNCTI;0;0;144740;ERRFA;MNMAI        % TMSUB,TMR,TTMR,HDEV,STDRIV,DRIVER
055665  MNDF2, 0;0;0;0;0;0;0;1;MNNA2;2;MNID2;MNOD2 % NA,NA,NA,TYPRING,MNCFL,MNOUT,MNCBNK,MNCNTREG,MNNAP,MNLNG,MNIDF,MNODF
055701  MNNA2, 'ND                  '              % MBNIU NAME
055714  MNID2, 0;0;0;0;0;0;0;0                     % TERMINAL INPUT DATAFIELDS
055724         0;0;0;0;0;0;0;0
055734         0;0;0;0;0;0;0;0
055744         0;0;0;0;0;0;0;0
055754  MNOD2, 0;0;0;0;0;0;0;0                     % TERMINAL OUTPUT DATAFIELDS
055764         0;0;0;0;0;0;0;0
055774         0;0;0;0;0;0;0;0
056004         0;0;0;0;0;0;0;0
056014
056014  "
056014  MNTAB=*
056014  "8NIU0; MNDF0; "8NIU1; MNDF1; "8NIU2; MNDF2; "-8NIU3; -1
056020  "-8NIU4; -1
056021  "-8NIU5; -1
056022  "-8NIU6; -1
056023  "-8NIU7; -1
056024  "
056024  -1
056025
056025  %==============================================================================
056025  % 28.5       T E R M I N A L  D A T A F I E L D S
056025  %
056025  % TERMINAL 1 INPUT DATAFIELD
056025
056025  NTRMS=0
056025  5TTST=*                      % USED BY ND-500 SYSTEM
056025
056025  "CXCPU
056025  ECBR7=1                      % BREAK AND ECHO TABLE #7 ALWAYS PRESENT
056025
056025  GTERM 01,300

056025         BAK01;300;XOFF@10+XON;1
056031  DT01R, 0;0;33;114040;210;44005;IORES
056040
056040         0;300+4;XOFF@10+XON;0
056044  DT01W, 0;0;*-2;114044;0;0;IORES
056053  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056053
056053
056053  XXYYZ=*
056053  DT01W+TYPRI/^10              % SET BIT 5NORESERVE
056050  DT01R+ZTSPE/-1               % SPEED FOR TERMINAL NO. 1 IS SET BY HARDWARE
056036  XXYYZ/; )KILL XXYYZ
056053  "
056053  5TTSZ=*-5TTST                % USED BY ND-500 SYSTEM
056053
056053
056053  % TERMINAL 2 - 64 DATAFIELDS
056053
056053  "8TR5 -9SMO1 CXCPU; GTERM 05,340

056053         BAK05;340;XOFF@10+XON;1
056057  DT05R, 0;0;33;114040;210;44005;IORES
056066
056066         0;340+4;XOFF@10+XON;0
056072  DT05W, 0;0;*-2;114044;0;0;IORES
056101  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056101
056101  "8TR6; GTERM 06,350

056101         BAK06;350;XOFF@10+XON;1
056105  DT06R, 0;0;33;114040;210;44005;IORES
056114
056114         0;350+4;XOFF@10+XON;0
056120  DT06W, 0;0;*-2;114044;0;0;IORES
056127  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056127
056127  "8TR7; GTERM 07,360

056127         BAK07;360;XOFF@10+XON;1
056133  DT07R, 0;0;33;114040;210;44005;IORES
056142
056142         0;360+4;XOFF@10+XON;0
056146  DT07W, 0;0;*-2;114044;0;0;IORES
056155  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056155
056155  "8TR8; GTERM 08,370

056155         BAK08;370;XOFF@10+XON;1
056161  DT08R, 0;0;33;114040;210;44005;IORES
056170
056170         0;370+4;XOFF@10+XON;0
056174  DT08W, 0;0;*-2;114044;0;0;IORES
056203  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056203
056203  "8TR9 -9SMO2 CXCPU; GTERM 09,1300

056203         BAK09;1300;XOFF@10+XON;1
056207  DT09R, 0;0;33;114040;210;44005;IORES
056216
056216         0;1300+4;XOFF@10+XON;0
056222  DT09W, 0;0;*-2;114044;0;0;IORES
056231  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056231
056231  "8TR10;GTERM 10,1310

056231         BAK10;1310;XOFF@10+XON;1
056235  DT10R, 0;0;33;114040;210;44005;IORES
056244
056244         0;1310+4;XOFF@10+XON;0
056250  DT10W, 0;0;*-2;114044;0;0;IORES
056257  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056257
056257  "8TR11;GTERM 11,1320

056257         BAK11;1320;XOFF@10+XON;1
056263  DT11R, 0;0;33;114040;210;44005;IORES
056272
056272         0;1320+4;XOFF@10+XON;0
056276  DT11W, 0;0;*-2;114044;0;0;IORES
056305  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056305
056305  "8TR12;GTERM 12,1330

056305         BAK12;1330;XOFF@10+XON;1
056311  DT12R, 0;0;33;114040;210;44005;IORES
056320
056320         0;1330+4;XOFF@10+XON;0
056324  DT12W, 0;0;*-2;114044;0;0;IORES
056333  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056333
056333  "8TR13 -9SMO3 CXCPU;GTERM 13,1340

056333         BAK13;1340;XOFF@10+XON;1
056337  DT13R, 0;0;33;114040;210;44005;IORES
056346
056346         0;1340+4;XOFF@10+XON;0
056352  DT13W, 0;0;*-2;114044;0;0;IORES
056361  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056361
056361  "8TR14;GTERM 14,1350

056361         BAK14;1350;XOFF@10+XON;1
056365  DT14R, 0;0;33;114040;210;44005;IORES
056374
056374         0;1350+4;XOFF@10+XON;0
056400  DT14W, 0;0;*-2;114044;0;0;IORES
056407  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056407
056407  "8TR15;GTERM 15,1360

056407         BAK15;1360;XOFF@10+XON;1
056413  DT15R, 0;0;33;114040;210;44005;IORES
056422
056422         0;1360+4;XOFF@10+XON;0
056426  DT15W, 0;0;*-2;114044;0;0;IORES
056435  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056435
056435  "8TR16;GTERM 16,1370

056435         BAK16;1370;XOFF@10+XON;1
056441  DT16R, 0;0;33;114040;210;44005;IORES
056450
056450         0;1370+4;XOFF@10+XON;0
056454  DT16W, 0;0;*-2;114044;0;0;IORES
056463  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056463
056463  "8TR17 -9SMO4 CXCPU;GTERM 17,200

056463         BAK17;200;XOFF@10+XON;1
056467  DT17R, 0;0;33;114040;210;44005;IORES
056476
056476         0;200+4;XOFF@10+XON;0
056502  DT17W, 0;0;*-2;114044;0;0;IORES
056511  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056511
056511  "8TR18;GTERM 18,210

056511         BAK18;210;XOFF@10+XON;1
056515  DT18R, 0;0;33;114040;210;44005;IORES
056524
056524         0;210+4;XOFF@10+XON;0
056530  DT18W, 0;0;*-2;114044;0;0;IORES
056537  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056537
056537  "8TR19;GTERM 19,220

056537         BAK19;220;XOFF@10+XON;1
056543  DT19R, 0;0;33;114040;210;44005;IORES
056552
056552         0;220+4;XOFF@10+XON;0
056556  DT19W, 0;0;*-2;114044;0;0;IORES
056565  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056565
056565  "8TR20;GTERM 20,230

056565         BAK20;230;XOFF@10+XON;1
056571  DT20R, 0;0;33;114040;210;44005;IORES
056600
056600         0;230+4;XOFF@10+XON;0
056604  DT20W, 0;0;*-2;114044;0;0;IORES
056613  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056613
056613  "8TR21 -9SMO5 CXCPU;GTERM 21,240

056613         BAK21;240;XOFF@10+XON;1
056617  DT21R, 0;0;33;114040;210;44005;IORES
056626
056626         0;240+4;XOFF@10+XON;0
056632  DT21W, 0;0;*-2;114044;0;0;IORES
056641  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056641
056641  "8TR22;GTERM 22,250

056641         BAK22;250;XOFF@10+XON;1
056645  DT22R, 0;0;33;114040;210;44005;IORES
056654
056654         0;250+4;XOFF@10+XON;0
056660  DT22W, 0;0;*-2;114044;0;0;IORES
056667  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056667
056667  "8TR23;GTERM 23,260

056667         BAK23;260;XOFF@10+XON;1
056673  DT23R, 0;0;33;114040;210;44005;IORES
056702
056702         0;260+4;XOFF@10+XON;0
056706  DT23W, 0;0;*-2;114044;0;0;IORES
056715  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056715
056715  "8TR24;GTERM 24,270

056715         BAK24;270;XOFF@10+XON;1
056721  DT24R, 0;0;33;114040;210;44005;IORES
056730
056730         0;270+4;XOFF@10+XON;0
056734  DT24W, 0;0;*-2;114044;0;0;IORES
056743  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056743
056743  "8TR25 -8SMO9 CXCPU;GTERM 25,1200

056743         BAK25;1200;XOFF@10+XON;1
056747  DT25R, 0;0;33;114040;210;44005;IORES
056756
056756         0;1200+4;XOFF@10+XON;0
056762  DT25W, 0;0;*-2;114044;0;0;IORES
056771  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
056771
056771  "8TR26;GTERM 26,1210

056771         BAK26;1210;XOFF@10+XON;1
056775  DT26R, 0;0;33;114040;210;44005;IORES
057004
057004         0;1210+4;XOFF@10+XON;0
057010  DT26W, 0;0;*-2;114044;0;0;IORES
057017  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057017
057017  "8TR27;GTERM 27,1220

057017         BAK27;1220;XOFF@10+XON;1
057023  DT27R, 0;0;33;114040;210;44005;IORES
057032
057032         0;1220+4;XOFF@10+XON;0
057036  DT27W, 0;0;*-2;114044;0;0;IORES
057045  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057045
057045  "8TR28;GTERM 28,1230

057045         BAK28;1230;XOFF@10+XON;1
057051  DT28R, 0;0;33;114040;210;44005;IORES
057060
057060         0;1230+4;XOFF@10+XON;0
057064  DT28W, 0;0;*-2;114044;0;0;IORES
057073  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057073
057073  "8TR29 -9SMO6 CXCPU;GTERM 29,1240

057073         BAK29;1240;XOFF@10+XON;1
057077  DT29R, 0;0;33;114040;210;44005;IORES
057106
057106         0;1240+4;XOFF@10+XON;0
057112  DT29W, 0;0;*-2;114044;0;0;IORES
057121  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057121
057121  "8TR30 -9SMO7 CXCPU;GTERM 30,1250

057121         BAK30;1250;XOFF@10+XON;1
057125  DT30R, 0;0;33;114040;210;44005;IORES
057134
057134         0;1250+4;XOFF@10+XON;0
057140  DT30W, 0;0;*-2;114044;0;0;IORES
057147  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057147
057147  "8TR31;GTERM 31,1260

057147         BAK31;1260;XOFF@10+XON;1
057153  DT31R, 0;0;33;114040;210;44005;IORES
057162
057162         0;1260+4;XOFF@10+XON;0
057166  DT31W, 0;0;*-2;114044;0;0;IORES
057175  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057175
057175  "8TR32;GTERM 32,1270

057175         BAK32;1270;XOFF@10+XON;1
057201  DT32R, 0;0;33;114040;210;44005;IORES
057210
057210         0;1270+4;XOFF@10+XON;0
057214  DT32W, 0;0;*-2;114044;0;0;IORES
057223  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057223
057223  "8TR33;GTERM 33,640

057223         BAK33;640;XOFF@10+XON;1
057227  DT33R, 0;0;33;114040;210;44005;IORES
057236
057236         0;640+4;XOFF@10+XON;0
057242  DT33W, 0;0;*-2;114044;0;0;IORES
057251  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057251
057251  "8TR34;GTERM 34,650

057251         BAK34;650;XOFF@10+XON;1
057255  DT34R, 0;0;33;114040;210;44005;IORES
057264
057264         0;650+4;XOFF@10+XON;0
057270  DT34W, 0;0;*-2;114044;0;0;IORES
057277  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057277
057277  "8TR35 -8SMO7 CXCPU;GTERM 35,660

057277         BAK35;660;XOFF@10+XON;1
057303  DT35R, 0;0;33;114040;210;44005;IORES
057312
057312         0;660+4;XOFF@10+XON;0
057316  DT35W, 0;0;*-2;114044;0;0;IORES
057325  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057325
057325  "8TR36 -8SMO8 CXCPU;GTERM 36,670

057325         BAK36;670;XOFF@10+XON;1
057331  DT36R, 0;0;33;114040;210;44005;IORES
057340
057340         0;670+4;XOFF@10+XON;0
057344  DT36W, 0;0;*-2;114044;0;0;IORES
057353  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057353
057353  "8TR37 -8SMO9 CXCPU;GTERM 37,1100

057353         BAK37;1100;XOFF@10+XON;1
057357  DT37R, 0;0;33;114040;210;44005;IORES
057366
057366         0;1100+4;XOFF@10+XON;0
057372  DT37W, 0;0;*-2;114044;0;0;IORES
057401  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057401
057401  "8TR38 -9SMO1 CXCPU;GTERM 38,1110

057401         BAK38;1110;XOFF@10+XON;1
057405  DT38R, 0;0;33;114040;210;44005;IORES
057414
057414         0;1110+4;XOFF@10+XON;0
057420  DT38W, 0;0;*-2;114044;0;0;IORES
057427  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057427
057427  "8TR39 -9SMO2 CXCPU;GTERM 39,1120

057427         BAK39;1120;XOFF@10+XON;1
057433  DT39R, 0;0;33;114040;210;44005;IORES
057442
057442         0;1120+4;XOFF@10+XON;0
057446  DT39W, 0;0;*-2;114044;0;0;IORES
057455  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057455
057455  "8TR40 -9SMO3 CXCPU;GTERM 40,1130

057455         BAK40;1130;XOFF@10+XON;1
057461  DT40R, 0;0;33;114040;210;44005;IORES
057470
057470         0;1130+4;XOFF@10+XON;0
057474  DT40W, 0;0;*-2;114044;0;0;IORES
057503  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057503
057503  "8TR41 -9SMO4 CXCPU;GTERM 41,1140

057503         BAK41;1140;XOFF@10+XON;1
057507  DT41R, 0;0;33;114040;210;44005;IORES
057516
057516         0;1140+4;XOFF@10+XON;0
057522  DT41W, 0;0;*-2;114044;0;0;IORES
057531  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057531
057531  "8TR42 -9SMO5 CXCPU;GTERM 42,1150

057531         BAK42;1150;XOFF@10+XON;1
057535  DT42R, 0;0;33;114040;210;44005;IORES
057544
057544         0;1150+4;XOFF@10+XON;0
057550  DT42W, 0;0;*-2;114044;0;0;IORES
057557  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057557
057557  "8TR43 -9SMO6 CXCPU;GTERM 43,1160

057557         BAK43;1160;XOFF@10+XON;1
057563  DT43R, 0;0;33;114040;210;44005;IORES
057572
057572         0;1160+4;XOFF@10+XON;0
057576  DT43W, 0;0;*-2;114044;0;0;IORES
057605  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057605
057605  "8TR44 -9SMO7 CXCPU;GTERM 44,1170

057605         BAK44;1170;XOFF@10+XON;1
057611  DT44R, 0;0;33;114040;210;44005;IORES
057620
057620         0;1170+4;XOFF@10+XON;0
057624  DT44W, 0;0;*-2;114044;0;0;IORES
057633  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057633
057633  "8TR45;GTERM 45,1400

057633         BAK45;1400;XOFF@10+XON;1
057637  DT45R, 0;0;33;114040;210;44005;IORES
057646
057646         0;1400+4;XOFF@10+XON;0
057652  DT45W, 0;0;*-2;114044;0;0;IORES
057661  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057661
057661  "8TR46;GTERM 46,1410

057661         BAK46;1410;XOFF@10+XON;1
057665  DT46R, 0;0;33;114040;210;44005;IORES
057674
057674         0;1410+4;XOFF@10+XON;0
057700  DT46W, 0;0;*-2;114044;0;0;IORES
057707  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057707
057707  "8TR47;GTERM 47,1420

057707         BAK47;1420;XOFF@10+XON;1
057713  DT47R, 0;0;33;114040;210;44005;IORES
057722
057722         0;1420+4;XOFF@10+XON;0
057726  DT47W, 0;0;*-2;114044;0;0;IORES
057735  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057735
057735  "8TR48;GTERM 48,1430

057735         BAK48;1430;XOFF@10+XON;1
057741  DT48R, 0;0;33;114040;210;44005;IORES
057750
057750         0;1430+4;XOFF@10+XON;0
057754  DT48W, 0;0;*-2;114044;0;0;IORES
057763  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
057763
057763  "8TR49;GTERM 49,1500

057763         BAK49;1500;XOFF@10+XON;1
057767  DT49R, 0;0;33;114040;210;44005;IORES
057776
057776         0;1500+4;XOFF@10+XON;0
060002  DT49W, 0;0;*-2;114044;0;0;IORES
060011  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060011
060011  "8TR50;GTERM 50,1510

060011         BAK50;1510;XOFF@10+XON;1
060015  DT50R, 0;0;33;114040;210;44005;IORES
060024
060024         0;1510+4;XOFF@10+XON;0
060030  DT50W, 0;0;*-2;114044;0;0;IORES
060037  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060037
060037  "8TR51;GTERM 51,1520

060037         BAK51;1520;XOFF@10+XON;1
060043  DT51R, 0;0;33;114040;210;44005;IORES
060052
060052         0;1520+4;XOFF@10+XON;0
060056  DT51W, 0;0;*-2;114044;0;0;IORES
060065  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060065
060065  "8TR52;GTERM 52,1530

060065         BAK52;1530;XOFF@10+XON;1
060071  DT52R, 0;0;33;114040;210;44005;IORES
060100
060100         0;1530+4;XOFF@10+XON;0
060104  DT52W, 0;0;*-2;114044;0;0;IORES
060113  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060113
060113  "
060113
060113  % TERMINAL 64-28  DATAFIELDS
060113
060113  "8TR65;GTERM 65,140400

060113         BAK65;140400;XOFF@10+XON;1
060117  DT65R, 0;0;33;114040;210;44005;IORES
060126
060126         0;140400+4;XOFF@10+XON;0
060132  DT65W, 0;0;*-2;114044;0;0;IORES
060141  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060141
060141  "8TR66;GTERM 66,140410

060141         BAK66;140410;XOFF@10+XON;1
060145  DT66R, 0;0;33;114040;210;44005;IORES
060154
060154         0;140410+4;XOFF@10+XON;0
060160  DT66W, 0;0;*-2;114044;0;0;IORES
060167  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060167
060167  "8TR67;GTERM 67,140420

060167         BAK67;140420;XOFF@10+XON;1
060173  DT67R, 0;0;33;114040;210;44005;IORES
060202
060202         0;140420+4;XOFF@10+XON;0
060206  DT67W, 0;0;*-2;114044;0;0;IORES
060215  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060215
060215  "8TR68;GTERM 68,140430

060215         BAK68;140430;XOFF@10+XON;1
060221  DT68R, 0;0;33;114040;210;44005;IORES
060230
060230         0;140430+4;XOFF@10+XON;0
060234  DT68W, 0;0;*-2;114044;0;0;IORES
060243  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060243
060243  "8TR69;GTERM 69,140440

060243         BAK69;140440;XOFF@10+XON;1
060247  DT69R, 0;0;33;114040;210;44005;IORES
060256
060256         0;140440+4;XOFF@10+XON;0
060262  DT69W, 0;0;*-2;114044;0;0;IORES
060271  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060271
060271  "8TR70;GTERM 70,140450

060271         BAK70;140450;XOFF@10+XON;1
060275  DT70R, 0;0;33;114040;210;44005;IORES
060304
060304         0;140450+4;XOFF@10+XON;0
060310  DT70W, 0;0;*-2;114044;0;0;IORES
060317  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060317
060317  "8TR71;GTERM 71,140460

060317         BAK71;140460;XOFF@10+XON;1
060323  DT71R, 0;0;33;114040;210;44005;IORES
060332
060332         0;140460+4;XOFF@10+XON;0
060336  DT71W, 0;0;*-2;114044;0;0;IORES
060345  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060345
060345  "8TR72;GTERM 72,140470

060345         BAK72;140470;XOFF@10+XON;1
060351  DT72R, 0;0;33;114040;210;44005;IORES
060360
060360         0;140470+4;XOFF@10+XON;0
060364  DT72W, 0;0;*-2;114044;0;0;IORES
060373  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060373
060373  "8TR73;GTERM 73,140500

060373         BAK73;140500;XOFF@10+XON;1
060377  DT73R, 0;0;33;114040;210;44005;IORES
060406
060406         0;140500+4;XOFF@10+XON;0
060412  DT73W, 0;0;*-2;114044;0;0;IORES
060421  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060421
060421  "8TR74;GTERM 74,140510

060421         BAK74;140510;XOFF@10+XON;1
060425  DT74R, 0;0;33;114040;210;44005;IORES
060434
060434         0;140510+4;XOFF@10+XON;0
060440  DT74W, 0;0;*-2;114044;0;0;IORES
060447  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060447
060447  "8TR75;GTERM 75,140520

060447         BAK75;140520;XOFF@10+XON;1
060453  DT75R, 0;0;33;114040;210;44005;IORES
060462
060462         0;140520+4;XOFF@10+XON;0
060466  DT75W, 0;0;*-2;114044;0;0;IORES
060475  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060475
060475  "8TR76;GTERM 76,140530

060475         BAK76;140530;XOFF@10+XON;1
060501  DT76R, 0;0;33;114040;210;44005;IORES
060510
060510         0;140530+4;XOFF@10+XON;0
060514  DT76W, 0;0;*-2;114044;0;0;IORES
060523  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060523
060523  "8TR77;GTERM 77,140540

060523         BAK77;140540;XOFF@10+XON;1
060527  DT77R, 0;0;33;114040;210;44005;IORES
060536
060536         0;140540+4;XOFF@10+XON;0
060542  DT77W, 0;0;*-2;114044;0;0;IORES
060551  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060551
060551  "8TR78;GTERM 78,140550

060551         BAK78;140550;XOFF@10+XON;1
060555  DT78R, 0;0;33;114040;210;44005;IORES
060564
060564         0;140550+4;XOFF@10+XON;0
060570  DT78W, 0;0;*-2;114044;0;0;IORES
060577  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060577
060577  "8TR79;GTERM 79,140560

060577         BAK79;140560;XOFF@10+XON;1
060603  DT79R, 0;0;33;114040;210;44005;IORES
060612
060612         0;140560+4;XOFF@10+XON;0
060616  DT79W, 0;0;*-2;114044;0;0;IORES
060625  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060625
060625  "8TR80;GTERM 80,140570

060625         BAK80;140570;XOFF@10+XON;1
060631  DT80R, 0;0;33;114040;210;44005;IORES
060640
060640         0;140570+4;XOFF@10+XON;0
060644  DT80W, 0;0;*-2;114044;0;0;IORES
060653  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060653
060653  "8TR81;GTERM 81,140600

060653         BAK81;140600;XOFF@10+XON;1
060657  DT81R, 0;0;33;114040;210;44005;IORES
060666
060666         0;140600+4;XOFF@10+XON;0
060672  DT81W, 0;0;*-2;114044;0;0;IORES
060701  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060701
060701  "8TR82;GTERM 82,140610

060701         BAK82;140610;XOFF@10+XON;1
060705  DT82R, 0;0;33;114040;210;44005;IORES
060714
060714         0;140610+4;XOFF@10+XON;0
060720  DT82W, 0;0;*-2;114044;0;0;IORES
060727  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060727
060727  "8TR83;GTERM 83,140620

060727         BAK83;140620;XOFF@10+XON;1
060733  DT83R, 0;0;33;114040;210;44005;IORES
060742
060742         0;140620+4;XOFF@10+XON;0
060746  DT83W, 0;0;*-2;114044;0;0;IORES
060755  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
060755
060755  "8TR84;GTERM 84,140630

060755         BAK84;140630;XOFF@10+XON;1
060761  DT84R, 0;0;33;114040;210;44005;IORES
060770
060770         0;140630+4;XOFF@10+XON;0
060774  DT84W, 0;0;*-2;114044;0;0;IORES
061003  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061003
061003  "8TR85;GTERM 85,140640

061003         BAK85;140640;XOFF@10+XON;1
061007  DT85R, 0;0;33;114040;210;44005;IORES
061016
061016         0;140640+4;XOFF@10+XON;0
061022  DT85W, 0;0;*-2;114044;0;0;IORES
061031  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061031
061031  "8TR86;GTERM 86,140650

061031         BAK86;140650;XOFF@10+XON;1
061035  DT86R, 0;0;33;114040;210;44005;IORES
061044
061044         0;140650+4;XOFF@10+XON;0
061050  DT86W, 0;0;*-2;114044;0;0;IORES
061057  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061057
061057  "8TR87;GTERM 87,140660

061057         BAK87;140660;XOFF@10+XON;1
061063  DT87R, 0;0;33;114040;210;44005;IORES
061072
061072         0;140660+4;XOFF@10+XON;0
061076  DT87W, 0;0;*-2;114044;0;0;IORES
061105  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061105
061105  "8TR88;GTERM 88,140670

061105         BAK88;140670;XOFF@10+XON;1
061111  DT88R, 0;0;33;114040;210;44005;IORES
061120
061120         0;140670+4;XOFF@10+XON;0
061124  DT88W, 0;0;*-2;114044;0;0;IORES
061133  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061133
061133  "8TR89;GTERM 89,140700

061133         BAK89;140700;XOFF@10+XON;1
061137  DT89R, 0;0;33;114040;210;44005;IORES
061146
061146         0;140700+4;XOFF@10+XON;0
061152  DT89W, 0;0;*-2;114044;0;0;IORES
061161  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061161
061161  "8TR90;GTERM 90,140710

061161         BAK90;140710;XOFF@10+XON;1
061165  DT90R, 0;0;33;114040;210;44005;IORES
061174
061174         0;140710+4;XOFF@10+XON;0
061200  DT90W, 0;0;*-2;114044;0;0;IORES
061207  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061207
061207  "8TR91;GTERM 91,140720

061207         BAK91;140720;XOFF@10+XON;1
061213  DT91R, 0;0;33;114040;210;44005;IORES
061222
061222         0;140720+4;XOFF@10+XON;0
061226  DT91W, 0;0;*-2;114044;0;0;IORES
061235  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061235
061235  "8TR92;GTERM 92,140730

061235         BAK92;140730;XOFF@10+XON;1
061241  DT92R, 0;0;33;114040;210;44005;IORES
061250
061250         0;140730+4;XOFF@10+XON;0
061254  DT92W, 0;0;*-2;114044;0;0;IORES
061263  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061263
061263  "8TR93;GTERM 93,140740

061263         BAK93;140740;XOFF@10+XON;1
061267  DT93R, 0;0;33;114040;210;44005;IORES
061276
061276         0;140740+4;XOFF@10+XON;0
061302  DT93W, 0;0;*-2;114044;0;0;IORES
061311  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061311
061311  "8TR94;GTERM 94,140750

061311         BAK94;140750;XOFF@10+XON;1
061315  DT94R, 0;0;33;114040;210;44005;IORES
061324
061324         0;140750+4;XOFF@10+XON;0
061330  DT94W, 0;0;*-2;114044;0;0;IORES
061337  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061337
061337  "8TR95;GTERM 95,140760

061337         BAK95;140760;XOFF@10+XON;1
061343  DT95R, 0;0;33;114040;210;44005;IORES
061352
061352         0;140760+4;XOFF@10+XON;0
061356  DT95W, 0;0;*-2;114044;0;0;IORES
061365  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061365
061365  "8TR96;GTERM 96,140770

061365         BAK96;140770;XOFF@10+XON;1
061371  DT96R, 0;0;33;114040;210;44005;IORES
061400
061400         0;140770+4;XOFF@10+XON;0
061404  DT96W, 0;0;*-2;114044;0;0;IORES
061413  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061413
061413  "8TR97;GTERM 97,141000

061413         BAK97;141000;XOFF@10+XON;1
061417  DT97R, 0;0;33;114040;210;44005;IORES
061426
061426         0;141000+4;XOFF@10+XON;0
061432  DT97W, 0;0;*-2;114044;0;0;IORES
061441  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061441
061441  "8TR98;GTERM 98,141010

061441         BAK98;141010;XOFF@10+XON;1
061445  DT98R, 0;0;33;114040;210;44005;IORES
061454
061454         0;141010+4;XOFF@10+XON;0
061460  DT98W, 0;0;*-2;114044;0;0;IORES
061467  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061467
061467  "8TR99;GTERM 99,141020

061467         BAK99;141020;XOFF@10+XON;1
061473  DT99R, 0;0;33;114040;210;44005;IORES
061502
061502         0;141020+4;XOFF@10+XON;0
061506  DT99W, 0;0;*-2;114044;0;0;IORES
061515  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061515
061515  "9TR00;GXTRM 100,141030

061515         BK100;141030;XOFF@10+XON;1
061521  T100R, 0;0;33;114040;210;44005;IORES
061530
061530         0;141030+4;XOFF@10+XON;0
061534  T100W, 0;0;*-2;114044;0;0;IORES
061543  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061543
061543  "9TR01;GXTRM 101,141040

061543         BK101;141040;XOFF@10+XON;1
061547  T101R, 0;0;33;114040;210;44005;IORES
061556
061556         0;141040+4;XOFF@10+XON;0
061562  T101W, 0;0;*-2;114044;0;0;IORES
061571  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061571
061571  "9TR02;GXTRM 102,141050

061571         BK102;141050;XOFF@10+XON;1
061575  T102R, 0;0;33;114040;210;44005;IORES
061604
061604         0;141050+4;XOFF@10+XON;0
061610  T102W, 0;0;*-2;114044;0;0;IORES
061617  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061617
061617  "9TR03;GXTRM 103,141060

061617         BK103;141060;XOFF@10+XON;1
061623  T103R, 0;0;33;114040;210;44005;IORES
061632
061632         0;141060+4;XOFF@10+XON;0
061636  T103W, 0;0;*-2;114044;0;0;IORES
061645  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061645
061645  "9TR04;GXTRM 104,141070

061645         BK104;141070;XOFF@10+XON;1
061651  T104R, 0;0;33;114040;210;44005;IORES
061660
061660         0;141070+4;XOFF@10+XON;0
061664  T104W, 0;0;*-2;114044;0;0;IORES
061673  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061673
061673  "9TR05;GXTRM 105,141100

061673         BK105;141100;XOFF@10+XON;1
061677  T105R, 0;0;33;114040;210;44005;IORES
061706
061706         0;141100+4;XOFF@10+XON;0
061712  T105W, 0;0;*-2;114044;0;0;IORES
061721  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061721
061721  "9TR06;GXTRM 106,141110

061721         BK106;141110;XOFF@10+XON;1
061725  T106R, 0;0;33;114040;210;44005;IORES
061734
061734         0;141110+4;XOFF@10+XON;0
061740  T106W, 0;0;*-2;114044;0;0;IORES
061747  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061747
061747  "9TR07;GXTRM 107,141120

061747         BK107;141120;XOFF@10+XON;1
061753  T107R, 0;0;33;114040;210;44005;IORES
061762
061762         0;141120+4;XOFF@10+XON;0
061766  T107W, 0;0;*-2;114044;0;0;IORES
061775  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
061775
061775  "9TR08;GXTRM 108,141130

061775         BK108;141130;XOFF@10+XON;1
062001  T108R, 0;0;33;114040;210;44005;IORES
062010
062010         0;141130+4;XOFF@10+XON;0
062014  T108W, 0;0;*-2;114044;0;0;IORES
062023  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062023
062023  "9TR09;GXTRM 109,141140

062023         BK109;141140;XOFF@10+XON;1
062027  T109R, 0;0;33;114040;210;44005;IORES
062036
062036         0;141140+4;XOFF@10+XON;0
062042  T109W, 0;0;*-2;114044;0;0;IORES
062051  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062051
062051  "9TR10;GXTRM 110,141150

062051         BK110;141150;XOFF@10+XON;1
062055  T110R, 0;0;33;114040;210;44005;IORES
062064
062064         0;141150+4;XOFF@10+XON;0
062070  T110W, 0;0;*-2;114044;0;0;IORES
062077  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062077
062077  "9TR11;GXTRM 111,141160

062077         BK111;141160;XOFF@10+XON;1
062103  T111R, 0;0;33;114040;210;44005;IORES
062112
062112         0;141160+4;XOFF@10+XON;0
062116  T111W, 0;0;*-2;114044;0;0;IORES
062125  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062125
062125  "9TR12;GXTRM 112,141170

062125         BK112;141170;XOFF@10+XON;1
062131  T112R, 0;0;33;114040;210;44005;IORES
062140
062140         0;141170+4;XOFF@10+XON;0
062144  T112W, 0;0;*-2;114044;0;0;IORES
062153  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062153
062153  "9TR13;GXTRM 113,141200

062153         BK113;141200;XOFF@10+XON;1
062157  T113R, 0;0;33;114040;210;44005;IORES
062166
062166         0;141200+4;XOFF@10+XON;0
062172  T113W, 0;0;*-2;114044;0;0;IORES
062201  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062201
062201  "9TR14;GXTRM 114,141210

062201         BK114;141210;XOFF@10+XON;1
062205  T114R, 0;0;33;114040;210;44005;IORES
062214
062214         0;141210+4;XOFF@10+XON;0
062220  T114W, 0;0;*-2;114044;0;0;IORES
062227  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062227
062227  "9TR15;GXTRM 115,141220

062227         BK115;141220;XOFF@10+XON;1
062233  T115R, 0;0;33;114040;210;44005;IORES
062242
062242         0;141220+4;XOFF@10+XON;0
062246  T115W, 0;0;*-2;114044;0;0;IORES
062255  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062255
062255  "9TR16;GXTRM 116,141230

062255         BK116;141230;XOFF@10+XON;1
062261  T116R, 0;0;33;114040;210;44005;IORES
062270
062270         0;141230+4;XOFF@10+XON;0
062274  T116W, 0;0;*-2;114044;0;0;IORES
062303  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062303
062303  "9TR17;GXTRM 117,141240

062303         BK117;141240;XOFF@10+XON;1
062307  T117R, 0;0;33;114040;210;44005;IORES
062316
062316         0;141240+4;XOFF@10+XON;0
062322  T117W, 0;0;*-2;114044;0;0;IORES
062331  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062331
062331  "9TR18;GXTRM 118,141250

062331         BK118;141250;XOFF@10+XON;1
062335  T118R, 0;0;33;114040;210;44005;IORES
062344
062344         0;141250+4;XOFF@10+XON;0
062350  T118W, 0;0;*-2;114044;0;0;IORES
062357  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062357
062357  "9TR19;GXTRM 119,141260

062357         BK119;141260;XOFF@10+XON;1
062363  T119R, 0;0;33;114040;210;44005;IORES
062372
062372         0;141260+4;XOFF@10+XON;0
062376  T119W, 0;0;*-2;114044;0;0;IORES
062405  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062405
062405  "9TR20;GXTRM 120,141270

062405         BK120;141270;XOFF@10+XON;1
062411  T120R, 0;0;33;114040;210;44005;IORES
062420
062420         0;141270+4;XOFF@10+XON;0
062424  T120W, 0;0;*-2;114044;0;0;IORES
062433  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062433
062433  "9TR21;GXTRM 121,141300

062433         BK121;141300;XOFF@10+XON;1
062437  T121R, 0;0;33;114040;210;44005;IORES
062446
062446         0;141300+4;XOFF@10+XON;0
062452  T121W, 0;0;*-2;114044;0;0;IORES
062461  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062461
062461  "9TR22;GXTRM 122,141310

062461         BK122;141310;XOFF@10+XON;1
062465  T122R, 0;0;33;114040;210;44005;IORES
062474
062474         0;141310+4;XOFF@10+XON;0
062500  T122W, 0;0;*-2;114044;0;0;IORES
062507  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062507
062507  "9TR23;GXTRM 123,141320

062507         BK123;141320;XOFF@10+XON;1
062513  T123R, 0;0;33;114040;210;44005;IORES
062522
062522         0;141320+4;XOFF@10+XON;0
062526  T123W, 0;0;*-2;114044;0;0;IORES
062535  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062535
062535  "9TR24;GXTRM 124,141330

062535         BK124;141330;XOFF@10+XON;1
062541  T124R, 0;0;33;114040;210;44005;IORES
062550
062550         0;141330+4;XOFF@10+XON;0
062554  T124W, 0;0;*-2;114044;0;0;IORES
062563  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062563
062563  "9TR25;GXTRM 125,141340

062563         BK125;141340;XOFF@10+XON;1
062567  T125R, 0;0;33;114040;210;44005;IORES
062576
062576         0;141340+4;XOFF@10+XON;0
062602  T125W, 0;0;*-2;114044;0;0;IORES
062611  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062611
062611  "9TR26;GXTRM 126,141350

062611         BK126;141350;XOFF@10+XON;1
062615  T126R, 0;0;33;114040;210;44005;IORES
062624
062624         0;141350+4;XOFF@10+XON;0
062630  T126W, 0;0;*-2;114044;0;0;IORES
062637  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062637
062637  "9TR27;GXTRM 127,141360

062637         BK127;141360;XOFF@10+XON;1
062643  T127R, 0;0;33;114040;210;44005;IORES
062652
062652         0;141360+4;XOFF@10+XON;0
062656  T127W, 0;0;*-2;114044;0;0;IORES
062665  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062665
062665  "9TR28;GXTRM 128,141370

062665         BK128;141370;XOFF@10+XON;1
062671  T128R, 0;0;33;114040;210;44005;IORES
062700
062700         0;141370+4;XOFF@10+XON;0
062704  T128W, 0;0;*-2;114044;0;0;IORES
062713  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062713
062713  "9TR29;GXTRM 129,142300

062713         BK129;142300;XOFF@10+XON;1
062717  T129R, 0;0;33;114040;210;44005;IORES
062726
062726         0;142300+4;XOFF@10+XON;0
062732  T129W, 0;0;*-2;114044;0;0;IORES
062741  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062741
062741  "9TR30;GXTRM 130,142310

062741         BK130;142310;XOFF@10+XON;1
062745  T130R, 0;0;33;114040;210;44005;IORES
062754
062754         0;142310+4;XOFF@10+XON;0
062760  T130W, 0;0;*-2;114044;0;0;IORES
062767  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
062767
062767  "9TR31;GXTRM 131,142320

062767         BK131;142320;XOFF@10+XON;1
062773  T131R, 0;0;33;114040;210;44005;IORES
063002
063002         0;142320+4;XOFF@10+XON;0
063006  T131W, 0;0;*-2;114044;0;0;IORES
063015  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063015
063015  "9TR32;GXTRM 132,142330

063015         BK132;142330;XOFF@10+XON;1
063021  T132R, 0;0;33;114040;210;44005;IORES
063030
063030         0;142330+4;XOFF@10+XON;0
063034  T132W, 0;0;*-2;114044;0;0;IORES
063043  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063043
063043  "9TR33;GXTRM 133,142340

063043         BK133;142340;XOFF@10+XON;1
063047  T133R, 0;0;33;114040;210;44005;IORES
063056
063056         0;142340+4;XOFF@10+XON;0
063062  T133W, 0;0;*-2;114044;0;0;IORES
063071  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063071
063071  "9TR34;GXTRM 134,142350

063071         BK134;142350;XOFF@10+XON;1
063075  T134R, 0;0;33;114040;210;44005;IORES
063104
063104         0;142350+4;XOFF@10+XON;0
063110  T134W, 0;0;*-2;114044;0;0;IORES
063117  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063117
063117  "9TR35;GXTRM 135,142360

063117         BK135;142360;XOFF@10+XON;1
063123  T135R, 0;0;33;114040;210;44005;IORES
063132
063132         0;142360+4;XOFF@10+XON;0
063136  T135W, 0;0;*-2;114044;0;0;IORES
063145  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063145
063145  "9TR36;GXTRM 136,142370

063145         BK136;142370;XOFF@10+XON;1
063151  T136R, 0;0;33;114040;210;44005;IORES
063160
063160         0;142370+4;XOFF@10+XON;0
063164  T136W, 0;0;*-2;114044;0;0;IORES
063173  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063173
063173  "9TR37;GXTRM 137,142400

063173         BK137;142400;XOFF@10+XON;1
063177  T137R, 0;0;33;114040;210;44005;IORES
063206
063206         0;142400+4;XOFF@10+XON;0
063212  T137W, 0;0;*-2;114044;0;0;IORES
063221  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063221
063221  "9TR38;GXTRM 138,142410

063221         BK138;142410;XOFF@10+XON;1
063225  T138R, 0;0;33;114040;210;44005;IORES
063234
063234         0;142410+4;XOFF@10+XON;0
063240  T138W, 0;0;*-2;114044;0;0;IORES
063247  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063247
063247  "9TR39;GXTRM 139,142420

063247         BK139;142420;XOFF@10+XON;1
063253  T139R, 0;0;33;114040;210;44005;IORES
063262
063262         0;142420+4;XOFF@10+XON;0
063266  T139W, 0;0;*-2;114044;0;0;IORES
063275  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063275
063275  "9TR40;GXTRM 140,142430

063275         BK140;142430;XOFF@10+XON;1
063301  T140R, 0;0;33;114040;210;44005;IORES
063310
063310         0;142430+4;XOFF@10+XON;0
063314  T140W, 0;0;*-2;114044;0;0;IORES
063323  XYZ=NTRMS; )KILL NTRMS; NTRMS=XYZ+1; )KILL XYZ
063323
063323  "
063323  5TFST=*
063323  "TEFX1
063323  %============================================================================
063323  %       T E L E F I X   PAIR TERMINAL DATAFIELDS
063323  TPAIR 01

063323  %------------------------------------------
063323         TFB01;0;0;1
063327  TB01R, 0;0;33;114040;0;TR01W;IORES
063336
063336         10000;0;0;0
063342  TB01W, 0;0;*-2;114044;2;TR01R;IORES
063351
063351         0;0;0;1
063355  TR01R, 0;0;33;114040;0;TB01W;IORES
063364
063364         10000;0;0;0
063370  TR01W, 0;0;*-2;114044;1;TB01R;IORES
063377  %----------------------------------------
063377
063377  "
063377
063377  5TEND=*                      % USED BY ND-500 SYSTEM
063377
063377  "BADAD
063377

063377  %======================================================================
063377  %      G L O B A L   D A T A   F O R   T A D
063377  %=======================================================================
063377  ITAD,   0        % I T A D  --- TAD INPUT  DF. ADDR. FOR LEVEL 10
063400  OTAD,   0        % O T A D  --- TAD OUTPUT DF. ADDR. FOR LEVEL 10
063401  41ITA,  0        % 4 1 I T A D  TAD INPUT  DF. ADDR. FOR LEVEL 1&4
063402  41OTA,  0        % 4 1 O T A D  TAD OUTPUT DF. ADDR. FOR LEVEL 1&4
063403
063403  %=======================================================================
063403  %      M E S S A G E   H E A D E R S
063403
063403  DMMES,  7DUMM@10;0;2            % DUMMY MESSAGE
063406  RFIMS,  7RFI@10;0;2             % RFI MESSAGE
063411  ERESP,  7ESRS@10;0;2            % ESCAPE RESPONSE BUFFER
063414  EDRSP,  7EDRS@10;0;2            % ESCAPE RESPONSE ESCAPE DISABLED BUFFER
063417  RSOFP,  0;3;7TMOD@10+1;104@10   % TMODE WITH RESET S.O.F.PAGE
063423  HIGHT,  0                       % SAVE TYPE OF HIGH PRIORITY MESSAGE
063424  RDATR,  0                       % DATA IN RESPONSE MESSAGE
063425
063425  %==============================================================================
063425  % 28.5B      T E R M I N A L   A C C E S S   D E V I C E
063425  %            D A T A F I E L D S
063425
063425  9BDST=*                      % START OF TAD DATAFIELDS
063425
063425  "BAD01;BADDV 01

063425         TAD01;3;410;0
063431  BD01R,  0;0;33;114020;0;0;IORES
063440
063440         0;0;0;0
063444  BD01W,  0;0;*-2;114020;0;0;IORES
063453
063453
063453  "BADAD
063453  5BDSZ=*-9BDST                % SIZE OF TAD INPUT AND OUTPUT DATAFIELD
063453
063453  "BAD02;BADDV 02

063453         TAD02;3;410;0
063457  BD02R,  0;0;33;114020;0;0;IORES
063466
063466         0;0;0;0
063472  BD02W,  0;0;*-2;114020;0;0;IORES
063501
063501  "BAD03;BADDV 03

063501         TAD03;3;410;0
063505  BD03R,  0;0;33;114020;0;0;IORES
063514
063514         0;0;0;0
063520  BD03W,  0;0;*-2;114020;0;0;IORES
063527
063527  "BAD04;BADDV 04

063527         TAD04;3;410;0
063533  BD04R,  0;0;33;114020;0;0;IORES
063542
063542         0;0;0;0
063546  BD04W,  0;0;*-2;114020;0;0;IORES
063555
063555  "BAD05;BADDV 05

063555         TAD05;3;410;0
063561  BD05R,  0;0;33;114020;0;0;IORES
063570
063570         0;0;0;0
063574  BD05W,  0;0;*-2;114020;0;0;IORES
063603
063603  "BAD06;BADDV 06

063603         TAD06;3;410;0
063607  BD06R,  0;0;33;114020;0;0;IORES
063616
063616         0;0;0;0
063622  BD06W,  0;0;*-2;114020;0;0;IORES
063631
063631  "BAD07;BADDV 07

063631         TAD07;3;410;0
063635  BD07R,  0;0;33;114020;0;0;IORES
063644
063644         0;0;0;0
063650  BD07W,  0;0;*-2;114020;0;0;IORES
063657
063657  "BAD08;BADDV 08

063657         TAD08;3;410;0
063663  BD08R,  0;0;33;114020;0;0;IORES
063672
063672         0;0;0;0
063676  BD08W,  0;0;*-2;114020;0;0;IORES
063705
063705  "BAD09;BADDV 09

063705         TAD09;3;410;0
063711  BD09R,  0;0;33;114020;0;0;IORES
063720
063720         0;0;0;0
063724  BD09W,  0;0;*-2;114020;0;0;IORES
063733
063733  "BAD10;BADDV 10

063733         TAD10;3;410;0
063737  BD10R,  0;0;33;114020;0;0;IORES
063746
063746         0;0;0;0
063752  BD10W,  0;0;*-2;114020;0;0;IORES
063761
063761  "BAD11;BADDV 11

063761         TAD11;3;410;0
063765  BD11R,  0;0;33;114020;0;0;IORES
063774
063774         0;0;0;0
064000  BD11W,  0;0;*-2;114020;0;0;IORES
064007
064007  "BAD12;BADDV 12

064007         TAD12;3;410;0
064013  BD12R,  0;0;33;114020;0;0;IORES
064022
064022         0;0;0;0
064026  BD12W,  0;0;*-2;114020;0;0;IORES
064035
064035  "BAD13;BADDV 13

064035         TAD13;3;410;0
064041  BD13R,  0;0;33;114020;0;0;IORES
064050
064050         0;0;0;0
064054  BD13W,  0;0;*-2;114020;0;0;IORES
064063
064063  "BAD14;BADDV 14

064063         TAD14;3;410;0
064067  BD14R,  0;0;33;114020;0;0;IORES
064076
064076         0;0;0;0
064102  BD14W,  0;0;*-2;114020;0;0;IORES
064111
064111  "BAD15;BADDV 15

064111         TAD15;3;410;0
064115  BD15R,  0;0;33;114020;0;0;IORES
064124
064124         0;0;0;0
064130  BD15W,  0;0;*-2;114020;0;0;IORES
064137
064137  "BAD16;BADDV 16

064137         TAD16;3;410;0
064143  BD16R,  0;0;33;114020;0;0;IORES
064152
064152         0;0;0;0
064156  BD16W,  0;0;*-2;114020;0;0;IORES
064165
064165  "BAD17;BADDV 17

064165         TAD17;3;410;0
064171  BD17R,  0;0;33;114020;0;0;IORES
064200
064200         0;0;0;0
064204  BD17W,  0;0;*-2;114020;0;0;IORES
064213
064213  "BAD18;BADDV 18

064213         TAD18;3;410;0
064217  BD18R,  0;0;33;114020;0;0;IORES
064226
064226         0;0;0;0
064232  BD18W,  0;0;*-2;114020;0;0;IORES
064241
064241  "BAD19;BADDV 19

064241         TAD19;3;410;0
064245  BD19R,  0;0;33;114020;0;0;IORES
064254
064254         0;0;0;0
064260  BD19W,  0;0;*-2;114020;0;0;IORES
064267
064267  "BAD20;BADDV 20

064267         TAD20;3;410;0
064273  BD20R,  0;0;33;114020;0;0;IORES
064302
064302         0;0;0;0
064306  BD20W,  0;0;*-2;114020;0;0;IORES
064315
064315  "BAD21;BADDV 21

064315         TAD21;3;410;0
064321  BD21R,  0;0;33;114020;0;0;IORES
064330
064330         0;0;0;0
064334  BD21W,  0;0;*-2;114020;0;0;IORES
064343
064343  "BAD22;BADDV 22

064343         TAD22;3;410;0
064347  BD22R,  0;0;33;114020;0;0;IORES
064356
064356         0;0;0;0
064362  BD22W,  0;0;*-2;114020;0;0;IORES
064371
064371  "BAD23;BADDV 23

064371         TAD23;3;410;0
064375  BD23R,  0;0;33;114020;0;0;IORES
064404
064404         0;0;0;0
064410  BD23W,  0;0;*-2;114020;0;0;IORES
064417
064417  "BAD24;BADDV 24

064417         TAD24;3;410;0
064423  BD24R,  0;0;33;114020;0;0;IORES
064432
064432         0;0;0;0
064436  BD24W,  0;0;*-2;114020;0;0;IORES
064445
064445  "BAD25;BADDV 25

064445         TAD25;3;410;0
064451  BD25R,  0;0;33;114020;0;0;IORES
064460
064460         0;0;0;0
064464  BD25W,  0;0;*-2;114020;0;0;IORES
064473
064473  "BAD26;BADDV 26

064473         TAD26;3;410;0
064477  BD26R,  0;0;33;114020;0;0;IORES
064506
064506         0;0;0;0
064512  BD26W,  0;0;*-2;114020;0;0;IORES
064521
064521  "BAD27;BADDV 27

064521         TAD27;3;410;0
064525  BD27R,  0;0;33;114020;0;0;IORES
064534
064534         0;0;0;0
064540  BD27W,  0;0;*-2;114020;0;0;IORES
064547
064547  "BAD28;BADDV 28

064547         TAD28;3;410;0
064553  BD28R,  0;0;33;114020;0;0;IORES
064562
064562         0;0;0;0
064566  BD28W,  0;0;*-2;114020;0;0;IORES
064575
064575  "BAD29;BADDV 29

064575         TAD29;3;410;0
064601  BD29R,  0;0;33;114020;0;0;IORES
064610
064610         0;0;0;0
064614  BD29W,  0;0;*-2;114020;0;0;IORES
064623
064623  "BAD30;BADDV 30

064623         TAD30;3;410;0
064627  BD30R,  0;0;33;114020;0;0;IORES
064636
064636         0;0;0;0
064642  BD30W,  0;0;*-2;114020;0;0;IORES
064651
064651  "BAD31;BADDV 31

064651         TAD31;3;410;0
064655  BD31R,  0;0;33;114020;0;0;IORES
064664
064664         0;0;0;0
064670  BD31W,  0;0;*-2;114020;0;0;IORES
064677
064677  "BAD32;BADDV 32

064677         TAD32;3;410;0
064703  BD32R,  0;0;33;114020;0;0;IORES
064712
064712         0;0;0;0
064716  BD32W,  0;0;*-2;114020;0;0;IORES
064725
064725  "BAD33;BADDV 33

064725         TAD33;3;410;0
064731  BD33R,  0;0;33;114020;0;0;IORES
064740
064740         0;0;0;0
064744  BD33W,  0;0;*-2;114020;0;0;IORES
064753
064753  "BAD34;BADDV 34

064753         TAD34;3;410;0
064757  BD34R,  0;0;33;114020;0;0;IORES
064766
064766         0;0;0;0
064772  BD34W,  0;0;*-2;114020;0;0;IORES
065001
065001  "BAD35;BADDV 35

065001         TAD35;3;410;0
065005  BD35R,  0;0;33;114020;0;0;IORES
065014
065014         0;0;0;0
065020  BD35W,  0;0;*-2;114020;0;0;IORES
065027
065027  "BAD36;BADDV 36

065027         TAD36;3;410;0
065033  BD36R,  0;0;33;114020;0;0;IORES
065042
065042         0;0;0;0
065046  BD36W,  0;0;*-2;114020;0;0;IORES
065055
065055  "BAD37;BADDV 37

065055         TAD37;3;410;0
065061  BD37R,  0;0;33;114020;0;0;IORES
065070
065070         0;0;0;0
065074  BD37W,  0;0;*-2;114020;0;0;IORES
065103
065103  "BAD38;BADDV 38

065103         TAD38;3;410;0
065107  BD38R,  0;0;33;114020;0;0;IORES
065116
065116         0;0;0;0
065122  BD38W,  0;0;*-2;114020;0;0;IORES
065131
065131  "BAD39;BADDV 39

065131         TAD39;3;410;0
065135  BD39R,  0;0;33;114020;0;0;IORES
065144
065144         0;0;0;0
065150  BD39W,  0;0;*-2;114020;0;0;IORES
065157
065157  "BAD40;BADDV 40

065157         TAD40;3;410;0
065163  BD40R,  0;0;33;114020;0;0;IORES
065172
065172         0;0;0;0
065176  BD40W,  0;0;*-2;114020;0;0;IORES
065205
065205  "BAD41;BADDV 41

065205         TAD41;3;410;0
065211  BD41R,  0;0;33;114020;0;0;IORES
065220
065220         0;0;0;0
065224  BD41W,  0;0;*-2;114020;0;0;IORES
065233
065233  "BAD42;BADDV 42

065233         TAD42;3;410;0
065237  BD42R,  0;0;33;114020;0;0;IORES
065246
065246         0;0;0;0
065252  BD42W,  0;0;*-2;114020;0;0;IORES
065261
065261  "BAD43;BADDV 43

065261         TAD43;3;410;0
065265  BD43R,  0;0;33;114020;0;0;IORES
065274
065274         0;0;0;0
065300  BD43W,  0;0;*-2;114020;0;0;IORES
065307
065307  "BAD44;BADDV 44

065307         TAD44;3;410;0
065313  BD44R,  0;0;33;114020;0;0;IORES
065322
065322         0;0;0;0
065326  BD44W,  0;0;*-2;114020;0;0;IORES
065335
065335  "BAD45;BADDV 45

065335         TAD45;3;410;0
065341  BD45R,  0;0;33;114020;0;0;IORES
065350
065350         0;0;0;0
065354  BD45W,  0;0;*-2;114020;0;0;IORES
065363
065363  "BAD46;BADDV 46

065363         TAD46;3;410;0
065367  BD46R,  0;0;33;114020;0;0;IORES
065376
065376         0;0;0;0
065402  BD46W,  0;0;*-2;114020;0;0;IORES
065411
065411  "BAD47;BADDV 47

065411         TAD47;3;410;0
065415  BD47R,  0;0;33;114020;0;0;IORES
065424
065424         0;0;0;0
065430  BD47W,  0;0;*-2;114020;0;0;IORES
065437
065437  "BAD48;BADDV 48

065437         TAD48;3;410;0
065443  BD48R,  0;0;33;114020;0;0;IORES
065452
065452         0;0;0;0
065456  BD48W,  0;0;*-2;114020;0;0;IORES
065465
065465  "BAD49;BADDV 49

065465         TAD49;3;410;0
065471  BD49R,  0;0;33;114020;0;0;IORES
065500
065500         0;0;0;0
065504  BD49W,  0;0;*-2;114020;0;0;IORES
065513
065513  "BAD50;BADDV 50

065513         TAD50;3;410;0
065517  BD50R,  0;0;33;114020;0;0;IORES
065526
065526         0;0;0;0
065532  BD50W,  0;0;*-2;114020;0;0;IORES
065541
065541  "BAD51;BADDV 51

065541         TAD51;3;410;0
065545  BD51R,  0;0;33;114020;0;0;IORES
065554
065554         0;0;0;0
065560  BD51W,  0;0;*-2;114020;0;0;IORES
065567
065567  "BAD52;BADDV 52

065567         TAD52;3;410;0
065573  BD52R,  0;0;33;114020;0;0;IORES
065602
065602         0;0;0;0
065606  BD52W,  0;0;*-2;114020;0;0;IORES
065615
065615  "BAD53;BADDV 53

065615         TAD53;3;410;0
065621  BD53R,  0;0;33;114020;0;0;IORES
065630
065630         0;0;0;0
065634  BD53W,  0;0;*-2;114020;0;0;IORES
065643
065643  "BAD54;BADDV 54

065643         TAD54;3;410;0
065647  BD54R,  0;0;33;114020;0;0;IORES
065656
065656         0;0;0;0
065662  BD54W,  0;0;*-2;114020;0;0;IORES
065671
065671  "BAD55;BADDV 55

065671         TAD55;3;410;0
065675  BD55R,  0;0;33;114020;0;0;IORES
065704
065704         0;0;0;0
065710  BD55W,  0;0;*-2;114020;0;0;IORES
065717
065717  "BAD56;BADDV 56

065717         TAD56;3;410;0
065723  BD56R,  0;0;33;114020;0;0;IORES
065732
065732         0;0;0;0
065736  BD56W,  0;0;*-2;114020;0;0;IORES
065745
065745  "BAD57;BADDV 57

065745         TAD57;3;410;0
065751  BD57R,  0;0;33;114020;0;0;IORES
065760
065760         0;0;0;0
065764  BD57W,  0;0;*-2;114020;0;0;IORES
065773
065773  "BAD58;BADDV 58

065773         TAD58;3;410;0
065777  BD58R,  0;0;33;114020;0;0;IORES
066006
066006         0;0;0;0
066012  BD58W,  0;0;*-2;114020;0;0;IORES
066021
066021  "BAD59;BADDV 59

066021         TAD59;3;410;0
066025  BD59R,  0;0;33;114020;0;0;IORES
066034
066034         0;0;0;0
066040  BD59W,  0;0;*-2;114020;0;0;IORES
066047
066047  "BAD60;BADDV 60

066047         TAD60;3;410;0
066053  BD60R,  0;0;33;114020;0;0;IORES
066062
066062         0;0;0;0
066066  BD60W,  0;0;*-2;114020;0;0;IORES
066075
066075  "BAD61;BADDV 61

066075         TAD61;3;410;0
066101  BD61R,  0;0;33;114020;0;0;IORES
066110
066110         0;0;0;0
066114  BD61W,  0;0;*-2;114020;0;0;IORES
066123
066123  "BAD62;BADDV 62

066123         TAD62;3;410;0
066127  BD62R,  0;0;33;114020;0;0;IORES
066136
066136         0;0;0;0
066142  BD62W,  0;0;*-2;114020;0;0;IORES
066151
066151  "BAD63;BADDV 63

066151         TAD63;3;410;0
066155  BD63R,  0;0;33;114020;0;0;IORES
066164
066164         0;0;0;0
066170  BD63W,  0;0;*-2;114020;0;0;IORES
066177
066177  "BAD64;BADDV 64

066177         TAD64;3;410;0
066203  BD64R,  0;0;33;114020;0;0;IORES
066212
066212         0;0;0;0
066216  BD64W,  0;0;*-2;114020;0;0;IORES
066225
066225  "BAD65;BADDV 65

066225         TAD65;3;410;0
066231  BD65R,  0;0;33;114020;0;0;IORES
066240
066240         0;0;0;0
066244  BD65W,  0;0;*-2;114020;0;0;IORES
066253
066253  "BAD66;BADDV 66

066253         TAD66;3;410;0
066257  BD66R,  0;0;33;114020;0;0;IORES
066266
066266         0;0;0;0
066272  BD66W,  0;0;*-2;114020;0;0;IORES
066301
066301  "BAD67;BADDV 67

066301         TAD67;3;410;0
066305  BD67R,  0;0;33;114020;0;0;IORES
066314
066314         0;0;0;0
066320  BD67W,  0;0;*-2;114020;0;0;IORES
066327
066327  "BAD68;BADDV 68

066327         TAD68;3;410;0
066333  BD68R,  0;0;33;114020;0;0;IORES
066342
066342         0;0;0;0
066346  BD68W,  0;0;*-2;114020;0;0;IORES
066355
066355  "BAD69;BADDV 69

066355         TAD69;3;410;0
066361  BD69R,  0;0;33;114020;0;0;IORES
066370
066370         0;0;0;0
066374  BD69W,  0;0;*-2;114020;0;0;IORES
066403
066403  "BAD70;BADDV 70

066403         TAD70;3;410;0
066407  BD70R,  0;0;33;114020;0;0;IORES
066416
066416         0;0;0;0
066422  BD70W,  0;0;*-2;114020;0;0;IORES
066431
066431  "
066431  9BDSL=*
066431
066431
066431
066431  "8SMO1+8SMO2+8SMO3+8SMO4+8SMO5+8SMO6+8SMO7+8SMO8+8SMO9+9SMO1+9SMO2+9SMO3+9SMO4+9SMO5+9SMO6+9SMO7
066431  %==============================================================================
066431  % 28.8       M O D E M  D A T A F I E L D S
066431  %
066431  "8SMO1
066431  % MODEM INPUT DATAFIELD
066431         0;0;0;0;0
066436         0;0;0;0;MOTMI;0;-16
066445         IOX 100;MODIN;MODI1
066450  IDMO1, 0;0;*-2;110000;0;0;IOREM
066457         MOTRI;TEXIT;MOSTI;UDMO1;0
066464         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
066473         MIBU1+MIBU1
066474
066474  %%XBU=BUF+MIBU1;)KILL BUF;BUF=XBU;)KILL XBU
066474
066474  "8SMO1
066474  % MODEM OUTPUT DATAFIELD
066474         0;0;0;0;0
066501         0;0;0;0;MOTMO;0;-3
066510         IOX 104;MODUT;MODUT
066513  UDMO1, 0;0;*-2;110000;0;0;IORES
066522         MOTRO;TEXIT;MOSTO;IDMO1;0
066527         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
066535
066535  %%XBU=BUF+MOBU1;)KILL BUF;BUF=XBU;)KILL XBU
066535
066535  "8SMO2
066535  % MODEM INPUT DATAFIELD
066535         0;0;0;0;0
066542         0;0;0;0;MOTMI;0;-16
066551         IOX 110;MODIN;MODI1
066554  IDMO2, 0;0;*-2;110000;0;0;IOREM
066563         MOTRI;TEXIT;MOSTI;UDMO2;0
066570         BUF;MIBU2+MIBU2;0;0;MIBU2+MIBU2;0;0
066577         MIBU2+MIBU2
066600
066600  %XXBU=BUF+MIBU2;)KILL BUF;BUF=XBU;)KILL XBU
066600
066600  "8SMO2
066600  % MODEM OUTPUT DATAFIELD
066600         0;0;0;0;0
066605         0;0;0;0;MOTMO;0;-3
066614         IOX 114;MODUT;MODUT
066617  UDMO2, 0;0;*-2;110000;0;0;IORES
066626         MOTRO;TEXIT;MOSTO;IDMO2;0
066633         BUF;MOBU2+MOBU2;0;0;MOBU2+MOBU2;0
066641
066641  %XXBU=BUF+MOBU2;)KILL BUF;BUF=XBU;)KILL XBU
066641
066641  "
066641

066641  %==============================================================================
066641  % 28.11      P H O T O S E T T E R  D A T A F I E L D S
066641  %
066641  "8PUN1
066641  % PAPERTAPE PUNCH DATAFIELD
066641
066641         0;0;TTOMR;0;-3
066646         410;WPUNC;WPUNC
066651  DPNCH, 0;0;*-2;110000;0;0;IORES
066660         TTPUT;DMOUT;CEXIT;0;0
066665         BUF;100+100;0;0;100+100;0;100
066674  %XBU=BUF+100;)KILL BUF;BUF=XBU;)KILL XBU
066674
066674  "
066674
066674
066674
066674
066674
066674
066674  ERTDT=*
066674
066674  "8BEX1
066674
066674  %=======================================================================
066674  % 28.21      DATAFIELD FOR BUS EXPANDER
066674  %
066674
066674         100000;BUSEX;BUSEX
066677  BEXDA, 0;0;*-2;2
066703
066703  "8MPM4
066703
066703  %=======================================================================
066703  % 28.22      DATAFIELD FOR MULTIPORT IV
066703  %
066703
066703         100200;BUSCD;BUSCD
066706  MPM4D, 0;0;*-2;2
066712
066712  "
066712  )LINE

066712  %%%%%%%%%%%%  M A C R O E S  -  S I N 2  -  G E N  %%%%%%%%%%%%%%%%%%%%%
066712
066712  %%     MACROES USED ON SIN2-GEN
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712  %%     PREVIOUSLY USED MACROES ARE KILLED
066712  )KILL DFFLD TPAIR GXTRM GTERM BADDV MBNIU MSOLU MSODV MSDEV
066712  )KILL MSUNI MSOUN MSLUN HDDMA HDIO  DFFL2
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712
066712
066712  % MACRO FOR INTERNAL DEVICE IN
066712
066712  )MCDEF IDVI $NAM,$NOC,$TCHAR
$NAM I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
       $NAM O;0;BUF;$NOC +$NOC ;0;0;$NOC +$NOC ;0
       1210+XIBNX;1211+XIBNX;1;0;$TCHAR ;0
%%XBU=BUF+$NOC ;)KILL BUF;BUF=XBU;)KILL XBU
"8S3C
BUF=*; )KILL BUF; *+$NOC /
"
]
066712
066712  % MACRO FOR INTERNAL DEVICE OUT
066712
066712  )MCDEF IDVO $NAM
$NAM O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;$NAM I;0
       0;0;0;0;0;0
       1210+XIBNX;1272+YIBNY;0;0
YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
]
066712
066712  % MACRO FOR INTERNAL BLOCK DEVICE
066712
066712  )MCDEF BLIDV $NAM
       0;0;$NAM O
$NAM I, 0;0;*-2;102;0;0;0;0;0;IMTRI;0;0

       $NAM I
$NAM O, 0;0;*-2;102;0;0;0;0;0;IMTRO;0;0
]
066712
066712  % MACROS FOR COUNTING INTERNAL DEVICES FOR MON CONFIG
066712
066712  )MCDEF 0IICN
0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
]
066712
066712  )MCDEF 0BBCN
0ZZZZ=0BBBB+1;)KILL 0BBBB;0BBBB=0ZZZZ;)KILL 0ZZZZ
]
066712
066712  % MACRO FOR SIBAS INT. DEV.:
066712  )MCDEF SIB $NAM
$NAM I,0;0;*-2;110000;0;0;IORES;GETDW;ISTDV;CLBUF
       $NAM O;0;BUF;200;0;0;200;0;0;0;200;0;177;0
%%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU

$NAM O, 0;0;*-2;110000;0;0;IORES;PUTDW;OSTDV;CEXIT;$NAM I;0
]
066712
066712
066712  % MACRO FOR ALLOCATING AREA WITH ZEROES
066712  )MCDEF BSPAC $NOADR
*<*+$NOADR -1
)ZERO
*+$NOADR /
]
066712  % MACRO FOR TEKTRONIX DISPLAY
066712
066712  )MCDEF TXTRO $NAM,$HNO,$MAXX,$MAXY,$MAXZ
TEXTR; $MAXY ;$MAXZ ;IOX $HNO ;0 ; $MAXX ;
$NAM , 0; 0; *-2; 0
]
066712
066712  % BATCH PROCESS MACRO
066712  )MCDEF BCHD $NAM,$GBACK,$SIZ

       33;0;0;0;0;0;0;0;0;0;0;0;0;0
$NAM R, 0;0;*-2;110002;0;0;IORES
       0;TEXIT;CEXIT;$NAM W;0
       0;0;0;0;BATNO;0
       0;0;$GBACK ;0;0;0
       0;0;0;0;0;0;0;0
       0;0;0

$NAM W, 0;0;*-2;110002;0;0;IORES
       0;0;CEXIT;$NAM R;0
       0;0;0;0;BATNO;0
       0;0;0

$NAM O, 0;0;*-2;110002;0;0;IORES
       IPTCH;OSTDV;CLBUF;$NAM I;0

$NAM I, 0;0;*-2;110002;0;0;IORES
       IGTCH;ISTDV;CLBUF;$NAM O;0
       BUF;$SIZ +$SIZ ;0;0;$SIZ +$SIZ ;0;0;0;20;0;47;0
%%XBU=BUF+$SIZ ;)KILL BUF;BUF=XBU;)KILL XBU
BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
]
066712
066712  % BATCH QUE INT DEV MACRO
066712  )MCDEF BACQD $NAM
$NAM O, 0;0;*-2;110002;0;0;IORES
       IPTCH;OSTDV;CLBUF;$NAM I;0

$NAM I, 0;0;*-2;110002;0;0;IORES
       IGTCH;ISTDV;CLBUF;$NAM O;0
       BUF;0 ;0;0;0;0;0;0;20;0;47;0
]
066712
066712  %MACROES FOR NORDCOM (SGB,SEL,GB,TB)
066712
066712
066712
066712  "8UDMA+8VICO
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712  %%      DATAFIELD DEFINITION AND
066712  %%      DATAFIELD INITIALIZATION FOR UDMA
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712  )MCDEF GUDMA $NR,$HD

 %---------------------------------------- UDMA (INPUT) DATAFIELD $NR ;
        0;0;0;0;0
        0;0;0;0;0;0;0;0
        0;0;0;0;0;0;0;0
        0;0;0;0;0;0;ND852;UBUSY
        UFIN;UBUSY;UDTMO; 0;177771;$HD ;USDRV;UDDRV
UDI$NR ,  0;0;*-2;2000;0;0;RETRA;0
        0;MTRNS;UDO$NR ;0;0;0
        0;0;0;0;0;0;0
 %--------------------------------------- OUPUT DATAFIELD FOR UDMA$NR ;
UDO$NR ,  0;0;*-2;0;0;0;IORES;*+4
        *+4;*+5;*+5;0;0;0;0;0               % ABSTR PARAMETER LIST
        0;UDF$NR ;*+1;0;0;0;0;0               % 22/*+1 DFPNT  MONITOR CALL
        0;0;0;0;0;0;0;0                     %               WORKING AREA
        0;0;0;0;0;0;0;0                     %
        0;0;0;0;0;0;0;0;0                   % MAX DISP: 36
"8VICO+8UDMA 8F5UD
%---------------------------------------- DATAFIELD FOR UDR$NR ;
UDF$NR ,  0;0;*-2;0;0;0;RIOWA;0               % FAST UDMA FORM ND-500
        *+4;*+4;*+5;*+5;0;0;0;0             % ABSTR PARAMETER LIST
        0;0
"8UDMA+8VICO
)FILL
]
066712  "
066712
066712  "8GPI0+8GPI1+8GPI2+8GPI3+8GPI4+8GPI5+8GPI6+8GPI7
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712  %%      DATAFIELD DEFINITION AND
066712  %%      DATAFIELD INITIALIZATION FOR GPIB
066712  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
066712  )MCDEF GGPIB $NO,$HDV
%------------------------------------------  GPIB (INPUT)DATAFIELD $NO ;
       GPIBT;4000;400;0;0;                % GPXTR DSIZE USIZE GPRUN GPBSI
       GPIBD;GPBUS;GPFIN;GPERR;           % STANDARD PART
       MTMRS;0;-7;$HDV ;GPITR;GPITR
DTGP$NO , 0;0;*-2;0;0;0;RETRA;0;0;MTRNS
       #0$NO ;0;                          % GPIBN ACTIV
       0;0;0;0;0;0;0;0;0                  % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32
       0;0;0;0;0;0                        % XTBLK SXTBL CPORT SPORT DPORT DMESA
       0;0;0;0;0;0;0;0                    % DBUFA       MVERS SUSFL DEVFL USCON CGPIM CURMTY
       0;0;0;0;0;0;0;0                    % CURMN       ERADD XERCO SRQFL MRETA SRETA GRETA
       0;0;0;0;0;0;0;0                    % STREG SAREG SDREG SXREG DINPT PIODP PIOWC FIRST
       0;*+20/;*+40/                      % SRSTR UMESS(20)   MNARR(2*20)
       0;0;*+10/;0;0;0;*+40/              % CURFU CGPUS INSTA(10)   CURAD       CURBC UENV(2*20)
]
066712  "
066712
066712  )LINE
%

066712  %==============================================================================
066712  %      S I N 2 - G E N
066712  %==============================================================================
066712  %
066712  % BUFFER FOR ERROR-MESSAGES TO AN EPSON-PRINTER CONNECTED TO
066712  % A TANDBERG TERMINAL
066712  %
066712          0        % EBULINK
066713          200      % EBUMAX
066714          0        % EBUHENTE
066715          0        % EBUFYLLE
066716  E1BUF,  15521    % CONTROL CHARACTERS TO ROUTE MESSAGE TO THE PRINTER
066717          15521
066720          15533
066721          32551
066722          *+102/   % CHARACTER BUFFER
067024
067024          E1BUF    % EBULINK
067025          200      % EBUMAX
067026          0        % EBUHENTE
067027          0        % EBUFYLLE
067030  E2BUF,  15521    % CONTROL CHARACTERS TO ROUTE MESSAGE TO THE PRINTER
067031          15521
067032          15533
067033          32551
067034          *+102/   % CHARACTER BUFFER
067136
067136  % ERROR MESSAGE TIMER DATAFIELD
067136          EBUTM    % TMSUB
067137          0        % TMR
067140          -2       % TTMR
067141          0;0;0
067144  EBUTD,  0;0;0;0
067150
067150
067150
067150
067150  "8CD01
067150  %

067150
067150  %==============================================================================
067150  % 28.41      C O N N E C T  D A T A F I E L D S
067150  %
067150  % "CONNECT" DATAFIELDS
067150  %
067150
067150  "8CD01
067150         0;0;DDRIV;DDRIV
067154  CDF01, 0;0;*-2;20000;0;0;DMONI
067163
067163  "8CD02
067163         0;0;DDRIV;DDRIV
067167  CDF02, 0;0;*-2;20000;0;0;DMONI
067176
067176  "
067176
067176  %==============================================================================
067176  % 28.42      S E M A P H O R E  D A T A F I E L D S
067176  %
067176  % SEMAPHORES
067176  0SEFI=*
067176
067176  SEMI1, 0;0;*-2;0
067202  SEMI2, 0;0;*-2;0
067206  SEMI3, 0;0;*-2;0
067212  SEMI4, 0;0;*-2;0
067216  SEMI5, 0;0;*-2;0
067222  "8SM10+8SM20+8SM30+8SM40+8SM50
067222  SEMI6, 0;0;*-2;0
067226  SEMI7, 0;0;*-2;0
067232  SEMI8, 0;0;*-2;0
067236  SEMI9, 0;0;*-2;0
067242  SEM10, 0;0;*-2;0
067246  "8SM20+8SM30+8SM40+8SM50
067246  SEM11, 0;0;*-2;0
067252  SEM12, 0;0;*-2;0
067256  SEM13, 0;0;*-2;0
067262  SEM14, 0;0;*-2;0
067266  SEM15, 0;0;*-2;0
067272  SEM16, 0;0;*-2;0
067276  SEM17, 0;0;*-2;0
067302  SEM18, 0;0;*-2;0
067306  SEM19, 0;0;*-2;0
067312  SEM20, 0;0;*-2;0
067316  "8SM30+8SM40+8SM50
067316  SEM21, 0;0;*-2;0
067322  SEM22, 0;0;*-2;0
067326  SEM23, 0;0;*-2;0
067332  SEM24, 0;0;*-2;0
067336  SEM25, 0;0;*-2;0
067342  SEM26, 0;0;*-2;0
067346  SEM27, 0;0;*-2;0
067352  SEM28, 0;0;*-2;0
067356  SEM29, 0;0;*-2;0
067362  SEM30, 0;0;*-2;0
067366  "8SM40+8SM50
067366  SEM31, 0;0;*-2;0
067372  SEM32, 0;0;*-2;0
067376  SEM33, 0;0;*-2;0
067402  SEM34, 0;0;*-2;0
067406  SEM35, 0;0;*-2;0
067412  SEM36, 0;0;*-2;0
067416  SEM37, 0;0;*-2;0
067422  SEM38, 0;0;*-2;0
067426  SEM39, 0;0;*-2;0
067432  SEM40, 0;0;*-2;0
067436  "8SM50
067436  SEM41, 0;0;*-2;0
067442  SEM42, 0;0;*-2;0
067446  SEM43, 0;0;*-2;0
067452  SEM44, 0;0;*-2;0
067456  SEM45, 0;0;*-2;0
067462  SEM46, 0;0;*-2;0
067466  SEM47, 0;0;*-2;0
067472  SEM48, 0;0;*-2;0
067476  SEM49, 0;0;*-2;0
067502  SEM50, 0;0;*-2;0
067506  "
067506  0SELA=*
067506  % SEMAPHORES RESERVED FOR THE BACKUP-SYSTEM
067506  SEM60, 0;0;*-2;2
067512  SEM61, 0;0;*-2;2
067516  SEM62, 0;0;*-2;2
067522  SEM63, 0;0;*-2;2
067526  SEM64, 0;0;*-2;2
067532
067532
067532

067532  %==============================================================================
067532  % 28.43      F I L E S Y S T E M  S E M A P H O R E  D A T A F I E L D S
067532  %
067532  % FILE SYSTEM SEMAPHORES
067532
067532
067532  9SFIS=*
067532  REESM, 0;0;*-2;2
067536  RTLFI, 0;0;*-2;2
067542  FS4,   0;0;*-2;2
067546  FS5,   0;0;*-2;2
067552  FS6,   0;0;*-2;2
067556  FS7,   0;0;*-2;2
067562
067562  FS20,  0;0;*-2;0             % GRAFS SEMAPHORE NO. 2
067566  FS21,  0;0;*-2;2
067572
067572  FS27,  0;0;*-2;2
067576  "8MT1+8MT2+8MT3+8MT4
067576  FS61,  0;0;*-2;2
067602  "SLP11
067602  FS62,  0;0;*-2;2
067606  "3B1U0+6B1U0+7B1U0+2B1U0+4B1U0+3C1U0+6C1U0+9C1U0+3D1U0+2D1U0+1E1U0+2E1U0+3E1U0+5E1U0+7E1U0+8E1U0+EE1U0+FE1U0+GE1U0+HE1U0+8S1U0
067606  F1101, 0;0;*-2;2
067612  F1102, 0;0;*-2;2
067616  "3B1U1+6B1U1+7B1U1+2B1U1+4B1U1+3C1U1+6C1U1+9C1U1+3D1U1+2D1U1+1E1U1+2E1U1+3E1U1+5E1U1+7E1U1+8E1U1+EE1U1+FE1U1+GE1U1+HE1U1+8S1U1
067616  F1117, 0;0;*-2;2
067622  F1120, 0;0;*-2;2
067626  "3B1U2+6B1U2+7B1U2+2B1U2+4B1U2+3C1U2+6C1U2+9C1U2+3D1U2+2D1U2+1E1U2+2E1U2+3E1U2+5E1U2+7E1U2+8E1U2+EE1U2+FE1U2+GE1U2+HE1U2
067626  F1121, 0;0;*-2;2
067632  F1122, 0;0;*-2;2
067636  "3B1U3+6B1U3+7B1U3+2B1U3+4B1U3+3C1U3+6C1U3+9C1U3+3D1U3+2D1U3+1E1U3+2E1U3+3E1U3+5E1U3+7E1U3+8E1U3+EE1U3+FE1U3+GE1U3+HE1U3
067636  F1123, 0;0;*-2;2
067642  F1124, 0;0;*-2;2
067646  "8M1U3
067646  F1127, 0;0;*-2;2
067652  "SLP1+CSP12
067652  F1136, 0;0;*-2;2
067656  F1137, 0;0;*-2;2
067662  "SLP2
067662  F1140, 0;0;*-2;2
067666  F1141, 0;0;*-2;2
067672  "
067672  F1142, 0;0;*-2;2
067676  F1143, 0;0;*-2;2
067702  F1144, 0;0;*-2;2
067706  % *************
067706  "8F1U0
067706  F1150, 0;0;*-2;2
067712  F1151, 0;0;*-2;2
067716  "8F1U1
067716  F1152, 0;0;*-2;2
067722  F1153, 0;0;*-2;2
067726  "8F1U2
067726  F1154, 0;0;*-2;2
067732  F1155, 0;0;*-2;2
067736  "8F2U0
067736  F1161, 0;0;*-2;2
067742  F1162,0;0;*-2;2
067746  "8F2U1
067746  F1163, 0;0;*-2;2
067752  F1164, 0;0;*-2;2
067756  "8F2U2
067756  F1165, 0;0;*-2;2
067762  F1166, 0;0;*-2;2
067766  "SLP3
067766  F1173, 0;0;*-2;2
067772  F1174, 0;0;*-2;2
067776  "
067776  F1177, 0;0;*-2;2
070002  "-8S3C
070002  D1201, 0;0;*-2;2             % DMAC
070006  "8LOG
070006  F1202, 0;0;*-2;2             % RT-PROGRAM-LOG
070012  "
070012  F1204, 0;0;*-2;2             % SERVICE PROGRAM
070016  F1205, 0;0;*-2;2             % MAIL
070022  F1222, 0;0;*-2;2             % TERMINATION COMMANDS BUFFER LOCK
070026  F602,  0;0;*-2;2             % DEFAULT SUBSYSTEM COMMANDS BUFFER LOCK
070032  F1223, 0;0;*-2;0             % GRAFS SEMAPHORE NO. 1
070036  "SLP4
070036  FS532, 0;0;*-2;2
070042  FS533, 0;0;*-2;2
070046  "SLP5
070046  FS534, 0;0;*-2;2
070052  FS535, 0;0;*-2;2
070056  "SLP6
070056  FS536, 0;0;*-2;2
070062  FS537, 0;0;*-2;2
070066  "SLP7
070066  F1262, 0;0;*-2;2
070072  F1263, 0;0;*-2;2
070076  "SLP8
070076  F1264, 0;0;*-2;2
070102  F1265, 0;0;*-2;2
070106  "SLP9
070106  F1266, 0;0;*-2;2
070112  F1267, 0;0;*-2;2
070116  "SLP10
070116  F1270, 0;0;*-2;2
070122  F1271, 0;0;*-2;2
070126  "3B2U0+6B2U0+7B2U0+2B2U0+4B2U0+3C2U0+6C2U0+9C2U0+3D2U0+2D2U0+1E2U0+2E2U0+3E2U0+5E2U0+7E2U0+8E2U0+EE2U0+FE2U0+GE2U0+HE2U0+8S2U0
070126  F1333, 0;0;*-2;2
070132  F1334, 0;0;*-2;2
070136  "3B2U1+6B2U1+7B2U1+2B2U1+4B2U1+3C2U1+6C2U1+9C2U1+3D2U1+2D2U1+1E2U1+2E2U1+3E2U1+5E2U1+7E2U1+8E2U1+EE2U1+FE2U1+GE2U1+HE2U1+8S2U1
070136  F1335, 0;0;*-2;2
070142  F1336, 0;0;*-2;2
070146  "3B2U2+6B2U2+7B2U2+2B2U2+4B2U2+3C2U2+6C2U2+9C2U2+3D2U2+2D2U2+1E2U2+2E2U2+3E2U2+5E2U2+7E2U2+8E2U2+EE2U2+FE2U2+GE2U2+HE2U2
070146  F1337, 0;0;*-2;2
070152  F1340, 0;0;*-2;2
070156  "3B2U3+6B2U3+7B2U3+2B2U3+4B2U3+3C2U3+6C2U3+9C2U3+3D2U3+2D2U3+1E2U3+2E2U3+3E2U3+5E2U3+7E2U3+8E2U3+EE2U3+FE2U3+GE2U3+HE2U3
070156  F1341, 0;0;*-2;2
070162  F1342, 0;0;*-2;0
070166  "SLP11
070166  F1347, 0;0;*-2;2
070172  "SLP12
070172  F1350, 0;0;*-2;2
070176  F1351, 0;0;*-2;2
070202  "SLP13
070202  F1722, 0;0;*-2;2
070206  F1723, 0;0;*-2;2
070212  "SLP14
070212  F1724, 0;0;*-2;2
070216  F1725, 0;0;*-2;2
070222  "SLP15
070222  F1726, 0;0;*-2;2
070226  F1727, 0;0;*-2;2
070232  "SLP16
070232  F2130, 0;0;*-2;2
070236  F2131, 0;0;*-2;2
070242  "SLP17
070242  F2132, 0;0;*-2;2
070246  F2133, 0;0;*-2;2
070252  "SLP18
070252  F2134, 0;0;*-2;2
070256  F2135, 0;0;*-2;2
070262  "SLP19
070262  F2136, 0;0;*-2;2
070266  F2137, 0;0;*-2;2
070272  "SLP20
070272  F2140, 0;0;*-2;2
070276  F2141, 0;0;*-2;2
070302  "SLP21
070302  F2142, 0;0;*-2;2
070306  F2143, 0;0;*-2;2
070312  "SLP22
070312  F2144, 0;0;*-2;2
070316  F2145, 0;0;*-2;2
070322  "8COSP
070322  F1731, 0;0;*-2;2                       % COSMOS SPOOLING PERIPHERAL DEVICE
070326  F2166, 0;0;*-2;2                       % COSMOS SPOOLING QUEUE SEMAPHORE
070332  F2167, 0;0;*-2;2                       % COSMOS SPOOLING I/O SEMAPHORE
070336
070336  "4M1U0+2M1U0+1M1U0+3M1U0+7M1U0
070336  F1732, 0;0;*-2;2                       % MICROPOLIS DISK CONTROLLER 1, UNIT 0 DIRECTORY LOCK.
070342  F1734, 0;0;*-2;2                       % MICROPOLIS DISK CONTROLLER 1, UNIT 0 BIT FILE LOCK.
070346  "4M1U1+2M1U1+1M1U1+3M1U1+7M1U1
070346  F1733, 0;0;*-2;2                       % MICROPOLIS DISK CONTROLLER 1, UNIT 1 DIRECTORY LOCK.
070352  F1735, 0;0;*-2;2                       % MICROPOLIS DISK CONTROLLER 1, UNIT 1 BIT FILE LOCK.
070356  "
070356
070356  "8NSDB
070356  % WORKING DATAFIELD FOR DEBUGGER MON CALL
070356  % USED TO ENSURE CORRECT SYNCRONIZATION
070356  DDEBU, 0;0;*-2;0;0;0;0;
070365         0;0;0  ;0;0;0;0;
070374         0;0;0  ;0;0;0
070402  "8NSDB CXCPU
070402         *-3;*-3;0;*-5;*-5           % PARAMETER LISTE FOR MON RFILE
070407         0;0;0;0;0;0;0;0
070417  "
070417  % "8LAMU
070417  %===========================================================================
070417  %      M D L A M
070417  %
070417  % MONITOR CALL WORKING FIELD FOR MON LAMU
070417  %
070417  MDLAM, 0;0;*-2;0
070423  *+44/
070467  % TIMER DATAFIELD FOR LAMU
070467         LTSUB;0;-1;0;0;0
070475  TLAMD, 0;0;*-2;2;0;0;0;0
070505         *+4;*+4;*+4;*+4;2;0;0;0
070515
070515
070515  UESEM, 0;0;*-2;2             % UEADM SEMAPHORE
070521  NAMSE, 0;0;*-2;2             % RTFIL SEMAPHORE
070525  ACSEM, 0;0;*-2;0             % ACCOUNTING SEMAPHORE
070531  "8DILG
070531  SEMDL, 0;0;*-2;2             % DISC-ACCESS-LOG BUFFER LOCK
070535  "BADAD
070535  BDSEM, 0;0;*-2;2             % TAD SEMAPHORES
070541  F601,  0;0;*-2;2             % BASEM
070545  "8VSX0
070545  F2500, 0;0;*-2;2
070551  F2501, 0;0;*-2;2
070555  F2502, 0;0;*-2;2
070561  F2503, 0;0;*-2;2
070565  F2504, 0;0;*-2;2
070571  F2505, 0;0;*-2;2
070575  F2506, 0;0;*-2;2
070601  F2507, 0;0;*-2;2
070605  F2510, 0;0;*-2;2
070611  F2511, 0;0;*-2;2
070615  F2512, 0;0;*-2;2
070621  F2513, 0;0;*-2;2
070625  F2514, 0;0;*-2;2
070631  F2515, 0;0;*-2;2
070635  F2516, 0;0;*-2;2
070641  F2517, 0;0;*-2;2
070645  F2520, 0;0;*-2;2
070651  F2521, 0;0;*-2;2
070655  F2522, 0;0;*-2;2
070661  F2523, 0;0;*-2;2
070665  F2524, 0;0;*-2;2
070671  F2525, 0;0;*-2;2
070675  F2526, 0;0;*-2;2
070701  F2527, 0;0;*-2;2
070705  F2530, 0;0;*-2;2
070711  F2531, 0;0;*-2;2
070715  F2532, 0;0;*-2;2
070721  F2533, 0;0;*-2;2
070725  F2534, 0;0;*-2;2
070731  F2535, 0;0;*-2;2
070735  F2536, 0;0;*-2;2
070741  F2537, 0;0;*-2;2
070745  F2540, 0;0;*-2;2
070751  F2541, 0;0;*-2;2
070755  F2542, 0;0;*-2;2
070761  F2543, 0;0;*-2;2
070765  F2544, 0;0;*-2;2
070771  F2545, 0;0;*-2;2
070775  F2546, 0;0;*-2;2
071001  F2547, 0;0;*-2;2
071005  F2550, 0;0;*-2;2
071011  F2551, 0;0;*-2;2
071015  F2552, 0;0;*-2;2
071021  F2553, 0;0;*-2;2
071025  F2554, 0;0;*-2;2
071031  F2555, 0;0;*-2;2
071035  F2556, 0;0;*-2;2
071041  F2557, 0;0;*-2;2
071045  F2560, 0;0;*-2;2
071051  F2561, 0;0;*-2;2
071055  F2562, 0;0;*-2;2
071061  F2563, 0;0;*-2;2
071065  F2564, 0;0;*-2;2
071071  F2565, 0;0;*-2;2
071075  F2566, 0;0;*-2;2
071101  F2567, 0;0;*-2;2
071105  F2570, 0;0;*-2;2
071111  F2571, 0;0;*-2;2
071115  F2572, 0;0;*-2;2
071121  F2573, 0;0;*-2;2
071125  F2574, 0;0;*-2;2
071131  F2575, 0;0;*-2;2
071135  F2576, 0;0;*-2;2
071141  F2577, 0;0;*-2;2
071145  F2600, 0;0;*-2;2
071151  F2601, 0;0;*-2;2
071155  F2602, 0;0;*-2;2
071161  F2603, 0;0;*-2;2
071165  F2604, 0;0;*-2;2
071171  F2605, 0;0;*-2;2
071175  F2606, 0;0;*-2;2
071201  F2607, 0;0;*-2;2
071205  F2610, 0;0;*-2;2
071211  F2611, 0;0;*-2;2
071215  F2612, 0;0;*-2;2
071221  F2613, 0;0;*-2;2
071225  F2614, 0;0;*-2;2
071231  F2615, 0;0;*-2;2
071235  F2616, 0;0;*-2;2
071241  F2617, 0;0;*-2;2
071245  F2620, 0;0;*-2;2
071251  F2621, 0;0;*-2;2
071255  F2622, 0;0;*-2;2
071261  F2623, 0;0;*-2;2
071265  F2624, 0;0;*-2;2
071271  F2625, 0;0;*-2;2
071275  F2626, 0;0;*-2;2
071301  F2627, 0;0;*-2;2
071305  F2630, 0;0;*-2;2
071311  F2631, 0;0;*-2;2
071315  F2632, 0;0;*-2;2
071321  F2633, 0;0;*-2;2
071325  F2634, 0;0;*-2;2
071331  F2635, 0;0;*-2;2
071335  F2636, 0;0;*-2;2
071341  F2637, 0;0;*-2;2
071345  "
071345
071345  9EFIS=*
071345
071345  F1200, 0;0;*-2;0             % *** SPECIAL FOR NORD TPS ***
071351  "8LOG
071351  F1352, 0;0;*-2;2
071355  "
071355

071355  %==============================================================================
071355  % 28.44      I N T E R N A L  D E V I C E  D A T A F I E L D S
071355  %
071355  % INTERNAL DEVICES
071355
071355
071355
071355  0IIII=0; 0BBBB=0
071355  "IND01+IBL01
071355  IDVI ID01,IDBUS,TERMC

071355
071355  ID01I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
071367         ID01O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
071377         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
071405  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
071405  "
071405
071405
071405  IDVO ID01

071405
071405  ID01O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID01I;0
071421         0;0;0;0;0;0
071427         1210+XIBNX;1272+YIBNY;0;0
071433  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
071433  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
071433
071433  0IICN

071433  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
071433  "IBL01
071433  BLIDV IB01

071433         0;0;IB01O
071436  IB01I, 0;0;*-2;102;0;0;0;0;0;IMTRI;0;0
071452
071452         IB01I
071453  IB01O, 0;0;*-2;102;0;0;0;0;0;IMTRO;0;0
071467
071467  0BBCN

071467  0ZZZZ=0BBBB+1;)KILL 0BBBB;0BBBB=0ZZZZ;)KILL 0ZZZZ
071467
071467  "IND02+IBL02
071467  IDVI ID02,IDBUS,TERMC

071467
071467  ID02I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
071501         ID02O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
071511         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
071517  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
071517  "
071517
071517
071517  IDVO ID02

071517
071517  ID02O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID02I;0
071533         0;0;0;0;0;0
071541         1210+XIBNX;1272+YIBNY;0;0
071545  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
071545  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
071545
071545
071545  0IICN

071545  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
071545  "IBL02
071545  BLIDV IB02

071545         0;0;IB02O
071550  IB02I, 0;0;*-2;102;0;0;0;0;0;IMTRI;0;0
071564
071564         IB02I
071565  IB02O, 0;0;*-2;102;0;0;0;0;0;IMTRO;0;0
071601
071601  0BBCN

071601  0ZZZZ=0BBBB+1;)KILL 0BBBB;0BBBB=0ZZZZ;)KILL 0ZZZZ
071601
071601  "IND03+IBL03
071601  IDVI ID03,IDBUS,TERMC

071601
071601  ID03I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
071613         ID03O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
071623         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
071631  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
071631  "
071631
071631
071631  IDVO ID03

071631
071631  ID03O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID03I;0
071645         0;0;0;0;0;0
071653         1210+XIBNX;1272+YIBNY;0;0
071657  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
071657  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
071657
071657
071657  0IICN

071657  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
071657  "IND04+IBL04
071657  IDVI ID04,IDBUS,TERMC

071657
071657  ID04I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
071671         ID04O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
071701         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
071707  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
071707  "
071707
071707
071707  IDVO ID04

071707
071707  ID04O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID04I;0
071723         0;0;0;0;0;0
071731         1210+XIBNX;1272+YIBNY;0;0
071735  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
071735  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
071735
071735
071735  0IICN

071735  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
071735  "IND05+IBL05
071735  IDVI ID05,IDBUS,TERMC

071735
071735  ID05I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
071747         ID05O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
071757         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
071765  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
071765  "
071765
071765
071765  IDVO ID05

071765
071765  ID05O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID05I;0
072001         0;0;0;0;0;0
072007         1210+XIBNX;1272+YIBNY;0;0
072013  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072013  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072013
072013
072013  0IICN

072013  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072013  "IND06
072013  IDVI ID06,IDBUS,TERMC

072013
072013  ID06I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072025         ID06O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072035         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072043  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072043  "
072043
072043  IDVO ID06

072043
072043  ID06O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID06I;0
072057         0;0;0;0;0;0
072065         1210+XIBNX;1272+YIBNY;0;0
072071  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072071  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072071
072071  0IICN

072071  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072071  "IND07
072071  IDVI ID07,IDBUS,TERMC

072071
072071  ID07I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072103         ID07O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072113         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072121  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072121  "
072121
072121  IDVO ID07

072121
072121  ID07O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID07I;0
072135         0;0;0;0;0;0
072143         1210+XIBNX;1272+YIBNY;0;0
072147  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072147  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072147
072147  0IICN

072147  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072147  "IND08
072147  IDVI ID08,IDBUS,TERMC

072147
072147  ID08I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072161         ID08O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072171         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072177  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072177  "
072177
072177  IDVO ID08

072177
072177  ID08O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID08I;0
072213         0;0;0;0;0;0
072221         1210+XIBNX;1272+YIBNY;0;0
072225  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072225  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072225
072225  0IICN

072225  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072225  "IND09
072225  IDVI ID09,IDBUS,TERMC

072225
072225  ID09I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072237         ID09O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072247         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072255  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072255  "
072255
072255  IDVO ID09

072255
072255  ID09O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID09I;0
072271         0;0;0;0;0;0
072277         1210+XIBNX;1272+YIBNY;0;0
072303  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072303  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072303
072303  0IICN

072303  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072303  "IND10
072303  IDVI ID10,IDBUS,TERMC

072303
072303  ID10I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072315         ID10O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072325         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072333  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072333  "
072333
072333  IDVO ID10

072333
072333  ID10O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID10I;0
072347         0;0;0;0;0;0
072355         1210+XIBNX;1272+YIBNY;0;0
072361  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072361  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072361
072361  0IICN

072361  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072361  "IND11
072361  IDVI ID11,IDBUS,TERMC

072361
072361  ID11I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072373         ID11O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072403         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072411  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072411  "
072411
072411  IDVO ID11

072411
072411  ID11O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID11I;0
072425         0;0;0;0;0;0
072433         1210+XIBNX;1272+YIBNY;0;0
072437  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072437  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072437
072437  0IICN

072437  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072437  "IND12
072437  IDVI ID12,IDBUS,TERMC

072437
072437  ID12I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072451         ID12O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072461         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072467  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072467  "
072467
072467  IDVO ID12

072467
072467  ID12O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID12I;0
072503         0;0;0;0;0;0
072511         1210+XIBNX;1272+YIBNY;0;0
072515  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072515  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072515
072515  0IICN

072515  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072515  "IND13
072515  IDVI ID13,IDBUS,TERMC

072515
072515  ID13I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072527         ID13O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072537         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072545  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072545  "
072545
072545  IDVO ID13

072545
072545  ID13O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID13I;0
072561         0;0;0;0;0;0
072567         1210+XIBNX;1272+YIBNY;0;0
072573  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072573  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072573
072573  0IICN

072573  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072573  "IND14
072573  IDVI ID14,IDBUS,TERMC

072573
072573  ID14I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072605         ID14O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072615         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072623  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072623  "
072623
072623  IDVO ID14

072623
072623  ID14O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID14I;0
072637         0;0;0;0;0;0
072645         1210+XIBNX;1272+YIBNY;0;0
072651  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072651  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072651
072651  0IICN

072651  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072651  "IND15
072651  IDVI ID15,IDBUS,TERMC

072651
072651  ID15I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072663         ID15O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072673         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072701  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072701  "
072701
072701  IDVO ID15

072701
072701  ID15O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID15I;0
072715         0;0;0;0;0;0
072723         1210+XIBNX;1272+YIBNY;0;0
072727  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
072727  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
072727
072727  0IICN

072727  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
072727  "IND16
072727  IDVI ID16,IDBUS,TERMC

072727
072727  ID16I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
072741         ID16O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
072751         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
072757  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
072757  "
072757
072757  IDVO ID16

072757
072757  ID16O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID16I;0
072773         0;0;0;0;0;0
073001         1210+XIBNX;1272+YIBNY;0;0
073005  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073005  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073005
073005  0IICN

073005  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073005  "IND17
073005  IDVI ID17,IDBUS,TERMC

073005
073005  ID17I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073017         ID17O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073027         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073035  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073035  "
073035
073035  IDVO ID17

073035
073035  ID17O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID17I;0
073051         0;0;0;0;0;0
073057         1210+XIBNX;1272+YIBNY;0;0
073063  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073063  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073063
073063  0IICN

073063  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073063  "IND18
073063  IDVI ID18,IDBUS,TERMC

073063
073063  ID18I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073075         ID18O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073105         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073113  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073113  "
073113
073113  IDVO ID18

073113
073113  ID18O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID18I;0
073127         0;0;0;0;0;0
073135         1210+XIBNX;1272+YIBNY;0;0
073141  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073141  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073141
073141  0IICN

073141  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073141  "IND19
073141  IDVI ID19,IDBUS,TERMC

073141
073141  ID19I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073153         ID19O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073163         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073171  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073171  "
073171
073171  IDVO ID19

073171
073171  ID19O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID19I;0
073205         0;0;0;0;0;0
073213         1210+XIBNX;1272+YIBNY;0;0
073217  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073217  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073217
073217  0IICN

073217  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073217  "IND20
073217  IDVI ID20,IDBUS,TERMC

073217
073217  ID20I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073231         ID20O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073241         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073247  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073247  "
073247
073247  IDVO ID20

073247
073247  ID20O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID20I;0
073263         0;0;0;0;0;0
073271         1210+XIBNX;1272+YIBNY;0;0
073275  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073275  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073275
073275  0IICN

073275  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073275  "IND21
073275  IDVI ID21,IDBUS,TERMC

073275
073275  ID21I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073307         ID21O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073317         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073325  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073325  "
073325
073325  IDVO ID21

073325
073325  ID21O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID21I;0
073341         0;0;0;0;0;0
073347         1210+XIBNX;1272+YIBNY;0;0
073353  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073353  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073353
073353  0IICN

073353  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073353  "IND22
073353  IDVI ID22,IDBUS,TERMC

073353
073353  ID22I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073365         ID22O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073375         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073403  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073403  "
073403
073403  IDVO ID22

073403
073403  ID22O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID22I;0
073417         0;0;0;0;0;0
073425         1210+XIBNX;1272+YIBNY;0;0
073431  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073431  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073431
073431  0IICN

073431  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073431  "IND23
073431  IDVI ID23,IDBUS,TERMC

073431
073431  ID23I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073443         ID23O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073453         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073461  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073461  "
073461
073461  IDVO ID23

073461
073461  ID23O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID23I;0
073475         0;0;0;0;0;0
073503         1210+XIBNX;1272+YIBNY;0;0
073507  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073507  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073507
073507  0IICN

073507  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073507  "IND24
073507  IDVI ID24,IDBUS,TERMC

073507
073507  ID24I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073521         ID24O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073531         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073537  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073537  "
073537
073537  IDVO ID24

073537
073537  ID24O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID24I;0
073553         0;0;0;0;0;0
073561         1210+XIBNX;1272+YIBNY;0;0
073565  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073565  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073565
073565  0IICN

073565  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073565  "IND25
073565  IDVI ID25,IDBUS,TERMC

073565
073565  ID25I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073577         ID25O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073607         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073615  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073615  "
073615
073615  IDVO ID25

073615
073615  ID25O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID25I;0
073631         0;0;0;0;0;0
073637         1210+XIBNX;1272+YIBNY;0;0
073643  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073643  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073643
073643  0IICN

073643  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073643  "IND26
073643  IDVI ID26,IDBUS,TERMC

073643
073643  ID26I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073655         ID26O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073665         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073673  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073673  "
073673
073673  IDVO ID26

073673
073673  ID26O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID26I;0
073707         0;0;0;0;0;0
073715         1210+XIBNX;1272+YIBNY;0;0
073721  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073721  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073721
073721  0IICN

073721  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073721  "IND27
073721  IDVI ID27,IDBUS,TERMC

073721
073721  ID27I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
073733         ID27O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
073743         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
073751  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
073751  "
073751
073751  IDVO ID27

073751
073751  ID27O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID27I;0
073765         0;0;0;0;0;0
073773         1210+XIBNX;1272+YIBNY;0;0
073777  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
073777  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
073777
073777  0IICN

073777  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
073777  "IND28
073777  IDVI ID28,IDBUS,TERMC

073777
073777  ID28I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074011         ID28O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
074021         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
074027  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
074027  "
074027
074027  IDVO ID28

074027
074027  ID28O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID28I;0
074043         0;0;0;0;0;0
074051         1210+XIBNX;1272+YIBNY;0;0
074055  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074055  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074055
074055  0IICN

074055  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
074055  "IND29
074055  IDVI ID29,IDBUS,TERMC

074055
074055  ID29I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074067         ID29O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
074077         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
074105  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
074105  "
074105
074105  IDVO ID29

074105
074105  ID29O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID29I;0
074121         0;0;0;0;0;0
074127         1210+XIBNX;1272+YIBNY;0;0
074133  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074133  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074133
074133  0IICN

074133  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
074133  "IND30
074133  IDVI ID30,IDBUS,TERMC

074133
074133  ID30I,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074145         ID30O;0;BUF;IDBUS+IDBUS;0;0;IDBUS+IDBUS;0
074155         1210+XIBNX;1211+XIBNX;1;0;TERMC;0
074163  %%XBU=BUF+IDBUS;)KILL BUF;BUF=XBU;)KILL XBU
074163  "
074163
074163  IDVO ID30

074163
074163  ID30O,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ID30I;0
074177         0;0;0;0;0;0
074205         1210+XIBNX;1272+YIBNY;0;0
074211  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074211  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074211
074211  0IICN

074211  0ZZZZ=0IIII+1;)KILL 0IIII;0IIII=0ZZZZ;)KILL 0ZZZZ
074211
074211  0INDV=0IIII
074211  0INBL=0BBBB
074211  )KILL 0IIII 0BBBB
074211
074211  "RQIBM
074211  IDVI IIBM,200,47

074211
074211  IIBMI,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074223         IIBMO;0;BUF;200+200;0;0;200+200;0
074233         1210+XIBNX;1211+XIBNX;1;0;47;0
074241  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
074241  "
074241
074241  IDVO IIBM

074241
074241  IIBMO,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;IIBMI;0
074255         0;0;0;0;0;0
074263         1210+XIBNX;1272+YIBNY;0;0
074267  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074267  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074267
074267  "RQCDC
074267  IDVI ICDC,200,47

074267
074267  ICDCI,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074301         ICDCO;0;BUF;200+200;0;0;200+200;0
074311         1210+XIBNX;1211+XIBNX;1;0;47;0
074317  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
074317  "
074317
074317  IDVO ICDC

074317
074317  ICDCO,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;ICDCI;0
074333         0;0;0;0;0;0
074341         1210+XIBNX;1272+YIBNY;0;0
074345  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074345  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074345
074345  "RQUNI
074345  IDVI IUNI,200,47

074345
074345  IUNII,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074357         IUNIO;0;BUF;200+200;0;0;200+200;0
074367         1210+XIBNX;1211+XIBNX;1;0;47;0
074375  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
074375  "
074375
074375  IDVO IUNI

074375
074375  IUNIO,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;IUNII;0
074411         0;0;0;0;0;0
074417         1210+XIBNX;1272+YIBNY;0;0
074423  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074423  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074423
074423  "RQHON
074423  IDVI IHON,200,47

074423
074423  IHONI,0;0;*-2;110000;0;0;IORES;IGTCH;ISTDV;CLBUF
074435         IHONO;0;BUF;200+200;0;0;200+200;0
074445         1210+XIBNX;1211+XIBNX;1;0;47;0
074453  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
074453  "
074453
074453  IDVO IHON

074453
074453  IHONO,0;0;*-2;110000;0;0;IORES;IPTCH;OSTDV;INIOS;IHONI;0
074467         0;0;0;0;0;0
074475         1210+XIBNX;1272+YIBNY;0;0
074501  YIBNX=XIBNX+2;)KILL XIBNX; XIBNX=YIBNX;)KILL YIBNX
074501  YIBNZ=YIBNY+1;)KILL YIBNY; YIBNY=YIBNZ;)KILL YIBNZ
074501
074501
074501  "8HIST
074501  F1203, 0;0;*-2;2             % HISTOGRAM SEMAPHORE
074505  "
074505
074505
074505  %============================================================================
074505  % 28.45      DATAFIELD FOR USERS RESTART PROGRAM
074505
074505  URERT, 0;0;*-2;0;0;0;MURES
074514
074514  "-8S3C
074514
074514  %============================================================================
074514  % 28.46      ABSTRANS PARAMETERS FOR START-PROGRAM
074514
074514  SBANK, 0                     % SBUF MUST BE A DOUBLE WORD
074515  SBUF,  0
074516  DFBLC=*
074516  FBLCK, 0;0
074520  DTBLC=*
074520  TBLCK, 0;0
074522  XFUNC, 0
074523  NBLCK, 0
074524  TNBLC, 0
074525  RPAR,  XFUNC
074526         SBUF-1
074527         FBLCK
074530         NBLCK
074531  WPAR,  XFUNC
074532         SBUF-1
074533         TBLCK
074534         TNBLC
074535
074535  )FILL
074535  "
074535
074535  %==============================================================================
074535  % 28.47      B A T C H  D A T A F I E L D S
074535  %
074535  BATNO=1
074535  9SBDF=*                   % START OF DF FOR BATCH
074535  "8BCH1
074535  BCHD BT01,BCH01,300

074535
074535         33;0;0;0;0;0;0;0;0;0;0;0;0;0
074553  BT01R, 0;0;*-2;110002;0;0;IORES
074562         0;TEXIT;CEXIT;BT01W;0
074567         0;0;0;0;BATNO;0
074575         0;0;BCH01;0;0;0
074603         0;0;0;0;0;0;0;0
074613         0;0;0
074616
074616  BT01W, 0;0;*-2;110002;0;0;IORES
074625         0;0;CEXIT;BT01R;0
074632         0;0;0;0;BATNO;0
074640         0;0;0
074643
074643  BT01O, 0;0;*-2;110002;0;0;IORES
074652         IPTCH;OSTDV;CLBUF;BT01I;0
074657
074657  BT01I, 0;0;*-2;110002;0;0;IORES
074666         IGTCH;ISTDV;CLBUF;BT01O;0
074673         BUF;300+300;0;0;300+300;0;0;0;20;0;47;0
074707  %%XBU=BUF+300;)KILL BUF;BUF=XBU;)KILL XBU
074707  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
074707
074707  "8BCH2
074707  BCHD BT02,BCH02,300

074707
074707         33;0;0;0;0;0;0;0;0;0;0;0;0;0
074725  BT02R, 0;0;*-2;110002;0;0;IORES
074734         0;TEXIT;CEXIT;BT02W;0
074741         0;0;0;0;BATNO;0
074747         0;0;BCH02;0;0;0
074755         0;0;0;0;0;0;0;0
074765         0;0;0
074770
074770  BT02W, 0;0;*-2;110002;0;0;IORES
074777         0;0;CEXIT;BT02R;0
075004         0;0;0;0;BATNO;0
075012         0;0;0
075015
075015  BT02O, 0;0;*-2;110002;0;0;IORES
075024         IPTCH;OSTDV;CLBUF;BT02I;0
075031
075031  BT02I, 0;0;*-2;110002;0;0;IORES
075040         IGTCH;ISTDV;CLBUF;BT02O;0
075045         BUF;300+300;0;0;300+300;0;0;0;20;0;47;0
075061  %%XBU=BUF+300;)KILL BUF;BUF=XBU;)KILL XBU
075061  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
075061
075061  "8BCH3
075061  BCHD BT03,BCH03,300

075061
075061         33;0;0;0;0;0;0;0;0;0;0;0;0;0
075077  BT03R, 0;0;*-2;110002;0;0;IORES
075106         0;TEXIT;CEXIT;BT03W;0
075113         0;0;0;0;BATNO;0
075121         0;0;BCH03;0;0;0
075127         0;0;0;0;0;0;0;0
075137         0;0;0
075142
075142  BT03W, 0;0;*-2;110002;0;0;IORES
075151         0;0;CEXIT;BT03R;0
075156         0;0;0;0;BATNO;0
075164         0;0;0
075167
075167  BT03O, 0;0;*-2;110002;0;0;IORES
075176         IPTCH;OSTDV;CLBUF;BT03I;0
075203
075203  BT03I, 0;0;*-2;110002;0;0;IORES
075212         IGTCH;ISTDV;CLBUF;BT03O;0
075217         BUF;300+300;0;0;300+300;0;0;0;20;0;47;0
075233  %%XBU=BUF+300;)KILL BUF;BUF=XBU;)KILL XBU
075233  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
075233
075233  "8BCH4
075233  BCHD BT04,BCH04,300

075233
075233         33;0;0;0;0;0;0;0;0;0;0;0;0;0
075251  BT04R, 0;0;*-2;110002;0;0;IORES
075260         0;TEXIT;CEXIT;BT04W;0
075265         0;0;0;0;BATNO;0
075273         0;0;BCH04;0;0;0
075301         0;0;0;0;0;0;0;0
075311         0;0;0
075314
075314  BT04W, 0;0;*-2;110002;0;0;IORES
075323         0;0;CEXIT;BT04R;0
075330         0;0;0;0;BATNO;0
075336         0;0;0
075341
075341  BT04O, 0;0;*-2;110002;0;0;IORES
075350         IPTCH;OSTDV;CLBUF;BT04I;0
075355
075355  BT04I, 0;0;*-2;110002;0;0;IORES
075364         IGTCH;ISTDV;CLBUF;BT04O;0
075371         BUF;300+300;0;0;300+300;0;0;0;20;0;47;0
075405  %%XBU=BUF+300;)KILL BUF;BUF=XBU;)KILL XBU
075405  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
075405
075405  "8BCH5
075405  BCHD BT05,BCH05,300

075405
075405         33;0;0;0;0;0;0;0;0;0;0;0;0;0
075423  BT05R, 0;0;*-2;110002;0;0;IORES
075432         0;TEXIT;CEXIT;BT05W;0
075437         0;0;0;0;BATNO;0
075445         0;0;BCH05;0;0;0
075453         0;0;0;0;0;0;0;0
075463         0;0;0
075466
075466  BT05W, 0;0;*-2;110002;0;0;IORES
075475         0;0;CEXIT;BT05R;0
075502         0;0;0;0;BATNO;0
075510         0;0;0
075513
075513  BT05O, 0;0;*-2;110002;0;0;IORES
075522         IPTCH;OSTDV;CLBUF;BT05I;0
075527
075527  BT05I, 0;0;*-2;110002;0;0;IORES
075536         IGTCH;ISTDV;CLBUF;BT05O;0
075543         BUF;300+300;0;0;300+300;0;0;0;20;0;47;0
075557  %%XBU=BUF+300;)KILL BUF;BUF=XBU;)KILL XBU
075557  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
075557
075557  "8BCH6
075557  BCHD BT06,BCH06,200

075557
075557         33;0;0;0;0;0;0;0;0;0;0;0;0;0
075575  BT06R, 0;0;*-2;110002;0;0;IORES
075604         0;TEXIT;CEXIT;BT06W;0
075611         0;0;0;0;BATNO;0
075617         0;0;BCH06;0;0;0
075625         0;0;0;0;0;0;0;0
075635         0;0;0
075640
075640  BT06W, 0;0;*-2;110002;0;0;IORES
075647         0;0;CEXIT;BT06R;0
075654         0;0;0;0;BATNO;0
075662         0;0;0
075665
075665  BT06O, 0;0;*-2;110002;0;0;IORES
075674         IPTCH;OSTDV;CLBUF;BT06I;0
075701
075701  BT06I, 0;0;*-2;110002;0;0;IORES
075710         IGTCH;ISTDV;CLBUF;BT06O;0
075715         BUF;200+200;0;0;200+200;0;0;0;20;0;47;0
075731  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
075731  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
075731
075731  "8BCH7
075731  BCHD BT07,BCH07,200

075731
075731         33;0;0;0;0;0;0;0;0;0;0;0;0;0
075747  BT07R, 0;0;*-2;110002;0;0;IORES
075756         0;TEXIT;CEXIT;BT07W;0
075763         0;0;0;0;BATNO;0
075771         0;0;BCH07;0;0;0
075777         0;0;0;0;0;0;0;0
076007         0;0;0
076012
076012  BT07W, 0;0;*-2;110002;0;0;IORES
076021         0;0;CEXIT;BT07R;0
076026         0;0;0;0;BATNO;0
076034         0;0;0
076037
076037  BT07O, 0;0;*-2;110002;0;0;IORES
076046         IPTCH;OSTDV;CLBUF;BT07I;0
076053
076053  BT07I, 0;0;*-2;110002;0;0;IORES
076062         IGTCH;ISTDV;CLBUF;BT07O;0
076067         BUF;200+200;0;0;200+200;0;0;0;20;0;47;0
076103  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
076103  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
076103
076103  "8BCH8
076103  BCHD BT08,BCH08,200

076103
076103         33;0;0;0;0;0;0;0;0;0;0;0;0;0
076121  BT08R, 0;0;*-2;110002;0;0;IORES
076130         0;TEXIT;CEXIT;BT08W;0
076135         0;0;0;0;BATNO;0
076143         0;0;BCH08;0;0;0
076151         0;0;0;0;0;0;0;0
076161         0;0;0
076164
076164  BT08W, 0;0;*-2;110002;0;0;IORES
076173         0;0;CEXIT;BT08R;0
076200         0;0;0;0;BATNO;0
076206         0;0;0
076211
076211  BT08O, 0;0;*-2;110002;0;0;IORES
076220         IPTCH;OSTDV;CLBUF;BT08I;0
076225
076225  BT08I, 0;0;*-2;110002;0;0;IORES
076234         IGTCH;ISTDV;CLBUF;BT08O;0
076241         BUF;200+200;0;0;200+200;0;0;0;20;0;47;0
076255  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
076255  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
076255
076255  "8BCH9
076255  BCHD BT09,BCH09,200

076255
076255         33;0;0;0;0;0;0;0;0;0;0;0;0;0
076273  BT09R, 0;0;*-2;110002;0;0;IORES
076302         0;TEXIT;CEXIT;BT09W;0
076307         0;0;0;0;BATNO;0
076315         0;0;BCH09;0;0;0
076323         0;0;0;0;0;0;0;0
076333         0;0;0
076336
076336  BT09W, 0;0;*-2;110002;0;0;IORES
076345         0;0;CEXIT;BT09R;0
076352         0;0;0;0;BATNO;0
076360         0;0;0
076363
076363  BT09O, 0;0;*-2;110002;0;0;IORES
076372         IPTCH;OSTDV;CLBUF;BT09I;0
076377
076377  BT09I, 0;0;*-2;110002;0;0;IORES
076406         IGTCH;ISTDV;CLBUF;BT09O;0
076413         BUF;200+200;0;0;200+200;0;0;0;20;0;47;0
076427  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
076427  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
076427
076427  "8BC10
076427  BCHD BT10,BCH10,200

076427
076427         33;0;0;0;0;0;0;0;0;0;0;0;0;0
076445  BT10R, 0;0;*-2;110002;0;0;IORES
076454         0;TEXIT;CEXIT;BT10W;0
076461         0;0;0;0;BATNO;0
076467         0;0;BCH10;0;0;0
076475         0;0;0;0;0;0;0;0
076505         0;0;0
076510
076510  BT10W, 0;0;*-2;110002;0;0;IORES
076517         0;0;CEXIT;BT10R;0
076524         0;0;0;0;BATNO;0
076532         0;0;0
076535
076535  BT10O, 0;0;*-2;110002;0;0;IORES
076544         IPTCH;OSTDV;CLBUF;BT10I;0
076551
076551  BT10I, 0;0;*-2;110002;0;0;IORES
076560         IGTCH;ISTDV;CLBUF;BT10O;0
076565         BUF;200+200;0;0;200+200;0;0;0;20;0;47;0
076601  %%XBU=BUF+200;)KILL BUF;BUF=XBU;)KILL XBU
076601  BNO=BATNO+1;)KILL BATNO;BATNO=BNO;)KILL BNO
076601
076601  "
076601  % EXTRA QUE INT DEV
076601  "8ABAT 8BCH1; BACQD BQ01

076601  BQ01O, 0;0;*-2;110002;0;0;IORES
076610         IPTCH;OSTDV;CLBUF;BQ01I;0
076615
076615  BQ01I, 0;0;*-2;110002;0;0;IORES
076624         IGTCH;ISTDV;CLBUF;BQ01O;0
076631         BUF;0 ;0;0;0;0;0;0;20;0;47;0
076645
076645  "8ABAT 8BCH2; BACQD BQ02

076645  BQ02O, 0;0;*-2;110002;0;0;IORES
076654         IPTCH;OSTDV;CLBUF;BQ02I;0
076661
076661  BQ02I, 0;0;*-2;110002;0;0;IORES
076670         IGTCH;ISTDV;CLBUF;BQ02O;0
076675         BUF;0 ;0;0;0;0;0;0;20;0;47;0
076711
076711  "8ABAT 8BCH3; BACQD BQ03

076711  BQ03O, 0;0;*-2;110002;0;0;IORES
076720         IPTCH;OSTDV;CLBUF;BQ03I;0
076725
076725  BQ03I, 0;0;*-2;110002;0;0;IORES
076734         IGTCH;ISTDV;CLBUF;BQ03O;0
076741         BUF;0 ;0;0;0;0;0;0;20;0;47;0
076755
076755  "8ABAT 8BCH4; BACQD BQ04

076755  BQ04O, 0;0;*-2;110002;0;0;IORES
076764         IPTCH;OSTDV;CLBUF;BQ04I;0
076771
076771  BQ04I, 0;0;*-2;110002;0;0;IORES
077000         IGTCH;ISTDV;CLBUF;BQ04O;0
077005         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077021
077021  "8ABAT 8BCH5; BACQD BQ05

077021  BQ05O, 0;0;*-2;110002;0;0;IORES
077030         IPTCH;OSTDV;CLBUF;BQ05I;0
077035
077035  BQ05I, 0;0;*-2;110002;0;0;IORES
077044         IGTCH;ISTDV;CLBUF;BQ05O;0
077051         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077065
077065  "8ABAT 8BCH6; BACQD BQ06

077065  BQ06O, 0;0;*-2;110002;0;0;IORES
077074         IPTCH;OSTDV;CLBUF;BQ06I;0
077101
077101  BQ06I, 0;0;*-2;110002;0;0;IORES
077110         IGTCH;ISTDV;CLBUF;BQ06O;0
077115         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077131
077131  "8ABAT 8BCH7; BACQD BQ07

077131  BQ07O, 0;0;*-2;110002;0;0;IORES
077140         IPTCH;OSTDV;CLBUF;BQ07I;0
077145
077145  BQ07I, 0;0;*-2;110002;0;0;IORES
077154         IGTCH;ISTDV;CLBUF;BQ07O;0
077161         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077175
077175  "8ABAT 8BCH8; BACQD BQ08

077175  BQ08O, 0;0;*-2;110002;0;0;IORES
077204         IPTCH;OSTDV;CLBUF;BQ08I;0
077211
077211  BQ08I, 0;0;*-2;110002;0;0;IORES
077220         IGTCH;ISTDV;CLBUF;BQ08O;0
077225         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077241
077241  "8ABAT 8BCH9; BACQD BQ09

077241  BQ09O, 0;0;*-2;110002;0;0;IORES
077250         IPTCH;OSTDV;CLBUF;BQ09I;0
077255
077255  BQ09I, 0;0;*-2;110002;0;0;IORES
077264         IGTCH;ISTDV;CLBUF;BQ09O;0
077271         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077305
077305  "8ABAT 8BC10; BACQD BQ10

077305  BQ10O, 0;0;*-2;110002;0;0;IORES
077314         IPTCH;OSTDV;CLBUF;BQ10I;0
077321
077321  BQ10I, 0;0;*-2;110002;0;0;IORES
077330         IGTCH;ISTDV;CLBUF;BQ10O;0
077335         BUF;0 ;0;0;0;0;0;0;20;0;47;0
077351
077351  "
077351  9EBDF=*                   % END OF BATCH DF
077351
077351
077351
077351
077351
077351
077351
077351  "8CXHD
077351

077351  %=======================================================================
077351  % 28.52     G E N E R A L   H D L C  -  D M A  -  D A T A F I E L D S
077351  %
077351  ENSIZ=1520
077351  "8C1HD
077351  %
077351  %      HDLC OUTPUT-DATAFIELD 1
077351  %
077351         X21OP;POFTO;0;HDTM2;0;-2;IOX 1640;HDSTA;FALSE
077362  HDOF1,  0;0;*-2;0;0;0;IORES
077371         0;ACT12;0;HDIF1;0
077376         0;0;0;0;0;0
077404         0;0;0;0;0;0;0
077413         0;0;0;0;0;0;0
077422         0;0;0;0;0;0;0;0;0;0;0
077435         0;0;0;0;0;0;0;0;0;
077446         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
077457         0;0;HOLI1;0;0;0;0
077466         0;0;0;*+1;0;0;0;0
077476         0;0;0;0
077502         0
077503
077503  HOLI1,  0;0;0;0
077507         NLP;0;0;HOLI1+DPITP
077513  %
077513  %      HDLC INPUT-DATAFIELD 1
077513  %
077513         X21OP;HIINT;0;HDTM3;0;-2;IOX 1640;HDSTA;HIINT
077524  HDIF1, 0;0;*-2;0;0;0;IORES
077533         0;ACT13;0;HDOF1;0
077540         0;0;0;0;0;0
077546         0;0;0;0;0;0;0
077555         0;0;0;0;0;0;0
077564         0;0;0;0;0;0;0;0;0;0;0
077577         0;0;0;0;0;0;0;0;0
077610         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
077621         0;0;HILI1;0;0;0;0
077630         0;0;0;*+1;0;0;0;0
077640         0;0;0;10
077644         0;0;0;0;0;0;0;0
077654  HILI1,  0;0;0;0
077660         0;0;0;0
077664         0;0;0;0
077670         0;0;0;0
077674         0;0;0;0
077700         0;0;0;0
077704         0;0;0;0
077710         0;0;0;0
077714         NLP;0;0;HILI1+DPITP
077720
077720
077720  "8C2HD
077720  %
077720  %      HDLC OUTPUT-DATAFIELD 2
077720  %
077720         X21OP;POFTO;0;HDTM2;0;-2;IOX 1660;HDSTA;FALSE
077731  HDOF2,  0;0;*-2;0;0;0;IORES
077740         0;ACT12;0;HDIF2;0
077745         0;0;0;0;0;0
077753         0;0;0;0;0;0;0
077762         0;0;0;0;0;0;0
077771         0;0;0;0;0;0;0;0;0;0;0
100004         0;0;0;0;0;0;0;0;0
100015         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
100026         0;0;HOLI2;0;0;0;0
100035         0;0;0;*+1;0;0;0;0
100045         0;0;0;0
100051         0
100052
100052  HOLI2,  0;0;0;0
100056         NLP;0;0;HOLI2+DPITP
100062  %
100062  %      HDLC INPUT-DATAFIELD 2
100062  %
100062         X21OP;HIINT;0;HDTM3;0;-2;IOX 1660;HDSTA;HIINT
100073  HDIF2, 0;0;*-2;0;0;0;IORES
100102         0;ACT13;0;HDOF2;0
100107         0;0;0;0;0;0
100115         0;0;0;0;0;0;0
100124         0;0;0;0;0;0;0
100133         0;0;0;0;0;0;0;0;0;0;0
100146         0;0;0;0;0;0;0;0;0
100157         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
100170         0;0;HILI2;0;0;0;0
100177         0;0;0;*+1;0;0;0;0
100207         0;0;0;10
100213         0;0;0;0;0;0;0;0
100223  HILI2,  0;0;0;0
100227         0;0;0;0
100233         0;0;0;0
100237         0;0;0;0
100243         0;0;0;0
100247         0;0;0;0
100253         0;0;0;0
100257         0;0;0;0
100263         NLP;0;0;HILI2+DPITP
100267
100267
100267  "8C3HD
100267  %
100267  %      HDLC OUTPUT-DATAFIELD 3
100267  %
100267         X21OP;POFTO;0;HDTM2;0;-2;IOX 1700;HDSTA;FALSE
100300  HDOF3,  0;0;*-2;0;0;0;IORES
100307         0;ACT12;0;HDIF3;0
100314         0;0;0;0;0;0
100322         0;0;0;0;0;0;0
100331         0;0;0;0;0;0;0
100340         0;0;0;0;0;0;0;0;0;0;0
100353         0;0;0;0;0;0;0;0;0
100364         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
100375         0;0;HOLI3;0;0;0;0
100404         0;0;0;*+1;0;0;0;0
100414         0;0;0;0
100420         0
100421
100421  HOLI3,  0;0;0;0
100425         NLP;0;0;HOLI3+DPITP
100431  %
100431  %      HDLC INPUT-DATAFIELD 3
100431  %
100431         X21OP;HIINT;0;HDTM3;0;-2;IOX 1700;HDSTA;HIINT
100442  HDIF3, 0;0;*-2;0;0;0;IORES
100451         0;ACT13;0;HDOF3;0
100456         0;0;0;0;0;0
100464         0;0;0;0;0;0;0
100473         0;0;0;0;0;0;0
100502         0;0;0;0;0;0;0;0;0;0;0
100515         0;0;0;0;0;0;0;0;0
100526         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
100537         0;0;HILI3;0;0;0;0
100546         0;0;0;*+1;0;0;0;0
100556         0;0;0;10
100562         0;0;0;0;0;0;0;0
100572  HILI3,  0;0;0;0
100576         0;0;0;0
100602         0;0;0;0
100606         0;0;0;0
100612         0;0;0;0
100616         0;0;0;0
100622         0;0;0;0
100626         0;0;0;0
100632         NLP;0;0;HILI3+DPITP
100636
100636
100636  "8C4HD
100636  %
100636  %      HDLC OUTPUT-DATAFIELD 4
100636  %
100636         X21OP;POFTO;0;HDTM2;0;-2;IOX 1720;HDSTA;FALSE
100647  HDOF4,  0;0;*-2;0;0;0;IORES
100656         0;ACT12;0;HDIF4;0
100663         0;0;0;0;0;0
100671         0;0;0;0;0;0;0
100700         0;0;0;0;0;0;0
100707         0;0;0;0;0;0;0;0;0;0;0
100722         0;0;0;0;0;0;0;0;0
100733         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
100744         0;0;HOLI4;0;0;0;0
100753         0;0;0;*+1;0;0;0;0
100763         0;0;0;0
100767         0
100770
100770  HOLI4,  0;0;0;0
100774         NLP;0;0;HOLI4+DPITP
101000  %
101000  %      HDLC INPUT-DATAFIELD 4
101000  %
101000         X21OP;HIINT;0;HDTM3;0;-2;IOX 1720;HDSTA;HIINT
101011  HDIF4, 0;0;*-2;0;0;0;IORES
101020         0;ACT13;0;HDOF4;0
101025         0;0;0;0;0;0
101033         0;0;0;0;0;0;0
101042         0;0;0;0;0;0;0
101051         0;0;0;0;0;0;0;0;0;0;0
101064         0;0;0;0;0;0;0;0;0
101075         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
101106         0;0;HILI4;0;0;0;0
101115         0;0;0;*+1;0;0;0;0
101125         0;0;0;10
101131         0;0;0;0;0;0;0;0
101141  HILI4,  0;0;0;0
101145         0;0;0;0
101151         0;0;0;0
101155         0;0;0;0
101161         0;0;0;0
101165         0;0;0;0
101171         0;0;0;0
101175         0;0;0;0
101201         NLP;0;0;HILI4+DPITP
101205
101205
101205  "8C5HD
101205  %
101205  %      HDLC OUTPUT-DATAFIELD 5
101205  %
101205         X21OP;POFTO;0;HDTM2;0;-2;IOX 1740;HDSTA;FALSE
101216  HDOF5,  0;0;*-2;0;0;0;IORES
101225         0;ACT12;0;HDIF5;0
101232         0;0;0;0;0;0
101240         0;0;0;0;0;0;0
101247         0;0;0;0;0;0;0
101256         0;0;0;0;0;0;0;0;0;0;0
101271         0;0;0;0;0;0;0;0;0
101302         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
101313         0;0;HOLI5;0;0;0;0
101322         0;0;0;*+1;0;0;0;0
101332         0;0;0;0
101336         0
101337
101337  HOLI5,  0;0;0;0
101343         NLP;0;0;HOLI5+DPITP
101347  %
101347  %      HDLC INPUT-DATAFIELD 5
101347  %
101347         X21OP;HIINT;0;HDTM3;0;-2;IOX 1740;HDSTA;HIINT
101360  HDIF5, 0;0;*-2;0;0;0;IORES
101367         0;ACT13;0;HDOF5;0
101374         0;0;0;0;0;0
101402         0;0;0;0;0;0;0
101411         0;0;0;0;0;0;0
101420         0;0;0;0;0;0;0;0;0;0;0
101433         0;0;0;0;0;0;0;0;0
101444         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
101455         0;0;HILI5;0;0;0;0
101464         0;0;0;*+1;0;0;0;0
101474         0;0;0;10
101500         0;0;0;0;0;0;0;0
101510  HILI5,  0;0;0;0
101514         0;0;0;0
101520         0;0;0;0
101524         0;0;0;0
101530         0;0;0;0
101534         0;0;0;0
101540         0;0;0;0
101544         0;0;0;0
101550         NLP;0;0;HILI5+DPITP
101554
101554
101554  "8C6HD
101554  %
101554  %      HDLC OUTPUT-DATAFIELD 6
101554  %
101554         X21OP;POFTO;0;HDTM2;0;-2;IOX 1760;HDSTA;FALSE
101565  HDOF6,  0;0;*-2;0;0;0;IORES
101574         0;ACT12;0;HDIF6;0
101601         0;0;0;0;0;0
101607         0;0;0;0;0;0;0
101616         0;0;0;0;0;0;0
101625         0;0;0;0;0;0;0;0;0;0;0
101640         0;0;0;0;0;0;0;0;0
101651         HXCOD;0;0;0;0;WT12;TRASE;XSSDA;77         % *81F*
101662         0;0;HOLI6;0;0;0;0
101671         0;0;0;*+1;0;0;0;0
101701         0;0;0;0
101705         0
101706
101706  HOLI6,  0;0;0;0
101712         NLP;0;0;HOLI6+DPITP
101716  %
101716  %      HDLC INPUT-DATAFIELD 6
101716  %
101716         X21OP;HIINT;0;HDTM3;0;-2;IOX 1760;HDSTA;HIINT
101727  HDIF6, 0;0;*-2;0;0;0;IORES
101736         0;ACT13;0;HDOF6;0
101743         0;0;0;0;0;0
101751         0;0;0;0;0;0;0
101760         0;0;0;0;0;0;0
101767         0;0;0;0;0;0;0;0;0;0;0
102002         0;0;0;0;0;0;0;0;0
102013         HXCOD;0;0;0;0;WT13;RECSE;HDREC;0
102024         0;0;HILI6;0;0;0;0
102033         0;0;0;*+1;0;0;0;0
102043         0;0;0;10
102047         0;0;0;0;0;0;0;0
102057  HILI6,  0;0;0;0
102063         0;0;0;0
102067         0;0;0;0
102073         0;0;0;0
102077         0;0;0;0
102103         0;0;0;0
102107         0;0;0;0
102113         0;0;0;0
102117         NLP;0;0;HILI6+DPITP
102123
102123
102123  "8PIOC
102123  %===========================================
102123  % 28.53     P I O C  -  D A T A F I E L D S
102123
102123  %      PIOC SEMAPHORE (PIOC DEMFIELD)
102123
102123  SEMPI, 0;0;*-2;0;0;0;0;0                                   % 0
102133         0;0;0;0;0;0;0;0                                     % 10
102143         0;0;0;0;0;0;0;0                                     % 20
102153         0;0;0;0;0;0;0                                       % 30
102162
102162
102162  "8PC01
102162         PITIM;0;-2;140020;PDRIV;PDRIV
102170  PIO01, 0;0;*-2;0;0;0;PIORE
102177         60;0;0;173
102203         0;0;0;0;0;0;0;0;0;0;0;0;377;0;0
102222         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
102240         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
102260         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
102300  "8PC02
102300         PITIM;0;-2;140024;PDRIV;PDRIV
102306  PIO02, 0;0;*-2;0;0;0;PIORE
102315         60;0;0;173
102321         0;0;0;0;0;0;0;0;0;0;0;0;377;1;0
102340         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
102356         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
102376         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
102416
102416  "8PC03
102416         PITIM;0;-2;140030;PDRIV;PDRIV
102424  PIO03, 0;0;*-2;0;0;0;PIORE
102433         60;0;0;173
102437         0;0;0;0;0;0;0;0;0;0;0;0;377;2;0
102456         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
102474         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
102514         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
102534
102534  "8PC04
102534         PITIM;0;-2;140034;PDRIV;PDRIV
102542  PIO04, 0;0;*-2;0;0;0;PIORE
102551         60;0;0;173
102555         0;0;0;0;0;0;0;0;0;0;0;0;377;3;0
102574         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
102612         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
102632         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
102652
102652  "8ETR1
102652         PITIM;0;-2;140360;PDRIV;PDRIV
102660  ETRN1, 0;0;*-2;0;0;0;PIORE
102667         60;0;0;173
102673         0;0;0;0;0;0;0;0;0;0;0;0;077;00;PQMT1
102712         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
102730         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
102750         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
102770
102770  % PIOC MTAD KICK DATAFIELD
102770  PQMT1,  0;0               % KICKL
102772          ETRN1             % PIODF
102773          0;0               % MBPRW;PIORP
102775          0;MTDMF           % MLINK;MFUNC
102777
102777  "8ETR2
102777         PITIM;0;-2;140364;PDRIV;PDRIV
103005  ETRN2, 0;0;*-2;0;0;0;PIORE
103014         60;0;0;173
103020         0;0;0;0;0;0;0;0;0;0;0;0;077;01;PQMT2
103037         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
103055         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
103075         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
103115
103115  % PIOC MTAD KICK DATAFIELD
103115  PQMT2,  0;0               % KICKL
103117          ETRN2             % PIODF
103120          0;0               % MBPRW;PIORP
103122          0;MTDMF           % MLINK;MFUNC
103124
103124  "8ETR3
103124         PITIM;0;-2;140370;PDRIV;PDRIV
103132  ETRN3, 0;0;*-2;0;0;0;PIORE
103141         60;0;0;173
103145         0;0;0;0;0;0;0;0;0;0;0;0;077;02;PQMT3
103164         0;0;0;0;-1;0;0;0;0;0;0;0;0;0                        % XMSG PART
103202         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XT BLOCKS
103222         0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0                     % XL ADDRESSES
103242
103242  % PIOC MTAD KICK DATAFIELD
103242  PQMT3,  0;0               % KICKL
103244          ETRN3             % PIODF
103245          0;0               % MBPRW;PIORP
103247          0;MTDMF           % MLINK;MFUNC
103251
103251  "
103251
103251  "8C1X2+8C2X2+8C3X2+8C4X2+8C5X2+8C6X2+8C7X2+8C8X2
103251  %========================================
103251  % 28.54      X 2 1    D A T A F I E L D S
103251
103251  "8C1X2
103251         X321T;0;HDTM3;0;0;IOX 1640;X32ST;X321I
103261  X21F1, 0;0;*-2;0;0;0;IORES
103270         0;ACT13;0;0;0
103275         0;0;0;0;0;0
103303  %      FROM DEMFIELD
103303
103303         0;0;0;0;0;0;0
103312         0;0;0;0;0;0;0
103321         0;0;0;0;0;0;0;0;0;0;0
103334         0;0;0;0;0;0;0;0;0
103345  %      ONLY X21 USED
103345         HXCOD;0;0;0;0;0;0;0;0;0;0;0;0
103362  %  X2DPS      CALL PROGRESS SIGNALS, LINE ID, CHARGING INFO
103362         0;*+1;0;*+1;0;0;0;0;0;0
103374  %  X2DMP     MESSAGE POINTER
103374         0;0;0;0;0;0
103402  %  X2D00     HARDWARE REGISTERS
103402         0;0;0;0;0;0;0
103411  %  X2DL3
103411         0;0;0;0;0;0;0
103420  "
103420  %
103420  "8C2X2
103420         X321T;0;HDTM3;0;0;IOX 1660;X32ST;X321I
103430  X21F2, 0;0;*-2;0;0;0;IORES
103437         0;ACT13;0;0;0
103444         0;0;0;0;0;0
103452  %      FROM DEMFIELD
103452
103452         0;0;0;0;0;0;0
103461         0;0;0;0;0;0;0
103470         0;0;0;0;0;0;0;0;0;0;0
103503         0;0;0;0;0;0;0;0;0
103514  %      ONLY X21 USED
103514         HXCOD;0;0;0;0;0;0;0;0;0;0;0;0
103531  %  X2DPS      CALL PROGRESS SIGNALS, LINE ID, CHARGING INFO
103531         0;*+1;0;*+1;0;0;0;0;0;0
103543  %  X2DMP     MESSAGE POINTER
103543         0;0;0;0;0;0
103551  %  X2D00     HARDWARE REGISTERS
103551         0;0;0;0;0;0;0
103560  %  X2DL3
103560         0;0;0;0;0;0;0
103567  %
103567  %
103567  %
103567  "
103567
103567  %
103567
103567  %
103567
103567
103567  %
103567
103567
103567  "8HMO1+8HMO2+8HMO3+8HMO4+8HMO5+8HMO6
103567  %=================================================================
103567  % 28.55      S Y N C    M O D E M   H D L C    D A T A F I E L D S
103567
103567  "8HMO1
103567         0;0;0
103572         0;0;0;X21OP;0;0;HOTMI;0;-16
103603         IOX 1640;HODIN;HODI1
103606  IDHM1, 0;0;*-2;110000;0;0;IOREM
103615         HOTRI;TEXIT;HOSTI;0;0
103622         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
103631         MIBU1+MIBU1
103632
103632         0;0;0
103635         0;0;0;X21OP;0;0;HOTMO;0;-3
103646         IOX 1640;HODUT;HODUT
103651  UDHM1, 0;0;*-2;110000;0;0;IORES
103660         HOTRO;TEXIT;HOSTO;0;0
103665         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
103673
103673  "8HMO2
103673         0;0;0
103676         0;0;0;X21OP;0;0;HOTMI;0;-16
103707         IOX 1660;HODIN;HODI1
103712  IDHM2, 0;0;*-2;110000;0;0;IOREM
103721         HOTRI;TEXIT;HOSTI;0;0
103726         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
103735         MIBU1+MIBU1
103736
103736         0;0;0
103741         0;0;0;X21OP;0;0;HOTMO;0;-3
103752         IOX 1660;HODUT;HODUT
103755  UDHM2, 0;0;*-2;110000;0;0;IORES
103764         HOTRO;TEXIT;HOSTO;0;0
103771         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
103777
103777  "8HMO3
103777         0;0;0
104002         0;0;0;X21OP;0;0;HOTMI;0;-16
104013         IOX 1700;HODIN;HODI1
104016  IDHM3, 0;0;*-2;110000;0;0;IOREM
104025         HOTRI;TEXIT;HOSTI;0;0
104032         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
104041         MIBU1+MIBU1
104042
104042         0;0;0
104045         0;0;0;X21OP;0;0;HOTMO;0;-3
104056         IOX 1700;HODUT;HODUT
104061  UDHM3, 0;0;*-2;110000;0;0;IORES
104070         HOTRO;TEXIT;HOSTO;0;0
104075         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
104103
104103  "8HMO4
104103         0;0;0
104106         0;0;0;X21OP;0;0;HOTMI;0;-16
104117         IOX 1720;HODIN;HODI1
104122  IDHM4, 0;0;*-2;110000;0;0;IOREM
104131         HOTRI;TEXIT;HOSTI;0;0
104136         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
104145         MIBU1+MIBU1
104146
104146         0;0;0
104151         0;0;0;X21OP;0;0;HOTMO;0;-3
104162         IOX 1720;HODUT;HODUT
104165  UDHM4, 0;0;*-2;110000;0;0;IORES
104174         HOTRO;TEXIT;HOSTO;0;0
104201         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
104207
104207  "8HMO5
104207         0;0;0
104212         0;0;0;X21OP;0;0;HOTMI;0;-16
104223         IOX 1740;HODIN;HODI1
104226  IDHM5, 0;0;*-2;110000;0;0;IOREM
104235         HOTRI;TEXIT;HOSTI;0;0
104242         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
104251         MIBU1+MIBU1
104252
104252         0;0;0
104255         0;0;0;X21OP;0;0;HOTMO;0;-3
104266         IOX 1740;HODUT;HODUT
104271  UDHM5, 0;0;*-2;110000;0;0;IORES
104300         HOTRO;TEXIT;HOSTO;0;0
104305         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
104313
104313  "8HMO6
104313         0;0;0
104316         0;0;0;X21OP;0;0;HOTMI;0;-16
104327         IOX 1760;HODIN;HODI1
104332  IDHM6, 0;0;*-2;110000;0;0;IOREM
104341         HOTRI;TEXIT;HOSTI;0;0
104346         BUF;MIBU1+MIBU1;0;0;MIBU1+MIBU1;0;0
104355         MIBU1+MIBU1
104356
104356         0;0;0
104361         0;0;0;X21OP;0;0;HOTMO;0;-3
104372         IOX 1760;HODUT;HODUT
104375  UDHM6, 0;0;*-2;110000;0;0;IORES
104404         HOTRO;TEXIT;HOSTO;0;0
104411         BUF;MOBU1+MOBU1;0;0;MOBU1+MOBU1;0
104417  "
104417
104417  "8UDMA+8VICO
104417

104417  %==============================================================================
104417  %            DATAFIELDS FOR UNIVERSAL DMA INTERFACES (INCLUDING VICOM)
104417  %
104417  "8UD01; GUDMA 01,140050

104417
104417   %---------------------------------------- UDMA (INPUT) DATAFIELD 01;
104417          0;0;0;0;0
104424          0;0;0;0;0;0;0;0
104434          0;0;0;0;0;0;0;0
104444          0;0;0;0;0;0;ND852;UBUSY
104454          UFIN;UBUSY;UDTMO; 0;177771;140050;USDRV;UDDRV
104464  UDI01,  0;0;*-2;2000;0;0;RETRA;0
104474          0;MTRNS;UDO01;0;0;0
104502          0;0;0;0;0;0;0
104511   %--------------------------------------- OUPUT DATAFIELD FOR UDMA01;
104511  UDO01,  0;0;*-2;0;0;0;IORES;*+4
104521          *+4;*+5;*+5;0;0;0;0;0               % ABSTR PARAMETER LIST
104531          0;UDF01;*+1;0;0;0;0;0               % 22/*+1 DFPNT  MONITOR CALL
104541          0;0;0;0;0;0;0;0                     %               WORKING AREA
104551          0;0;0;0;0;0;0;0                     %
104561          0;0;0;0;0;0;0;0;0                   % MAX DISP: 36
104572  "8VICO+8UDMA 8F5UD
104572  %---------------------------------------- DATAFIELD FOR UDR01;
104572  UDF01,  0;0;*-2;0;0;0;RIOWA;0               % FAST UDMA FORM ND-500
104602          *+4;*+4;*+5;*+5;0;0;0;0             % ABSTR PARAMETER LIST
104612          0;0
104614  "8UDMA+8VICO
104614  )FILL
104614
104614  "8UD02; GUDMA 02,140060

104614
104614   %---------------------------------------- UDMA (INPUT) DATAFIELD 02;
104614          0;0;0;0;0
104621          0;0;0;0;0;0;0;0
104631          0;0;0;0;0;0;0;0
104641          0;0;0;0;0;0;ND852;UBUSY
104651          UFIN;UBUSY;UDTMO; 0;177771;140060;USDRV;UDDRV
104661  UDI02,  0;0;*-2;2000;0;0;RETRA;0
104671          0;MTRNS;UDO02;0;0;0
104677          0;0;0;0;0;0;0
104706   %--------------------------------------- OUPUT DATAFIELD FOR UDMA02;
104706  UDO02,  0;0;*-2;0;0;0;IORES;*+4
104716          *+4;*+5;*+5;0;0;0;0;0               % ABSTR PARAMETER LIST
104726          0;UDF02;*+1;0;0;0;0;0               % 22/*+1 DFPNT  MONITOR CALL
104736          0;0;0;0;0;0;0;0                     %               WORKING AREA
104746          0;0;0;0;0;0;0;0                     %
104756          0;0;0;0;0;0;0;0;0                   % MAX DISP: 36
104767  "8VICO+8UDMA 8F5UD
104767  %---------------------------------------- DATAFIELD FOR UDR02;
104767  UDF02,  0;0;*-2;0;0;0;RIOWA;0               % FAST UDMA FORM ND-500
104777          *+4;*+4;*+5;*+5;0;0;0;0             % ABSTR PARAMETER LIST
105007          0;0
105011  "8UDMA+8VICO
105011  )FILL
105011
105011  "
105011  "8GPI0+8GPI1+8GPI2+8GPI3+8GPI4+8GPI5+8GPI6+8GPI7
105011

105011  %==============================================================================
105011  %            DATAFIELDS FOR GPIB INTERFACES
105011  %
105011  "8GPI0; GGPIB 0,140000

105011  %------------------------------------------  GPIB (INPUT)DATAFIELD 0;
105011         GPIBT;4000;400;0;0;                % GPXTR DSIZE USIZE GPRUN GPBSI
105016         GPIBD;GPBUS;GPFIN;GPERR;           % STANDARD PART
105022         MTMRS;0;-7;140000;GPITR;GPITR
105030  DTGP0, 0;0;*-2;0;0;0;RETRA;0;0;MTRNS
105042         #00;0;                          % GPIBN ACTIV
105044         0;0;0;0;0;0;0;0;0                  % ABFUN MEMA1 MEMA2 ABP21 ABP22 ABP31 ABP32 ABA31 ABA32
105055         0;0;0;0;0;0                        % XTBLK SXTBL CPORT SPORT DPORT DMESA
105063         0;0;0;0;0;0;0;0                    % DBUFA       MVERS SUSFL DEVFL USCON CGPIM CURMTY
105073         0;0;0;0;0;0;0;0                    % CURMN       ERADD XERCO SRQFL MRETA SRETA GRETA
105103         0;0;0;0;0;0;0;0                    % STREG SAREG SDREG SXREG DINPT PIODP PIOWC FIRST
105113         0;*+20/;*+40/                      % SRSTR UMESS(20)   MNARR(2*20)
105174         0;0;*+10/;0;0;0;*+40/              % CURFU CGPUS INSTA(10)   CURAD       CURBC UENV(2*20)
105251
105251  "8GPI0+8GPI1+8GPI2+8GPI3+8GPI4+8GPI5+8GPI6+8GPI7 CXCPU
105251  %==============================================================================
105251  %            VARIABLES USED BY THE GPIB DRIVER
105251  GPMSL, 0                       % ONE WORD DMA BUFFER
105252  GPXRM, 3                       % FIRST TWO BYTES IN XROUT MESSAGE
105253  GPXRL, 10                      % NEXT TWO BYTES IN XROUT MESSAGE
105254  GPP01, 177406                  % PARAMETER LENGTH IN XROUT MESSAGE
105255  GPPNA, 'GPIBXX'                % PORT NAME
105261  GPSCR, 0                       % SCRATCH LOCATION FOR FUNCTION 14 INITIATED BY TRANSFER ROUTINE
105262  "
105262
105262
105262
105262
105262
105262
105262
105262
105262
105262  )LINE
%%%%%%%%%%%%   M A C R O E S  -  S I N 3  -  G E N  %%%%%%%%%%%%%%%%%%%%%
105262
105262  %%     MACROS USED ON CX-SIN3-GEN
105262  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
105262  %%     PREVIOUSLY USED MACROES ARE KILLED
105262  )KILL IDVI IDVO BLIDV SIB TXTRO BCHD NSGB NTBA DR11C DIGOUT
105262  )KILL ARISTO CMAC GUDMA GGPIB
105262
105262  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
105262
105262  )MCDEF JONAC $CJOC
CKJU=*; DVTAB/ $CJOC  %
CKJU/
)KILL CKJU
]
105262
105262
105262
105262
105262  )LINE

105262  %%%%%%%%%%%%%%%%%%%%%%% C X - S I N 3 - G E N %%%%%%%%%%%%%%%%%%%%%%%%%%
105262
105262  %==============================================================================
105262  % 28.10      L I N E  P R I N T E R  D A T A F I E L D S
105262  %
105262  "8DVE1; 1DVE1=1
105262  "8DLP1+8DVE1
105262
105262  % DATAFIELDS FOR LINE-PRINTER 1 USING MONITOR CALL MAGTP
105262
105262         0;1DVE1;0;COCHB;0;0;0;0;0;0;0;0;0;0
105300         400;0;LP1BU;0
105304         DMLP1;4;IOX 433;IOX 432;IOX 431;0;TRDLP
105313         0;0;0
105316         DLPTM;0;-3;IOX 430;TLPRI;CLP10
105324  DMLP1, 0;0;*-2;2006;0;0;RETRA
105333         0;0;MTRNS;0;DILP1
105340         0;0;0;0;0;0;0
105347         0;0;0;0;DMLPC;DILP1+37
105355  COCHB=*; *+42/; )KILL COCHB
105417
105417         0
105420  DILP1, 0;0;*-2;112000;0;0;IORES
105427         CLPUT;TEXIT;CLCLO;0;0
105434         0;1000;0;0;1000;0
105442         1167;1170;0;0;0;0;0
105451         (1;*+3;*-6;*-4;0;0;11;5
105461         DMLP1
105462  )FILL
105463  )KILL 1DVE1
105463
105463  "8NLP1
105463  %=============================================================================
105463  %       DMA LINEPRINTER #1
105463
105463
105463         0;0;0;0;0;0;0;0
105473         0;0;0;0;0;0;0;0
105503         0;0;0;0;0;0;0;0
105513         0;0;0;0;0;0
105521         0;2000;VERDR;BUSYV;FINIV;FEILV
105527         DMTLP;0;-10;142170;CTRVE;CTRVE
105535  DMPR1, 0;0;*-2;6;0;0;RETRA;0;0;MTRNS;0;0
105551         0;0;0;0
105555         0;0;0;0;0;0;0
105564         DMCLP;IDMP1+37
105566
105566  IDMP1, 0;0;*-2;112000;0;0;IORES
105575         CBPUT;TEXIT;DMSLP;0;0
105602         0;4000;0;0;4000;0
105610         1167;1170;0;0;0;0;2000
105617         (1;*+3;*-6;*-4;0;0;11;5
105627  )FILL
105630
105630  "8DVE2; 2DVE2=1
105630  "8DLP2+8DVE2
105630
105630  % LINE PRINTER 2 DATAFIELD
105630
105630         0;2DVE2;0;COCHB;0;0;0;0;0;0;0;0;0;0
105646         400;0;LP2BU;0
105652         DMLP2;4;IOX 437;IOX 436;IOX 435;0;TRDLP
105661         0;0;0
105664         DLPTM;0;-3;IOX 434;TLPRI;CLP10
105672  DMLP2, 0;0;*-2;2006;0;0;RETRA
105701         0;0;MTRNS;0;DILP2
105706         0;0;0;0;0;0;0
105715         0;0;0;0;;DMLPC;DILP2+37
105723  COCHB=*; *+42/; )KILL COCHB
105765
105765         0
105766  DILP2, 0;0;*-2;112000;0;0;IORES
105775         CLPUT;TEXIT;CLCLO;0;0
106002         0;1000;0;0;1000;0
106010         1175;1176;0;0;0;0;0
106017         (1;*+3;*-6;*-4;0;0;11;15
106027         DMLP2
106030  )FILL
106031  )KILL 2DVE2
106031
106031  "8NLP2
106031  %===========================================================================
106031  %       DMA LINEPRINTER #2
106031
106031         0;0;0;0;0;0;0;0
106041         0;0;0;0;0;0;0;0
106051         0;0;0;0;0;0;0;0
106061         0;0;0;0;0;0
106067         0;2000;VERDR;BUSYV;FINIV;FEILV
106075         DMTLP;0;-10;142200;CTRVE;CTRVE
106103  DMPR2, 0;0;*-2;6;0;0;RETRA;0;0;MTRNS;0;0
106117         0;0;0;0
106123         0;0;0;0;0;0;0
106132         DMCLP;IDMP2+37
106134
106134  IDMP2, 0;0;*-2;112000;0;0;IORES
106143         CBPUT;TEXIT;DMSLP;0;0
106150         0;4000;0;0;4000;0
106156         1175;1176;0;0;0;0;2000
106165         (1;*+3;*-6;*-4;0;0;11;5
106175  )FILL
106176
106176
106176  "8LP1
106176  % LINE PRINTER DATAFIELD
106176
106176         0;0;TTOMR;0;-3
106203         430;DWRIT;DWRIT
106206  DLPR,  0;0;*-2;110000;0;0;IORES
106215         TTPUT;DMOUT;CEXIT;0;0
106222         BUF;120+120;0;0;120+120;0;120
106231  %XXBU=BUF+120;)KILL BUF;BUF=XBU;)KILL XBU
106231
106231  "8LP2
106231  % LINE PRINTER 2 DATAFIELD
106231
106231         0;0;TTOMR;0;-3
106236         434;DWRIT;DWRIT
106241  DLPR2, 0;0;*-2;110000;0;0;IORES
106250         LPPUT;DMOUT;CEXIT;0;0
106255         BUF;120+120;0;0;120+120;0;120
106264  %XXBU=BUF+120;)KILL BUF;BUF=XBU;)KILL XBU
106264
106264  "
106264

106264
106264  "8N500
106264
106264  % DISC ACCESS QUEUE ELEMENT FOR ND-500 SWAPPER
106264  5DQAC,  0                 % ILQLINK
106265          5SWAP             % ILQRTRES
106266          5RSCO             % ILQPADDR
106267          5RDTR             % ILQRADDR
106270          0                 % ILQDFADDR
106271          0
106272          5                 % TYPCO
106273          0;0;0;  0;0
106300          0; 0;0; 0;0; 0;0; 0;0;
106311          *+10/             % FOR PATCHING
106321
106321  %==========================================================================
106321  %      N D - 5 0 0   L O C K S
106321  %
106321  5NAMS, 0;0;*-2;2             % LOCK FOR NAME SEGMENT
106325  CSSEM, 0;0;*-2;2             % LOCK FOR LOADING CONTROL STORE
106331  PLSSE, 0;0;*-2;2
106335  FIXSE, 0;0;*-2;2             % LOCK FOR FIX-SEGMENT HANDLING IN ND-500
106341  SYDSE, 0;0;*-2;2             % LOCK FOR STANDARD DOMAIN SEGMENT
106345  SWORK, 0;0;*-2;2             % LOCK FOR RTP-WORKA
106351
106351  %==========================================================================
106351  %       5 S W A P   A B S T R A N S   P A R A M E T E R S
106351  %
106351  ABSLI, XABSF;XSWME;XABLO;XABLN    % ABSTR PARLISTE
106355  XSDUN, 0;0                        % LOGICAL UNIT OF SWAP DEVICE
106357  XABSF, 0                          % FUNCTION IN ABSTR
106360  XSWME, 0;0                        % MEMORY ADDRESS OF DISC TRANSFER
106362  XABLO, 0;0                        % MASS STORAGE (DISC) ADDRESS
106364  XHABL, 0                          % DUMMY (DO NOT REMOVE!)
106365  XABLN, 0                          % NUMBER OF SECTORS TO TRANSFER
106366  SWEHS, 0                          % SWAP DEVICE HARDWARE STATUS
106367  CKFLI, 0                          % ERROR INDICATOR
106370  DSWMS, 0;0                        % ADDRESS TO SWAP "ABSTR" PARAMETERS IN SWMSG
106372
106372  %==============================================================================
106372  %       N D - 5 0 0    V A R I A B L E S
106372
106372  SWMSG, 0             % ADDRESS OF ND-500 SWAPPER'S MESSAGE (MAILBOX)
106373  5HIFL, 0             % ND-500 HISTOGRAM FLAG
106374  5HRTP, 0             % CONTAIN RT-DESCR ADDR OF PROGR. USING ND-500 HISTOGRAM
106375  5HINT, 0             % SIZE OF EACH HISTOGRAM INTERVAL IN BYTES
106376  5HICH, 0             % NUMBER OF HISTOGRAM INTERVALS
106377  5HRTB, 0             % ADDR OF ND-500 CPU DATAFIELD USED BY THE PROC. RESERVING THE HISTOGRAM
106400  5HIST, 0;0           % START ADDR OF HISTOGRAM AREA (ND-500 BYTE ADDR)
106402  5HIDA=*; *+1000/     % HISTOGRAM SAMPLING BUFFER
107402  5HIOU, 0;0           % HISTOGRAM SAMPLE LOCS. FOR OUTSIDE "HISTOGRAM AREA"
107404  5MLOG, 0             % RT-DESCR OF PROGR. USING ND-500 MON.CALL LOG
107405  5MLOP, 0             % PROC.NO OF PROC. BEING MON.CALL LOGGED
107406  5LOGP, 0             % PROCESS-LOG-ONE/PROCESS-LOG-ALL FLAG
107407  D5FXB=*
107407  5FXBN, 0             % MEM.BANK OF FIX-INFO TABLE AD DATA.CAP. TABLE
107410  5FXTB, 0             % ADDR OF FIX-INFO TABLE WITHIN 5FXBNK
107411  5DSPS, 0             % ADDR OF CAP. TABLE WITHIN 5FXBNK
107412  CERNE, 0             % FLAG FOR MON CERN ALLOWED OR NOT
107413  5DBFL, 0             % SET IF MON 377 FOR DEBUGGING SWAPPER IS IN USE
107414  HIMES, 0             % ADDRESS OF HISTOGRAM MESSAGE (MAILBOX)
107415  PROCA, 0             % ADDR OF ND-500 PROC.DESCR CURRENTLY SERVED BY ND-500 DRIVER
107416  5MSIN, 0             % FLAG FOR ND-500 BUFFERS ALLOCATED OR NOT
107417  5MMES, 0             % CURRENT ND-500 MESS. IN N500C (MONITOR LEVEL)
107420  5FPMA, 0             % FIRST PHYS PAGE USED FOR ND-500 MESSAGES
107421  5NPMA, 0             % NUMBER OF PAGES USED FOR ND-500 MESSAGES
107422  5FPM6, 0             % FIRST PHYS PAGE USED FOR MON60 BUFFERS
107423  5NPM6, 0             % NUMBER OF PAGES USED FOR MON60 BUFFERS
107424  5SWOW, 0             % MESSAGE CURRENTLY BEING SERVED BY ND-500 SWAPPER
107425  5SUSP, 0             % FLAG SET WHEN A ND-500 PROCESS IS SUSPENDED
107426  SUSPA, 0             % COPY OG ATIM2 SET BY ND-500 TIMESLICER
107427  %===========================================
107427  % VARIABLES USED BY IBMOVE
107427
107427  IBM41,0;0       % DOUBLE  IBM41PITENTRY     % SAVED TERMINAL PITENTRY
107431  IBM5P,0;0       % DOUBLE  IBM5PITENTRY      % SAVED ND500-MESSAGE PITENTRY
107433  IBMM6,0;0       % DOUBLE  IBMM6PITENTRY     % SAVED MON60-BUFFER PITENTRY
107435  IBMIN,0         % INTEGER IBMIN5MSG         % SAVED IN5MSG
107436  IBMPR,0         % INTEGER IBMPRD            % SAVED PROCESS DESCRIPTION ADDRESS
107437  IBMWN,0         % INTEGER IBMWNDMESS        % LOGICAL ADDR OF MESSAGE
107440  IBMLG,0         % INTEGER IBMLGBUADDR       % LOGICAL ADDR OF DATA BUFFER
107441  %============================================
107441
107441  RTPWO=*; *+5WCBU/    % "WORKA" FOR RT-PROGRAMS
107525
107525  "8HIST+8LOG
107525

107525  %============================================================================
107525  %      H I S T O G R A M   A N D   L O G G I N G   C O M M A N D ' S
107525  %      V A R I A B L E S
107525  %
107525  LOGFI, 0                     % TERMINAL OUTPUT DF LOGGING ON
107526  MNLOG, 0                     % TERMINAL OUTPUT DF IF NOTS/MTAD.
107527  COMRT, 0                     % FLAG >< 0 WHEN PROGRAM-LOG AND SYSTEM-HISTOGRAM
107530  ALLRT, 0                     % FLAG >< 0 WHEN PROGRAM-LOG
107531  MBLGA, 0                     % MEMORY-BANK OF PROGRAM-LOG SAMPLING BUFFER
107532  ALGAR, 0                     % PHYS.ADDR WITHIN MBPGA OF START OF PROGRAM-LOG SAMBLING BUFFER
107533  %=============================
107533  % ARRAY FOR HISTOGRAM
107533  % DO NOT CHANGE THE ORDER OF THESE VARIABLES!
107533  0;0                          % HTOT1,HTOT2  % TOTAL NUMBER OF SAMPLES
107535  0;0                          % STLT1,STLT2  % COUNTS BACKGROUND PROGRAM EXECUTING ON RING 2/3
107537  0                            % HISTPROG     % PROGRAM TO DO HISTOGRAMING ON
107540  0                            % HISTART      % FLAG >< 0 WHEN HISTOGRAM IS STARTED
107541  0                            % FPREG        % ADDR OF FIRST HISTOGRAM INTERVAL
107542  0                            % DELTA        % SIZE OF EACH HISTOGRAM INTERVAL
107543  0                            % HISTFLAG     % FLAG >< 0 WHEN SYSTEM-HISTOGRAM
107544  0                            % CHILEV       % "IRR XX DP" INSTRUCTION
107545  0                            % FLGHIST      % FLAG FOR COMMANDS ROUTINES
107546  HISTO=*
107546  HISTO+200/                   % ARRAY FOR SAMPLING 100B "HISTOGRAM CHANNELS"
107746  0;0                          % SAMPLING OUTSIDE "HISTOGRAM CHANNELS"
107750  %=============================
107750  SLVTB=*
107750  SLVTB+40/                    % INTERRUPT LEVEL SAMPLING FOR COMBINATION
110010                               % OF PROGRAM-LOG AND DEF-SYS-HISTOGRAM COMMANDS
110010

110010  %=============================
110010  % PROGRAM-LOG COMMAND VARIABLES
110010  % DO NOT CHANGE THE ORDER OF THESE VARIABLES!
110010  %
110010  LGARR=*
110010  0;0                          % ACTC1,ACTC2  % CPU ACTIVE
110012  0;0                          % ACTP1,ACTP2  % TARGET PROGRAM ACTIVE (USING CPU)
110014  0;0                          % SWC1,SWC2    % SWAPPER IN USE
110016  0;0                          % SWP1,SWP2    % SWAPPER IN USE BY TARGET PROGRAM
110020  0;0                          % FILC1,FILC2  % FILESYSTEM IN USE
110022  0;0                          % FILP1,FILP2  % FILESYSTEM IN USE BY TARGET PROGRAM
110024  0;0                          % DIC1,DIC2    % MAIN SWAP-DISC IN USE
110026  0;0                          % PASP1,PASP2  % TARGET PROGRAM PASSIVE
110030  0;0                          % IOWP1,IOWP2  % TARGET PROGRAM IN I/O WAIT
110032  0;0                          % TOTL1,TOTL2  % TOTAL NUMBER OF SAMPLES
110034  0;0                          % U1T1,U1T2    % ADDITIONAL LOG.UNIT #1 USED
110036  0;0                          % U1P1,U1P2    % ADDITIONAL LOG.UNIT #1 USED BY TARGET PROGRAM
110040  0;0                          % U2T1,U2T2    % ADDITIONAL LOG.UNIT #2 USED
110042  0;0                          % U2P1,U2P2    % ADDITIONAL LOG.UNIT #2 USED BY TARGET PROGRAM
110044  0                            % ADRSWP       % ADDR OF MAIN-SWAP DEVICE DF
110045  0;0                          % ADRU1,ADRU2  % ADDRS OF ADDITIONAL UNITS DF'S
110047  0                            % LOGPROG      % RT-DESCR OF TARGET PROGRAM
110050  0;0                          % PTOT1,PTOT2  % TOTAL NUMBER OF SAMPLES FOR PROGRAM-LOG
110052  0;0                          % XINCR,CINCR  % NUMBER OF INTERRUPTS PER SAMPLE (INITIAL AND COUNTING)
110054  %=============================
110054
110054
110054  "8MOLI
110054  %===========================================================================
110054  %      M L I D F I E L D
110054  %
110054  % MONITOR CALL WORKING FIELD FOR MON LOGIN
110054  %
110054         MLGTM;0;-100;0;0;0
110062  MLIDF, 0;0;*-2;0
110066  *+140/
110226
110226  "8STRN+8N500
110226  %=============================================================================
110226  %       3 O W F I E L D
110226  %
110226  % USED AS TEMPORARLY MONITOR-CALL WORKING-FIELD FOR
110226  % MON OUTSTRING TO TERMINAL AND TAD
110226  %
110226  3OWFI=*; *+11/
110237
110237
110237  "8SIBA+8SIBX+8SIBM+8SIBN
110237  %==============================================================================
110237  %        S I B A S   M O N I T O R   C A L L S   D A T A
110237  %
110237  "8SIBA
110237  )KILL XSIB; XSIB=2
110237  "8SIBX
110237  )KILL XSIB; XSIB=5
110237  "8SIBM
110237  )KILL XSIB; XSIB=13
110237  "
110237
110237  MXSIB,XSIB                             % MAX SIBAS NUMBER IN THIS SYSTEM, 0 IS FIRST
110240  )KILL XSIB;
110240  "8SIBA+8SIBX+8SIBM+8SIBN
110240  SIBBD=*                                % POINTER TO MON MSIBB WORKING FIELDS
110240         DSI0;DSI1;DSI2
110243  "8SIBX+8SIBM+8SIBN
110243         DSI3;DSI4;DSI5
110246  "8SIBM+8SIBN
110246         DSI6;DSI7;DSI8;DSI9;DSI10;DSI11
110254  "8SIBA+8SIBX+8SIBM+8SIBN
110254  SIBAP=*                                % POINTER TO MON MAPSIB WORKING FIELDS
110254         DIA0;DIA1;DIA2
110257  "8SIBX+8SIBM+8SIBN
110257         DIA3;DIA4;DIA5
110262  "8SIBM+8SIBN
110262         DIA6;DIA7;DIA8;DIA9;DIA10;DIA11
110270  "8SIBA+8SIBX+8SIBM+8SIBN
110270  DIA0, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #0
110317  DIA1, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #1
110346  DIA2, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #2
110375
110375        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110403  DSI0, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #0
110424        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110432  DSI1, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #1
110453        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110461  DSI2, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #2
110502
110502  "8SIBX+8SIBM+8SIBN
110502  DIA3, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #3
110531  DIA4, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #4
110560  DIA5, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #5
110607
110607        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110615  DSI3, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #3
110636        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110644  DSI4, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #4
110665        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
110673  DSI5, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #5
110714
110714  "8SIBM+8SIBN
110714  DIA6, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #6
110743  DIA7, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #7
110772  DIA8, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #8
111021  DIA9, 0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #9
111050  DIA10,0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #10
111077  DIA11,0;0;*-2;2;0;0;APLRS;*20/         % MAPSIB WORKING FIELD FOR SIBAS #11
111126
111126        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111134  DSI6, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #6
111155        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111163  DSI7, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #7
111204        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111212  DSI8, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #8
111233        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111241  DSI9, 0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #9
111262        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111270  DSI10,0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #10
111311        TISIB;0;0;0;0;0                  % TMSUB TMR TTMR 3*DUMMY
111317  DSI11,0;0;*-2;2;*15/                   % MSIBB WORKING FIELD FOR SIBAS #11
111340  "8SIBA+8SIBX+8SIBM+8SIBN
111340  EDSIB=*
111340
111340
111340  "-CAMA
111340  RTTAB=*
111340  DVTAB=*
111340  MAXCA=1
111340
111340  "8SWLG
111340  %=============================================================================
111340  %      S W A P P I N G  -  L O G   D A T A
111340  %
111340  CSWLG,0                  % ><0 : SWAPPING-LOG STARTED
111341                           % = RT-DESC. ADDR: LOG FOR A SPESIFIC PROGRAM TOO.
111341  CCSWL,0                  % SAVED CSWLG
111342  SWLGO,0                  % TERMINAL NUMBER OF USER ACTIVATED SWAPPING LOG
111343  TFPF1,0;TFPF2,0          % TOTAL FAST PAGE FAULTS (REQUIRING NO DISC ACCESS)
111345  TFPFS=TFPF1
111345  CFPF1,0;CFPF2,0          % NUMBER OF FAST PAGE FAULTS FOR A SPESIFIC PROGRAM
111347  CFPFS=CFPF1
111347  TPFR1,0;TPFR2,0          % TOTAL NUMBER OF PAGE FAULTS IN RT-COMMON
111351  TPFRS=TPFR1
111351  CPFR1,0;CPFR2,0          % NUMBER OF PAGE FAULTS IN RT-COMMON FOR A SPESIFIC PROGRAM
111353  CPFRS=CPFR1
111353  TPF41,0;TPF42,0          % TOTAL NUMBER OF PAGE FAULTS ON LEVEL 4
111355  TPFL4=TPF41
111355  CPF41,0;CPF42,0          % NUMBER OF PAGE FAULTS ON LEVEL 4 FOR A SPESIFIC PROGRAM
111357  CPFL4=CPF41
111357  TPF11,0;TPF12,0          % TOTAL NUMBER OF PAGE FAULTS ON LEVEL 1
111361  TPFL1=TPF11
111361  CPF11,0;CPF12,0          % NUMBER OF PAGE FAULTS ON LEVEL 1 FOR A SPESIFIC PROGRAM
111363  CPFL1=CPF11
111363  SNWP1,0;SNWP2,0          % NUMBER OF PAGES SWAPPED OUT
111365  SNWPS=SNWP1
111365  %============================================================================
111365  %   D I S C   A C C E S S   L O G
111365  %
111365  "8DILG
111365
111365
111365  DLPM6, (4; (DILGS; DLMFP; DLMLP; (0; (0    % MON 61 PARAMETER LISTE
111373  DLMFP, 0
111374  DLMLP, 0
111375  XPPRS, *+3;*+3;*+2           % PARAMETER LIST FOR RESRV/RELES
111400         2201;0
111402  DLPMF, (DILGS                % PARAMETER LIST FOR FIX/UNFIX OF DISC ACCESS
111403  )FILL
111406  CDILB=*; *+20/               % TEMPORARY ARRAY FOR CONTENTS IN DILBU
111426
111426  "8LAMU
111426  %=============================================================================
111426  %      L A M U  DISCONNECT PARAMETER LIST.
111426  LAMD9, (4; (-1; (0; (0
111432  )FILL
111435  "
111435  %==============================================================================
111435  %      DATAFIELD ADDRESSES AND LOGICAL UNITS OF ALL DISCS
111435  %
111435  DIDLO=*
111435  BIGDI;1100
111437  BIGD2;1207
111441  BIGD3;565
111443  BIGD4;566
111445  WIGDI;1224
111447  WIGD2;1231
111451  DRFIE;502
111453  DRFI2;1104
111455  GIGDI;1100
111457  GIGD2;1207
111461
111461  %===========================================================================
111461  %  DISC ERROR DATAFIELD
111461  %
111461  "8DI1+8BD1+8GD1+8WD1+8MD1 8DILG
111461  DEDF1=*;*+60/
111541  "8DI2+8BD2+8GD2+8WD2+8MD2 8DILG
111541  DEDF2=*;*+60/
111621  "
111621  %=============================================================================
111621  %          N D - 1 0 0   S Y M B O L I C   D E B U G G E R
111621  %
111621  MAXUS=0
111621  "8DB30+8DB40+8DB50+8DB60
111621  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
111621  "8DB20+8DB30+8DB40+8DB50+8DB60
111621  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
111621  "8DB10+8DB20+8DB30+8DB40+8DB50+8DB60
111621  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
111621  "8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
111621  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
111621  "8DB01+8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
111621  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
111621  "
111621  DBGPR=*; *+MAXUS/
111661  )KILL MAXUS
111661
111661  %==============================================================================
111661  % 29.2       B A C K G R O U N D  T A B L E
111661  %
111661  % BACKGROUND TERMINAL TABLE
111661  1NBPP,0      % NUMBER OF BACKGROUND PROGRAMS (NOT EQUAL ENTRIES IN BACKGROUND TABLE)
111662  2NBPP,0      % NUMBER OF DYNAMIC ALLOCATED BACKGROUND PROGRAMS
111663  BNUMB, NOBGP
111664  BACKT,DT01R
111665  "8TR5 -9SMO1 8BP5+8BACS -9SMO1 8TR5;DT05R
111666  "8TR6 8BP6+8BACS 8TR6;DT06R
111667  "8TR7 8BP7+8BACS 8TR7;DT07R
111670  "8TR8 8BP8+8BACS 8TR8;DT08R
111671  "8TR9 -9SMO2 8BP9+8BACS -9SMO2 8TR9;DT09R
111672  "8TR10 8BP10+8BACS 8TR10;DT10R
111673  "8TR11 8BP11+8BACS 8TR11;DT11R
111674  "8TR12 8BP12+8BACS 8TR12;DT12R
111675  "8TR13 -9SMO3 8BP13+8BACS -9SMO3 8TR13;DT13R
111676  "8TR14 8BP14+8BACS 8TR14;DT14R
111677  "8TR15 8BP15+8BACS 8TR15;DT15R
111700  "8TR16 8BP16+8BACS 8TR16;DT16R
111701  "8TR17 -9SMO4 8BP17+8BACS -9SMO4 8TR17;DT17R
111702  "8TR18 8BP18+8BACS 8TR18;DT18R
111703  "8TR19 8BP19+8BACS 8TR19;DT19R
111704  "8TR20 8BP20+8BACS 8TR20;DT20R
111705  "8TR21 -9SMO5 8BP21+8BACS -9SMO5 8TR21;DT21R
111706  "8TR22 8BP22+8BACS 8TR22;DT22R
111707  "8TR23 8BP23+8BACS 8TR23;DT23R
111710  "8TR24 8BP24+8BACS 8TR24;DT24R
111711  "8TR25 -8SMO9 8BP25+8BACS -8SMO9 8TR25;DT25R
111712  "8TR26 8BP26+8BACS 8TR26;DT26R
111713  "8TR27 8BP27+8BACS 8TR27;DT27R
111714  "8TR28 8BP28+8BACS 8TR28;DT28R
111715  "8TR29 -9SMO6 8BP29+8BACS -9SMO6 8TR29;DT29R
111716  "8TR30 8BP30+8BACS 8TR30;DT30R
111717  "8TR31 8BP31+8BACS 8TR31;DT31R
111720  "8TR32 8BP32+8BACS 8TR32;DT32R
111721  "8TR33 8BP33+8BACS 8TR33;DT33R
111722  "8TR34 8BP34+8BACS 8TR34;DT34R
111723  "8TR35 -8SMO7 8BP35+8BACS -8SMO7 8TR35;DT35R
111724  "8TR36 -8SMO8 8BP36+8BACS -8SMO8 8TR36;DT36R
111725  "8TR37 -8SMO9 8BP37+8BACS -8SMO9 8TR37;DT37R
111726  "8TR38 -9SMO1 8BP38+8BACS -9SMO1 8TR38;DT38R
111727  "8TR39 -9SMO2 8BP39+8BACS -9SMO2 8TR39;DT39R
111730  "8TR40 -9SMO3 8BP40+8BACS -9SMO3 8TR40;DT40R
111731  "8TR41 -9SMO4 8BP41+8BACS -9SMO4 8TR41;DT41R
111732  "8TR42 -9SMO5 8BP42+8BACS -9SMO5 8TR42;DT42R
111733  "8TR43 -9SMO6 8BP43+8BACS -9SMO6 8TR43;DT43R
111734  "8TR44 -9SMO7 8BP44+8BACS -9SMO7 8TR44;DT44R
111735  "8TR45 8BP45+8BACS 8TR45;DT45R
111736  "8TR46 8BP46+8BACS 8TR46;DT46R
111737  "8TR47 8BP47+8BACS 8TR47;DT47R
111740  "8TR48 8BP48+8BACS 8TR48;DT48R
111741  "8TR49 8BP49+8BACS 8TR49;DT49R
111742  "8TR50 8BP50+8BACS 8TR50;DT50R
111743  "8TR51 8BP51+8BACS 8TR51;DT51R
111744  "8TR52 8BP52+8BACS 8TR52;DT52R
111745  "8TR65 8BP65+8BACS 8TR65;DT65R
111746  "8TR66 8BP66+8BACS 8TR66;DT66R
111747  "8TR67 8BP67+8BACS 8TR67;DT67R
111750  "8TR68 8BP68+8BACS 8TR68;DT68R
111751  "8TR69 8BP69+8BACS 8TR69;DT69R
111752  "8TR70 8BP70+8BACS 8TR70;DT70R
111753  "8TR71 8BP71+8BACS 8TR71;DT71R
111754  "8TR72 8BP72+8BACS 8TR72;DT72R
111755  "8TR73 8BP73+8BACS 8TR73;DT73R
111756  "8TR74 8BP74+8BACS 8TR74;DT74R
111757  "8TR75 8BP75+8BACS 8TR75;DT75R
111760  "8TR76 8BP76+8BACS 8TR76;DT76R
111761  "8TR77 8BP77+8BACS 8TR77;DT77R
111762  "8TR78 8BP78+8BACS 8TR78;DT78R
111763  "8TR79 8BP79+8BACS 8TR79;DT79R
111764  "8TR80 8BP80+8BACS 8TR80;DT80R
111765  "8TR81 8BP81+8BACS 8TR81;DT81R
111766  "8TR82 8BP82+8BACS 8TR82;DT82R
111767  "8TR83 8BP83+8BACS 8TR83;DT83R
111770  "8TR84 8BP84+8BACS 8TR84;DT84R
111771  "8TR85 8BP85+8BACS 8TR85;DT85R
111772  "8TR86 8BP86+8BACS 8TR86;DT86R
111773  "8TR87 8BP87+8BACS 8TR87;DT87R
111774  "8TR88 8BP88+8BACS 8TR88;DT88R
111775  "8TR89 8BP89+8BACS 8TR89;DT89R
111776  "8TR90 8BP90+8BACS 8TR90;DT90R
111777  "8TR91 8BP91+8BACS 8TR91;DT91R
112000  "8TR92 8BP92+8BACS 8TR92;DT92R
112001  "8TR93 8BP93+8BACS 8TR93;DT93R
112002  "8TR94 8BP94+8BACS 8TR94;DT94R
112003  "8TR95 8BP95+8BACS 8TR95;DT95R
112004  "8TR96 8BP96+8BACS 8TR96;DT96R
112005  "8TR97 8BP97+8BACS 8TR97;DT97R
112006  "8TR98 8BP98+8BACS 8TR98;DT98R
112007  "8TR99 8BP99+8BACS 8TR99;DT99R
112010  "9TR00 9BP00+8BACS 9TR00;T100R
112011  "9TR01 9BP01+8BACS 9TR01;T101R
112012  "9TR02 9BP02+8BACS 9TR02;T102R
112013  "9TR03 9BP03+8BACS 9TR03;T103R
112014  "9TR04 9BP04+8BACS 9TR04;T104R
112015  "9TR05 9BP05+8BACS 9TR05;T105R
112016  "9TR06 9BP06+8BACS 9TR06;T106R
112017  "9TR07 9BP07+8BACS 9TR07;T107R
112020  "9TR08 9BP08+8BACS 9TR08;T108R
112021  "9TR09 9BP09+8BACS 9TR09;T109R
112022  "9TR10 9BP10+8BACS 9TR10;T110R
112023  "9TR11 9BP11+8BACS 9TR11;T111R
112024  "9TR12 9BP12+8BACS 9TR12;T112R
112025  "9TR13 9BP13+8BACS 9TR13;T113R
112026  "9TR14 9BP14+8BACS 9TR14;T114R
112027  "9TR15 9BP15+8BACS 9TR15;T115R
112030  "9TR16 9BP16+8BACS 9TR16;T116R
112031  "9TR17 9BP17+8BACS 9TR17;T117R
112032  "9TR18 9BP18+8BACS 9TR18;T118R
112033  "9TR19 9BP19+8BACS 9TR19;T119R
112034  "9TR20 9BP20+8BACS 9TR20;T120R
112035  "9TR21 9BP21+8BACS 9TR21;T121R
112036  "9TR22 9BP22+8BACS 9TR22;T122R
112037  "9TR23 9BP23+8BACS 9TR23;T123R
112040  "9TR24 9BP24+8BACS 9TR24;T124R
112041  "9TR25 9BP25+8BACS 9TR25;T125R
112042  "9TR26 9BP26+8BACS 9TR26;T126R
112043  "9TR27 9BP27+8BACS 9TR27;T127R
112044  "9TR28 9BP28+8BACS 9TR28;T128R
112045  "9TR29 9BP29+8BACS 9TR29;T129R
112046  "9TR30 9BP30+8BACS 9TR30;T130R
112047  "9TR31 9BP31+8BACS 9TR31;T131R
112050  "9TR32 9BP32+8BACS 9TR32;T132R
112051  "9TR33 9BP33+8BACS 9TR33;T133R
112052  "9TR34 9BP34+8BACS 9TR34;T134R
112053  "9TR35 9BP35+8BACS 9TR35;T135R
112054  "9TR36 9BP36+8BACS 9TR36;T136R
112055  "9TR37 9BP37+8BACS 9TR37;T137R
112056  "9TR38 9BP38+8BACS 9TR38;T138R
112057  "9TR39 9BP39+8BACS 9TR39;T139R
112060  "9TR40 9BP40+8BACS 9TR40;T140R
112061  "TEFX1;TB01R
112062  "BAD01;BD01R
112063  "BAD02;BD02R
112064  "BAD03;BD03R
112065  "BAD04;BD04R
112066  "BAD05;BD05R
112067  "BAD06;BD06R
112070  "BAD07;BD07R
112071  "BAD08;BD08R
112072  "BAD09;BD09R
112073  "BAD10;BD10R
112074  "BAD11;BD11R
112075  "BAD12;BD12R
112076  "BAD13;BD13R
112077  "BAD14;BD14R
112100  "BAD15;BD15R
112101  "BAD16;BD16R
112102  "BAD17;BD17R
112103  "BAD18;BD18R
112104  "BAD19;BD19R
112105  "BAD20;BD20R
112106  "BAD21;BD21R
112107  "BAD22;BD22R
112110  "BAD23;BD23R
112111  "BAD24;BD24R
112112  "BAD25;BD25R
112113  "BAD26;BD26R
112114  "BAD27;BD27R
112115  "BAD28;BD28R
112116  "BAD29;BD29R
112117  "BAD30;BD30R
112120  "BAD31;BD31R
112121  "BAD32;BD32R
112122  "BAD33;BD33R
112123  "BAD34;BD34R
112124  "BAD35;BD35R
112125  "BAD36;BD36R
112126  "BAD37;BD37R
112127  "BAD38;BD38R
112130  "BAD39;BD39R
112131  "BAD40;BD40R
112132  "BAD41;BD41R
112133  "BAD42;BD42R
112134  "BAD43;BD43R
112135  "BAD44;BD44R
112136  "BAD45;BD45R
112137  "BAD46;BD46R
112140  "BAD47;BD47R
112141  "BAD48;BD48R
112142  "BAD49;BD49R
112143  "BAD50;BD50R
112144  "BAD51;BD51R
112145  "BAD52;BD52R
112146  "BAD53;BD53R
112147  "BAD54;BD54R
112150  "BAD55;BD55R
112151  "BAD56;BD56R
112152  "BAD57;BD57R
112153  "BAD58;BD58R
112154  "BAD59;BD59R
112155  "BAD60;BD60R
112156  "BAD61;BD61R
112157  "BAD62;BD62R
112160  "BAD63;BD63R
112161  "BAD64;BD64R
112162  "BAD65;BD65R
112163  "BAD66;BD66R
112164  "BAD67;BD67R
112165  "BAD68;BD68R
112166  "BAD69;BD69R
112167  "BAD70;BD70R
112170  "
112170  BBCHT=*
112170  "8BCH1;BT01R
112171  "8BCH2;BT02R
112172  "8BCH3;BT03R
112173  "8BCH4;BT04R
112174  "8BCH5;BT05R
112175  "8BCH6;BT06R
112176  "8BCH7;BT07R
112177  "8BCH8;BT08R
112200  "8BCH9;BT09R
112201  "8BC10;BT10R
112202  "
112202  EBCHT=*
112202
112202  NOBGP=*-BACKT
112202  -1
112203
112203  %==============================================================================
112203  % 29.3       B A T C H  T A B L E
112203  %
112203  BCHTA, 0
112204  "8BCH1; 0;BCH01;1236;1237
112210  "8BCH2; 0;BCH02;1240;1241
112214  "8BCH3; 0;BCH03;1242;1243
112220  "8BCH4; 0;BCH04;1244;1245
112224  "8BCH5; 0;BCH05;1246;1247
112230  "8BCH6; 0;BCH06;1250;1251
112234  "8BCH7; 0;BCH07;1252;1253
112240  "8BCH8; 0;BCH08;1254;1255
112244  "8BCH9; 0;BCH09;1256;1257
112250  "8BC10; 0;BCH10;1260;1261
112254  "
112254  8NOBA=*
112254         -1
112255  "8ABAT
112255  %==============================================================================
112255  %      E X T R A   B A T C H  T A B L E
112255  %      APPEND-BATCH  QUE DEVICE-NUMBER TABLE
112255  XBCHT,0
112256  "8ABAT 8BCH1;1237
112257  "8ABAT 8BCH2;1241
112260  "8ABAT 8BCH3;1243
112261  "8ABAT 8BCH4;1245
112262  "8ABAT 8BCH5;1247
112263  "8ABAT 8BCH6;1251
112264  "8ABAT 8BCH7;1253
112265  "8ABAT 8BCH8;1255
112266  "8ABAT 8BCH9;1257
112267  "8ABAT 8BC10;1261
112270  "8ABAT;      -1;
112271
112271
112271  "8BACS
112271

112271  %============================================================================
112271  %            X B C K T
112271  %
112271  % THIS TABLE IS USED TO FIND THE ADDRESS OF THE BACKGROUND PROGRAMS
112271  % INPUT DATAFIELD. (ACTUAL BACKGROUND PROGRAM - BAK01) IS INDEX IN
112271  % THIS TABLE. (USED BY GETDATAFIELD)
112271  %
112271  XBCKT=*
112271  "8BACS; DT01R
112272  "8BP2 8BACS; 0
112273  "8BP3 8BACS; 0
112274  "8BP4 8BACS; 0
112275  "8BP5 8BACS; 0
112276  "8BP6 8BACS; 0
112277  "8BP7 8BACS; 0
112300  "8BP8 8BACS; 0
112301  "8BP9 8BACS; 0
112302  "8BP10 8BACS; 0
112303  "8BP11 8BACS; 0
112304  "8BP12 8BACS; 0
112305  "8BP13 8BACS; 0
112306  "8BP14 8BACS; 0
112307  "8BP15 8BACS; 0
112310  "8BP16 8BACS; 0
112311  "8BP17 8BACS; 0
112312  "8BP18 8BACS; 0
112313  "8BP19 8BACS; 0
112314  "8BP20 8BACS; 0
112315  "8BP21 8BACS; 0
112316  "8BP22 8BACS; 0
112317  "8BP23 8BACS; 0
112320  "8BP24 8BACS; 0
112321  "8BP25 8BACS; 0
112322  "8BP26 8BACS; 0
112323  "8BP27 8BACS; 0
112324  "8BP28 8BACS; 0
112325  "8BP29 8BACS; 0
112326  "8BP30 8BACS; 0
112327  "8BP31 8BACS; 0
112330  "8BP32 8BACS; 0
112331  "8BP33 8BACS; 0
112332  "8BP34 8BACS; 0
112333  "8BP35 8BACS; 0
112334  "8BP36 8BACS; 0
112335  "8BP37 8BACS; 0
112336  "8BP38 8BACS; 0
112337  "8BP39 8BACS; 0
112340  "8BP40 8BACS; 0
112341  "8BP41 8BACS; 0
112342  "8BP42 8BACS; 0
112343  "8BP43 8BACS; 0
112344  "8BP44 8BACS; 0
112345  "8BP45 8BACS; 0
112346  "8BP46 8BACS; 0
112347  "8BP47 8BACS; 0
112350  "8BP48 8BACS; 0
112351  "8BP49 8BACS; 0
112352  "8BP50 8BACS; 0
112353  "8BP51 8BACS; 0
112354  "8BP52 8BACS; 0
112355  "8BP53 8BACS; 0
112356  "8BP54 8BACS; 0
112357  "8BP55 8BACS; 0
112360  "8BP56 8BACS; 0
112361  "8BP57 8BACS; 0
112362  "8BP58 8BACS; 0
112363  "8BP59 8BACS; 0
112364  "8BP60 8BACS; 0
112365  "8BP61 8BACS; 0
112366  "8BP62 8BACS; 0
112367  "8BP63 8BACS; 0
112370  "8BP64 8BACS; 0
112371  "8BP65 8BACS; 0
112372  "8BP66 8BACS; 0
112373  "8BP67 8BACS; 0
112374  "8BP68 8BACS; 0
112375  "8BP69 8BACS; 0
112376  "8BP70 8BACS; 0
112377  "8BP71 8BACS; 0
112400  "8BP72 8BACS; 0
112401  "8BP73 8BACS; 0
112402  "8BP74 8BACS; 0
112403  "8BP75 8BACS; 0
112404  "8BP76 8BACS; 0
112405  "8BP77 8BACS; 0
112406  "8BP78 8BACS; 0
112407  "8BP79 8BACS; 0
112410  "8BP80 8BACS; 0
112411  "8BP81 8BACS; 0
112412  "8BP82 8BACS; 0
112413  "8BP83 8BACS; 0
112414  "8BP84 8BACS; 0
112415  "8BP85 8BACS; 0
112416  "8BP86 8BACS; 0
112417  "8BP87 8BACS; 0
112420  "8BP88 8BACS; 0
112421  "8BP89 8BACS; 0
112422  "8BP90 8BACS; 0
112423  "8BP91 8BACS; 0
112424  "8BP92 8BACS; 0
112425  "8BP93 8BACS; 0
112426  "8BP94 8BACS; 0
112427  "8BP95 8BACS; 0
112430  "8BP96 8BACS; 0
112431  "8BP97 8BACS; 0
112432  "8BP98 8BACS; 0
112433  "8BP99 8BACS; 0
112434  "9BP00 8BACS; 0
112435  "9BP01 8BACS; 0
112436  "9BP02 8BACS; 0
112437  "9BP03 8BACS; 0
112440  "9BP04 8BACS; 0
112441  "9BP05 8BACS; 0
112442  "9BP06 8BACS; 0
112443  "9BP07 8BACS; 0
112444  "9BP08 8BACS; 0
112445  "9BP09 8BACS; 0
112446  "9BP10 8BACS; 0
112447  "9BP11 8BACS; 0
112450  "9BP12 8BACS; 0
112451  "9BP13 8BACS; 0
112452  "9BP14 8BACS; 0
112453  "9BP15 8BACS; 0
112454  "9BP16 8BACS; 0
112455  "9BP17 8BACS; 0
112456  "9BP18 8BACS; 0
112457  "9BP19 8BACS; 0
112460  "9BP20 8BACS; 0
112461  "9BP21 8BACS; 0
112462  "9BP22 8BACS; 0
112463  "9BP23 8BACS; 0
112464  "9BP24 8BACS; 0
112465  "9BP25 8BACS; 0
112466  "9BP26 8BACS; 0
112467  "9BP27 8BACS; 0
112470  "9BP28 8BACS; 0
112471  "9BP29 8BACS; 0
112472  "9BP30 8BACS; 0
112473  "9BP31 8BACS; 0
112474  "9BP32 8BACS; 0
112475  "9BP33 8BACS; 0
112476  "9BP34 8BACS; 0
112477  "9BP35 8BACS; 0
112500  "9BP36 8BACS; 0
112501  "9BP37 8BACS; 0
112502  "9BP38 8BACS; 0
112503  "9BP39 8BACS; 0
112504  "9BP40 8BACS; 0
112505  "9BP41 8BACS; 0
112506  "9BP42 8BACS; 0
112507  "9BP43 8BACS; 0
112510  "9BP44 8BACS; 0
112511  "9BP45 8BACS; 0
112512  "9BP46 8BACS; 0
112513  "9BP47 8BACS; 0
112514  "9BP48 8BACS; 0
112515  "9BP49 8BACS; 0
112516  "9BP50 8BACS; 0
112517  "9BP51 8BACS; 0
112520  "8BACS 8BCH1;BT01R
112521  "8BACS 8BCH2;BT02R
112522  "8BACS 8BCH3;BT03R
112523  "8BACS 8BCH4;BT04R
112524  "8BACS 8BCH5;BT05R
112525  "8BACS 8BCH6;BT06R
112526  "8BACS 8BCH7;BT07R
112527  "8BACS 8BCH8;BT08R
112530  "8BACS 8BCH9;BT09R
112531  "8BACS 8BC10;BT10R
112532  "
112532
112532  )LINE

112532  %%%%%%%%%%%%  M A C R O E S  -  S I N 4  -  G E N  %%%%%%%%%%%%%%%%%%%%%
112532
112532  %%    MACROES USED ON SIN4-GEN
112532  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
112532  %%     PREVIOUSLY USED MACROES ARE KILLED
112532  )KILL JONAC RTUP RWCR RWCW BASFI
112532  )KILL VDRT VPRT
112532
112532  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
112532
112532
112532
112532
112532  % FILE SYSTEM MACROS:
112532
112532  % MACRO FOR DEVICE BUFFER:
112532  )MCDEF FDVBU $DKLDN
F$DKLDN , 0 ; 0 ; *-2 ; 2
-1 ; -1 ; -1 ; $DKLDN ; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
]
112532
112532  % MACRO FOR DIRECTORY ENTRY:
112532
112532  )MCDEF DDRTB $DKDVN,$DKNAN,$DILDN,$DKRES
0; $DKDVN ; $DKNAN ; $DILDN ; $DKRES ;
0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
0;0;0;0;0;0;0;0
0;0;0
]
112532
112532  )MCDEF MDRTB $DKDVN,$DKNAN,$DILDN,$DKRES
20000; $DKDVN ; $DKNAN ; $DILDN ; $DKRES ; 0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;
]
112532
112532  % MACRO FOR BIT FILE BUFFER:
112532  )MCDEF FBFBU $BFLDN
BINDX ; -1; $BFLDN ; 0; *+20/
XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
]
112532
112532
112532
112532  %      MACRO FOR SPOOLING DATAFIELD IN RESIDENT
112532  %
112532  %      $SRT        SPOOLING RT PROGRAM NAME.
112532  %      $SLNR       LOGICAL DEVICE NUMBER OF DEVICE TO WHICH DATA IS SPOOLED.
112532  %      $QSEG       SEGMENT NUMBER WHERE QUEUE IS HELD (= QUEUE NUMBER).
112532  %      $INXX       SPOOLING INDEX
112532  %      $QSEM       QUEUE SEMAPHORE - USED TO LOCK QUEUE.
112532  %      $QIOS       QUEUE I/O SEMAPHORE - USED TO WAIT FOR SOMETHING TO BE INSERTED IN QUEUE.
112532
112532  "CXCPU
112532  )MCDEF SPOOD $SPPR,$SRT,$SLNR,$QSEG,$INXX,$QSEM,$QIOS

$SPPR ,0; SPORT; $SRT ;$SLNR ;$QSEG ;$QSEM ;$QIOS ;0;0;$INXX ;

]
112532  "
112532  "8N500 CXCPU
112532  %********************************************************************
112532  %      M A C R O E S   F O R   N D 5 0 0   S Y S T E M
112532  %
112532  % MACRO TO ALLOCATE A ND500 PROCESS DESCRIPTION FOR VSX
112532
112532  )MCDEF PRSDC
       0;0;*-2;2;0;0;RTBAK;0
X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
]
112532
112532
112532  "
112532  )LINE

112532  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%  S I N 4  -  G E N  %%%%%%%%%%%%%%%%%%%%%%%%%%
112532

112532  %==============================================================================
112532  %            T I M E - S L I C E   T A B L E S
112532  %
112532  "CXCPU
112532  XNOBP=NXRTP
112532  "8XMSG CXCPU
112532  %===========================================================================
112532  %       X M S G   T A B L E S
112532
112532  % DATAFIELD TO LINK INTO MQUEUE FOR STARTING PROGRAMS FROM XMSG
112532  XDFLD, 0;0;XDFLD;0;0;0;XXMEN
112541
112541  % TABLE OF PROGRAMS THAT WILL BE STARTED BY XMSG
112541  XRTDS,0
112542  XRTDS+XNOBP/
113373  "
113373
113373
113373
113373  "CXCPU
113373  %===========================================================================
113373  %       ACCOUNTING TABLES FOR VSX/500
113373  %
113373  %==============================================================================
113373  "8ACC CXCPU
113373  0                 % SAVTT FOR ACCOUNTING READ AND WRITE MEMORY ROUTINES.
113374  ACBAS=*+200       %BASE ACBASE
113374  AC101=*;*+36/     %INTEGER ARRAY BACCO(5ACCO),  % BUFFER FOR ACCOUNTING RECORD. (I.E. BLOCKS FROM ACCOUNTS:DATA).
113432  AC102=*;*+14/     %              BRTPR(5RTPR);  % BUFFER TO READ RTPROJ RECORD
113446                    %
113446                    %DOUBLE  ARRAY DBACC=BACCO;   % USED TO ACCESS BACCO AS A DOUBLE INTEGER ARRAY.
113446                    %
113446  AC001=*;0         %INTEGER FILN1:=0,            % FILE-NUMBER FOR RTPROJ:DATA
113447  AC002=*;0         %        BLOC1:=0,            % BLOCK-NUMBER FOR RTPROJ:DATA
113450  AC003=*;0         %        FILN2:=0,            % FILE-NUMBER FOR ACCOUNTS:DATA
113451  AC004=*;0         %        BLOC2:=0,            % BLOCK-NUMBER FOR ACCOUNTS:DATA
113452                    %
113452                    %        PARA1:=(FILN1,"0",BRTPR,BLOC1,"5RTPR"),           % R/W 1 RTPROJ BLOCK
113452  AC001;(0;AC102;AC002;(14
113457                    %        PARA2:=(FILN2,"0",BACCO,BLOC2,"5ACCO"),           % R/W 1 ACCOUNT BLOCK
113457  AC003;(0;AC101;AC004;(36
113464                    %
113464  0                 %        ACPOI :=0,           % CURRENT ENTRY IN ACTAB
113465  0                 %        ENDAC :=0,           % ADDRESS OF LAST RECORD IN ACTAB.
113466  0                 %        IOPOI :=0,           % CURRENT ENTRY IN IOACT
113467  0                 %        SAERR :=0,           % SAVED ERROR-CODE
113470  0                 %        NMBR  :=0,           % NUMBER OF ACCOUNTING RECORDS IN FILE
113471  0                 %        DMAX  :=0,           % MAX NUMBER OF ACCOUNTS BEFORE A WARNING IS GIVEN
113472  0                 %        RMAX  :=0,           % MAX NUMBER OF ACCOUNTS PERMITTED IN THE FILE.
113473  0                 %        ERRFL :=0,           % ERROR-FLAG :THE ACCOUNTING FILE IS FULL IF = 244
113474  AC005=*;0         %        BUNI  :=0,
113475  0                 %        SEC   :=0,
113476  0                 %        MINUT :=0,
113477  0                 %        HOUR  :=0,
113500  0                 %        DAY   :=0,
113501  0                 %        MNTH  :=0,
113502  0                 %        YEAR  :=0,
113503                    %
113503  AC005             %        TPARA:=(BUNI);
113504                    %ESAB;
113504  )FILL
113507  )KILL AC001 AC002 AC003 AC004 AC005 AC101 AC102
113507  % TABLE FOR CPU-TIME ACCOUNTING FOR RT-PROGRAMS
113507  "
113507

113507  "8N500
113507  %===========================================================================
113507  %      N D 5 0 0   P R O C E S S   D E S C R I PT I O N S
113507  %
113507
113507  %      N D 5 0 0   P R O C E S S   D E S C R I P T I O N S
113507
113507  NN5MS= 0
113507  ACCE5= 0
113507  NU5PR= 0
113507
113507  S500S=*; PRSDC

113507         0;0;*-2;2;0;0;RTBAK;0
113517  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113517  "8PR01; PRSDC

113517         0;0;*-2;2;0;0;RTBAK;0
113527  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113527  "8PR02; PRSDC

113527         0;0;*-2;2;0;0;RTBAK;0
113537  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113537  "8PR03; PRSDC

113537         0;0;*-2;2;0;0;RTBAK;0
113547  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113547  "8PR04; PRSDC

113547         0;0;*-2;2;0;0;RTBAK;0
113557  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113557  "8PR05; PRSDC

113557         0;0;*-2;2;0;0;RTBAK;0
113567  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113567  "8PR06; PRSDC

113567         0;0;*-2;2;0;0;RTBAK;0
113577  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113577  "8PR07; PRSDC

113577         0;0;*-2;2;0;0;RTBAK;0
113607  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113607  "8PR08; PRSDC

113607         0;0;*-2;2;0;0;RTBAK;0
113617  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113617  "8PR09; PRSDC

113617         0;0;*-2;2;0;0;RTBAK;0
113627  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113627  "8PR10; PRSDC

113627         0;0;*-2;2;0;0;RTBAK;0
113637  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113637  "8PR11; PRSDC

113637         0;0;*-2;2;0;0;RTBAK;0
113647  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113647  "8PR12; PRSDC

113647         0;0;*-2;2;0;0;RTBAK;0
113657  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113657  "8PR13; PRSDC

113657         0;0;*-2;2;0;0;RTBAK;0
113667  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113667  "8PR14; PRSDC

113667         0;0;*-2;2;0;0;RTBAK;0
113677  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113677  "8PR15; PRSDC

113677         0;0;*-2;2;0;0;RTBAK;0
113707  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113707  "8PR16; PRSDC

113707         0;0;*-2;2;0;0;RTBAK;0
113717  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113717  "8PR17; PRSDC

113717         0;0;*-2;2;0;0;RTBAK;0
113727  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113727  "8PR18; PRSDC

113727         0;0;*-2;2;0;0;RTBAK;0
113737  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113737  "8PR19; PRSDC

113737         0;0;*-2;2;0;0;RTBAK;0
113747  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113747  "8PR20; PRSDC

113747         0;0;*-2;2;0;0;RTBAK;0
113757  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113757  "8PR21; PRSDC

113757         0;0;*-2;2;0;0;RTBAK;0
113767  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113767  "8PR22; PRSDC

113767         0;0;*-2;2;0;0;RTBAK;0
113777  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
113777  "8PR23; PRSDC

113777         0;0;*-2;2;0;0;RTBAK;0
114007  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114007  "8PR24; PRSDC

114007         0;0;*-2;2;0;0;RTBAK;0
114017  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114017  "8PR25; PRSDC

114017         0;0;*-2;2;0;0;RTBAK;0
114027  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114027  "8PR26; PRSDC

114027         0;0;*-2;2;0;0;RTBAK;0
114037  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114037  "8PR27; PRSDC

114037         0;0;*-2;2;0;0;RTBAK;0
114047  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114047  "8PR28; PRSDC

114047         0;0;*-2;2;0;0;RTBAK;0
114057  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114057  "8PR29; PRSDC

114057         0;0;*-2;2;0;0;RTBAK;0
114067  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114067  "8PR30; PRSDC

114067         0;0;*-2;2;0;0;RTBAK;0
114077  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114077  "8PR31; PRSDC

114077         0;0;*-2;2;0;0;RTBAK;0
114107  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114107  "8PR32; PRSDC

114107         0;0;*-2;2;0;0;RTBAK;0
114117  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114117  "8PR33; PRSDC

114117         0;0;*-2;2;0;0;RTBAK;0
114127  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114127  "8PR34; PRSDC

114127         0;0;*-2;2;0;0;RTBAK;0
114137  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114137  "8PR35; PRSDC

114137         0;0;*-2;2;0;0;RTBAK;0
114147  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114147  "8PR36; PRSDC

114147         0;0;*-2;2;0;0;RTBAK;0
114157  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114157  "8PR37; PRSDC

114157         0;0;*-2;2;0;0;RTBAK;0
114167  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114167  "8PR38; PRSDC

114167         0;0;*-2;2;0;0;RTBAK;0
114177  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114177  "8PR39; PRSDC

114177         0;0;*-2;2;0;0;RTBAK;0
114207  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114207  "8PR40; PRSDC

114207         0;0;*-2;2;0;0;RTBAK;0
114217  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114217  "8PR41; PRSDC

114217         0;0;*-2;2;0;0;RTBAK;0
114227  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114227  "8PR42; PRSDC

114227         0;0;*-2;2;0;0;RTBAK;0
114237  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114237  "8PR43; PRSDC

114237         0;0;*-2;2;0;0;RTBAK;0
114247  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114247  "8PR44; PRSDC

114247         0;0;*-2;2;0;0;RTBAK;0
114257  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114257  "8PR45; PRSDC

114257         0;0;*-2;2;0;0;RTBAK;0
114267  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114267  "8PR46; PRSDC

114267         0;0;*-2;2;0;0;RTBAK;0
114277  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114277  "8PR47; PRSDC

114277         0;0;*-2;2;0;0;RTBAK;0
114307  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114307  "8PR48; PRSDC

114307         0;0;*-2;2;0;0;RTBAK;0
114317  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114317  "8PR49; PRSDC

114317         0;0;*-2;2;0;0;RTBAK;0
114327  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114327  "8PR50; PRSDC

114327         0;0;*-2;2;0;0;RTBAK;0
114337  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114337  "8PR51; PRSDC

114337         0;0;*-2;2;0;0;RTBAK;0
114347  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114347  "8PR52; PRSDC

114347         0;0;*-2;2;0;0;RTBAK;0
114357  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114357  "8PR53; PRSDC

114357         0;0;*-2;2;0;0;RTBAK;0
114367  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114367  "8PR54; PRSDC

114367         0;0;*-2;2;0;0;RTBAK;0
114377  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114377  "8PR55; PRSDC

114377         0;0;*-2;2;0;0;RTBAK;0
114407  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114407  "8PR56; PRSDC

114407         0;0;*-2;2;0;0;RTBAK;0
114417  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114417  "8PR57; PRSDC

114417         0;0;*-2;2;0;0;RTBAK;0
114427  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114427  "8PR58; PRSDC

114427         0;0;*-2;2;0;0;RTBAK;0
114437  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114437  "8PR59; PRSDC

114437         0;0;*-2;2;0;0;RTBAK;0
114447  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114447  "8PR60; PRSDC

114447         0;0;*-2;2;0;0;RTBAK;0
114457  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114457  "8PR61; PRSDC

114457         0;0;*-2;2;0;0;RTBAK;0
114467  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114467  "8PR62; PRSDC

114467         0;0;*-2;2;0;0;RTBAK;0
114477  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114477  "8PR63; PRSDC

114477         0;0;*-2;2;0;0;RTBAK;0
114507  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114507  "8PR64; PRSDC

114507         0;0;*-2;2;0;0;RTBAK;0
114517  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114517  "8PR65
114517  PRSDC

114517         0;0;*-2;2;0;0;RTBAK;0
114527  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114527  "8PR66
114527  PRSDC

114527         0;0;*-2;2;0;0;RTBAK;0
114537  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114537  "8PR67
114537  PRSDC

114537         0;0;*-2;2;0;0;RTBAK;0
114547  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114547  "8PR68
114547  PRSDC

114547         0;0;*-2;2;0;0;RTBAK;0
114557  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114557  "8PR69
114557  PRSDC

114557         0;0;*-2;2;0;0;RTBAK;0
114567  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114567  "8PR70
114567  PRSDC

114567         0;0;*-2;2;0;0;RTBAK;0
114577  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114577  "8PR71
114577  PRSDC

114577         0;0;*-2;2;0;0;RTBAK;0
114607  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114607  "8PR72
114607  PRSDC

114607         0;0;*-2;2;0;0;RTBAK;0
114617  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114617  "8PR73
114617  PRSDC

114617         0;0;*-2;2;0;0;RTBAK;0
114627  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114627  "8PR74
114627  PRSDC

114627         0;0;*-2;2;0;0;RTBAK;0
114637  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114637  "8PR75
114637  PRSDC

114637         0;0;*-2;2;0;0;RTBAK;0
114647  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114647  "8PR76
114647  PRSDC

114647         0;0;*-2;2;0;0;RTBAK;0
114657  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114657  "8PR77
114657  PRSDC

114657         0;0;*-2;2;0;0;RTBAK;0
114667  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114667  "8PR78
114667  PRSDC

114667         0;0;*-2;2;0;0;RTBAK;0
114677  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114677  "8PR79
114677  PRSDC

114677         0;0;*-2;2;0;0;RTBAK;0
114707  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114707  "8PR80
114707  PRSDC

114707         0;0;*-2;2;0;0;RTBAK;0
114717  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114717  "8PR81
114717  PRSDC

114717         0;0;*-2;2;0;0;RTBAK;0
114727  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114727  "8PR82
114727  PRSDC

114727         0;0;*-2;2;0;0;RTBAK;0
114737  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114737  "8PR83
114737  PRSDC

114737         0;0;*-2;2;0;0;RTBAK;0
114747  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114747  "8PR84
114747  PRSDC

114747         0;0;*-2;2;0;0;RTBAK;0
114757  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114757  "8PR85
114757  PRSDC

114757         0;0;*-2;2;0;0;RTBAK;0
114767  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114767  "8PR86
114767  PRSDC

114767         0;0;*-2;2;0;0;RTBAK;0
114777  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
114777  "8PR87
114777  PRSDC

114777         0;0;*-2;2;0;0;RTBAK;0
115007  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115007  "8PR88
115007  PRSDC

115007         0;0;*-2;2;0;0;RTBAK;0
115017  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115017  "8PR89
115017  PRSDC

115017         0;0;*-2;2;0;0;RTBAK;0
115027  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115027  "8PR90
115027  PRSDC

115027         0;0;*-2;2;0;0;RTBAK;0
115037  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115037  "8PR91
115037  PRSDC

115037         0;0;*-2;2;0;0;RTBAK;0
115047  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115047  "8PR92
115047  PRSDC

115047         0;0;*-2;2;0;0;RTBAK;0
115057  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115057  "8PR93
115057  PRSDC

115057         0;0;*-2;2;0;0;RTBAK;0
115067  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115067  "8PR94
115067  PRSDC

115067         0;0;*-2;2;0;0;RTBAK;0
115077  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115077  "8PR95
115077  PRSDC

115077         0;0;*-2;2;0;0;RTBAK;0
115107  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115107  "8PR96
115107  PRSDC

115107         0;0;*-2;2;0;0;RTBAK;0
115117  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115117  "8PR97
115117  PRSDC

115117         0;0;*-2;2;0;0;RTBAK;0
115127  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115127  "8PR98
115127  PRSDC

115127         0;0;*-2;2;0;0;RTBAK;0
115137  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115137  "8PR99
115137  PRSDC

115137         0;0;*-2;2;0;0;RTBAK;0
115147  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115147  "8P100
115147  PRSDC

115147         0;0;*-2;2;0;0;RTBAK;0
115157  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115157  "8P101
115157  PRSDC

115157         0;0;*-2;2;0;0;RTBAK;0
115167  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115167  "8P102
115167  PRSDC

115167         0;0;*-2;2;0;0;RTBAK;0
115177  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115177  "8P103
115177  PRSDC

115177         0;0;*-2;2;0;0;RTBAK;0
115207  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115207  "8P104
115207  PRSDC

115207         0;0;*-2;2;0;0;RTBAK;0
115217  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115217  "8P105
115217  PRSDC

115217         0;0;*-2;2;0;0;RTBAK;0
115227  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115227  "8P106
115227  PRSDC

115227         0;0;*-2;2;0;0;RTBAK;0
115237  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115237  "8P107
115237  PRSDC

115237         0;0;*-2;2;0;0;RTBAK;0
115247  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115247  "8P108
115247  PRSDC

115247         0;0;*-2;2;0;0;RTBAK;0
115257  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115257  "8P109
115257  PRSDC

115257         0;0;*-2;2;0;0;RTBAK;0
115267  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115267  "8P110
115267  PRSDC

115267         0;0;*-2;2;0;0;RTBAK;0
115277  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115277  "8P111
115277  PRSDC

115277         0;0;*-2;2;0;0;RTBAK;0
115307  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115307  "8P112
115307  PRSDC

115307         0;0;*-2;2;0;0;RTBAK;0
115317  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115317  "8P113
115317  PRSDC

115317         0;0;*-2;2;0;0;RTBAK;0
115327  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115327  "8P114
115327  PRSDC

115327         0;0;*-2;2;0;0;RTBAK;0
115337  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115337  "8P115
115337  PRSDC

115337         0;0;*-2;2;0;0;RTBAK;0
115347  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115347  "8P116
115347  PRSDC

115347         0;0;*-2;2;0;0;RTBAK;0
115357  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115357  "8P117
115357  PRSDC

115357         0;0;*-2;2;0;0;RTBAK;0
115367  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115367  "8P118
115367  PRSDC

115367         0;0;*-2;2;0;0;RTBAK;0
115377  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115377  "8P119
115377  PRSDC

115377         0;0;*-2;2;0;0;RTBAK;0
115407  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115407  "8P120
115407  PRSDC

115407         0;0;*-2;2;0;0;RTBAK;0
115417  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115417  "8P121
115417  PRSDC

115417         0;0;*-2;2;0;0;RTBAK;0
115427  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115427  "8P122
115427  PRSDC

115427         0;0;*-2;2;0;0;RTBAK;0
115437  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115437  "8P123
115437  PRSDC

115437         0;0;*-2;2;0;0;RTBAK;0
115447  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115447  "8P124
115447  PRSDC

115447         0;0;*-2;2;0;0;RTBAK;0
115457  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115457  "8P125
115457  PRSDC

115457         0;0;*-2;2;0;0;RTBAK;0
115467  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115467  "8P126
115467  PRSDC

115467         0;0;*-2;2;0;0;RTBAK;0
115477  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115477  "8P127
115477  PRSDC

115477         0;0;*-2;2;0;0;RTBAK;0
115507  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115507  "8P128
115507  PRSDC

115507         0;0;*-2;2;0;0;RTBAK;0
115517  X5=NU5PR+1; )KILL NU5PR; NU5PR=X5; )KILL X5
115517  "8N500
115517  S500E=*
115517  "
115517
115517  %==============================================================================
115517  % 29.7       R T C O M M O N  T A B L E S
115517  %
115517  CCNOX,CCNO                   % NUMBER OF PAGES IN RTCOMMON
115520  CCSTA=*;0                    % FIRST PHYSICAL PAGE IN RT-COMMON WHEN IT IS CONTIGUOUS
115521  CCTAB=*
115521  *+CCNO+CCNO+20/              % RTCOMMON PIT ENTRY
115555  -1
115556  "CXCPU
115556  %=========================================================================
115556  %
115556  IRTCP, 0             % PNUMB*2+IRTCPIT=ADDR OF PROTECT AND PHYSICAL PAGE
115557                       % OF RT-COMMON ENTRY (TO BE SET INTO PIT)
115557                       % I.E. ADDR IN XCCTA
115557  XCCTA=*; *+CCNO+CCNO+20/
115613
115613  "
115613  %==============================================================================
115613  % 29.8       I O X  T A B L E
115613  %
115613  % IOX-ADDRESS CHECK TABLE
115613  IOXTA=*
115613  *+8IOXT/
115623  EIOXT, -1                    % END OF IOX-TABLE
115624
115624

115624  %==============================================================================
115624  % 29.9       F I L E S Y S T E M   D E F I N I T I O N S
115624  %
115624
115624
115624  % OPEN FILE NUMBER TABLE AND BUFFER POOL DEFINITIONS:
115624
115624  FMAX 5NPOO                   % TO UNDEFINE FMAX AND 5NPOO IF NOT DEFINED
115625
115625
115625
115625  S000,  0
115626  SDUMM, DUMMY
115627  S504=504
115627  S505=505
115627  S506=506
115627  S507=507
115627  S511=511
115627  S512=512
115627  S513=513
115627  S514=514
115627  S521=521
115627  S522=522
115627  S523=523
115627  S524=524
115627  S525=525
115627  S554=554
115627  S555=555
115627  S556=556
115627  S557=557
115627  S40D,  (40
115630         S000;SDUMM
115632  S561=561
115632  S41D,  (41
115633         S000;SDUMM
115635  S25D,  (25
115636         S000;SDUMM
115640  S570=570
115640  S571=571
115640  S572=572
115640  S573=573
115640  MOLDS=516
115640  S516=MOLDS
115640  )FILL
115643
115643  S1101=1101
115643  S1102=1102
115643  S1105=1105
115643  S1106=1106
115643  S1107=1107
115643  S1110=1110
115643  S1112=1112
115643  S1114=1114
115643  S1117=1117
115643  S1120=1120
115643  S1121=1121
115643  S1122=1122
115643  S1123=1123
115643  S1124=1124
115643  S1127=1127
115643  S1130=1130
115643  S1131=1131
115643  S1132=1132
115643  S1133=1133
115643  S1134=1134
115643  S1135=1135
115643  S1142=1142
115643  S1147=1147
115643  S1150=1150
115643  S1151=1151
115643  S1152=1152
115643  S1153=1153
115643  S1154=1154
115643  S1155=1155
115643  S1160=1160
115643  S1161=1161
115643  S1162=1162
115643  S1163=1163
115643  S1164=1164
115643  S1165=1165
115643  S1166=1166
115643  S1225=1225                   %
115643  S1226=1226                   %
115643  S1227=1227                   %
115643  S1230=1230                   % SATELLITE DIRECTORY AND BIT FILE BUFFER LOCKS
115643  S1232=1232                   %  (I.E. FINCH DISK)
115643  S1233=1233                   %
115643  S1234=1234                   %
115643  S1235=1235                   %
115643
115643  S32D,  (32
115644         S000;SDUMM
115646  SX7D,  (1113
115647         S000;SDUMM
115651  S34D,  (34
115652         S000;SDUMM
115654  SX8D,  (1115
115655         S000;SDUMM
115657  )FILL
115663  S563D, (563
115664         S000;SDUMM
115666  S564D, (564
115667         S000;SDUMM
115671
115671  S33D,  (33
115672         S000;SDUMM
115674  )FILL
115677
115677  SX1D,  (1000
115700         S000;SDUMM
115702  SX2D,  (1001
115703         S000;SDUMM
115705  SX3D,  (1002
115706         S000;SDUMM
115710  SX4D,  (1003
115711         S000;SDUMM
115713  SX5D,  (1004
115714         S000;SDUMM
115716  SX6D,  (1005
115717         S000;SDUMM
115721  )FILL
115727  D1232, (1232
115730         S000;SDUMM
115732  D1233, (1233
115733         S000;SDUMM
115735  D1234, (1234
115736         S000;SDUMM
115740  D1235, (1235
115741         S000;SDUMM
115743  )FILL
115747  D1225, (1225
115750         S000;SDUMM
115752  D1226, (1226
115753         S000;SDUMM
115755  D1227, (1227
115756         S000;SDUMM
115760  D1230, (1230
115761         S000;SDUMM
115763  )FILL
115767
115767  S1171=1171
115767  S1172=1172
115767  S1177=1177
115767  S1300=1300
115767  S1301=1301
115767  S1333=1333
115767  S1334=1334
115767  S1335=1335
115767  S1336=1336
115767  S1337=1337
115767  S1340=1340
115767  S1341=1341
115767  S1342=1342
115767  % *** VIRTUAL DISK DRIVER LDNs
115767  VDD01=1716
115767  VDD02=1717
115767  VDD03=1720
115767  VDD04=1721
115767  % ***
115767  %      SYMBOL DEFINITIONS FOR MICROPOLIS 5 1/4 INCH WINCHESTER DISK.
115767  S1732=1732
115767  S1733=1733
115767  S1734=1734
115767  S1735=1735
115767  S1737=1737
115767  S1740=1740
115767  S1741=1741
115767  S1742=1742
115767  S1743=1743
115767  S1744=1744
115767  S1745=1745
115767  S1746=1746
115767  S1747=1747
115767  S1750=1750
115767  S1751=1751
115767  S1752=1752
115767  %
115767  SLDN,  S1142
115770  WSLDN, 1142
115771  WULDN, 1143
115772  WFLDN, 1144
115773  FDFSE, 1177
115774  )FILL
115774
115774  GLDN,  S504                  % GENERAL LOCK FOR FILE SYSTEM
115775  MOLDN, 516                   % 0PEN - CLOSE MONITOR CALL PROGRAM LOCK
115776  ULDN=  S505                  % USER FILE BUFFER LOCK
115776  OLDN=  S506                  % OBJECT FILE BUFFER LOCK
115776  OFLDN= S507                  % RT-OPEN-FILE-TABLE LOCK
115776  BLDN,  S521                  % GET DEVICE BUFFER LOCK
115777
115777
115777
115777

115777  %==============================================================================
115777  % 29.10      D E V I C E  B U F F E R S
115777  %
115777  ENDBU, XENDB              % ADDRESS OF END OF DEVICE BUFFERS
116000
116000  % SPECIAL DEVICE BUFFER FOR DIRECT TRANSFER:
116000  5BUFA=0
116000  DTHEA=*
116000  FDVBU 0

116000  F0, 0 ; 0 ; *-2 ; 2
116004  -1 ; -1 ; -1 ; 0; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116025  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116025
116025
116025  DEVBU=*
116025
116025  )KILL 5BUFA
116025  5BUFA=0
116025  "8BU0+8BU1+8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
116025  FDVBU 1600

116025  F1600, 0 ; 0 ; *-2 ; 2
116031  -1 ; -1 ; -1 ; 1600; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116052  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116052
116052  "8BU1+8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
116052  FDVBU 1601

116052  F1601, 0 ; 0 ; *-2 ; 2
116056  -1 ; -1 ; -1 ; 1601; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116077  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116077
116077  "8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
116077  FDVBU 1602

116077  F1602, 0 ; 0 ; *-2 ; 2
116103  -1 ; -1 ; -1 ; 1602; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116124  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116124
116124  "8BU3+8BU4+8BU5+8BU6+8BU7
116124  FDVBU 1603

116124  F1603, 0 ; 0 ; *-2 ; 2
116130  -1 ; -1 ; -1 ; 1603; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116151  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116151
116151  "8BU4+8BU5+8BU6+8BU7
116151  FDVBU 1604

116151  F1604, 0 ; 0 ; *-2 ; 2
116155  -1 ; -1 ; -1 ; 1604; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116176  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116176
116176  "8BU5+8BU6+8BU7
116176  FDVBU 1605

116176  F1605, 0 ; 0 ; *-2 ; 2
116202  -1 ; -1 ; -1 ; 1605; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116223  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116223
116223  "8BU6+8BU7
116223  FDVBU 1606

116223  F1606, 0 ; 0 ; *-2 ; 2
116227  -1 ; -1 ; -1 ; 1606; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116250  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116250
116250  "8BU7
116250  FDVBU 1607

116250  F1607, 0 ; 0 ; *-2 ; 2
116254  -1 ; -1 ; -1 ; 1607; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116275  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116275
116275  %
116275  "8BU10+8BU20+8BU30+8BU40+8BU50+8BU60+8BU70
116275  FDVBU 1610

116275  F1610, 0 ; 0 ; *-2 ; 2
116301  -1 ; -1 ; -1 ; 1610; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116322  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116322
116322  FDVBU 1611

116322  F1611, 0 ; 0 ; *-2 ; 2
116326  -1 ; -1 ; -1 ; 1611; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116347  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116347
116347  FDVBU 1612

116347  F1612, 0 ; 0 ; *-2 ; 2
116353  -1 ; -1 ; -1 ; 1612; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116374  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116374
116374  FDVBU 1613

116374  F1613, 0 ; 0 ; *-2 ; 2
116400  -1 ; -1 ; -1 ; 1613; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116421  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116421
116421  FDVBU 1614

116421  F1614, 0 ; 0 ; *-2 ; 2
116425  -1 ; -1 ; -1 ; 1614; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116446  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116446
116446  FDVBU 1615

116446  F1615, 0 ; 0 ; *-2 ; 2
116452  -1 ; -1 ; -1 ; 1615; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116473  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116473
116473  FDVBU 1616

116473  F1616, 0 ; 0 ; *-2 ; 2
116477  -1 ; -1 ; -1 ; 1616; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116520  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116520
116520  FDVBU 1617

116520  F1617, 0 ; 0 ; *-2 ; 2
116524  -1 ; -1 ; -1 ; 1617; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116545  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116545
116545  "8BU20+8BU30+8BU40+8BU50+8BU60+8BU70
116545  FDVBU 1620

116545  F1620, 0 ; 0 ; *-2 ; 2
116551  -1 ; -1 ; -1 ; 1620; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116572  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116572
116572  FDVBU 1621

116572  F1621, 0 ; 0 ; *-2 ; 2
116576  -1 ; -1 ; -1 ; 1621; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116617  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116617
116617  FDVBU 1622

116617  F1622, 0 ; 0 ; *-2 ; 2
116623  -1 ; -1 ; -1 ; 1622; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116644  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116644
116644  FDVBU 1623

116644  F1623, 0 ; 0 ; *-2 ; 2
116650  -1 ; -1 ; -1 ; 1623; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116671  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116671
116671  FDVBU 1624

116671  F1624, 0 ; 0 ; *-2 ; 2
116675  -1 ; -1 ; -1 ; 1624; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116716  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116716
116716  FDVBU 1625

116716  F1625, 0 ; 0 ; *-2 ; 2
116722  -1 ; -1 ; -1 ; 1625; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116743  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116743
116743  FDVBU 1626

116743  F1626, 0 ; 0 ; *-2 ; 2
116747  -1 ; -1 ; -1 ; 1626; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
116770  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
116770
116770  FDVBU 1627

116770  F1627, 0 ; 0 ; *-2 ; 2
116774  -1 ; -1 ; -1 ; 1627; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117015  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117015
117015  "8BU30+8BU40+8BU50+8BU60+8BU70
117015  FDVBU 1630

117015  F1630, 0 ; 0 ; *-2 ; 2
117021  -1 ; -1 ; -1 ; 1630; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117042  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117042
117042  FDVBU 1631

117042  F1631, 0 ; 0 ; *-2 ; 2
117046  -1 ; -1 ; -1 ; 1631; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117067  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117067
117067  FDVBU 1632

117067  F1632, 0 ; 0 ; *-2 ; 2
117073  -1 ; -1 ; -1 ; 1632; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117114  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117114
117114  FDVBU 1633

117114  F1633, 0 ; 0 ; *-2 ; 2
117120  -1 ; -1 ; -1 ; 1633; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117141  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117141
117141  FDVBU 1634

117141  F1634, 0 ; 0 ; *-2 ; 2
117145  -1 ; -1 ; -1 ; 1634; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117166  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117166
117166  FDVBU 1635

117166  F1635, 0 ; 0 ; *-2 ; 2
117172  -1 ; -1 ; -1 ; 1635; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117213  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117213
117213  FDVBU 1636

117213  F1636, 0 ; 0 ; *-2 ; 2
117217  -1 ; -1 ; -1 ; 1636; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117240  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117240
117240  FDVBU 1637

117240  F1637, 0 ; 0 ; *-2 ; 2
117244  -1 ; -1 ; -1 ; 1637; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117265  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117265
117265  "8BU40+8BU50+8BU60+8BU70
117265  FDVBU 1640

117265  F1640, 0 ; 0 ; *-2 ; 2
117271  -1 ; -1 ; -1 ; 1640; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117312  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117312
117312  FDVBU 1641

117312  F1641, 0 ; 0 ; *-2 ; 2
117316  -1 ; -1 ; -1 ; 1641; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117337  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117337
117337  FDVBU 1642

117337  F1642, 0 ; 0 ; *-2 ; 2
117343  -1 ; -1 ; -1 ; 1642; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117364  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117364
117364  FDVBU 1643

117364  F1643, 0 ; 0 ; *-2 ; 2
117370  -1 ; -1 ; -1 ; 1643; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117411  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117411
117411  FDVBU 1644

117411  F1644, 0 ; 0 ; *-2 ; 2
117415  -1 ; -1 ; -1 ; 1644; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117436  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117436
117436  FDVBU 1645

117436  F1645, 0 ; 0 ; *-2 ; 2
117442  -1 ; -1 ; -1 ; 1645; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117463  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117463
117463  FDVBU 1646

117463  F1646, 0 ; 0 ; *-2 ; 2
117467  -1 ; -1 ; -1 ; 1646; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117510  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117510
117510  FDVBU 1647

117510  F1647, 0 ; 0 ; *-2 ; 2
117514  -1 ; -1 ; -1 ; 1647; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117535  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117535
117535  "8BU50+8BU60+8BU70
117535  FDVBU 1650

117535  F1650, 0 ; 0 ; *-2 ; 2
117541  -1 ; -1 ; -1 ; 1650; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117562  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117562
117562  FDVBU 1651

117562  F1651, 0 ; 0 ; *-2 ; 2
117566  -1 ; -1 ; -1 ; 1651; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117607  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117607
117607  FDVBU 1652

117607  F1652, 0 ; 0 ; *-2 ; 2
117613  -1 ; -1 ; -1 ; 1652; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117634  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117634
117634  FDVBU 1653

117634  F1653, 0 ; 0 ; *-2 ; 2
117640  -1 ; -1 ; -1 ; 1653; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117661  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117661
117661  FDVBU 1654

117661  F1654, 0 ; 0 ; *-2 ; 2
117665  -1 ; -1 ; -1 ; 1654; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117706  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117706
117706  FDVBU 1655

117706  F1655, 0 ; 0 ; *-2 ; 2
117712  -1 ; -1 ; -1 ; 1655; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117733  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117733
117733  FDVBU 1656

117733  F1656, 0 ; 0 ; *-2 ; 2
117737  -1 ; -1 ; -1 ; 1656; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
117760  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
117760
117760  FDVBU 1657

117760  F1657, 0 ; 0 ; *-2 ; 2
117764  -1 ; -1 ; -1 ; 1657; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120005  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120005
120005  "8BU60+8BU70
120005  FDVBU 1660

120005  F1660, 0 ; 0 ; *-2 ; 2
120011  -1 ; -1 ; -1 ; 1660; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120032  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120032
120032  FDVBU 1661

120032  F1661, 0 ; 0 ; *-2 ; 2
120036  -1 ; -1 ; -1 ; 1661; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120057  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120057
120057  FDVBU 1662

120057  F1662, 0 ; 0 ; *-2 ; 2
120063  -1 ; -1 ; -1 ; 1662; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120104  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120104
120104  FDVBU 1663

120104  F1663, 0 ; 0 ; *-2 ; 2
120110  -1 ; -1 ; -1 ; 1663; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120131  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120131
120131  FDVBU 1664

120131  F1664, 0 ; 0 ; *-2 ; 2
120135  -1 ; -1 ; -1 ; 1664; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120156  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120156
120156  FDVBU 1665

120156  F1665, 0 ; 0 ; *-2 ; 2
120162  -1 ; -1 ; -1 ; 1665; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120203  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120203
120203  FDVBU 1666

120203  F1666, 0 ; 0 ; *-2 ; 2
120207  -1 ; -1 ; -1 ; 1666; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120230  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120230
120230  FDVBU 1667

120230  F1667, 0 ; 0 ; *-2 ; 2
120234  -1 ; -1 ; -1 ; 1667; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120255  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120255
120255  "8BU70
120255  FDVBU 1670

120255  F1670, 0 ; 0 ; *-2 ; 2
120261  -1 ; -1 ; -1 ; 1670; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120302  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120302
120302  FDVBU 1671

120302  F1671, 0 ; 0 ; *-2 ; 2
120306  -1 ; -1 ; -1 ; 1671; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120327  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120327
120327  FDVBU 1672

120327  F1672, 0 ; 0 ; *-2 ; 2
120333  -1 ; -1 ; -1 ; 1672; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120354  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120354
120354  FDVBU 1673

120354  F1673, 0 ; 0 ; *-2 ; 2
120360  -1 ; -1 ; -1 ; 1673; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120401  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120401
120401  FDVBU 1674

120401  F1674, 0 ; 0 ; *-2 ; 2
120405  -1 ; -1 ; -1 ; 1674; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120426  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120426
120426  FDVBU 1675

120426  F1675, 0 ; 0 ; *-2 ; 2
120432  -1 ; -1 ; -1 ; 1675; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120453  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120453
120453  FDVBU 1676

120453  F1676, 0 ; 0 ; *-2 ; 2
120457  -1 ; -1 ; -1 ; 1676; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120500  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120500
120500  FDVBU 1677

120500  F1677, 0 ; 0 ; *-2 ; 2
120504  -1 ; -1 ; -1 ; 1677; 0 ; 0 ; 0 ; 0 ; 0 ; 0 ; *-1 ; *-7 ; *-5 ; *-7 ; 0 ; 0 ; 0
120525  XBU=5BUFA+1;)KILL 5BUFA; 5BUFA=XBU; )KILL XBU
120525
120525  "
120525  XENDB=*
120525
120525  "
120525
120525  %==============================================================================
120525  % 29.11      S P O O L I N G  D A T A F I E L D S
120525  %
120525  % SPOOLING DATAFIELDS
120525
120525  ENEN,  1
120526  SPTAB=*+1
120526  "SLP1
120526  SPOOD SPPR1,SPRT1,SLD1,SPSG1,1,1136,1137

120526
120526  SPPR1,0; SPORT; SPRT1;SLD1;SPSG1;1136;1137;0;0;1;
120540
120540
120540  "SLP2
120540  SPOOD SPPR2,SPRT2,SLD2,SPSG2,2,1140,1141

120540
120540  SPPR2,0; SPORT; SPRT2;SLD2;SPSG2;1140;1141;0;0;2;
120552
120552
120552  "SLP3
120552  SPOOD SPPR3,SPRT3,SLD3,SPSG3,3,1173,1174

120552
120552  SPPR3,0; SPORT; SPRT3;SLD3;SPSG3;1173;1174;0;0;3;
120564
120564
120564  "SLP4
120564  SPOOD SPPR4,SPRT4,SLD4,SPSG4,4,532,533

120564
120564  SPPR4,0; SPORT; SPRT4;SLD4;SPSG4;532;533;0;0;4;
120576
120576
120576  "SLP5
120576  SPOOD SPPR5,SPRT5,SLD5,SPSG5,5,534,535

120576
120576  SPPR5,0; SPORT; SPRT5;SLD5;SPSG5;534;535;0;0;5;
120610
120610
120610  "SLP6
120610  SPOOD SPPR6,SPRT6,SLD6,SPSG6,6,536,537

120610
120610  SPPR6,0; SPORT; SPRT6;SLD6;SPSG6;536;537;0;0;6;
120622
120622
120622  "SLP7
120622  SPOOD SPPR7,SPRT7,SLD7,SPSG7,7,1262,1263

120622
120622  SPPR7,0; SPORT; SPRT7;SLD7;SPSG7;1262;1263;0;0;7;
120634
120634
120634  "SLP8
120634  SPOOD SPPR8,SPRT8,SLD8,SPSG8,10,1264,1265

120634
120634  SPPR8,0; SPORT; SPRT8;SLD8;SPSG8;1264;1265;0;0;10;
120646
120646
120646  "SLP9
120646  SPOOD SPPR9,SPRT9,SLD9,SPSG9,11,1266,1267

120646
120646  SPPR9,0; SPORT; SPRT9;SLD9;SPSG9;1266;1267;0;0;11;
120660
120660
120660  "SLP10
120660  SPOOD SPPR10,SPR10,SLD10,SPS10,12,1270,1271

120660
120660  SPPR10,0; SPORT; SPR10;SLD10;SPS10;1270;1271;0;0;12;
120672
120672
120672  "SLP11
120672  SPOOD SPPR11,SPR11,SLD11,SPS11,13,562,1347

120672
120672  SPPR11,0; SPORT; SPR11;SLD11;SPS11;562;1347;0;0;13;
120704
120704
120704  "SLP12
120704  SPOOD SPPR12,SPR12,SLD12,SPS12,14,1350,1351

120704
120704  SPPR12,0; SPORT; SPR12;SLD12;SPS12;1350;1351;0;0;14;
120716
120716
120716  "SLP13
120716  SPOOD SPPR13,SPR13,SLD13,SPS13,15,1722,1723

120716
120716  SPPR13,0; SPORT; SPR13;SLD13;SPS13;1722;1723;0;0;15;
120730
120730
120730  "SLP14
120730  SPOOD SPPR14,SPR14,SLD14,SPS14,16,1724,1725

120730
120730  SPPR14,0; SPORT; SPR14;SLD14;SPS14;1724;1725;0;0;16;
120742
120742
120742  "SLP15
120742  SPOOD SPPR15,SPR15,SLD15,SPS15,17,1726,1727

120742
120742  SPPR15,0; SPORT; SPR15;SLD15;SPS15;1726;1727;0;0;17;
120754
120754
120754  "SLP16
120754  SPOOD SPPR16,SPR16,SLD16,SPS16,20,2130,2131

120754
120754  SPPR16,0; SPORT; SPR16;SLD16;SPS16;2130;2131;0;0;20;
120766
120766
120766  "SLP17
120766  SPOOD SPPR17,SPR17,SLD17,SPS17,21,2132,2133

120766
120766  SPPR17,0; SPORT; SPR17;SLD17;SPS17;2132;2133;0;0;21;
121000
121000
121000  "SLP18
121000  SPOOD SPPR18,SPR18,SLD18,SPS18,22,2134,2135

121000
121000  SPPR18,0; SPORT; SPR18;SLD18;SPS18;2134;2135;0;0;22;
121012
121012
121012  "SLP19
121012  SPOOD SPPR19,SPR19,SLD19,SPS19,23,2136,2137

121012
121012  SPPR19,0; SPORT; SPR19;SLD19;SPS19;2136;2137;0;0;23;
121024
121024
121024  "SLP20
121024  SPOOD SPPR20,SPR20,SLD20,SPS20,24,2140,2141

121024
121024  SPPR20,0; SPORT; SPR20;SLD20;SPS20;2140;2141;0;0;24;
121036
121036
121036  "SLP21
121036  SPOOD SPPR21,SPR21,SLD21,SPS21,25,2142,2143

121036
121036  SPPR21,0; SPORT; SPR21;SLD21;SPS21;2142;2143;0;0;25;
121050
121050
121050  "SLP22
121050  SPOOD SPPR22,SPR22,SLD22,SPS22,26,2144,2145

121050
121050  SPPR22,0; SPORT; SPR22;SLD22;SPS22;2144;2145;0;0;26;
121062
121062
121062  "8COSP CXCPU
121062  COSDA, 0;0;COSPO;1731;COSEG;2166;2167;0;0;37
121074
121074  "
121074  ENDSP=*+1
121074
121074  "SLP1+SLP2+CSP12+SLP3+SLP4+SLP5+SLP6+SLP7+SLP8+SLP9+SLP10+SLP11+SLP12+SLP13+SLP14+SLP15+SLP16+SLP17+SLP18+SLP19+SLP20+SLP21+SLP22+SLP23+SLP24+SLP25+SLP26+SLP27+SLP28+SLP29+SLP30+8COSP -CXCPU

121074  %
121074
121074  "8RFAC
121074  %  ============================================================================
121074  %                  REMOTE FILE ACCESS SEGMENT RESERVATION TABLE:
121074  RFSGN, DSSNM          % SEGMENT NUMBER OF FIRST DATA SEGMENT
121075  TEMP=0
121075  "8SG50; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG49; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG48; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG47; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG46; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG45; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG44; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG43; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG42; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG41; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG40; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG39; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG38; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG37; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG36; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG35; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG34; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG33; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG32; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG31; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG30; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG29; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG28; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG27; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG26; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG25; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG24; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG23; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG22; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG21; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG20; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG19; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG18; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG17; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG16; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG15; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG14; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG13; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG12; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG11; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG10; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG09; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG08; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG07; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG06; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG05; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG04; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG03; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8SG02; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  "8RFAC; XYS=TEMP; )KILL TEMP; TEMP=XYS+1; )KILL XYS;
121075  NRFSG, TEMP
121076  RFSTB=*
121076  * TEMP/
121160  )KILL TEMP
121160  "
121160  )LINE

121160  %%%%%%%%%%%%%%%%%%%%%%%%%   B U F F E R S   %%%%%%%%%%%%%%%%%%%%%%%%%%%%
121160  %=======================================================================
121160  %      LINE-PRINTER AND/OR VERSATEC BUFFERS
121160  %
121160  "8DLP1+8DVE1
121160  LP1BU=*; *+200/
121360  "8DLP2+8DVE2
121360  LP2BU=*; *+200/
121560  "
121560
121560
121560
121560  )LINE
%===================================================================================
121560  %       O C T O B U S   D A T A F I E L D S    M A C R O   D E F E N I T I O N S
121560  %===================================================================================
121560
121560
121560  )MCDEF OCNTR $CTN,$HNO,$SBMX
%=======================================================================================
%      O C T O B U S   C O N T R O L L E R   NUMBER-$CTN   I N P U T   D A T A F I E L D
%
        0                            % BANK NO OF IDENT ENTRIES
        KICK$CTN                         % POINTER TO TABLE OF KICK ENTRIES
        OMDE$CTN                         % POINTER TO TABLE OF OMD ENTRIES (LAST PART)
        OMDT$CTN                         % POINTER TO TABLE OF OMD DATAFIELD ADDRESSES
        MBSO$CTN                         % TABLE OF STATIONS RECEIVING MULTIBYTE
        SOUI$CTN                         % POINTER TO TABLE OF IDENT ENTRIES
        OCITI; -2; -10               % TIMEOUT SUBROUTINE AND COUNTERS
        $HNO ; SOCTO; IOCTO         % IOX, STDRIV, DRIVER
IOCT$CTN ,  000001; 0                    % RECEIVE CONTROL WORD AND STATUS
        0;0;0;0;0;0                  % STATUS AND ERROR COUNTS

%=======================================================================================
%      O C T O B U S   C O N T R O L L E R   NUMBER-$CTN   O U T P U T   D A T A F I E L D
%
       0;0;0                         % TRMODUS, TRFRAME, TROMD
       SBBU$CTN ;$SBMX ; 0;0                % SBBUFF, SBMAX, SBGETP, SBPUTP
       1                             % EMPTFLAG
       OCOTI; -3; -3;                % TIMEOUT SUBROUTINE AND COUNTERS
       $HNO +4; SOCTW; SOCTW        % IOX, STDRIV, DRIVER
OOCT$CTN ,  000005; 0                    % TRANSMITT CONTROL WORD AND STATUS
       0;0;0;0                       % MULTIBYTE MESSAGE VARIABLES


%-----------------------------------------------------------------------------------------------
%  ADDRESS TO KICK ENTRIES
%
KICK$CTN ,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0


%-----------------------------------------------------------------------------------------------
%  ADDRESS TO OMD ENTRIES (LAST PART)
%
OMDE$CTN ,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0


%-----------------------------------------------------------------------------------------------
%  ADDRESS TO OMD DATAFIELDS
%
OMDT$CTN ,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0


%-----------------------------------------------------------------------------------------------
%  MULTIBYTE MESSAGE SOURCE STATION TABLE
%
MBSO$CTN ,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
        0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0

%-----------------------------------------------------------------------------------------------
%  IDENT TABLE
%
SOUI$CTN ,  0;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;20;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5
        5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5

%-----------------------------------------------------------------------------------------------
%  SINGLE BYTE MESSAGE OUTPUT BUFFER

SBBU$CTN , *+$SBMX /
]
121560
121560
121560  %==============================================================================
121560  )MCDEF OMDNU $CTN,$CHN,$ONO,$SBMX
%==============================================================================
%       OCTOBUS MESSAGE DEVICE NUMBER: $CHN

        4;0;0;0;0;0                       % VARIOUS COUNTERS
        0;0                               % MBMRE,MBSLRE
        IOCT$CTN ;OOCT$CTN ;$ONO
OM$CTN $CHN ,  0;0;*-2
         2;0;0;IORES

%-----------------------------------------------------------------------------------------------
%  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
)KILL XXX
XXX=*
OMDT$CTN +$CHN /OM$CTN $CHN
XXX/
)KILL XXX
]
121560
121560  %==============================================================================
121560  )MCDEF LEVDF $LEV
%==============================================================================
%       OCTOBUS LEVEL LINK DATAFIELD FOR LEVEL 10, 11 AND 12.

OCD$LEV ,  0                      % NOT USED
           0                   % NOT USED
           -1                  % LEVLINK
           0                   % BANK NO OF OCTOBUS TABLES
           0                   % BREGQ
           0                   % NLINK
           AOC$LEV                % NFUNC
]
121560
121560  )LINE
%=================================================================================================
121560  %  (D)  FILE: DP-P2-OCTOBUS:MAC
121560  %
121560  %       O C T O B U S   D A T A F I E L D S
121560  %
121560  %=================================================================================================
121560  OCNTR 0,100400,100

121560  %=======================================================================================
121560  %      O C T O B U S   C O N T R O L L E R   NUMBER-0  I N P U T   D A T A F I E L D
121560  %
121560          0                            % BANK NO OF IDENT ENTRIES
121561          KICK0                        % POINTER TO TABLE OF KICK ENTRIES
121562          OMDE0                        % POINTER TO TABLE OF OMD ENTRIES (LAST PART)
121563          OMDT0                        % POINTER TO TABLE OF OMD DATAFIELD ADDRESSES
121564          MBSO0                        % TABLE OF STATIONS RECEIVING MULTIBYTE
121565          SOUI0                        % POINTER TO TABLE OF IDENT ENTRIES
121566          OCITI; -2; -10               % TIMEOUT SUBROUTINE AND COUNTERS
121571          100400; SOCTO; IOCTO         % IOX, STDRIV, DRIVER
121574  IOCT0,  000001; 0                    % RECEIVE CONTROL WORD AND STATUS
121576          0;0;0;0;0;0                  % STATUS AND ERROR COUNTS
121604
121604  %=======================================================================================
121604  %      O C T O B U S   C O N T R O L L E R   NUMBER-0  O U T P U T   D A T A F I E L D
121604  %
121604         0;0;0                         % TRMODUS, TRFRAME, TROMD
121607         SBBU0;100; 0;0                % SBBUFF, SBMAX, SBGETP, SBPUTP
121613         1                             % EMPTFLAG
121614         OCOTI; -3; -3;                % TIMEOUT SUBROUTINE AND COUNTERS
121617         100400+4; SOCTW; SOCTW        % IOX, STDRIV, DRIVER
121622  OOCT0,  000005; 0                    % TRANSMITT CONTROL WORD AND STATUS
121624         0;0;0;0                       % MULTIBYTE MESSAGE VARIABLES
121630
121630
121630  %-----------------------------------------------------------------------------------------------
121630  %  ADDRESS TO KICK ENTRIES
121630  %
121630  KICK0,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
121650
121650
121650  %-----------------------------------------------------------------------------------------------
121650  %  ADDRESS TO OMD ENTRIES (LAST PART)
121650  %
121650  OMDE0,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
121670
121670
121670  %-----------------------------------------------------------------------------------------------
121670  %  ADDRESS TO OMD DATAFIELDS
121670  %
121670  OMDT0,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
121710
121710
121710  %-----------------------------------------------------------------------------------------------
121710  %  MULTIBYTE MESSAGE SOURCE STATION TABLE
121710  %
121710  MBSO0,  0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
121750          0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0
122010
122010  %-----------------------------------------------------------------------------------------------
122010  %  IDENT TABLE
122010  %
122010  SOUI0,  0;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;20;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5
122050          5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5;5
122110
122110  %-----------------------------------------------------------------------------------------------
122110  %  SINGLE BYTE MESSAGE OUTPUT BUFFER
122110
122110  SBBU0, *+100/
122210
122210  OMDNU 0,00,00,10;
122210  %==============================================================================
122210  %       OCTOBUS MESSAGE DEVICE NUMBER: 00
122210
122210          4;0;0;0;0;0                       % VARIOUS COUNTERS
122216          0;0                               % MBMRE,MBSLRE
122220          IOCT0;OOCT0;00
122223  OM000,  0;0;*-2
122226           2;0;0;IORES
122232
122232  %-----------------------------------------------------------------------------------------------
122232  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122232  )KILL XXX
122232  XXX=*
122232  OMDT0+00/OM000
121671  XXX/
122232  )KILL XXX
122232
122232  OMDNU 0,01,01,10;
122232  %==============================================================================
122232  %       OCTOBUS MESSAGE DEVICE NUMBER: 01
122232
122232          4;0;0;0;0;0                       % VARIOUS COUNTERS
122240          0;0                               % MBMRE,MBSLRE
122242          IOCT0;OOCT0;01
122245  OM001,  0;0;*-2
122250           2;0;0;IORES
122254
122254  %-----------------------------------------------------------------------------------------------
122254  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122254  )KILL XXX
122254  XXX=*
122254  OMDT0+01/OM001
121672  XXX/
122254  )KILL XXX
122254
122254  OMDNU 0,02,02,10;
122254  %==============================================================================
122254  %       OCTOBUS MESSAGE DEVICE NUMBER: 02
122254
122254          4;0;0;0;0;0                       % VARIOUS COUNTERS
122262          0;0                               % MBMRE,MBSLRE
122264          IOCT0;OOCT0;02
122267  OM002,  0;0;*-2
122272           2;0;0;IORES
122276
122276  %-----------------------------------------------------------------------------------------------
122276  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122276  )KILL XXX
122276  XXX=*
122276  OMDT0+02/OM002
121673  XXX/
122276  )KILL XXX
122276
122276  OMDNU 0,03,03,10;
122276  %==============================================================================
122276  %       OCTOBUS MESSAGE DEVICE NUMBER: 03
122276
122276          4;0;0;0;0;0                       % VARIOUS COUNTERS
122304          0;0                               % MBMRE,MBSLRE
122306          IOCT0;OOCT0;03
122311  OM003,  0;0;*-2
122314           2;0;0;IORES
122320
122320  %-----------------------------------------------------------------------------------------------
122320  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122320  )KILL XXX
122320  XXX=*
122320  OMDT0+03/OM003
121674  XXX/
122320  )KILL XXX
122320
122320  OMDNU 0,04,04,10;
122320  %==============================================================================
122320  %       OCTOBUS MESSAGE DEVICE NUMBER: 04
122320
122320          4;0;0;0;0;0                       % VARIOUS COUNTERS
122326          0;0                               % MBMRE,MBSLRE
122330          IOCT0;OOCT0;04
122333  OM004,  0;0;*-2
122336           2;0;0;IORES
122342
122342  %-----------------------------------------------------------------------------------------------
122342  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122342  )KILL XXX
122342  XXX=*
122342  OMDT0+04/OM004
121675  XXX/
122342  )KILL XXX
122342
122342  OMDNU 0,05,05,10;
122342  %==============================================================================
122342  %       OCTOBUS MESSAGE DEVICE NUMBER: 05
122342
122342          4;0;0;0;0;0                       % VARIOUS COUNTERS
122350          0;0                               % MBMRE,MBSLRE
122352          IOCT0;OOCT0;05
122355  OM005,  0;0;*-2
122360           2;0;0;IORES
122364
122364  %-----------------------------------------------------------------------------------------------
122364  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122364  )KILL XXX
122364  XXX=*
122364  OMDT0+05/OM005
121676  XXX/
122364  )KILL XXX
122364
122364  OMDNU 0,06,06,10;
122364  %==============================================================================
122364  %       OCTOBUS MESSAGE DEVICE NUMBER: 06
122364
122364          4;0;0;0;0;0                       % VARIOUS COUNTERS
122372          0;0                               % MBMRE,MBSLRE
122374          IOCT0;OOCT0;06
122377  OM006,  0;0;*-2
122402           2;0;0;IORES
122406
122406  %-----------------------------------------------------------------------------------------------
122406  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122406  )KILL XXX
122406  XXX=*
122406  OMDT0+06/OM006
121677  XXX/
122406  )KILL XXX
122406
122406  OMDNU 0,07,07,10;
122406  %==============================================================================
122406  %       OCTOBUS MESSAGE DEVICE NUMBER: 07
122406
122406          4;0;0;0;0;0                       % VARIOUS COUNTERS
122414          0;0                               % MBMRE,MBSLRE
122416          IOCT0;OOCT0;07
122421  OM007,  0;0;*-2
122424           2;0;0;IORES
122430
122430  %-----------------------------------------------------------------------------------------------
122430  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122430  )KILL XXX
122430  XXX=*
122430  OMDT0+07/OM007
121700  XXX/
122430  )KILL XXX
122430
122430  OMDNU 0,10,10,10;
122430  %==============================================================================
122430  %       OCTOBUS MESSAGE DEVICE NUMBER: 10
122430
122430          4;0;0;0;0;0                       % VARIOUS COUNTERS
122436          0;0                               % MBMRE,MBSLRE
122440          IOCT0;OOCT0;10
122443  OM010,  0;0;*-2
122446           2;0;0;IORES
122452
122452  %-----------------------------------------------------------------------------------------------
122452  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122452  )KILL XXX
122452  XXX=*
122452  OMDT0+10/OM010
121701  XXX/
122452  )KILL XXX
122452
122452  OMDNU 0,11,11,10;
122452  %==============================================================================
122452  %       OCTOBUS MESSAGE DEVICE NUMBER: 11
122452
122452          4;0;0;0;0;0                       % VARIOUS COUNTERS
122460          0;0                               % MBMRE,MBSLRE
122462          IOCT0;OOCT0;11
122465  OM011,  0;0;*-2
122470           2;0;0;IORES
122474
122474  %-----------------------------------------------------------------------------------------------
122474  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122474  )KILL XXX
122474  XXX=*
122474  OMDT0+11/OM011
121702  XXX/
122474  )KILL XXX
122474
122474  OMDNU 0,12,12,10;
122474  %==============================================================================
122474  %       OCTOBUS MESSAGE DEVICE NUMBER: 12
122474
122474          4;0;0;0;0;0                       % VARIOUS COUNTERS
122502          0;0                               % MBMRE,MBSLRE
122504          IOCT0;OOCT0;12
122507  OM012,  0;0;*-2
122512           2;0;0;IORES
122516
122516  %-----------------------------------------------------------------------------------------------
122516  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122516  )KILL XXX
122516  XXX=*
122516  OMDT0+12/OM012
121703  XXX/
122516  )KILL XXX
122516
122516  OMDNU 0,13,13,10;
122516  %==============================================================================
122516  %       OCTOBUS MESSAGE DEVICE NUMBER: 13
122516
122516          4;0;0;0;0;0                       % VARIOUS COUNTERS
122524          0;0                               % MBMRE,MBSLRE
122526          IOCT0;OOCT0;13
122531  OM013,  0;0;*-2
122534           2;0;0;IORES
122540
122540  %-----------------------------------------------------------------------------------------------
122540  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122540  )KILL XXX
122540  XXX=*
122540  OMDT0+13/OM013
121704  XXX/
122540  )KILL XXX
122540
122540  OMDNU 0,14,14,10;
122540  %==============================================================================
122540  %       OCTOBUS MESSAGE DEVICE NUMBER: 14
122540
122540          4;0;0;0;0;0                       % VARIOUS COUNTERS
122546          0;0                               % MBMRE,MBSLRE
122550          IOCT0;OOCT0;14
122553  OM014,  0;0;*-2
122556           2;0;0;IORES
122562
122562  %-----------------------------------------------------------------------------------------------
122562  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122562  )KILL XXX
122562  XXX=*
122562  OMDT0+14/OM014
121705  XXX/
122562  )KILL XXX
122562
122562  OMDNU 0,15,15,10;
122562  %==============================================================================
122562  %       OCTOBUS MESSAGE DEVICE NUMBER: 15
122562
122562          4;0;0;0;0;0                       % VARIOUS COUNTERS
122570          0;0                               % MBMRE,MBSLRE
122572          IOCT0;OOCT0;15
122575  OM015,  0;0;*-2
122600           2;0;0;IORES
122604
122604  %-----------------------------------------------------------------------------------------------
122604  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122604  )KILL XXX
122604  XXX=*
122604  OMDT0+15/OM015
121706  XXX/
122604  )KILL XXX
122604
122604  OMDNU 0,16,16,10;
122604  %==============================================================================
122604  %       OCTOBUS MESSAGE DEVICE NUMBER: 16
122604
122604          4;0;0;0;0;0                       % VARIOUS COUNTERS
122612          0;0                               % MBMRE,MBSLRE
122614          IOCT0;OOCT0;16
122617  OM016,  0;0;*-2
122622           2;0;0;IORES
122626
122626  %-----------------------------------------------------------------------------------------------
122626  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122626  )KILL XXX
122626  XXX=*
122626  OMDT0+16/OM016
121707  XXX/
122626  )KILL XXX
122626
122626  OMDNU 0,17,17,10;
122626  %==============================================================================
122626  %       OCTOBUS MESSAGE DEVICE NUMBER: 17
122626
122626          4;0;0;0;0;0                       % VARIOUS COUNTERS
122634          0;0                               % MBMRE,MBSLRE
122636          IOCT0;OOCT0;17
122641  OM017,  0;0;*-2
122644           2;0;0;IORES
122650
122650  %-----------------------------------------------------------------------------------------------
122650  %  SET ADDRESS TO OMD DATAFIELD IN OMDTAB
122650  )KILL XXX
122650  XXX=*
122650  OMDT0+17/OM017
121710  XXX/
122650  )KILL XXX
122650
122650
122650  %==============================================================================
122650  %  LEVEL DATAFIELDS FOR OCTOBUS
122650  LEVDF 10;
122650  %==============================================================================
122650  %       OCTOBUS LEVEL LINK DATAFIELD FOR LEVEL 10, 11 AND 12.
122650
122650  OCD10,  0                      % NOT USED
122651             0                   % NOT USED
122652             -1                  % LEVLINK
122653             0                   % BANK NO OF OCTOBUS TABLES
122654             0                   % BREGQ
122655             0                   % NLINK
122656             AOC10               % NFUNC
122657
122657  LEVDF 11;
122657  %==============================================================================
122657  %       OCTOBUS LEVEL LINK DATAFIELD FOR LEVEL 10, 11 AND 12.
122657
122657  OCD11,  0                      % NOT USED
122660             0                   % NOT USED
122661             -1                  % LEVLINK
122662             0                   % BANK NO OF OCTOBUS TABLES
122663             0                   % BREGQ
122664             0                   % NLINK
122665             AOC11               % NFUNC
122666
122666  LEVDF 12;
122666  %==============================================================================
122666  %       OCTOBUS LEVEL LINK DATAFIELD FOR LEVEL 10, 11 AND 12.
122666
122666  OCD12,  0                      % NOT USED
122667             0                   % NOT USED
122670             -1                  % LEVLINK
122671             0                   % BANK NO OF OCTOBUS TABLES
122672             0                   % BREGQ
122673             0                   % NLINK
122674             AOC12               % NFUNC
122675
122675
122675  %==============================================================================
122675  %       B U F F E R      D E S C R I P T O R S    F O R   O C T O B U S
122675  %
122675  ONOBU; *-1/; "ONOBU; ONOBU=30; "  % NUMBER OF BUFFER IN BUFFERPOOL
122675  STOCT=*
122675  ONOBU@3+ONOBU+*/                  % BUFFER DESCRIPTOR AREA
123225  ENDOC=*
123225
123225
123225  )LINE
%=================================================================================================
123225  %
123225  %       N U C L E U S   S E R V E R  D A T A F I E L D S
123225  %
123225  %=================================================================================================
123225
123225  %=======================================================================================
123225  %       N U C L E U S    S E R V E R   D A T A F I E L D
123225  %
123225          DKICK                        % DRIVER
123226          DKICK                        % DRIVER
123227  NUSDF,  0                            % RESLINK
123230          0                            % RTRES
123231          NUSDF                        % BWLINK
123232          0                            % TYPRING
123233          -1                           % ISTATE
123234          0                            % MLINK
123235          IORES                        % MFUNC
123236
123236  %=======================================================================================
123236  %       I N P U T   D A T A F I E L D
123236  %
123236  NUIDF,  0                            % RESLINK
123237          0                            % RTRES
123240          NUIDF                        % BWLINK
123241          0                            % TYPRING
123242          -1                           % ISTATE
123243          0                            % MLINK
123244          IORES                        % MFUNC
123245
123245  %=======================================================================================
123245  %      O U T P U T   D A T A F I E L D
123245  %
123245         NUCTI                         % TMSUB
123246         0                             % TMR
123247         -1000                         % TTMR
123250         0;0;0                         % IOX, STDRIV, DRIVER
123253  NUODF, 0                             % RESLINK
123254         0                             % RTRES
123255         NUODF                         % BWLINK
123256         0                             % TYPRING
123257         0                             % ISTATE
123260         0                             % MLINK
123261         IORES                         % MFUNC
123262         0                             % NTMOUT (TIMEOUT FLAG)
123263         0                             % MAILSYNC
123264
123264  %=======================================================================================
123264  %   DATAFIELD USED WHEN CALLING ROUTINES ON OTHER PITS
123264  %
123264  PITDF,  0                            % RESLINK
123265          0                            % RTRES
123266          PITDF                        % BWLINK
123267          0                            % TYPRING
123270          -1                           % ISTATE
123271          0                            % MLINK
123272          IORES                        % MFUNC
123273
123273  )LINE
%======================================================================%
123273  %                                                                      %
123273  %  ( D )    D I S K   M I R R O R I N G   D A T A                      %
123273  %                                                                      %
123273  %======================================================================%
123273
123273  % WORKING FIELD FOR MON SYSU
123273  SYUWL=400                    % WORK AREA LENGTH
123273  SYUDF, 0;0;*-2;0;0;0;0
123302         0;0;0;0;0;0;0;0
123312         0;0;0;0;0;0
123320         0                     % POINTER TO CLUSTER ENTRY
123321         *+11+SYUWL/           % WORKING AREA (CLUSTER ENTRY ETC.)
123732
123732  "8DIMI
123732  % SEMPHORE FOR UPDATING CLUSTERS
123732  CLSEM, 0;0;*-2;0;0;0;0
123741
123741  DMDAQ, 0                     % LAST QUEUE ELEMENT USED
123742  DWDOK, 0                     % RUNNING FLAG FOR DIMIR WATCHDOG
123743  RVSEM, 0                     % REVIVE SEMAPHORE
123744
123744  % BITMASKS FOR ACCESS BITS
123744  DMRMM, 0; 1@5DRM1; 1@5DRM2; 1@5DRM3
123750  DMWMM, 0; 1@5DWM1; 1@5DWM2; 1@5DWM3
123754
123754
123754  % DISK MIRRORING CLUSTER TABLE (DMT)
123754  DMTBL=*
123754  %
123754  % DMT HEADER:
123754  DHNCL, NDMTE@10+NNUAC        % NUMBER OF CLUSTERS AND NO UPDATE AREAS
123755  DHVER, DMVER@10+DMREV        % VERSION AND REVISION
123756  DHFLG, 4                     % HEADER FLAGS
123757  DMHL=*-DMTBL                 % LENGTH OF HEADER
123757
123757  % DEFINE CLUSTER ENTRIES
123757  DMCLT, NDMTE@1+*/; NDMTE@4+*/; NDMTE@5+*/   % 62 LOCATIONS PER CLUSTER
124577  DMECT=*
124577  DMCLT<DMECT-1
124577  )ZERO
124577  DMFST, -1; NDMTE@3+*/; NDMTE+*/             % FAST CLUSTER SEARCH TABLE
124710
124710  DIMWA, ADMWA                 % ADDRESS OF DIMIR WORKING AREA
124711
124711  ADMWA, 0;0;*-2;0;0           % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
124716         0;0                   % MLINK, MFUNC
124720  SECNO, 0; 9FLP1, 0; 9FLP2, 0; 9FLP3, 0; 9FLP4, 0
124725  ERMSA=SECNO                  % ERMSG FOR 9FLEA
124725         0; 0;0; 0;0; 0;0; 0;0 % ABSTR PARAMETER AREA
124736
124736  % DIMIR OPERATION DATAFIELDS
124736
124736  )MCDEF ODDEF
XXXS=XXX0; )KILL XXX0
       0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
       XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
       0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
]
124736
124736  XXX0=0; NODAF=0
124736  ODDEF

124736  XXXS=XXX0; )KILL XXX0
124736         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
124745  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
124752         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
124761         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
124772  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
124772  ODDEF

124772  XXXS=XXX0; )KILL XXX0
124772         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125001  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125006         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125015         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125026  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125026  ODDEF

125026  XXXS=XXX0; )KILL XXX0
125026         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125035  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125042         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125051         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125062  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125062  ODDEF

125062  XXXS=XXX0; )KILL XXX0
125062         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125071  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125076         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125105         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125116  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125116  ODDEF

125116  XXXS=XXX0; )KILL XXX0
125116         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125125  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125132         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125141         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125152  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125152  ODDEF

125152  XXXS=XXX0; )KILL XXX0
125152         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125161  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125166         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125175         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125206  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125206  ODDEF

125206  XXXS=XXX0; )KILL XXX0
125206         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125215  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125222         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125231         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125242  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125242  ODDEF

125242  XXXS=XXX0; )KILL XXX0
125242         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125251  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125256         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125265         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125276  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125276  ODDEF

125276  XXXS=XXX0; )KILL XXX0
125276         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125305  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125312         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125321         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125332  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125332  ODDEF

125332  XXXS=XXX0; )KILL XXX0
125332         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125341  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125346         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125355         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125366  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125366  ODDEF

125366  XXXS=XXX0; )KILL XXX0
125366         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125375  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125402         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125411         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125422  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125422  ODDEF

125422  XXXS=XXX0; )KILL XXX0
125422         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125431  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125436         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125445         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125456  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125456  ODDEF

125456  XXXS=XXX0; )KILL XXX0
125456         0;0;0;0;0;0;0          % DMORO,DMODU,DMRUT,DMRWM,DMSTAT,DMSTAT,XSTAT
125465  XXX0,  0;0;*-2;0;0            % RESLINK,RTRES,BWLINK,TYPRING,ISTATE
125472         XXXS;DIMRS;0;0;0;0;0   % MLINK,MFUNC,SRLREG,SSSTAT,CLUPT,DMCDF,FUNC
125501         0; 0;0; 0;0; 0;0; 0;0  % ABFNC,ABMEA,APDIA,APNBL;FILLER,APHDI
125512  XXXX=NODAF+1; )KILL NODAF; NODAF=XXXX; )KILL XXXX XXXS
125512
125512  DMOFQ, XXX0                   % FREELIST POINTER FOR OP DATAF
125513  DMNFO, NODAF                  % NUMBER OF FREE OP DATAF
125514  )KILL XXX0 NODAF ODDEF
125514  DMWCP, 0                      % POINTER TO CLUSTER ENTRY IN WRITE CLUSTER
125515  DMWQP, 0                      % QUEUE POINTER FOR WRITE CLUSTER WAIT CONDITION
125516  DMDWQ, 0                      % POINTER FOR FREE DAQ WAITING QUEUE
125517  DMNRQ, FQELN                  % NUMBER OF UNRESERVED DAQ'S
125520
125520  % DIMIR FUNCTION TYPES
125520  DMTYP, 000@10+000; 000@10+000; 000@10+000; 204@10+000  % 00 - 07
125524         000@10+000; 000@10+000; 000@10+000; 000@10+000  % 10 - 17
125530         000@10+000; 000@10+000; 000@10+000; 000@10+000  % 20 - 27
125534         000@10+000; 000@10+000; 000@10+204; 000@10+000  % 30 - 37
125540         000@10+000; 204@10+000; 000@10+000; 000@10+000  % 40 - 47
125544         000@10+000; 000@10+000; 000@10+000; 000@10+000  % 50 - 57
125550         371@10+372; 361@10+341; 343@10+343; 371@10+000  % 60 - 67
125554         000@10+000; 000@10+000; 000@10+000; 000@10+000  % 70 - 77
125560
125560  % PARAMETER LIST FOR MON CALLS
125560  FC510, (10; (5DIMS; (0; (0; (0; (0
125566  DM164, (5IMDA
125567  )FILL
125573  "
125573  @

125573  %==============================================================================
125573  %                           C X - S I N 5 - G E N
125573  STNRD=*
125573  %==============================================================================
125573  % 29.13      N A M E  T A B L E
125573  %
125573  NAMTA=*
125573  *+NTLEN/
125611  *+NTLEN/
125627  *+NTLEN/
125645  *+NTLEN/
125663  *+NTLEN/
125701  *+NTLEN/
125717  *+NTLEN/
125735  *+NTLEN/
125753  *+NTLEN/
125771  *+NTLEN/
126007  *+NTLEN/
126025  *+NTLEN/
126043  *+NTLEN/
126061  *+NTLEN/
126077  *+NTLEN/
126115  *+NTLEN/
126133  *+NTLEN/
126151  *+NTLEN/
126167  *+NTLEN/
126205  *+NTLEN/
126223  ENDNT=*
126223  FFTAB=*
126223  010400 % FLOPPY FORMAT 0 : SECTOR SIZE 400, DEVICE SIZE 232 PAGES
126224  022017 % FLOPPY FORMAT 17: SECTOR SIZE 400*2, DEVICE SIZE 232*4 PAGES
126225  -1
126226
126226  %==============================================================================
126226  % 29.14      D I R E C T O R Y  T A B L E
126226  %
126226
126226
126226  DIRTA=*
126226  DDRTB 0,0,0,0

126226  0; 0; 0; 0; 0;
126233  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126243  0;0;0;0;0;0;0;0
126253  0;0;0
126256
126256  DDRTB 0,0,0,0

126256  0; 0; 0; 0; 0;
126263  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126273  0;0;0;0;0;0;0;0
126303  0;0;0
126306
126306  DDRTB 0,0,0,0

126306  0; 0; 0; 0; 0;
126313  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126323  0;0;0;0;0;0;0;0
126333  0;0;0
126336
126336  DDRTB 0,0,0,0

126336  0; 0; 0; 0; 0;
126343  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126353  0;0;0;0;0;0;0;0
126363  0;0;0
126366
126366  DDRTB 0,0,0,0

126366  0; 0; 0; 0; 0;
126373  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126403  0;0;0;0;0;0;0;0
126413  0;0;0
126416
126416  DDRTB 0,0,0,0

126416  0; 0; 0; 0; 0;
126423  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126433  0;0;0;0;0;0;0;0
126443  0;0;0
126446
126446  DDRTB 0,0,0,0

126446  0; 0; 0; 0; 0;
126453  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126463  0;0;0;0;0;0;0;0
126473  0;0;0
126476
126476  DDRTB 0,0,0,0

126476  0; 0; 0; 0; 0;
126503  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126513  0;0;0;0;0;0;0;0
126523  0;0;0
126526
126526  DDRTB 0,0,0,0

126526  0; 0; 0; 0; 0;
126533  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126543  0;0;0;0;0;0;0;0
126553  0;0;0
126556
126556  DDRTB 0,0,0,0

126556  0; 0; 0; 0; 0;
126563  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126573  0;0;0;0;0;0;0;0
126603  0;0;0
126606
126606  DDRTB 0,0,0,0

126606  0; 0; 0; 0; 0;
126613  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126623  0;0;0;0;0;0;0;0
126633  0;0;0
126636
126636  DDRTB 0,0,0,0

126636  0; 0; 0; 0; 0;
126643  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126653  0;0;0;0;0;0;0;0
126663  0;0;0
126666
126666  DDRTB 0,0,0,0

126666  0; 0; 0; 0; 0;
126673  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126703  0;0;0;0;0;0;0;0
126713  0;0;0
126716
126716  DDRTB 0,0,0,0

126716  0; 0; 0; 0; 0;
126723  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126733  0;0;0;0;0;0;0;0
126743  0;0;0
126746
126746  DDRTB 0,0,0,0

126746  0; 0; 0; 0; 0;
126753  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
126763  0;0;0;0;0;0;0;0
126773  0;0;0
126776
126776  DDRTB 0,0,0,0

126776  0; 0; 0; 0; 0;
127003  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127013  0;0;0;0;0;0;0;0
127023  0;0;0
127026
127026  DDRTB 0,0,0,0

127026  0; 0; 0; 0; 0;
127033  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127043  0;0;0;0;0;0;0;0
127053  0;0;0
127056
127056  DDRTB 0,0,0,0

127056  0; 0; 0; 0; 0;
127063  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127073  0;0;0;0;0;0;0;0
127103  0;0;0
127106
127106  DDRTB 0,0,0,0

127106  0; 0; 0; 0; 0;
127113  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127123  0;0;0;0;0;0;0;0
127133  0;0;0
127136
127136  DDRTB 0,0,0,0

127136  0; 0; 0; 0; 0;
127143  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127153  0;0;0;0;0;0;0;0
127163  0;0;0
127166
127166  DDRTB 0,0,0,0

127166  0; 0; 0; 0; 0;
127173  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127203  0;0;0;0;0;0;0;0
127213  0;0;0
127216
127216  DDRTB 0,0,0,0

127216  0; 0; 0; 0; 0;
127223  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127233  0;0;0;0;0;0;0;0
127243  0;0;0
127246
127246  DDRTB 0,0,0,0

127246  0; 0; 0; 0; 0;
127253  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127263  0;0;0;0;0;0;0;0
127273  0;0;0
127276
127276  DDRTB 0,0,0,0

127276  0; 0; 0; 0; 0;
127303  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127313  0;0;0;0;0;0;0;0
127323  0;0;0
127326
127326  DDRTB 0,0,0,0

127326  0; 0; 0; 0; 0;
127333  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127343  0;0;0;0;0;0;0;0
127353  0;0;0
127356
127356  DDRTB 0,0,0,0

127356  0; 0; 0; 0; 0;
127363  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127373  0;0;0;0;0;0;0;0
127403  0;0;0
127406
127406  DDRTB 0,0,0,0

127406  0; 0; 0; 0; 0;
127413  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127423  0;0;0;0;0;0;0;0
127433  0;0;0
127436
127436  DDRTB 0,0,0,0

127436  0; 0; 0; 0; 0;
127443  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127453  0;0;0;0;0;0;0;0
127463  0;0;0
127466
127466  DDRTB 0,0,0,0

127466  0; 0; 0; 0; 0;
127473  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127503  0;0;0;0;0;0;0;0
127513  0;0;0
127516
127516  DDRTB 0,0,0,0

127516  0; 0; 0; 0; 0;
127523  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127533  0;0;0;0;0;0;0;0
127543  0;0;0
127546
127546  DDRTB 0,0,0,0

127546  0; 0; 0; 0; 0;
127553  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127563  0;0;0;0;0;0;0;0
127573  0;0;0
127576
127576  DDRTB 0,0,0,0

127576  0; 0; 0; 0; 0;
127603  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127613  0;0;0;0;0;0;0;0
127623  0;0;0
127626
127626  DDRTB 0,0,0,0

127626  0; 0; 0; 0; 0;
127633  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127643  0;0;0;0;0;0;0;0
127653  0;0;0
127656
127656  DDRTB 0,0,0,0

127656  0; 0; 0; 0; 0;
127663  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127673  0;0;0;0;0;0;0;0
127703  0;0;0
127706
127706  DDRTB 0,0,0,0

127706  0; 0; 0; 0; 0;
127713  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127723  0;0;0;0;0;0;0;0
127733  0;0;0
127736
127736  DDRTB 0,0,0,0

127736  0; 0; 0; 0; 0;
127743  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
127753  0;0;0;0;0;0;0;0
127763  0;0;0
127766
127766  DDRTB 0,0,0,0

127766  0; 0; 0; 0; 0;
127773  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130003  0;0;0;0;0;0;0;0
130013  0;0;0
130016
130016  DDRTB 0,0,0,0

130016  0; 0; 0; 0; 0;
130023  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130033  0;0;0;0;0;0;0;0
130043  0;0;0
130046
130046  DDRTB 0,0,0,0

130046  0; 0; 0; 0; 0;
130053  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130063  0;0;0;0;0;0;0;0
130073  0;0;0
130076
130076  DDRTB 0,0,0,0

130076  0; 0; 0; 0; 0;
130103  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130113  0;0;0;0;0;0;0;0
130123  0;0;0
130126
130126  ENDHD=*                                % END OF PART OF DIRECTORY TABLE DEALING WITH HARD DISKS.
130126
130126  DDRTB 0,0,0,0

130126  0; 0; 0; 0; 0;
130133  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130143  0;0;0;0;0;0;0;0
130153  0;0;0
130156
130156  DDRTB 0,0,0,0

130156  0; 0; 0; 0; 0;
130163  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130173  0;0;0;0;0;0;0;0
130203  0;0;0
130206
130206  DDRTB 0,0,0,0

130206  0; 0; 0; 0; 0;
130213  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130223  0;0;0;0;0;0;0;0
130233  0;0;0
130236
130236  DDRTB 0,0,0,0

130236  0; 0; 0; 0; 0;
130243  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130253  0;0;0;0;0;0;0;0
130263  0;0;0
130266
130266  DDRTB 0,0,0,0

130266  0; 0; 0; 0; 0;
130273  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130303  0;0;0;0;0;0;0;0
130313  0;0;0
130316
130316  DDRTB 0,0,0,0

130316  0; 0; 0; 0; 0;
130323  0;0;0;0;0;0;0;0;                                 % DIRECTORY NAME
130333  0;0;0;0;0;0;0;0
130343  0;0;0
130346
130346  % DDRTB 0,0,0,0
130346  % DDRTB 0,0,0,0
130346
130346  ENDDD=*                                % END OF PART OF DIRECTORY TABLE FOR DISKS.
130346
130346
130346  ENDDT=*                                          % END OF DIRECTORY TABLE: BOTH DISKS AND MAG TAPE
130346
130346
130346  %==============================================================================
130346  % 29.15      B I T  F I L E  B U F F E R S
130346  %
130346  BINDX=0
130346  BFBUF=*
130346  FBFBU 0

130346  BINDX ; -1; 0; 0; *+20/
130372  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130372
130372  FBFBU 0

130372  BINDX ; -1; 0; 0; *+20/
130416  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130416
130416  FBFBU 0

130416  BINDX ; -1; 0; 0; *+20/
130442  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130442
130442  FBFBU 0

130442  BINDX ; -1; 0; 0; *+20/
130466  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130466
130466  FBFBU 0

130466  BINDX ; -1; 0; 0; *+20/
130512  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130512
130512  FBFBU 0

130512  BINDX ; -1; 0; 0; *+20/
130536  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130536
130536  FBFBU 0

130536  BINDX ; -1; 0; 0; *+20/
130562  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130562
130562  FBFBU 0

130562  BINDX ; -1; 0; 0; *+20/
130606  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130606
130606  FBFBU 0

130606  BINDX ; -1; 0; 0; *+20/
130632  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130632
130632  FBFBU 0

130632  BINDX ; -1; 0; 0; *+20/
130656  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130656
130656  FBFBU 0

130656  BINDX ; -1; 0; 0; *+20/
130702  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130702
130702  FBFBU 0

130702  BINDX ; -1; 0; 0; *+20/
130726  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130726
130726  FBFBU 0

130726  BINDX ; -1; 0; 0; *+20/
130752  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130752
130752  FBFBU 0

130752  BINDX ; -1; 0; 0; *+20/
130776  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
130776
130776  FBFBU 0

130776  BINDX ; -1; 0; 0; *+20/
131022  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131022
131022  FBFBU 0

131022  BINDX ; -1; 0; 0; *+20/
131046  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131046
131046  FBFBU 0

131046  BINDX ; -1; 0; 0; *+20/
131072  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131072
131072  FBFBU 0

131072  BINDX ; -1; 0; 0; *+20/
131116  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131116
131116  FBFBU 0

131116  BINDX ; -1; 0; 0; *+20/
131142  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131142
131142  FBFBU 0

131142  BINDX ; -1; 0; 0; *+20/
131166  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131166
131166  FBFBU 0

131166  BINDX ; -1; 0; 0; *+20/
131212  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131212
131212  FBFBU 0

131212  BINDX ; -1; 0; 0; *+20/
131236  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131236
131236  FBFBU 0

131236  BINDX ; -1; 0; 0; *+20/
131262  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131262
131262  FBFBU 0

131262  BINDX ; -1; 0; 0; *+20/
131306  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131306
131306  FBFBU 0

131306  BINDX ; -1; 0; 0; *+20/
131332  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131332
131332  FBFBU 0

131332  BINDX ; -1; 0; 0; *+20/
131356  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131356
131356  FBFBU 0

131356  BINDX ; -1; 0; 0; *+20/
131402  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131402
131402  FBFBU 0

131402  BINDX ; -1; 0; 0; *+20/
131426  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131426
131426  FBFBU 0

131426  BINDX ; -1; 0; 0; *+20/
131452  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131452
131452  FBFBU 0

131452  BINDX ; -1; 0; 0; *+20/
131476  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131476
131476  FBFBU 0

131476  BINDX ; -1; 0; 0; *+20/
131522  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131522
131522  FBFBU 0

131522  BINDX ; -1; 0; 0; *+20/
131546  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131546
131546  FBFBU 0

131546  BINDX ; -1; 0; 0; *+20/
131572  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131572
131572  FBFBU 0

131572  BINDX ; -1; 0; 0; *+20/
131616  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131616
131616  FBFBU 0

131616  BINDX ; -1; 0; 0; *+20/
131642  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131642
131642  FBFBU 0

131642  BINDX ; -1; 0; 0; *+20/
131666  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131666
131666  FBFBU 0

131666  BINDX ; -1; 0; 0; *+20/
131712  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131712
131712  FBFBU 0

131712  BINDX ; -1; 0; 0; *+20/
131736  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131736
131736  FBFBU 0

131736  BINDX ; -1; 0; 0; *+20/
131762  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
131762
131762  FBFBU 0

131762  BINDX ; -1; 0; 0; *+20/
132006  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132006
132006  FBFBU 0

132006  BINDX ; -1; 0; 0; *+20/
132032  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132032
132032  FBFBU 0

132032  BINDX ; -1; 0; 0; *+20/
132056  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132056
132056  FBFBU 0

132056  BINDX ; -1; 0; 0; *+20/
132102  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132102
132102  FBFBU 0

132102  BINDX ; -1; 0; 0; *+20/
132126  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132126
132126  FBFBU 0

132126  BINDX ; -1; 0; 0; *+20/
132152  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132152
132152  FBFBU 0

132152  BINDX ; -1; 0; 0; *+20/
132176  XBINX=BINDX+1;)KILL BINDX;BINDX=XBINX;)KILL XBINX
132176
132176  %%%FBFBU 0
132176  %%%FBFBU 0
132176
132176  ENDBF=*
132176
132176  )LINE
014742   %$--:COMMON                    % FOR SPLITTING AV LISTING.
014742   *P2CCC/
017307   @DEV (S-S-L)CC-P2-COMMON:NPL
017307   %$--:COMMON                    % FOR SPLITTING AV LISTING.
017307   *P2CCC/
017307   %==============================================================================
017307   %     ( C )     G E T D A T A F I E L D
017307
017307   % SUBROUTINE TO GET ADDRESS TO TERMINAL DATAFIELD
017307   % RETURNED IN X-REG.
017307   SUBR GETDATAFIELD
017307
017307   GETDATAFIELD:
017307          RTREF-"BAK01"
017311          IF A<=0 THEN
017313             IF LGCOLDSTART><0 THEN L=:X; CALL LOGPH; X=:L:=A; EXIT FI
017322             A:=0
017323          FI; A=:D:=0; T:=5RTSIZE; *RDIV ST
017327          IF D><0 THEN CALL ERRFATAL FI
017332   *"-8BACS
"017332          X:=XBCKTAB(A)
017334   *"
"017334          EXIT
017335   RBUS
017343
017343   %===========================================================================
017343   %                G B P I U S I N D X
017343   %
017343   % SUBROUTINE TO FIND BACKGROUND-PROGRAM-IN-USE INDEX
017343   %
017343   % ENTRY:         A=RT-DESCRIPTION ADDRESS
017343   %
017343   % EXIT:          NOT BACKGROUND-PROGRAM-IN-USE
017343   %
017343   % EXIT+1:        A=BACKGROUND-PROGRAM-IN-USE INDEX
017343   %
017343   SUBR GBPIUSINDX
017343   GBPIUSINDX:
017343          IF A>>="9FBPR" AND A<<"9LBPR" THEN
017351   *"8BACS
"017351             IF A<<"9LTBP" THEN                     % TERMINAL/TAD BACKGROUND PROGRAM
017354                A-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
017361                EXITA
017362             FI
017362             A-"2THSS"=:D:=0; T:=5RTSIZE; *RDIV ST
017367             A+MXTBPROGS; EXITA                     % BATCH BACKGROUND PROGRAM
017371   *"-8BACS
"017371          FI; EXIT                                  % NOT BACKGROUND PROGRAM
017372   RBUS
017377
017377
017377   SUBR 9GTLOGDV
017377   %============================================================================
017377   %            C F L O G D V
017377   %
017377   % LOCAL SUBROUTINE TO SEARCH FOR A DATAFIELD ADDRESS
017377   % IN A LOGICAL-DEVICE NUMBER GROUP TABLE
017377   %
017377   % ENTRY: B=ADDRESS OF DATAFIELD
017377   %        X= LOGICAL NUMBER GROUP TO TEST AGAINST
017377   %
017377   % EXIT:  D=LOGICAL DEVICE NUMBER
017377   %
017377   % EXITA: NO LOGICAL DEVICE NUMBER FOUND
017377   %
017377   INTEGER POINTER LREG2
017400   CFLOGDV: A:=L=:"LREG2":=X SH 6=:D; X:=CNVRT(X)
017406            T:=LOGDBANK; *LDATX
017410            A SH 1+X+1=:L                             % L=LAST ENTRY IN LOGICAL DEVICE NUMBER GROUP
017413            X+1
017414            DO
017414                *LDATX
017415                IF A=B GO LREG2                     % LOGICAL DEVICE NUMBER FOUND
017417                IF X=L THEN MIN "LREG2"; GO LREG2 FI% END OF TABLE
017423                D+1; X+2
017425            OD
017426
017426   %===========================================================================
017426   %            9 G T L O G D V
017426   %
017426   % SUBROUTINE TO FIND LOGICAL DEVICE NUMBER OF A TERMINAL/TAD
017426   %
017426   % CALLED ON MLEV AND ALEV.
017426   % ROUTINE MUST BE CALLED WITH MONITOR LEVEL DISABLED (OR IOF),
017426   % WHEN CALLED FROM LEVEL 1.
017426   % (THIS ROUTINE IS NOT REENTRANT!!)
017426   %
017426   % ENTRY:     B=ADDRESS OF DATAFIELD
017426   %
017426   % EXIT:      NO LOGICAL DEVICE NUMBER FOUND
017426   %
017426   % EXIT+1:    D=LOGICAL DEVICE NUMBER
017426   %
017426   INTEGER POINTER LREG1
017427   9GTLOGDV: A:=L=:"LREG1"
017431          X:=0; CALL CFLOGDV; GO FOUND
017434          X:=10; CALL CFLOGDV; GO FOUND
017437          X:=12; CALL CFLOGDV; GO FOUND
017442          X:=14; CALL CFLOGDV; GO FOUND
017445          X:=15; CALL CFLOGDV; GO FOUND
017450          X:=20; CALL CFLOGDV; GO FOUND
017453          X:=27; CALL CFLOGDV; GO FOUND
017456          X:=30; CALL CFLOGDV; GO FOUND
017461          X:=31; CALL CFLOGDV; GO FOUND
017464          GO LREG1
017465   FOUND: MIN "LREG1"; GO LREG1
017467   RBUS
017471
017471   %=============================================================================
017471   %       ( C )     F I B C K T A B L E
017471   %
017471   % SUBROUTINE TO SEARCH FOR ENTRY IN BACKGROUND TABLE
017471   %
017471   % ENTRY:         X=ADDRESS OF DATAFIELD
017471   %
017471   % EXIT:          ENTRY NOT FOUND
017471   %
017471   % EXIT+1:        ENTRY FOUND IN BACKGROUND TABLE
017471   %
017471   SUBR FIBCKTABLE
017471   FIBCKTABLE:
017471           IF X=0 THEN EXIT FI                 % 0 IS ILLEGAL
017474           X=:D:=0
017476           DO BACKTAB(X) WHILE A><-1
017502              IF A=D THEN X:=D; EXITA FI       % ENTRY FOUND
017506              X+1
017507           OD; X:=D; EXIT                      % ENTRY NOT FOUND
017512   RBUS
017513
017513
017513   %==============================================================================
017513   %       ( C )     G B T I N D X
017513   %
017513   % SUBROUTINE TO FIND THE INDEX OF A TERMINAL/TAD IN PRVTTABLE.
017513   %
017513   % ENTRY:     X=ADDRESS OF DATAFIELD
017513   %
017513   % EXIT:      NOT TERMINAL/TAD
017513   %
017513   % EXIT+1:    A=INDEX IN PRVTTABLE
017513   %
017513   % T,A,D REGISTERS ARE DESTROYED
017513   %
017513   SUBR GBTINDX
017513   INTEGER NTTYS
017514   GBTINDX:IF "BPTMP"=0 THEN EXIT FI
017517           IF X.TYPRING NBIT 5BAD AND A NBIT 5TERM THEN EXIT FI  % NOT TERMINAL/TAD
017525           IF A BIT 5TERM THEN
017527              A:=X-"DT01R"=:D:=0; T:="5TTSZ"; *RDIV ST
017535           ELSE
017536              A:="5TEND"-"5TTST"=:D:=0; T:="5TTSZ"; *RDIV ST
017544              A=:NTTYS                                           % INDEX OF FIRST TAD
017545              A:=X-"BD01R"=:D:=0; T:="5BDSZ"; *RDIV ST
017553              A+NTTYS
017554           FI; IF D><0 THEN EXIT FI
017557           EXITA
017560   RBUS
017567
017567   %=============================================================================
017567   %      ( C )      F P I T S L P R T A B
017567   %
017567   % SUBROUTINE TO SEARCH FOR AN ENTRY IN DTSLPRTAB
017567   % THIS ROUTINE MUS BE CALLED WITH IOF OR MLEV DISABLED IF CALLED
017567   % FROM ALEVL
017567   % ALL REGISTERS EXCEPT B ARE DESTROYED.
017567   %
017567   % ENTRY:     X=PROGRAM
017567   %
017567   % EXIT:      NOT FOUND
017567   %            X=END OF USED PART OF TABLE
017567   %
017567   % EXITA:     FOUND.
017567   %            X=END OF USED PART OF TABLE
017567   %            D=ADDR OF ACTUAL ENTRY
017567   %
017567   SUBR FPITSLPRTAB
017567   INTEGER CFOUND
017570   FPITSLPRTAB:
017570          -1=:CFOUND
017572          X=:D:=DTSLPRTAB; T:=GLTMBANK
017575          DO
017575             *LDATX
017576             IF A=D THEN X=:CFOUND FI
017601             IF A+1=0 THEN
017603                IF CFOUND><-1 THEN A=:D; L+1 FI
017611                EXIT
017612             FI; X+2
017613          OD
017614   RBUS
017616
017616
017616   *"BADAD
"017616   %======================================================================================
017616   %                T A D   R O U T I N E S
017616   %======================================================================================
017616   INTEGER 41ITAD=?,41OTAD=?    % P R E D E C L A R E
017616
017616   %===============================================================================
017616   % (C)   X I S W T A D    X O S W T A D
017616   %       X I S T A D      X O S T A D
017616   %       B I S W T A D    B O S W T A D
017616   %       B I S T A D      B O S T A D
017616   %
017616   % ROUTINES TO PREPARE DATAFIELD ACCESS FOR TAD
017616   % MUST BE CALLED WITH MONITOR LEVEL DISABLED!
017616   %
017616   % XISWTAD:  X = RESIDENT INPUT  DATAFIELD
017616   % XOSWTAD:  X = RESIDENT OUTPUT DATAFIELD
017616   % XISTAD:   X = INPUT  DATAFIELD WINDOW ADDRESS
017616   % XOSTAD:   X = OUTPUT DATAFIELD WINDOW ADDRESS
017616   % RETURN:   X = WINDOW ADDRESS INPUT OR OUTPUT
017616   %
017616   % BISWTAD:  B = RESIDENT INPUT  DATAFIELD
017616   % BOSWTAD:  B = RESIDENT OUTPUT DATAFIELD
017616   % BISTAD:   B = INPUT  DATAFIELD WINDOW ADDRESS
017616   % BOSTAD:   B = OUTPUT DATAFIELD WINDOW ADDRESS
017616   %
017616   % RETURN:   B = WINDOW ADDRESS INPUT OR OUTPUT
017616   %
017616   % COMMON TO ALL, SETS:
017616   %           GLOBAL VAR: 41ITAD  INPUT-DF.  WINDOW  ADDRESS
017616   %                       41OTAD  OUTPUT-DF. WINDOW  ADDRESS
017616   %
017616   SUBR XISWTAD,XOSWTAD,XISTAD,XOSTAD,BISWTAD,BOSWTAD,BISTAD,BOSTAD
017616   TRIPLE TADREG; INTEGER POINTER LREG
017622   XISWTAD: K:=1; GO FELXI
017624   XISTAD:  K:="0"
017625   FELXI:  TAD=:TADREG; A:=L=:"LREG"
017630           IF K THEN CALL XSETBFPAGE FI
017633           X=:41ITAD; X.DFOPP/\1777=:T:=X/\176000+T=:41OTAD
017643           TAD:=TADREG; GO LREG
017645
017645   XOSWTAD: K:=1; GO FELXO
017647   XOSTAD:  K:="0"
017650   FELXO:  TAD=:TADREG; A:=L=:"LREG"
017653           IF K THEN CALL XSETBFPAGE FI
017656           X=:41OTAD; X.DFOPP/\1777=:T:=X/\176000+T=:41ITAD
017666           TAD:=TADREG; GO LREG
017670
017670   BISWTAD: K:=1; GO FELBI
017672   BISTAD:  K:="0"
017673   FELBI:  TAD=:TADREG; A:=L=:"LREG"; X:=:B
017677           IF K THEN CALL XSETBFPAGE FI
017702           X=:41ITAD; X.DFOPP/\1777=:T:=X/\176000+T=:41OTAD
017712           TAD:=TADREG; X:=:B; GO LREG
017715
017715   BOSWTAD: K:=1; GO FELBO
017717   BOSTAD:  K:="0"
017720   FELBO:  TAD=:TADREG; A:=L=:"LREG"; X:=:B
017724           IF K THEN CALL XSETBFPAGE FI
017727           X=:41OTAD; X.DFOPP/\1777=:T:=X/\176000+T=:41ITAD
017737           TAD:=TADREG; X:=:B; GO LREG
017742   RBUS
017747
017747   %=========================================================================
017747   %            C X R E S P    C B E R S P
017747   %
017747   % IF TAD, ROUTINE ACTIVATES DRIVER TO SEND ESCAPE-RESPONSE
017747   % ENTRY: X-REG - RESIDENT INPUT-DATAFIELD (CXRESP)
017747   %        B-REG - RESIDENT INPUT-DATAFIELD (CBERSP)
017747   % THE ROUTINE IS CALLED WITH INTERRUPT OFF
017747   % RETURN EXIT AD1
017747   SUBR CXRESP,CBERSP
017747   INTEGER TREG,XREG
017751   CXRESP: IF X.TYPRING NBIT 5BAD THEN EXITA FI; X=:A; GO FELLS
017757   CBERSP: IF TYPRING NBIT 5BAD THEN EXITA FI; B=:A
017764   FELLS:  *IRW LV10B DB              % B = TAD RESIDENT INPUT DATAFIELD
017765           "BERESP"; *IRW LV10B DT    % T = DRIVER ESCAPE-RESPONSE
017767           "SLV10";  *IRW LV10B DP    % P = LEVEL ACTIVATING POINT
017771           LV10; *MST PID
017773           EXITA
017774   RBUS
017777
017777   %=========================================================================
017777   % (C)  M A C T D R
017777   %
017777   % ROUTINE CALLED FROM MAIL SYSTEM TO ACTIVATE TAD-DRIVER ENTRIES
017777   % ENTRY: X-REG - OUTPUT DATAFIELD, A-REG - WANTED FUNCTION
017777   SUBR MACTDR
017777   MACTDR: *IOF; IRW LV10B DT             % T = FUNCTION TO PERFORM
020001          "SLV10";  *IRW LV10B DP         % P = LEVEL ACTIVATING POINT
020003          A:=X; *IRW LV10B DB             % B = TAD OUTPUT DATAFIELD (RES)
020005          LV10; *MST PID
020007          *ION; EXIT                      % ALLOW DRIVER TO EXECUTE
020011   RBUS
020013
020013   %======================================================================
020013   % (C)  S M A T I M R
020013   %
020013   % SUBROUTINE TO TWMESS TO START SPECIAL MAIL TIMEOUT
020013   % X = TAD OUTPUT DATAFIELD
020013   SUBR SMATIMR
020013   INTEGER LREG
020014   SMATIMR: *IOF
020015          A:=L=:LREG
020017          T:="TMR"; -3; CALL XSTDFADDR              % TIMEOUT IN 3 SEC.
020022          T:="KTMSUB"; "MTDTOU"; CALL XSTDFADDR     % SPECIAL MAIL TIMEOUT
020025          LREG=:L; *ION; EXIT
020031   RBUS
020035
020035   %============================================================================
020035   % (C)   R C T M O D
020035   %
020035   % ROUTINE CALLED FROM TERMODE (SPIT) TO SEND TERMINAL MODE
020035   % X-REG = INPUT DATAFIELD
020035   SUBR RCTMOD
020035   INTEGER POINTER RETAD    % ALWAYS SAME RETURN ADDRESS
020036   RCTMOD: IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"RETAD"
020043           X=:L; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF
020046           A=:CURPROG.ACTPRI; *TRR PCR; ION
020052           MLEV; *MCL PIE
020054           L=:X; CALL XISTAD; CALL CTMOD; 0/\0
020060           "NSPIT+ADPIT+ALEVB+ERNG2"; *IOF
020062           X=:L; A=:CURPROG.ACTPRI; *TRR PCR; ION
020067           MLEV; *MST PIE
020071           L=:X; GO RETAD
020073   RBUS
020100
020100   %============================================================================
020100   % (C)   R C S D A E
020100   %
020100   % ROUTINE CALLED FROM DEFESC (SPIT) TO SEND  CHANGED ESCAPE CHARACTER.
020100   % X-REG = RESIDENT INPUT DATAFIELD
020100   SUBR RCSDAE
020100   INTEGER POINTER RETAD    % ALWAYS SAME RETURN ADDRESS
020101   RCSDAE: A:=L+1=:"RETAD"
020103           X=:L; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF
020106           A=:CURPROG.ACTPRI; *TRR PCR; ION
020112           MLEV; *MCL PIE
020114           L=:X; CALL XISWTAD; CALL CSDAE; 0/\0
020120           "NSPIT+ADPIT+ALEVB+ERNG2"; *IOF
020122           X=:L; A=:CURPROG.ACTPRI; *TRR PCR; ION
020127           MLEV; *MST PIE
020131           L=:X; GO RETAD
020133   RBUS
020140
020140   %============================================================================
020140   % (C)   R C C E S C
020140   %
020140   % ROUTINE CALLED FROM CDESCFU/CEESCFU (SPIT) TO SEND  ENABLE/DISABLE ESCAPE.
020140   % X-REG = RESIDENT INPUT DATAFIELD
020140   SUBR RCCESC
020140   INTEGER POINTER RETAD    % ALWAYS SAME RETURN ADDRESS
020141   RCCESC: A:=L+1=:"RETAD"
020143           X=:L; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF
020146           A=:CURPROG.ACTPRI; *TRR PCR; ION
020152           MLEV; *MCL PIE
020154           L=:X; CALL XISWTAD; CALL CCESC; 0/\0
020160           "NSPIT+ADPIT+ALEVB+ERNG2"; *IOF
020162           X=:L; A=:CURPROG.ACTPRI; *TRR PCR; ION
020167           MLEV; *MST PIE
020171           L=:X; GO RETAD
020173   RBUS
020200
020200   %============================================================================
020200   % (C)   R C S T Y P
020200   %
020200   % ROUTINE CALLED FROM CSTTYP (SPIT) TO SEND  TERMINAL TYPE.
020200   % X-REG = RESIDENT INPUT DATAFIELD
020200   SUBR RCSTYP
020200   INTEGER POINTER RETAD    % ALWAYS SAME RETURN ADDRESS
020201   RCSTYP: A:=L+1=:"RETAD"
020203           X=:L; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF
020206           A=:CURPROG.ACTPRI; *TRR PCR; ION
020212           MLEV; *MCL PIE
020214           L=:X; CALL XISWTAD; CALL CSTYP; 0/\0
020220           "NSPIT+ADPIT+ALEVB+ERNG2"; *IOF
020222           X=:L; A=:CURPROG.ACTPRI; *TRR PCR; ION
020227           MLEV; *MST PIE
020231           L=:X; GO RETAD
020233   RBUS
020240
020240   %============================================================================
020240   % (C)   R B S C P C
020240   %
020240   % ROUTINE CALLED FROM UEADM (SPIT) TO SEND  COMPLETION CODE.
020240   % X-REG = INPUT DATAFIELD
020240   SUBR RBSCPC
020240   INTEGER POINTER RETAD    % ALWAYS SAME RETURN ADDRESS
020241   RBSCPC: A:=L+1=:"RETAD"
020243           X=:L; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF
020246           A=:CURPROG.ACTPRI; *TRR PCR; ION
020252           L=:X; CALL BSCPC
020254           "NSPIT+ADPIT+ALEVB+ERNG2"; *IOF
020256           X=:L; A=:CURPROG.ACTPRI; *TRR PCR; ION
020263           L=:X; GO RETAD
020265   RBUS
020271
020271
020271   *"-BADAD
"020271
020271   %
020271
020271   % ===========================================================================
020271   % 15.16      F I L U S
020271   % INTERFACE ROUTINE TO CALL PLANC SUBROUTINES ON FILE USER SEGMENT
020271   % PARAMETER TRANSFER BY REFERENCE
020271   %
020271   % CALL SEQUENCE:
020271   %      X:=<INDEX TO PLANC ROUTINE>; CALL FILUS; CALL ERROR
020271   %      SKIP RETURN IF NO ERRORS DETECTED
020271   % NOTE:
020271   %      BEFORE CALLING FILUS, REFERENCES TO PARAMETERS MUST BE
020271   %      PLACED ON THE FILE SYSTEM STACK FROM LOCATION CSTCK+24
020271   %      CSTCK: FILE SYSTEM CURRENT STACK POINTER
020271   %
020271   SUBR FILUS
020271
020271          *SDATA
020271
020271   % NOTE:      THIS DISP VARIABLES ARE ALSO DEFINED IN THE ROUTINE
020271   %            TOFENTRY IN RESIDENT (ON FILE SINB-X).
020271   %            DO NOT CHANGE THIS DISP DEFINITIONS WITHOUT DOING
020271   %            THE SAME MODIFICATIONS IN TOFENTRY
020271   %
020271
020271   DISP 0
020271          INTEGER XREG,TREG,AREG,DREG,LREG,BREG
020271          INTEGER OLDSG,WPROG                           % SAVED ON FILE SYSTEM STACK
020271          INTEGER RETUR,PREVB,STPTR,STMAX,LEXIT,ERRCO   % PLANC STACK FRAME
020271   PSID
020271          *DATA ERRCO
020271
020271   INTEGER POINTER TOFENTRY=?         % ENTRY POINT ON FUPIT
020271
020271   % FUNCTION CODES WITH BIT SET REQUIRES A BUFFER FROM SPOOL:
020271   INTEGER ARRAY UFNCO:=(136500,116621,167)
020274
020274   FILUS: *FENTR
020301          A:=X; A SHZ -4:=:X; A/\17 SHZ 3; *BSET ZRO
020307          T:=UFNCO(X); *BSET ONE; ADD (BSKP ONE DT; EXR SA
020313          GO NNEED                    % NO NEED FOR BUFFER
020314          IF SPOOL=0 THEN             % NO BUFFERS FREE
020316             CSTCK+20=:CSTCK          % TRY TO TAKE BUFFER FROM SEQ. OPENED FILE
020321             CALL FOFT; GO NXBUF; CALL RBUF
020324   NXBUF:    CSTCK-20=:CSTCK
020327          FI
020327   NNEED: 0=:LEXIT=:ERRCO             % MAKE PLANC STACK FRAME
020331          "ESTCK"=:STMAX
020333          CSTCK=:STPTR
020335          % GET FILE USER DATA SEGMENT
020335          IF XREG=URTLIOP THEN
020341             A:=507; CALL XLOCK
020343             "5RRUS"=:DRFSG
020345          ELSE
020346             CALL GETFUDSEG; GO FAR NSGSX
020350          FI
020350          A=:T; CALL M1MEXY; T=:OLDSG
020353          % CHANGE PAGETABLE TO FILE USER PAGE TABLE:
020353          RTREF.ACTPRI/\NCLEAR+NFUPIT=:X.ACTPRI; *TRR PCR
020361          % CHECK FILE USER VERSION:
020361          X:="PITST+1"; *BSET ZRO; LDA ,X; BSET ONE
020365          IF A<0 GO FAR XNLO                        % TOO OLD VERSION
020367          IF A/\177400<43000 GO FAR XNLO            % TOO OLD VERSION
020373          IF DRFSG="5RRUS" THEN                     % RT PROGRAM
020377             IF X:="RTRFA"=RTREF GO ASBACK          % ALREADY RUNNING
020403             A:=1730; CALL XLOCK                    % RESERVE RTRFA SEMA
020405             *IOF
020406             CALL RTENTRY; *ION                     % START RTRFA IF PASSIVE
020410             T:=RTREF                               % T-REG MUST BE COPIED CORRECTLY
020411             X:=X.RTDLGADDR; CALL SVRBLK            % COPY REGISTER BLOCK
020413             A:="NSTRT"; T:=0; *STATX               % SET P-REG.
020416             AD:=RTREF.DACTSEG; T:=X.ACTPRI;
020421             AD=:"RTRFA".DACTSEG; T=:X.ACTPRI
020424             0=:X.RSEGM
020425             MLEV; *MCL PIE
020427             X.STATUS BZERO 5WAIT=:X.STATUS
020432             RTREF.STATUS BONE 5WAIT=:X.STATUS
020436             "STUPR"; *IRW MLEVB DP;
020440             MLEV; *MST PID; MST PIE  % RESTARTED HERE AFTER RTRFA HAVE FINISHED
020443             GO XRRT; A:=1730; CALL XUNLOCK; MIN LREG; GO OUT
020450             *)FILL
020506   XRRT:     A:=1730; CALL XUNLOCK; D=:A; GO ERRT
020512   NSTRT:    T=:WPROG                               % NEW ENTRY OF RTRFA
020513             X:=XREG; CALL TOFENTRY; GO EERRT
020516             T:=0; X:=WPROG.RTDLGADDR
020521             *LDATX; AAA 1; STATX                   % INCREMENT P-REG.
020524             GO ENDXX
020525   EERRT:    X:=WPROG.RTDLGADDR; T:=0; *STATX 40    % ERROR CODE IN D-REG.
020531   ENDXX:    RTREF.ACTPRI/\NCLEAR+NFPIT=:X.ACTPRI; *TRR PCR; IOF
020540             WPROG.STATUS BZERO 5WAIT=:X.STATUS     % RESTART WAITING PROCESS
020544             X:=RTREF; 0=:X.ACT1SEG; 5=:X.ACT2SEG
020550             X.STATUS BONE 5WAIT =:X.STATUS
020553             "STUPR"; *IRW MLEVB DP;
020555             MLEV; *MST PID; MST PIE; ION
020561             *JMP I (SRRT4                          % BACK TO FILE SYSTEM
020562          FI
020562   ASBAC: X:=XREG
020563          CALL TOFENTRY; GO ERRT                    % X MUST BE SET
020565          MIN LREG; GO OUT                          % SKIP RETURN IF NO ERRORS
020567   ERRT:  IF A=-1 THEN
020572   XNLO:     A:=ER161                               % FILE USER NOT CORRECTLY LOADED
020573          FI; A=:AREG
020574   OUT:   % GET BACK FILE SYSTEM SEGMENT(S):
020574          T:=OLDSG; CALL M1MEXY
020576          % CHANGE PAGE TABLE TO FILE SYSTEM PIT:
020576          RTREF.ACTPRI/\NCLEAR+NFPIT=:X.ACTPRI; *TRR PCR
020604          IF XREG=URTLIOP THEN A:=507; CALL XUNLOCK; FI
020612   OUT2:  *FLEAV
020614   NSGSX: A=:AREG; GO OUT2
020616   INTEGER POINTER TOFENTRY:=PITST
020617   RBUS
020632
020632   %===============================================================================
020632   %          G E T F U D S E G
020632   %          GET FILE USER DATA SEGMENT
020632   %
020632   %  RETURN:         ERROR: NO SEGMENTS AVAILABLE
020632   %  SKIP RETURN:    SEGMENT NUMBER STORED IN FUDSG
020632   %
020632   SUBR GETFUDSEG
020632   INTEGER ARRAY POINTER RFRES:=RFSTB      % RFA DATA SEGMENT RESERVE TABLE
020633   INTEGER POINTER NMSEGS:=NRFSG           % NUMBER OF RFA DATA SEGMENTS
020634   %
020634   GETFUDSEG:
020634          IF BACKGR=0 OR RTREF.ACT2SEG=5ERRSEG THEN
020643             % RT PROGRAM OR RTOPEN, RTCONNECT, RTCLOSE,LIST-RTOPEN OR RTRES-O-F-E
020643             A:="5RRUS"         % RT PROGRAM
020644          ELSE
020645             IF XDRFSG=0 THEN
020647                *IOF                                                            %%%%%%%%%%%%%%%%%%%%%
020650                FOR X:=0 TO NMSEGS-1 DO                                         %%                 %%
020655                   IF RFRES(X)=0 GO SFNDX; X=:T:=A  % SEGMENT IS FREE TO USE    %%  MUST NOT CROSS %%
020661                   IF X.WLINK=0 AND X.TLINK=0 AND X.STATUS NBIT 5RWAIT THEN     %%  A PAGE BORDER  %%
020670                      T=:X; GO SFNDX   % PROGRAM IS PASSIVE, TAKE SEGMENT       %%                 %%
020672                   FI; T=:X                                                     %%                 %%
020673                OD; *ION                                                        %%                 %%
020676                % ALL SEGMENTS ARE RESERVED                                     %%                 %%
020676                A:=ER188; EXIT                                                  %%                 %%
020700   SFNDX:       RTREF=:RFRES(X); 0=:INSFG; A:="DSSNM"+X; *ION                   %%%%%%%%%%%%%%%%%%%%%
020706                A=:XDRFSG
020707             FI
020707          FI    % A-REG: RFA DATA SEGMENT NUMBER
020707          A=:DRFSG; EXITA
020711   RBUS
020720
020720   %===========================================================================
020720   %            S V R B L K
020720   %
020720   % SUBROUTINE TO SAVE THE REGISTER BLOCK
020720   %
020720   % ENTRY:     X=ADDRESS WHERE THE REGISTER BLOCK WILL BE SAVED
020720   %
020720   SUBR SVRBLK
020720   SVRBLK: *PIOF; SRB 10; PION
020723           EXIT
020724   RBUS
020724
020724   *"-8RFAC
"020724
020724   %===========================================================================
020724   %            C H L A M
020724   %      CHECK IF A LOGICAL PAGE INTERVAL IS WITHIN A LAMU
020724   %      RETURNS WITH INTERRUPT ON
020724   %      ENTRY:    T = FIRST LOGICAL PAGE
020724   %                D = LAST LOGICAL PAGE
020724   %                A = RT DESCR
020724   %      EXIT:     NOT WITHIN A CONNECTED LAMU
020724   %      EXIT+1:   OK.   A = PHYSICAL START PAGE OF BUFFER WITHIN LAMU
020724
020724   SUBR CHLAM
020724
020724   INTEGER FPAGE, LPAGE         % FIRST & LAST LOGICAL INTERVAL
020726   INTEGER CACLE                % CURRENT ACTIVE LAMU ELEMENT
020727   INTEGER SAVX
020730   INTEGER LC                   % LOOP COUNTER
020731
020731   CHLAM:
020731          *IOF
020732          X=:SAVX; T=:FPAGE:=D=:LPAGE:=5RTSIZE; A-RTSTART=:D:=0; *RDIV ST
020743          A*GNLPRT*ALMSZ+LAMACT=:CACLE; 0=:LC
020750          FOR LC TO GNLPRT-1 DO
020755                A*ALMSZ+CACLE=:X; T:=LAMBANK; *LDDTX
020762                IF A >< 0 THEN                 % A= LAM ID, D= LOG PAG
020763                   IF A > 0 THEN
020765                     A*LDTSZ+LAMDT
020767                   ELSE
020770                     A-*SDTSZ+SYLDT
020773                   FI A=:X; *LDATX LMNP
020775                   A+D-1
020777                   IF T:=LPAGE <<= A AND FPAGE >>= D THEN
021005                      A-D=:D; T:=LAMBANK; *LDATX LMPP
021011                      A+D; L+1; GO CHLRE
021014                   FI
021014                FI
021014          OD
021020   CHLRE: X:=LPAGE=:D:=SAVX; *ION
021024          EXIT
021025   RBUS
021036
021036   %==============================================================================
021036   %            C O L A M       C L L A M
021036   %      COPY AND CLEAR LAMU
021036   %      ENTRY COLAM:    A = SOURCE RT PROG
021036   %                      X = DESTINATION RT PROG
021036   %      CLLAM:          A = RT PROGRAM
021036
021036   SUBR COLAM, CLLAM
021036   INTEGER LREG,SAVA
021040   COLAM:
021040          A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
021045          A*GNLPRT*ALMSZ+LAMACT; A:=:X; A-RTSTART=:D:=0; *RDIV ST
021055          A*GNLPRT*ALMSZ+LAMACT=:T; A:=GNLPRT:=:L=:LREG; L+L
021065          X=:D:=LAMBANK=:A; *MOVPP
021071          LREG=:L
021073          EXIT
021074   %
021074   % MUST BE CALLED WITH MLEV DISABLED
021074   %
021074   CLLAM:
021074          A=:D;       *IOF
021076          A:="1CLAM"; *IRW SLEVB DP
021100          A:=SLEV   ; *MST PID; ION
021103          A:=D-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
021111          A*GNLPRT*ALMSZ+LAMACT=:X; GNLPRT*ALMSZ+X-1=:D:=0; T:=LAMBANK
021124          DO WHILE X <<= D
021126                *STATX
021127                 X+1
021130          OD
021131          EXIT
021132   RBUS
021140   SUBR LAMDISCONNECT
021140   %=================================================================
021140   % DISCONNECT ALL LAMUS FROM THE CALLING PROGRAM
021140   % CALLED FROM ESCAPE HANDLING ,MON 0  AND BATCH I/O
021140   %
021140   *"
"021140   LAMDISCONNECT:
021140   *"8ADP
"021140          IF MAILCON\/RUNLAMU><0 THEN         % RESET CONNECTED LAMUS FOR MON ADP.
021143              T:=14; *MON 2ADP
021145          FI
021145   *"
"021145          A:="LAMD9"; *MON 2LAMU; MON 2ERMS
021150   EXIT
021151   RBUS
021154   SUBR LAMINHIBIT,LAMENABLE,LAMEENABL
021154   %===================================================================
021154   % SUBROUTINE TO SET/RESET LAMU INHIBIT FLAG
021154   % A= RTPROG
021154
021154   LAMINHIBIT:X:=1;GO FELLS
021156   LAMEENABL: X:=0;K:="0";GO FELL
021161   LAMENABLE: X:=0
021162   FELLS:K:="1"
021163   FELL:
021163     A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
021170     A+LAMIH:=:X;     T:=LAMBANK; *STATX     % LAMU INHIBITED FOR THIS PROGRAM
021174     IF K THEN
021176       "STUPR"; *IOF; IRW MLEVB DP
021201       MLEV; *MST PID; MST PIE; ION
021205     FI
021205     EXIT
021206   RBUS
021212   *"8UDMA+8VICO
"021212   SUBR CXCFR
021212   % =========================================================================
021212   % SUBROUTINE TO CALL XCSGM ON FPIT FOR RT-PROG
021212   % OFLCK MUST BE LOCKED BEFORE CALLING
021212   % =========================================================================
021212   INTEGER SAVA,SAVX,CCPCR
021215   INTEGER POINTER LREG
021216   SYMBOL NNPCR=ADPIT+NFPIT+ALEVB+ERNG2
021216   CXCFR: A=:SAVA:=L=:"LREG";X=:SAVX
021222          CURPROG.ACTPRI=:CCPCR;
021225          A:=NNPCR;          *IOF
021227          A=:CURPROG.ACTPRI; *TRR PCR; ION  % NPIT= FPIT, APIT=DPIT
021233          X:=SAVX; A:=SAVA; CALL XCSGM; GO L1; MIN "LREG"; 0/\0
021241   L1:    A=:SAVA; X=:SAVX; A:=CCPCR; *IOF
021245          A=:CURPROG.ACTPRI; *TRR PCR; ION
021251          X:=SAVX; A:=SAVA; GO LREG
021254   RBUS
021257   *"8NSDB
"021257   % =========================================================================
021257   %  C A B L O O K
021257   %  ROUTINE TO CALL ABLOOK ON SPIT
021257   %  CALLED FROM DEBUGGER MONITOR CALL ONLY
021257   %
021257   % LOCAL VARIABLES IN THIS ROUTINE ARE PROTECTED BY
021257   % RESERVATION OF DEBUGGER'S DATAFIELD
021257   % ENTRY: B= BFIELD
021257   %        X= REENTRANT TABLE
021257   %        ACT1SEG= COMSEG
021257   %        ACT2SEG= SYST.SEG
021257   % EXIT:  B= BFIELD
021257   %        A= ABLOOK FLAG
021257   %        T= TABLE ELEMENT ADRESS IF MATCH FOUND
021257
021257   SUBR CABLOOK
021257   INTEGER DBOPCR
021260   INTEGER POINTER DBLREG,PABLOOK:=ABLOOK
021262   SYMBOL NNPCR=ADPIT+NSPIT+ALEVB+ERNG2
021262   CABLOOK:A:=L=:"DBLREG"
021264           X=:D            % SAVE PARAMETER TO ABLOOK
021265           A:=CURPROG.ACTPRI=:DBOPCR
021270           A:=NNPCR
021271           *IOF
021272           A=:CURPROG.ACTPRI
021274           *TRR PCR
021275           *ION            % NPT=SPIT ; APT=DPIT
021276           D=:X            % UNSAVE PARAMETER
021277           CALL PABLOOK    % RETURN PARAMETERS: A AND T
021300           IF A=0 THEN     % MATCH FOUND
021301               *1BANK
021302               T:=T.S2=:D  % START ADDRESS IN D
021305               T:=X.S1     % SEGMENT NUMBER IN T
021306               *2BANK
021307           FI
021307           A=:L
021310           A:=DBOPCR
021311           *IOF
021312           A=: CURPROG.ACTPRI
021314           *TRR PCR
021315           A:=L
021316           GO DBLREG
021317   RBUS
021321   *"
"021321   *"8DLP1+8DLP2+8DVE1+8DVE2
"021321   %==============================================================================
021321   %      ( C )     D M L P C
021321   %
021321   % CLEAR-DEVICE  SUBROUTINE FOR LINE-PRINTER AND VERSATEC
021321   %
021321   SUBR DMLPC
021321   DMLPC: *IOF
021322          T:=HDEV+"DCONT"; 20; *EXR ST
021326          0=:CXBHOLD=:CXHENTE=:XCBHOLD=:XCHENTE
021332          IF RTRES><0 THEN L=:D; CALL XRTACT; L:=D; FI
021337          *ION; EXIT
021341   RBUS
021342
021342   *"8NLP1+8NLP2+8NLP3+8NLP4
"021342   %=============================================================================
021342   %       D M C L P R
021342   %
021342   % CLEAR-DEVICE SUBROUTINE FOR NEW DMA LINE PRINTER
021342   %
021342   SUBR DMCLPR
021342   DMCLPR: *IOF
021343           T:=HDEV+5; A:=20; *IOXT                     % CLEAR DEVICE
021347           IF RTRES><0 THEN L=:D; CALL RTACT; D=:L FI  % RESTART WAITING PROGR
021354           *ION; EXIT
021356   RBUS
021357   *"
"021357
021357   *"8XMSG
"021357
021357
021357   %**********************************************************************
021357   %
021357   %      X M S G  -  R E S I D E N T    P A R T
021357   %
021357   %      LINKAGE BETWEEN THE RESIDENT AND KERNEL(XPIT) CODE
021357   %      IS VIA SYMBOL-2-LIST.
021357   %
021357   %*************************************************************************
021357
021357   *XXRPT=177777 % Set flag indicating that XMSG has been generated (8XMSG)
021357
021357   %============================================================================
021357   % 35.38      X R T E N
021357   %
021357   %      X R T E N    -   R E S T A R T    R T     F R O M    R T  W A I T
021357   %
021357   %============================================================================
021357   SUBR XRTEN,XXMENT
021357   % THIS ROUTINE IS CALLED ON LEVEL 5 TO DO AN RTENTRY ON RT-PROG IN A-REG
021357   INTEGER HOME
021360   INTEGER SAVA
021361
021361   XRTEN: *2BANK
021362          *IOF
021363          T:=L=:HOME; X:=0                          % A=RT-DESC ADDRESS
021366          DO WHILE 0><XRTDS(X); IF A=T GO OUT; X+1; OD % FIND END; CHECK NOT THERE
021375          A=:XRTDS(X); X+1; 0=:XRTDS(X)               % INSERT IN TABLE
021400          IF X=1 THEN X:="XDFLD":=:B; CALL XRTACT; X:=:B; FI % PUT IN MONITOR QUEUE
021407   OUT:   *1BANK
021410          T:=HOME; *ION
021412          T=:P                                               % EXIT
021413
021413   % MFUNC ROUTINE EXECUTED ON MONITOR LEVEL
021413   XXMENT: X:=0; T:=0; *IOF                                  % LOCK OUT LEVEL 5
021416          DO WHILE XRTDS(X)><0; X+1; A=:T; OD                % FIND LAST ELEMENT
021423          IF T><0                                            % WAS THERE ANY
021423          THEN X-1; 0=:XRTDS(X); *ION                        % CLEAR HIS ENTRY
021430               A=:SAVA; T=:X
021432               IF X.STATUS BIT 5WAIT AND A BIT 5XMSY THEN    % SET IN I/O WAIT BY XMSG
021437                  A BZERO 5WAIT BZERO 5XMSY=:X.STATUS        % RESET STATUS
021442                  A:=SAVA
021443               ELSE
021444                  A:=SAVA; CALL RTENTRY                      % START HIM,
021446               FI                                            % AND TRY NEXT ONE
021446               GO XXMENT
021447          FI; *ION
021450          GO STUPR
021451   RBUS
021457
021457   *"8XMSG+8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"021457
021457
021457   %
021457   %==============================================================================
021457   %
021457   % 35.39   D A T A    C O P Y I N G:   X M S G / P I T 3,  H D L C,  X 2 1
021457   %
021457   %==============================================================================
021457   %
021457   SUBR Z2PHY,Z2USR
021457
021457   % Routines to transfer data between a user V.S. and physical memory. They
021457   % assume that everything has been set up so that only the 0 bit in the status
021457   % register needs to be turned on to allow access via the APT to the user data
021457   % area.
021457
021457   % On entry: D contains the byte count and B points to the parameter block:
021457   DISP 0
021457         INTEGER ZXUBF          % Buffer address in user's logical space
021457         INTEGER ZXSBK,ZXSBF    % Physical buffer address (Bank, Displacement)
021457         DOUBLE ZXSAD=ZXSBK
021457         INTEGER POINTER ZXHOM  % Scratch location used to save L-register
021457   PSID
021457   *APTON=BSET ONE; APTOF=BSET ZRO  % Enable/disable alternative page table
021457
021457   Z2PHY: D SHZ -1                                  % Convert to word count
021460          IF M                                      % Odd byte count?
021460          THEN X:=ZXUBF+D; *APTON; LDA 0,X; APTOF   % Get via APT
021467               A/\177400                            % Maskout r.h. byte
021470          FI; T:=ZXSBK; X:=ZXSBF; A:=:L=:"ZXHOM"    % Get physical addr
021474          IF M                            % Odd count?
021474          THEN X+D; *LDATX 0                        % Get last word
021500               A/\377\/L; *STATX 0                  % Mask in lh byte and store
021503               X-D
021504          FI; ZXUBF:=:D; *APTON                     % TX=Destn addr; D=Useraddr
021507          X:=:T                                     % XT=Destn address
021510          DO A=:L:=4000:=:L; WHILE A>0              % A=No of words left,L=4000
021515                *SKP IF DA GRE SL; COPY SA DL       % Skip if more than 4000?
021517                A-L; * MOVAP;                       % A=No of words left
021521          OD;
021522          GO OUT
021523
021523   Z2USR: D SHZ -1;                                 % Convert byte count to words
021524          IF M                                      % Odd byte count?
021524          THEN X:=ZXSBF+D; T:=ZXSBK; *LDATX 0       % Get last word in physbuff
021532               A SHZ -10; D SHZ 1=:X; T:=ZXUBF;     % Mask & get user buffer addr
021536               *APTON; SBYT; APTOF                  % Enable APT & store
021541               GO Z2USR                             % Try again (even byte count)
021542          FI;
021542          D=:X; T:=L=:"ZXHOM":=ZXUBF; ZXSAD; *APTON % AD=Physical, X=count, T=user
021550          DO X=:L:=4000:=:L; WHILE X>0              % X=No of words left,L=4000
021555                *SKP IF DX GRE SL; COPY SX DL       % Skip if more than 4000?
021557                X-L; * MOVPA;                       % X=No of words left
021561          OD;
021562   OUT:   * APTOF                                   % Switch off access to APT
021563          GO ZXHOM
021564   *)KILL APTON APTOF
021564   RBUS
021570
021570   SUBR ZDALTON
021570   INTEGER XREG,LREG; REAL TADREG
021575   % OLDPAGE IN D-REG.
021575   ZDALTON:
021575          TAD=:TADREG; X=:XREG
021577          T:=3600/\D
021601          CURPROG.ACTPRI/\ACLEAR\/T
021605   OUT:   A=:X.ACTPRI; *TRR PCR
021607          TADREG; X:=XREG
021611          EXIT
021612   RBUS
021615
021615   %============================================================================
021615   %
021615   % 35.40  X M S G / H D L C    I N T E R F A C E  : S T A R T    D R I V E R
021615   %
021615   %============================================================================
021615   SUBR ZXS12,ZXS13
021615   INTEGER POINTER HOME
021616   ZXS12: A:=L=:"HOME"; *IOF                        % X->DCB, B->HDLC DATAFIELD
021621          CALL ICHAIN; CALL ACT12; GO UT            % CHAIN TO HDLC AND KICK HIM
021624
021624   ZXS13: A:=L=:"HOME"; *IOF                        % X->DCB, B->HDLC DATAFIELD
021627          CALL ICHAIN; CALL ACT13;                  % CHAIN TO HDLC AND KICK HIM
021631
021631   UT:    *ION;
021632          GO HOME
021633   RBUS
021636
021636   *"-8XMSG
"021636   *"8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"021636   %===============================================================================
021636   %      A C T 1 2      A C T 1 3
021636   %      ROUTINES FOR ACTIVATION OF DRIVER PART
021636   %
021636   SUBR ACT12,ACT13
021636   ACT12: IF WAKEF = 1 THEN EXIT FI
021643          T:="STDRIV"; D:=L; CALL STL12; D=:P                 %*80B*
021647   %
021647   %
021647   ACT13: IF WAKEF = 1 THEN EXIT FI
021654          T:="STDRIV"; D:=L; CALL STL13; D=:P                 %*80B*
021660   RBUS
021662
021662
021662
021662   %      START LEVEL 12/13 AT ADDRESS IN T-REG
021662   %      B-REG FROM CALLING LEVEL IS COPIED
021662   %      RETURN TO CALLER WITH IOF
021662
021662   SUBR STL12                                       %*80B*
021662   STL12: "SLV12"; *IOF; IRW LV12B DP               %*80B*
021665          A:=B; *IRW LV12B DB                       %*80B*
021667          A:=T; *IRW LV12B DT                       %*80B*
021671          LV12; *MST PID; ION; IOF; EXIT            %*80E*
021676   RBUS                                             %*80B*
021700   SUBR STL13                                       %*80B*
021700   STL13: "SLV13"; *IOF; IRW LV13B DP               %*80B*
021703          A:=B; *IRW LV13B DB                       %*80B*
021705          A:=T; *IRW LV13B DT                       %*80B*
021707          LV13; *MST PID; ION; IOF; EXIT            %*80B*
021714   RBUS                                             %*80B*
021716
021716
021716
021716
021716   %=======================================================================
021716   % 39.14     I C H A I N    O C H A I N
021716   %      HDLC - CHAINING ROUTINES
021716   %
021716   %
021716   %PURPOSE: ENTER OR REMOVE ENTRIES IN THE DRIVER QUEUE
021716   %
021716   %METHOD:     THE QUEUES ARE ARRANGED AS FIFOS.
021716   %            THE LINKING IS ONE WAY ONLY.
021716   %            0 IN THE LINKWORD IS USED T MARK END OF QUEUE.
021716   %            THE HEAD OF THE QUEUES IS IN THE APPROPRIATE DATAFIELD.
021716   %            IQUEU FOR INPUT, AND OQUEU FOR OUTPUT.
021716
021716   %            CHANGED FOR I VERSION:
021716   %            THE QUEUES MAY NOW APPEAR OUTSIDE BANK 0
021716   %            THE "MASTB" LOCATION IN DATAFIELD HOLDS THE BANK NUMBER
021716
021716   %ICHAIN: SET MESSAGE IN INPUT QUEUE (TO DRIVER)
021716   %OCHAIN: SET MESSAGE IN OUTPUT QUEUE (FROM DRIVER)
021716   %
021716   %ENTRY:  B-REG   DATAFIELDPOINTER
021716   %        X-REG   MESSAGEPOINTER (ICHAIN ONLY)
021716   %
021716   %EXIT:   B-REG   DATAFIELDPOINTER
021716   %        X-REG   MESSAGEPOINTER (OCHAIN ONLY)
021716   %
021716   SUBR ICHAIN,OCHAIN
021716   ICHAIN: IF IQUEU =0 THEN                                   % AM I ALONE ?
021720             X=:IQUEU; T:=MASTB; * BCHAI@3 STATX              % YES, 0 IN NEXT POINTER
021723             EXIT
021724           FI
021724           GO ICOC                                            % NO, LINK IN AT END OF LIST
021725   OCHAIN: T:=MASTB; * BBID@3 LDATX
021727           IF A < 0 THEN                                      % DOES DCB BELONG TO XMSG
021730              * XCHAI@3 LDATX                                 % YES
021731              IF A >< 0 THEN
021732                 * ION; COPY SA DP                            % GOTO ROUTINE SPECIFIED IN DCB
021734              FI
021734              EXIT                                            % PART OF CLEARING SEQUENCE EXECUTED
021735           FI
021735           IF ISTATE >< 0  THEN L=:D; CALL RTACT; D=:L; FI
021742           IF OQUEU =0 THEN                                   % AM I ALONE?
021744             X=:OQUEU; T:=MASTB; * BCHAI@3 STATX              % YES, 0 IN LINK WORD
021747             EXIT
021750           FI
021750   ICOC: X=:D:=A; T:=MASTB
021753      DO WHILE A >< 0
021754          A=:X; * BCHAI@3 LDATX
021756      OD
021757          A:=D; * BCHAI@3 STATX                     % LINK IN AT END OF LIST
021761          A=:X:=0; * BCHAI@3 STATX                  % 0 AT END OF LIST
021764          EXIT
021765   RBUS
021766
021766   %=======================================================================
021766   % 39.15     D I C H A I N    D O C H A I N
021766   %
021766   %DICHAIN: REMOVE OLDEST ENTRY FROM INPUT QUEUE (TO DRIVER)
021766   %DOCHAIN: REMOVE OLDEST ENTRY FROM OUTPUT QUEUE (FROM DRIVER)
021766   %TSTCH:   ANY MESSAGE IN DRIVER QUEUE.
021766   %
021766   %ENTRY:  B-REG  DATAFIELDPOINTER
021766   %
021766   %EXIT:   B-REG  DATAFIELDPOINTER
021766   %        X-REG  MESSAGEPOINTER
021766   %
021766   %        SKIP RETURN - MESSAGE FOUND
021766   %        NO SKIP     - EMTY QUEUE
021766   %
021766   SUBR DICHAIN,DOCHAIN,TSTCH
021766   TSTCH:   IF IQUEU><0 THEN EXITA FI EXIT
021772   DICHAIN: IF IQUEU =0 THEN 0=:WAKEF; EXIT FI
021776            X:=A; T:=MASTB; * BCHAI@3 LDATX
022001            A =:IQUEU; 1=:WAKEF; EXITA;
022005   DOCHAIN: IF OQUEU =0 THEN
022007                IF DDD4 = 0 THEN -1=:ISTATE FI
022013                EXIT
022014            FI
022014            X:=A; T:=MASTB; * BCHAI@3 LDATX
022017            A=:OQUEU; 0=:ISTATE; EXITA;
022022   RBUS
022022   *"
"022022   %=========================================================================
022022   %      I N B X 2 1
022022   %
022022   % SUBROTINE TO SET UP THE PHYSICAL ADDRESS OF THE "X21-BUFFERS" INTO
022022   % THE "X21" DATAFIELDS
022022   %
022022   % CALLED FROM OLDSTART
022022   %
022022   SUBR INBX21
022022
022022   INTEGER ARRAY ADRX21(0)
022022   *"8C1X2
"022022   *      X21F1;X2S01;X2E01
022025   *"8C2X2
"022025   *      X21F2;X2S02;X2E02
022030   *"8C3X2
"022030   INTEGER ARRAY EAX21(0)
022030   *"8C1X2+8C2X2+8C3X2+8C4X2+8C5X2+8C6X2
"022030   INTEGER CNDX,CADR,16BADR; DOUBLE DCAD=CADR
022033   DISP 0; TRIPLE FS0; PSID
022033   *"
"022033   INBX21:
022033   *"8C1X2+8C2X2+8C3X2+8C4X2+8C5X2+8C6X2
"022033          X:="ADRX21"=:CNDX
022035          DO WHILE CNDX<<"EAX21"
022041             MPTPHPAGE=:D
022043             A:=0; AD SHZ 12=:DCAD; *1BANK
022047             TAD:=CNDX.FS0; *2BANK
022052             X:=T; A:=:D; A-D-1 SH 1=:X.MAX
022060             A:=D-"PITST"+16BADR=:X.BUFST
022064             CADR=:X.MASTB; CNDX+3=:CNDX
022071          OD
022072   *"
"022072          EXIT
022073   RBUS
022077
022077
022077   *"8MT1+8MT2+8MT3+8MT4
"022077   %==============================================================================
022077   %     ( C )       M T C L D
022077   %
022077   % ROUTINE TO PERFORM CLEAR-DEVICE ON MAGTAPE, CALLED
022077   % FROM THE COMMAND @CLEAR-DEVICE
022077   % EXECUTED ON ALEVL
022077   %
022077   SUBR MTCLD
022077   INTEGER CCPCR
022100   MTCLD: *IOF
022101          HDEV+"164000+5"=:T; 20=:HSTAT; *EXR ST
022107   *"8MT1+8MT2+8MT3+8MT4 8DTMT
"022107          IF RTRES><0 THEN L=:D; CALL XRTACT; L:=D FI
022114          *ION; EXIT
022116   RBUS
022120
022120   *"8DMVC
"022120
022120
022120   %==============================================================================
022120   %      ( C )   V D M A C
022120   %
022120   %
022120   % @CLEAR-DEVICE  ROUTINE FOR VERSATEC (DMA)
022120   %
022120
022120   SUBR VDMAC
022120
022120   VDMAC: *IOF
022121          HDEV+"164000+5"=:T; 20=:HSTAT; *EXR ST
022127          IF RTRES><0 THEN L=:D; CALL RTACT; L:=D; FI
022134          *ION; EXIT
022136   RBUS
022140
022140
022140   *"8CRD+8CRD2
"022140
022140
022140   @DEV 1
022140   @DEV (S-S-L)CC-P2-N500:NPL
022140

022140   *"8N500
"022140   %==========================================================================
022140   %
022140   %       N D - 5 0 0   R O U T I N E S
022140   %
022140   %===========================================================================
022140
022140   %===========================================================================
022140   %       ( C )     F S E M A
022140   %
022140   % CHECK IF THE PROGRAM HAS RESERVED A ND-500 PROCESS
022140   % ENTRY:     D=RT-DESCRIPTION ADDRESS
022140   %            WHEN CALLED FROM LEVEL 1, THEN  FSEMA MUST BE CALLED WITH
022140   %            INTERRUPT OFF OR WITH MONITOR LEVEL DISABLED
022140   % EXIT:      THE PROGRAM HAS NOT RESERVED ANY ND-500 PROCESS
022140   % EXIT+1:    X=PROCESS DESCRIPTION OF THE RESERVED ND-500 PROCESS
022140   %
022140   SUBR FSEMA
022140   FSEMA: X:="BRESLINK"+D
022142          DO WHILE X:=X.RESLINK><D
022145             IF X>>="S500S"+5PRDSIZE AND X<<"S500E" THEN EXITA FI
022155          OD; EXIT
022157   RBUS
022162
022162
022162   %=============================================
022162   %      ( C )   E S C 5 O N
022162   %
022162   % USER LEVEL - SUBROUTINE TO ESCON IN SINTRAN III
022162   %
022162   % ENTRY: X=TERMINAL DATAFIELD
022162   %        A=FLAGB
022162   %        CALLED WITH INTERRUPT OFF
022162   %
022162   % EXIT:  EXIT FROM ESCON. A=FLAGB IN TERMINAL DATAFIELD
022162   %
022162   % EXIT +1 : CONTINUE IN ESCON
022162   %
022162   %
022162   SUBR ESC5ON
022162   INTEGER CXREG,CCFLAGB
022164   ESC5ON: A=:CCFLAGB:=X.RTRES=:D+"BRESLINK"                  % D: RESERVING PGM; A:THE RESERVATION QUEUE HEADER IN RT DESC
022170          X=:CXREG                                            % SAVE X
022171          DO WHILE A.RESLINK<<"S500S" OR A>>="S500E"          % SEARCH RESARVATION QUEUE UNTIL N500 PROCESS FOUND
022201             IF A=D THEN X:=CXREG; EXITA FI
022205          OD
022206          T:=5MBBANK; X:=A.MESSBUFF; *AAX 5MSFL; LDATX
022213          IF A BIT 5IBRK THEN CCFLAGB; X:=CXREG; EXIT FI      % HAS ESCAPE/BREAK BEEN TYPED?
022220          "ESC500"; *IRW MLEVB DP                             % START IN ESC500 ON MONITOR LEVEL
022222          CXREG; *IRW MLEVB DB                                % B-REG ON MONITOR LEVEL IS INPUT DATAFIELD
022224          MLEV; *MST PID
022226          X:=CXREG; CCFLAGB BONE 5ESCON; EXIT                 % SET ESCAPE ON BEFORE EXIT
022232   RBUS
022237
022237
022237   SUBR FESC1
022237   RBUS
022237
022237   %==========================================================================
022237   %      ( C )       5 B A B O R T
022237   %
022237   % SUBROUTINE CALLED FROM THE ABORT-BATCH AND ABORT-JOB COMMANDS
022237   % FOR START CLEANING-UP (LOG-OFF), ND-500 PROC.
022237   % CALLED ON SPIT; CONTINUES ON 5PIT IF ND-500.
022237   %
022237   SUBR 5BABORT,M5BABORT
022237   5BABORT:  RTREF+"BRESLINK"
022241          DO WHILE A.RESLINK<<"S500S" OR A>>="S500E"
022251             IF A=RTREF THEN EXIT FI
022255          OD; A=:D
022257          "N5PIT+ADPIT+ALEVB+ERNG2"
022260          A=:RTREF.ACTPRI; *TRR PCR                 % SWITCH TO 5PIT
022263          T:=5MBBANK; X:=D.MESSBUFF                % X=ND-500 MESSAGE ADDR
022266          A:=L; *AAX LRET; STATX                    % ADDR TO RETURN TO AFTER CLEANING-UP
022271          A:=B; *AAX 5BRG-LRET; STATX               % SAVE B, FOR RESTORING WHEN RETURNING AFTER CLEANING-UP
022274          *AAX XADPR-5BRG; LDXTX                    % X=PROCESS DESCRIPTION
022276          A:=1                                      % INDICATE ABORT-JOB/ABORT-BATCH
022277          GO FESC1                                  % CONTINUE IN FROMESC ON 5PIT
022300
022300   % MONITOR LEVEL
022300   % ALEVL.XREG IS RETURN ADDR
022300   M5BABORT: "NSPIT+ADPIT+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR
022304           *IRR ALEVB DX; IRW ALEVB DP
022306           GO MONEN
022307   RBUS
022320
022320
022320   %===============================================================================
022320   %       ( C )    C A L L R O U T
022320   %
022320   % Routine to call a routine on another pit
022320   %
022320   % Entry:     T=routine number (index into routine vector)
022320   %
022320   % On entry DPIT must be alternative pit.
022320   % The D- and T-register are destroyed.
022320   % On calling the routine the D-register holds the original return address
022320   %
022320   SUBR CALLROUT,R5PIT,RRPIT,RMPIT
022320   INTEGER TREG,AREG,XREG,CLVL
022324   CALLROUT: A=:D; *TRA STS; IOF; BLDA 170 DA       % Read status register and set interupt on/off in K-bit
022330         T=:TREG:=D=:AREG; X=:XREG                  % Store current registers
022334         A SH -5/\170=:CLVL; *TRA PGC               % Read PCR on current level
022340         A/\74000=:D                                % T=normal pit when called
022342         TREG*2; GOVECTOR(A)                        % Get normal pit depending on routine to call
022346         IF A><D THEN                               % Current normal pit different than wanted?
022350            A=:T:="ADPIT+ERNG2"\/CLVL; T\/A         % Set new normal pit
022354            CLVL-ALEVB:=:T
022357            IF T=0 THEN A=:RTREF.ACTPRI FI; *TRR PCR
022364            A:=D SH -13/\17; RETVECTOR(A)           % Get return point depending on normal pit when called
022371            L=:D:=A                                 % D=original return address; L=retrun address within CALLROUT
022373         FI
022373         TREG*2+1; T:=GOVECTOR(A)                   % Get address of routine to call
022400         AREG; X:=XREG                              % Restore A- and X-register
022402         IF K THEN                                  % Turn interrupt on if call in ion
022404            *ION
022405         FI; T=:P                                   % Call routine
022406
022406   R5PIT: P+1; D+1; T:="N5PIT"; GO RRCOM
022412   RMPIT: P+1; D+1; T:="NMPIT"; GO RRCOM
022416   RRPIT: P+1; D+1; T:="NRPIT"
022421   RRCOM: D=:L:=A                                   % Restore original return address in L-reg
022423          *TRA STS; IOF; BLDA 170 DA                % Read status register and set interupt on/off in K-bit
022426          A SH -5/\170\/"ADPIT+ERNG2"; T\/A         % Set PCR back to original
022432          A/\170-ALEVB:=:T
022435          IF T=0 THEN X=:T; A=:RTREF.ACTPRI; X:=T FI
022443          *TRR PCR
022444          IF K THEN                                 % Turn interrupt on before leaving?
022446             *ION                                   % yes
022447          FI; A:=D; EXIT                            % Return
022451   RBUS
022464
022464   SUBR 5IORESTART
022464   RBUS
022464   %===============================================================================
022464   %       ( C )    T E R 5 0 0          Routine to terminate (stop) nd-500
022464   %       ( C )    I A C T 5 0 0        Activate the nd-500.
022464   %       ( C )    A C T R D Y          Activate the nd-500.
022464   %       ( C )    R S T A R T A L L    Routine to restart all sintran iii programs with
022464   %                                     messages in the N500 execution queue with an error message
022464   %       ( C )    C L E A N            5MTRANS routine to clean up on process termination
022464   %       ( C )    M S I N I T          Routine moved to mpit to initialize nd-500 data structures
022464   %       ( C )    I B M O V E          Monitor function
022464   %                                     Calls ribmove on rpit to move bytes from terminal input buffer to nd-500 buffer
022464   %                                     If max no of bytes is reached the the nd-500 process is restarted.
022464   %                                     Goes to MONEN if the input buffer is empty.
022464   %       ( C )    5 E R A C T I V A T E    Reactivate a ND-500 process.
022464   %       ( C )    5 P R A C T I V A T E    Reactivate a ND-500 process.
022464   %
022464   % Entry:     B=cpu datafield
022464   %            TER500:
022464   %            X=-1 then no actual message
022464   %            X><-1 then x=actual message
022464   %
022464   %            RSTARTALL,5ERACTIVATE
022464   %            A=error code
022464   %
022464   %            IBMOVE:
022464   %            X=terminal datafield  (resident part)
022464   %               IN5MSG=nd-500 msg waiting in dvinst or dvio monitor call
022464   %
022464   %            5ERACTIVATE,5PRACTIVATE
022464   %            X=process description
022464   %              interrupt must be off!
022464   %
022464   % Exit:      TER500:
022464   %            error, nd-500 not terminated
022464   %            IACT500,RSTARTALL:
022464   %            ok
022464   %
022464   % Exit+1:
022464   %            TER500:
022464   %            ok, nd-500 stopped
022464   %
022464   @ICR;
022464   SUBR KICK500,TER500,IACT500,ACTRDY,RSTARTALL,IBMOVE,CLEAN,MSINIT,
022464        5ERACTIVATE,5PRACTIVATE,5XGBUFF,5GBUFF,5CONOMD;
022464   @CR;
022464   KICK500:
022464   *NNJ00=*
022464               P+1; EXIT                           % Direct exit if "old" 500
022466               T:=0KICK500;     GO CALLROUT        % Send Octobus kick to 500
022470   TER500:     IF 5CPUSTOPPED><0 THEN EXITA FI     % Cpu already stopped?
022473               T:=0TER500;      GO CALLROUT
022475   IACT500:    T:=0ACT500;      GO CALLROUT        % Common activate for ND500/ND5000
022477   ACTRDY:
022477   *NNJ01=*
022477               P+1; EXIT                           % Direct exit if "old" 500
022501               T:=0ACTRDY;      GO CALLROUT        % Process ready; activate ND5000 (exit is patched in if ND500)
022503   RSTARTALL:  T:=0RSTARTALL;   GO CALLROUT
022505   IBMOVE:     X=:B; RTRES=:D; CALL FSEMA          % Check if prog. still has reserved an nd-500 proc
022511               GO 5IORESTART                       % No 500-proc reserved, continue in iorestart
022512               T:=0IBMOVE;      GO CALLROUT
022514   CLEAN:      T:=0CLEAN;       GO CALLROUT
022516   MSINIT:     T:=0MSINIT;      GO CALLROUT
022520   5ERACTIVATE:T:=05ERACTIVATE; GO CALLROUT
022522   5PRACTIVATE:T:=05PRACTIVATE; GO CALLROUT
022524   5XGBUFF:    T:=05XGBUFF;     GO CALLROUT
022526   5GBUFF:     T:=05GBUFF;      GO CALLROUT
022530   5CONOMD:    T:=05CONOMD;     GO CALLROUT
022532   RBUS
022535
022535
022535   %============================================================================
022535   %      ( C )    5 M C S T      X 5 M C S T
022535   %
022535   % Subroutine to stop N500 (Micro stop)
022535   %
022535   SUBR 5MCST,X5MCST
022535   X5MCST: T:=HDEV
022536   5MCST: T+UNLC5; *IOXT                   % UNLOCK
022540          A:=40; T+"LCON5-UNLC5"; *IOXT    % DISABLE TAG-IN DECODING
022543          A:=2;  T+"RETG5-LCON5"; *IOXT
022546          EXIT
022547   RBUS
022547
022547
022547
022547   %============================================================================
022547   %        ( C )   I T O 5 0 0 X Q
022547   %
022547   % Insert message in the N500-Execution queue
022547   %
022547   % Called from other levels than driver in IOF.
022547   % The N100/N500 general semaphore must be locked.
022547   %
022547   % ENTRY:     X=Message to insert in queue
022547   %
022547   SUBR ITO500XQ
022547   INTEGER CMESS                % Current message address
022550   INTEGER POINTER LREG
022551
022551   ITO500XQ:
022551          T:=5MBBANK; *AAX 5MSFL; LDATX
022554          A=:D BONE 5IEXQUEUE; *STATX; AAX -5MSFL      % Mark proc. is in ex-queue
022560          IF D BIT 5IEXQUEUE THEN EXIT FI
022563          A:=L=:"LREG"; X=:CMESS
022566          *AAX 5PRIO; LDATX
022570          A=:L; T:=5MBBANK; X:=MAILINK
022573          DO
022573             *LINK@3 LDDTX
022574          WHILE D><-1                               % Append at end of queue
022577   *NNC01,   CNVBYADR
022602             IF D=CMESS THEN CALL ERRFATAL FI
022606             T:=A; X:=:D
022610             *AAX 5PRIO; LDATX; AAX -5PRIO           % A=X.5PRIORITY
022613             IF A<L THEN                             % Insert before this element
022615                X:=D; GO ITO51
022617             FI
022617          OD
022620   ITO51: T:=5MBBANK; *LINK@3 LDDTX                  % previous.LINK
022622          X=:L:=CMESS; *LINK@3 STDTX                 % into current.LINK
022625          IF D><-1 THEN
022630   *NNC02,   CNVBYADR
022633             T:=A; X=:A:=D; *AAX PLINK; STATX
022640          FI
022640          T:=5MBBANK; X:=CMESS; A:=L
022643          *AAX PLINK; STATX; AAX -PLINK
022646          A:=T; D:=X
022650   *NNC03,CNVWADR
022653          X:=L; *LINK@3 STDTX                        % current into previous.LINK
022655          MIN LEXQUEUE; 0/\0
022657          X:=CMESS; GO LREG
022661   RBUS
022664
022664
022664
022664   %============================================================================
022664   %      ( C )     I F M 5 0 0 X Q     F R 5 T M Q U
022664   %
022664   % Ifm500xq:
022664   % Remove message from ND-500 Time queue
022664   %
022664   % Fr5tmqu:
022664   % Remove message from the N500 Execution/Time queue
022664   %
022664   % Called from lower levels than the driver in IOF.
022664   % The N100/N500 general semaphore must be locked.
022664   %
022664   % Entry:     X=message to remove
022664   %            B=N500 Cpu-datafield
022664   %
022664   SUBR IFM500XQ,FR5TMQ
022664   INTEGER CMESS
022665
022665   IFM500XQ:
022665          T:=5MBBANK; *AAX 5MSFL; LDATX
022670          A=:D BZERO 5IEXQUEU; *STATX; AAX -5MSFL       % Mark process not longer in ex-queue
022674          IF D NBIT 5IEXQUEUE THEN EXIT FI
022677          IF LEXQUEUE-1<0 THEN A:=0 FI; A=:LEXQUEUE
022704          GO FELLS
022705   FR5TMQ:
022705          T:=5MBBANK; *AAX 5MSFL; LDATX
022710          A=:D BZERO 5ITMQUEUE; *STATX; AAX -5MSFL
022714          IF D NBIT 5ITMQUEUE THEN EXIT FI
022717   FELLS: T:=5MBBANK; X=:CMESS
022721          *LINK@3 LDDTX; AAX PLINK; LDXTX; LINK@3 STDTX
022725          IF D><-1 THEN
022730   *NNC04,   CNVBYADR
022733             T:=A; X=:A:=D; *AAX PLINK; STATX
022740          FI
022740          X:=CMESS; EXIT
022742   RBUS
022744
022744   %==========================================================================
022744   %        ( C )      L O W A C T 5 0 0
022744   %
022744   % ROUTINE TO ACTIVATE N500 FROM LOWER LEVELS THEN THE DRIVER LEVEL
022744   %
022744   % THE ROUTINE MUST BE CALLED WITH INTERRUPT OFF.
022744   %
022744   % LOWACT500:
022744   % Entry:   B=ND500 cpu datafield
022744   %
022744   SUBR LOWACT500,XLOWACT500
022744   LOWACT500:
022744   *NNJ03=*
022744          EXIT                           % Direct exit if nd5000
022745   XLOWACT500:
022745          A:=B; *IRW LV12B DB
022747          "5STDRIV"; *IRW LV12B DP
022751          LV12; *MST PID; EXIT
022754   RBUS
022756
022756
022756   %===========================================================================
022756   %       ( C )    S E T I O W A I T
022756   %
022756   % SETS THE CALLING PROGRAM IN I/O WAIT
022756   %
022756   % ENTRY:     X=ADDRESS OF CURRENT PROCESS DESCRIPTION
022756   %
022756   SUBR SETIOWAIT
022756   SETIOWAIT: *IOF
022757          IF X.PSTAT NBIT F5BUFF THEN
022762             A BONE 5REWA=:X.PSTAT                  % MARK THAT PROC WILL WAIT FOR RESTART BY ND-500 DRIVER
022764             RTREF.STATUS BONE 5WAIT=:X.STATUS      % SET PROGR IN I/O-WAIT
022770             "RWAIT"; *IRW MLEVB DP                 % RESTART NEXT PROGR IN EX-QUEUE
022772             MLEV; *MST PIE; MST PID
022775          FI; *ION
022776          EXIT
022777   RBUS
023001
023001
023001   %===================================================================
023001   %       ( C )   M O N I C O   -   E M O N I C O   -  O K M O N I C O
023001   %               M C C O
023001   %
023001   % SUBROUTINES TO RESTART A ND-500 PROCESS AFTER A MONITOR CALL
023001   %
023001   % ENTRY:
023001   %      X-REG: MESSAGE ADDRESS
023001   %      AD-REG: FUNCTION VALUE
023001   %      T-REG: K FLIP-FLOP
023001   %
023001   SUBR MONICO,EMONICO,OKMONICO,MCCO
023001   INTEGER KKFLIP
023002   EMONICO:  A=:D:=0; T:=1; GO MONICO
023006   OKMONICO: T:=0; A:=0; D:=0
023011   MONICO:   T=:KKFLIP:=5MBBANK; *AAX FUNCV; STDTX      % SAVE FUNCTION VALUE
023015             A:=KKFLIP; *AAX KFLIP-FUNCV; STATX         % SET ERROR FLAG ON/OFF
023020             *AAX NUMPA-KFLIP; STZTX
023022             3MONCO; *AAX -NUMPA; STATX XMICF           % RESTART AFTER MONITOR CALL
023025   MCCO:     T:=5MBBANK; 140300; *AAX H500A; STATX; AAX -H500A
023032             L=:D; MSGN500; CALL WN5STATUS; L:=D
023036             T:=5MBBANK; X=:D; *AAX XADPR; LDXTX
023042             X.PSTAT/\5CLRUNSTATUS+5ACTIVE=:X.PSTAT    % SET PROC. ACTIVE
023046             X:=D; EXIT
023050   RBUS
023055
023055
023055   %===========================================================================
023055   %      ( C )      F S Y S I N T E R F A C E   -   T S 3 C O M P R O C
023055   %
023055   % FSYSINTERFACE:
023055   % ROUTINE TO CALL ROUTINES IN THE FILESYSTEM  FROM ND-500 SYSTEM MONITOR
023055   %
023055   % TS3COMPROC:
023055   % ROUTINE TO CALL ROUTINES IN THE SINTRAN III COMMAND SEGMENT.
023055   %
023055   % ENTRY:     X=LOGICA ADDR OF ND-500 MESSAGE
023055   %            THE REGISTER VALUES, (INPUT PARAMETERS TO THE FILE SYSTEM ROUTINES),
023055   %            ARE IN THE ND-500 MESSAGE
023055   %
023055   % EXIT:      EXIT FROM THE FILESYSTEM ROUTINE
023055   %            T,A,D,X REGISTERS HAVE THE VALUE RETURNED FROM THE FILESYSTEM ROUTINE
023055   %
023055   % EXIT+1:    EXIT+1 FROM THE FILESYSTEM ROUTINE
023055   %            T,A,D,X REGISTERS HAVE THE VALUE RETURNED FROM THE FILESYSTEM ROUTINE
023055   %
023055   SUBR FSYSINTERFACE,TS3COMPROC
023055
023055   INTEGER POINTER OFLDX:=OFLCK
023056
023056   TS3COMPROC: T:=5OPSEG; A:=L=:5LREG; GO IFSYINIT            % SEGMENT 5OPCOM FOR S3. COMMAND SEGM
023062   FSYSINTERFACE: T:=0                                        % NO SEGMENT FOR FILESYSTEM
023063          A:=L=:5LREG; OFLDX; CALL XLOCK                      % LOCK STACK FOR RT-PROGR
023067   IFSYINIT: X=:B; T=:SEG5
023071          IF T=0 THEN
023073             "NFPIT+ADPIT+ALEVB+ERNG2"
023074          ELSE
023075             CALL M1MEXY; T=:SEG5                             % SWITCH SEGM TO S3.OPCOM SEGM, AND SAVE OLD
023077             "NSPIT+ADPIT+ALEVB+ERNG2"
023100          FI; A=:CURPROG.ACTPRI; *TRR PCR                     % SET NEW NPIT.
023103          "STACK"=:CSTCK                                      % RESET CURRENT STACK POINTER
023105          TAD:=5TADRG; X:=5XRG; 0=:5ERRFLAG; CALL FSYSENTRY   % CALL ROUTINE
023111          MIN 5ERRFLAG                                        % MARK NOT SKIP RETURN FROM FILSYS/OPCOM ROUTINE
023112          TAD=:5TADRG; X=:5XRG                                % SAVE RETURN PARAMETERS
023114          IF T:=SEG5><0 THEN CALL M1MEXY FI                   % GET IN ND-500 DATA SEGMENT IF TS3COMPROC
023120          "N5PIT+ADPIT+ALEVB+ERNG2"=:CURPROG.ACTPRI; *TRR PCR % RESET NPIT TO 5PIT
023124          IF XADPROC.PSTAT NBIT OFLDUNLOCK THEN OFLDX; CALL XUNLOCK FI % UNLOCK STACK
023132          5LREG=:L; IF 5ERRFLAG=0 THEN L+1 FI                 % SET UP RETURN ADDR, SKIP RETURN OR NOT
023137          TAD:=5TADRG; A=:5AREG; X:=5XRG; DBASE=:B; A:=5AREG  % GET REG.VALUES FROM FILSYS/S3 OPCOM ROUTINE
023145          EXIT
023146   RBUS
023162
023162
023162   %=============================================
023162   %      ( C )     X 5 D C N
023162   %
023162   %      ROUTINE FOR DISCONNECT FROM XMSG.
023162   %      ON LEVEL 1. WILL ACTIVATE DRIVER LEVEL ROUTINE.
023162   %   ENTRY:
023162   %      A=PROCESS DESCRIPTION
023162   %   EXIT:
023162   %      ION
023162
023162   SUBR X5DCN
023162   INTEGER AREG,LREG
023164   X5DCN: *IOF
023165          A=:AREG:=L=:LREG
023170          T:=5MBBANK
023171          X:=AREG.MESSBUFF
023173          *AAX XTBLK; LDATX           % XT-BLOCK
023175          IF A >< 0 THEN              % DO WE HAVE ANY ?
023176                *STZTX; AAX -XTBLK    % YES, GET RID OF IT
023200                *IRW LV12B DL
023201                CALL GCPUDF; CALL ERRFATAL
023203                *IRW LV12B DB
023204                "P12DCN"; *IRW LV12B DP
023206                LV12; *MST PID
023210          FI; A:=AREG
023211          LREG=:L
023213          *ION
023214          EXIT
023215   RBUS
023222
023222
023222   %========================================================================
023222   %      ( C )      5 C S E T D V
023222   %
023222   % SUBROUTINE TO CALL SETDV ON A SPLITTED-DATAFIELD DEVICE
023222   % CALLED FROM 5PIT
023222   %
023222   % ENTRY:     T=FUNCTION CODE WHEN CALLING SETDV
023222   %            A=ADDR OF SETDV ROUTINE
023222   %            X=RESIDENT DATAFIELD
023222   %            INTERRUPT IS OFF
023222   %
023222   SUBR 5CSETDV
023222   INTEGER POINTER LREG
023223   5CSETDV: A:=:L=:"LREG"
023225          X=:D; "NRPIT+ADPIT+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR  % SWITCH TO RPIT
023232          A:=T; X:=D; L:=:P               % A="FUNCTION CODE"; X=RESIDENT DF
023235          X=:D; "N5PIT+ADPIT+ALEVB+ERNG2"; *TRR PCR    % RESET TO 5PIT
023240          A=:RTREF.ACTPRI
023242          X:=D; GO LREG
023244   RBUS
023247
023247
023247   %=============================================================
023247   %      ( C )    L 3 S T D V
023247   %
023247   % MONITOR FUNCTION ROUTINE TO START TERMINAL OUTPUT DRIVER
023247   % ACTIVATED FROM STTDRIV ON MPIT
023247   % ENTRY: X=TERMINAL DATAFIELD
023247   %
023247   SUBR L3STDV
023247   L3STDV: *IOF
023250           AD:=X.DTDFPHPAGE                          % A=BANK NO. OF TERM DF; D=PHYS.PAGE OF TERM DF.
023251           A:=:D/\1777+"WND41*2000"=:B:=142000       % B=LOG.ADDR OF TERM.OUTPUT DF.
023256           T:=0; X:="WND41+WND41+174000"; *STDTX     % SET UP TERM. WINDOW
023261           "NRPIT+ADPIT+MLEVB+ERNG2"; *TRR PCR       % SWITCH TO RPIT
023263           CALL STDEV                                % START TERM.OUTPUT DRIVER
023264           "NMPIT+ADPIT+MLEVB+ERNG2"; *TRR PCR       % RESET TO MPIT
023266           T:=0; X:="WND41+WND41+174000"; *STZTX     % CLEAR TERM.WINDOW ENTRY IN PIT
023271           GO MONEN
023272   RBUS
023300
023300   %=====================================================================
023300   %     ( C )    S P I T M Q
023300   %
023300   % START PROCESS CURRENTLY IN TIME QUEUE
023300   %
023300   % ENTRY:     X=MESSAGE TO RESTART
023300   %            A=RESTART REASON
023300   %
023300   SUBR SPITMQ
023300   INTEGER POINTER SPIRET
023301   SPITMQ: T:=L=:"SPIRET"
023303           A=:D; IF A><-1 THEN A:=0 FI
023310           T:=5MBBANK; *AAX 5ADP3; STDTX
023313           A:=4; *AAX NUMPA-5ADP3; STATX
023316           A:=0=:D; *AAX FUNCV-NUMPA; STDTX
023322           *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
023325           3MONCO; *MICFU@3 STATX
023327           CALL MCCO; GO SPIRET
023331   RBUS
023333
023333
023333   %===========================================================================
023333   %      ( C )   N W 5 S T   -   P N W 5 S T
023333   %
023333   %      NO WAIT ND-500 START.
023333   %      CALLED ON BREAK WHEN TERMINAL OR INTERNAL DEVICE IS IN NO WAIT MODUS
023333   %      MUST BE CALLED IN IOF.
023333   %
023333   % ENTRY WHEN PNW5ST: B=ADDR OF "BIG" TERM.DF
023333   % ENTRY WHEN NW5ST:  B=ADDR OF RESIDENT DF.
023333   %
023333   % EXIT:      ND-500 PROC RESTARTED
023333   %
023333   % EXIT+1:    ND-500 PROC NOT RESTARTED
023333   %
023333   SUBR XNW5ST,NW5ST,PNW5ST,INW5ST
023333
023333   INTEGER NWFLAG,NWBSAVE,NWPROC,NWSTATUS
023337   INTEGER POINTER NW5RET
023340
023340   XNW5ST: A:=L=:"NW5RET"; X:=RTRES; A:=1; GO 0NW5ST
023345   PNW5ST: X:=TDRADDR.RTRES; GO INW5ST
023350   NW5ST:  X:=RTRES
023351   INW5ST: A:=L=:"NW5RET"; A:=0
023354   0NW5ST: IF X=0 THEN EXITA FI; A=:NWFLAG
023360          IF X.WLINK=0 AND X.TLINK=0 AND X.STATUS NBIT 5RWAIT THEN EXITA FI
023370          D:=X; CALL FSEMA; GO NWRET; X=:NWPROC     % RESERVED ANY ND-500 PROC?
023374          A:=X.PSTAT; T:=5MBBANK; X:=X.MESSBUFF
023377          IF A NBIT T5BUF GO NIQUEUE
023401          CALL RN5STATUS
023402          IF A=I5TMQU OR A=STOPPED THEN             % PROC WAITING FOR RESPONSE FROM ND500?
023410             A=:NWSTATUS
023411             CALL GCPUDF; CALL ERRFATAL
023413             A:=:B=:NWBSAVE                         % B=ND-500 CPU DF.
023415             IF NWSTATUS=I5TMQU THEN                % PROCESS IN TIME QUEUE
023421                CALL FR5TMQU; A:=1; CALL SPITMQU
023424   *NNT01=*
023424                CALL TER500; 0/\0
023426                CALL SLOCK; 0/\0
023430                CALL ITO500XQ                       % ACTIVATE PROCESS
023431                CALL SUNLOCK
023432             ELSE                                   % PROCESS HAS BEEN STOPPED
023433                CALL OKMONICO                       % RESTART PROC AFTER MONCALL
023434             FI
023434             CALL IACT500
023435   *NNJ04=*
023435             GO W5ST
023436             *TRA STS
023437             IF A SH -5/\170><LV12B THEN CALL LOWACT500 FI
023445   W5ST:     NWBSAVE=:B
023447          ELSE
023450   NIQUEUE:  IF NWFLAG=0 THEN
023452                CALL SLOCK; 0/\0
023454                T:=5MBBANK; *AAX 5MSFL; LDATX
023457                A BONE 55REP; *STATX                % SET REPEAT
023461                CALL SUNLOCK
023462             FI
023462             MIN "NW5RET"
023463          FI
023463          NWPROC.PSTAT BONE 55BRKPRIOR=:X.PSTAT     % SET BREAK PRIORITY
023467          IF X:=X.RTRES><0 THEN X.STATUS BONE 5BRKF=:X.STATUS FI
023474          GO NW5RET
023475
023475   NWRET: MIN "NW5RET"; GO NW5RET
023477   RBUS
023517
023517
023517   %=========================================================================
023517   %       ( C )     5 R E T U E C O M
023517   %
023517   % ROUTINE TO CHANGE PIT'S BEFORE RETURNING AFTER MON UECOM (317)
023517   % CALLED IN IOF FROM FROMESC
023517   %
023517   SUBR 5RETUECOM
023517   5RETUECOM:
023517          "ADPIT+NSPIT+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR
023523          *ION
023524          IF GP3SW><0 THEN                   % ESCAPE WHILE IN FILESYSTEM
023526             GP3RSEGM=:RTREF.RSEGM; *IOF     % SETUP REENTRANT SEGMENT
023532             "STUPR"; *IRW MLEVB DP
023534             MLEV; *MST PID; ION
023537             0=:GP3SW
023540          FI; X:=UEXREG
023541          TAD:=UECMRET
023542          D=:P                               % CONTINUE AFTER UECOM
023543   RBUS
023552
023552
023552   %==============================================================================
023552   %      ( C )      5 O C T O S W I T C H
023552   %
023552   %    Subroutine to call octobus routines on Mpit, called  from 5pit.
023552   %    Required data is found in  physical memory  and in  stack window
023552   %    on Dpit  according to B-reg and  the dispfield defined file ACCPSYMB-SYSMON
023552   %
023552   %    Entry    : None
023552   %    Exit+1   : Error
023552   %    Exit     : OK
023552   %
023552   SUBR 5OCTOSWITCH
023552
023552   5OCTOSWITCH: A:=L=:"2LREGOCTO"; *IOF
023555          "NMPIT+ADPIT+ALEVB+ERNG2"=:RTREF.ACTPRI   % cannot tolerate an interrupt between this statement and the next
023560          *TRR PCR; ION                             % Switch to Mpit, same alt. pit
023562          2PREGOCTO=:L;TAD:=2TADOCTOREG;X:=2XREGOCTO% Retrieve registers
023566          L:=:P; GO ERR; MIN "2LREGOCTO"            % Jump to Mpit routine; return; skip return
023571   ERR:   TAD=:2TADOCTOREG; X=:2XREGOCTO; *IOF      % Preserve registers
023574          "N5PIT+ADPIT+ALEVB+ERNG2"=:RTREF.ACTPRI   % cannot tolerate an interrupt between this statement and the next
023577          *TRR PCR; ION                             % Reset to 5pit
023601          GO 2LREGOCTO
023602   RBUS
023605
023605
023605   %==============================================================================
023605   %    ( C )        G C P U D F
023605   %
023605   %    Subroutine to get cpu datafield of cpu on which the process is running
023605   %
023605   %    Entry    : X=address of message within bank
023605   %    Exit     : Error, illegal Cpu no in message
023605   %    Exit+1   : A=cpu datafield
023605   %
023605   %    Registers destroyed: T
023605   %
023605   SUBR GCPUDF
023605   GCPUDF: T:=5MBBANK; *AAX 5CPUN; LDATX; AAX -5CPUN
023611           IF A/\377-1>=0 THEN
023614              A*5CPUDFSZ+"S5CPUDF"
023616              IF A<<="E5CPUDF" THEN EXITA FI
023622           FI
023622           EXIT
023623   RBUS
023630
023630
023630   %==============================================================================
023630   %    ( C )        G E T C 5 P R O C
023630   %
023630   %    Subroutine to get current executing process number
023630   %
023630   %    Entry    : B=cpu datafield
023630   %    Exit     : A=current executing process
023630   %
023630   %    Registers destroyed: T,D
023630   %
023630   SUBR GETC5PROC
023630   GETC5PROC: T:=5MBBANK; X=:D:=MAILINK; *AAX X5PRO
023634           *BSET BCM 120 DX; LDATX                      % Fool the cache
023636           *BSET BCM 120 DX; LDATX
023640           X:=D; EXIT
023642   RBUS
023643
023643
023643   %==============================================================================
023643   %    ( C )        W N 5 S T A T U S
023643   %                 R N 5 S T A T U S
023643   %
023643   %    Subroutine to get/set status word in Nd-500 message
023643   %
023643   %    Entry    : X=address of message within bank
023643   %               If WN5STATUS:
023643   %               A=value to set
023643   %    Exit     : If RN5STATUS:
023643   %               A=value
023643   %
023643   %    Registers destroyed: T,D
023643   %
023643   SUBR RN5STATUS,WN5STATUS
023643   RN5STATUS: T:=5MBBANK
023644           *BSET BCM 120 DX; N5STA@3 LDATX              % Fool the cache
023646           *BSET BCM 120 DX; N5STA@3 LDATX
023650           EXIT
023651
023651   WN5STATUS: T:=5MBBANK; *N5STA@3 STATX
023653           EXIT
023654   RBUS
023655
023655
023655   %===============================================================================
023655   %       ( C )    S L O C K          S U N L O C K
023655   %
023655   % Routines to lock/unlock N500 execution queue/interrupt semaphore
023655   %
023655   % Entry:     None
023655   %
023655   % Exit:      If SUNLOCK: ok
023655   %            If SLOCK:   error
023655   %
023655   % Exit+1:    ok, semaphore locked
023655   %
023655   SUBR SLOCK,SUNLOCK
023655   INTEGER TREG,AREG,DREG,XREG,BREG
023662   TRIPLE  TADREG=TREG
023662   INTEGER POINTER LREG
023663   INTEGER 1COUNT,2COUNT
023665   INTEGER TSET(0);  *140123     % Logical test-and-set instr. for not Rask cpu
023666   INTEGER TSETP(0); *140516     % Physical test-and-set instr. for Rask cpu
023667
023667   SLOCK:
023667   *NNJ05=*
023667          P+1; EXITA                                     % Direct exit+1 if "old" 500
023671          TAD=:TADREG; X=:XREG; A:=L=:"LREG"
023675          1HWINF; *RASK@3 BLDA DA                        % K-bit set if Rask-cpu
023677          IF K THEN
023701             "N500DF".X500DF+"X5SEMA"=:X; T:=5MBBANK     % yes, use physical test-and-set
023706             TSETP=:D
023710          ELSE                                           % no, use logical test-and-set
023711             "N500DF".X500DF=:D; 5MBBANK; AD SHZ 6
023716             A=:D:=142000
023720             X:="WNDN5+WNDN5+174000"; T:=0; *STDTX
023723             "N500DF".X500DF+"X5SEMA"/\1777+"WNDN5*2000"=:T
023731             TSET=:D
023733          FI
023733          *EXR SD                                        % Reserve semaphore
023734          IF A=0 GO SOKRET                               % Lock reserved ok?
023735          T=:L:=5MBBANK; X=:A:="N500DF".X500DF
023742          *AAX X5RES; LDXTX
023744          IF X+1=0 GO SOKRET                             % Lock already reserved by N100?
023746          T:=L; X:=A
023750          -2=:1COUNT
023752          FOR 1COUNT DO
023752             % Wait for lock.....
023752             %   Total wait time: appox.  100 millisec. per loop
023752             %   Wait time per Test-and-set: appox. 100 microsec.
023752             %   Loop counter is set on the assumption that
023752             %   Rask/Delilhia has twice the performance to CX-CPU.
023752             %
023752             IF K THEN -3720 ELSE -1750 FI
023757             A=:L
023760             DO WHILE L<0
023762                *EXR SD
023763                IF A=0 GO SOKRET
023764                IF K THEN A:=-130 ELSE A:=-54 FI
023771                DO WHILE A<0; A+1; OD
023774                L+1
023775             OD
023776          OD
024000          % Failed to reserve the lock
024000          % ...Lock timeout...
024000          N5LTIMOUT=:AREG; GO SRET
024003
024003          % Set N100 as current reserving CPU (N100=-1)
024003   SOKRET:T:=5MBBANK; X:="N500DF".X500DF
024006          A:=-1; *AAX X5RES; STATX
024011          MIN "LREG"
024012   SRET:  IF K NBIT THEN
024014             X:="WNDN5+WNDN5+174000"; T:=0; *STZTX
024017          FI
024017          TAD:=TADREG; X:=XREG; GO LREG
024022
024022   SUNLOCK:
024022   *NNJ06=*
024022          P+1; EXIT                                         % Direct exit if "old" 500
024024          TAD=:TADREG; X=:XREG
024026          "N500DF".X500DF+"X5SEMA"=:X; T:=5MBBANK
024033          *AAX X5RES; LDATX
024035          IF A+1=0 THEN                                     % Reserved by N100?
024037             *STZTX; AAX -X5RES; STZTX                      %   Yes, release lock
024042          FI
024042          TAD:=TADREG; X:=XREG; EXIT
024045   RBUS
024060
024060
024060   %===============================================================================
024060   %       ( C )    F 5 D B H S
024060   %
024060   % SUBROUTINE TO CHECK IF A PROGRAM HAS ANY 500-FILE-TRANSFER-BUFFER-HEADERS
024060   %
024060   % ENTRY: A=RT-DESCRIPTION ADDRESS
024060   %        MUST BE CALLED IN IOF!
024060   % EXIT:  NO 500-FILE-TRANSFER-BUFFER-HEADER RESERVED
024060   % EXIT+1: A=ADDR OF 500-FILE-TRANSFER-BUFFER-HEADER
024060   %
024060   SUBR F5DBHS
024060   TRIPLE  TADREG
024063   INTEGER XREG
024064   F5DBHS: TAD=:TADREG; X=:XREG
024066           X:="BRESLINK"+A
024070           DO WHILE X:=X.RESLINK><A
024073              IF X>>5DVBSTART THEN
024076                 TAD:=TADREG; A:=X; X:=XREG
024101                 EXITA
024102              FI
024102           OD
024103           TAD:=TADREG; X:=XREG
024105           EXIT
024106   RBUS
024110
024110
024110   *"-8N500
"024110   *       EXIT AD1
024111   *"-8N500
"024111
024111   @DEV 1
024111   *ENDCC=*
024111   @EOF
024111
024111
024111   File : (SAMSON)KILL-MACROS:DUMY
176000   %$--:COMMON                    % FOR SPLITTING AV LISTING.
176000   *PITST/
026000   @DEV (S-S-L)XC-P2-1:NPL
026000   %==============================================================================
026000   % 11.21        G E T B I T
026000
026000   %SUBROUTINE TO GET BIT FROM BITMAP, ADDRESS IN X, CHAR IN A
026000   %RESULT IN A BIT 17
026000
026000   SUBR GETBIT,SSCGETBIT,VSXGETBIT
026000   INTEGER SHAINSTR(0); *SHA
026001   VSXGETBIT: IF X>>="WNDBF*2000" THEN
026004                 A=:T:=B/\176000:=:X/\1777; X+A; A:=T
026013              FI
026013   SSCGETBIT:
026013   GETBIT: A BZERO 7; AD SHZ -4; X+A; SHAINSTR; D SHZ -14+A
026021          X.S0; *EXR SD
026023          EXIT
026024   RBUS
026027
026027   %=================================================================
026027   %37.2A      T E C H O
026027   %
026027   %  TEST FOR ECHO:
026027   %  THIS SUBROUTINE SHOULD BE CALLED WITH INTERRUPTS OFF!!
026027   %
026027   SUBR TECHO
026027   INTEGER CHARN; INTEGER POINTER LREG
026031   SYMBOL 5PIP=17
026031   TECHO: A=:CHARN; A:=L=:"LREG"
026034          IF X:=ECHOTAB><0 THEN
026036             A:=CHARN
026037             IF T:=TINFO BIT 58BIT AND A BIT 7 THEN     % 8-BITS MODE
026044                EXIT                                    % NO ECHO IN UPPER RANGE
026045             FI
026045             CALL VSXGETBIT
026046             IF A<0 THEN                  % NO ECHO
026047                IF X:=ECHOTAB><"ECH0" AND X><"ECH1" AND X><"ECH2" THEN
026061                   BRECHOFL BONE 5PIP=:BRECHOFL
026064                FI
026064             ELSE                         % ECHO
026065                IF DFLAG NBIT 5SPEC AND A NBIT 5HDUP THEN
026072                   BRECHOFL BONE 5ECHO BZERO 5PIP=:BRECHOFL
026076                FI
026076             FI
026076          FI
026076         CHARN; GO LREG
026100   RBUS
026104
026104   %========================================================================
026104   % 37.2B       T B R E A K
026104   %
026104   %     TEST FOR BREAK:
026104   %     THIS ROUTINE SHOULD BE CALLED WITH INTERRUPTS OFF!!
026104   %
026104   SUBR TBREAK
026104   INTEGER CHARN; INTEGER POINTER LREG
026106   SYMBOL 5PIP=17
026106   TBREAK: A=:CHARN; A:=L=:"LREG"
026111           IF X:=TINFO BIT 58BIT AND CHARN BIT 7 THEN      % 8-BITS MODUS WITH BIT 7 SET
026117              IF X NBIT 5UMOD THEN
026121                 BRECHOFL BONE 5PIP=:BRECHOFL; EXIT        % REJECT CHARACTER
026125              FI
026125              IF BRKTAB><0 THEN                            % BIT 7 AND BREAK DEFINED
026127                 0=:NCBRK
026130                 BRECHOFL BONE 5BREAK BZERO 5PIP=:BRECHOFL % BREAK ON 8-BITS CHARACTER
026134                 EXIT
026135              FI
026135           FI
026135           IF DFLAG BIT 5SPEC THEN        %UNCONDITIONAL BREAK, NO ECHO.
026140              0=:NCBRK
026141              A BZERO 5SPEC BZERO 5CTRLO=:DFLAG
026144              BRECHOFL BONE 5BREAK BZERO 5ECHO=:BRECHOFL
026150           ELSE
026151              IF X:=BRKTAB><0 THEN
026153                 IF BRECHOFL>=0 THEN MIN NCBRK; 0/\0; FI
026157                 IF BRKTAB="BRK1" AND CHARN/\177=17 OR =20 OR =26 OR =30 OR =32 THEN
026204                    DFLAG BONE 5SPEC =:DFLAG    %BREAK ON NEXT
026207                 ELSE
026210                    A:=CHARN; CALL VSXGETBIT
026212                    IF A<0 THEN                 %BREAK ON CHARACTER
026213                       0=:NCBRK
026214                       BRECHOFL BONE 5BREAK BZERO 5PIP=:BRECHOFL
026220                    ELSE                        %POSSIBLE BREAK ON MAX CHARS.
026221                       IF BRKMAX><0 AND A<<=NCBRK THEN
026226                          0=:NCBRK
026227                          BRECHOFL BONE 5BREAK=:BRECHOFL
026232                       FI
026232                    FI
026232                 FI
026232              FI
026232           FI; CHARN; GO LREG
026234   RBUS
026237
026237   %==============================================================================
026237   %            T E R M I N A L   O U T P U T
026237   %==============================================================================
026237   % 11.22      T T P U T   T R T P U T   D M O U T P U T   T T O M R   I O N I O F
026237   %
026237
026237   SUBR TTPUT,TRTPUT,DMOUTPUT,TTOMR,DIOUT,MLTTOMR ,TTWPUT
026237
026237   % IOTRANS SUBROUTINE FOR INTERNAL DEVICE 500
026237   TTWPUT: IF T:=CFREE=0 THEN EXIT FI
026243           L+1; T:=0 ; GO TDWPUT
026246
026246   %IOTRANS SUBROUTINE, CALLED FROM OUTBT
026246   TTPUT: IF T:=CFREE=0 THEN EXIT FI
026252          L+1; GO RBPUT
026254
026254   % TERMINAL OUTPUT IOTRANS ROUTINE
026254   TRTPUT: IF T:=CFREE=0 THEN EXIT FI                          % BUFFER FULL
026260           IF T:=MINBHOLD<0 THEN EXIT FI                       % BUFFER LOCKED
026264           X:=XOPPDF+B
026266           IF T:=X.TINFO NBIT 5UMOD OR X:=X.BSTATE=5BCOM THEN
026275              A BZERO 7                                        % 7-BIT DATA ONLY
026276           FI; L+1; GO CXRBPUT
026300
026300   %STDEV SUBROUTINE, CALLED FROM OUTBT, TO ACTIVATE LEVEL 10
026300   INTEGER SVT,SVL
026302   DIOUT: T=:SVT; GO IDIOUT
026304   TTOMR: T=:SVT; K:="1"; GO ITTOMR
026307   DMOUTPUT: T=:SVT; K:="0"
026311          T:=HDEV+DST; *IOXT
026314          IF NBIT 0 THEN
026316   % TERMINAL OUTPUT TIME-OUT SUBROUTINE
026316   ITTOMR:
026316             IF DFOPP><0 AND X:=TYPRING BIT 5TERM THEN
026323                IF K AND BITFLAG BIT 5MAIL THEN       % MAIL BEEING PRINTED ON THIS TERMINAL
026330                   IF CURMAIL=X:="F1205".RTRES THEN   % X-REG DESTROYED !!!
026335                      GO CLBF
026336                   ELSE
026337                      BITFLAG BZERO 5MAIL=:BITFLAG; 5TMR=:TTMR
026344                      X:=XOPPDF+B
026346                   FI
026346                FI
026346                IF K AND BITFLAG BIT 5CLOU GO CLBF    % CLEAR OUTPUT BUFFER
026353                X:=XOPPDF+B; IF X.DFLAG NBIT 5LBRK GO L1
026360                IF CFREE=MAX THEN         % OUTPUT BUFFER EMPTY
026364                   MINBHOLD BZERO 5BLOC=:MINBHOLD
026367                FI
026367                IF X.DBPROG><0 THEN
026371                   X.DFLAG BZERO 5LBRK=:X.DFLAG; T:=HDEV+DST-4; *IOXT
026400                   IF A BIT 13 THEN                   % MISSING CARRIER
026402                      GO CLBF
026403                   FI
026403                FI
026403             FI; GO L1
026404
026404   CLBF:     A:=L=:SVL; CALL CLBUFF; "IORESTART"; CALL CXXRTACT; SVL=:L
026413             MINBHOLD BZERO 5BLOC=:MINBHOLD
026416   L1:       IF TYPRING BIT 5TERM THEN TDRADDR; GO L2 FI
026423
026423   %  DIGITAL I/O TIMEOUT ENTRY POINT  (DR11C)
026423   IDIOUT:   B=:A
026424   L2:       *IRW LV10B DB
026425             "STDRIV"; *IRW LV10B DT
026427             "SLV10"; *IRW LV10B DP
026431             LV10; *MST PID
026433          FI
026433          T:=SVT; TTMR=:TMR
026436          EXIT
026437
026437   RBUS
026451
026451
026451
026451
026451   SUBR ERR22
026451   %FALSE INTERRUPT, A=IDENT NO.:
026451     ERR22: T:=A; *TRA STS; 2BANK
026454          A SH 4 SHZ -14=:X; CALL 9ERR(#22)
026461     ERRY:  X-12 GOSW WT10,WT11,WT12,WT13
026467   RBUS
026474
026474
026474   %==============================================================================
026474   %                C A T E S T   -    C A R T T E
026474   %
026474   % CAMAC DRIVER:
026474
026474   SUBR CATEST,CARTTE
026474
026474          % ENTRY FOR LEVELS 10,11,12
026474   CATEST:
026474   *"CAMA
"026474   CARTTE:
026474   *"CAMA
"026474         EXIT
026475   *"
"026475   RBUS
026475
026475
026475   %====================================================================
026475   %              P H L O G
026475   %
026475   % PHLOG : FIND DEVICENUMBER FROM DATAFIELD ADDRESS
026475   %
026475   %    ENTRY : A = DATAFIELD ADDRESS
026475   %
026475   %    EXIT  : A = DEVICE NUMBER (BIT 17 SET WHEN OUTPUT PART)
026475   %
026475   SUBR PHLOG
026475
026475   INTEGER SAVT, SAVA, SAVD
026500   TRIPLE SVTAD=SAVT
026500   INTEGER SAVX, SAVB, U
026503   INTEGER POINTER HOME
026504
026504   PHLOG: A:=:B=:SAVB:=L=:"HOME"
026510          TAD=:SVTAD; X=:SAVX
026512          0=:SAVA; 0=:U
026514          DO
026514             IF U><1 THEN
026520                U=:X SHZ 6=:SAVA; X:=CNVRT(X)
026525                T:=LOGDBANK; *LDATX            % NUMBER OF ENTRIES
026527                X+1; A SHZ 1+X=:L              % NEXT ENTRY
026533                DO WHILE X<<L
026535                   *LDDTX                      % DATAFIELD ADDRESSES
026536                   IF A=B GO FOUND
026540                   IF D=B THEN
026542                      SAVA BONE 17=:SAVA       % OUTPUT PART
026545                      GO FOUND
026546                   FI
026546                   X+2; MIN SAVA               % NEXT ELEMENT
026550                OD
026551             FI
026551             WHILE U+1=:U<=31
026557          OD
026560          CALL ERRFATAL                        % NOT FOUND
026561
026561   FOUND: SVTAD; X:=SAVB=:B:=SAVX; GO HOME
026566   RBUS
026571
026571
026571   %=======================================================================
026571   % DISK HANDLING UTILLITY ROUTINES
026571
026571   SUBR GETOUT,PUTIN
026571   %-------------------------------------------------------------------
026571   % ROUTINE TO LINK OUT A QUE ELEMENT                              (M/I)
026571   %  X= QUE HEAD ADDRESS
026571   % RETURN:T= OUT LINKED  ELEM., X= QUE HEAD
026571   %-------------------------------------------------------------------
026571   GETOUT:
026571           T:=X.S0 ;IF T=0 THEN CALL ERRFATAL; FI
026575           X:=:T; A:=X.NLINK; 0=:X.NLINK
026600           X:=:T; A=:X.S0
026602           EXIT
026603   %-------------------------------------------------------------------
026603   % ROUTINE TO LINK IN A QUE ELEMENT                               (M/I)
026603   % T= QUE ELEMENT, X= QUE HEAD ADDRESS
026603   % RETURN:T= IN LINKED  ELEM., X= QUE HEAD
026603   %-------------------------------------------------------------------
026603   PUTIN:
026603           A:=X.S0;    X:=:T
026605           A=:X.NLINK; X:=:T
026607           T=:X.S0
026610           EXIT
026611   RBUS
026612
026612   %============================================================================
026612   %       SUBROUTINE TO RETURN A QUEUE DATAFIELD TO POOL OF FREE DATAFIELDS (M/R)
026612   %       T-REG: ADDRESS OF DATAFIELD TO BE INSERTED IN FREE LIST
026612   %       CALLED FROM MPIT AND RPIT
026612   %
026612   SUBR PTFREE
026612   INTEGER POINTER SAVL
026613   INTEGER SAVB
026614   PTFREE: X:=L=:"SAVL"; X:=:B=:SAVB:="QP100"=:B; *AAX QPFRH
026623           CALL PUTIN; MIN 5MQCU; 0/\0
026626           X:=SAVB=:B; GO SAVL
026631   RBUS
026633
026633
026633
026633   SUBR TO10Q,TO11Q,TO12Q
026633   %--------------------------------------------------------------------
026633   % TO APPEND Q ELEMENT IN LEVEL 11 QUE
026633   % ENTRY: X= QUE ELEMENT, B= WILL BE SAVED IN QUE ELEMENT
026633   % EXIT:  IOF
026633   %--------------------------------------------------------------------
026633   INTEGER SVX
026634   TO10Q: T:="IL10Q-NLINK"; GO TOQ
026636   TO11Q: T:="IL11Q-NLINK"; GO TOQ
026640   TO12Q: T:="IL12Q-NLINK";
026641   TOQ:   *IOF
026642          IF X.NLINK >< 0 THEN CALL ERRFATAL FI  %
026645          X=:SVX:=T; T:=-1
026650          DO WHILE X.NLINK >< T                % TO THE END
026653             X:=X.NLINK
026654          OD
026655          SVX=:X.NLINK=:X
026660          A:=B=:X.BREGQ; T=:X.NLINK            % MARK END
026663          EXIT
026664   RBUS
026670
026670   SUBR ST10L
026670   %--------------------------------------------------------------------
026670   % TO START LEV 10
026670   % ENTRY: X= QUE ELEMENT, B= WILL BE SET ON LEV 10
026670   % EXIT:  IOF
026670   %--------------------------------------------------------------------
026670   ST10L:  *IOF; TRA PID
026672           IF A BIT BLV10 THEN
026674             GO TO10Q
026675           ELSE
026676             IF X.NLINK >< 0 THEN CALL ERRFATAL FI
026701             A:=B;       *IRW LV10B DB                 % CONTROLLER
026703             A:=X;       *IRW LV10B DX                 % PARAMETERS
026705             X.NFUNC;    *IRW LV10B DP
026707             LV10;       *MST PID
026711           FI
026711           EXIT
026712   RBUS
026715
026715   SUBR ST11L
026715   %--------------------------------------------------------------------
026715   % TO START LEV 11
026715   % ENTRY: X= QUE ELEMENT, B= WILL BE SET ON LEV 11
026715   % EXIT:  IOF
026715   %--------------------------------------------------------------------
026715   ST11L:  *IOF; TRA PID
026717           IF A BIT BLV11 THEN
026721             GO TO11Q
026722           ELSE
026723             IF X.NLINK >< 0 THEN CALL ERRFATAL FI
026726             A:=B;       *IRW LV11B DB                 % CONTROLLER
026730             A:=X;       *IRW LV11B DX                 % PARAMETERS
026732             X.NFUNC;    *IRW LV11B DP
026734             LV11;       *MST PID
026736           FI
026736           EXIT
026737   RBUS
026742
026742   SUBR ST12L
026742   %--------------------------------------------------------------------
026742   % TO START LEV 12
026742   % ENTRY: X= QUE ELEMENT, B= WILL BE SET ON LEV 12
026742   % EXIT:  IOF
026742   %--------------------------------------------------------------------
026742   ST12L:  *IOF; TRA PID
026744           IF A BIT BLV12 THEN
026746              GO TO12Q
026747           ELSE
026750             IF X.NLINK >< 0 THEN CALL ERRFATAL FI
026753             A:=B;       *IRW LV12B DB                 % CONTROLLER
026755             A:=X;       *IRW LV12B DX                 % PARAMETERS
026757             X.NFUNC;    *IRW LV12B DP
026761             LV12;       *MST PID
026763           FI
026763           EXIT
026764   RBUS
026767
026767   SUBR DRTRANS,DL11T,DL12T
026767    %-----------------------------------------------------------------------
026767    % DRIVER LEVEL ROUTINE TO START A DISK TRANSFER
026767    %
026767    % ENTRY: B= DISK DF, X= QUE  DF
026767    %
026767    % EXIT :  BUSY (DO'NT TOUCH "DRIVER" IN DISK DF)
026767    % EXITA:  FINISH   SSSTAT IN QUE DF IS VALID
026767    %
026767    %-----------------------------------------------------------------------
026767   DRTRANS:
026767           A:=L=:X."TRLREG"
026771   *"8DIMI
"026771           IF DMFST><-1 THEN
026775              X:=:B=:DMCDF; "0" BONE 6DL12=:DMSTAT
027002              "DIMI2"=:"DMRUT"; "DIMRS"=:MFUNC
027006              0=:MLINK; CALL RTACT
027010              X:=:B; A:=X."TRLREG"=:P
027013           FI
027013   *"
"027013           "DL11T"=:X.NFUNC; *IOF
027016           CALL ST11L      ; *ION
027020           A:=X."TRLREG"=:L; EXIT        % BUSY RETURN
027023   % ENTRY ON LEV 11, B= DISK DF, X= QUE DF
027023   DL11T:  T:=5; CALL DODMA
027025           "DL12T"=:X.NFUNC; *IOF
027030           CALL ST12L;       *ION
027032           GO WT11
027033   % ENTRY ON LEV 12, B= DISK DF, X= QUE DF
027033   DL12T: A:=X."TRLREG"=:L; EXITA       % FINISH RETURN
027036   RBUS
027047
027047   %==============================================================================
027047   % 11.27        D D R I V E R
027047   %DRIVER ON LEVEL 10-13
027047   SUBR DDRIVER
027047   DDRIVER: *TRA STS
027050          A SH 4 SHZ -14; A-12; A SH 1=:X
027055          CALL RTACT; P+X
027057          CALL ID10; GO DDRIVER
027061          CALL ID11; GO DDRIVER
027063          CALL ID12; GO DDRIVER
027065          CALL ID13; GO DDRIVER
027067   RBUS
027075
027075   @DEV 1
027075   @DEV (S-S-L)XC-P2-2:NPL
027075   %=====================================================================
027075   %
027075   %       S E T 1 0 W I N D O W   LEVEL 10 WINDOW
027075   %       S E T 1 2 W I N D O W   LEVEL 12 WINDOW
027075   %       R E S 1 0 W I N D O W   LEVEL 10 WINDOW
027075   %       R E S 1 2 W I N D O W   LEVEL 12 WINDOW
027075   %
027075   %       SETUP OF TERMINAL WINDOWS.
027075   %       ENTRY : B - RESIDENT DATAFIELD.
027075   %       EXIT  : B - BIG DATAFIELD AND PAGE TABLE IS SET UP.
027075   %       ALL REGISTERS ARE DESTROYED
027075   %
027075   SUBR SET10WINDOW,SET12WINDOW,RES10WINDOW,RES12WINDOW
027075
027075   SYMBOL W10=WND10*2+174000
027075   SYMBOL W12=WND12*2+174000
027075
027075   DOUBLE SV10:=(0,0),SV12:=(0,0)
027101   INTEGER 10FL:=0,12FL:=0
027103
027103   SET10WINDOW:
027103           IF 10FL=0 THEN
027105              1=:10FL; X:=W10; T:=0; *LDDTX; STD SV10         % GET OLD ENTRY AND SAVE IT
027113           FI
027113           AD:=DTDFPHPAGE; A:=:D/\1777+"WND10*2000"=:B        % SET B-REG
027120           A:=142000; X:=W10; T:=0; *STDTX                    % SET UP WINDOW
027124           EXIT
027125   SET12WINDOW:
027125           IF 12FL=0 THEN
027127              1=:12FL; X:=W12; T:=0; *LDDTX; STD SV12         % GET OLD ENTRY AND SAVE IT
027135           FI
027135           AD:=DTDFPHPAGE; A:=:D/\1777+"WND12*2000"=:B        % SET B-REG
027142           A:=142000; X:=W12; T:=0; *STDTX                    % SET UP WINDOW
027146           EXIT
027147   RES10WINDOW:
027147           IF 10FL=0 THEN EXIT FI
027152           0=:10FL; AD:=SV10; X:=W10; T:=0; *STDTX            % RESTORE OLD ENTRY
027157           EXIT
027160   RES12WINDOW:
027160           IF 12FL=0 THEN EXIT FI
027163           0=:12FL; AD:=SV12; X:=W12; T:=0; *STDTX            % RESTORE OLD ENTRY
027170           EXIT
027171
027171   RBUS
027177
027177   %=============================================================================
027177   %      S E T B F W I D N O W    SET UP WINDOW IN PIT.
027177   %                               THE WNDBF WINDOW IS USDED.
027177   %      ENTRY:  B - RESIDENT DATAFIELD
027177   %
027177   %      EXIT:   B - "BIG" DATAFIELD
027177   %              ALL REGISTERS DESTROYED
027177   %              K DESTROYED
027177   SUBR SETBFWINDOW
027177   INTEGER WNDADDR:=WNDBF*2+174000
027200   SETBFWINDOW:
027200          *BLDA 170                                  % K:=IONI (READ ION INDICATOR)
027201          *IOF
027202          AD:=DTDFPHPAGF; A:=:D/\1777+"WNDBF*2000"=:B  % B IS DF. IN BUF.WINDOW
027207          A:=142000; X:=WNDADDR; T:=0; *STDTX          % SET PIT ENTRY
027213          *BSKP ZRO SSK                                % SET ION IF SET ON ENTRY
027214          *ION
027215          EXIT
027216   RBUS
027221
027221   %==============================================================================
027221   % 7.5        M O N T H   M N T H 1         ( M )
027221
027221   % SUBROUTINE TO DETERMINE DAYS IN A MONTH (NEGATIVE)
027221   % A=MONTH, D=YEAR, RETURN WITH RESULT IN T
027221
027221   SUBR MONTH,MNTH1
027221   DOUBLE POINTER D9CL5:=9CLO5
027222   MONTH: AD:=D9CL5
027223   MNTH1: IF A-14<=0 THEN A+14 FI
027227          IF A-2=0 THEN   %FEBRUARY
027231                T:=-35
027232                IF 3/\D=0 THEN T-1 FI
027236                EXIT
027237          FI
027237          IF A-6<0 THEN ;*BSET BCM 0 DA
027242          FI
027242          T:=-37; IF A NBIT 0 THEN T-1 FI
027246          EXIT
027247   RBUS
027247
027247   %==============================================================================
027247   % 7.4        K A L D R   K A L N X   S T R T   ( M )
027247
027247
027247   %SUBROUTINE TO UPDATE CALENDAR, CALLED FOR EACH CLOCK INTERRUPT
027247   % -KALDR- CALLED FROM ICLK
027247   % -KALNX- CALLED FROM CLADJ WITH A=TIME AND X=UNIT
027247
027247   SUBR KALDR,KALNX
027247   SYMBOL 5DAY=4,5MONTH
027247   INTEGER ARRAY 9CLOC=9CLO0,X9CLOC=9CLO1
027247   INTEGER POINTER LREG
027250   KALNX: T:=L=:"LREG"
027252          X:=D1-1; A:=D0        % MOVED FROM CLADJ
027255          A+9CLOC(X)=:9CLOC(X); GO KALN
027260   KALDR: A:=L=:"LREG"
027262   LOOP:  IF ATIM2-MTIM2<=0 GO LREG    %RETURN POINT FOR KALDR
027266          AD:=MTIME; D+1; A:=A+C; AD=:MTIME
027272          X:=0; MIN 9CLOC(X)          %BASIC UNITS
027274   KALN:  DO
027274                IF 9CLOC(X)+STRT(X)<0 GO LOOP
027277   LOOPC:       MIN X9CLOC(X)
027300                A+STRT(X); IF >=0 GO LOOPC
027302                A-STRT(X)=:9CLOC(X)
027304                IF X=5MONTH THEN MIN 9CLOC(X); GO LOOP FI
027311                IF X=5DAY THEN MIN 9CLOC(X); CALL MONTH; T=:MND FI
027317                X+1
027320          OD
027321   RBUS
027331
027331   *"8MPRF
"027331   %
027331   % Mon Performance sampling routines for disks must reside in common
027331   % or excom.
027331   %
027331   % Data area for sampling is on MPIT - which is compiled/assembled later
027331   %
027331   INTEGER CABFUNC=?
027331   INTEGER CDRIV=?
027331   INTEGER CCDAD=?
027331   INTEGER CCTAC=?
027331   INTEGER XDLFLAG=?
027331   INTEGER C5SEG=?
027331   INTEGER 5NPAR=?
027331
027331   INTEGER ARRAY DILGU=?
027331   INTEGER ARRAY CDADR=?
027331
027331   INTEGER XDLXD=?                 % Specific nd-100 program/nd-500 process.
027331   INTEGER XDLYD=?                 % Specific nd-100 segment/nd-500 segment.
027331   INTEGER BDLBUADDR=?
027331   INTEGER SDLBUADDR=?             % Physical addr of "extra data buffer"
027331   DOUBLE  DBDLBUADDR=?
027331   INTEGER BASEG=?
027331   INTEGER SASEG=?
027331   DOUBLE  DDBASEG=?
027331
027331
027331   %
027331   %=========================================================================
027331   % Primitive #32
027331   %
027331   %                         D I A L O
027331   %
027331   % Called from routine CTRDISK on level 11
027331   % Called from SCSI magnetic and optical disk routines on level 11.
027331   %
027331   % Entry: B = Disk datafield
027331   %        X = Disk queue element
027331   %
027331   SUBR DIALO,TDALO,TDALX,TYDAL,RWDAL,XDLOG
027331   INTEGER TREG,AREG,DREG,XREG=?
027334   TRIPLE  TADREG=TREG
027334   INTEGER POINTER LREG
027335   INTEGER CNDX
027336   INTEGER 1LLIM,2LLIM
027340   DOUBLE  CLLIM=1LLIM
027340   INTEGER 1ULIM,2ULIM
027342   DOUBLE  CULIM=1ULIM
027342   INTEGER PCRSAVE
027343
027343   SYMBOL MPNORM=50000              % Mask for MPIT as normal
027343   SYMBOL CLNPIT=103777             % Mask to clear normal pit
027343
027343   % Local subroutine to check legal reserving rtprog
027343   % Entry: none
027343   % Exit : X=xreg
027343   %
027343   % Called in ?BANK mode; returns in 2BANK mode
027343   %
027343   CHRTRES: *2BANK
027344           IF RTSTART>>XREG.RTRES OR RTEND<<=T THEN CALL ERRFATAL FI
027355           EXIT
027356
027356
027356   DIALO:  0/\0; EXIT
027360           TAD=:TADREG
027361           IF ACTMPERFORM=0 THEN                             % Logging activated?
027363              AREG; EXIT                                    % No, return
027365           FI
027365           X=:XREG; A:=L=:"LREG"
027370           LV11B; *TRA PGC
027372           A=:PCRSAVE
027373           A /\ CLNPIT \/ MPNORM; *TRR PCR                  % MPIT as normal
027376           X.ABFUNC
027377           *1BANK
027400           A=:CABFUNC
027401           A SH -6/\7=:CDRIV=:L                                % Current disk drive number
027405           0=:CNDX
027406           % Check if this disk drive should be logged
027406           FOR CNDX DO WHILE X:=CNDX<4
027412              X:=DILGU(X); AD:=X.DS0
027414              IF A=B AND D=L GO FOUND
027420           OD
027422   OUT:    *2BANK
027423           PCRSAVE; *TRR PCR                                   % Back to IPIT
027425           TAD:=TADREG; X:=XREG; GO LREG                       % Return
027430   *)FILL
027442   INTEGER XREG
027443
027443   FOUND:  NODTY=:CCTAC
027445           IF 77/\CABFUNC>=67 OR A>1 AND A<60 GO OUT           % Check for read & write functions
027460           *2BANK
027461
027461           % Log all disk accesses
027461   TDALO:  0/\0; GO TYDAL
027463   TDALX:  0/\0; GO ADALG
027465           *1BANK
027466           CNDX SH 2+"XFDA1"=:X                               % Log accesses within a limited disk area
027472           AD:=X.DS0=:CLLIM; AD:=X.DS2=:CULIM
027476           CABFUNC; X:=XREG
027500           *2BANK
027501           IF A/\77>=2 THEN
027505              AD:=X.ABPA2                                      % Func>=60, double disk addr
027506           ELSE
027507              X.ABP21=:D; A:=0                                 % Func<2, single word disk addr
027512           FI
027512           IF A<<1LLIM OR A=T AND D<<2LLIM GO FAR OUT          % Test current disk addr against specific disk area
027522           IF A>>1ULIM OR A=T AND D>>2ULIM GO FAR OUT
027532   ADALG:  *1BANK
027533           X:=CDADR(CNDX)=:CCDAD
027536           MIN X.2TDAC; P+1; MIN X.1TDAC; 0/\0                 % Count total number of accesses
027542           *2BANK
027543           GO TYDAL
027544   *)FILL
027554
027554   TYDAL:  0/\0; GO RWDAL
027556           *1BANK
027557           CCTAC; X:=XREG; CALL FDTYP; A=:CCTAC; X:=CCDAD
027564           IF CCTAC=ACC1F THEN                                % Branch according to routine switch
027570              MIN X.2FIL1; P+1; MIN X.1FIL1; 0/\0
027574           ELSE IF A=ACC5F THEN
027600              MIN X.2FIL5; P+1; MIN X.1FIL5; 0/\0
027604           ELSE IF A=ACC1S THEN
027610              MIN X.2SWP1; P+1; MIN X.1SWP1; 0/\0
027614           ELSE IF A=ACC5S THEN
027620              MIN X.2SWP5; P+1; MIN X.1SWP5; 0/\0
027624           ELSE IF A=ACCFS THEN
027630              MIN X.2FISG; P+1; MIN X.1FISG; 0/\0
027634           FI FI FI FI FI
027634           *2BANK
027635
027635   RWDAL:  P+1; GO XDLOG
027637           *1BANK
027640           X:=CCDAD
027641           IF CABFUNC NBIT "0" THEN
027644              MIN X.2RRAC; P+1; MIN X.1RRAC; 0/\0              % Count all read accesses
027650           ELSE
027651              MIN X.2TWAC; P+1; MIN X.1TWAC; 0/\0              % Count all write accesses
027655           FI
027655           *2BANK
027656           GO XDLOG
027657   *)FILL
027665
027665   XDLOG:  0/\0; GO FAR OUT
027667           *1BANK
027670           IF XDLFL>5 GO FAR YLO
027674           IF A=1 THEN
027677              IF CCTAC=ACC1F THEN
027703   1MBOK:        CALL FAR CHRTRES; *1BANK
027705                 IF XDLXD=0 OR A=T THEN                        % Test rt-program
027711   RWF:             *1BANK
027712                    X:=CCDAD
027713                    IF CABFUNC NBIT 0 THEN
027716                       MIN X.2XRAC; P+1; MIN X.1XRAC; 0/\0     % Read
027722                    ELSE
027723                       MIN X.2XWAC; P+1; MIN X.1XWAC; 0/\0     % Write
027727                    FI
027727                 FI
027727              FI
027727           ELSE IF A=2 THEN
027733              IF CCTAC=ACC1S THEN
027737                 T:=BASEG; X:=SASEG; *LDATX
027742                 IF A=XDLYD OR T=0 GO 1MBOK                    % Test for nd-100 segment
027747              FI
027747           ELSE IF A=3 THEN
027753              IF CCTAC=ACC5F THEN
027757                 CALL FAR CHRTRES
027760                 IF X:=XDLXD=0 OR X.RTRES=T GO RWF    %???     % Test nd-500 process no.
027765              FI
027765           ELSE IF A=4 THEN
027771              IF CCTAC=ACC5S THEN
027775   5FELS:        IF C5SEG=0 OR A=XDLYD THEN                    % Test for nd-500 segment no.
030002                    *2BANK
030003                    T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
030010   *NNC54,          CNVBYADR
030013                    *1BANK
030014                    IF XDLXD=0 OR A=D GO RWF
030020                 FI
030020              FI
030020           ELSE IF A=5 THEN
030024              IF CCTAC=ACCFS GO 5FELS
030030              IF A=ACC5S AND 5NPAR=7 THEN                      % Modified swapper?
030037                 A:=-1=:D; AD=:CCDAD.D1XRAC; AD=:X.D1XWAC      % No, mark swapper not patched.
030044              FI
030044           FI FI FI FI FI
030044           GO FAR OUT; *)FILL
030065
030065   YLO:    IF A=6 THEN
030070              IF CCTAC=ACC1F THEN
030074   YRWF:         CALL FAR CHRTRES
030075                 A:=T-RTSTART=:D; A:=0; T:=5RTSIZE; *RDIV ST
030103                 A*5
030104   XYRWF:        *1BANK
030105                 T:=BDLBUADDR; X:=SDLBUADDR+A
030110                 IF CABFUNC NBIT 0 THEN
030113                    *LDDTX 20
030114                    D+1; A:=A+C; *STDTX 20
030117                 ELSE
030120                    *LDDTX 40
030121                    D+1; A:=A+C; *STDTX 40
030124                 FI
030124              FI
030124           ELSE IF A=7 THEN
030130              IF CCTAC=ACC1S GO YRWF
030134           ELSE IF A=10 THEN
030140              IF CCTAC=ACC5F THEN
030144                 CALL FAR CHRTRES
030145                 D:=T; CALL FSEMA; GO FAR OUT
030150                 X:=X.MESSBUFF
030151   55FEL:        *2BANK
030152                 T:=5MBBANK; *SENDE@3 LDATX
030154                 A*4-1                                         % TO LDDTX 20/STDTX 20
030156                 GO XYRWF
030157                 *)FILL
030172              FI
030172           ELSE IF A=11 THEN
030176              IF CCTAC=ACC5S GO 55FEL
030202           ELSE IF A=12 THEN
030206              IF CCTAC=ACCFS GO 55FELL
030212              IF A=ACC5S AND 5NPAR=7 THEN
030221                 A:=-1=:D
030223                 T:=BDLBUADDR; X:=SDLBUADDR; *STDTX 20; STDTX 40
030227              FI
030227           FI FI FI FI FI
030227           GO FAR OUT
030230   RBUS
030235   *"
"030235
030235
030235   @DEV 1
030235   @DEV (S-S-L)XC-P2-N500:NPL
030235
030235   %============================================================================
030235   %        ( M )     5 M O N I C O    5 E M O N I C O
030235   %
030235   % Entry: X= message address
030235   %        A= function value
030235   %        T= clear cache mask  (if 5MONICO)
030235   %        D= write back mask
030235   %
030235   SUBR 5MONICO,5EMONICO
030235   INTEGER KKFLIP,CLCACHE,WBMASK
030240
030240   5EMONICO:T:=D=:WBMASK; 0=:CLCACHE; T:=1; GO MOICO
030245   5MONICO: T=:CLCACHE; T:=D=:WBMASK; T:=0
030251   MOICO:   T=:KKFLIP:=5MBBANK; A=:D; A:=0; *AAX FUNCV; STDTX    % Set function value
030257            A:=KKFLIP; *AAX KFLIP-FUNCV; STATX                   % Set error flag on/off
030262            A:=WBMASK; *AAX NUMPA-KFLIP;  STATX                  % Set parameter write back mask
030265            3MONCO; *AAX -NUMPA; STATX XMICF                     % Restart after monitor call
030270            CLCACHE\/140300; *AAX H500A; STATX; AAX -H500A       % Set clear cache status
030275            L=:D; MSGN500; CALL WN5STATUS
030300            D=:L:=X; *AAX XADPR; LDXTX
030304            X.PSTAT/\5CLRUNSTATUS+5ACTIVE=:X.PSTAT               % Set process active
030310            D=:X; EXIT
030312   RBUS
030316
030316
030316   %===============================================================================
030316   %      ( C )    C L E 5 S T A T U S
030316   %
030316   % Routine to clear Status register
030316   %
030316   % When called from other levels than the driver level then
030316   % CLESTATUS must be called with interrupt off.
030316   %
030316   % ENTRY:     A=Mask to clear status with:
030316   %              177377 Clear latched "power has been off" Status (bit 5POWOF=10)
030316   %              177177 Also clear "power fault executed by Microprog" (5PFAIL=7)
030316   %
030316   % EXIT:      A=ND-500 Status after clearing
030316   %              BIT  5PAGF=4 (000020) = Inclusive "or" of errors
030316   %              BIT 5DMAER=6 (000100) = Communication error
030316   %              BIT 5PFAIL=7 (000200) = Power fault executed by Microprog
030316   %              BIT 5POWOF=8 (000400) = Latched power fault
030316   %              BIT 5CLOST=9 (001000) = Microclock stopped
030316   %
030316   SUBR CLE5STATUS
030316   INTEGER POINTER LREG
030317   CLE5STATUS:
030317          A=:D; T:=HDEV+RSTA5; *IOXT
030323          IF A BIT 5POWOF OR A BIT 5PFAIL THEN
030327             IF A BIT 5PFAIL OR C5STAT BIT BHPFAIL THEN
030334                A:=L=:"LREG"
030336                CALL TER500; GO CLABORT
030340                10;   T:=HDEV+LCON5;  *IOXT
030344                      T+"RSTA5-LCON5"; *IOXT
030346                A/\D; T+"LSTA5-RSTA5"; *IOXT
030351                "0";  T+"LCON5-LSTA5"; *IOXT
030354   CLABORT:     "LREG"=:L; T:=HDEV+RSTA5; *IOXT
030361             ELSE
030362                A BONE 5POWOF BZERO 5PFAIL
030364             FI
030364          FI; EXIT
030365   RBUS
030366
030366   %============================================================================
030366   %        ( C )   I T O F I F O Q
030366   %
030366   % Insert message in the N5000-FIFO-queue
030366   %
030366   % Called from other levels than driver in IOF.
030366   % The N100/N500 general semaphore must be locked.
030366   %
030366   % ENTRY:     X=Message to insert in queue
030366   %
030366   SUBR ITOFIFOQ
030366   INTEGER XREG
030367   INTEGER POINTER LREG
030370
030370   ITOFIFOQ:
030370   *NNJ02=*
030370         P+1; EXIT                           % Direct exit if "old" 500
030372         A:=L=:"LREG"; X=:XREG
030375         T:=5MBBANK; X:="N500DF".X500DF; *AAX X5MXF; LDATX
030402         A=:L; *AAX X5FYL-X5MXF; LDATX
030405         IF A=:D+1>=L THEN A:=0 FI; *STATX
030413         D SH 1=:L; *AAX X5FIF-X5FYL; LDDTX
030417         *CNVBYADR
030422         X:=D+L; T:=A+C; XREG=:D; A:=5MBBANK
030430         *CNVWADR
030433         *STDTX
030434         X:=XREG; GO LREG
030436   RBUS
030441
030441   @DEV 1
030441   *EEXCC=*
030441   @EOF
030441
030441
030441   File : (SAMSON)KILL-MACROS:DUMY
170000   *STPBS/
170000   @DEV (S-S-L)PH-P2-START-BASE:NPL
170000   %=====================================================================
170000   % GLOBAL DATA FOR SINTRAN START/RESTART
170000   %=====================================================================
170000   %
170000   DOUBLE ARRAY ZHDLCSIZE(100)  % SIZE OF HDLC BUFFER GREATER THAN 1777B WORDS
170200   *XSBFI=*+200                 % USED BY RESTART ROUTINE (SETPTABLE)
170200
170200   SYMBOL MT1MASK=170020        % USED TO FIND WHICH MT.TYPE (STC OR CIPHER/PERTEC)
170200   SYMBOL MT2MASK=20            % USED TO FIND WHICH MT.TYPE (STC OR CIPHER/PERTEC)
170200
170200   DISP 0   % MAIN-SWAPPING-DISC DATA
170200    INTEGER SWDDFIELD           % ADDRESS OF DATAFIELD
170200    INTEGER SWDLOGNO            % LOGICAL DEVICE NUMBER
170200    INTEGER SWDSWDRIVER         % DRIVER USED BY BOOTS-STRAP, ("SWAP DRIVER")
170200    INTEGER SWDDRIVER           % START-UP DRIVER
170200    INTEGER SWHDEV              % HARDW. DEV NO FOR SWAPPE CONT.
170200   PSID
170200
170200   BASE SBFIELD
170200   INTEGER XIOBUTAB:=IOBUTAB    % ADDRESS OF IOBUTAB
170201   INTEGER ARRAY BIGDDFS:=(BIGDI,BIGD2,BIGD3,BIGD4)
170205   INTEGER ARRAY WDIDFS:=(WIGDI,WIGD2)
170207   INTEGER CBUF                 % ADDRESS OF CURRENT I/O BUFFER
170210   INTEGER ASCBUF               % LOGICAL START ADDR OF I/O BUFFERS IN
170211   INTEGER LPHYSPAGE            % LAST PAGE IN MEMORY
170212   INTEGER DBFNO:=5BUFA         % NUMBER OF DEVICE-BUFFER-HEADERS.
170213
170213   DOUBLE ARRAY DMMLIMS(0)
170213   DOUBLE MMDPAGE(0)
170213   INTEGER MMFPAGE:=-1          % FIRST PAGE OF MEMORY MAP
170214   INTEGER MMLPAGE:=-1          % LAST PAGE OF MEMORY MAP
170215   DOUBLE DBDPAGE(0)
170215   INTEGER DBFPAGE:=-1          % FIRST PAGE USED AS DEVICE BUFFER
170216   INTEGER DBLPAGE:=-1          % LAST PAGE USED AS DEVICE BUFFER
170217   DOUBLE DLAMPAGE(0)
170217   INTEGER FLAMPAGE:=-1         % FIRST PHYSICAL PAGE FOR LAMU TABLES
170220   INTEGER LLAMPAGE:=-1         % LAST PHYSICAL PAGE FOR LAMU TABLES
170221   DOUBLE SGTDPHPAGE(0)
170221   INTEGER SGTFPHPAGE:=-1       % FIRST PHYSICAL PAGE FOR SEGMENT TABLE
170222   INTEGER SGTLPHPAGE:=-1       % LAST PHYSICAL PAGE FOR SEGMENT TABLE
170223   DOUBLE LGTDPHPAGE(0)
170223   INTEGER LGTFPHPAGE:=-1       % FIRST PHYSICAL PAGE IN LOGICAL NUMBER TABLE
170224   INTEGER LGTLPHPAGE:=-1       % LAST PHYSICAL PAGE IN LOGICAL NUMBER TABLE
170225   DOUBLE ECODPHPAGE(0)
170225   INTEGER ECOFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED BY EXT. COMMON
170226   INTEGER ECOLPHPAGE:=-1       % LAST PHYSICAL PAGE USED BY EXT. COMMON
170227   DOUBLE RPIDPHPAGE(0)
170227   INTEGER RPIFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED BY RPIT
170230   INTEGER RPILPHPAGE:=-1       % LAST PHYSICAL PAGE USED BY RPIT
170231   DOUBLE MPIDPHPAGE(0)
170231   INTEGER MPIFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED BY MPIT
170232   INTEGER MPILPHPAGE:=-1       % LAST PHYSICAL PAGE USED BY MPIT
170233   DOUBLE IPIDPHPAGE(0)
170233   INTEGER IPIFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED BY IPIT
170234   INTEGER IPILPHPAGE:=-1       % LAST PHYSICAL PAGE USED BY IPIT
170235   DOUBLE SYMDPHPAGE(0)
170235   INTEGER SYMFPHPAGE:=-1       % FIRST PHYSICAL PAGE IN BIG SYNC-MODEM BUFFER
170236   INTEGER SYMLPHPAGE:=-1       % LAST PHYSICAL PAGE IN BIG SYNC-MODEM BUFFER
170237   DOUBLE CMDPHPAGE(0)
170237   INTEGER CMFPHPAGE:=-1        % FIRST PHYSICAL PAGE USED BY COMMON CODE
170240   INTEGER CMLPHPAGE:=-1        % LAST PHYSICAL PAGE USED BY COMMON CODE
170241   DOUBLE DPIDPHPAGE(0)
170241   INTEGER DPIFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED BY DPIT
170242   INTEGER DPILPHPAGE:=-1       % LAST PHYSICAL PAGE USED BY DPIT
170243   DOUBLE RSDPHPAGE(0)
170243   INTEGER RSFPHPAGE:=-1        % FIRST PHYSICAL PAGE USED BY RESTART ROUTINE
170244   INTEGER RSLPHPAGE:=-1        % LAST PHYSICAL PAGE USED BY RESTART-ROUTINE AND REGBLOCKS/BITMAPS
170245   DOUBLE POWDPAGE(0)
170245   INTEGER POWFPAG:=-1          % FIRST PHYSICAL PAGE USED BY THE PAGE-OWNER TABLE
170246   INTEGER POWLPAG:=-1          % LAST PHYSICAL PAGE USED BY THE PAGE-OWNER TABLE
170247   DOUBLE DTADPHPAGE(0)
170247   INTEGER FTADPAGE:=-1         % FIRST PHYSICAL PAGE USED FOR TAD DATAFIELDS
170250   INTEGER LTADPAGE:=-1         % LAST PHYSICAL PAGE USED FOR TAD DATFIELDS
170251   DOUBLE TDDPAGE(0)
170251   INTEGER TDFPAGE:=-1          % FIRST PHYSICAL PAGE USED FOR TERM. DATAFIELDS
170252   INTEGER TDLPHPAGE:=-1        % LAST PHYSICAL PAGE USED FOR TERM. DATAFIELDS
170253   DOUBLE IOBDPHPAGE(0)
170253   INTEGER IOBFPHPAGE:=-1       % FIRST PHYSICAL PAGE USED FOR I/O BUFFERS
170254   INTEGER IOBLPHPAGE:=-1       % LAST PHYSICAL PAGE USED FOR I/O BUFFERS
170255   DOUBLE RTSGDPPHPAGE(0)
170255   INTEGER RTSGFPHPAGE:=-1      % FIRST PHYSICAL PAGE IN RT'S SYSTEM SEGMENT
170256   INTEGER RTSGLPHPAGE:=-1      % LAST PHYSICAL PAGE IN RT'S SYSTEM SEGMENT
170257   DOUBLE PITSDPHPAGE(0)
170257   INTEGER PITSFPHPAGE:=76      % FIRST PHYSICAL PAGE USED TO PITS
170260   INTEGER PITSLPHPAGE:=77      % LAST PHYSICAL PAGE USED TO PITS
170261   DOUBLE DHDLCPAGES(0)
170261   INTEGER HDLCFPHPAGE:=-1      % FIRST PHYSICAL PAGE USED TO HDLC BUFFER
170262   INTEGER HDLCLPHPAHE:=-1      % LAST PHYSICAL PAGE USED TO HDLC BUFFER
170263   DOUBLE DEDPHPAGES(0)
170263   INTEGER EDFPHPAGE:=-1        % FIRST PHYSICAL PAGE USED BY THE EDIT-ROUTINE SEG.
170264   INTEGER EDLPHPAGE:=-1        % LAST PHYSICAL PAGE USED BY THE EDIT-ROUTINE SEG.
170265   DOUBLE DBACSPHPAGES(0)
170265   INTEGER BACSFPHPAGE:=-1      % FIRST PHYSICAL PAGE USED BY BACKGROUND ALLOCATION TABLES
170266   INTEGER BACSLPHPAGE:=-1      % LAST PHYSICAL PAGE USED BY BACKGROUND ALLOCATION TABLES
170267   DOUBLE 5PIDPHPAGE(0)
170267   INTEGER 5PIFPHPAGE:=-1       % FIRST PHYS PAGE USED BY 5PIT SEGMENT
170270   INTEGER 5PILPHPAGE:=-1       % LAST PHYS PAGE USED BY 5PIT SEGMENT
170271   DOUBLE D8LOGPHPAGE(0)
170271   INTEGER 8LOGFPHPAGE:=-1      % FIRST PHYS PAGE USED FOR PROGRAM-LOG SAMPLING BUFFER
170272   INTEGER 8LOGLPHPAGE:=-1      % LAST PHYS PAGE USED FOR PROGRAM-LOG SAMPLING BUFFER
170273   DOUBLE DSPTRPHPAGE(0)
170273   INTEGER SPTRFPHPAGE:=-1      % FIRST PAGE USED FOR "SPARE-TRACK-ADDR-BUFFER"
170274   INTEGER SPTRLPHPAGE:=-1      % LAST PAGE USED FOR "SPARE-TRACK-ADDR-BUFFER"
170275   DOUBLE DCMCLPAGE(0)
170275   INTEGER CMCLFPHPAGE:=-1      % FIRST PHYS.PAGE USED FOR MON.CALL LOG
170276   INTEGER CMCLLPHPAGE:=-1      % LAST PHYS.PAGE USED FOR MON.CALL LOG
170277   DOUBLE DRTWFPAGE(0)
170277   INTEGER FRTWFPAGE:=-1        % FIRST PHYSICAL PAGE USED FOR RT-PROG'S MON.CALL WORKING FIELD
170300   INTEGER LRTWFPAGE:=-1        % LAST PHYSICAL PAGE USED FOR RT-PROG'S MON.CALL WORKING FIELD
170301   DOUBLE DCACHEINHIBIT(0)
170301   INTEGER FPHPCACHEINHIBIT:=-1 % FIRST PHYS PAGE FOR CACHE-INHIBIT BITMAP
170302   INTEGER LPHPCACHEINHIBIT:=-1 % LAST PHYS PAGE FOR CACHE-INHIBIT BITMAP
170303   DOUBLE SCPHYSPAGE(0)
170303   INTEGER SCFPHYSPAGE:=-1      % FIRST PHYS PAGE FOR SCSI BUFFERS
170304   INTEGER SCLPHYSPAGE:=-1      % LAST PHYS PAGE FOR SCSI BUFFERS
170305   DOUBLE NUPHYSPAGE(0)
170305   INTEGER NUFPHPAGE:=-1        % FIRST PHYS PAGE FOR NUCLEUS
170306   INTEGER NULPHPAGE:=-1        % LAST PHYS PAGE FOR NUCLUES
170307   DOUBLE OCPHYSPAGE(0)
170307   INTEGER OCFPHPAGE:=-1        % FIRST PHYS PAGE FOR OCTOBUS
170310   INTEGER OCLPHPAGE:=-1        % LAST PHYS PAGE FOR OCTOBUS
170311   DOUBLE IERDPHPAGE(0)
170311   INTEGER IERFPHPAGE:=-1       % FIRST PHYS PAGE FOR ERROR DEV BUFFER
170312   INTEGER IERLPHPAGE:=-1       % LAST PHYS PAGE FOR ERROR DEV BUFFER
170313   DOUBLE  FSEDP(0)             % USED FOR FIXING FILESYSTEM IN FLOMEM (MOL)
170313   INTEGER FSEFP:=-1            % FIRST PHYS PAGE FOR FILESYSTEM
170314   INTEGER FSELP:=-1            % LAST PHYS PAGE FOR  FILESYSTEM
170315   DOUBLE  UCPAG(0)
170315   INTEGER UCFPA:=-1            % FIRST PHYS PAGE FOR MICRO CODE
170316   INTEGER UCTPA:=-1            % LAST  PHYS PAGE FOR MICRO CODE
170317
170317   INTEGER EMMLIMS(0)
170317
170317
170317   INTEGER NPLAMU               % NUMBER OF PAGES USED BY LAMU TABLES
170320   INTEGER POWSIZE              % SIZE OF PAGE-OWNER TABLE
170321   INTEGER CLAMSIZE             % SIZE OF LAMU DESCRIPTION TABLE
170322   INTEGER MMSIZE               % SIZE OF MEMORY MAP
170323   INTEGER CURRPAGE             % CURRENT PAGE NUMBER TO CHECK
170324   INTEGER CHDLCF               % HDLC FLAG
170325   INTEGER C1IOB,C2IOB
170327   DOUBLE CIOBENTRY=C1IOB       % IOBUTAB ELEMENT
170327   INTEGER NPSGTAB              % NUMBER OF PAGES IN SEGMENT TABLE
170330   INTEGER CSWPDF               % ADDR OF SWAP-DISC DATAFIELD
170331   INTEGER CDIFELEMENT          % ADDR OF SWAP-DISC LAY-OUT ELEMENT
170332   INTEGER 1CDDMADR,2CDDMADR
170334   DOUBLE CDDMADR=1CDDMADR      % MEMORY ADDR USED FOR DISC TRANSFERS
170334   INTEGER CDABLPAGE            % NUMBER OF DISC SECTORS PER TRACK
170335   INTEGER CDTBLCK              % DESTINATION DISC ADDR
170336   INTEGER CDFBLCK              % SOURCE DISC ADDR
170337   INTEGER CDNBLCK              % NUMBER OF SECTORS TO TRANSFER IN DISC TRANSFER
170340   INTEGER CCOUNT
170341   DOUBLE ARRAY POINTER DCCTAB:=CCTAB
170342   INTEGER ARRAY POINTER ACCTAB=DCCTAB
170342   INTEGER ARRAY POINTER PNSWPAGE:=NSWPAGE
170343   INTEGER POINTER ICINDADDR
170344   DOUBLE POINTER CINDADDR=ICINDADDR
170344   INTEGER XT,XA,XD,XXX; DOUBLE XAD=XA; TRIPLE XTAD=XT
170350   INTEGER POINTER CLINK
170351   INTEGER PREVX,PREVT
170353   DOUBLE ARRAY POINTER PNINITPAGE:=NINITPAGE
170354   DOUBLE ARRAY POINTER PLAMARR:=LAMARR
170355   INTEGER 1CCTAB,2CCTAB
170357   INTEGER 0CINX
170360   INTEGER NPAGES
170361   INTEGER NNRTP                % NUMBER OF RT-DESCRIPTIONS
170362   INTEGER BUSYMOD
170363   INTEGER CFIOFLG              % FLAG USED IN CFIOBUF
170364   INTEGER ERTDLGADDR           % END OF AREA USED FOR REG-BLOCKS/REE-BITMAP
170365   TRIPLE CTIOBENTRY(0)
170365   INTEGER TRLND,BINSZ,BOUSZ
170370   DOUBLE TBUSZ=BINSZ
170370   INTEGER DFTINDX
170371   INTEGER DFTEND
170372   INTEGER DFTELEM
170373   INTEGER FREBIT
170374   INTEGER BTNUM
170375   INTEGER 0DFADDR
170376   INTEGER CSAVX
170377   INTEGER GPART
170400   INTEGER CFPHYSPAGE           % FIRST THAT CAN BE USED FOR VARIOUS BUFFERS
170401   INTEGER CFSYSEG              % FIRST SYSTEM SEGMENT NUMBER
170402   INTEGER PROLOG(0)
170402   DOUBLE DPROLOG               % PROTECT AND LOGADR IN MEMORY MAP ELEMENT
170404   INTEGER CSGNO
170405   INTEGER CSGSIZE
170406   INTEGER NXMADR
170407   INTEGER CBLST
170410   INTEGER TMRADDR
170411   INTEGER ETMRADDR
170412   INTEGER IPIBANK
170413   INTEGER RPIBANK
170414   INTEGER MPIBANK
170415   INTEGER C1DFADDR,C2DFADDR
170417   DOUBLE DCDFADDR=C1DFADDR
170417
170417   INTEGER CSPERI=NPAGES        % CURRENT LOG.UNIT.NO FOR SPOOLING
170417   INTEGER NTADS=NPAGES         % NUMBER OF TAD'S IN THIS SYSTEM
170417   INTEGER AD1500=CSGNO         % ADDRESS OF LOG.UNIT. TABLE D1500
170417   INTEGER AETADS=CBLST         % ADDR OF LAST TAD DF.+1 IN LOG.UNIT TABLE
170417   INTEGER 1TDFADDR=1CDDMADR
170417   INTEGER 2TDFADDR=2CDDMADR
170417   DOUBLE DTDFADDR=1TDFADDR
170417
170417   @ICR
170417   INTEGER ARRAY CCNVRT:=(DV000,   0,DV200,DV300,DV400,DV500,DV600,DV700,
170427                         D1000,D1100,D1200,D1300,D1400,D1500,D1600,D1700,
170437                         D2000,D2100,D2200,D2300,D2400,D2500,D2600,D2700,
170447                         D3000,D3100,    0,D3300,D3400,D3500,D3600,D3700);
170457
170457   INTEGER ARRAY VSXIMICP:=(SP01J,SP02J,SP03J,SP04J,SP05J,SP06J,SP07J,SP08J,
170467                            SP09J,SP10J,SP11J,SP12J,SP13J,SP14J,-1);
170476   INTEGER ARRAY VSXMMICP:=(SP15J,-1);
170500   @CR;
170500   INTEGER NBPROGS              % NUMBER OF BACKGROUND PROGRAMS
170501   INTEGER CNBATCHES            % NUMBER OF BATCHES
170502   INTEGER CPRVTSIZE            % SIZE OF THE PRVTTABLE
170503   INTEGER SWPDRIVER            % ADDRESS OF "SWAP-DRIVER"
170504   INTEGER CBPRTSIZE            % SIZE OF SBPRTAB
170505   INTEGER FXCTSIZE             % SIZE OF FXCTABLE
170506   INTEGER ARRAY DAMO(0); *37
170507   INTEGER CCFEB; *37;36;37;36;37;37;36;37;36;37
170522   INTEGER ARRAY DFTBIT(40)     % BIT MAP ARRAY FOR "INTDFIELDS"
170562   INTEGER 1CLTIMER,2CLTIMER
170564   INTEGER XXSWTYPE             % FLAG FOR FIXED 30/60/90 MB DISC (PHOENIX)
170565
170565   ESAB
170565
170565   *0DMML=DMMLI; 0EMML=EMMLI             % GLOBAL FOR MON CONFIG.
170565
170565   %%INTEGER ARRAY XTDFELT(200),XEDFELT(0) % USED TO BUILD DATAFIELDS
170565   *XTDFE=*; *+200/XEDFE=*
170765
170765   TRIPLE ARRAY ESARRAY(ESMAX)           % DATA FOR ENTSG MONITOR CALL
171075   INTEGER      ESEARRAY(0)              % END OF ABOVE
171075
171075   INTEGER ARRAY TMMAP(20)               % BIT SET FOR EACH EXISTING MEMORY BANK
171115                                         % MAX=64*16*16=16384 PAGES (=32MB)
171115   @ICR;
171115   % TABLE OF ALL PIOCS, EACH ENTRY CONSIST OF THE FOLLOWING 2 LOCATIONS
171115   %       0: ADRESS OF DATAFIELD
171115   %       1: LOGICAL DEVICE NUMBER
171115   DOUBLE ARRAY PIOCS:=(
171115          PIO01,1700, PIO02,1701, PIO03,1702, PIO04,1703,
171125          PIO05,1704, PIO06,1705, PIO07,1706, PIO08,1707,
171135          PIO09,1710, PIO10,1711, PIO11,1712, PIO12,1713,
171145          PIO13,1714, PIO14,1715, PIO15,1716, PIO16,1717,
171155          ETRN1,2240, ETRN2,2241, ETRN3,2242, ETRN4,2243,
171165          -1);
171166
171166   % TABLE OF ALL "BIG-DISKS", EACH ENTRY CONSIST OF THE FOLLOWING 3 LOCATIONS
171166   %       0: ADDRESS OF DATAFIELD
171166   %       1: LOGICAL DEVICE NUMBER
171166   %       2: IDENT CODE (LEVEL 11)
171166   INTEGER ARRAY BDISTABLE:=(
171166          BIGDI,1100,17,    BIGD2,1207,20,
171174          BIGD3, 565, 2,    BIGD4, 566, 6,
171202          -1);
171203
171203   % TABLE OF ALL STC MAG.TAPES, CIPHER/PERTEC MAG.TAPES AND WINCHESTER DISKS
171203   % EACH ENTRY CONSIST OF THE FOLLOWING 4 LOCATIONS
171203   %       0: ALTERNATIVE 1 DATAFIELD, I.E. STC MAG.TAPE
171203   %       1: ALTERNATIVE 2 DATAFIELD, I.E. CIPHER/PERTEC MAG.TAPE OR WINCHESTER DISK
171203   %       2: LOGICAL DEVICE NUMBER
171203   %       3: IDENT CODE (LEVEL 11)
171203   DOUBLE ARRAY DMTDITABLE(0);
171203   INTEGER ARRAY MTDITABLE:=(
171203          STMT1,TMMT1, 560,3,      STMT2,TMMT2,1111,7,
171213          STMT3,WIGD2,1231,5,      STMT4,WIGDI,1224,1,
171223          -1);
171224
171224   % TABLE OF LOGICAL DEVICE UNITS OF MAG.TAPE I/O DATAFIELDS
171224   % EACH ENTRY CONSISTS OF THE FOLLOWING 9 LOCATIONS
171224   %      0: LOG.DEV.NO OF CONTROLLER DATAFIELD
171224   %      1: LOG.DEV.NO OF MAG.TAPE UNIT #0 DATAFIELD
171224   %      2: LOG.DEV.NO OF MAG.TAPE UNIT #1 DATAFIELD
171224   %      3: LOG.DEV.NO OF MAG.TAPE UNIT #2 DATAFIELD
171224   %      4: LOG.DEV.NO OF MAG.TAPE UNIT #3 DATAFIELD
171224   %      5: ADDRESS OF MAG.TAPE UNIT #0 DATAFIELD
171224   %      6: ADDRESS OF MAG.TAPE UNIT #1 DATAFIELD
171224   %      7: ADDRESS OF MAG.TAPE UNIT #2 DATAFIELD
171224   %     10: ADDRESS OF MAG.TAPE UNIT #3 DATAFIELD
171224   %
171224   INTEGER ARRAY XMTTABLE:=(
171224           560,  40,  41,  25,  33,MTDI1,MTDI2,MTDI3,MTDI4,
171235          1111,  32,  34, 563, 564,M2DI1,M2DI2,M2DI3,M2DI4,
171246          1231,1232,1233,1234,1235,M3DI1,M3DI2,M3DI3,M3DI4,
171257          1224,1225,1226,1227,1230,M4DI1,M4DI2,M4DI3,M4DI4,
171270          -1);
171271   @CR;
171271
171271   INTEGER ARRAY FLOP1:=(SFDD1,FDID1,1145,21) % OLD DF;NEW DF;LOGNO;IDENT-CODE
171275   INTEGER ARRAY FLOP2:=(SFDD2,FDID2,1156,22)
171301   INTEGER ARRAY TDISORT:=(BIGDI,BIGD2,BIGD3,BIGD4,WIGDI,WIGD2,-1)
171310
171310   @ICR;
171310   INTEGER ARRAY CX21TABLE:=(
171310           X21F1, 1374,
171312           X21F2, 1375,
171314           X21F3, 1376,
171316           X21F4, 1377,
171320           X21F5, 1774,
171322           X21F6, 1775,
171324           X21F7, 1776,
171326           X21F8, 1777,
171330           -1);
171331   SYMBOL TBLX21SIZE=2;
171331
171331   INTEGER ARRAY CCMPIT:=(
171331           CCM01,CCM02,CCM03,CCM04,CCM05,CCM06,CCM07,CCM08,CCM09,
171342           CCM10,CCM11,CCM12,CCM14,
171346           -1);
171347   INTEGER ARRAY CCRPIT:=(
171347           CCR01,CCR02,CCR03,CCR04,CCR05,CCR06,CCR07,CCR08,CCR09,
171360           -1);
171361   DOUBLE ARRAY DMPM4(20);            % MPM4 MEMORY
171421   @CR;
171421
171421   %===========================================================================
171421   *ESBFI=*
171421   *99EBU=*@-12+1@12             % START OF ERROR RING BUFFER.
171421
171421   @DEV 1
171421   @EOF
171421
026000   %$--:COMMON                    % FOR SPLITTING AV LISTING.
026000   @DEV (S-S-L)PH-P2-MEMTOF:NPL
026000   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
026000   %%                                                           %%
026000   %%     M E M T O F   -   MEMORY DUMP TO SEVERAL FLOPPIES     %%
026000   %%                                                           %%
026000   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
026000
026000   * MTPG=*-1@-12@12+2000
026000   * PGNO=*@-12
026000   INTEGER ARRAY MDUMP(2000)    % USED TO COPY THE PAGE TABLE ENTRIES
030000
030000   %--- GLOBAL VARIABLES -------------------------------------
030000
030000   INTEGER ARRAY REGSV(200)     % REGISTERBLOCK SAVE-AREA
030200   INTEGER ARRAY INTSM(20)      % SAVE AREA OF INTERNAL REGISTERS
030220   INTEGER ARRAY PGSSV(20)      % SAVE AREA OF PAGING STATUS REGISTERS
030240   INTEGER MTFSTA               % FLOPPY STATUS
030241   INTEGER LMEMORY:=0           % NO OF PAGES TO TRANSFER (MEMORY SIZE)
030242   INTEGER LVERSION:=5          %% VERSION IDENTIFICATION THAT IS   %%
030243   INTEGER LREVISION:=0         %% TO BE MATCHED WITH INVESTIGATOR  %%
030244   INTEGER FFORM:=177777        % FLOPPY FORMAT
030245   INTEGER SHPAGE:=PGNO         % PAGE USED TO COPY PAGE TABLE ENTRIES
030246   INTEGER ARRAY CHAMP(10)      % FIELD CONTAINING EXISTING
030256                                % MEMORY LOCATION : I   START
030256                                %        LOCATION : I+1 END
030256
030256   INTEGER LMSG1:=  '$-- MEMTOF-100 Sintran VSX/L--$'
030276   INTEGER LMSG2:=  '$ Insert a new F O R M A T T E D   diskette and'
030326   INTEGER LMSG3:=  '$ type one character to continue...'
030350   INTEGER LMSG4:=  '$ Page dumped : '
030361   INTEGER FIDU:=  '$$--Dump finished --$'
030374
030374   INTEGER BUSDV:= '$$ Device busy!$'
030405   INTEGER FLER1:= '$$ Error; status 1 = '
030420
030420   INTEGER  CMD:=1
030421   INTEGER         NSECT                  % NO OF SECTORS PR BLOCK
030422   INTEGER         MNBLK                  % NO OF BLOCKS
030423   INTEGER         NOOK                   % BLOCK COUNTER
030424   INTEGER         DSKAD   := 0           % DISC ADDRESS
030425   INTEGER         0PCOUNT                % PAGE COUNTER
030426   INTEGER         MPAGS   := 0           % NO OF PAGES AVAILABLE ON THE DISKETTE
030427   INTEGER         PGCOP   := 0           % NO OF PAGES COPIED TO THE DISKETTE(S)
030430   INTEGER         STOP                   % LOOP UPPER VALUE
030431   @ICR;
030431                                          % FORMAT 0-17 NB OF PAGES
030431   INTEGER ARRAY PAGTAB:=( 232, 220, 175,   0,
030435                           464, 440, 372,   0,
030441                           440, 372,   0, 464,
030445                          1101, 764,   0,1150);
030451                                           % NO OF SECT. PR. PAGE(FORMAT 0-17)
030451   INTEGER ARRAY SECTAB:=(0004,0010,0020,0000,
030455                          0004,0010,0020,0000,
030461                          0004,0010,0000,0002,
030465                          0004,0010,0000,0002);
030471   @CR;
030471
030471   SUBR MEMTOF,MEMTR,WFLOP,XFLOP
030471
030471   INTEGER         INCOUNT                     % COUNTER IN CHAMP
030472   INTEGER POINTER LDRIVER=?                   % FLOPPY DRIVER START ADDRESS
030472   INTEGER POINTER LTRNSF=?                     % MEMORY TO FLOPPY TRANSFER ROUTINE
030472   INTEGER         LCURAD                      % CURRENT ADDRESS
030473   INTEGER         FSADR                       % START ADDRESS OF REGISTER SAVE
030474   INTEGER         LVNO                        % LEVEL
030475   INTEGER         LEVEL
030476   INTEGER ARRAY LSRBI(0) ; *SRB 0
030477   INTEGER ARRAY LTRAA(0) ; *TRA 0
030500
030500   %--- ND-100 INSTRUCTIONS ----------------------------------
030500   %
030500   SYMBOL MSEX=     150406               % SET EXTENDED ADDRESS MODE
030500   SYMBOL MREX=     150407               % SET NORMAL ADDRESS MODE
030500   SYMBOL MPGC=     000014               % PAGING CONTROL REGISTER READ (TRA PGC)
030500
030500   MEMTOF:*TRA STS                             % Read status
030501          *MSEX                                % SET EXTENDED
030502          A:=7 ; *TRR PCR                      % RING 3 TO PCR
030504
030504          "REGSV"=:FSADR
030506          0=:LEVEL
030507          FOR LEVEL TO 17 DO
030513            LEVEL SHZ 3=:LVNO+FSADR=:LCURAD:=LSRBI(0)
030522            X:=LCURAD; T:=LVNO; A\/T; *EXR SA   % SAVE REG. BLOCK
030526          OD
030532          LTRAA(0)=:D
030535          FOR X:=0 TO 17 DO
030541            A:=X SHZ 3; *IRW 30 DA; TRA MPGC    % READ PGC (LEVEL IN A-REG)
030545            A=:PGSSV(X)
030546            T:=D\/X; *EXR ST                   % READ INT.REG. (NO IN X-REG)
030551            A=:INTSM(X)
030552          OD
030554
030554   MEMTR: "LMSG1"; CALL 3UTXT; *IOX 1562        % READ FLOPPY STATUS
030557          A=:MTFSTA
030560          CALL 0CHMEM
030561          0=:INCOUNT
030562
030562       FOR INCOUNT STEP 2 TO 10 DO
030566          CHAMP(INCOUNT) =: PGCOP
030571          IF A =- 1 GO FAR FINI
030574          X + 1 =: X
030576          CHAMP(X)  =: LMEMORY
030600
030600          0 =: MPAGS
030601   NEXTF: PGCOP+MPAGS=:PGCOP                   % Next floppy
030604          IF LMEMORY=PGCOP GO ENDDO
030610          CALL ASKCH                           % Ask for floppy diskette
030611          *IOX 1562                            % Read floppy status
030612          A =: MTFSTA
030613          IF MTFSTA<0 THEN                     % DMA FLOPPY
030615            0=:A=:D; X:=1; T:="42"
030621            CALL FDRI2; GO FAR MWERR; GO FAR MBUS   % READ FORMAT
030624            A=:X SHZ 10 +1=:CMD                     % FORMAT/WRITE COMMAND
030630            T:="FDRI2"; "DMA"
030632          ELSE                                 % PIO FLOPPY
030633            X:=0; T:="FDRI1"; "PIO"
030636          FI
030636          A=:"LTRNSF"; T=:"LDRIVER"; X=:FFORM
030641          T:=PAGTAB(X)=:MPAGS                  % NO OF PAGES IN DISK
030643          IF LMEMORY-PGCOP<T THEN A=:MPAGS FI  % PAGES TO TRANSFER
030650          MPAGS*SECTAB(X) =: NSECT             % NO OF SECTORS
030653
030653          0=:DSKAD                             % FLOPPY DISK ADDRESS
030654          PGCOP=:NOOK=:MNBLK                   % PAGE ADDRESS IN MEMORY
030657          GO LTRNSF
030660   ENDDO:
030660     OD
030664   *WAIT 76                                    % SHOULD NEVER BE HERE
030665   *)FILL
030722
030722
030722   % ---------- DMA FLOPPY TRANSFER --------------
030722   %
030722   %
030722   DMA:   IF MTFSTA BIT 16 THEN
030725             CALL WFLOP                        % NEW DMA FLOPPY
030726          ELSE
030727             IF FFORM=17 THEN                  % OLD DMA FLOPPY
030733                 CALL XFLOP                    % DOUBLESIDE/DOUBLEDENSITY
030734                ELSE
030735                 CALL WFLOP                    % SINGLESIDE/SINGLEDENSITY
030736             FI
030736          FI
030736          IF PGCOP = 0 THEN                    % IF FIRST DISKETTE THEN
030740                                               % COPY PAGE TABLE ENTRIES
030740
030740            SECTAB(FFORM)=:NSECT
030743            T:=SHPAGE ; A:=76 ; CALL COPYP     % TRANSFER VIA PAGE 0
030746            SHPAGE =: MNBLK =: NOOK
030751            NSECT*76=:DSKAD
030754            CALL WFLOP
030755
030755            SECTAB(FFORM)=:NSECT
030760            T:=SHPAGE ; A:=77 ; CALL COPYP     % TRANSFER VIA PAGE 0
030763            SHPAGE =: MNBLK =: NOOK
030766            NSECT*77=:DSKAD
030771            CALL WFLOP
030772
030772          FI
030772          GO FAR NEXTF
030773
030773
030773   % ---------- PIO FLOPPY TRANSFER --------------------
030773   %
030773   %
030773   PIO:
030773          4 =: NSECT                           % SECTOR PER PAGE
030775          PGCOP=:0PCOUNT+MPAGS-1=:STOP         % TRANSFER PAGE BY PAGE
031002          FOR 0PCOUNT TO STOP DO               % IN PHYSICAL MEMORY
031006             T:=SHPAGE ; CALL COPYP
031010             SHPAGE =:NOOK=: MNBLK ; CALL WFLOP
031014          OD
031020          GO FAR NEXTF
031021
031021
031021   INTEGER POINTER LDRIVER                     % FLOPPY DRIVER START ADDRESS
031022   INTEGER POINTER LTRNSF                      % MEMORY TO FLOPPY TRANSFER ROUTINE
031023
031023
031023   % ---------- W R I T E  TO  F L O P P Y ---------------
031023   %
031023   %       Routine   WFLOP
031023
031023   INTEGER         3LREG  , NUM
031025   INTEGER POINTER LLRET=3LREG
031025   INTEGER LXREG=3LREG                         % USE ONLY WHEN ERROR EXIT
031025
031025   WFLOP: A:=L=:"LLRET"
031027          FOR NOOK TO MNBLK DO
031033            A:=DSKAD=:D                        % A:=DISC ADDRESS=:D
031035            X:=NSECT                           % X:=NO OF SECTOR
031036            A+X=:DSKAD                         % DISK ADDRESS FOR NEXT TRANSFERT
031040            A:=NOOK                            % A:=MEMORY PAGE ADDRESS
031041            T:=CMD                             % T:=WRITE COMMAND
031042            CALL LDRIVER; GO MWERR; GO MBUS % P+1:ERROR; P+2:BUSY; P+3:OK
031045          OD
031051          GO LLRET
031052
031052   XFLOP: A:=L=:"LLRET"
031054          NSECT SHZ -2 =: NSECT
031057          0=:NUM
031060          FOR NUM TO 3 DO
031064            A:=DSKAD=:D
031066            X := NSECT
031067            A+X=:DSKAD                         % DISK ADDRESS FOR NEXT TRANSFERT
031071            A:=NOOK                            % A:=MEMORY PAGE ADDRESS
031072            T:=CMD                             % T:=WRITE COMMAND
031073            CALL LDRIVER; GO MWERR; GO MBUS % P+1:ERROR; P+2:BUSY; P+3:OK
031076            NOOK+232=:NOOK
031101          OD
031105          GO LLRET
031106   *)FILL
031136
031136   MWERR: X=:LXREG; "FLER1"; CALL 3UTXT          % ERROR MESSAGE
031141          A:=LXREG; CALL FOCTU; GO DEXI
031144
031144   MBUS:   "BUSDV"; CALL 3UTXT; GO MEMTR         % DEVICE BUSY
031147
031147   FINI:  "LMSG4" ; CALL 3UTXT
031151           LMEMORY ; CALL FOCTU
031153          "FIDU"                                % OK EXIT
031154
031154   ERREX: CALL 3UTXT
031155   DEXI:  *WAIT 0; JMP * -1                     % FINISHED DUMP
031157   RBUS
031167
031167
031167   % -------------------------------------
031167   %  SUBROUTINE TO ASK FOR CHARACTER
031167   % -------------------------------------
031167
031167   SUBR ASKCH
031167   INTEGER POINTER LLINK
031170   ASKCH: T:=L=:"LLINK"
031172          "LMSG2"; CALL 3UTXT
031174          "LMSG3"; CALL 3UTXT
031176           CALL 0CLDEV                % CLEAR INPUT CHANNEL
031177           CALL 7INBT                 % GET CHARACTER
031200          GO LLINK
031201   RBUS
031206
031206   % -------------------------------------
031206   % SUBROUTINE TO CLEAR INPUT CHANNEL
031206   %
031206   % -------------------------------------
031206   SUBR 0CLDEV
031206   0CLDEV:
031206   @MAC

)9SCLC
031206          IOX 302           % READ STATUS
031207          BSKP ONE 30 DA
031210          JMP *+3
031211          IOX 300           % CLEAR INPUT
031212          JMP *-4           % REPEAT
031213          SAA 20            % CLEAR DEVICE BIT
031214          IOX 303
031215          EXIT
031216  )9RCLC
)9SLPL
031216   RBUS
031216
031216   % -------------------------------------
031216   %  SUBROUTINE TO FIND MEMORY CONFIG.
031216   %  AND INITIALIZE MEMORY.
031216   % -------------------------------------
031216
031216   SUBR 0CHMEM
031216   INTEGER LCOUNT                               % LOOP COUNTER
031217   INTEGER FIRSTMOR                             % FIRST TIME MOR
031220   INTEGER PNT                                  % COUNTER IN FIELD CHAMP
031221   SYMBOL MEXAM=    150416                      % MEMORY EXAMINE
031221
031221   0CHMEM:
031221         FOR X:=0 TO 10 DO
031225           -1 =: CHAMP(X)
031227         OD
031231         "1000";  *TRR IIE                      % ENABLE MEMORY OUT OF RANGE
031233         100=:LCOUNT                            % STARTING AT BANK 1
031235
031235          0 =: CHAMP(0)
031237          1 =: PNT ; 1 =: FIRSTMOR
031243
031243          FOR LCOUNT TO 37777 DO
031247            A =: D
031250            *LDT (2000  ; RMPY SD DT
031252            *MEXAM       ; TRA IIC
031254            IF A-11=0 THEN                      % MEMORY OUT OF RANGE
031256                 IF FIRSTMOR=1 THEN             % SAVE THE LAST PAGE WHEN WE
031262                    LCOUNT-1 =: CHAMP(PNT)      % DIDNOT HAVE MOR FOR
031266                    X+1 =:  PNT                 % INCREMENT PNT
031270                    0 =: FIRSTMOR
031271                 FI
031271              ELSE                              % NOT MEMORY OUT OF RANGE
031272                 IF FIRSTMOR=0 THEN             % SAVE START OF MEMORY AFTER A HOLE
031274                    LCOUNT =: CHAMP(PNT)        % IN MEMORY
031277                    X+1=: PNT                   % INCREMENT PNT
031301                    1 =: FIRSTMOR
031303                 FI
031303
031303
031303            FI
031303            IF PNT=7 THEN GO FINI ; FI           % END OF FIELD CHAMP
031310
031310          OD
031314
031314   FINI:  LCOUNT-1=:LMEMORY ; EXIT
031320   RBUS
031325
031325   % -------------------------------------
031325   %  SUBROUTINE TO COPY ONE PAGE (FROM
031325   %  ENTRY : A CONTAINED PAGE NO TO COPY FROM
031325   %          T CONTAINED PAGE NO TO COPY TO
031325   % -------------------------------------
031325
031325   SUBR COPYP
031325     SYMBOL MEXAM=    150416               % MEMORY EXAMINE
031325   COPYP: 0=:D; AD SH -6; *RDCR DD
031330          T SH 12 =:B                      % CONVER PAGE TO ADDRESS
031332          FOR X:=0 TO 1777 DO
031336            *RINC DD; MEXAM; STT ,B ,X
031341          OD
031343          EXIT         % EXIT
031344   RBUS
031345
031345   % -------------------------------------
031345   %  SUBROUTINE TO PRINT A TEXT STRING
031345   %  ENTRY:
031345   %  A-REG  = ADDRESS OF TEXT STRING
031345   % -------------------------------------
031345
031345   SUBR 3UTXT
031345   INTEGER SVL
031346   INTEGER POINTER PSVL=SVL
031346   3UTXT: A=:D:=L=:SVL; X:=0
031352          DO
031352                T:=D; *LBYT; AAX 1
031355                IF A=##' THEN GO PSVL; FI
031361                IF A=##$ THEN
031364                  T:=1; A:=15; CALL 7OUTB; A:=12 % $= CR & LF
031370                FI; T:=1; CALL 7OUTB
031372          OD
031373          GO PSVL         % RETURN
031374   RBUS
031375
031375   % -------------------------------------
031375   %  OCTAL OUTPUT (A-REGISTER)
031375   % -------------------------------------
031375
031375   SUBR FOCTU
031375   INTEGER WORD, SVL
031377   INTEGER POINTER PSVL=SVL
031377   FOCTU: A SHR -17 =:WORD; A:=L=:SVL;
031403          A:=WORD; A/\1; X:=-6; GO OCT1
031407          FOR X DO
031407            A:=WORD SHR 3=:WORD; A/\7
031413   OCT1:    A+##0; T:=1; CALL 7OUTB
031416          OD;
031417          GO PSVL               % RETURN
031420
031420   RBUS
031423
031423   % -------------------------------------
031423   %  ROUTINE INPUT AND OUTPUT A BYTE
031423   % -------------------------------------
031423
031423   SUBR 7INBT,7OUTB
031423   7INBT:
031423   @MAC

)9SCLC
031423         IOX 302; BSKP ONE 30 DA; JMP *+3
031426         LDA (44004; IOX 303             % CHECK PARITY, 7 BIT CH.,
031430         IOX 302; BSKP ONE 30 DA; JMP *-2
031433         IOX 300; BSET ZRO 70 DA; STA ASAV
031436         LDA (44004; IOX 303; JMP * +2
031441
031441  7OUTB, STA ASAV; IOX 306; BSKP ONE 30 DA; JMP *-2
031445         LDA ASAV; IOX 305; EXIT
031450  ASAV,  0
031451  )KILL ASAV
031451  )9RCLC
)9SLPL
031452   RBUS
031452
031452   @MAC

031452  )9RLPL
031452
031452  % =====================================
031452  %      F D R I 2
031452  % -------------------------------------
031452  %  FLOPPY DISC DMA DRIVER
031452  % -------------------------------------
031452  %
031452  %  CALLING SEQUENCE:
031452  %
031452  %     ON ENTRY:    A-REG: MEMORY BUFFER ADDRESS (PAGES IN MEMORY)
031452  %                  D-REG: FIRST SECTOR OF TRANSFER
031452  %                  X-REG: NUMBER OF SECTORS TO TRANSFER
031452  %                  T-REG: COMMAND WORD (1=WRITE DATA)
031452  %     ON RETURN:
031452  %            NON    SKIP: ERROR
031452  %                             X-REG = STATUS WORD 1 .OR. HSTAT
031452  %
031452  %            SINGLE SKIP: BUSY
031452  %                             ALL REGISTER UNCHANGED
031452  %
031452  %            DOUBLE SKIP: FINISHED
031452  %                             A-REG = STATUS WORD 2 OF STATUS BLOCK
031452  %                                     IF THE COMMAND WAS "READ FORMAT" THEN
031452  %                                     BIT 3 SET MEANS DUAL DENSITY
031452
031452
031452  FDRI2, STF   3TREG                     %% SAVE T-, A- AND D-REGISTERS
031453         IOX   1562                      %% READ HARDWARE STATUS
031454         STA   3HSTA                     %% SAVE IN HSTAT
031455         BSKP  ZRO 20 DA                 %% SKIP IF NOT BUSY
031456         JMP   FBUSY                     %% BUSY, JUMP TO BUSY EXIT
031457
031457  %--- INITIALIZE "COMMAND FIELD" ELEMENTS ------------------
031457
031457         STT   3COMF+0                  %% COMMAND
031460         STZ   3COMF+4                  %% WORD COUNT-HIGH (BIT 15= WC/SC FLAG)
031461         STX   3COMF+5                  %% WORD COUNT-LOW/SECTOR COUNT
031462         LDA   (2000; SWAP SA DD         %% NO OF WORDS PR PAGE (=2000)
031464         STA   3COMF+1                  %% DISC ADDRESS
031465         LDA   3AREG;  RMPY SA DD        %% MEMORY WORD ADDRESS IN AD-REG.
031467         STD   3COMF+2                  %% A = MEM.ADDR. (MOST SIGN. 8 BITS)
031470  %            3COMF+3                  %% D = MEM.ADDR. (LEAST SIGN. 16 BITS)
031470  %%
031470         SAA   0
031471         IOX   1565                      %% LOAD COMMAND FIELD ADDR.(MOST SIGN.)
031472
031472         COPY  SP DA
031473         AAA   3COMF-*                   %% LOAD COMMAND FIELD ADDR.(LEAST SIGN.)
031474         IOX   1567
031475
031475         LDA   (1400                     %% CTRL.WORD: EXECUTE COMMAND/STEP RATE
031476         IOX   1563                      %% LOAD CONTROL WORD
031477
031477  LOOP,  IOX   1562                      %% READ HARDWARE STATUS
031500         BSKP  ONE 30 DA                 %% SKIP IF READY FOR TRANSFER
031501         JMP   LOOP                      %% NOT READY, TRY AGAIN
031502
031502         STA   3HSTA                     %% SAVE STATUS IN HSTAT
031503         BSKP  ZRO 40 DA                 %% SKIP IF NO ERRORS
031504         JMP   FLERR                     %% YES, WE HAD ERRORS
031505         LDX   3HSTA                     %% RETURN THE STATUS IN X-REG
031506         LDF   3TREG                      %% RESTORE T- AND D-REG
031507         LDA   3COMF+7                  %% STATUS WORD 2
031510         COPY  SL DL AD1
031511         EXIT  AD1                       %% DOUBLE SKIP RETURN, FINISHED EXIT
031512
031512  FBUSY, LDA   3AREG
031513         EXIT  AD1                       %% SINGLE SKIP RETURN, BUSY EXIT
031514
031514  FLERR, IOX 1560                        %% LDX   3COMF+6  %% STATUS WORD 1
031515         COPY SA DX                      %%  RORA  SA DX    %% .OR. HSTAT
031516         LDF   3TREG
031517         EXIT                            %% NON SKIP RETURN, ERROR EXIT
031520
031520  3TREG,  0
031521  3AREG,  0
031522  3DREG,  0
031523  3HSTA, 0
031524  3COMF,0;0;0;0;0;0;0;0;0;0;0;0         %% FIELD IS 12 (DEC) LOCATIONS LONG
031540
031540  )FILL
031542  )PCL FDRI2
031542  )9RCLC
)9SLPL
031542
031542   % =====================================
031542   %      F D R I 1
031542   % -------------------------------------
031542   %  FDRI1:
031542   %  PIO FLOPPY DISC DRIVER.
031542   %  ROUTINE TO WRITE A NUMBER OF 256
031542   %  WORDS BLOCKS ON FLOPPY-DISK-1,
031542   %  UNIT 0 STARTING IN SPECIFIED
031542   %  ADDRESS.
031542   %
031542   %  ENTRY:    D = DISK ADDRESS
031542   %                (RANGE 0-1150B)
031542   %            A = MEMORY ADDRESS (IN PAGES!!)
031542   %            X = NO OF SECTORS TO
031542   %                TRANSFER (256 WORDS)
031542   %
031542   %  RETURN:   RETURN IF ERROR
031542   %            (REGISTERS RESET EXEPT X=STATUS)
031542   %            SKIP-RETURN IF BUSY
031542   %            SKIP-SKIP-RETURN IF OK
031542   %            (STATUS IN X-REGISTER)
031542   %
031542   % -------------------------------------
031542
031542   SUBR FDRI1
031542   FDRI1:
031542          SYMBOL 3DEVN = 1560
031542          SYMBOL 3RDAT  = 3DEVN+0
031542          SYMBOL 3WDAT  = 3DEVN+1
031542          SYMBOL 3RSR1  = 3DEVN+2
031542          SYMBOL 3WCWD  = 3DEVN+3
031542          SYMBOL 3RSR2  = 3DEVN+4
031542          SYMBOL 3WDAD  = 3DEVN+5
031542          SYMBOL 3WSCT  = 3DEVN+7
031542
031542          SYMBOL 3BUSY  = 20
031542
031542   @MAC

)9SCLC
031542
031542  %--- SAVE REGISTERS/INITIAL VALUES ------------------------
031542
031542         STF   9TREG
031543         COPY SL DT
031544         STT 9LREG
031545         STX 9XREG
031546         MPY   (2000
031547         STA 3MADR             % NO OF WORRDS PR PAGE
031550
031550  RSR01, IOX   3RSR1
031551         BSKP  ZRO 3BUSY DA     % CONTROLLER BUSY?
031552         JMP   FBUSY
031553
031553  NTRNS, SAA   60
031554  WCWD3, IOX   3WCWD            % CLEAR DEVICE
031555         LDA   (140001
031556  WDAD1, IOX   3WDAD            % SELECT DRIVE & FORMAT
031557         STZ   *               % DELAY
031560         STZ   *
031561  RSR06, IOX   3RSR1
031562         STA   3STA1
031563         BSKP  ZRO 40 DA
031564         JMP   ERR
031565         STZ   SETIB           % INITIALIZE SECTOR COUNT (ADDRESS IN BUFFER)
031566         LDA   3CALB
031567         JAF   UTBUF           % START TRANSFER IF CALIBRATED
031570
031570  %--- CALIBRATE ----------
031570
031570  CALFL, STZ   NYTR
031571         LDA   (40000
031572  WCWD4, IOX   3WCWD            % RECALIBRATE COMMAND
031573  RSR07, IOX   3RSR1
031574         BSKP  ZRO 3BUSY DA
031575         JMP   *-2
031576
031576  %--- CHECK RECALIBRATE ----
031576
031576  RSR03, IOX   3RSR1
031577         STA   3STA1
031600         AND   FMSK
031601         AAA   -200
031602         JAF   ERR
031603         SAA   -1
031604         STA   3CALB           % DRIVE IS RECALIBRATED
031605
031605  %--- READ ID TRANSFER -------
031605
031605
031605  IDTRN, LDA   (4040
031606  WCWD6, IOX   3WCWD            % READ ID COMMAND/CLEAR BUFFER
031607  RSR11, IOX   3RSR1
031610         BSKP  ZRO 3BUSY DA
031611         JMP   *-2
031612
031612  %--- CHECK READ ID ----------
031612
031612
031612  RSR02, IOX   3RSR1
031613         STA   3STA1           % SAVE STATUS
031614         AND   FMSK
031615         AAA   -100            % SUBTRACT RIGHT STATUS
031616         JAF   ERR
031617
031617  %--- CHECK NEW TRACK ADDRESS --
031617
031617  ADCHK, SAA   40
031620  WCWD1, IOX   3WCWD            % CLEAR BUFFER
031621  RDAT1, IOX   3RDAT            % READ TRACK ID BYTES
031622         SHA   ROT 10
031623         SUB   NYTR
031624         JAZ   *+3             % NEW TRACK OK
031625         STZ   3CALB           % SET RECALIBRATE FLAG
031626         JMP   ERR
031627         LDA   NYTR
031630         STA   GAMTR
031631         JMP   UTBUF
031632
031632  FBUSY, LDF   9TREG           % BUSY EXIT !
031633         LDX   9XREG
031634         EXIT  AD1
031635
031635  FFINI, LDX   3STA1           % FINISH
031636         LDA   9LREG
031637         COPY  AD1 SA DL
031640         LDF   9TREG
031641         EXIT  AD1
031642
031642  ERR,   IOX   3RSR2            % ERROR
031643         ORA   3STA1
031644         COPY  SA DX
031645         LDF   9TREG
031646         JMP I 9LREG
031647  )FILL
031653
031653  9TREG, 0
031654  9AREG, 0
031655  9DREG, 0
031656  9XREG, 0
031657  9LREG, 0
031660  3STA1, 0
031661  3STA2, 0
031662  SETIB, 0                     % NO. OF SECTORS IN BUFFER
031663  NBLTT, 0                     % NO. OF BLOCKS LEFT TO TRANSFER
031664  3MADR, 0                     % CURRENT MEMORY ADDRESS
031665  FMSK,  360
031666  MSECT,  0                     % SECTOR
031667  3CALB, 0                     % CALIBRATION FLAG
031670  NYTR, 0                     % NEW TRACK
031671  GAMTR, 0                     % OLD TRACK
031672
031672
031672  UTBUF, SAA   40              % FILL THE INTERFACE
031673  WCW11, IOX   3WCWD
031674         LDA   3MADR
031675         COPY  SA DX
031676         ADD   (2000
031677         COPY  SA DT
031700  IWDAT, LDA   ,X              % FETCH DATA IN MEMORY
031701         IOX   3WDAT
031702         AAX   1
031703         SKP   DX EQL ST
031704         JMP   IWDAT
031705         SAA   -4
031706         STA   NBLTT           % SET NO. OF BLOCKS LEFT TO TRANSFER
031707                               % WITHOUT FILLING THE INTERFACE BUFFER
031707
031707  %--- CHECK NO. OF BLOCKS LEFT TO TRANSFER --
031707
031707  CHLFT, LDX   9XREG           % NO OF 256 WORDS BLOCKS TO TRANSFER
031710         LDA   SETIB           % SECTOR NUMBER ADDRESS IN BUFFER
031711         SKP   DA GEQ SX       % TRANSFER IF MAX<CURRENT SECTOR
031712         JMP   FTRNS
031713         JMP   FFINI           % FINISHED ?
031714
031714  %--- PREPARE READ/WRITE TRANSFER ---------
031714
031714  FTRNS, LDA   9DREG
031715         AND   (7777
031716         ADD   SETIB
031717         COPY  SA DD
031720         SAA   0
031721         SAT   10
031722         RDIV  ST              %  A: TRACK  (SA/SR ->A=QUOTIENT, D=REMAINDER)
031723         COPY  SD DT AD1       %  T: SECTOR (D+1=T)
031724         STT   MSECT
031725         STA   NYTR
031726         SUB   GAMTR
031727         JAZ   RWTRN           % ON TRACK?
031730
031730  %--- NO,  WRONG TRACK ! -----------------
031730
031730         JAP   *3              % NO. A: DIFFERENCE  (15=0 -> "OUT", 15=1 -> "IN")
031731         COPY  SA DA CM2
031732         JMP   *2
031733         BSET  ONE 70 DA       % SEEK "IN" (NYTR > GAMTR)
031734         SHA   ZIN 10
031735  WDAD2, IOX   3WDAD            % LOAD DIFFERENCE
031736         LDA   (20000
031737  WCWD5, IOX   3WCWD            % SEEK COMMAND
031740  RSR10, IOX   3RSR1
031741         BSKP  ZRO 3BUSY DA
031742         JMP   *-2
031743
031743  %--- CHECK SEEK ---------------
031743
031743  RSR04, IOX   3RSR1
031744         STA   3STA1
031745         AND   FMSK
031746         AAA   -200
031747         JAF   ERR
031750         JMP   IDTRN
031751
031751  %--- TRANSFER CONTENT TO DISK (TRACK=NYTR, SECTOR=MSECT) --
031751
031751  RWTRN, LDA   MSECT
031752         SHA   ZIN 10
031753  WSCT1, IOX   3WSCT            % LOAD SECTOR
031754  WTRSF, LDA   (1000           % WRITE CODE
031755  WCWD7, IOX   3WCWD            % WRITE TRANSFER COMMAND
031756         LDA   3MADR
031757         ADD   (400
031760         STA   3MADR           % INCREMENT MEMORY ADDRESS
031761  RSR12, IOX   3RSR1
031762         BSKP  ZRO 3BUSY DA
031763         JMP   *-2
031764         MIN   SETIB           % INCREMENT BUFFER SECTOR ADDRESS (NEVER ZERO)
031765         MIN   NBLTT           % DECREMENT NO OF SECTORS IN BUFFER
031766         JMP   CHLFT
031767         JMP   UTBUF
031770
031770  )FILL
031775  )PCL FDRI1
031775
031775  EMTOF=*-1
031775  )9RCLC
)9SLPL
031775
031775   RBUS
031775   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
031775   %%     END OF MEMORY TO FLOPPY DUMP PROGRAM      %%
031775   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
031775
031775   @DEV 1
031775   @DEV (S-S-L)PH-P2-RESTART:NPL
031775

031775   * SRSTA=*
031775   INTEGER 9PWFAIL              % ><0 WHEN POWER-FAIL HAS OCCURED
031776   %==============================================================================
031776   %
031776   %   3 8 . 0     S Y S T E M   S T A R T  A N D  S T O P
031776   %
031776   %==============================================================================
031776   % 38.1       P W F A I L   R E S T A R T   S E T P T A B L
031776   %
031776   @ICR;
031776   % INITIAL VALUES OF PCR REGISTERS FOR ALL INTERRUPT LEVELS
031776   INTEGER ARRAY PCCS:=(
031776           NMPIT+ADPIT+ERNG2+000,
031777           NMPIT+ADPIT+ERNG2+ALEVB,
032000           NMPIT+ADPIT+ERNG2+MLEVB,
032001           NIPIT+ADPIT+ERNG3+SLEVB,
032002           NRPIT+ADPIT+ERNG2+BLEVB,
032003           NXPIT+ADPIT+ERNG2+50,
032004           64,
032005           74,
032006           104,
032007           114,
032010           NMPIT+ADPIT+ERNG2+LV10B,
032011           NIPIT+ADPIT+ERNG2+LV11B,
032012           NMPIT+ADPIT+ERNG2+LV12B,
032013           NMPIT+ADPIT+ERNG2+LV13B,
032014           NMPIT+ADPIT+ERNG2+LV14B,
032015           174);
032016   @CR;
032016
032016   INTEGER ARRAY LEV1=?
032016   INTEGER LEV14=?,URERTP=?
032016
032016   SUBR PWFAIL,SETPTABL,RESTART
032016
032016
032016   DISP 0
032016   INTEGER TTINF=NBPROGS
032016   INTEGER TTSPEED=CNBATCHES
032016   INTEGER CCNTRG=CPRVTSIZE
032016   INTEGER CURBX=SWPDRIVER
032016   INTEGER CURPAGE=CBPRTSIZE
032016   PSID
032016
032016
032016   INTEGER ARRAY QMSDF:=(DRFIE,DRFI2,BIGDI,BIGD2,BIGD3,BIGD4,GIGDI,GIGD2,WIGDI,WIGD2,-1)
032031   DISP 0; REAL FS0, RCTRG=CTRG, RTRG=TRG; PSID
032031
032031   %========================================================================
032031   %            P I N H B T C A C H E   -   P E N A B C A C H E
032031   %
032031   % LOCAL SUBROUTINES TO ENABLE/DISABLE PAGE IN CACHE FOR THE ND-110 COMPUTER
032031   %
032031   INTEGER CINSTR
032032   INTEGER CEINSTR
032033   INTEGER FLGCACHE
032034
032034   PINHBTCACHE:
032034          0=:FLGCACHE
032035          *LDA (BSKP ONE 00 DD; LDT (BSKP ONE 170 DD
032037          GO PCFELLS
032040   PENABCACHE:
032040          100000=:FLGCACHE
032042          *LDA (BSKP ZRO 00 DD; LDT (BSKP ZRO 170 DD
032044   PCFELLS: A=:CINSTR; T=:CEINSTR
032046          0=:CURPAGE
032047          DO WHILE CURPAGE<<=37777
032053             T:=MBCACHINHIBIT; A:=CURPAGE SHZ -4+CACHINHIBIT=:X; *LDATX
032061             A=:D; T:=CINSTR
032063             FOR X:=-20 DO
032064                *EXR ST
032065                GO NPENABLE
032066                A:=CURPAGE+FLGCACHE; *TRR CILP           % ENABLE/DISABLE PAGE IN CACHE
032071   NPENABLE:    MIN CURPAGE
032072             WHILE CEINSTR><T
032075                T+10
032076             OD
032077          OD; *TRR CCLR
032101          EXIT
032102
032102   *)FILL
032112
032112   *"8N500
"032112   %==========================================================================
032112   %           5 P F 1   -   5 P F 2   -   5 P F 3
032112   %
032112   % SUBROTINE TO THE SINTRAN III POWER FAIL ROUTINE ON LEVEL 14
032112   %
032112   INTEGER 5PFFL,5PFCPUDF
032114   5PF1:  1=:5PFFL; GO 5PF
032117   5PF2:  2=:5PFFL; GO 5PF
032122   5PF3:  3=:5PFFL
032124   5PF:   X:="S5CPUDF"+DPITPHYS
032126          DO WHILE X<<="E5CPUDF"+DPITPHYS
032132             X=:5PFCPUDF; T:=DPITBANK
032134             *AAX CPUAV; LDATX; AAX -CPUAV
032137             IF A=:B/\5CPUTYPE><0 THEN
032142                *AAX MAIL1; LDDTX
032144                A=:T; D=:X; *AAX X5CLR; STZTX; AAX -X5CLR
032151                X:=5PFCPUDF; T:=DPITBANK
032153                IF 5PFFL-1 = 0 THEN
032156                   *AAX C5PWF; STZTX; AAX -C5PWF
032161                ELSE IF A-2 = 0 THEN
032164                   *AAX C5STA; LDATX
032166                   A BONE BHPFAIL; *STATX; AAX -C5STA
032171                FI; FI
032171                *AAX C5PWF; LDATX
032173                IF A=0 THEN
032174                   IF A:=B/\5CPUTYPE = SAMSON THEN
032201                      A:=1; *STATX
032203                      GO NCPUPF
032204                   FI
032204                   *AAX HDEV-C5PWF; LDATX
032206                   A+RSTA5=:T; *IOXT
032211                   IF A BIT 5ILOC THEN
032213                      T+"TERM5-RSTA5"; *IOXT
032215                      FOR X:=-10 DO; OD
032217                      T+"RSTA5-TERM5"; *IOXT
032221                      IF A BIT 5ILOC THEN
032223                            GO NCPUPF      % NEXT CPU IF THIS ONE DID NOT STOP
032224                      FI
032224                   FI;
032224                   T:=DPITBANK; A:=1
032226                   *AAX C5PWF-HDEV; STATX
032230                   *AAX HDEV-C5PWF; LDATX
032232                   A+LCON5=:T; A:=10; *IOXT
032236                   T+"RSTA5-LCON5"; *IOXT
032240                   A BONE 5POWOF; T+"LSTA5-RSTA5"; *IOXT
032243                   A:="0"; T+"LCON5-LSTA5"; *IOXT
032246                   A:=400; *IOXT
032250                   T+"SLOC5-LCON5"; *IOXT
032252                   T+"TERM5-SLOC5"; *IOXT
032254                FI
032254             FI
032254   NCPUPF:   X:=5PFCPUDF+5CPUDFSZ
032256          OD; EXIT
032260   *)FILL
032264   *"-8N500
"032264
032264   %==========================================================
032264   %      C C L N R E E N T R A N T
032264   %
032264   % LOCAL SUBROUTINE TO CLEAR "NON-REENTRANT" PAGES OF
032264   % A REENTRANT SEGMENT
032264   %
032264   INTEGER ARRAY POINTER RTDSCR,PTBLE
032266   CCLNREENTRANT:
032266          X:=X.RTDLGADDR
032267          X=:"RTDSCR"                     % X POINTS TO REGISTER BLOCK AND BITMAP.
032270          X:=SEGMC; T:=SEGTBANK           % SAVE B IN T AND SET TO SEGMENT
032272          *LOGAD@3 LDATX
032273          A/\1700 SH 1+174000=:"PTBLE"    % MAKE PIT POINTER FOR THIS SEGMENT.
032277          5BITMAP=:D; *POF                % DISPLACEMENT OF BITMAP INTO D, TURN OFF PAGING TO ACCESS PITS.
032302          FOR D TO "5BITMAP+7" DO         % TEST ALL BITMAP WORDS.
032305             "PTBLE"+40=:"PTBLE"          % POINTER TO END OF PIT FOR THIS WORD
032310             T:=0; X:="RTDSCR"+D; *LDATX  % GET BITMAP WORD
032314             IF A><0 THEN                 % IF ANY BIT SET IN THIS WORD THEN
032315                FOR X:=-20 DO             % TEST ALL BITS IN THIS WORD
032316                   A SHR -1               % MOVE BIT TO THE SIGN POSITION
032317                   IF A<0 THEN            % IF THIS BIT IS SET THEN
032320                       X=:T+X             % SAVE X IN T AND DOUBLE
032322                       0=:PTBLE(X)        % CLEAR PIT FOR THIS PAGE
032323                       X:=T               % RESTORE X
032324                   FI                     % ENDIF BIT
032324                OD                        % ENDDO BITS
032325             FI                           % ENDIF WORD
032325          OD                              % ENDDO WORDS
032327          *PON ; EXIT                     % TURN ONN PAGING AND RETURN.
032331   *)FILL
032335
032335   %=========================================================
032335   %       C S E T R T
032335   %
032335   % LOCAL SUBROUTINE TO SET-UP RT'S SYSTEM SEGMENT IN PIT.
032335   %
032335   INTEGER ARRAY POINTER CPITADDR:=DPIT*200+174000+SYSST+5ESSZ+SYSST+5ESSZ
032336   DOUBLE  ARRAY POINTER DCPITADDR=CPITADDR
032336   CSETRT:T:=DPITBANK; X:="RTSYSG"; *LDATX
032341          A=:D; SISYSEG-"5ESSZ"-1 SH 1 =:T
032347          A:=162000; *POF
032351          FOR X:=0 STEP 2 TO T DO  % SET UP PIT FOR RT SYSTEM SEGMENT.
032354              AD=:DCPITADDR(X); D+1
032356          OD; *PON
032361          EXIT
032362   *)FILL
032366
032366   %=================================================
032366   %      T B U S P E E D
032366   %
032366   % LOCAL SUBROUTINE TO SET SPEED FOR TERMINAL BUFFER AND MULTITERMINAL INTERFACE
032366   % THE SPEED IS FOUND IN INPUT DATAFIELD; -1 MEANS DO NOT SET SPEED
032366   % THE ROUTINE ALSO CHECKS WHICH TYPE OF TERMINAL INTERFACE IS USED
032366   % AND IN CASE OF BUFF.TERM CONTROLLER SETS 5FIFO IN TINFO.
032366   % IF CNTREG IS DEFINED WITH CHARACTER LENGTH EQUAL 8-BITS 58BIT IS
032366   % ALSO SET IN TINFO.
032366
032366   TBUSPEED: A:=L=:"CLINK"
032370          T:=RPIFPHPAGE SH 12
032372          "TMRTE"-"PITEX"+T=:ETMRADDR-2=:TMRADDR
032400          T:=RPIFPHPAGE SHZ -6=:RPIBANK
032403          DO
032403             T:=RPIBANK; X:=TMRADDR; *LDATX
032406          WHILE A><-1 OR X=ETMRADDR
032414             IF X=ETMRADDR OR X=0 GO NXT
032421             IF A.TYPRING BIT 5TERM THEN
032425                T:="TINFO"; CALL XGTDFADDR; A=:TTINF
032430                T:="HDEV"; CALL XGTDFADDR
032432                IF A NBIT 2 AND A><0 THEN               % TERMINAL INPUT
032435                   T:=A+DST; *IOXT
032440                   IF A BIT 10 THEN                     % FIFO TERMINAL
032442                      TTINF BONE 5FIFO=:TTINF
032445                   FI
032445                   T:="CNTREG"; CALL XGTDFADDR
032447                   IF A/\14000=0 THEN                   % 8-BIT MODE
032451                      TTINF BONE 58BIT=:TTINF
032454                   FI
032454                   T:="TINFO"; TTINF; CALL XSTDFADDR
032457                   T:="TSPEED"; CALL XGTDFADDR; A=:TTSPEED
032462                   IF A><-1 THEN                        % IF TSPEED >< -1 THEN
032465                      T:="HDEV"; CALL XGTDFADDR         % SET BAUD RATE AS
032467                      T:=A+1; A:=TTSPEED; *IOXT         % SPESIFIED IN TSPEED.
032472                   FI
032472                FI
032472   NXT:      FI; MIN TMRADDR
032473          OD; GO CLINK
032475   *)FILL
032506
032506   %=======================================================
032506   %      C L A D V
032506   %
032506   % LOCAL SUBROUTINE TO CLEAR ALL IOX-DEVICES EXCEPT
032506   % USER-RESERVED IOX'S
032506   %
032506   INTEGER 5IX:=0, 500IOX
032510   INTEGER ARRAY 5IOXARR(0)     % ND-500 IOX TABLE
032510   *"8N500; 60  ;"              % ASCENDING IOX PLEASE !
""032511   *"8CP55; 560 ;"
"032511   *"8CP53; 660 ;"
""032512   *"8CP54; 760 ;"
""032513   *"8CP52; 1060;"
""032514   *"
"032514   * -1
032515
032515   % CLEAR ALL DEVICES EXCEPT CUSTOMER RESERVED DEVICES
032515   INTEGER CCIOX
032516   CLADV: A:=L=:"CLINK"; *1BANK
032521          5IOXARR(0)=:500IOX; *2BANK
032525          0=:CCIOX
032526          DO
032526             IF CCIOX=500IOX THEN                   % ND-500 DEVICE NUMBER
032532                CALL 5MCST; X:=5IX+1=:5IX; *1BANK
032537                5IOXARR(X)=:500IOX; *2BANK
032542                CCIOX+20=:CCIOX; GO NXIOX
032546             FI; X:=0
032547             *1BANK
032550             DO WHILE X<<"USDVSIZE*2"               % DO NOT CLEAR USER RESERVED DEV.NO'S
032553                AD:=USIOXTAB(X)
032554                IF A<<=CCIOX AND D>>=T THEN
032561                   A:=D/\177774=:CCIOX; GO NXIOX
032565                FI; X+2
032566             OD
032567             T:=CCIOX+"DCONT"; A:=20; *IOXT     % CLEAR DEVICE
032573   NXIOX: WHILE CCIOX+4><0
032576             A=:CCIOX; *2BANK
032600          OD; *2BANK
032602          GO CLINK
032603   *)FILL
032607
032607   %=======================================================
032607   %          S S G I P T A B L E
032607   %
032607   % LOCAL SUBROUTINE TO SET UP A SEGMENT IN PIT
032607   %
032607   % ENTRY:     X=SEGMENT ADDRESS
032607   %
032607   INTEGER BREG,XWIP
032611   RSSGIPTABLE:
032611          IF X=0 THEN EXIT FI
032614          0=:XWIP; GO FELLS
032616   SSGIPTABLE:
032616          IF X=0 THEN EXIT FI
032621          T:=SEGTBANK; *SGSTA@3 LDATX
032623          IF A BIT 5WPM THEN A:=0 BONE 5WIP ELSE A:=0 FI
032631          A=:XWIP
032632   FELLS: A:=B=:BREG
032634          T:=SEGTBANK; *BPAGL@3 LDXTX
032636          T:=CORMBANK
032637          *POF
032640          DO WHILE X><0
032641             D:=X SHZ -2; *LOGPA@3 LDATX
032644             A SH 1+174000=:B; *PROTE@3 LDATX
032650             A\/XWIP; AD=:DS0; *PAGLI@3 LDXTX
032653          OD; BREG=:B; *PON
032657          EXIT
032660
032660
032660   INTEGER CSGTENTRY,CSGTBANK,CCMBANK
032663
032663   %======================================================
032663   %            S S G F P T A B L E
032663   %
032663   % LOCAL SUBROUTINE TO REMOVE A SEGMENT FROM PIT
032663   %
032663   % ENTRY:     X=SEGMENT ADDR
032663   %
032663   SSGFPTABLE:
032663          IF X><0 THEN
032664             T:=CSGTBANK; *BPAGL@3 LDXTX
032666             T:=CCMBANK
032667             DO WHILE X><0
032670                *LOGPA@3 LDATX
032671                A SH 1+174000=:B; 0=:S0
032675                *PAGLI@3 LDXTX
032676             OD
032677          FI; EXIT
032700
032700   %======================================================
032700   %            S S W I P I N F O
032700   %
032700   % LOCAL SUBROUTINE TO SAVE WIP BITS FOR A SEGMENT
032700   %
032700   % ENTRY:     X=SEGMENT TABLE ADDR
032700   %
032700   SSWIPINFO:
032700          IF X=0 THEN EXIT FI
032703          X=:CSGTENTRY; T:=CSGTBANK; *SGSTA@3 LDATX
032706          IF A BIT 5WPM THEN
032710             *BPAGL@3 LDXTX
032711             T:=CCMBANK
032712             DO WHILE X><0
032713                *LOGPA@3 LDATX
032714                 A SH 1+174000=:B
032717                 IF S0><0 THEN
032721                    *PROTE@3 STATX
032722                 FI; *PAGLI@3 LDXTX
032723             OD
032724          FI; EXIT
032725   *)FILL
032730
032730

032730   %============================================================================
032730   %           P W F A I L
032730   %
032730   %ROUTINE ON LEVEL 14, ACTIVATED BY POWER FAIL
032730   %CAN ALSO BE CALLED BY THE STOP-SYSTEM COMMAND
032730   %
032730   INTEGER LEVC,SRBI(0); *SRB 10
032732   DOUBLE ARRAY SWPTWIDOWS(5)                       % SAVED DPIT-WINDOWS
032744   PWFAIL: CALL FAR 5PF1
032745          -15=:LEVC; SRBI; X:="LEV1"
032751          FOR LEVC DO; *EXR SA                      % SAVE REGISTERS ON ALL LEVELS
032752                X+10; A+10
032754          OD
032756          FOR X:=1 TO 15 DO                         % SAVE PCR ON LEVEL 1-13
032762             A:=X SHZ 3=:T; *TRA 14
032766             A/\177603+T+4=:PCCS(X)
032772          OD;  *TRA PIE
032775          T:=DPITBANK; X:="PIEREG+DPITPHYS"; *STATX
033000          A=:9PWFAIL; *TRA PID
033002          X:="PIDREG+DPITPHYS"; *STATX
033004          CALL FAR 5PF2
033005          CALL FAR 5PF3
033006          "WNDBF+WNDBF+174000"=:B; X:=0; T:=5
033012          DO WHILE T><0; DS0=:SWPTWINDOWS(X); X+2; B+2; T-1; OD % SAVE DPIT WINDOWS
033022          T:=DPITBANK; X:="CORMBANK+DPITPHYS"; *LDATX
033025          A=:CCMBANK                                   % PHYS ADDR OF CORMBANK
033026          X:="SEGTBANK+DPITPHYS"; *LDATX
033030          A=:CSGTBANK                                  % PHYS ADDR OF SEGTBANK
033031          X:="SEGMA+DPITPHYS"; *LDATX
033033          X:=A; CALL FAR SSGFPTABLE
033035          X:="SEGMB+DPITPHYS"; T:=DPITBANK; *LDATX
033040          X:=A; CALL FAR SSGFPTABLE
033042          X:="SEGMC+DPITPHYS"; T:=DPITBANK; *LDATX
033045          X:=A; CALL SSWIPINFO     % SAVE WIP-BITS FOR SEGMC
033047          GO PWAIT; *)FILL
033071   PWAIT: *WAIT; JMP *
033073
033073   %=============================================
033073   %      R E S T A R T
033073   %
033073   %- - - POWER UP AGAIN:
033073   RESTART:
033073          2000; *TRR IIE; TRA IIC                    %ENABLE POWER FAIL
033076          A:=6; *TRR PCR; SEX
033101          *2BANK
033102          X:=174000; A:=0; D:=0
033105          DO WHILE X><0; AD=:X.DS0; X+2 OD           % CLEAR ALL PITS
033111          "HWINFO"+DPITPHYS=:X; T:=DPITBANK; *LDATX
033116          IF A/\377 >= 2  THEN
033122             *143500                                 % EXTENDED MICROPROGRAM
033123          FI
033123
033123   % IF DISK DMA WAS ACTIVE AT POWER FAIL TIME, FORCE NEW CALL
033123
033123          X:="QMSDF"; X=:B
033125   QL0:   IF X:=S0=-1 GO SETPTABL
033131          IF X=0 GO QL1
033132          A:=DPITPHYS; X+A; % T:=DPITBANK
033134          100; *AAX DIFTC; STATX         % WAIT 100B*3 SECS. BEFORE TIMOUT ON DISC
033137          *AAX BUSFL-DIFTC; STZTX        % FORCE NEW CALL
033141          *AAX TACNS-BUSFL; LDATX; AAX TACOU-TACNS; STATX
033145          *AAX RCTRG-TACOU; LDATX
033147          A=:L; *LDDTX 10; AAX RTRG-RCTRG; STDTX 10; COPY SL DA; STATX
033155          *AAX CXRG-RTRG; LDATX; AAX XRG-CXRG; STATX
033161   QL1:   B+1; GO QL0
033163   *)FILL
033171
033171   % LOCAL SUBROUTINE TO MAP A SEGMENT INTO A PIT
033171   %
033171   % ENTRY: A=SEGMENT NUMBER
033171   %
033171   SGMAP: A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *BPAGL@3 LDXTX
033176          T:=CORMBANK
033177          DO WHILE X><0
033200             D:=X SHZ -2        % D=PHYSICAL PAGE
033202             *LOGPA@3 LDATX
033203             A SH 1 +174000=:B  % B=PIT ENTRY
033206             *PROTE@3 LDATX
033207             *POF; STD ,B; PON
033212             *PAGLI@3 LDXTX
033213          OD; "XSBFIELD"=:B
033216          EXIT
033217
033217   % LOCAL SUBROUTINE TO MAP THE I/O BUFFER AREA INTO PITS
033217   %
033217   % ENTRY: A=PIT NUMBER
033217   %
033217   IOMAP: A*200+174000=:X; A:=ASCBUF SHZ -12 SH 1; X+A
033226          A:=IOBFPHPAGE=:D:=162000
033231          DO
033231             *POF; STD ,X; PON
033234          WHILE D><IOBLPHPAGE
033237             D+1; X+2
033241          OD; EXIT
033243
033243   % LOCAL SUBROUTINE TO MAP COMMON-CODE INTO PITS
033243   %
033243   % ENTRY: A=PIT NUMBER
033243   %
033243   CCMAP: A*200+174000=:X; D:=0; T:=CMLPHPAGE
033250          A:=162000
033251          DO
033251             *POF; STD ,X; PON
033254          WHILE D><T
033256             D+1; X+2
033260          OD; EXIT
033262   *)FILL
033272
033272
033272   SETPTABL:
033272          "XSBFIELD"=:B
033274          CALL IPTMAP           % USE PIT #0 AS NPIT AND PIT #17 AS APIT
033275          X:="DPIT*200+174000"; A:=162000; D:=0
033300          *POF; STD ,X; PON            % MAP "MICRO-COMMON" INTO DPIT
033303          D+1; X+2; *POF; STD ,X; PON
033310          CALL LOCOSTORE        % LOAD NEW MICRO PROGRAMM
033311   % MAP I/O BUFFERS INTO RPIT AND MPIT
033311          RPIT; CALL IOMAP
033313          MPIT; CALL IOMAP
033315   % MAP COMMON CODE INTO THE NECESSARY PITS
033315          RPIT; CALL CCMAP
033317          SPIT; CALL CCMAP
033321          FPIT; CALL CCMAP
033323          FUPIT;CALL CCMAP
033325          5PIT; CALL CCMAP
033327          XPIT; CALL CCMAP
033331          MPIT; CALL CCMAP
033333          IPIT; CALL CCMAP
033335          5ECOM; CALL FAR SGMAP           % MAP EXT. COMMON SEGENT (RPIT)
033337          A:=0; X:=0                      % ALSO MAP INTO MPIT,IPIT
033341          T:=4=:L:="RPIT*200+174000+26"=:D:="MPIT*200+174000+26"; *MOVPP
033347          T:=4=:L:="RPIT*200+174000+26"=:D:="IPIT*200+174000+26"; *MOVPP
033355          5RPIT; CALL FAR SGMAP           % MAP RPIT SEGMENT
033357          5MPIT; CALL FAR SGMAP           % MAP MPIT SEGMENT
033361          5IPIT; CALL FAR SGMAP           % MAP IPIT SEGMENT
033363          5DPIT; CALL FAR SGMAP           % MAP DATA SEGMENT
033365          42; CALL FAR SGMAP              % MAP 1 PAGE IN SPIT (EDIT-ROUTINES)
033367          55PIT; CALL FAR SGMAP           % MAP 5PIT SEGMENT
033371   *"8FLMN
"033371          GO BYP1; *)FILL
033403
033403   % MAP PIT HANDLING ROUTINES ON RING 3 IN IPIT
033403
033403   BYP1:  A:="SRNG3" SHZ -12 SH 1 + "IPIT*200+174000"=:X
033410          A:="EERG3" SHZ -12 SH 1 + "IPIT*200+174000"=:T
033415          A:=163000; *POF
033417          DO A=:X.S0; WHILE X><T; X+2 OD
033424          *PON
033425          0=:PWRFREST
033426   % INITIALIZE PCR ON ALL LEVELS EXCEPT LEVEL 0
033426          *1BANK
033427          FOR X:=1 TO 17 DO
033433             PCCS(X); *TRR PCR
033435          OD; *2BANK
033440          IF PIDREG><0 THEN                         % AFTER POWER FAIL
033442             X:="S5CPUDF"
033443             DO WHILE X<<="E5CPUDF"
033446                X.TTMR=:X.TMR
033450                X+5CPUDFSZ
033451             OD
033452             IF BACKGROUND=0 THEN CALL FAR CSETRT FI % SET UP RT'S SYSTEM SEGMENT
033455             IF X:=SEGMC><0 THEN
033457                CALL FAR RSSGIPTABLE; X:=RTREF; CALL FAR CCLNREENTRANT
033462             FI; X:=SEGMA; CALL FAR SSGIPTABLE; X:=SEGMB; CALL FAR SSGIPTABLE
033466             X:=FILSEGM; CALL FAR SSGIPTABLE
033470             X:=5NSEGM; CALL FAR SSGIPTABLE
033472             X:=FUSEGM; CALL FAR SSGIPTABLE
033474             *POF
033475             "WNDBF+WNDBF+174000"=:B
033477             FOR X:=0 STEP 2 TO 10 DO
033503                AD:=SWPTWINDOWS(X)=:DS0; B+2        % RESTORE DPIT WINDOWS
033506             OD; *PON
033511             "XSBFIELD"=:B
033513             *1BANK
033514             "ERR14"=:LEV14
033516             *2BANK
033517          FI
033517          CALL FAR TBUSPEED
033520          CALL FAR CLADV
033521          GO L1; *)FILL
033556
033556   L1:
033556          LGCOLDSTART; CALL LOGPH
033560          IF A=0 OR A.TYPRING NBIT 5TERM THEN X:="DT01R" FI
033566          T:="CNTREG"; CALL XGTDFADDR; A BZERO "0"=:CCNTRG
033572          T:="HDEV"; CALL XGTDFADDR; T:=A+DCONT; CCNTRG; *IOXT
033600   *"8SCSI
"033600          CALL SCPWF                               % SCSI START/RESTART HANDLING
033601   *"
"033601          MASSNO(0); CALL LOGPH
033604          IF A."DODMA"><"SCSDI" THEN
033611             X.HDEV+"164000+5"=:T
033614             "0"; *EXR ST                          % SELECT UNIT
033616             FOR X:=100000 DO OD                   % HOLD 3 MICRO SEC.
033620             20; *EXR ST                           % CLEAR DEVICE
033622             FOR X:=100000 DO OD                   % HOLD 3 MICRO SEC.
033624             IF T BIT 11 THEN
033626                A:=34004; *EXR ST                  % RETURN TO ZERO SEEK IF BIG DISC
033630             FI; T-1                               % READ STATUS (4=READ STATUS)
033631   DDLAY:    FOR X:=100000 DO; OD                  % DELAY
033633             *EXR ST; BSKP ZRO 160 DA; JMP ADLAY   % ON CYLINDER
033636             *BSKP ONE 030 DA; JMP DDLAY           % UNTIL ON CYLINDER
033640          FI
033640   ADLAY: GO LDLAY
033641
033641   *"8FLMN
"033641
033641   LDLAY: *BSET ZRO SSZ
033642          *TRA IIC; TRA PEA; TRA PGS
033645          "0"; *TRR PID; TRR PIE
033650          "LV0"; *IRW 0 DP; ION
033653   LV0:   *IOF
033654          IMASK; *TRR IIE
033656          GO BYPAX; *)FILL
033675
033675   BYPAX:
033675   *"8BEX1
"033675   % INITIALIZE BUS EXPANDER
033675          IF MEMTYPE BIT BBEXPANDER THEN
033700             T := 100000 =: CURBX
033702             T:=CURBX+4=:CURBX            % NEXT ADRESS
033705             T-1; A:=20; *IOXT            % SET SWITCH LIMITS
033710             DO WHILE 100040 >> CURBX     % 8 EXPANDERS MAXIMUM!!!
033714                T + 4 =: CURBX - 1
033717                A := 20; *IOXT; TRA IIC   % SET SWITC ON THIS
033722                IF A = 7 GO L2            % NOT PRESENT!!!
033725                A:=40; *IOXT              % ENABLE READING OF PEA-REG
033727                T-3; *IOXT                % READ PEA-REG.
033731                T+3; A:=2; *IOXT          % ENABLE INTERRUPT FROM EXPANDER
033734             OD
033735          FI
033735   *"
"033735
033735   L2:
033735   *"8MPM4
"033735   %  INITIALIZE MULTIPORT IV
033735          IF MEMTYPE BIT BMPM4 THEN
033740             T:= 100200 =: CURBX                    % INIT FIRST DEVNO
033742             DO WHILE 100400 >> CURBX               % CLEAR AND INIT
033746                T+4 =: CURBX - 1                    % ALL POSSIBLE MPM4 BUSC'S
033751                A := 040; * IOXT                    % ENABLE READ LPEA
033753                T - 3; * IOXT                       % READ LPEA
033755                T + 2; * IOXT                       % READ STATUS TO CLEAR IT
033757                T + 1; A := 06; * IOXT              % CLEAR DEVICE AND ENABLE INTERRUPT
033762             OD; * TRA IIC                          % CLEAR IIC
033764          FI
033764   *"
"033764          GO L3; *)FILL
033772
033772   % RESTORE REGISTER BLOCKS
033772   INTEGER LEVCN,LRBI(0); *LRB 10
033774   L3:    *1BANK
033775          X:="LEV1"; -16=:LEVCN; LRBI
034001          FOR LEVCN DO; *EXR SA
034002                X+10; A+10 OD
034006          "FREQU+160001"; *IOX DCONT RTCLD
034010          *2BANK
034011          9TIM0; *IOX DDW RTCLD
034013          PIEREG; *TRR PIE
034015          PIDREG ; *TRR PID
034017          IF PIDREG><0 THEN
034021             IF X:=URESTART><0 THEN
034023                *JPL ,X                             % CALL "USER-RESTART" ROUTINE
034024              FI
034024              X:="URERTP"; MQUEU=:X.MLINK; X=:MQUEU % START USER RESTART PROGRAM
034030          FI
034030   % INITIALIZE NOTS CONTROLLERS
034030          CALL MNINIT
034031   % SET UP POINTERS TO AND INITIALIZE THE MEMORY AREA USED
034031   % FOR REG.BLOCKS AND REE.BITMAP
034031         IF PIDREG=0 THEN           % NOT AFTER POWER FAIL
034033            "SRTDL"=:D
034035            X:=RTSTART
034036            DO WHILE X <<="ERTBS"-5RTSIZE
034042               A:=D=:X.RTDLGADDR+5XRTDSIZE=:D
034046               IF X.BRESLINK=0 THEN X=: X.BRESLINK FI
034051               X+5RTSIZE
034052            OD
034053            X:="SRTDL"; *1BANK
034055            DO WHILE X<<D; 0=:X.S0; X+1 OD; *2BANK
034063            "DUMMY".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034071            "STSIN".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034077            "1SWAP".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034105          FI; GO OVFI1; *)FILL
034125   OVFI1:
034125   % INITIALIZE MICRO SEGADM FOR CX/K MICRO PROGRAM
034125          IF HWINFO(0)/\377 >= 3 THEN
034133              TAD:=GLOBPARAM
034134              *WGLOB
034135                          % AND CHECK THAT THEY ARE CORRECT
034135              0=:T=:A=:D
034140              *RGLOB
034141              IF T >< X:=SEGTBANK THEN CALL ERRFATAL FI
034145              IF A >< X:=SEGSTART THEN CALL ERRFATAL FI
034151              IF D >< X:=CORMBANK THEN CALL ERRFATAL FI
034155          FI
034155          GO L4
034156   *)FILL
034164
034164   L4:
034164          IF PIDREG=0 THEN                            % INITIAL START, (NOT AFTER POWER FAIL)
034166             A:=UCACHLIM=:D:=LCACHLIM; CALL DISCACHE; 0/\0
034173             IF HWINFO(0)/\ 377 >=3  THEN                 % ND-110 , ND-120
034201                DBDPAGE;    CALL DISCACHE; 0/\0
034204                DHDLCPAGES; CALL DISCACHE; 0/\0
034207                DSPTRPHPAGE;CALL DISCACHE; 0/\0
034212             FI
034212          FI
034212          IF HWINFO(0)/\ 377 >=3  THEN                    % ND-110 , ND-120
034220             IF PIDREG=0 THEN
034222                CALL FAR PINHBTCACHE                  % INHIBIT PAGES IN CACHE
034223             ELSE
034224                CALL FAR PENABCACHE                   % ENABLE PAGES IN CACHE (CACHE IS CLOSED AFTER MASTER-CLEAR)
034225             FI
034225          ELSE
034226             CALL FFPCACHEINHIBIT; A:=-1; *TRR 11  % SET LOWER CACHE INHIBIT PAGE
034231             CALL FLPCACHEINHIBIT; A:=0;  *TRR 12  % SET UPPER CACHE INHIBIT PAGE
034234             *TRR CCLR                             % CLEAR CACHE
034235          FI
034235   % CLEAR PIT #0 AND PIT #17
034235          X:=174000; A:=0; D:=0
034240          *POF
034241          DO AD=:X.DOU0; X+2 WHILE X><174200 OD
034247          X:=177600; DO AD=:X.DOU0; X+2 WHILE X><0 OD
034254          PCCS(0); *TRR PCR               % SET PCR FOR LEVEL 0
034257          GO L5
034260   *)FILL
034275   TRIPLE ARRAY POINTER ESPARRAY
034276
034276   % RESTORE PIT ENTRIES FOR SEGMENTS ENTERED WITH MON ENTSG
034276   % GET NUMBER OF SEGMENTS ENTERED WITH ENTSG
034276   L5:    "ESCNT"=:X; T:=DPITBANK; *LDATX          % PHYSICAL ADDRESS OF ESCNT.
034302          IF A >< 0 THEN                           % IF ANY SEGMENTS ENTERED
034303              "ESARRAY"=:"ESPARRAY"                % SET POINTER TO ENTERED SEGMENTS TABLE
034305              FOR X:=0 STEP 3 TO "ESMAX-1*3" DO    % REENTER SEGMENTS.
034311                  TAD:=ESPARRAY(X)
034312                  IF T >< 0 THEN CALL PFENTSG FI
034315              OD
034317          FI
034317          CALL UPPOW                 % POWWER UP TO OCTOBUSS ?
034320          GO PENT0
034321   RBUS
034326
034326
034326   @ICR
034326   INTEGER ARRAY LEV1:=(
034326   ERRFA,0,0,0,0,0,1,0,
034336   MONEN,0,0,0,0,0,1,0,
034346   ERRFA,0,0,0,0,0,1,0,
034356   ERRFA,0,0,0,0,0,1,0,
034366   ERRFA,0,0,0,0,0,1,0,
034376   ERRFA,0,0,0,0,0,1,0,
034406   ERRFA,0,0,0,0,0,1,0,
034416   ERRFA,0,0,0,0,0,1,0,
034426   ERRFA,0,0,0,0,0,1,0,
034436   WT10,0,0,0,0,0,1,0,
034446   WT11,0,0,0,0,0,1,0,
034456   WT12,0,0,0,0,0,1,0,
034466   ID13+4,0,0,0,0,0,1,0);
034476   INTEGER LEV14:=(
034476   ENT14,0,0,0,0,0,1,0);
034506   @CR;
034506
034506   *"8LAMU
"034506   %

034506   %=========================================================================
034506   %      L A M A R R
034506   %
034506   % PHYSICAL MEMORY PARTS AVAILABLE FOR LAMUS
034506   %
034506   % FORMAT: 2 LOCATIONS FOR EATCH ENTRY
034506   %         FIRST PHYSICAL PAGE IN AREA
034506   %         LAST PHYSICAL PAGE IN AREA
034506   %
034506   DOUBLE ARRAY LAMARR(NINSZ*2)
034626   * LAMAR<*; )ZERO
034626   *"
"034626
034626   %==========================================================================
034626   %       M N I N I T
034626   %
034626   % SUBROUTINE TO INITIALIZE NOTS CONTROLLERS
034626   %
034626   SUBR MNINIT
034626   INTEGER CC1,CC2
034630   INTEGER POINTER LREG
034631   MNINIT: A:=L+1=:"LREG":="MNTAB"=:CC1
034635           DO WHILE CC1.S0 >< -1                                  % SEARCH MNTAB
034642              A=:CC2
034643              IF A >< 0 THEN                                      % MBNIU PRESENT ?
034644                 T:=A.HDEV+2; 22; *IOXT                           % SET MEMORY SIZE AND WINDOW ADDRESS
034651                 T:=X.HDEV; 5; *IOXT                              % ENABLE INTERRUPTS AND MEMORY ACCESSES
034654                 T+4; *IOXT                                       % CLEAR MULTIBUS TIME-OUT BIT
034656                 T:=CC2.MNCBNK; X:="MNCONT+MNHST"; MNRST; *STATX  % INDICATE HOST INITIATED RESTART
034663                 IF PIDREG=0 THEN                                 % NOT IF POWER FAIL
034665                    A:=T SHZ 6+77=:D-177; CALL DISCACHE; *JMP *   % DISABLE CACHE FOR THIS MEMORY
034674                 FI
034674                 T:=CC2.HDEV+5; 2; *IOXT                          % GENERATE TIMER INTERRUPT
034701              FI
034701              MIN CC1
034702           OD
034703           IF PIDREG><0 THEN                                      % POWERFAIL ?
034705              IF MNACT><0 THEN
034707                 "WT10"; *IRW LV10B DP                            % ABORT DRIVER IF ACTIVE
034711              FI
034711              "LREG"+52=:"LREG"                                   % OLD CODE
034714           FI
034714           GO LREG
034715   RBUS
034723
034723   %==========================================================================
034723   %       I P T M A P
034723   %
034723   % SUBROUTINE TO SET UP PIT #0 AND PIT #17 FOR THE START AND RESTART ROUTINES
034723   %
034723   SUBR IPTMAP
034723   IPTMAP: *PIOF
034724   % INITIALIZE PAGE TABLE #0 TO LOGICAL EQUAL PHYSICAL ADDR
034724          A:=162000; D:=0; X:=174000
034727          DO AD=:X.DOU0; X+2; D+1 WHILE X><174200 OD
034736   % CLEAR ALL THE OTHER PAGE TABLES
034736          A:=0; D:=0
034740          DO AD=:X.DOU0; X+2 WHILE X><0 OD
034744          X:=177600; D:=0; A:=162000; AD=:X.DOU0
034750          X+2; D+1; AD=:X.DOU0
034753          "STPBS" SHZ -11+177600=:T
034757          A:=DPITBANK SHZ 6+2=:D:=162000; X+2
034765          DO AD=:X.DOU0; X+2; D+1 WHILE X><T OD          % MAP GLOBAL DATA
034773          A:="STPBS" SHZ -12=:D:=162000; AD=:X.DOU0      % MAP SBFIELD
035000          A:="ADTPIT+ERNG2"; *TRR PCR          % LEVEL 0: NPIT=0, APIT=17, RING=2
035002          EXIT
035003   RBUS
035010
035010   *"8SCSI
"035010   %--------------------------------------------------
035010   %
035010   % POWERFAIL/RESET ROUTINE FOR SCSI
035010   %
035010   SUBR SCPWF
035010
035010   %..............................
035010   % DEFINITIONS FOR SCSI DRIVER .
035010   %..............................
035010
035010   SYMBOL RLMAR=00              % READ MEMORY ADDRESS REGISTER BITS 14-0
035010   SYMBOL WLMAR=01              % WRITE MEMORY ADDRESS REGISTER BITS 14-0
035010   SYMBOL REDAT=02              % READ DATA
035010   SYMBOL WRDAT=03              % WRITE DATA
035010   SYMBOL RSTAU=04              % READ STATUS
035010   SYMBOL CTBUS=02              % CONTROLLER BUSY
035010   SYMBOL NCRIT=11              % INTERRUPT FROM NCR
035010   SYMBOL SCREQ=15              % REQ FROM SCSI BUS
035010   SYMBOL WCONT=05              % WRITE CONTROL
035010   SYMBOL ENDMA=05              % ENABLE DMA
035010   SYMBOL RHMAR=06              % READ MEMORY ADDRESS REGISTER BITS 23-15
035010   SYMBOL WHMAR=07              % WRITE MEMORY ADDRESS REGISTER BITS 23-15
035010   SYMBOL RNDAT=40              % READ NCR DATA REGISTER
035010   SYMBOL WNDAT=41              % WRITE NCR DATA REGIISTER
035010   SYMBOL RNCOM=42              % READ NCR COMMAND REGISTER
035010   SYMBOL WNCOM=43              % WRITE NCR COMMAND REGISTER
035010   SYMBOL RNCNT=44              % READ NCR CONTROL REGISTER
035010   SYMBOL WNCNT=45              % WRITE NCR CONTROL REGISTER
035010   SYMBOL RDESI=46              % READ DESTINATION ID REGISTER
035010   SYMBOL WDESI=47              % WRITE DESTINATION ID REGISTER
035010   SYMBOL RAUXS=50              % READ AUXILIARY STATUS
035010   SYMBOL DARGF=07              % DATA REGISTER FULL
035010   SYMBOL WAUXS=51              % WRITE AUXILIARY STATUS
035010   SYMBOL ROIDN=52              % READ OWN ID NUMBER
035010   SYMBOL RITRG=54              % READ INTERRUPT REGISTER
035010
035010   SYMBOL ILCOM=16              % ILLEGAL COMMAND
035010   SYMBOL RECON=14              % RECONNECT
035010   SYMBOL CONEC=13              % CONNECT
035010   SYMBOL DISCO=12              % DISCONNECT
035010   SYMBOL BUSSI=11              % BUS SERVICE INTERRUPT
035010   SYMBOL FUCOM=10              % FUNCTION COMPLETE
035010   SYMBOL PARIT=06              % PARITY ERROR
035010   SYMBOL PAUSE=02              % PAUSED
035010   SYMBOL TCZRO=01              % TRANSFER COUNT ZERO
035010
035010   SYMBOL RSOUI=56              % READ SOURCE ID
035010   SYMBOL RDIST=62              % READ DIAGNOSTIC STATUS
035010   SYMBOL SLFCO=07              % SELFTEST COMPLEAT NCR 5386
035010   SYMBOL RTCM=70               % READ TRANSFER COUNTER MOST
035010   SYMBOL WTCM=71               % WRITE TRANSFER COUNTER MOST
035010   SYMBOL RTC2=72               % READ TRANSFER COUNTER 2ND.
035010   SYMBOL WTC2=73               % WRITE TRANSFER COUNTER 2ND.
035010   SYMBOL RTCL=74               % READ TRANSFER COUNTER LEAST
035010   SYMBOL WTCL=75               % WRITE TRANSFER COUNTER LEAST
035010
035010   SYMBOL 6SFUN=17              % FUNCTION STARTED
035010   SYMBOL 6STMS=16              % TARGET SUPPORTS OPTIONAL MESSAGES
035010   SYMBOL 6SRST=15              % SCSI BUS RESET
035010   SYMBOL 6SBCZ=13              % BYTECOUNT ZERO
035010   SYMBOL 6SMSO=12              % MESSAGE OUT PENDING
035010   SYMBOL 6SRFD=11              % RETURN ON COMMAND ACCEPTED (I.E. FIRST DISCONNECT)
035010   SYMBOL 6SDIS=10              % DISCONNECT MESSAGE RECEIVED
035010   SYMBOL 6SCCO=7               % COMMAND COMPLETE MESSAGE RECEIVED
035010   SYMBOL 6SMSI=6               % MESSAGE RECEIVED
035010   SYMBOL 6SARB=5               % ARBITRATION PHASE
035010   SYMBOL 6SSBT=4               % SINGLE BYTE TRANSFER
035010   SYMBOL 6SCRP=3               % CONNECT/RECONNECT PHASE
035010
035010
035010   INTEGER CLMSK:=0; * *-1/1@8SRIN+^; *-1/1@8SDIA+^; *-1/1@8STMR+^
035011                     * *-1/1@8SERR+^; *-1/177777-^
035011
035011   SCRST: IF NCROK=0 THEN
035013             IF X:=SCTST>>2 THEN TMR=:X.SUTMR FI        % SAVE CURRENT TIMER
035021             -1=:SCEIM; 2=:SCTST                        % LOCK INTERFACE
035025             "0" BONE 8SRST=:NCROK
035030             IF X:=SCCSU><0 THEN
035032                IF X.SUTRG=0 THEN PFAIL=:X.SUTRG FI     % INDICATE POWERFAIL
035036                BUSFL BONE 6SRST=:BUSFL                 % INDICATE RESET STARTED
035041                NCROK BONE 8SCLR=:NCROK                 % RECOVERY NECESSARY
035044             ELSE
035045                "0" BONE 6SRST=:BUSFL                   % INDICATE RESET STARTED
035050             FI
035050             X:="SCTQP-SULINK"+B
035052             DO
035052                WHILE X:=X.SULINK><0                    % FOR ALL ACTIVE OPERATIONS
035054                IF X.SUTHS BIT 6SDIS THEN
035057                   A BONE 6SRST=:X.SUTHS                % INDICATE RESET
035061                   IF X.SUTRG=0 THEN PFAIL=:X.SUTRG FI  % INDICATE POWERFAIL
035065                   NCROK BONE 8SCLR=:NCROK              % RECOVERY NECESSARY
035070                FI
035070             OD
035071          ELSE
035072             NCROK/\CLMSK=:NCROK
035075          FI
035075          IF PIDREG><0 THEN NCROK BONE 8SPWF=:NCROK FI  % POWERFAIL
035102          "0"; T:=HDEV+WNCOM; *IOXT                     % DISCONNECT TO NCR
035106          20; T+"WCONT-WNCOM"; *IOXT                    % CLEAR CONTROLLER
035111          T+"RSTAU-WCONT"; *IOXT                        % READ STATUS
035113          IF A BIT 5 THEN
035115             NCROK BONE 8SRIN BONE 8SPWF=:NCROK         % RECEIVING RST
035121             -1=:TMR
035123          ELSE
035124             T+"WCONT-RSTAU"
035125             2000; *IOXT                                % SET RESET ON SCSI BUS
035127             -5000=:TMR; FOR TMR DO OD                  % LEAVE "RST" ON FOR AT LEAST 250 us
035133             "0"; *IOXT                                 % CLEAR RESET
035135             T+"RDIST-WCONT"                            % READ DIAGNOSTIC STATUS
035136             FOR X:=-1000 DO
035137                *IOXT
035140                WHILE A NBIT 7
035142             OD
035143             IF A=200 THEN                              % SELFCHECK OK
035146                NCROK BONE 8SDIA=:NCROK
035151                13; T:=HDEV+WNCOM; *IOXT                % START DIAGNOSTIC
035155                376; T+"WNDAT-WNCOM"; *IOXT             % WRITE DATAREGISTER
035160                5; T+"WCONT-WNDAT"; *IOXT               % ENABLE INTERRUPT
035163                -2=:TMR                                 % DIAGNOSTIC TIMER
035165             ELSE
035166                100000=:NCROK                           % ERROR IN INTERFACE
035170             FI
035170          FI
035170          EXIT
035171   *)FILL
035201
035201   INTEGER SCDNO, SAVB
035203   INTEGER POINTER HOME
035204
035204   SCPWF: A:=B=:SAVB:=L=:"HOME"
035210          2202=:SCDNO
035212          FOR SCDNO TO 2205 DO
035216             CALL LOGPH
035217             IF A=:B><0 THEN CALL FAR SCRST FI
035222          OD
035226          A:=SAVB=:B; GO HOME
035231   RBUS
035235   *"
"035235   %
035235   % ==================================================================
035235   %
035235   %  Load Control-Store if ND-110 or ND-120
035235   %
035235   %     + Loads and/or compares control-store-RAM in 110/120 from a segment
035235   %     + Segment must be permanently in memory and reside within one bank.
035235   %     + Compares the versions of the CPU-m.code and the segment.
035235   %         If CPU lowest then both loading and comparing is performed.
035235   %         If equal then only compare.
035235   %         If CPU highest then no action.
035235   %     + Floating (32/48) is choosen from the CPU type or it may be
035235   %       forced by Sintran (UCLOAD=40B OR 60B)
035235   %
035235   %     Must only be called if ND-110 or ND-120  !!!!! (or UCLOAD=0)
035235   %
035235   %     Called both when Sintran starts an after powerfail
035235   %     in 2BANK mode.
035235   %
035235   %     Separate segment for 110 and 120. Only one of them will be
035235   %     fixed in memory . Here is a visualization of the segment
035235   %     layout:
035235   %
035235   %                  ___________
035235   %     Seg. start  l           l 0
035235   %                 l info rec. l
035235   %                 l           l   See description below.
035235   %                 l-----------l
035235   %                 l           l
035235   %                 l           l
035235   %                 l-----------l <DASTA>   - Start of U-code data
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l * * * * * l <32UST>   - Start of floating part
035235   %                 l * * * * * l             of U-code. ( Micro address )
035235   %                 l * * * * * l             This part contains 32bit
035235   %                 l * * * * * l             floating. 48LEN is length
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l___________l           - End of U-code data.
035235   %                 l           l             <DASTA>+LENGT is address
035235   %                 l           l
035235   %                 l-----------l <48STA>   - Same as floating part above
035235   %                 l + + + + + l             but whith 48bit floating
035235   %                 l + + + + + l             48LEN is length
035235   %                 l + + + + + l
035235   %                 l + + + + + l
035235   %                 l-----------l
035235   %     Seg. end    l           l
035235   %                  -----------
035235   %
035235   %
035235
035235   INTEGER XERCR:='$Error in CPU control store RAM. Address : '
035263   INTEGER XERSG:='$Mismatch  CPU / micro-code-segm'
035304   INTEGER XERLC:='$$Micro-code not loaded. CPU revision too low !!$$'
035336   INTEGER XMG32:='$CPU forced to 32 bit floating!'
035356   INTEGER XMG48:='$CPU forced to 48 bit floating!'
035376
035376   SUBR LOCOSTORE
035376
035376   INTEGER SAVL=?
035376
035376   DOUBLE FLSEG=?
035376   INTEGER FLSGB=?
035376   INTEGER FLSGA=?
035376
035376   INTEGER 48FLOAT=?
035376   INTEGER SGPNTER=?
035376   INTEGER MICVER=?
035376   INTEGER CONVER=?
035376   INTEGER MXADR=?
035376   INTEGER FLSTA=?
035376   INTEGER FLDISP=?
035376   INTEGER FLEND=?
035376
035376   % ------------------------------------------------------------
035376   %  I N F O    R E C O R D.
035376   % It will be located from locaton zero on the segment,
035376   % and will describe the segment layout
035376   %
035376
035376
035376   %DISP  0; INTEGER STATU    ; PSID % Status
035376   DISP  1; INTEGER DASTA    ; PSID % U-code start addr. in segment
035376   DISP  2; INTEGER LENGT    ; PSID % U-code length in 16 bit words
035376                                    %  48 bit floating part that may be xchanged
035376   DISP  3; INTEGER 32UST    ; PSID % U-start address for floating (in micro prog 64bit words)
035376   DISP  4; INTEGER 48STA    ; PSID % Data start in segment
035376   DISP  5; INTEGER 48LEN    ; PSID % Length in segment in 16 bit words
035376
035376   LOCOSTORE:
035376           A:=L=:SAVL
035400
035400           A:=UCFPA=:D:=0
035403           AD SH 12 =: FLSEG
035405
035405     %------------------------------------------------------
035405     % Check if control store should be loaded and which one
035405
035405           IF UCLOAD =0 THEN
035407              EXIT
035410           ELSE
035411              HWINFO(0) =:D
035414              IF UCLOAD><40 AND A><60 THEN
035423                IF D NBIT 10 THEN "1" ELSE "0" FI
035430              ELSE
035431                *1BANK
035432                IF A=40 THEN                       % Floating forced by Sintran
035435                   IF D NBIT 10 THEN "XMG32"; CALL 3UTXT FI
035441                   "0"
035442                ELSE
035443                   IF D BIT 10 THEN "XMG48"; CALL 3UTXT FI
035447                   "1"
035450                FI
035450                *2BANK
035451              FI
035451           FI
035451           A =:48FLOAT =:D :=HWINFO(0)            % "1" is 48 bit float
035455           IF D=0 THEN A BONE 10
035460           ELSE A BZERO 10 FI
035462           A=: HWINFO(X)
035463
035463    % ---------------------------
035463    % Set up working variables
035463
035463   %        *VERSN                             % U-code version CPU
035463           X := 100
035464           *150017
035465           A =: MICVER =: D
035467           IF A<<13 THEN              % CPU rev low
035472              *1BANK
035473              "XERLC"; CALL 3UTXT
035475              *2BANK
035476              GO FAR NOTLOAD
035477           FI
035477
035477           T:=FLSGB; X:=FLSGA     % Start of segment
035501
035501           *AAX DASTA; LDATX
035503           A=:FLDISP+FLSGA=:SGPNTER            % Start of U-code
035506
035506           *AAX LENGT-DASTA; LDATX
035510           A+SGPNTER =: MXADR                  % End of U-code
035512
035512           *AAX 32UST-LENGT; LDATX
035514           A SH 2 + SGPNTER =: FLSTA           % Start of floating part in U-code
035517
035517           *AAX 48STA-32UST; LDATX
035521           A +SGPNTER -FLDISP =:L -FLSTA =:FLDISP     % Disp to 48 bit floating part
035526
035526           *AAX 48LEN-48STA; LDATX
035530           A + L =: FLEND                       % End of 48 bit floating
035532           *AAX -48LEN
035533
035533           X:=SGPNTER
035534           *AAX 100; LDATX                      % U-code version in segment
035536           A =: CONVER
035537
035537           IF A >< D THEN
035541              *1BANK
035542              IF A BIT 17 AND D NBIT 17 THEN "XERSG"; CALL 3UTXT; CALL ERRFATAL FI
035551              IF A NBIT 17 AND D BIT 17 THEN "XERSG"; CALL 3UTXT; CALL ERRFATAL FI
035560              *2BANK
035561           FI
035561           IF A << D GO NOTLOAD
035563
035563           GO CONTLO
035564   *)FILL
035575
035575   % --------------------------------------------
035575   %        Variables
035575
035575   INTEGER SAVL
035576
035576   DOUBLE FLSEG(0)
035576   INTEGER FLSGB           % Segments physical address in memory (fixed)
035577   INTEGER FLSGA
035600
035600   INTEGER 48FLOAT           % 0=32 bit fl. / 1=48 bit fl.
035601   INTEGER SGPNTER           % Current address on segment
035602   INTEGER MICVER            % Micro prog version from CPU
035603   INTEGER CONVER            % Version from segment
035604   INTEGER MXADR             % End of chosen control store
035605   INTEGER FLSTA             % Trig address in segment for start load floating part
035606   INTEGER FLDISP            % Disp to get 48 float part for same
035607   INTEGER FLEND             % End address for same
035610     %-------------------
035610     % Load control store
035610
035610   CONTLO: 0=:D          % CONT START ADDR
035611           X:=SGPNTER
035612           IF 48FLOAT=1 THEN K:="1" ELSE K:="0" FI
035621           DO
035621                                               % X=segm/ D=cpu
035621                IF K THEN             % 48 bit floating handeling
035623                   IF X=FLSTA THEN    % Start floating
035626                      A:=X+FLDISP=:X
035631                   FI
035631                   IF X=FLEND THEN    % End floating
035634                      A:=X-FLDISP=:X
035637                      K:="0"
035640                   FI
035640                FI
035640                T := FLSGB
035641                *LDATX                % Load from segm.
035642                X:=:D                          % X=cpu / D=segm
035643                *150117               % Store to CPU
035644                X:=:D
035645                                               % X=segm/ D=cpu
035645                X+1; D+1
035647                WHILE X><MXADR
035652           OD
035653    % --------------------
035653    % Test control store
035653
035653   CHKCONT:
035653           0=:D          % CONT START ADDR
035654           X:=SGPNTER
035655           IF 48FLOAT=1 THEN K:="1" ELSE K:="0" FI
035664           DO
035664                IF K THEN             % 48 bit floating handeling
035666                   IF X=FLSTA THEN    % Start floating
035671                      A:=X+FLDISP=:X
035674                   FI
035674                   IF X=FLEND THEN    % End floating
035677                      A:=X-FLDISP=:X
035702                      K:="0"
035703                   FI
035703                FI
035703
035703                T:=FLSGB
035704                *LDATX
035705                X:=:D ; A=:L
035707                *150017               % Read cont store
035710                X:=:D
035711
035711                IF A >< L THEN         % Error in cpu
035713                   A:=D=:SGPNTER
035715                   *1BANK
035716                   "XERCR"; CALL 3UTXT
035720                   SGPNTER; CALL FOCTU
035722                   CALL ERRFATAL
035723                FI
035723                X+1 ; D+1
035725                WHILE X><MXADR
035730           OD
035731   NOTLOAD:
035731           A:=SAVL=:L
035733           EXIT
035734   RBUS
035740
035740
035740   %==============================================================================
035740   % 36.24      N S W P A G E  -  N I N I T P A G E  -   C U M T A B L E
035740   %
035740   % NSWPAGE    : MEMORY AREA NOT USED AS SWAPPING AREA
035740   % NINITPAGE  : MEMORY AREA NOT LEGAL TO INITIALIZE
035740   %
035740   % THE LAYOUT IN THE TABLES:
035740   %      TWO WORDS FOR EACH ENTRY, FIRST PAGE AND LAST PAGE IN AREA
035740   %      THE TABLES ARE TERMINATED BY A ZERO
035740   %
035740   DOUBLE ARRAY NSWPAGE(NNSWSZ)           % MEMORY AREAS UNAVAILABLE FOR SWAPPING
036010   *NINSZ
036011   DOUBLE ARRAY NINITPAGE(NINSZ)          % MEMORY AREAS NOT ACCESSED IN START-UP (SHARED BETWEEN CPU'S)
036061   *0;0                                   % RESERVED FOR MBNIU PATCH
036063   DOUBLE ARRAY CUMTABLE(CUMSIZE)         % CUSTOMER RESERVED MEMORY AREAS
036107   DOUBLE ARRAY USIOXTAB(USDVSIZE)        % CUSTOMER RESERVED PHYSICAL DEVICE NUMBERS (SHOULD NOT BE CLEARED)
036127   DOUBLE ARRAY MMPIOC(24)                % PHYS MEMORY USED BY THE PIOCS, (FIRST AND LAST PHYS PAGE)
036177                                          % PIOC NUMBER IS INDEX IN MMPIOC
036177   * NSWPA<*; )ZERO
036177   * CURR=*
036177   * USIOX/144300;144677                  % SCSI DEVICE NUMBERS
036111   * CURR/ )KILL CURR
036177
036177   @DEV 1
036177   @DEV (S-S-L)PH-P2-CONFG-TAB:NPL
036177   %

036177   %============================================================================
036177   %       TABLES FOR MON CONFIG.              (CX-CONFIG-TABLES)
036177   %
036177   %
036177   % HDLC-TABLE
036177   DISP 0
036177   INTEGER HDLCSELECTION
036177   INTEGER LOGHDLC
036177   INTEGER NHDLC
036177   INTEGER NOHDLC
036177   INTEGER SYNHDLC
036177   INTEGER SYNOHDLC; DOUBLE DSYNHDLC=SYNHDLC
036177   INTEGER IDHDLC
036177   INTEGER INTHDLC              % DF-ADDR TO INSERT IN IDENT-CODE TABLE
036177   INTEGER CDF1CLTIMER          % DF-ADDR TO REMOVE FROM TIMER TABLE
036177   INTEGER CDF2CLTIMER          % DF-ADDR TO REMOVE FROM TIMER TABLE
036177   DOUBLE 2CDFCLTIMER=CDF1CLTIMER
036177   PSID
036177   SYMBOL TBLHDLCSIZE=12        % ELEMENT SIZE
036177   @MAC

036177
036177  %============================================================================
036177  %
036177  %       TABLE FOR LEGAL AND POSSIBLE HDLC DEVICES.
036177  %
036177  %       EACH ENTRY REPRESENTS ONE HDLC INTERFACE AND CONSISTS OF
036177  %       SIX WORDS: SELECTION, LOGICAL UNIT, HDLC-DF IN+OUT, SYNCH-DF IN+OUT.
036177  %
036177  %       SELECTION: 0 - DON'T USE THIS HDLC.
036177  %                  1 - USE THIS HDLC AS HDLC.
036177  %                      (LOGNO.IN=HDLC-DF.IN, LOGNO.OUT=0,
036177  %                       LOGNO+1.IN=0,        LOGNO+1.OUT=HDLC-DF.OUT)
036177  %                  2 - USE THIS HDLC AS SYNCH. MODEM.
036177  %                      (LOGNO.IN=SYNCH-DF.IN, LOGNO.OUT=SYNCH-DF.OUT,
036177  %                       LOGNO+1.IN=0,         LOGNO+1.OUT=0)
036177  %
036177
036177  % MACRO FOR INTERFACES THAT MEY ONLY BE USED AS HDLC.
036177  )MCDEF 11HDF $LGNO, $NNO, $IDNO
1; $LGNO ; HIF$NNO ; HOF$NNO ; 0;0; $IDNO ;  0;0;0
0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
]
036177
036177  % MACRO FOR INTERFACES THAT MAY BE USED FOR BOTH HDLC AND SYNCH. MODEM.
036177  )MCDEF 11HDX $LGNO,$NNO,$IDNO
1; $LGNO ; HDIF$NNO ;HDOF$NNO ;IDHM$NNO ;UDHM$NNO ;$IDNO ;  0;0;0
0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
]
036177
036177  0HHHH=0
036177  0HDTA=*                   % START OF HDLC TABLE.
036177  "8C1HD+8HM01
036177  11HDX 1360,1,150          % HDLC/SYNCH 1.

036177  1; 1360; HDIF1;HDOF1;IDHM1;UDHM1;150          ;  0;0;0
036211  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036211
036211  "8C2HD+8HM02
036211  11HDX 1362,2,151          % HDLC/SYNCH 2.

036211  1; 1362; HDIF2;HDOF2;IDHM2;UDHM2;151          ;  0;0;0
036223  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036223
036223  "8C3HD+8HM03
036223  11HDX 1364,3,152          % HDLC/SYNCH 3.

036223  1; 1364; HDIF3;HDOF3;IDHM3;UDHM3;152          ;  0;0;0
036235  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036235
036235  "8C4HD+8HM04
036235  11HDX 1366,4,153          % HDLC/SYNCH 4.

036235  1; 1366; HDIF4;HDOF4;IDHM4;UDHM4;153          ;  0;0;0
036247  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036247
036247  "8C5HD+8HM05
036247  11HDX 1370,5,154          % HDLC/SYNCH 5.

036247  1; 1370; HDIF5;HDOF5;IDHM5;UDHM5;154          ;  0;0;0
036261  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036261
036261  "8C6HD+8HM06
036261  11HDX 1372,6,155          % HDLC/SYNCH 6.

036261  1; 1372; HDIF6;HDOF6;IDHM6;UDHM6;155          ;  0;0;0
036273  0ZZZH=0HHHH+1;)KILL 0HHHH;0HHHH=0ZZZH;)KILL 0ZZZH
036273
036273  "
036273  0HDEN=*                   % END OF HDLC DEVICES.
036273  -1
036274  0NHDL=0HHHH               % NUMBER OF GENERATED HDLC DEVICES.
036274  )KILL 0HHHH 11HDF 11HDX
036274  %============================================================================
036274  %
036274  %       NUMBER OF GENERATED X21 CONNECTIONS.
036274  %
036274  % MACRO FOR COUNTING X21 DATAFIELDS.
036274  )MCDEF 0XXCC
0ZZZX=0XXXX+1;)KILL 0XXXX;0XXXX=0ZZZX;)KILL 0ZZZX
]
036274  0XXXX=0
036274  "8C1X2; 0XXCC    % X21 #1.

036274  0ZZZX=0XXXX+1;)KILL 0XXXX;0XXXX=0ZZZX;)KILL 0ZZZX
036274
036274  "8C2X2; 0XXCC    % X21 #2.

036274  0ZZZX=0XXXX+1;)KILL 0XXXX;0XXXX=0ZZZX;)KILL 0ZZZX
036274
036274  "
036274  0NX21=0XXXX
036274  )KILL 0XXXX 0XXCC
036274  )9SLPL
036274   %============================================================================
036274   %
036274   %       TABLE FOR LINE PRINTERS.
036274   %       EACH ENTRY CONSISTS OF 16 WORDS, SEE BELOW.
036274   %
036274   %       SELECTION: 0 - DON'T USE THIS L-P.
036274   %                  1 - USE DF-1 FOR THIS L-P. (DMPR-TYPE).
036274   %                  2 - USE DF-2 FOR THIS L-P. (DMLP-TYPE).
036274   %                  3 - USE DF-3 FOR THIS L-P. (DLPR-TYPE).
036274   %
036274   DISP 0
036274   INTEGER LPSELECTION                         % L-P TYPE
036274   INTEGER LPLOGNO                             % MAIN LOG.NO
036274   INTEGER LPDMLOGNO                           % DMA-DF LOG.NO
036274   INTEGER LPIODF(0)                           % ADDR OF MAIN DATAFIELD
036274   INTEGER 1LPIODF,2LPIODF,3LPIODF
036274   INTEGER LPDMDF(0)                           % ADDR OF DMA DATAFIELDS
036274   INTEGER 1LPDMDF,2LPDMDF,3LPDMDF
036274   INTEGER LPIDENT(0)                          % IDENT-CODE
036274   INTEGER 1LPIDENT,2LPIDENT,3LPIDENT
036274   INTEGER LPCLENTRY                           % FLAG><0 WHEN L-P CANNOT/SHOULD NO BE USED
036274   PSID
036274   DISP 3; INTEGER XLPDMDF; PSID               % ACCESSING LPDMDF RELATIVE TO LPIODF
036274   SYMBOL LPTBSIZE=20                          % ELEMENT SIZE
036274
036274   INTEGER ARRAY 0LPTA(0)
036274   *"8LP1+8DLP1+8NLP1+8DVE1
"036274   DATA( 0,    5, 1167, IDMP1, DILP1,  DLPR, DMPR1, DMLP1,  DLPR, 140230,  3,  3, 0,0,0,0) % LINE PRINTER 1.
036314   *"8LP2+8DLP2+8NLP2+8DVE2
"036314   DATA( 0,   15, 1175, IDMP2, DILP2, DLPR2, DMPR2, DMLP2, DLPR2, 140231, 23, 23, 0,0,0,0) % LINE PRINTER 2.
036334   *"8LP3+8DLP3+8NLP3+8DVE3
"036334   *0NLPS=*-0LPTA@-4             % NUMBER OF GENERATED LINE PRINTERS.
036334   DATA( -1)
036335
036335   %============================================================================
036335   %
036335   %       TABLE SPOOLING DEVICES.
036335   %       EACH ENTRY IS ONE WORD: LOGICAL DEVICE NUMBER FOR THIS SPOOLING INDEX.
036335   %       THE LOGICAL UNIT SHOULD BE ENTERED INTO THE CORRESPONDING SPOOLING
036335   %       DATAFIELD AND REMOVED FROM THE BACKGROUND TABLE.
036335   %
036335   INTEGER 0SPTA(0)
036335   @MAC

036335  "SLP1;   SLD1  % SPOOLING DEVICE # 1
036336  "SLP2;   SLD2  % SPOOLING DEVICE # 2
036337  "SLP3;   SLD3  % SPOOLING DEVICE # 3
036340  "SLP4;   SLD4  % SPOOLING DEVICE # 4
036341  "SLP5;   SLD5  % SPOOLING DEVICE # 5
036342  "SLP6;   SLD6  % SPOOLING DEVICE # 6
036343  "SLP7;   SLD7  % SPOOLING DEVICE # 7
036344  "SLP8;   SLD8  % SPOOLING DEVICE # 8
036345  "SLP9;   SLD9  % SPOOLING DEVICE # 9
036346  "SLP10;  SLD10 % SPOOLING DEVICE # 10
036347  "SLP11;  SLD11 % SPOOLING DEVICE # 11
036350  "SLP12;  SLD12 % SPOOLING DEVICE # 12
036351  "SLP13;  SLD13 % SPOOLING DEVICE # 13
036352  "SLP14;  SLD14 % SPOOLING DEVICE # 14
036353  "SLP15;  SLD15 % SPOOLING DEVICE # 15
036354  "SLP16;  SLD16 % SPOOLING DEVICE # 16
036355  "SLP17;  SLD17 % SPOOLING DEVICE # 17
036356  "SLP18;  SLD18 % SPOOLING DEVICE # 18
036357  "SLP19;  SLD19 % SPOOLING DEVICE # 19
036360  "SLP20;  SLD20 % SPOOLING DEVICE # 20
036361  "SLP21;  SLD21 % SPOOLING DEVICE # 21
036362  "SLP22;  SLD22 % SPOOLING DEVICE # 22
036363  "
036363  0SPLE=*-0SPTA  % END OF SPOOLING TABLE.
036363  -1
036364  )9RCLC
)9SLPL
036364   %=========================================================================
036364   %
036364   % TABLE FOR XMSG GENERATION PARAMETERS. THE TABLE CONSIST OF 30B ELEMENTS.
036364   % EACH ELEMENT IS 3 WORDS;
036364   %
036364   % 1) MINIMUM LEGAL VALUE
036364   % 2) CURRENT GENERATED VALUE
036364   % 3) MAXIMUM LEGAL VALUE
036364   %
036364   % THE TABLE IS USED BY MON 343 (CONFG)
036364   %
036364   %=========================================================================
036364
036364   INTEGER ARRAY XRUNA=?
036364   @ICR
036364   INTEGER ARRAY XMINA:=(   3, X4TSK,    764,  % SUBINDEX  1; NUMBER OF TASK DISCRIPTORS
036367                            3, X5PRT,    777,  % SUBINDEX  2; NUMBER OF PORTS
036372                            1, X4NAM,   1500,  % SUBINDEX  3; NUMBER OF NAMED SYSTEMS/PORT
036375                            4, X4NLW,     24,  % SUBINDEX  4; LENGTH OF NAME IN WORDS
036400                            2, X4MES,   7640,  % SUBINDEX  5; NUMBER OF MESSAGE ELEMENTS
036403                          400, X4MMX,  77776,  % SUBINDEX  6; MESSAGE SIZE IN BYTES
036406                          400, X5MTS, 177466,  % SUBINDEX  7; BUFFER SPACE OWNED BY A TASK (IN BYTES)
036411                            1, X4BPG,    400,  % SUBINDEX 10; MESSAGE BUFFER SPACE IN PAGES
036414                            0, X4MCB,    144,  % SUBINDEX 11; MAX. NUMBER OF CALLS IN A MULTICALL FUNCTION
036417                            1, X4SIR,   1500,  % SUBINDEX 12; NUMBER OF SYSTEM ACCESSIBLE
036422                            0, X5LNK,    310,  % SUBINDEX 13; NUMBER OF LINKS
036425                            0, X4LTO,  77777,  % SUBINDEX 14; HDLC/MEGALINK TIMEOUT IN XTU'S
036430                            0, X5TO1,  77777,  % SUBINDEX 15; TIMEOUT WHEN RECEIVING DATAGRAMS (IN XTU'S)
036433                            0, X5TO2,  77777,  % SUBINDEX 16; TIMEOUT WHEN TRANSMITTING DATAGRAMS (IN XTU'S)
036436                            0, X3FSZ,  37776,  % SUBINDEX 17; FRAME SIZE IN WORDS (INPUT)
036441                            0, X4FSO,  37776,  % SUBINDEX 20; FRAME SIZE IN WORDS (OUTPUT)
036444                            0, X4ACK,    764,  % SUBINDEX 21; NUMBER OF NETWORK ACKNOWLEDGEMENT FRAMES
036447                            0, X4NBF,     10,  % SUBINDEX 22; NUMBER OF RECEIVE BUFFERS PER LINK
036452                            1, X4TMS,    144,  % SUBINDEX 23; NUMBER OF TRANSMIT BUFFERS PER NETWORK SERVER
036455                            0, X4IRM, 177777,  % SUBINDEX 24; MAX. NUMBER OF SABM'S WHEN STARTING THE LINK
036460                            0, X4RPM,  77777,  % SUBINDEX 25; NUMBER OF REPEATS BEFORE LINK IS STOPPED
036463                            0, X4MXH,    377,  % SUBINDEX 26; NUMBER OF HOPS ALLOWED
036466                            0, X4NGT,  77777,  % SUBINDEX 27; GATEWAY TIMEOUT IN XTU'S WHEN SENDING TO NET SERVER
036471                            0, X5TRB,    177); % SUBINDEX 30; NUMBER OF TRACE BUFFERS
036474   @CR;
036474   *XRUNA=XMINA+1
036474   %===============================================================================
036474   %   TABLE FOR XMSG VALUES USED FOR CALCULATING SIZE OF XMSG TABLES ON SEGMENT
036474   %   S3XMK
036474   %==============================================================================
036474   @ICR
036474   INTEGER ARRAY XCALC:=(4TLEN,  % SUBINDEX 1; LENGTH OF ONE XT-BLOCK
036475                         4PLEN,  % SUBINDEX 2; LENGTH OF ONE XP-BLOCK
036476                         4MLEN,  % SUBINDEX 3; LENGTH OF ONE XM-BLOCK
036477                         4LLEN,  % SUBINDEX 4; LENGTH OF ONE XL-BLOCK
036500                         5FLEN,  % SUBINDEX 5; LENGTH OF ONE XD- AND XF-BLOCK
036501                         X5FUN,  % SUBINDEX 6; LENGTH OF FUNCTION BLOCK
036502                         X6TOP); % SUBINDEX 7; END OF SEGMENT 76
036503   @CR;
036503   %===============================================================================
036503   % TABLE FOR NUCLEUS GENERATION PARAMETERS.
036503   %==============================================================================
036503   @ICR
036503   INTEGER ARRAY NUPAR:=(250,  % SUBINDEX 1; TOTAL MESSAGE BUFFER AREA FOR SYSTEM
036504                         500,  % SUBINDEX 2; TOTAL NUMBER DESCRIPTORS FOR SYSTEM
036505                         250,  % SUBINDEX 3; TOTAL MESSAGE BUFFER AREA FOR PUBLIC
036506                         300,  % SUBINDEX 4; TOTAL NUMBER DESCRIPTORS FOR PUBLIC
036507                         10,   % SUBINDEX 5; MESSAGE BUFFER AREA PER USER PROCESS
036510                         10,   % SUBINDEX 6; NUMBER DESCRIPTOR PER USER PROCESS
036511                         2,    % SUBINDEX 7; TRACE BUFFER SIZE
036512                         0,    % SUBINDEX 10; NUCLEUS STARTUP FUNCTION (FUTURE EXTENSION)
036513                         0,    % SUBINDEX 11; FUTURE EXTENSION
036514                         0);   % SUBINDEX 12; FUTURE EXTENSION
036515   @CR;
036515   %=========================================================================
036515   %
036515   % TABLE FOR VERSATEC ON DMA INTERFACE
036515   % EACH ENTRY CONSIST OF 7 WORDS
036515   %
036515   DISP 0
036515   INTEGER DMVSELECTION         % =0: DON'T USE THIS VERSATEC; ><0: USE IT IF INTERFACE PRESENT
036515   INTEGER DMVDATFADDR          % DATAFIELD ADDRESS
036515   INTEGER DMVDLOGNO            % LOGICAL DEVICE NUMBER OF VERSATEC
036515   INTEGER DMVDFLOGNO           % LOGICAL DEVICE NUMBER OF VERSATEC-DF-DATAFIELD
036515   INTEGER DMVIOLOGNO           % LOGICAL DEVICE NUMBER OF VERSATGEC I/O DATAFIELD
036515   INTEGER DMVIDENT             % IDENT CODE OF VERSATEC
036515   INTEGER DMVHDEV              % IOX-NUMBER OF VERSATEC
036515   PSID
036515   SYMBOL TBLVERSATEC=7         % TABLE ELEMENT SIZE
036515
036515   * 0DMVT=*
036515   *"8DMVC
"036515   DATA(1, VEFIE,  577,  576, 22,  4,  600)
036524   *"8DMV2
"036524   DATA(1, VE2FI, 1125, 1126, 23, 14, 1600)
036533   *"
"036533   DATA(-1)
036534
036534
036534   %========================================================================
036534   %
036534   % TABLE FOR SYNC.MODEM
036534   %
036534   DISP 0
036534   INTEGER SYMSELECTION         % =0: DON'T USE THIS SYNC.MODEM
036534   INTEGER SYMIDFELT            % ADDR OF INPUT DATAFIELD
036534   INTEGER SYMODFELT            % ADDR OF OUTPUT DATAFIELD
036534   INTEGER SYMLOGNO             % LOGICAL DEVICE NUMBER OF SYNC.MODEM
036534   INTEGER SYMCIDENT            % IDENT CODE OF SYNC.MODEM
036534   INTEGER SYMCLENTRY           % FLAG SET WHEN GENERATED SYNC.MODEM SHOULD BE "CLEARED"
036534   PSID
036534   SYMBOL TBLSYMSIZE=6          % TABLE ELEMENT SIZE
036534
036534   INTEGER 0SYMTAB(0)
036534   *"8SMO1
"036534   DATA(1,IDMO1,UDMO1,   6, 4,1)
036542   *"8SMO2
"036542   DATA(1,IDMO2,UDMO2,  16,14,1)
036550   *"8SMO3
"036550   DATA( -1)
036551
036551
036551   %==============================================================================
036551   % UNIVERSAL DMA/VICOM/RAMTEC CONFIGURATION TABLE
036551   % EACH ENTRY CONSIST OF THE FOLLOWING LOCATIONS
036551   %      0: ADDRESS OF DATAFIELD
036551   %      1: LOGICAL DEVICE NUMBER
036551   %      2: UDMA DEVICE NUMBER
036551   %      3: UDMA IDENT CODE
036551   %      4: VICOM DEVICE NUMBER
036551   %      5: VICOM IDENT CODE
036551   %      6: RAMTEC DEVICE NUMBER
036551   %      7: RAMTEC IDENT CODE
036551   %
036551   SYMBOL TUDMSIZE=10           % ELEMENT SIZE
036551   @ICR;
036551   INTEGER ARRAY TBUDMA:=(
036551          UDI01,2100, 140050,140010, 141460,140146, 141760,140176,
036561          UDI02,2101, 140060,140011, 141470,140147, 141770,140177,
036571          UDI03,2102, 140070,140012, 141500,140150, 142000,140200,
036601          UDI04,2103, 140100,140013, 141510,140151, 142010,140201,
036611          UDI05,2104, 140110,140014, 141520,140152, 142020,140202,
036621          UDI06,2105, 140120,140015, 141530,140153, 142030,140203,
036631          UDI07,2106, 140130,140016, 141540,140154, 142040,140204,
036641          UDI08,2107, 140140,140017, 141550,140155, 142050,140205,
036651          UDI09,2110, 140150,140020, 141560,140156, 142060,140206,
036661          UDI10,2111, 140160,140021, 141570,140157, 142070,140207,
036671          UDI11,2112, 140170,140022, 141600,140160, 142100,140210,
036701          UDI12,2113, 140200,140023, 141610,140161, 142110,140211,
036711          UDI13,2114, 140210,140024, 141620,140162, 142120,140212,
036721          UDI14,2115, 140220,140025, 141630,140163, 142130,140213,
036731          UDI15,2116, 140230,140026, 141640,140164, 142140,140214,
036741          UDI16,2117, 140240,140027, 141650,140165, 142150,140215,
036751          -1);
036752
036752   @CR;
036752
036752   @DEV 1
036752   @EOF
036752
%------------------------------------------------------------
040752  %
040752  %  DISK LAYOUT:
040752  %      SECWO, SECTR, SECSY, MAXCY, POLSY, REFOR, RESCY, DISPN
040752  %          SECWO = WORDS   / SECTOR.
040752  %          SECTR = SECTORS / TRACK.
040752  %          SECSY = SECTORS / CYLINDER.
040752  %          MAXCY = VALUE OF MAX CYLINDER.
040752  %          POLSY = VALUE OF FIRST CYLINDER IN POOL.
040752  %          REFOR = FORMAT TYPE:
040752  %                     0 = TRACK OR NO REALLOCATION.
040752  %                    10 = TRACK OR NO REALLOCATION + TEST SECTOR ADDRESS
040752  %                    20 = SECTOR REALLOCATION.
040752  %          RESCY = VALUE OF FIRST RESERVED CYLINDER.
040752  %          ALTFO = ALTERNATIVE FORMAT (ADDRESS OF DTxxx OR 0)
040752  %          DISPN = INDEX FOR THIS ENTRY(FORMAT).
040752  %
040752
040752  "8WD1+8WD2+8MD1+8MD2
040752
040752  DT014, 1000; 14;   44;  577; 1124;  0;    0;     0; 10 % DISC-14MB
040763  DT021, 1000; 14;   44; 1134; 1124;  0;    0;     0; 11 % DISC-21MB
040774  DT023, 1000; 11;   33; 1475; 1462;  0;    0;     0; 12 % DISC-23MB
041005  DT045, 1000; 11;   66; 1475; 1462;  0;    0;     0; 13 % DISC-45MB
041016  DT028, 1000; 11;   33; 1775; 1763;  0; 1776;     0; 14 % DISC-28MB
041027  DT074, 1000; 11;  110; 1775; 1763;  0; 1776;     0; 15 % DISC-74MB
041040
041040  "8BD1+8BD2+8BD3+8BD4
041040
041040  DT030, 1000; 22;   22; 1466; 1465; 10;    0;     0; 20 % DISC-30/60/90MB
041051  DT037, 1000; 22;  132;  632;    0; 10;    0;     0; 21 % DISC-38MB
041062  DT070, 1000; 22;  132; 1466; 1434; 10; 1465;     0; 22 % DISC-70MB
041073  DT075, 1000; 22;  132; 1466; 1465; 10;    0;     0; 23 % DISC-75MB
041104  DT140, 1000; 22;  264; 1466; 1441; 10; 1465; DT135; 24 % DISC-140MB-F
041115  DT135, 1000; 21;  252; 1466; 1462; 20; 1465; DT140; 25 % DISC-140MB-S
041126  DT160, 1000; 22;  264; 1466; 1465; 10;    0;     0; 26 % DISC-2-75MB
041137  DT288, 1000; 22;  526; 1466; 1465; 10;    0;     0; 27 % DISC-288MB-R
041150  DT285, 1000; 21;  630; 1306; 1303; 20; 1305; DT300; 30 % DISC-288MB-S
041161  DT300, 1000; 22;  660; 1306; 1260; 10; 1305; DT285; 31 % DISC-288MB-F
041172  DT450, 1000; 32; 1160; 1306; 1303; 20; 1305; DT460; 32 % DISC-450MB-S
041203  DT460, 1000; 33; 1210; 1306; 1260; 10; 1305; DT450; 33 % DISC-450MB-F
041214  DT310, 1000; 32;  404; 2300; 2267; 20; 2277;     0; 17 % DISC-288MB-E
041225  DT470, 1000; 37; 1115; 1367; 1363; 20; 1366;     0; 34 % DISC-450MB-N
041236  DT290, 1000; 43;  536; 1466; 1460; 20; 1465;     0; 35 % DISC-288MB-N
041247  "8SCSI
041247  DTSSS, 1000;  0;    0;    0;    0;  0;    0;     0; 36 % SCSI DISK
041260  DTOD1, 1000; 36;    0;    0;    0;  0;    0;     0; 40 % OPTICAL DISK (RS=1024)
041271  DTOD2, 2000; 36;    0;    0;    0;  0;    0;     0; 41 % OPTICAL DISK (RS=2048)
041302  "
041302  %      END LAYOUT
041302
041302  DILEZ=11                     % DISC LAYOUT TABLE ELEMENT SIZE
041302
041302  %------------------------------------------------------------
041302  %
041302  %   DISC TYPE POINTER     ==> Optional
041302  %
041302  %          0      1      2      3      4      5      6      7
041302  DISPE,     0; DT010; DT033; DT066;     0;     0;     0;     0 % 00 - 07
041312         DT014; DT021; DT023; DT045; DT028; DT074;     0; DT310 % 10 - 17
041322         DT030; DT037; DT070; DT075; DT140; DT135; DT160; DT288 % 20 - 27
041332         DT285; DT300; DT450; DT460; DT470; DT290; DTSSS;     0 % 30 - 37
041342         DTOD1; DTOD2;     0;     0;     0;     0;     0;     0 % 40 - 47
041352  MAXDI=47                     % MAX DISC TYPE INDEX
041352
041352  )LINE
041352   @DEV (S-S-L)PH-P2-OPPSTART:NPL
041352

041352   %%%%%%%%%%%%%%%%%%%%%%% P H - P 2 - O P P S T A R T %%%%%%%%%%%%%%%%%%%%%%%%%%%
041352
041352   SUBR SINTR,TTMMAP
041352
041352   %===============================================================================
041352   % 36.16      S I N T R
041352   %
041352   *SRTDL=*                     % START OF REG-BLOCKS AND REE-BITMAPS
041352   %===========================================================================
041352   *PL000=*
041352   % MAIN-SWAPPING-DISC DATA  (XXDIS)
041352   % EACH ENTRY CONSIST OF THE FOLLOWING 4 LOCATIONS:
041352   %       0: ADDRESS OF DATAFIELD
041352   %       1: LOGICAL DEVICE NUMBER
041352   %       2: ENTRY POINT OF DRIVER USED BY BOOTS-STRAP, ("SWAP DRIVER")
041352   %       3: ENTRY POINT OF START-UP DRIVER
041352   %       4: HARDW. DEV NO FOR SWAPPE CONT.
041352   @ICR;
041352   INTEGER ARRAY MDISCS:=(
041352           0,    0,    0,    0,    0,    0,    0,    0,   % 00 - 07
041362       WWDIS,WWDIS,WWDIS,WWDIS,WWDIS,WWDIS,    0,BBDIS,   % 10 - 17
041372       BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,   % 20 - 27
041402       BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,SCDIS,    0,   % 30 - 37
041412           0,    0,    0,    0,    0,    0,    0,    0);  % 40 - 47
041422
041422   INTEGER ARRAY WWDIS:=(WIGDI,1224,ZWDIS,WIDIS,   500);  % ST-506
041427   INTEGER ARRAY BBDIS:=(BIGDI,1100,ZBDIS,BDISK,  1540);  % SMD
041434   INTEGER ARRAY SCDIS:=(SCDI1,2210,SCSWD,SCSWD,144300);  % SCSI
041441   INTEGER ARRAY XXDIS:=(    0,   0,    0,    0,     0);  % SPARE
041446   @CR;
041446   %=============================================================================
041446   %            T T M M A P
041446   %
041446   % LOCAL SUBROUTINE TO TEST IF A PAGE (MEMORY BANK), EXIST OR NOT
041446   %
041446   % ENTRY:     A=PAGE NUMBER
041446   %
041446   % EXIT:      PAGE DOES NOT EXIST
041446   %
041446   % EXIT+1:    PAGE EXSIST
041446   %
041446   TRIPLE TRARDR
041451   INTEGER XR,CCBTST(0); *BSKP ZRO DT
041453   TTMMAP: TAD=:TRARDR; X=:XR
041455          A SHZ -6; AD SHZ -4; T:=TMMAP(A)
041461          AD SH 4; A/\17 SH 3+CCBTST; *EXR SA
041466          L+1; TAD:=TRARDR; X:=XR
041471          EXIT
041472
041472   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 10
041472   %
041472   % ENTRY:  A=IDENT CODE
041472   %
041472   10IDCLEAR:
041472          IF A><0 THEN
041473             A-1=:X:="ITB10"-"PITEX"; X+A
041500             A:=MPIFPHPAGE SHZ 12; X+A
041503             T:=MPIBANK; *STZTX                               % CLEAR ENTRY
041505          FI; EXIT
041506
041506   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 11
041506   %
041506   % ENTRY:  A=IDENT CODE
041506   %
041506   11IDCLEAR:
041506          IF A><0 THEN
041507             A-1=:X:="ITB11"-"PITEX"; X+A
041514             A:=IPIFPHPAGE SHZ 12; X+A
041517             T:=IPIBANK; *STZTX                               % CLEAR ENTRY
041521          FI; EXIT
041522
041522   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 12
041522   %
041522   % ENTRY:  A=IDENT CODE
041522   %
041522   12IDCLEAR:
041522          IF A><0 THEN
041523             A-1=:X:="ITB12"-"PITEX"; X+A
041530             A:=MPIFPHPAGE SHZ 12; X+A
041533             T:=MPIBANK; *STZTX                               % CLEAR ENTRY
041535          FI; EXIT
041536
041536
041536   % CLEAR AN ENTRY IN THE LOGICAL UNIT TABLE
041536   %
041536   % ENTRY:  A=LOG.DEV.NO
041536   %
041536   CLLOGENTRY:
041536          IF A><0 THEN
041537             A=:D SHZ -6; X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
041550             T:=LOGDBANK; *STZTX; STZTX 10
041553          FI; EXIT
041554
041554
041554   % LOCAL SUBROUTINE TO REMOVE AN ELEMENT FROM THE TIMER TABLE
041554   %
041554   % ENTRY:   A=ACTUAL TIMER-TABLE-ELEMENT VALUE
041554   %
041554   RFTMTABLE:
041554          IF A><0 THEN
041555             A=:XA; "TMRTA"-"PITEX"=:X; RPIFPHPAGE SHZ 12=:D; X+A  % X=START OF TIMER TABLE
041565             "ETMRT"-"PITEX"; D+A                                  % D=END OF TIMER TABLE +1
041570             DO WHILE X<<D
041572                T:=RPIBANK; *LDATX
041574                IF A-XA=0 THEN                                     % ELEMENT FOUND
041576                   *STZTX                                          % CLEAR ENTRY
041577                   EXIT
041600                FI; X+1
041601             OD
041602          FI; EXIT
041603   *)FILL
041616
041616   *PL001=*
041616
041616   % LOCAL SUBROUTINE TO CHECK IF A FLOPPY INTERFACE IS PRESENT
041616   % AND UPDATE TIMER-TABLE, IDENT-CODE TABLE, LOGICAL UNIT TABLE
041616   % ACCORDING TO THE RESULT OF THE INVESTIGATION, I.E
041616   % ENTRIES ARE CLEARED IF INTERFACE NOT FOUND, CORRECT DATAFIELD,
041616   % OLD OR NEW FLOPPY, IS INSERTED INTO THE TABLES IF INTERFACE IS PRESENT.
041616   %
041616   INTEGER POINTER FFLLREG
041617   FINDFLOPPY: X=:CSAVX                              % X=ADDR OF FLOPPY-ARRAY
041620          0=:1CLTIMER=:2CLTIMER
041622          A:=L=:"FFLLREG"
041624          IF X.S0><0 OR X.S1><0 THEN                % ANY FLOPPY CONTROLLER GENERATED?
041630             X:=A; A:=200; *TRR IIE; TRA IIC        % ENABLE FOR IOX-ERRORS
041634             T:=X.HDEV+2; *EXR ST                   % IOX READ STATUS
041637             A=:D; *TRA IIC                         % D=FLOPPY STATUS
041641             IF A=0 THEN                            % INTERFACE PRESENT
041642                IF D<0 THEN
041644                   CSAVX.S1; T:=X.S0                 % NEW FLOPPY
041647                ELSE
041650                   CSAVX.S0; T:=X.S1                 % OLD FLOPPY
041653                FI; T=:1CLTIMER                     % ENTRY TO BE REMOVED FROM TIMER TABLE
041654             ELSE
041655                CSAVX.S0=:1CLTIMER; X.S1=:2CLTIMER
041662                A:=0                                % INTERFACE NOT PRESENT
041663             FI; A=:XA                              % D=VALUE TO INSERT INTO TABLES
041664             CSAVX.S2=:T SHZ -6; X:=CNVRT(A)
041672             A:=T/\77 SH 1+1; X+A                   % X=ADDR IN LOG.DEV.NO. TABLE
041677             A:=XA; T:=LOGDBANK; *STATX             % UPDATE LOG.DEV.NO. TABLE
041702             T:=IPIFPHPAGE SHZ 12=:D
041705             A:="ITB11"-"PITEX"+D+CSAVX.S3-1=:X
041714             T:=IPIBANK; A:=XA; *STATX              % UPDATE IDENT CODE TABLE
041717             1CLTIMER; CALL RFTMTABLE
041721             2CLTIMER; CALL RFTMTABLE
041723          FI; GO FFLLREG
041724   *)FILL
041732
041732
041732   % LOCAL SUBROUTINE TO BUILD A SEGMENT
041732   %
041732   % ENTRY: A=FIRST PHYS.PAGE IN SEGMENT
041732   %        D=LAST PHYS.PAGE IN SEGMENT
041732   %        T=SEGMENT NUMBER
041732   SGBUILD:
041732          IF A+1=0 THEN EXIT FI                     % NO MEMORY RESERVED FOR THIS SEGMENT
041735          A-1; X:=L=:"CLINK"
041740          T=:CSGNO
041741          A:=:D-D+1=:NPAGES
041745          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
041752          A:=D SH 2+CORMSTART
041755          *BPAGL@3 STATX; LOGAD@3 LDATX
041757          A=:D; *SGSTA@3 LDATX
041761          A BONE 5CMSYS
041762          AD=:DPROLOGAD                   % PROTECT AND LOGADR
041763          A:=NPAGES
041764          *SEGLE@3 STATX; BPAGL@3 LDXTX
041766          X=:L; T:=CORMBANK
041770          DO WHILE NPAGES><0
041772             A:=PROLOG; *PROTE@3 STDTX
041774             D+1; *PAGLI@3 LDXTX
041776             NPAGES-1=:NPAGES
042001          OD; IF X><0 THEN CALL ERRFATAL FI
042004          X:=L; A:=CSGNO SH 2+3; *PREVI@3 STATX
042011          GO CLINK
042012   *)FILL
042020
042020   % LOCAL SUBROUTINE TO SIMULATE LOGPH FOR ELEMENTS IN IOBUTAB
042020   %
042020   % ENTRY:     A=LOGICAL DEVICE NUMBER
042020   %            CINDADDR MUST POINT TO ELEMENT IN IOBUTAB
042020   %
042020   % EXIT:      X=ADDRESS OF DATAFIELD
042020   %
042020   % CALL TO ERRFATAL WHEN ERROR
042020   @ICR;
042020   INTEGER ARRAY ENTAB:=(EN000,0,EN200,EN300,EN400,EN500,EN600,EN700,
042030                         E1000,E1100,E1200,E1300,E1400,E1500,E1600,E1700,
042040                         E2000,E2100,E2200,E2300,E2400,E2500,E2600,E2700,
042050                         E3000,E3100,    0,E3300,    0,    0,    0,    0);
042060   @CR;
042060   CLOGPH: K:=1; GO ILOGPH
042062   XLOGPH: K:="0"
042063   ILOGPH: AD SHZ -6; IF A=1 OR A =RDLNO OR A>LGDGMAX THEN CALL ERRFATAL FI
042076          A=:X:=D SHZ -12
042101          A+A+CCNVRT(X)+1=:D; *1BANK
042106          IF A-ENTAB(X)>=0 THEN CALL ERRFATAL FI; *2BANK
042112          X:=D; *POF; LDD ,X; PON
042116          IF K THEN
042120             IF A><0 THEN X:=A ELSE X:=D FI
042124          ELSE
042125             X:="ICINDADDR"; *POF; LDT ,X; PON
042131             IF T BIT 17 THEN D=:X ELSE A=:X FI
042136          FI; IF X=0 THEN CALL ERRFATAL FI
042141          EXIT
042142   *)FILL
042144   *PL002=*
042144
042144   % ROUTINE ON LEVEL 14 TO TEST FOR MMS II AND PGS WITH 10 BITS PAGE NUMBER
042144   TSPCR: *TRA IIC
042145          IF A><3 THEN CALL ERRFATAL FI                 % NOT PAGE FAULT
042151          *TRA PGS
042152          IF A/\1777><1777 THEN CALL ERRFATAL FI        % NOT MMS II?
042157          *IRR 0 DP; AAA 1; IRW 0 DP                    % INCREMENT P-REG ON LEVEL 0
042162          *WAIT; JMP *-1
042164   *)FILL
042166
042166   % LOCAL SUBROUTINES TO COMPRESS THE EXTENDED IDENT CODE TABLES
042166   %
042166   % ENTRY: X=LOGICAL START ADDR OF TABLE.
042166   %
042166   INTEGER CCBNK,CCPHP
042170
042170   EIDCIPIT:IPIBANK=:CCBNK; IPIFPFPAGE=:CCPHP; GO EIDFELLS
042175   EIDCMPIT:MPIBANK=:CCBNK; MPIFPFPAGE=:CCPHP
042201   EIDFELLS:
042201          A:=L=:"CLINK"
042203          A:=X-"PITEX"=:D:=CCPHP SHZ 12+D=:X   % PHYS. ADDR OF TABLE WITHIN MEM.BANK
042212          X=:CSAVX; T:=CCBNK
042214          DO
042214             *LDATX                       % FIND END OF TABLE
042215          WHILE A+1><0; X+2
042220          OD; X=:PREVX                    % END OF TABLE
042222          DO
042222             X:=CSAVX
042223             DO
042223                T:=CCBNK; *LDATX
042225             WHILE A><0 AND A><-1; X+2
042232             OD
042233             IF A=-1 GO CLINK                % EXIT, TABLE IS COMPRESSED
042236             IF PREVX-2<<=X GO CLINK         % EXIT, TABLE IS COMPRESSED
042242             A=:PREVX-X=:L                   % L=NUMBER OF WORDS TO MOVE
042245             A:=X+2=:D; X=:CSAVX=:T
042252             A:=CCBNK=:X; *MOVPP             % COMPRESS TABLE
042255             T:=CCBNK; X:=PREVX
042257             *STZTX; STZTX 10                % FILL OUT WITH ZEROES
042261          OD; *)FILL
042263
042263   %---------------------------------------------------------------
042263   % READ DPIT INTO BANK 1. KGT
042263   %---------------------------------------------------------------
042263   * ODDFI=*+112; ODDFI+40/; ODDFI-75<*; )ZERO  % DISK DF
042435
042435          INTEGER POINTER PSWD:=BDISK
042436          INTEGER DPAH:=DPITBANK,DPAL:=4000    % MEMORY ADDRESS
042440          DOUBLE DPAD=DPAH
042440
042440          INTEGER DPSA:=MSDPT,DPIM:=MIDPT      % DISK ADDRESS (SAVE/IMAGE)
042442          INTEGER DPLN:=LSDPT                  % LENGTH
042443          INTEGER LSST                         % SCETORS/PAGE
042444          INTEGER POINTER L3RG
042445
042445   DPRE: A:=L=:"L3RG"
042447         A:="ODDFI"=:B                           % DF. FOR DISK DRIVER
042451         T:=ODISP(SWTYP)=:HTABL(0)               % COPY OF DISPE ON START SEGM
042455         T:=T.S0; A:=2000=:D:=0; *RDIV ST        % SECTORS/PAGE
042463         IF D><0 THEN CALL ERRFATAL FI
042466         A=:LSST
042467         X:= MDISCS(SWTYPE)                      % ADDR OF DISC-ATTRIBUTES
042471         X.SWHDEV=:HDEV
042473         IF X.SWDDRIVER=:"PSWD"><"SCSWD" THEN    % DRIVER ADDRESS
042500            A:=B+"NWLBA-5"=:NWLBA                % SPARE TRACK ADDRESS
042503         ELSE
042504            A:=-70+B=:D:=0; *STD ,B -72          % SCSI BUFFER ADDRESS
042511         FI
042511         DPAD=:MEMAD=:CMADR; T:=42; X:=1
042516   LDF:  CALL PSWD; CALL ERRFATAL;GO LDF         % INITIATE DF
042521         DPAD=:MEMAD=:CMADR; A:=DPLN*LSST =:X           % PARAMETERS TO DRIVER
042527         IF HENTFLAG=0 THEN A:=DPSA ELSE A:=DPIM FI
042534         A+SEGFSTART*LSST=:D:=0; 0=:T
042541   RLOP: CALL PSWD; CALL ERRFATAL;GO RLOP
042544         GO L3RG
042545   *)FILL
042557   %-----------------------------------------------------------------
042557   %     S I N T R
042557   %-----------------------------------------------------------------
042557   % INITIALIZE PAGING SYSTEM AND INTERRUPT SYSTEM
042557   SINTR: A:=0; *PIOF; TRR IIE; TRA IIC
042563          A:=0; *TRR PID; TRR PIE
042566          A:=6; *TRR PCR; SEX; TRA PGS; TRA STS
042573          IF A NBIT 5N100 THEN CALL ERRFATAL FI % THIS SYSTEM IS ONLY FOR NORD 100!!!!
042576          A:="LV0"; *IRW 0 DP; ION
042601   LV0:   *IOF
042602          CALL DPRE                            % READ DPIT
042603          "SBFIELD"=:B
042605          CALL IPTMAP                          % SET UP THE PAGE TABLES
042606   % TEST IF THIS ND-100 HAS MMS II WITH 10 BITS PAGE NUMBER IN PGS.
042606          A:=LV14; *TRR PIE                    % ENABLE INTERRUPT ON LEVEL 14
042610          A:=10; *TRR IIE                      % ENABLE FOR PAGE FAULT
042612          A:="TSPCR"; *IRW LV14B DP
042614          A:="ADTPIT+ERNG2"; *TRR PCR          % LEVEL 0:NPIT=0, APIT=DTPIT, RING=2
042616          A:="ERNG2+LV14B"; *TRR PCR           % LEVEL 14: NPIT=APIT=0, RING=2
042620          X:=-1; *PION; 2BANK
042623          X.S0; CALL ERRFATAL                  % LEVEL 14 SHOULD INREMENT P ON LEVEL 0
042625          A:=0; *TRR PIE; TRR PID              % CLEAR LEVEL 14 ENABELING
042630          *TRA STS
042631          A=:CPSTA
042632          CALL SYSEVAL                         % FIND CPU TYPE
042633          IF HWINFO(0)/\377 >= 3 THEN CALL GCPUNR FI    % TRY TO GET CPU NUMBER
042642          IF HWINFO(0)/\377 <  2 THEN CALL ERRFATAL FI  % MUST BE ND-100/CX , ND-110/CX OR ND-120/CX
042651          IF HWINFO(0) SHZ -10=4 OR =5 THEN
042662             13642=:CPULOOPTIME                % CPU LOOP TIME FOR ND-110.
042664             -15=:LPDELAY
042666          ELSE
042667             IF A=6 OR =7 THEN
042675                27627=:CPULOOPTIME             % CPU LOOP TIME FOR ND-120.
042677                -30=:LPDELAY
042701          FI;FI
042701          A:=-1; *TRR 11
042703          A:=0; *TRR 12                        % NO CACHE INHIBIT
042705          CALL MNHDSJ                          % CHECK NOTS CONTROLLERS
042706   *IFILL
042730
042730   % TEST MEMORY ADDRESS BITS 19-23 (1-32MB)
042730          1000=:CURRPAGE
042732   % IF MULTIPORT 3 THEN 3777=:ENDPAGE ELSE 37777=:ENDPAGE FI
042732          A:=200; *TRR IIE; TRA IIC; IOX 750; TRA IIC
042737          IF A=0 THEN A:=3777 ELSE A:=37777 FI; A=:ENDPAGE
042744          A:=0; *TRR IIE
042746          DO WHILE CURRPAGE><ENDPAGE+1
042753             X:=0
042754             DO WHILE X<<"NINSZ+1*2"
042757                *1BANK
042760                AD:=NINITPAGE(X)
042761                *2BANK
042762                IF A><0 AND A<<=CURRPAGE AND D>>=T GO NEXT
042770                X+2
042771             OD; *POF
042773             X:=0; 124000=:X.S0
042776             *PON
042777             A:=CURRPAGE=:D:=162000; X:=177776
043003             *POF; STD ,X; PON
043006             A:=1000; *TRR IIE; TRA IIC                 % ENABLE FOR MEMORY OUT OF RANGE
043011             X:=176000; X.S0; *TRA IIC
043014             IF A=0 THEN                                % MEMORY OUT OF RANGE?
043015                *PON                                    % NO, TEST FOR WRAP-AROUND
043016                A:=X.S0=:D:=-1=:X.S0; *POF
043023                X:=0
043024                IF X.S0=124000 THEN                     % TEST IF PHYS.ADDR 0 IS CHANGED
043030                   A:=D; X:=176000; *PON
043033                   A=:X.S0; *TRA IIC
043035                ELSE
043036                   124000=:X.S0; *PON
043041                   CURRPAGE-1=:ENDPAGE
043044                   GO LABL1
043045                FI
043045             FI
043045   NEXT:     CURRPAGE SH 1=:CURRPAGE
043050          OD; *IFILL
043063
043063   *PL003=*
043063
043063   % FIND LAST 32K MEMORY MODULE
043063   INTEGER CCTBSET(0); *BSET ONE DT
043064   LABL1: FOR X:=0 TO 17 DO; 0=:TMMAP(X); OD
043073          A:=0=:LPHYSPAGE
043075   DO1:   DO WHILE A<<=ENDPAGE
043100             CALL PHYSPTEST; GO NOTEXIST; A=:CURRPAGE
043103             IF A/\77=0 THEN
043105                CURRPAGE SHZ -6; AD SHZ -4; A=:X    % X=INDEX IN BIT-MAP ARRAY TMMAP
043111                AD SH 4; A/\17 SHZ 3 +CCTBSET
043115                T:=TMMAP(X); *EXR SA
043117                T=:TMMAP(X)
043120             FI; CURRPAGE+37=:LPHYSPAGE; A+1
043124          OD; GO L1
043126   NOTEXIST: A+40; GO DO1
043130   *)FILL
043135
043135   L1:    LPHYSPAGE=:ENDPAGE
043137          A:="ERTBS"-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
043145          A=:NNRTP                        % NUMBER OF RT-DESCRIPTIONS
043146          A*5XRTDSIZE+"SRTDL"=:ERTDLGADDR % END OF REG-BLOCKS AND REE-BITMAPS
043151          IF C THEN CALL ERRFATAL FI
043154          IF A>>=60000 THEN CALL ERRFATAL FI        % OVERLAP WITH GLOBAL DATA
043160          GO CHHDLC; *)FILL
043170
043170   % CHECK ALL GENERATED HDLC'S
043170   INTEGER CLGTADDR=?,CSVXX=?
043170   CHHDLC:
043170          "0HDTA"=:CSVXX                            % START OF HDLC CONFIG. TABLE
043172   HDLOOP:
043172          IF X:=CSVXX>>="0HDEN" GO FAR FINCHDLC
043176          *1BANK
043177          IF X.NHDLC=0 AND X.SYNHDLC=0 GO FAR NXHDLC % DATAFIELDS DOES NOT EXIST
043204          A=:D:=X.LOGHDLC=:T SHZ -6=:X
043211          A:=T/\77 SH 1; *2BANK
043215          A+CCNVRT(X)+1=:CLGTADDR; *1BANK     % ACTUAL ADDR IN LOG.DEV.NO TABLE
043221          IF CSVXX.HDLCSELECTION=0 GO CLHDLC  % HDLC CANNOT BE USED
043224          IF A>>2 GO CLHDLC                   % ILLEGAL SELECTION
043227          A:=200; *TRR IIE; TRA IIC; 2BANK
043233          T:=D.HDEV+RRTS; *EXR ST; TRA IIC; 1BANK
043241          IF A=0 THEN                         % INTERFACE IS PRESENT
043242             IF CSVXX.HDLCSELECTION=1 THEN    % NORMAL HDLC
043247                IF X.NHDLC=0 GO CLHDLC        % DATAFIELD FOR HDLC DOES NOT EXIST
043251                D:=0; X:=CLGTADDR             % UPDATE LOG.NO TABLE
043253                *POF; STD ,X; PON             % LOGNO.IN=INDF; LOGNO.OUT=0
043256                A:=CSVXX.NOHDLC=:D:=0; X:=CLGTADDR
043263                *POF; STD 2,X; PON            % LOGNO+1.IN=0; LOGNO+1.OUT=OUTDF
043266                A:=CSVXX.NHDLC; T:=X.SYNHDLC
043271                D:=0 BONE BISYMOD
043273             ELSE                             % HDLC SYNC
043274                IF X.SYNHDLC=0 GO CLHDLC      % ILLEGAL SELECTION
043276                X.DSYNHDLC; X:=CLGTADDR
043300                *POF; STD ,X                  % LOGNO.IN=INDF; LOGNO.OUT=OUTDF
043302                *STZ 2,X; STZ 3,X; PON        % LOGNO+1.IN=0; LOGNO+1.OUT=0
043305                A:=CSVXX.SYNHDLC; T:=X.NHDLC
043310                D:=0 BONE BIHDLC
043312             FI; T=:X.CDF1CLTIMER             % T=DF TO REMOVE FROM TIMER
043313             A=:X.INTHDLC                     % VALUE TO INSERT IN IDENT TABLE
043314             X.LOGHDLC\/D=:D+1=:L
043321             X:="IOBUTAB"; *POF
043323             DO WHILE X<<"EIOBUTAB"           % CLEAR ENTRIES IN IOBUTAB
043326                IF X.S0/\77777=D OR A=L THEN 0=:X.S0 FI
043335                X+2
043336             OD; *PON
043340          ELSE                                % DON'T USE THIS HDLC
043341             GO CLHDLC; *)FILL
043353             INTEGER CLGTADDR,CSVXX
043355   CLHDLC:   A:=0; D:=0; X:=CLGTADDR
043360             *POF; STD ,X; STD 2,X            % CLEAR ENTRIES IN LOG.UNIT TABLE
043363             CSVXX.LOGHDLC=:D+1=:L
043370             0=:X.HDLCSELECTION
043371             X:="IOBUTAB"
043372             DO WHILE X<<"EIOBUTAB"
043375                IF X.S0/\7777=D OR A=L THEN
043403                   0=:X.S0                    % REMOVE FROM IOBUTAB
043404                FI; X+2
043405             OD; *PON
043407             0=:CSVXX.INTHDLC                 % A=VALUE TO INSERT IN IDENT TABLE
043411             X.NHDLC=:X.CDF1CLTIMER
043413             X.SYNHDLC=:X.CDF2CLTIMER
043415          FI
043415   NXHDLC: CSVXX+TBLHDLCSIZE=:CSVXX
043420          GO FAR HDLOOP
043421   FINCHDLC: *2BANK
043422          GO CHLPS; *)FILL
043427
043427   *PL004=*
043427
043427   INTEGER CSVXY
043430   CHLPS: "0LPTA"=:CSVXY; *1BANK
043433          DO WHILE CSVXY.LPSELECTION><-1                      % -1: END OF TABLE
043440             IF A=0 OR A>>3 THEN
043444                1=:X.LPCLENTRY; GO NXLPENTRY                  % ILLEGAL SELECTION (OR DON'T USE THIS L-P)
043447             FI; A-1+"LPIODF"; X+A
043452             IF X.LPIODF=0 OR X.XLPDMDF=0 THEN                % DATAFIELD(S) NOT GENERATED
043456                1=:CSVXY.LPCLENTRY; GO NXLPENTRY
043462             FI; *2BANK
043463             T:=A.HDEV+2; A:=200; *TRR IIE; TRA IIC; 1BANK
043472             IF CSVXY.LPSELECTION-2=0 THEN
043476                *EXR ST
043477             ELSE
043500                *IOXT
043501             FI; *TRA IIC
043502             IF A><0 THEN 1=:X.LPCLENTRY FI                   % INTERFACE NOT PRESENT
043505   NXLPENTRY:
043505             IF CSVXY.LPSELECTION><3 OR X.LPCLENTRY><0 THEN
043514                X.LPLOGNO=:D; X:="IOBUTAB"
043517                DO WHILE X<<"EIOBUTAB"
043522                   IF X.S0/\7777=D THEN 0=:X.S0 FI            % REMOVE FROM IOBUTAB
043527                   X+2
043530                OD
043531             FI; CSVXY+LPTBSIZE=:CSVXY
043534          OD; *2BANK
043536          GO TSYMODEM; *)FILL
043545
043545   TSYMODEM:
043545          0=:0CINX; 0=:NPAGES                       % NPAGES=NUMBER OF SYNC.MODEM TO USE
043547          DO
043547             0CINX*TBLSYMSIZE+"0SYMTABLE"=:CSAVX=:X; *1BANK
043555          WHILE X.SYMSELECTION><-1
043561             IF A><0 AND X:=X.SYMIDFELT><0 THEN
043564                A:=200; *TRR IIE; TRA IIC; 2BANK
043570                T:=X.HDEV; *EXR ST; TRA IIC
043573                IF A=0 THEN                         % INTERFACE PRESENT
043574                   MIN NPAGES; X:=CSAVX; *1BANK
043577                   0=:X.SYMCLENTRY; GO NXSYMODEM
043601                FI
043601             FI; *2BANK
043602             X:=CSAVX; *1BANK
043604             X.SYMLOGNO=:D                          % D=LOGICAL DEVICE NUMBER
043606             X:="IOBUTAB"
043607             DO WHILE X<<"EIOBUTAB"
043612                IF X.S0/\7777=D THEN 0=:X.S0 FI     % CLEAR ENTRY IN IOBUTAB
043617                X+2
043620             OD
043621   NXSYMODEM:*2BANK
043622             MIN 0CINX
043623          OD; *2BANK
043625          GO LABL2; *)FILL
043634   *PL005=*
043634
043634   % FIND THE I/O BUFFER AREA
043634   % THE I/O BUFFER AREA WILL BE MAPPED IN RPIT AND MPIT.
043634   LABL2: IF FSDRP(2)>>FSDMP(X) THEN A=:ASCBUF ELSE T=:ASCBUF FI
043644          A:=ASCBUF+1777 SHZ -12 SH 12=:ASCBUF=:CBUF
043652          0=:0CINX; X:=XIOBUTAB
043654          DO
043654             *POF; LDD ,X; PON
043657          WHILE A><-1
043662             IF A><0 AND A><276 THEN                   % SKIP ERROR DEV NO 276
043666                IF A NBIT BIHDLC AND A NBIT BISYMOD THEN
043672                   A:=D/\77777+CBUF
043675                   IF C THEN CALL ERRFATAL FI          % BUFFER AREA CROSS MEMORY BANK
043700                   A=:CBUF
043701                ELSE
043702                   IF A BIT BIHDLC AND A:=D/\77777>=2000 THEN
043711                      *POF; LDD ,X; PON
043714                      T:=0CINX; X:=:T; AD=:ZHDLCSIZE(X)
043717                      X+2=:0CINX:=T
043722                   FI
043722                FI
043722             FI; X+2
043723          OD; A:=-1=:D; AD=:ZHDLCSIZE(0CINX); GO IOBOK; *)FILL
043741
043741   % SET UP THE I/O BUFFERS
043741   IOBOK: A:=CBUF-ASCBUF- SHZ -12 SH 12=:ASCBUF
043747          ASCBUF=:CBUF; XIOBUTAB=:"CINDADDR"
043753          DO
043753             X:="CINDADDR"; *POF; LDD ,X; PON
043757          WHILE A><-1
043762             IF A><0 THEN
043763                AD=:CIOBENTRY
043764                IF A NBIT BIHDLC AND A NBIT BISYMOD THEN
043770                   A/\7777;
043771                   IF A=276 THEN                        % SPECIAL FOR ERS INT.DEV.
043774                      CALL FAR XLOGPH; AD:=CIOBENTRY
043776                   ELSE
043777                      CALL FAR XLOGPH
044000                      CBUF=:X.BUFST; AD:=CIOBENTRY
044003                      A:=D BZERO 17+CBUF=:CBUF
044007                   FI
044007                   IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
044015                   A=:X.MAX=:X.CFREE
044017                FI
044017             FI; "CINDADDR"+2=:"CINDADDR"
044022          OD
044023
044023   % FIND BUFFER FOR SYNC.MODEM AND HDLC
044023          0=:CHDLCF=:BUSYMOD
044025          X:=XIOBUTAB
044026          DO
044026             *POF; LDD ,X; PON
044031          WHILE A><-1
044034             IF A BIT BIHDLC THEN
044036                IF A:=D/\77777<<2000 THEN
044043                   A+CHDLCF=:CHDLCF
044045                   IF C THEN CALL ERRFATAL FI       % BUFFER EXCEED MEMORY BANK
044050                FI; GO NXT
044051             FI
044051             IF A BIT BISYMOD THEN
044053                A:=D/\77777+BUSYMOD=:BUSYMOD
044057                IF C THEN CALL ERRFATAL FI          % BUFFER EXCEED MEMORY BANK
044062             FI
044062   NXT:      X+2
044063          OD
044064   % SET UP BUFFER FOR ERROR-DEVICE (LOG.DEV. 500B)
044064          "99EBU"=:"IERRF".BUFST
044067          IF 2000 < X.MAX THEN
044073             A=:X.MAX=:X.CFREE
044075          FI
044075   % COMPUTE MEMORY ADDRESS LIMITS IN PHYSICAL PAGES
044075          A:=FSDCC(2) SHZ -12=:CMLPHPAGE       % END OF COMMON CODE
044101          0=:CMFPHPAGE                         % START OF COMMON CODE
044102          "PITST" SHZ -12=:RSFPHPAGE           % START OF RESTART ROUTINES & REG.BLOCKS
044105          A:=ERTDLGADDR SHZ -12=:RSLPHPAGE     % END OF START ROUTINES & REG.BLOCKS
044110          DPITBANK SHZ 6+2=:DPIFPHPAGE         % START OF DPIT
044114          A:=FSDDP(2)-"DPSTA"; CALL FPGNO
044120          A+DPIFPHPAGE=:DPILPHPAGE             % END OF DPIT
044122          A:="9ERST"+1777 SHZ -12=:CFPHYSPAGE  % FIRST PHYS.PAGE AVAILABLE FOR BUFFERS
044126          GO OVFI1; *)FILL
044146
044146   *PL006=*
044146
044146   % CHECK IF THE PIOC INTERFACES ARE PRESENT OR NOT
044146   % IF NOT PRESENT THE ENTRY IN THEN LOG.NO TABLE IS CLEARED
044146   % IF PRESENT THEN THE SIZE OF THE PIOC IS UPDATED IN TH ELOCATION PIMPG IN
044146   %      THE DATAFIELD
044146   OVFI1:
044146          0=:CSAVX; A:=200; *TRR IIE; TRA IIC        % ENABLE FOR IOX-ERROR AND CLEAR
044152          DO
044152             AD:=PIOCS(CSAVX)
044154          WHILE A><-1
044157             IF A><0 THEN
044160                AD=:XAD
044161                T:=A.HDEV; T+2; *IOXT                  % READ STATUS
044165                A=:D; *TRA IIC                         % D=STATUS REGISTER
044167                IF A><0 THEN                           % INTERFACE PRESENT?
044170                   A:=XD/\77=:T; A:=XD SHZ -6=:X       % NO, CLEAR TABLE ENTRIES
044176                   X:=CCNVRT(X)+T+T+1
044201                   *POF; LDD ,X; PON                   % FETCH ENTRY IN LOG.NO TABLE
044204                   IF A=XA AND D=T THEN                % MATCH FOUND
044211                      *POF; STZ ,X; STZ 1,X; PON       % CLEAR ENTRY IN LOG.NO. TABLE
044215                   FI
044215                ELSE                                   % INTERFACE IS PRESENT
044216                   IF D BIT 6 THEN                     % 64K PIOC OR "OLD" PIOC
044220                      A:=D SHZ -10 SHZ 6=:D            % D=PHYS PAGE NO OF START OF PIOC MEMORY
044224                      A:=77=:XA.PIMPG
044227                   ELSE
044230                      IF D BIT 10 THEN CALL ERRFATAL FI % ODD BANK NUMBER; NOT LEGAL IN SINTRAN
044233                      A:=D SHZ -10/\375 SHZ 6=:D       % D=FIRST PHYS PAGE
044240                      A:=377=:XA.PIMPG                 % 256K PIOC
044243                   FI; A+D; A:=:D                      % A=FIRST PHYS PAGE; D=LAST PHYS PAGE
044245                   X:=CSAVX; *1BANK; STD I ,X (MMPIO; 2BANK  % SAVE PIOC RESERVED MEMORY
044251                FI
044251             FI; CSAVX+2=:CSAVX
044254          OD; GO XOVF1; *)FILL
044265
044265   XOVF1:
044265   % SET UP RT-COMMON TABLE
044265          IF CCNOX><0 THEN                % NUMBER OF PAGES IN RT-COMMON
044267             IF ACCTAB(0)=0 THEN          % NO ENTRIES IN CCTAB
044272                IF CCSTART=0 THEN         % FIRST PHYS.PAGE OF RT-COMMON NOT SPECIFIED
044274                   LPHYSPAGE; X:=CCNOX; T:=0        % ALLOCATE RT-COMMON FROM TOP OF PHYS.MEM
044277                   CALL YGETAREA; CALL ERRFATAL
044301                   A-CCNOX+1=:CCSTART     % FIRST PHYS.PAGE OF RT-COMMON
044304                FI; A=:D
044305                200-CCNOX+161000; T:=CCNOX; X:=0    % COMPUTE FIRST LOG.PAGE OF RT-COMMON
044312                DO WHILE T><0
044314                   AD=:DCCTAB(X); A+1; D+1; X+2; T-1 % FILL IN LOG.PAGE AND PHYS.PAGE
044321                OD; -1=:ACCTAB(X)                   % -1 IS END OF TABLE
044324             FI
044324          ELSE
044325             IF ACCTAB(0)=0 THEN -1=:ACCTAB(X) FI
044332          FI; GO L2; *)FILL
044341   % TEST IF RT-COMMON PAGES EXIST AND INITIALIZE THE RT-COMMON PAGES
044341   L2:    X:=0
044342        DO WHILE ACCTAB(X)><-1
044346           X+1; ACCTAB(X); CALL PHYSPTEST; CALL ERRFATAL
044352           CALL INITPAGE; X+1
044354        OD
044355
044355   *PL007=*
044355
044355   *"8STRD -8DIMI
"044355        GO FILL1; *)FILL
044361
044361   *PL008=*
044361
044361   % LOCAL SUBROUTINE TO READ FROM DISC / WRITE TO DISC
044361   %
044361   % ENTRY:     A= DISCADDR IN PAGES
044361   %            X= NUMBER OF PAGES
044361   %            T= READ/WRITE FLAG
044361   %            CDDMADDR=MEMORY ADDRESS
044361   %
044361   INTEGER POINTER CTRNSF=?
044361   INTEGER LOOPC=?
044361   CRDISC:
044361          IF A><0 THEN A*CDABLPAGE+XXSWTYPE FI
044364          A=:CDFBLCK
044365          A:=L=:"CLINK"
044367          A:=-6=:LOOPC
044371          A:=DSKTYPE; T+A =: CDTBLCK
044374          A:= X*CDABLPAGE =: CDNBLCK
044377   RTRY:  CDDMADDR=:CSWPDF.CMADR=:X.MEMAD
044403          A := CDFBLCK =: D :=0
044406          T := CDTBLCK  ; X =: L
044410          X := CDNBLCK  ; L =: B
044412   CRLOOP: CALL CTRNSF; GO GVTRY ; GO CRLOOP
044415          "SBFIELD"=:B
044417          *TRR 10
044420          GO CLINK
044421   GVTRY: "SBFIELD" =: B
044423          MIN LOOPC ; GO RTRY ; CALL ERRFATAL
044426
044426   INTEGER LOOPC             % COUNTER USED WHEN ERROR FROM THE DRIVER
044427
044427   % LOCAL SUBROUTINE TO COPY FROM THE SAVE-AREA TO IMAGE/SEGMENTS
044427   % ENTRY: T=DISC ADDR, IN PAGES, READ FROM
044427   %        X=NUMBER OF PAGES TO MOVE
044427   %        A=DISC ADDR, IN PAGES, TO WRITE TO
044427   %        CDDMADDR=MEMORY ADDRESS
044427   %        CDABLPAGE=NUMBER OF SECTORS PER TRACK
044427   %
044427   % EXIT: OK
044427   % CALL ERRFATAL IF ERROR OCCURS.
044427   %
044427   CRWDISC: A*CDABLPAGE+XXSWTYPE=:CDTBLCK
044432          A:=T*CDABLPAGE+XXSWTYPE=:CDFBLCK
044436          A:=X*CDABLPAGE=:CDNBLCK
044441          A:=L=:"CLINK"
044443          A:=-6=:LOOPC
044445   TRYR:  CDDMADR=:CSWPDF.MEMAD=:X.CMADR
044451          X:=CDNBLCK; A:=CDFBLCK=:D:=CSWPDF
044455          T:=DSKTYPE; A=:B:=0
044460   RLOOP: CALL CTRNSF; GO RDISK ; GO RLOOP
044463          A:=-6=:LOOPC
044465   TRYW:  "SBFIELD".CDDMADR=:MEMAD=:CMADR
044471          T:=DSKTYPE BONE "0"
044473          A:=X.CDTBLCK=:D:=0; X:=X.CDNBLCK
044477   WLOOP: CALL CTRNSF; GO WDISK ; GO WLOOP
044502          "SBFIELD"=:B
044504          *TRR 10
044505          GO CLINK
044506   RDISK: "SBFIELD" =: B
044510          MIN LOOPC ; GO TRYR ; CALL ERRFATAL
044513   WDISK: MIN LOOPC ; GO TRYW ; CALL ERRFATAL
044516   *)FILL
044523   INTEGER LDTA                       % ADDRESS IN DISK DESCRIPTION TABLE
044524   INTEGER POINTER CTRNSF
044525
044525   *PL009=*
044525
044525   FILL1:
044525
044525   % FIND SWAP-DEVICE
044525          IF SWTYP<<7 OR>>36 THEN CALL ERRFATAL FI  % ILLEGAL MAIN-SWAP-DEVICE TYPE
044535          IF A=7 THEN                               % MAIN SWAP-DEVICE IS FIXED PHOENIX DISK
044540             20=:SWTYP; 40000=:DSKTYPE; 100000=:XXSWTYPE
044546          ELSE
044547             0=:XXSWTYPE=:DSKTYPE
044551          FI;                          *1BANK
044552          X:= MDISCS(SWTYPE)=:LDTA                 % ADDR OF DISC-ATTRIBUTES
044555          X.SWDLOGNO;                  *2BANK
044557          CALL FAR CLOGPH; A:=X;       *1BANK
044562          T:=LDTA.SWDDFILD;            *2BANK
044565          IF A=0 OR A >< T THEN CALL ERRFATAL FI % ILLEGAL LOGICAL DEV.NO.
044571          A=:CSWPDF=:X
044573          IF XXSWTYPE><0 THEN
044575             X.M2UNTYPE BONE "0"=:X.M2UNTYPE           % MARK FIXED PHOENIX
044600          FI; *1BANK
044601          LDTA.SWDDRIVER=:"CTRNSF"                     % DISC-DRIVER ADDR
044604          A:=X.SWDSWDRIV; *2BANK
044606          A=:SWPDRIVER;   *1BANK                       % ADDR OF SWAP-DRIVER
044610          A:=X.SWDLOGNO;  *2BANK
044612          A=:MASSNO(0)                                 % LOGICAL DEV.NO. OF MAIN-SWAP-DEVICE
044614
044614          X:=DISPE(SWTYP); T:=X.S0; A:=2000=:D:=0; *RDIV ST   % SECTORS/TRACK
044623          IF D><0 THEN CALL ERRFATAL FI
044626          A=:ABLPAGE(0)=:CDABLPAGE
044631          A*200+XXSWTYPE=:BLST(1)                   % SET START OF SEGFIL0 IN SECTORS.
044635          CSWPDF=:B
044637          DISPE(SWTYP)=:HTABL(0)                    % INITIAL DISC-LAYOUT TABLE
044643          MASSNO(0)=:MASSNO(4)                      % INITIALIZE "SEGMENT FILE" #4.
044647          MASSUNIT(0)=:MASSUNIT(4)
044653          ABLPAGE(0)=:ABLPAGE(4)+"SBFIELD".XXSWTYPE=:BLST(11) % SIZF IS PREDEFINED (177)
044663
044663   % FIND SWAP-DEVICE DISC LAYOUT
044663
044663          IF "CTRNSF"="BDISK" OR ="SCSWD" THEN
044672             T:=42; X:=1; A:=0=:D         % READ FORMAT NECESSARY
044676   DIBUS:    CALL CTRNSF; CALL ERRFATAL; GO DIBUS
044701          FI
044701          X:=HTABL(0); "SBFIELD"=:B
044705          X=:CDIFELEMENT                  % DISC LAYOUT ELEMENT ADDRESS
044706          GO FILL2; *)FILL
044730   *PL010=*
044730
044730   FILL2:
044730   % FIND MEMORY AREA TO USE IN DISC TRANSFERS
044730          IF HENTFLAG=0 THEN X:=70 ELSE X:=1 FI
044735          A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
044741          A=:D:=0; AD SH 12=:CDDMADR                % MEMORY ADDR FOR DISC TRANSFERS
044745          SEGFSTART=:CBLST                          % START OF SEGFILE 0
044747   *IFILL
044754          IF HENTFLAG><0 GO FAR OVCO
044757   % COPY FROM SAVE TO IMAGE
044757             X:=CBLST; T:="MSECO"+X; A:="MIECO"+X
044764             X:="LSECO"; CALL FAR CRWDISC           % COPY EXT. COMMON
044766             X:=CBLST; T:="MSDPT"+X; A:="MIDPT"+X
044773             X:="LSDPT"; CALL FAR CRWDISC           % COPY DPIT
044775             X:=CBLST; T:="MSRPT"+X; A:="MIRPT"+X
045002             X:="LSRPT"; CALL FAR CRWDISC           % COPY RPIT
045004             X:=CBLST; T:="MSMPT"+X; A:="MIMPT"+X
045011             X:="LSMPT"; CALL FAR CRWDISC           % COPY MPIT
045013             X:=CBLST; T:="MSIPT"+X; A:="MIIPT"+X
045020             X:="LSIPT"; CALL FAR CRWDISC           % COPY IPIT
045022             X:=CBLST; T:="MSSGT"+X; A:="MISGT"+X
045027             X:="LSSGT"; CALL FAR CRWDISC           % COPY SEGMENT TABLE
045031             X:=CBLST; T:="MFILS"+X; A:="MIFIL"+X
045036             X:="LFILS"; CALL FAR CRWDISC           % COPY FILE SYSTEM
045040             X:=CBLST; T:="MRTLO"; A:="S04MA"+X
045044             X:=20; CALL FAR CRWDISC                % COPY RT-LOADER PROGRAM SEGMENT
045046   *IFILL
045101             X:=CBLST; T:="MRTLO"+20; A:="S37MA"+X
045106             X:=16; CALL FAR CRWDISC                % COPY RT-LOADER DATA SEGMENT
045110             X:=CBLST; T:="MERRP"; A:="S14MA"+X
045114             X:="LERRP"; CALL FAR CRWDISC           % COPY ERROR PROGRAM
045116             X:=CBLST; T:="MSCOM"+X; A:="S41MA"+X
045123             X:=1; CALL FAR CRWDISC                 % COPY "EDIT-ROUTINE" SEGMENT
045125             X:=CBLST; T:="MSCOM"+1+X; A:="MICOM"+X
045133             X:="LOPCO"-1; CALL FAR CRWDISC         % COPY COMMAND SEGMENT
045136             X:=CBLST; T:="MSSMS"+X; A:="MISMS"+X
045143             X:="LSSMS"; CALL FAR CRWDISC           % COPY SM SEGMENT
045145             X:=CBLST; T:="MSSYS"+X; A:="S05MA"+X
045152             X:="5ESSZ"; CALL FAR CRWDISC           % COPY SEGMENT 5 (INCLUDING RT'S SYS.SEGM)
045154             X:=CBLST; T:="MSSYS"+X; A:="MISYS"+X
045161             X:="LSSYS"; CALL FAR CRWDISC           % COPY FIRST PART OF SYSTEM SEGMENT
045163   *IFILL
045206             X:=CBLST; T:="MS5PT"+X; A:="MI5PT"+X
045213             X:="LS5PT"; CALL FAR CRWDISC           % COPY 5PIT SEGMENT
045215             X:=CBLST; T:="MSXMK"+X; A:="MIXMK"+X
045222             X:="LSXMK"; CALL FAR CRWDISC           % COPY XMSG KERNEL
045224             X:=CBLST; T:="MSXRO"+X; A:="MIXRO"+X
045231             X:="LSXRO"; CALL FAR CRWDISC           % COPY XMSG XROUT
045233             X:=CBLST; T:="MSNMT"+X; A:="MINMT"+X
045240             X:="LSNMT"; CALL FAR CRWDISC           % COPY DEVICE NAME TABLE
045242             X:=CBLST; T:="MSFID"+X; A:="MIFID"+X
045247             X:="LSFID"; CALL FAR CRWDISC           % COPY XMSG WATCHDOG (XMFIDO)
045251             X:=CBLST; T:="MSNKS"+X; A:="MINKS"+X
045256             X:="LSNKS"; CALL FAR CRWDISC           % COPY NK-SERV
045260             X:=CBLST; T:="MSNKN"+X; A:="MINKN"+X
045265             X:="LSNKN"; CALL FAR CRWDISC           % COPY NK-NAME
045267             X:=CBLST; T:="MSERC"+X; A:="MIERC"+X
045274             X:="LSERC"; CALL FAR CRWDISC           % COPY ERSWD CODE
045276             X:=CBLST; T:="MSERD"+X; A:="MIERD"+X
045303             X:="LSERD"; CALL FAR CRWDISC           % COPY ERSWD DATA
045305   *IFILL
045342             X:=CBLST; T:="MSUC1"+X; A:="MIUC1"+X
045347             X:="LSUC1"; CALL FAR CRWDISC           % COPY 110 MICRO CODE
045351             X:=CBLST; T:="MSUC2"+X; A:="MIUC2"+X
045356             X:="LSUC2"; CALL FAR CRWDISC           % COPY 120 MICRO CODE
045360             X:=CBLST; T:="MSPRM"+X; A:="MIPRM"+X
045365             X:="LSPRM"; CALL FAR CRWDISC           % COPY PROCESSOR MANAGER SERVER
045367             X:=CBLST; T:="MSEMG"+X; A:="MIEMG"+X
045374             X:="LSEMG"; CALL FAR CRWDISC           % COPY EVENT MESSAGE SERVER
045376             X:=CBLST; T:="MSBOP"+X; A:="MIBOP"+X
045403             X:="LSBOP"; CALL FAR CRWDISC           % COPY BOPCOM SERVER
045405             X:=CBLST; T:="MSMTS"+X; A:="MIMTS"+X
045412             X:="LSMTS"; CALL FAR CRWDISC           % COPY MTSERV
045414             X:=CBLST; T:="MSDMW"+X; A:="MIDMW"+X
045421             X:="LDDMW"; CALL FAR CRWDISC           % COPY DIMWD
045423   *PL011=*
045423   *"8N500
"045423             X:=CBLST; T:="MN5MO"+X; A:="MI5MO"+X
045430             X:="LN5MO"; CALL FAR CRWDISC           % COPY ND-500 SYSTEM MONITOR
045432   *"
"045432   OVCO:
045432   *IFILL
045464   % SET UP DISC LAYOUT TABLE FOR THE "SWAP-DRIVER"
045464          CDIFELEMENT=:D; 11=:L; "DFELT"+"DED01"=:T; *MOVAN
045474          "DFELT"+"HTABL"=:X; A:="DFELT"+"DED01";
045501          *1BANK; STA ,X; 2BANK                         % ADDR OF DISC-LAYOUT TABLE
045504   %INITIALIZE THE DATAFIELD FOR THE "SWAP-DRIVER"
045504          CDABLPAGE*77; *1BANK; STA I (NOBLK; 2BANK
045511          CSWPDF.HDEV; *1BANK; STA I (KLHDE; 2BANK
045516          A+"IOX+4"; *1BANK; STA I (KLIOX; 2BANK
045522          DBLST(0); *1BANK; STD I (DYBLS; 2BANK
045527          DSKTYP; *1BANK; STA I (XSWTP; 2BANK
045533          A:=-4; *1BANK; STA I (KLRC1; 2BANK
045537          SWPDRIVER; *1BANK; STA I (LDRAD; 2BANK
045543          A+SWDSIZE; *1BANK; STA I (ADR2B; 2BANK
045547          IF SWPDRIVER="ZBDIS" THEN A:=1               % SYSTEM DISC IS A "BIG-DISC"
045554          ELSE IF A="ZWDIS" THEN A:=2                  % SYSTEM DISC IS A "WINCHESTER" DISC
045561          ELSE IF A="SCSWD" THEN
045565             CSWPDF.BLSZ; *1BANK; STA I (KBLSZ
045571             *STZ I (KLIOX; 2BANK
045573             A:=3
045574          ELSE A:=0
045576          FI; FI; FI; *1BANK; STA I (YSWTY; 2BANK
045601
045601   % READ PAGE #0 AND INSERT BOOTS-STRAP AND "SWAP-DRIVER", AND
045601   % THEN WRITE THE PAGE BACK
045601          A:=0; X:=1; T:=0; CALL FAR CRDISC
045605   % MOVE BOOTS-STRAP INTO "PAGE #0"
045605          A:="LDEND"-"RELOA"=:L; A:="RELOA"=:D
045612          X:=1CDDMADR; T:=2CDDMADR; *MOVNP
045615   % MOVE SWAP-DRIVER TO "PAGE #0"
045615          SWDSIZE=:L; A:=SWPDRIVER=:D; *MOVNP
045622   % WRITE PAGE #0 BACK TO DISC
045622          A:=0; X:=1; T:=1; CALL FAR CRDISC
045626          GO OVFI3; *)FILL
045657   *PL012=*
045657   % COMPUTE SIZE OF MEMORY MAP, FIND CONTINUOUS MEMORY FOR THE MEMORY MAP
045657   % AND SET UP MEMORY MAP FOR ALL PAGES (0 - LPHYSPAGE)
045657   % THE PHYSICAL PAGE NUMBER IS INDEX IN THE MEMORY MAP
045657   INTEGER CCCPG
045660   OVFI3:
045660          IF LPHYSPAGE><37777 THEN A SH 2; CALL FPGNO; A+D ELSE A:=100 FI
045671          A=:MMSIZE; 100=:CCCPG
045674          DO WHILE CCCPG<<LPHYSPAGE
045700             X:=MMSIZE; T:=A+X-1
045704             CALL GETAREA; GO TRNX1; GO MMFOUND
045707   TRNX1:    CCCPG+100=:CCCPG
045712          OD; CALL ERRFATAL; *)FILL                 % NO MEMORY FOUND FOR MEMORY MAP
045720   MMFOUND:
045720          A=:MMFPAGE+MMSIZE-1=:MMLPAGE
045724          A:=MMFPAGE=:D:=0; AD SH 12; A=:CORMBANK:=D=:CORMSTART
045733
045733   % COMPUTE SIZE OF THE LOGICAL NUMBER TABLES, AND RESERVE MEMORY
045733   % FOR THESE TABLES
045733          A:="EN999"-"DV000"; CALL FPGNO; A+D=:MMSIZE
045740          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
045745          A=:LGTFPHPAGE+MMSIZE-1=:LGTLPHPAGE
045751          A:=LGTFPHPAGE=:D:=0; AD SH 12; A=:LOGDBANK
045756          A:=D=:CNVRT(0); CCNVRT(2)-CCNVRT(0)+D=:CNVRT(2); X=:0CINX
045771          DO WHILE X><LGDGMAX
045774             X+1; IF CCNVRT(X) >< 0 THEN
045777               X=:D; A-CCNVRT(0CINX)+CNVRT(X)
046003               A=:CNVRT(D); X=:0CINX
046006             FI
046006          OD
046007   % MOVE THE LOGICAL NUMBER TABLES
046007          "DV000"=:D; X:=LOGDBANK; T:=LGTFPHPAGE SH 12
046014          DO WHILE MMSIZE><0
046016             A:=2000=:L; *MOVNP
046021             MMSIZE-1=:MMSIZE
046024          OD; GO OVFI4; *)FILL
046040
046040   OVFI4:
046040
046040   % COMPUTE SIZE OF EXT. COMMON AND ALLOCATE AREA
046040          FSDEC(2)-"PITST"; CALL FPGNO; A+D=:MMSIZE
046046          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046053          A=:ECOFPHPAGE+MMSIZE-1=:ECOLPHPAGE
046057
046057   % COMPUTE SIZE OF RPIT AND ALLOCATE AREA
046057          FSDRP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046065          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046072          A=:RPIFPHPAGE=:RPTPHPAGE+MMSIZE-1=:RPILPHPAGE
046077          RPIFPHPAGE SHZ -6=:RPIBANK
046102
046102   % COMPUTE SIZE OF MPIT
046102          FSDMP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046110          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046115          A=:MPIFPHPAGE=:MPTPHPAGE+MMSIZE-1=:MPILPHPAGE
046122          A:=MPIFPHPAGE SHZ -6=:MPIBANK
046125
046125   % COMPUTE SIZE OF IPIT
046125          FSDIP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046133          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046140          A=:IPIFPHPAGE=:IPTPHPAGE+MMSIZE-1=:IPILPHPAGE
046145          A:=IPIFPHPAGE SHZ -6=:IPIBANK
046150
046150   % ALLOCATE MEMORY FOR SEGMENT 42
046150          A:=100; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
046155          A=:EDFPHPAGE=:EDLPHPAGE
046157
046157   % ALLOCATE MEMORY FOR THE I/O BUFFERS
046157          A:=ASCBUF SHZ -12; X:=100-A=:MMSIZE
046164          X:=MMSIZE; A:=CFPHYSPAGE; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046171          A=:IOBFPHPAGE+MMSIZE-1=:IOBLPHPAGE
046175
046175   % ALLOCATE MEMORY FOR RT'S SYSTEM SEGMENT
046175          A:=SISYSEG-"5ESSZ"=:MMSIZE=:X
046201          A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046205          A=:RTSGFPHPAGE+MMSIZE-1=:RTSGLPHPAGE
046211
046211   *"8FLMN
"046211
046211   *PL013=*
046211
046211   *"8N500
"046211          A:=100; T:=LPHYSPAGE; X:="LS5PT"; CALL GETAREA; CALL ERRFATAL
046216          A=:5PIFPHPAGE+"LS5PT"-1=:5PILPHPAGE
046222   *"
"046222          GO OVFI5; *)FILL
046242   OVFI5:
046242   % COMPUTE THE NUMBER OF DEVICE-BUFFERS TO USE IN THIS SYSTEM
046242          A:=ENDBU-"DEVBU"=:D:=0; T:=DBLEN; *RDIV ST
046250          IF A<<MXDVBUFS THEN A=:MXDVBUFS FI
046254          MXDVBUFS*DBLEN+"DEVBU"=:ENDBU             % UPDATE END OF DEVICE-BUFFER HEADERS
046260   % FIND CONTIGUOUS AREA FOR THE DEVICE-BUFFERS
046260   % AND INITIALIZE THESE PAGES
046260          A:=DVBFPAGE; X:=MXDVBUFS; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046265          A=:DBFPAGE/\77 SH 12=:BUFASTART=:SBUF     % START ADDRESS OF BUFFER AREA WITHIN BUFBANK
046272          A:=DBFPAGE SHZ -6=:BUFBANK=:SBANK         % MEMORY BANK IN WHICH THE BUFFERS LIE
046276          DBFPAGE+MXDVBUFS-1=:DBLPAGE
046302          FOR A:=DBFPAGE TO DBLPAGE DO CALL INITPAGE; OD
046311          GO INZSPRTAD; *)FILL
046327
046327   *PL014=*
046327
046327   INZSPRTAD:
046327
046327   % COMPUTE AND SET-UP THE ADDR OF "SPARE-TRACK-TRANSFER-BUFFER" IN THE DATAFIELD
046327   % FOR ALL "BIG-DISCS" AND WINCHESTER DISCS.
046327           IF DVBFPAGE><0 THEN
046331              T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL    % RESERVE 1 PAGE FOR "SPARE-TRACK-ADDR-BUFFER"
046335              A=:SPTRFPHPAGE=:SPTRLPHPAGE
046337              0=:0CINX
046340              FOR X:=0 TO 3 DO
046344                 IF BIGDDFS(X)><0 THEN                  % FOR ALL BIG-DISCS DO
046346                    X=:L:=A; A:=SPTRFPHPAGE=:D:=0; AD SH 12; A:=:D+0CINX
046356                    A:=:D; AD=:X.DNWLBB
046360                    0CINX+2=:0CINX; X:=L
046364                 FI
046364              OD
046366              FOR X:=0 TO 1 DO
046372                 IF WDIDFS(X)><0 THEN                   % FOR ALL WINCHESTER DISCS DO
046374                    X=:L:=A; A:=SPTRFPHPAGE=:D:=0; AD SH 12; A:=:D+0CINX
046404                    A:=:D; AD=:X.DWNLBA
046406                    0CINX+2=:0CINX; X:=L
046412                 FI
046412              OD
046414           ELSE                                         % "SPARE-TRACK-ADDR-BUFFER" IS IN DATAFIELD
046415              FOR X:=0 TO 3 DO                          % FOR ALL BIG-DISCS DO
046421                 IF BIGDDFS(X)><0 THEN
046423                    X=:L:=A; A+"NWLBB"-4=:D:=DPITBANK; AD=:X.DNWLBB
046432                    X:=L
046433                 FI
046433              OD
046435              FOR X:=0 TO 1 DO                          % FOR ALL WINCHESTER DISCS DO
046441                 IF WDIDFS(X)><0 THEN
046443                    X=:L:=A; A+"ALTPO"=:D:=DPITBANK; AD=:X.DWNLBA
046451                    X:=L
046452                 FI
046452              OD
046454           FI; GO INZMENT; *)FILL
046462
046462   *PL015=*
046462
046462   INZMENT:
046462
046462   % INITIALIZE THE VARIABLES FOR MON ENTSG.
046462
046462          0=:ESBANK                            % MEMORY BANK OF "ESARRAY"
046463          "ESARRAY"=:ESDATA                    % DISPLACEMENT WITHIN BANK OF ESDATA.
046465          "ESEARRAY"=:ESEDATA                  % DISPLACEMENT WITHIN BANK OF ESEDATA.
046467          0=:ESCNT                             % CLEAR NUMBER OF ENTERED SEGMENTS.
046470
046470   % RESERVE MEMORY FOR MICRO CODE
046470          IF UCLOAD >< 0 THEN
046472             A:=100; T:=LPHYSPAGE;X:="LSUC1"
046475             CALL 1BAREA; CALL ERRFATAL; AD=:UCPAG
046500          FI
046500
046500   % RESERVE MEMORY FOR THE LAMU SYSTEM AND CLEAR THE LAMU TABLES
046500   *IFILL
046513          IF GNLAMU><0 OR GNSYL >< 0 THEN
046517             GNSYL*SDTSZ=:CLAMSIZE             % SIZE OF LAMU DESCRIPTOR (SYLDT)
046522             GNLAMU*LDTSZ+CLAMSIZE=:CLAMSIZE   % ADD SIZE OF LAMU DESCRIPTOR (LAMDT)
046526             "NXRTP"*GNLPRT*ALMSZ              % SIZE OF ACTIVE LAMU TABLE (LAMACT)
046531             A+NINSZ                           % SIZE OF LAMU AREA MON 61 INDEX (LAMAI)
046532             A+"NXRTP"                         % SIZE OF LAMU INHIBIT TABLE
046533             A+CLAMSIZE; CALL FPGNO; A+D=:NPLAMU; IF A > 100 THEN CALL ERRFATAL FI
046543             A:=100; T:=LPHYSPAGE; X:=NPLAMU; CALL GETAREA; CALL ERRFATAL
046550             A=:D=:FLAMPAGE+NPLAMU-1=:LLAMPAGE:=0; AD SHZ 12
046557             A=:LAMBANK; A:=D=:SYLDT         % SYLDT  START
046562             GNSYL*SDTSZ+D=:LAMDT            % LAMDT  START
046566             A:=D+CLAMSIZE=:LAMACT=:D        % LAMACT START
046572             "NXRTP"*GNLPRT*ALMSZ+D=:LAMAI   % LAMAI  START
046577             A+NINSZ=:LAMIH                  % LAMIH  START
046601             A:=FLAMPAGE; T:=NPLAMU+A
046604             DO WHILE A><T; CALL ZEROPAGE; A+1; OD
046611             GO AFLAM; *)FILL
046633          FI
046633
046633   *PL016=*
046633
046633   AFLAM:
046633   *"8MCLG
"046633   % RESERVE MEMORY FOR THE MONITOR-CALL-LOG TABLE
046633          IF "MCLGPAGE"><0 THEN
046635             A:=0; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
046642             A=:MCLGPAGE=:CMCLFPHPAGE=:CMCLLPHPAGE
046645             A=:D:=0; AD SHZ 12; A=:MCLGBANK:=D=:TNMCALL
046653          FI
046653   *"
"046653   % RESERVE MEMORY FOR THE SYNC.MODEM BUFFERS.
046653
046653          IF BUSYMOD><0 THEN
046655             CALL FPGNO; A+D=:X=:SYMLPHPAGE
046661             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046665             A=:SYMFPHPAGE-1+SYMLPHPAGE=:SYMLPHPAGE
046671             A:=SYMFPHPAGE=:D:=0; AD SHZ 12; A=:MBSYMOD:=D=:CBUF
046700             XIOBUTAB=:"CINDADDR"
046702   % INITIALIZE THE SYNC.MODEM DATAFIELDS WITH
046702   % BUFFER START ADDR, MAX AND CFREE
046702             DO
046702                X:="CINDADDR"; *POF; LDD ,X; PON
046706             WHILE A><-1
046711                IF A BIT BISYMOD THEN
046713                   AD=:CIOBENTRY
046714                   A/\7777; CALL FAR XLOGPH
046716                   CBUF=:X.BUFST
046720                   AD:=CIOBENTRY
046721                   IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
046727                   A=:X.MAX=:X.CFREE
046731                   A:=D BZERO 17+CBUF=:CBUF
046735                FI; "CINDADDR"+2=:"CINDADDR"
046740             OD
046741          FI; GO BYPFILL; *)FILL
046753
046753   BYPFILL:
046753   *PL017=*
046753
046753   % RESERVE MEMORY FOR THE HDLC BUFFERS.
046753          IF CHDLCF><0 THEN
046755             CALL FPGNO; A+D=:X=:HDLCLPHPAGE
046761             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046765             A=:HDLCFPHPAGE-1+HDLCLPHPAGE=:HDLCLPHPAGE
046771             A:=HDLCFPHPAGE=:D:=0; AD SHZ 12; A=:CHDLCF:=D=:CBUF
047000   % INITIALIZE THE HDLC DATAFIELDS
047000             XIOBUTAB=:"CINDADDR"
047002             DO
047002                X:="CINDADDR"; *POF; LDD ,X; PON
047006             WHILE A><-1
047011                IF A BIT BIHDLC THEN
047013                   AD=:CIOBENTRY
047014                   IF A:=D/\77777<<2000 THEN
047021                      A:=C1IOBENTRY/\7777; CALL FAR XLOGPH
047024                      CBUF=:X.BUFST
047026                      AD:=CIOBENTRY
047027                      IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
047035                      A=:X.MAX=:X.CFREE; CHDLCF=:X.MASTB
047041                      A:=D BZERO 17+CBUF=:CBUF
047045                   FI
047045                FI; "CINDADDR"+2=:"CINDADDR"
047050             OD; GO OVFILL; *)FILL
047061          FI
047061   OVFILL:
047061
047061   % COMPUTE SIZE OF THE SEGMENT TABLE, AND ALLOCATE MEMORY
047061   % FOR THE SEGMENT TABLE
047061           "9ESGT"-"XSEGS"; CALL FPGNO; A+D=:NPSGTAB
047066           X:=NPSGTAB; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
047073           A=:SGTFPHPAGE+NPSGTAB-1=:SGTLPHPAGE
047077           A:=SGTFPHPAGE=:D:=0; AD SH 12
047103           A=:SEGTBANK:=D=:SEGSTART+5SEGSIZE=:XSGRT
047110   % READ IN THE SEGMENT TABLE FROM IMAGE
047110          A:=SGTFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047115          A:="MISGT"+CBLST; X:=NPSGTAB; T:=0; CALL FAR CRDISC
047122          GO L3; *)FILL
047135
047135   *PL018=*
047135   % RESERVE MEMORY FOR ERROR DEVICE BUFFER (LOG.NO 276B)
047135   L3:    IF "ERSIN".MAX SHZ -1><0 THEN
047141             CALL FPGNO; A+D=:X=:IERLPHPAGE
047145             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
047151             A=:IERFPHPAGE-1+IERLPHPAGE=:IERLPHPAGE
047155             A:=IERFPHPAGE=:D:=0; AD SHZ 12; A=:MBIERBUFF
047162             A:=D=:"ERSIN".BUFST
047165          FI
047165          0=:CURRPAGE; X:=CORMSTART
047167          FOR CURRPAGE DO WHILE CURRPAGE<<=LPHYSPAGE
047173             T:=CORMBANK; A:=X-4=:D+10; *PAGLI@3 STDTX
047201             A:=0; D:=0; *PROTE@3 STDTX
047204             X+4
047205          OD; X-4=:ECORMAP; T:=CORMBANK; *PAGLI@3 STZTX
047213          X:=CORMSTART+4; A:=7; *PREVI@3 STATX
047217          A:=X; X:=XSGRT; T:=SEGTBANK; *BPAGL@3 STATX
047223          X:=CORMSTART; T:=CORMBANK; A:=0 BONE 5CMINHB
047227          *PROTE@3 STATX; PAGLI@3 STZTX
047231          GO OVFI6; *)FILL
047244   OVFI6:
047244   % INITIALISE THE SEGMENT LINK
047244          T:=SEGTBANK; X:=XSGRT=:A
047247          *SEGLI@3 STATX; PRESE@3 STATX
047251          X=:BSEGLINK
047252
047252   % READ IN THE EXT. COMMON
047252          A:=ECOFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047257          A:=ECOLPHPAGE-ECOFPHPAGE+1=:X; A:="MIECO"+CBLST; T:=0; CALL FAR CRDISC
047267   % READ IN THE RPIT
047267          A:=RPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047274          A:=RPILPHPAGE-RPIFPHPAGE+1=:X; A:="MIRPT"+CBLST; T:=0; CALL FAR CRDISC
047304          GO BYP1; *)FILL
047313   % READ IN MPIT
047313   BYP1:  A:=MPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047320          A:=MPILPHPAGE-MPIFPHPAGE+1=:X; A:="MIMPT"+CBLST; T:=0;  CALL FAR CRDISC
047330   % READ IN IPIT
047330          A:=IPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047335          A:=IPILPHPAGE-IPIFPHPAGE+1=:X; A:="MIIPT"+CBLST; T:=0;  CALL FAR CRDISC
047345   % READ IN SEGMENT 42
047345          A:=EDFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047352          X:=1; A:="S41MA"+CBLST; T:=0; CALL FAR CRDISC
047357   % READ IN RT'S SYSTEM SEGMENT AND CLEAR THE BUFFER-POOL
047357          A:=RTSGFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047364          A:=SISYSEG-"5ESSZ"=:X; A:="MISYS"+"5ESSZ"+CBLST
047372          T:=0; CALL FAR CRDISC
047374          T:="DV100"+1; A:="5ESSZ" SH 12 + "BGSYS"; T-A         % CLEAR SEGM FROM DV100+1 TO END OF SEGM
047402          A:=RTSGFPHPAGE SH 12+T=:X; T:=RTSGFPHPAGE SHZ -6      % TX=PHYS.ADDR OF DV100+1
047410          A:=RTSGLPHPAGE SH 12-1=:D                             % D= END OF SEGMENT
047414          DO
047414             *STZTX
047415          WHILE X><D
047417             X+1
047420          OD
047421   *PL019=*
047421   *IFILL
047433
047433
047433   *"8N500
"047433   % READ IN 5PIT SEGMENT
047433          A:=5PIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047440          X:="LS5PT"; A:="MI5PT"+CBLST; T:=0; CALL FAR CRDISC
047445
047445   *"8FLMN
"047445         IF UCLOAD >< 0 THEN          % READ IN MICRO CODE
047447           A:=UCFPA=:D:=0; AD SH 12=:CDDMADDR
047454           IF HWINFI(0) /\ 377 = 3 OR A= 11 OR A = 12 THEN    % ND 110
047470             X:="LSUC1"; A:="MIUC1"
047472           ELSE IF A = 4 OR A = 10 THEN                       % ND 120
047501             X:="LSUC2"; A:="MIUC2"
047503           ELSE
047504             0=:UCLOAD; GO NOUC
047506           FI FI
047506           A+CBLST; T:=0; CALL FAR CRDISC
047511         FI
047511   *IFILL
047524   NOUC:
047524          A:=RPIFPHPAGE; T:=MPIFPHPAGE
047526          CALL XCHIOX           % FIND OUT HOW MANY TERM.INTERFACES THERE ARE
047527                                % IN THIS SYSTEM, AND CHECK THE IDENT CODE OF
047527                                % THE EXISTING TERM.INTERFACES
047527
047527   *"-8BACS
"047527   *PL020=*
047527
047527   % COMPUTE REQUIRED SPACE FOR THE TERMINAL DATAFIELDS OUTSIDE RESIDENT
047527   % INITIALISE THESE PAGES
047527
047527          X:="TIOBU"; L:=0; *1BANK
047532          DO WHILE X.S0><-1
047536             IF A><0 THEN
047537                AD:=X.DOU1
047540                A+D+TDISIZ+TDOSIZ; DO A-400; L+1 WHILE A>0 OD
047550             FI; X+3
047551          OD; *2BANK
047553          A:=L*400; CALL FPGNO; A+D=:X=:TDLPHPAGE
047561          IF X >> 200 THEN CALL ERRFATAL FI    % MAX 200 PAGES FOR BIG TERM DF
047565          A:=100; T:=LPHYSPAGE; CALL ZGETAREA; CALL ERRFATAL
047571          A=:TDFPAGE SHZ -6=:TDFBANK; TDFPAGE-1+TDLPHPAGE=:TDLPHPAGE
047600          GO OVFI8; *)FILL
047611
047611   % LOCAL SUBROUTINE TO REMOVE A TAD DF. FROM THE TIMER TABLE
047611   ZTMRTENTRY: T:=L=:"CLINK"
047613          AD=:DCDFADR; X=:0CINX
047615          X:=TMRADDR
047616          DO WHILE X<<ETMRADDR
047621             T:=RPIBANK; *LDATX
047623             IF A=C1DFADDR OR A=C2DFADDR THEN
047631                T:=RPIBANK; *STZTX
047633             FI; X+1
047634          OD; A:=C1DFADDR; CALL CLBCKTABENTRY
047637          X:=0CINX; GO CLINK
047641   *)FILL
047642
047642   OVFI8:
047642   % FIND NUMBER OF TAD'S IN THIS SYSTEM
047642          A:=CNVRT(15)=:AD1500
047645          A:="9EBAD"-"DV000"; T:=LGTFPHPAGE SH 12+A=:AETADS
047653          X:=CNVRT(14)+1; 0=:NTADS
047657          DO                                        % SEARCH IN LOG.DEV TABLES
047657             IF X=AD1500 THEN X+1 FI
047663          WHILE AETADS>>X AND NTADS<<MXTADS
047672             T:=LOGDBANK; *LDDTX
047674             IF A><0 OR D><0 THEN MIN NTADS FI
047700             X+2
047701          OD
047702   % IF MAX NUMBER OF TADS TO USE, IS LESS THAN THE NUBER OF TADS GENERATED
047702   % IN THIS SYSTEM, THEN CLEAR THE NOT USED ENTRIES IN THE LOGICAL UNIT TABLE
047702          IF X<<AETADS THEN
047705              T:=RPIFPHPAGE SH 12
047707              A:="TMRTE"+1-"PITEX"+T=:TMRADDR
047714              A:="ETMRT"-"PITEX"+T=:ETMRADDR
047720              DO WHILE X<<AETADS
047723                 IF X=AD1500 THEN X+1 FI
047727                 T:=LOGDBANK; *LDDTX; STZTX; STZTX 10  % CLEAR ENTRY IN LOG.UN. TABLE
047733                 IF A><0 THEN CALL ZTMRTENTRY FI
047735                 X+2
047736              OD
047737          FI
047737   *"-8BACS
"047737
047737   *PL021=*
047737
047737   % COMPUTE NUMBER OF TAD/TERMINAL BACKGROUND PROGRAMS TO USE,
047737   % THE REMAINING TAD/TERMINAL BACKGROUND PROGRAMS WILL BE SET IN RTOFF.
047737          A:="2THSS"-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
047745          IF A>MXBPROGS THEN
047750             A:=MXBPROGST=:NBPROGS*5RTSIZE+"9FBPR"=:X
047755             DO WHILE X><"9LTBP"
047760                X.STATUS BONE 5RTOFF=:X.STATUS
047763                X+5RTSIZE
047764             OD
047765          ELSE
047766             A=:NBPROGS
047767          FI; NBPROGS=:MXTBPROGS                   % NUMBER OF TERMINAL/TAD BACKG.PROGS IN USE
047771   *"
"047771          GO GTADMEMORY; *)FILL
050010   GTADMEMORY:
050010
050010   % RESERVE MEMORY FOR THE "BIG" TAD DATAFIELDS
050010          IF NTADS><0 THEN
050012             A*200; CALL FPGNO; A+D=:MMSIZE=:X      % 200B WORDS PER TAD DF.
050017             A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050023             A=:FTADPAGE+MMSIZE-1=:LTADPAGE         % FIRST AND LAST PHYS.PAGE FOR TAD DF'S
050027             X:=CNVRT(14)+1; 0=:NTADS
050033             DO                                      % SEARCH IN LOG.DEV TABLES
050033               IF X=AD1500 THEN X+1 FI
050037             WHILE AETADS>>X
050042               T:=LOGDBANK; *LDDTX
050044               IF A><0 OR D><0 THEN
050047                  X=:0CINX; T:=NTADS; X:=A; CALL FAR MAKTADDF; MIN NTADS; X:=0CINX
050055               FI; X+2
050056             OD
050057          FI; GO OVFI9; *)FILL
050067
050067   OVFI9:
050067
050067   % FIND NUMBER OF BATCHES TO USE IN THIS SYSTEM
050067          0=:CNBATCES; "BCHTA"+1=:0CINX
050073          DO WHILE 0CINX.S0><-1
050100             IF CNBATCHES>>=MXBATCHES THEN
050104                -1=:X.S0
050106                X.S1.STATUS BONE 5RTOFF=:X.STATUS
050112                T:=0CINX.S2 SHZ -6; X.S2/\77 SH 1
050120                X:=CNVRT(T)+A; T:=LOGDBANK; *LDATX 10
050125                CALL CLBCKTABENTRY                  % REMOVE FROM BACKGROUND TABLE
050126                *STZTX 10; STZTX 20                 % CLEAR LOG.UNIT TABLE ELEMENT
050130                T:=0CINX.S3 SHZ -6; X.S2/\77 SH 1
050136                X:=CNVRT(T)+A; T:=LOGDBANK; *STZTX 10; STZTX 20
050144                0=:0CINX.S2=:X.S3
050147             FI; MIN CNBATCHES; 0CINX+4=:0CINX
050153          OD
050154          IF CNBATCHES>>MXBATCHES THEN A:=T FI
050161          A=:"BCHTAB".S0+NBPROGS=:NBPROGS
050165          GO OVFIA; *)FILL
050174
050174   OVFIA:
050174
050174   % COMPUTE SIZE OF THE PAGE-OWNER TABLE FOR MON SPLREE
050174          NBPROGS*POTESIZE; CALL FPGNO; A+D=:X=:POWSIZE
050202          A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050206          A=:D=:POWFPAGE+POWSIZE-1=:POWLPAGE:=0; AD SH 12=:DSREBADDR
050216
050216   *PL022=*
050216
050216   *"8BACS
"050216   % COMPUTE SIZE OF THE BACKS-TABLE AREA, AND RESERVE MEMORY FOR THIS AREA
050216          A:="EPRVT"-"PRVTT"=:D:=0; T:=5IPRVTSIZE; *RDIV ST
050224          IF D><0 THEN CALL ERRFATAL FI; A*5PRVTSIZE=:CPRVTSIZE
050231          T:=RPIBANK=:MBPRVTTABLE
050233          T:=RPIFPHPAGE SH 12
050235          A:="PRVTTABLE"-"PITEX"+T=:APRVTTABLE+CPRVTSIZE=:AEPRVTTABLE
050243          A:="EBPRT"-"SBPRT"=:D:=0; T:=5IBPRTSIZE; *RDIV ST
050251          IF D><0 THEN CALL ERRFATAL FI
050254          MXTBPROGS*BPRTSIZE=:CBPRTSIZE
050257          CALL FPGNO; A+D=:MMSIZE=:X
050263          A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050267          A=:BACSFPHPAGE+MMSIZE-1=:BACSLPHPAGE
050273          A:=BACSFPHPAGE=:D:=0; AD SH 12; A=:MBSPRTAB
050300          A:=D=:ASBPRTAB+CBPRTSIZE=:AEBPRTAB
050304          NBPROGS=:1NBPP                                % NUMBER OF BACKGROUND PROGS IN USE
050306          A:="9LBPR"-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
050314          IF D><0 THEN CALL ERRFATAL FI; A=:2NBPP       % NUMBER OF BACKGROUND PROG. RT-DESCR
050320   *"
"050320          GO AFILL; *)FILL
050350
050350   *PL023=*
050350
050350   AFILL:
050350          A:="9FSSG"=:D:=0; T:=5SEGSIZE; *RDIV ST
050355          A=:CSGNO                                  % FIRST CONFIG.DEPENDANT SEGMENT AFTER DILGS
050356          "9FSMA"=:NXMADR                           % MASS ADDR OF FIRST CONFIG.DEPENDANT SEGMENT
050360
050360   % COMPUT NUMBER OF SPOOLING PROCESSES TO USE IN THIS SYSTEM
050360   % SET SEGMENT SIZE AND MASS STORAGE ADDR OF THE SPOOLING QUEUE SEGMENTS
050360   % TO USE. THE UNUSED SPOOLING QUEUE SEGMENTS WILL BE SET
050360   % INHBT AND THE PERIPHERAL DEVICE NUMBER IN THE SPOOLING TABLE ELEMENT
050360   % WILL BE CLEARED (SET TO -1), AND THE CORRESPONDING SPOOLING
050360   % RT-PROGRAM WILL BE SET RTOFF
050360
050360          A:="ENDSP"-"SPTAB"=:D:=0; T:=SPLEN; *RDIV ST
050366          IF A<<MXSPOOLER THEN A=:MXSPOOLERS FI  % MAX SPOOLERS TO USE
050372          IF "SPTAB"="ENDSP" GO FAR OVFIB
050376          IF SPQSSIZE>>14 THEN A:=T FI           % ADDR 150000-177777 IS AVAILABLE FOR SPOOL.QUEUE
050403          A=:CSGSIZE                             % SPOOLING QUEUE SEGMENT SIZE
050404          IF HENTFLAG=0 THEN
050406             200=:CBLST; A:=100; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
050415             A=:D:=0; AD SH 12=:CDDMADDR
050421          FI; 0=:0CINX; X:="SPTAB"
050423          GO ISPOOLOOP; *)FILL
050437   ISPOOLOOP:
050437          DO WHILE X><"ENDSP"
050442             X=:CSAVX
050443             IF 0CINX><MXSPOOLERS OR X="COSDA"+1 THEN      % USE MORE SPOOLERS?
050453                IF HENTFLAG=0 THEN
050455                   CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK % YES
050462                   NXMADR; *MADR@3 STATX                   % SET MASSADDR OF SEGMENT
050464                   CSGSIZE; *SEGLE@3 STATX                 % SET LENGTH OF SEGMENT
050466                   X:=CBLST; T:="MSPDF"+X; A:=NXMADR+X
050473                   X:=1; CALL FAR CRWDISC           % COPY QUEUE-HANDLING ROUTINES
050475                   NXMADR+CSGSIZE=:NXMADR
050500                FI; MIN 0CINX
050501             ELSE
050502                -1=:X.SPERI                                % CLEAR LOG.DEV.NO OF SPOOLING TABLE ELEMENT
050504                CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
050511                *FLAG@3 LDATX
050512                A BONE 5INHBT; *FLAG@3 STATX               % SET SEGMENT INHBT
050514                CSAVX.SPROG.STATUS BONE 5RTOFF=:X.STATUS    % RTOFF ON SPOOLING RT-PROGR.
050521             FI; MIN CSGNO; X:=CSAVX+SPLEN
050524          OD; GO OVFIB; *)FILL
050537
050537   *PL024=*
050537
050537   OVFIB: X:=1; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL % ALLOCATE PAGE FOR CACHE INHIBIT BIT MAP
050544          A=:FPHPCACHEINHIBIT=:LPHPCACHEINHIBIT
050546          A=:D:=0; AD SHZ 12; A=:MBCACHINHIBIT:=D=:CACHINHIBIT
050554          A:=FPHPCACHEINHIBIT; CALL ZEROPAGE                    % CLEAR CACHE INHIBIT BIT MAP
050556
050556          CALL OCSTART                               % START UP FOR OCTOBUS
050557          CALL NUCST                                 % START UP FOR NUCLEUS
050560   *"8N500
"050560   % COMPUTE THE MAX. NUMBERS OF ND-500 PROCESSES TO USE IN THIS SYSTEM.
050560   % SET THE MASS. STORAGE ADDR OF THE ND-500 DATA SEGMENTS TO USE.
050560   % THE UNUSED ND-500 DATA SEGMENTS AND ND-500 FILE TRANSFER SEGMENTS
050560   % WILL BE SET INHBT.
050560   %
050560          CALL CH5CPUPRESENT; 0=:MX5PROCS           % CHECK IF ND-500 CPU IS PRESENT
050562          A:="S500E"-"S500S"=:D:=0; T:=5PRDSIZE; *RDIV ST
050570          IF A-1<<MX5PROCS THEN A=:MX5PROCS FI
050575          "F5DSG"=:CSGNO*5SEGSIZE+SEGSTART=:X
050602          T:=SEGTBANK; *SEGLE@3 LDATX
050604          A=:CSGSIZE                                % ND-500 DATA SEGMENT SIZE
050605          0=:0CINX
050606          IF HENTFLAG >< 0 THEN
050610             A:="F5DSG"*5SEGSIZE+SEGSTART=:X
050614             T:=SEGTBANK; *FLAG@3 LDATX
050616                IF A BIT 5INHB THEN
050620                   0=:MX5PROCS                      % ND-500 DATA SEGMENT IS NOT INITIALIZED
050621                FI
050621          FI
050621          DO WHILE CSGNO><"L5DSG"
050625             IF 0CINX><MX5PROCS THEN
050631                IF HENTFLAG=0 THEN
050633                   NXMADR; T:=SEGTBANK; *MADR@3 STATX  % MASS STORAGE OF ND-500 DATA SEGM
050636                   A+CSGSIZE=:NXMADR
050640                FI; X+5SEGSIZE+5SEGSIZE; MIN 0CINX
050643             ELSE
050644                IF HENTFLAG=0 THEN
050646                   T:=SEGTBANK; *FLAG@3 LDATX
050650                   A BONE 5INHB; *FLAG@3 STATX         % INHBT OF ND-500 DATA SEGM
050652                   X+5SEGSIZE; *FLAG@3 LDATX
050654                   A BONE 5INHB; *FLAG@3 STATX         % INHBT OF ND-500 FILE TRANSFER SEGM
050656                   X+5SEGSIZE
050657                FI
050657             FI; MIN CSGNO; MIN CSGNO
050661          OD
050662   *"
"050662          GO SCAPM; *)FILL
050704
050704   *"8SCSI
"050704   %==============================================================================
050704   %        S C A P M
050704   %
050704   %
050704   % SCAPM : ALLOCATE PHYSICAL MEMORY BUFFERS TO SCSI DEVICES
050704   %
050704
050704   % ROUTINE TO ALLOCATE PHYSICAL MEMORY BUFFERS TO DEVICE AND LUN DATAFIELDS
050704   % ENTRY: AD = PHYSICAL ADDRESS OF BUFFER LOW PART
050704   % EXIT: AD = FIRST ADDRESS NOT USED
050704
050704   INTEGER CURDF, SAVX, SAVB
050707   INTEGER CPHA1,CPHA2
050711   DOUBLE CPHAD=CPHA1
050711
050711   ALPHM: AD=:CPHAD; A:=B=:SAVB
050714          "SCBDF"=:CURDF
050716          DO WHILE CURDF<<"SCDDF"
050722             IF CURDF.S1=:B><0 THEN
050726                CPHA1; AD=:SCPMB; A:=10; D+A
050732             FI
050732             CURDF+2=:CURDF
050735          OD
050736          CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
050743          "SCDDF"=:CURDF
050745          DO WHILE CURDF<<"SCSDF"
050751             IF CURDF.S1=:B><0 AND SCIDN SHZ -4><0 THEN
050760                0=:SAVX
050761                FOR SAVX TO 3 DO
050765                   IF X:=PUNDF(SAVX)><0 THEN
050770                      CPHAD; T:=SDDBS; D+T; AD=:X.CMADR
050774                      CPHAD=:X.SCDFA.SMBPA
050777                   FI
050777                   CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
051004                OD
051010             FI
051010             CURDF+2=:CURDF
051013          OD
051014          DO WHILE CURDF.S0><-1
051021             IF X.S1=:B><0 AND SCIDN SHZ -4><0 THEN
051027                X:=SCDFA+1; CPHAD=:X.SMBPA
051033                T:=SDDBS; D+T; AD=:CMADR
051036                CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
051043             FI
051043             CURDF+2=:CURDF
051046          OD
051047          SAVB=:B; CPHAD; EXIT
051053   *)FILL
051057
051057   INTEGER NPAGS
051060   INTEGER NOP(0); *RAND
051061
051061   *"
"051061
051061   SCAPM:
051061
051061   *"8SCSI
"051061          A:=0=:D; CALL FAR ALPHM              % DETERMINE AMOUNT OF MEMORY NEEDED
051064          AD SHZ 6; IF D><0 THEN A+1 FI        % NUMBER OF PAGES
051070          IF X:=A=:NPAGS><0 THEN
051073             DVBFPAGE; T:=LPHYSPAGE            % LEGAL AREA
051075             CALL ZGETAREA; CALL ERRFATAL      % GET MEMORY AREA
051077             A=:D-1+NPAGS:=:D; AD=:SCPHYSPAGE  % FIRST AND LAST PAGE
051104             D:=0; AD SHZ -6; CALL FAR ALPHM   % INITIALIZE DATAFIELDS
051107          FI
051107          IF HWINFO(0)/\ 377 >= 3 THEN         % ND-110 , ND-120
051115             NOP=:SCCLR; SCPHYSPAGES           % REMOVE CLEAR CACHE INSTRUCTION
051120             CALL DISCACHE; CALL ERRFATAL      % DISABLE CACHE
051122          FI
051122          GO OVFIC
051123   *)FILL
051133   *"
"051133
051133   *PL026=*
051133
051133   OVFIC:
051133
051133   *"8RFAC
"051133   % COMPUTE THE MAX NUMBER OF REMOTE-FILE-ACCES CONNECTIONS THAT
051133   % SIMULTANEOUSLY CAN BE ACTIVE IN TH SYSTEM
051133   % THE MASS STORAGE ADDR OF THE REMOTE-FILE-TRANSFER DATA SEGMENTS, THAT CAN
051133   % BE USED IS SET UP, AND THE REST OF THE REMOTE-FILE-TRANSFER DATA SEGMENTS
051133   % ARE SET INHBT.
051133          IF "NRFSG".S0<<MXRFACS THEN A=:MXRFACS FI
051141          A+"DSSNM"=:D                              % D=LAST SEGM+1 FOR REMOTE-FILE-ACC.
051143          "DSSNM"=:CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051152          A=:CSGSIZE; 0=:0CINX
051154          DO WHILE CSGNO<<D
051157             IF 0CINX><MXRFACS THEN
051163                IF HENTFLAG=0 THEN
051165                   NXMADR; T:=SEGTBANK; *MADR@3 STATX
051170                   A+CSGSIZE=:NXMADR
051172                FI; MIN 0CINX
051173             ELSE
051174                T:=SEGTBANK; *FLAG@3 LDATX
051176                A BONE 5INHB; *FLAG@3 STATX
051200             FI; MIN CSGNO; X+5SEGSIZE
051202          OD; MXRFACS=:"NRFSG".S0
051206   *"
"051206   % COMPUTE THE MAX NUMBER OF ND-100 SYMBOLIC DEBUGGERS THAT SIMULTANEOUSLY
051206   % CAN BE ACTIVE.
051206   % THE MASS STORAGE ADDR OF THE SYMBOLIC DEBUGGER SEGMENTS, THAT CAN BE USED,
051206   % IS SET UP, AND THE REST OF THE DEBUGGER DATA SEGMENTS PRESENT
051206   % ARE SET INHBT.
051206          A:="9SGNU"=:D:=0; T:=5SEGSIZE; *RDIV ST
051213          IF A-"SGNUM"<<MXSDBUGGER THEN A=:MXSDBUGGER FI
051220          "SGNUM"=:CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051227          A=:CSGSIZE; 0=:0CINX
051231          DO WHILE "9SGNU"+SEGSTART><X
051235             IF 0CINX><MXSDBUGGERS THEN
051241                IF HENTFLAG=0 THEN
051243                   NXMADR; T:=SEGTBANK; *MADR@3 STATX
051246                   A+CSGSIZE=:NXMADR
051250                FI; MIN 0CINX
051251             ELSE
051252                T:=SEGTBANK; *FLAG@3 LDATX
051254                A BONE 5INHB; *FLAG@3 STATX
051256             FI; X+5SEGSIZE; MIN CSGNO
051260          OD; GO OVFID; *)FILL
051274
051274   *PL027=*
051274
051274   OVFID:
051274
051274          A:="1SYSS"=:D:=0; T:=5SEGSIZE; *RDIV ST
051301          A=:CFSYSEG                                % FIRST SYSTEM SEGMENT IN THIS SYSTEM
051302          IF HENTFLAG=0 THEN
051304             CFSYSEG*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
051311             NXMADR; *MADR@3 STATX                     % MASS STORAGE ADDR OF FIRST SYSTEM SEGMENT
051313             SISYSEG; *SEGLE@3 STATX                   % SYSTEM SEGMENT SIZE
051315             X+5SEGSIZE; A+NXMADR; *MADR@3 STATX       % MASS STORAGE ADDR OF FIRST BACKGROUND SEGMENT
051320             X+5SEGSIZE
051321             DO WHILE "9SYSS"+SEGSTART>>X
051325                SISYSEG; T:=SEGTBANK; *SEGLE@3 STATX   % SET SEGMENT LENGTH OF ALL SYS.SEGMS
051330                X+5SEGSIZE+5SEGSIZE
051332             OD
051333          FI
051333          IF "MNADP"><0 AND SGADPSIZE><0 THEN
051337             "FREDS"*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051345             A=:SGADPSIZE                           % SIZE OF ADP.SEGMENT
051346          ELSE
051347             0=:SGADPSIZE                           % CANNOT USE "MON ADP", NO ADP-DATA-SEGM AVAILABLE
051350          FI
051350          MXALLMEM+40                               % NALME+ MAX.NO. OF HDLS'C
051352          IF T:=SGADPSIZE><0 THEN A+NBPROGS FI      % IF MON ADP THEN 1 ELEMENT FOR EACH BACKGR.PROGR
051356          A SH 1=:D=:FXCTSIZE                       % 2 LOCS FOR EACH ENTRY IN FXCTAB
051361          "NXRTP"*TSLSIZE+D=:D                      % TIMESLICE TABLE AREA
051365          "NXRTP"+1 SH 1+D=:D                       % DTSLPRTAB
051372   *"8ACC
"051372          A:="8RTN"*3+D=:D                          % RT-ACCOUNTING
051376   *"8IOAC
"051376          A:="NXRTP" SH 1+D=:D                      % I/O ACCOUNTING
051402   *"8LOG+8HIST
"051402          A:="NXRTP" SH 1+D=:D                      % LOG/HISTOGRAM SAMPLING AREA
051406   *"
"051406          A:=200; D+A                               % MEMORY-TYPE ARRAY
051410          GO OVFIE; *)FILL
051431
051431   *PL028=*
051431
051431   OVFIE: A:=D; CALL FPGNO; A+D=:MMSIZE
051435          A=:X; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
051442          A=:8LOGFPHPAGE+MMSIZE-1=:8LOGLPHPAGE=:D
051447          A:=8LOGFPHPAGE; DO CALL ZEROPAGE WHILE A><D; A+1; OD
051455          A:=8LOGFPHPAGE=:D:=0; AD SH 12; A=:GLTMBANK
051462   *"8LOG+8HIST
"051462          A=: MBLGARR
051463   *"
"051463          A=:MBMEMARRAY
051464          A=:MBFXCTAB:=D=:FXCTAB+FXCTSIZE=:EFXCTAB=:D  % FXCTABLE ADDRESSES
051472          A:=D=:GTSLTAB; "NXRTP"*TSLSIZE+D
051477          A=:DTSLPRTAB=:D; "NXRTP"+1 SH 1+D
051505   *"8ACC
"051505          A=:ACTABLE=:D:="8RTN"*3+D
051512   *"8IOAC
"051512          A=:IOACTABLE=:D:="NXRTP" SH 1+D
051517   *"8LOG+8HIST
"051517          A=:ALGARR=:D:="NXRTP" SH 1+D
051524   *"
"051524          A=:MEMARRAY                               % MEMEORY-TYPE-ARRAY ADDR
051525   % ALLOCATE MEMORY FOR THE RT-PROGR'S MON.CALL WORKING FIELDS
051525          A:="9FBPR"-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
051533          A*40; CALL FPGNO; A+D=:MMSIZE
051537          A=:X:=0; T:=LPHYSPAGE; CALL ZGETAREA; CALL ERRFATAL
051544          A=:RTWFPAGE=:FRTWFPAGE+MMSIZE-1=:LRTWFPAGE
051551   % INITIALIZE THE RT-DESCRS WITH PAGE NUMBER FOR MON.CALL WORKING FIELD
051551          A:=RTWFPAGE; X:=RTSTART
051553          DO
051553             T:=-40=:0CINX
051555             FOR 0CINX DO
051555                A=:X.TRMWINDOW
051556                IF X+5RTSIZE>>="9FBPR" GO OVFIG
051562             OD; A+1
051565          OD; *)FILL
051617
051617   *PL029=*
051617
051617   OVFIG:
051617          AD:=CMDPHPAGE; A+1; CALL MOUTLINKL % LINK OUT COMMON CODE
051622          AD:=DPIDPHPAGE; CALL MOUTLINKL    % LINK OUT DPIT
051624          AD:=RSDPHPAGE; CALL MOUTLINKL     % LINK OUT RESTART ROUTINE AND REG-BLOCKS/REE-BITMAP
051626          "STPBS" SHZ -12=:D-1; D+1; CALL MOUTLINK % LINK OUT SBFIELD + ERROR RING BUFFER + PATCH INFO AREA
051634          AD:=RTSGDPHPAGE; CALL MOUTLINKL   % LINK OUT RT'S SYSTEM SEGMENT
051636          AD:=PITSDPHPAGE; CALL IMOUTLINKL  % LINK OUT PIT PAGES AND INITIALIZED THEM.
051640          AD:=LGTDPHPAGE; CALL MOUTLINKL    % LINK OUT LOG.DEV.NO. TABLE
051642          AD:=MMDPAGE; CALL MOUTLINKL       % LINK OUT MEMORY MAP AREA
051644          AD:=DBDPAGE; CALL IMOUTLINKL      % LINK OUT DEVICE BUFFER AREA
051646          AD:=SGTDPHPAGE; CALL MOUTLINKL    % LINK OUT SEGMENT TABLE
051650          AD:=ECODPHPAGE; CALL MOUTLINKL    % LINK OUT EXT. COMMON
051652          AD:=RPIDPHPAGE; CALL MOUTLINKL    % LINK OUT RPIT
051654          AD:=MPIDPHPAGE; CALL MOUTLINKL    % LINK OUT MPIT
051656          AD:=IPIDPHPAGE; CALL MOUTLINKL    % LINK OUT IPIT
051660          AD:=DEDPHPAGES; CALL MOUTLINKL    % LINK OUT "EDIT-ROUTINES" SEGMENT
051662          AD:=IOBDPHPAGE; CALL IMOUTLINKL   % LINK OUT I/O BUFFER PAGES
051664          AD:=POWDPAGE; CALL IMOUTLINKL     % LINK OUT PAGE-OWNER TABLE AREA
051666          AD:=DCMCLPAGE; CALL IMOUTLINKL    % LINK OUT MONITOR-CALL-LOG-TABLE PAGE
051670          AD:=SYMDPHPAGE; CALL IMOUTLINKL   % LINK OUT SYNC.MODEM I/O BUFFERS
051672          AD:=DHDLCPAGES; CALL IMOUTLINKL   % LINK OUT HDLC BUFFER AREA
051674          AD:=TDDPAGE; CALL IMOUTLINKL      % LINK OUT TERMINAL DATAFIELD AREA
051676          AD:=DTADPHPAGE; CALL IMOUTLINKL   % LINK OUT TAD DATAFIELD AREA
051700          AD:=DLAMPAGE; CALL IMOUTLINKL     % LINK OUT LAMU AREA
051702          AD:=DBACSPHPAGES; CALL IMOUTLINKL % LINK OUT BACS TABLE AREA
051704          AD:=5PIDPHPAGES; CALL MOUTLINK    % LINK OUT 5PIT SEGMENT PAGES
051706          AD:=D8LOGPHPAGE; CALL IMOUTLINKL  % LINK OUT PROG-LOG PAGES
051710          AD:=DSPTRPHPAGE; CALL IMOUTLINKL  % LINK OUT "SPARE-TRACK-ADDR-BUFFER"
051712          AD:=DRTWFPAGE; CALL IMOUTLINKL    % LINK OUT RT-PROG'S MON.CALL WORKING FIELDS
051714          AD:=DCACHEINHIBIT; CALL MOUTLINKL % LINK OUT CACHE INHIBIT BIT MAP PAGE
051716          AD:=SCPHYSPAGE; CALL IMOUTLINKL   % LINK OUT SCSI BUFFER PAGES
051720          AD:=NUPHYSPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR NUCLEUS
051722          AD:=OCPHYSPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR OCTOBUS
051724          AD:=IERDPHPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR ERROR DEVICE BUFFER
051726   *"8FLMN
"051726          IF UCLOAD >< 0 THEN
051730            AD:=UCPAG; CALL IMOUTLINKL      % LINK OUT PAGES FOR MICR CODE
051732          FI; *IFILL
051737
051737   *PL030=*
051737
051737   % LINK OUT RT-COMMON
051737          IF ACCTAB(0)><-1 THEN
051744             A/\177=:ARTFPAGE SH 1; T:="XCCTAB"-A=:IRTCPIT
051752             ARTFPAGE\/77=:ARTLPAGE
051755             DO WHILE ACCTAB(X)><-1
051761                X=:0CINX; A=:1CCTAB
051763                X+1; ACCTAB(X)=:D=:2CCTAB; CALL IMOUTLINKL
051770                A:=2CCTAB=:D:=161000; AD=:XCCTAB(0CINX); X+2
051776             OD
051777          ELSE
052000             -1=:ARTFPAGE=:ARTLPAGE
052003          FI
052003
052003   % LINK OUT NOT-SWAP PAGES AND INITIALIZE THE PAGES
052003          X:=0
052004          DO WHILE X<<"NNSWSZ*2"
052007             *1BANK
052010             AD:=NSWPAGE(X)
052011             *2BANK
052012             IF A><0 AND A<<=D THEN
052015                CALL MOUTLINKL
052016                DO WHILE A<<=D; CALL INITPAGE; A+1; OD
052023             FI; X+2
052024          OD; *IFILL
052041
052041   % LINK OUT LAMU AREAS
052041          X:=0; DO WHILE X<<"NINSZ+1*2"
052045             *1BANK
052046             AD:=LAMARR(X); *2BANK
052050             IF A><0 AND D >< 0 THEN CALL MOUTLINKL FI  % LINK OUT LAMU AREAS
052054             X+2
052055          OD
052056
052056   % FIND NUMBER OF SWAPPING PAGES AND INITIALIZE THE SWAPPING PAGES
052056          0=:CURRPAGES; T:=SEGTBANK; X:=XSGRT; *AAX BPAGL-PAGLI
052062   INDO2: DO
052062             *PAGLI@3 LDXTX
052063          WHILE X><0
052064             T:=CORMBANK; A:=X SHZ -2     % A= PHYSICAL PAGE NUMBER
052067             CALL PHYSPTEST; GO COUTLINKL; CALL INITPAGE
052072             MIN CURRPAGE
052073          OD; CURRPAGE=:NOPGS; GO L4
052077
052077   % LINK OUT A MEMORY MAP ELEMENT (X=ADDR OF ELEMENT)
052077   COUTLINKL: T:=CORMBANK; X=:L
052101          A:=0 BONE 5CMINHB; *PROTE@3 STATX
052104          *PREVI@3 LDATX; PAGLI@3 LDXTX
052106          IF X><0 THEN
052107             *PREVI@3 STATX
052110          FI; X=:D:=A
052112          IF A/\3><0 THEN
052114             X:=XSGRT; T:=SEGTBANK; *AAX BPAGL-PAGLI
052117          FI; A:=D; *PAGLI@3 STATX
052121          GO INDO2
052122   *)FILL
052133
052133   *PL031=*
052133
052133   L4:
052133          GO LL4; *)FILL
052134
052134   LL4:
052134
052134   *PL032=*
052134
052134   % SET TIMESLICE CLASS
052134   % IF SAVED TIMESLICE CLASS (TSLSTATUS BIT 14-17) EQUALS ZERO THEN
052134   %          TIMESLICE CLASS FOR TERMINALS IS SET TO ZERO AND TIMESLICE
052134   %          CLASS FOR BATCH IS SET TO ONE
052134   % ELSE
052134   %          TIMESLICE CLASS IS SET EQUAL SAVED TIMESLICE CLASS
052134   % ENDIF
052134   %
052134          0=:NPAGES=:CCOUNT; RTSTART=:0CINX
052140   *"-8BACS
"052140          DO WHILE X:=0CINX<<"ERTBS"
052144             IF X.STATUS BIT 5TSLICED AND A NBIT 5RTOFF THEN
052151                IF A NBIT 5BACKGR OR X>>="2THSS" THEN         % ONLY RT-PROGR AND BATCHES
052156                   A BONE 5ESCF=:X.STATUS
052160                   IF A BIT 5BACKGR THEN
052162                      A:=1                                    % BATCH: TIMESLICE CLASS 1
052163                   ELSE
052164                      IF 0CINX.INTSLCLASS BIT BINTSLCLASS THEN
052170                         A SHZ -7CUTY/\TSLCMSK                 % "SAVED" TIMESLICE CLASS
052172                      ELSE
052173                         A:=0                                 % DEFAULT CLASS
052174                      FI
052174                   FI; A SHZ 7CUTY=:D
052176                   A:=NPAGES*TSLSIZE+GTSLTAB=:X
052202                   T:=GLTMBANK; A:=D; *TSLST@3 STATX          % INSERT TIMESLICE CLASS
052205                   A:=CCOUNT+DTSLPRTAB=:X
052210                   A:=NPAGES=:D:=0CINX; *STDTX                % INSERT IN DTSLPRTAB
052214                   CCOUNT+2=:CCOUNT                           % INCREMENT INDEX IN DTSLPRTAB
052217                FI
052217             FI; MIN NPAGES; 0CINX+5RTSIZE=:0CINX             % INCREMENT RT-DESCR ADDR AND RT-PROGR INDEX
052223          OD
052224   *"
"052224   *PL033=*
052224
052224          CCOUNT+DTSLPRTAB=:X; T:=GLTMBANK
052230          A:=-1=:D; *STDTX
052233          0=:CCOUNT
052234          DO WHILE CCOUNT<<"NXRTP"
052240             A*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; A:=-1; *TSLCO@3 STATX
052246             MIN CCOUNT
052247          OD; X:=RTSTART
052251          DO WHILE X<<RTEND; 0=:X.INTSLCLASS; X+5RTSIZE; OD
052257          GO FFLTYPE; *)FILL
052272
052272   FFLTYPE:
052272          X:="FLOP1"; CALL FAR FINDFLOPPY
052274          X:="FLOP2"; CALL FAR FINDFLOPPY
052276
052276          0=:0CINX
052277          DO WHILE BDISTABLE(0CINX)><-1
052304             IF A><0 THEN                                     % DISK DF. GENERATED
052305                A:=200; *TRR IIE; TRA IIC                     % ENABLE FOR IOX-ERRORS
052310                X:=BDISTABLE(X); T:=X.HDEV+2; *IOXT; TRA IIC
052315
052315   *"8FLMN      % DO NOT REMOVE DISK IF FOR FLOMEN
"052315                IF A=0 THEN
052316                   BDISTABLE(0CINX)                           % INTERFACE PRESENT
052320                ELSE
052321                   BDISTABLE(0CINX); CALL FAR RFTMTABLE       % REMOVE FROM TIMER TABLE
052324                   A:=0                                       % DISK INTERFACE NOT PRESENT
052325                FI; A=:XA; MIN 0CINX
052327                BDISTABLE(0CINX)=:T SHZ -6; X:=CNVRT(A)
052335                A:=T/\77 SH 1+1; X+A                          % X=ADDR IN LOG.DEV.NO. TABLE
052342                A:=XA; T:=LOGDBANK; *STATX                    % UPDATE LOG.DEV.NO. TABLE
052345                MIN 0CINX; T:=IPIFPHPAGE SHZ 12=:D
052351                A:="ITB11"-"PITEX"+D+BDISTABLE(0CINX)-1=:X
052360                T:=IPIBANK; A:=XA; *STATX                     % UPDATE IDENT CODE TABLE
052363                MIN 0CINX
052364             ELSE
052365                0CINX+3=:0CINX
052370             FI
052370          OD
052371          GO MB2MT; *)FILL
052405   MB2MT:
052405          0=:0CINX
052406          DO AD:=DMTDITABLE(0CINX) WHILE A><-1
052413             IF A><0 OR A:=D><0 THEN                          % DATAFIELD EXISTS
052416                A=:X; A:=200; *TRR IIE; TRA IIC               % ENABLE FOR IOX-ERROR
052422                T:=X.HDEV+3; A:=20; *IOXT; TRA IIC            % CLEAR DEVICE AND CHECK FOR IOX-ERRORS
052427
052427   *"8FLMN      % DO NOT REMOVE DISK IF SINTRAN IF FOR FLOMEM
"052427                IF A=0 THEN                                   % INTERFACE EXISTS
052430                   T+"5-3"; *IOXT                             % WRITE COMMAND WHEN STC
052432                   A:=MT1MASK; *IOXT
052434                   A:=0; T+"2-5"; *IOXT                       % READ STATUS
052437                   IF A/\170040=170040 THEN
052443                      A:=MT2MASK; T:=X.HDEV+5; *IOXT          % WRITE COMMAND WHEN STC
052447                      A:=0; T+"2-5"; *IOXT                    % READ STATUS
052452                      IF A/\170040><40 GO NOTSTC              % NOT STC MAG.TAPE
052456                      X:=0CINX+1; MTDITABLE(X); CALL FAR RFTMTABLE
052462                      MTDITABLE(0CINX)                        % STC MAG.TAPE
052464                   ELSE
052465   NOTSTC:            MTDITABLE(0CINX); CALL FAR RFTMTABLE
052470                      X:=0CINX+1; MTDITABLE(X)                % CIPHER/PERTEC MAG.TAPE OR WINCHESTER DISC
052473                   FI
052473                ELSE
052474                   MTDITABLE(0CINX) CALL FAR RFTMTABLE
052477                   X:=0CINX+1; MTDITABLE(X); CALL FAR RFTMTABLE
052503                   A:=0;                                      % INTERFACE NOT PRESENT
052504                FI; A=:XA; 0CINX+2=:0CINX
052510                MTDITABLE(0CINX)=:T SHZ -6; X:=CNVRT(A)
052516                A:=T/\77 SH 1+1; X+A                          % X=ADDR IN LOG.DEV.NO. TABLE
052523                A:=XA; T:=LOGDBANK; *STATX                    % UPDATE LOG.DEV.NO. TABLE
052526                MIN 0CINX; T:=IPIFPHPAGE SHZ 12=:D
052532                A:="ITB11"-"PITEX"+D+MTDITABLE(0CINX)-1=:X
052541                T:=IPIBANK; A:=XA; *STATX                     % UPDATE IDENT CODE TABLE
052544                MIN 0CINX
052545              ELSE
052546                0CINX+4=:0CINX
052551              FI
052551          OD; GO XCLMT; *)FILL
052565
052565   *PL034=*
052565
052565   % CLEAR ALL UNUSED MAG.TAPE UNITS FROM LOG.NO TABLES AND TIMER TABLE
052565   XCLMT: "XMTTABLE"=:CSAVX
052567          DO WHILE CSAVX.S0><-1
052574             AD SHZ -6; X:=CNVRT(A); AD SH 6
052600             A/\77 SH 1+1; X+A; T:=LOGDBANK; *LDXTX
052606             IF X=0 OR X.TYPRING NBIT 5MT THEN              % NO MAG.TAPE
052612                CSAVX.S1; CALL FAR CLLOGENTRY; CSAVX.S2; CALL FAR CLLOGENTRY
052620                CSAVX.S3; CALL FAR CLLOGENTRY; CSAVX.S4; CALL FAR CLLOGENTRY
052626                CSAVX.S5; CALL FAR RFTMTABLE; CSAVX.S6; CALL FAR RFTMTABLE
052634                CSAVX.S7; CALL FAR RFTMTABLE; CSAVX.S10; CALL FAR RFTMTABLE
052642             FI; CSAVX+11=:CSAVX
052645          OD
052646
052646   *"8SCSI
"052646        CALL FAR SCOPS
052647   *"
"052647        GO FAR TPIOCS; *)FILL
052660
052660   *"8SCSI
"052660   %==============================================================================
052660   %        S C O P S
052660   %
052660   %
052660   % SCOPS : HANDLING OF SCSI DEVICES IN SINTRAN START
052660   %
052660
052660
052660   % ROUTINE TO UPDATE RESIDENT LOGICAL NUMBER TABLE
052660   % ENTRY: T = DEVICE NUMER, AD = DATAFIELD ADDRESSES
052660
052660   STDFA: T=:X SHZ -6:=:X SHZ 12 SHZ -11; X:=CNVRT(X)+T
052667          T:=LOGDBANK; *STDTX 10
052671          EXIT
052672   *)FILL
052674
052674   % ROUTINE TO CHECK IF CORRESPONDING HOST INTERFACE EXITS
052674   % ENTRY: A= DEVICE DATAFIELD ADDRESS
052674
052674   INTEGER POINTER SAVL
052675   INTEGER HIDFN
052676
052676   CHBDF: A.SCIDN SHZ -4=:HIDFN:=L=:"SAVL"     % HOST INTERFACE DEVICE NUMBER
052704          X:="SCBDF"
052705          DO WHILE X<<"SCDDF"
052710             IF X.S0=HIDFN THEN
052714                CALL LOGPH; GO SAVL            % CHECK INTERFACE
052716             FI
052716             WHILE X+2<<"SCDDF"
052722          OD
052723          "0"; GO SAVL
052725   *)FILL
052730
052730   TRIPLE ARRAY SCMUD(0)                       % MAGTAPE UNIT DATAFIELDS
052730          *   40; MTDI1; MTDO1
052733          *   32; M2DI1; M2DO1
052736          * 1232; M3DI1; M3DO1
052741          * 1225; M4DI1; M4DO1
052744
052744   INTEGER U, SAVR
052746   INTEGER POINTER HOME
052747
052747   SCOPS: A:=L=:"HOME"; "SCBDF"=:U
052753
052753          DO
052753             U.S0; CALL LOGPH; A=:SAVR   % CHECK DEVICE NUMBER
052757             IF X:=A><0 THEN
052761                200; *TRR IIE; TRA IIC         % ENABLE IOX ERRORS
052764                T:=X.HDEV+4; *IOXT; TRA IIC    % TEST INTERFACE
052770
052770   *"8FLMN                   % ALL SCSI GENERATED IN THE SINTRAN WILL BE PRESENT
"052770
052770                IF A><0 THEN
052771                   U.S0; CALL FAR CLLOGENTRY   % REMOVE DEVICE NUMBER
052774                   SAVR; CALL FAR RFTMTABLE    % REMOVE FROM TIMER TABLE
052776                   SAVR; CALL 11EIDCLEAR       % REMOVE FROM IDENT TABLE
053000                FI
053000             FI
053000             WHILE U+2=:U<<"SCDDF"
053006          OD
053007          "SCDDF"=:U
053011          DO
053011             IF U.S1><0 THEN                   % DATAFIELD GENERATED
053014                CALL FAR CHBDF                 % CHECK HOST INTERFACE
053015                IF A=0 THEN
053016                   U.S0; CALL FAR CLLOGENTRY   % REMOVE DEVICE NUMBER
053021                FI
053021             FI
053021             WHILE U+2=:U<<"SCTDF"
053027          OD
053030          DO
053030             WHILE U.S0>0; CALL LOGPH
053035             IF A=0 AND U.S1><0 THEN           % NOT IN USE AND GENERATED
053041                CALL FAR CHBDF                 % CHECK HOST INTERFACE
053042                IF A><0 THEN
053043                   T:=U.S0; X.S1; D:=0
053047                   CALL FAR STDFA              % DEFINE TAPE DATAFIELD
053050                   U-"SCTDF" SHZ -1*3
053054                   *1BANK
053055                   SCMUD(A)
053057                   *2BANK
053060                   CALL FAR STDFA              % DEFINE UNIT DATAFIELD
053061                FI
053061             FI
053061             U+2=:U
053064          OD
053065          GO HOME
053066   *)FILL
053102   *"
"053102
053102   TPIOCS:
053102   % CLEAR NON-EXISTING PIOCS FROM THE TIMER TABLE,
053102   % AND FROM THE EXTENDED IDENT-CODE-TABLE.
053102          0=:CSAVX
053103          DO AD:=PIOCS(CSAVX) WHILE A><-1
053110             IF A><0 THEN                           % PIOC DATAFIELD EXISTS
053111                AD=:XAD
053112                *1BANK; LDD I ,X (MMPIO; 2BANK
053115                IF A=0 AND D=0 THEN                 % PIOC INTERFACE NOT PRESENT
053120                   XA; CALL FAR RFTMTABLE
053122                   A:=MPIFPHPAGE SHZ 12=:D
053125                   A:="ITE12"-"PITEX"+D=:X
053131                   DO
053131                      T:=MPIBANK; *LDDTX
053133                   WHILE A><-1
053136                      IF D=XA THEN
053141                         T:=MPIBANK; *STZTX; STZTX 10   % CLEAR ENTRY IN EXTENDED IDENT CODE TABLE
053144                         GO NXPIOC
053145                      FI; X+2
053146                   OD
053147                FI
053147   NXPIOC:   FI; CSAVX+2=:CSAVX
053152          OD; GO XCHHDLC; *)FILL
053161
053161   *PL035=*
053161
053161   % CHECK ALL GENERATED HDLC'S
053161   XCHHDLC:
053161          "0HDTA"=:CSAVX                             % START OF HDLC CONFIG. TABLE
053163          DO WHILE X:=CSAVX<<"0HDEN"
053167             *1BANK
053170             IF X.NHDLC><0 OR X.SYNHDLC><0 THEN     % DATAFIELD EXISTS
053174                X.HDLCSELECTION=:L                  % L=HDLCSELECTION
053176                X.INTHDLC=:D; X.IDHDLC-1+"ITB13"-"PITEX"=:X
053205                *2BANK
053206                A:=MPIFPHPAGE SH 12; X+A; T:=MPIBANK
053212                A:=D; *STATX                         % UPDATE IDENT-CODE TABLE
053214                IF A><0 THEN
053215                   A:="ITB12"-"ITB13"+X=:D           % D=ADDR OF ENTRY IN ITB12-TABLE
053221                   X:=CSAVX; *1BANK
053223                   IF 1=L THEN X.NOHDLC ELSE X.SYNOHDLC FI
053231                   X:=D; *STATX; 2BANK               % UPDATE ITB12 ENTRY
053234                ELSE
053235                   A:="ITB12"-"ITB13"                % ENTRIES SHOULD BE CLEARED
053237                   X+A; A:=D; *STATX
053242                   X:=CSAVX; *1BANK
053244                   X.NHDLC; *2BANK
053246                   CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
053251                   AD:=X.DSYNHDLC=:X.2CDFCLTIMER
053253                   X.NOHDLC; *2BANK
053255                   CALL FAR RFTMTABLE
053256                FI; X:=CSAVX; *1BANK
053260                X.CDF1CLTIMER; *2BANK
053262                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK  % REMOVE FROM TIMER TABLE
053265                X.CDF2CLTIMER; *2BANK
053267                CALL FAR RFTMTABLE                   % REMOVE FROM TIMER TABLE
053270             FI; *2BANK
053271             CSAVX+TBLHDLCSIZE=:CSAVX
053274          OD; GO FAR XCHLPS; *)FILL
053305
053305   *PL036=*
053305
053305   % LOCAL SUBROUTINE TO UPDATE THE LOG.DEV.NO TABLE FOR A LINE-PRINTER
053305   %
053305   % ENTRY:     A=I/O-DF
053305   %            D=DMA-DF
053305   %            X=ADDR OF ENTRY IN LINE-PRINTER CONFIG.TABLE (0LPTA)
053305   %            CALLED IN 1BANK MODE
053305   %
053305   INTEGER CSVAA,CSVDD,CXXX1; DOUBLE CSVAD=CSVAA
053310   UPDLPLOGNO:
053310          AD=:CSVAD; X=:CXXX1
053312          IF X.LPLOGNO><0 THEN
053314             A=:D SHZ -6; *2BANK
053317             X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
053326             T:=LOGDBANK; A:=CSVAA; *STATX 10; STZTX          % LOG.NO.IN=0; LOG.NO-OUT=I/O-DF
053332             *1BANK
053333          FI
053333          IF CXXX1.LPDMLOGNO><0 THEN
053336             A=:D SHZ -6; *2BANK
053341             X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
053350             T:=LOGDBANK; A:=CSVDD; *STATX; STZTX 10          % LOG.NO-IN=DMA-DF; LOG.NO-OUT=0
053354             IF A=0 THEN                                      % NOT "DMA-TYPE" LINE-PRINTER
053355                *STZTX 20; STZTX 30                           % CLEAR LOG.NO.TABLE ENTRY FOR "DF-DF"
053357             FI; *1BANK
053360          FI; EXIT
053361   *)FILL
053364   % CLEAR AN ENTRY IN EXTENDED IDENT CODE TABLE FOR LEVEL 11
053364   %
053364   % ENTRY:  A=DF.ADDR TO REMOVE FROM IDENT-CODE TABLE
053364   %
053364   11EIDCLEAR:
053364          IF A><0 THEN
053365             A=:D:="ITE11"-"PITEX"=:X
053371             A:=IPIFPHPAGE SHZ 12; X+A
053374             DO
053374                T:=IPIBANK; *LDATX 10
053376             WHILE A><-1                            % -1: END OF TABLE
053401                IF A=D THEN                         % ENTRY FOUND
053403                   T:=IPIBANK; *STZTX; STZTX 10     % CLEAR ENTRY
053406                   EXIT
053407                FI; X+2
053410             OD
053411          FI; EXIT
053412
053412   % LOCAL SUBROUTINE TO CLEAR A LINE-PRINTER FROM ALL TABLES
053412   %
053412   % ENTRY:  X=ADDR IN LINE-PRINTER DESCRIPTION TABLE (0LPTA)
053412   %         CALLED IN 1BANK MODE
053412   %
053412   INTEGER POINTER CLLPLREG
053413   INTEGER CXX1,CXX2
053415
053415   *PL037=*
053415
053415   CLLPENTRY: A:=L=:"CLLPLREG"
053417          X=:CXX1; *1BANK
053421          X.LPLOGNO; *2BANK
053423          CALL FAR CLLOGNENTRY; *1BANK              % CLEAR MAIN-DF FROM LOG.DEV.NO TABLE
053425          CXX1.LPDMLOGNO; *2BANK
053430          CALL FAR CLLOGENTRY; *1BANK               % CLEAR DMA-DF FROM LOG.DEV.NO TABLE
053432          CXX1.LPDMLOGNO+1; *2BANK
053436          CALL FAR CLLOGENTRY                       % CLEAR DF-DF FROM LOG.DEV.NO TABLE
053437          *1BANK
053440          CXX1+"LPDMDF"=:CXX2
053443          CXX2.S0; *2BANK
053446          CALL FAR RFTMTABLE; *1BANK                % REMOVE FROM TIMER TABLE
053450          CXX2.S1; *2BANK
053453          CALL FAR RFTMTABLE; *1BANK
053455          CXX2.S2; *2BANK
053460          CALL FAR RFTMTABLE; *1BANK
053462          CXX1+"LPIDENT"=:CXX2
053465          CXX1.1LPDMDF; *2BANK
053470          CALL 11EIDCLEAR; *1BANK                   % REMOVE FROM IDENT-CODE TABLE
053472          CXX2.S1; *2BANK
053475          CALL FAR 10IDCLEAR; *1BANK
053477          CXX2.S2; *2BANK
053502          CALL FAR 10IDCLEAR; *1BANK
053504          GO CLLPLREG                               % EXIT
053505   *)FILL
053515
053515   *PL038=*
053515
053515   INTEGER CSXXY,CLPSELECTION
053517   XCHLPS:
053517          "0LPTA"=:CSXXY; *1BANK
053522          DO WHILE CSXXY.LPSELECTION><-1
053527             IF X.LPCLENTRY><0 THEN
053531                CALL CLLPENTRY; GO NXTLP                      % CLEAR ALL TABLE-ENTRIES FOR THIS L-P
053533             FI
053533             IF CSXXY.LPSELECTION=3 THEN
053540                A:=0                                          % NO DMA-DF
053541             ELSE
053542                A-1+"LPDMDF"; X+A; X.S0                       % DMA-DF
053546             FI
053546             A=:D:=CSXXY.LPSELECTION
053551             A-1+"LPIODF"; X+A; X.S0
053555             X:=CSXXY
053556             CALL FAR UPDLPLOGNO                              % UPDATE LOG.DEV.NO TABLE
053557             IF CSXXY.LPSELECTION=1 THEN                      % "DMPR-TYPE" PRINTER
053564                X.2LPIDENT; *2BANK
053566                CALL FAR 10IDCLEAR                            % CLEAR ENTRY IN LEVEL 10 IDENT-CODE-TABLE (ITB10)
053567             ELSE
053570                T:=X.2LPIDENT; A-1+"LPDMDF"; X+A; X.S0=:D
053576                "ITB10"-"PITEX"=:X; *2BANK
053602                A:=MPIFPHPAGE SH 12; X+A+T-1                  % X=ADDR IN IDENT-CODE-TABLE (ITB10)
053607                T:=MPIBANK; A:=D; *STATX; 1BANK               % UPDATE IDENT-CODE TABLE
053613                CSXXY.1LPDMDF; *2BANK
053616                CALL FAR 11EIDCLEAR                           % CLEAR "DMPR-TYPE" L-P FROM EXTENDED-IDENT-CODE-TABLE
053617             FI; *1BANK
053620             1=:CLPSELECTION
053622             DO WHILE CLPSELECTION<<=3
053626                IF CLPSELECTION><CSXXY.LPSELECTION THEN
053633                   A-1+"LPDMDF"; X+A; X.S0; *2BANK            % A=DMA-DF
053640                   CALL FAR RFTMTABLE; *1BANK                 % REMOVE FROM TIMER TABLE
053642                FI; MIN CLPSELECTION
053643             OD
053644   NXTLP:    CSXXY+LPTBSIZE=:CSXXY
053647          OD; *2BANK
053651          GO TDMVC; *)FILL
053663
053663   TDMVC: X:="0DMVT"
053664          DO
053664             X=:CSAVX
053665             *1BANK
053666          WHILE X.DMVSELECTION><-1
053672             IF A><0 THEN                                     % VERSATEC CAN BE USED
053673                IF X.DMVDATFADDR><0 THEN                      % DATAFIELD EXISTS
053675                   A:=200; *TRR IIE; TRA IIC
053700                   T:=X.DMVHDEV+4; *IOXT; TRA IIC
053704                   IF A=0 THEN                                % INTERFACE IS PRESENT
053705                      X.DMVIDENT=:L; X:=X.DMVDATFADDR=:D; *2BANK
053712                      T-4=:X.HDEV                             % UPDATE HDEV IN DATFIELD
053714                      IF L<<"MAX11" THEN
053717                         "ITB11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12
053724                         X+A+L-1; T:=IPIBANK; A:=D; *STATX    % UPDATE IDENT CODE TABLE
053732                      ELSE
053733                         "ITE11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12; X+A
053741                         DO
053741                            T:=IPIBANK; *LDATX
053743                            IF A=-1 GO CLVERS
053746                            IF A=0 THEN
053747                               A:=L; T:=IPIBANK; *STDTX
053752                               GO SCODFF
053753                            FI; X+2
053754                         OD
053755   SCODFF:            FI; X:=D
053756                      IF DVBFPAGE><0 THEN
053760                         *LDA -110,B; SWAP SA CLD DD
053762                         AD SH 12; T:=1770; D+T
053765                         T:=X.CODFF; *DEPO
053767                      ELSE
053770                         A:=X+"CODFF"=:D:=DPITBANK
053774                      FI; AD=:X.VCODFFADDR                    % UPDATE ADDR OF FORM-FEED
053775                      GO NXVERS
053776                   FI
053776                FI
053776             FI; GO CLVERS; *)FILL
054010
054010   *PL039=*
054010
054010   CLVERS:   *2BANK
054011             X:=CSAVX; *1BANK
054013             X.DMVDATFADDR; *2BANK
054015             CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054020             X.DMVDLOGNO; *2BANK
054022             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054025             X.DMVDFLOGNO; *2BANK
054027             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054032             X.DMVIOLOGNO; *2BANK
054034             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054037             X.DMVIDENT; *2BANK
054041             CALL FAR 11IDCLEAR
054042   NXVERS:   *2BANK
054043             X:=CSAVX+TBLVERSATEC
054045          OD; *2BANK
054047          IF MXX21<<"0NX21" THEN                    % GENERATED MORE X21 THAN WANTED TO USE
054053             A*TBLX21SIZE+"CX21TABLE"=:CSAVX
054056             DO WHILE CSAVX.S0><-1
054063                CALL FAR RFTMTABLE                  % REMOVE FROM TIMER TABLE
054064                CSAVX.S1; CALL FAR CLLOGENTRY        % REMOVE FROM LOGICAL NUMBER TABLE
054067                CSAVX+TBLX21SIZE=:CSAVX
054072             OD
054073          FI; GO SSPODEV; *)FILL
054102
054102   *PL040=*
054102
054102   % SET SPOOLING DEVICE NUMBER IN SPOOLING-DATAFIELD ACCORDING TO
054102   % THE VALUES SET UP IN SPOOLING-CONFIG.TABLE (0SPTA)
054102   SSPODEV:
054102          0=:0CINX; "SPTAB"=:CSAVX
054105          DO WHILE 0CINX><MXSPOOLERS AND CSAVX><"COSDA"+1
054116             "0SPTA"+0CINX=:X; *1BANK; LDA ,X; 2BANK
054124             IF A><0 THEN
054125                A=:CSPERI; AD SHZ -6
054127                IF A<<=LGDGMAX THEN
054132                   X:=CNVRT(A)
054134                   IF X >< 0 THEN
054135                     AD SH 6; A/\77+A; X+A+1; T:=LOGDBANK; *LDDTX % D=OUTPUT DF
054143                     IF D><0 THEN
054145                        IF T:=D.TYPRING BIT 5TERM AND T:=X.ZTINFO NBIT 5PCONN THEN
054154                           X:=A; CALL CLBCKTABENTRY            % REMOVE FROM BACKGROUND TABLE
054156                           T:=X.ZDBPROG; 0=:X.ZDBPROG    % CLEAR DBPROG BECAUSE OF TERMINAL TIMER ROUTINE
054160                           IF "BPTMP"=0 THEN
054162                              T.STATUS BONE 5RTOFF=:X.STATUS  % SET DBPROG RTOFF
054166                           FI
054166                        FI
054166                     FI; CSPERI=:CSAVX.SPERI
054171                   FI
054171                FI
054171             FI; MIN 0CINX; CSAVX+SPLEN=:CSAVX
054175          OD; GO CLSYMODEM; *)FILL
054210
054210   % CLEAR UNUSED SYNC-MODEM ENTRIES
054210   CLSYMODEM: 0=:0CINX
054211          DO
054211             0CINX*TBLSYMSIZE+"0SYMTABLE"=:CSAVX=:X; *1BANK
054217          WHILE X.SYMSELECTION><-1
054223             IF X.SYMCLENTRY><0 THEN
054225                X.SYMIDFELT; *2BANK
054227                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054232                X.SYMODFELT; *2BANK
054234                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054237                X.SYMLOGNO; *2BANK
054241                CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054244                X.SYMCIDENT; *2BANK
054246                CALL FAR 10IDCLEAR; X:=CSAVX; *1BANK
054251                X.SYMCIDENT; *2BANK
054253                CALL FAR 12IDCLEAR
054254             FI; *2BANK
054255             MIN 0CINX
054256          OD; *2BANK
054260          GO CLUDMA; *)FILL
054267
054267   *PL041=*
054267
054267   % SUBROUTINE TO TEST IF AN UDMA-TYPE INTERFACE IS PRESENT
054267   % IF PRESENT THEN EXIT ELSE EXITA FI
054267   CCIOXTER:
054267          A:=200; *TRR IIE; TRA IIC; IOXT; TRA IIC
054274          IF A=0 THEN EXIT FI
054276          EXITA
054277
054277   CLUDMA:
054277          "TBUDMA"=:0CINX
054301          DO
054301             X:=0CINX; *1BANK; LDA ,X
054304          WHILE A><-1                                         % -1: END OF TABLE
054307             IF A><0 THEN                                     % DATAFIELD EXISTS
054310                *2BANK
054311                CALL FAR 11EIDCLEAR                           % REMOVE FROM IDENT CODE TABLE
054312                X:=0CINX; *1BANK
054314                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT NORMAL UDMA?
054320                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT VICOM?
054324                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT RTAMTEC
054330   NOUDMA:      *2BANK                                        % INTERFACE DOES NOT EXIST
054331                X:=0CINX; *1BANK; LDA ,X; 2BANK
054335                CALL FAR RFTMTABLE                            % REMOVE FROM TIMER TABLE
054336                X:=0CINX; *1BANK; LDA 1,X; 2BANK
054342                CALL FAR CLLOGENTRY                           % REMOVE FROM LOG.NO.TABLE
054343                GO NXUDMA
054344
054344   UDMOK:       X.S1=:L; *LDA ,X; 2BANK                       % L=IDENT CODE
054350                X:=0CINX; *1BANK; LDX ,X; 2BANK
054354                *COPY SX DD; STA ,X HDEV                      % D=DATAFIELD
054356                "ITE11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12; X+A
054364                DO
054364                   T:=IPIBANK; *LDATX
054366                   IF A=-1 GO NOUDMA                          % END OF ITE11
054371                   IF A=0 THEN                                % FREE ENTRY
054372                      A:=L; T:=IPIBANK; *STDTX                % INSERT IN ITE11
054375                      GO NXUDMA
054376                   FI; X+2
054377                OD
054400             FI
054400   NXUDMA:   *2BANK
054401             0CINX+TUDMSIZE=:0CINX
054404          OD; *2BANK
054406          GO INTDFIELDS; *)FILL
054416
054416   *PL042=*
054416
054416   % COMPUTE THE NUMBER OF DAYS IN FEBRUARY THE YEAR THE SYSTEM
054416   % IS GENERATED
054416   INTDFIELDS:
054416          GENDA(4)-PTBASE(X); D:=0
054422          DO WHILE A>0
054424             A-1; IF D+1>3 THEN D:=0 FI
054432          OD; IF D=1 THEN 35 ELSE 34 FI; A=:CCFEB
054442          X:=GENDA(3)-1; A:=DAMO(X)+1-=:MND
054451          A:=200; *TRR IIE; TRR IIC
054454          A:=10; *TRR ECCR; TRA IIC
054457          IF A><0 THEN
054460             0=:TCNTI
054461          ELSE
054462             A:=4; *TRR ECCR
054464          FI; A:=0; *TRR IIE; TRA PGS; TRA PEA; TRA IIC
054471          GO L0; *)FILL
054477
054477   L0:
054477          A:=-1; FOR X:=0 TO 37 DO A=:DFTBIT(X) OD
054507          A:=TDLPHPAGE-TDFPAGE+1*4=:D:=0; T:=20; *RDIV ST
054517          X:=0; DO WHILE X><A; 0=:DFTBIT(X); X+1 OD
054525          A:=-1; T:=174005
054527          DO WHILE D><0
054531             *EXR ST
054532             D-1; T+10
054534          OD; A=:DFTBIT(X)
054536          4=:GPART; GO STLOP; *)FILL
054543
054543   *PL043=*
054543
054543   STLOP: "TIOBU"=:"CINDADDR"
054545   LOOP:  X:="CINDADDR"; *1BANK; LDF ,X; 2BANK
054551          TAD=:CTIOBENTRY
054552          IF A=-1 THEN
054555             GPART -1=:GPART
054560             IF A=0 GO RETU
054561             GO STLOP
054562          FI
054562          "CINDADDR"+3=:"CINDADDR"
054565          AD:=TBUSZ; A+D+TDISIZ+TDOSIZ; T:=0; DO A-400; T+1; WHILE A>0 OD
054577          IF T>A:=4 THEN CALL ERRFATAL FI
054603          IF GPART><T GO LOOP
054606          IF TRLND=0 GO LOOP
054610          TRLND; CALL LOGPH; IF A=0 THEN CALL ERRFATAL FI
054614          A=:0DFADDR
054615          DFTINDX=:DFTEND; GPART=:L
054621   DLOOP: DFTBIT(DFTINDX)=:DFTELM
054624          IF A><-1 THEN
054627             T:=175005; 0=:FREBIT=:BTNUM
054632             FOR X:=-20 DO
054633                A:=DFTELEM; *EXR ST
054635                GO NTFBIT; MIN FREBIT
054637                IF FREBIT=L THEN
054642                   X=:CSAVX:=4; A:=BTNUM=:D:=0; *RDIV SX
054650                   IF D+1>=L THEN
054653                      A=:X:=DFTINDX*4+X
054657                      A SH 2 ; D-L ; A+D=:L
054663                      BTNUM SHZ 3; T:=174205; T+A; DFTELM
054670                      FOR X:=FREBIT- DO; *EXR ST
054673                        T-10
054674                      OD
054675                      A=:DFTBIT(DFTINDX)
054677                      A:=L; CALL FAR MAKETDFS; GO LOOP
054702                   FI
054702                   A:=D=:FREBIT; X:=CSAVX
054705                FI; GO FBIT
054706   NTFBIT:      0=:FREBIT
054707   FBIT:        T+10; MIN BTNUM
054711             OD
054712          FI
054712          IF DFTINDX+1=40 THEN "0" FI; A=:DFTINDX
054721          IF A=DFTEND THEN CALL ERRFATAL FI
054725          GO DLOOP; *)FILL
054736
054736   *PL044=*
054736
054736   INTEGER XBONE(0); *BSET ONE DX
054737   RETU:  FOR X:=0 TO 17 DO     % ALL FOUND MEMORY IS INITALLY SET TO MPM5 MEMORY
054743             IF TMMAP(X)><0 THEN
054745                X=:CSAVX; A=:XA:=X SH 12=:CURRPAGE
054752                FOR X:=-20 DO
054753                   IF XA BIT "0" THEN               % MEMORY BANK EXSIST
054756                      T:=KMPM5; A:=CURRPAGE; CALL SMEMTYPE
054761                   FI; XA SHZ -1=:XA
054764                   CURRPAGE+100=:CURRPAGE
054767                OD; X:=CSAVX
054771             FI
054771          OD
054773          0=:MEMTYPE
054774          A:=200; *TRR IIE; TRA IIC
054777   *"8BEX1
"054777          T:=100000; *IOXT; TRA IIC
055002          IF A=0 THEN MEMTYPE BONE BBEXPANDER=:MEMTYPE FI
055006   *"
"055006          *IOX 750; TRA IIC
055010          IF A=0 THEN MEMTYPE BONE BMPM3=:MEMTYPE FI
055014          A:=4; T:=100115; *IOXT; TRA IIC
055020          IF A=0 THEN MEMTYPE BONE BMECCR=:MEMTYPE FI
055024   *"8MPM4
"055024          0=:NBUSCN; 0=:XA
055026          FOR NBUSCN TO 17 DO
055032             A:=NBUSCN*4+100200=:T; *IOXT; TRA IIC
055040             IF A=0 THEN
055041                NBUSCN SH 3+XBONE; X:=XA
055045                *EXR SX                                % BSET BONE XX DD
055046                X=:XA
055047                MEMTYPE BONE BMPM4=:MEMTYPE
055052                T+3; A:=100; *IOXT                      % ENABLE READ LIMITS
055055                T-3; *IOXT                              % READ LIMITS
055057                A=:D/\377 SH 6:=:D SHZ -10 SH 6:=:D
055066                IF A><D THEN D-1 ELSE A:=0; D:=0 FI     % TEST FOR EMPRY MPM4 PORT
055074             ELSE
055075                A:=0; D:=0
055077             FI; X:=NBUSCN+X; AD=:DMPM4(X)
055102          OD; XA=:NBUSCN
055110          GO MMMM4; *)FILL
055124   MMMM4:
055124   *"8MPM4
"055124          IF MEMTYPE NBIT BMPM4 THEN
055127             T:=MPIFPHPAGE SH 12
055131             A:="ITB13"-"PITEX"+17+T=:X+20=:D; T:=MPIBANK
055141             DO WHILE X<<D
055143                *STZTX; AAX 1
055145             OD
055146          FI
055146   *"
"055146
055146   *PL045=*
055146          IF MEMTYPE BIT BMPM3 THEN CALL MPM3MAP FI
055152          IF MEMTYPE BIT BMPM4 OR A BIT BMECCR THEN CALL MPM4MAP FI
055160          X:=0
055161          DO WHILE X<<50                  % DEFINE PIOC-MEMORY
055164             *1BANK
055165             AD:=MMPIOCS(X)
055166             *2BANK
055167             IF A><0 THEN
055170                A=:CURRPAGE:=D=:NPAGES
055173                DO WHILE CURRPAGE<<=NPAGES
055177                   A:=CURRPAGE; T:=KMPIOC; CALL SMEMTYPE
055202                   CURRPAGE+100=:CURRPAGE
055205                OD
055206             FI; X+2
055207          OD; GO SMPM4MEM; *)FILL
055220   SMPM4MEM:
055220   *"8MPM4
"055220          0=:XA
055221          FOR XA TO 17 DO
055225             X:=XA+X; AD:=DMPM4(X); A=:CURRPAGE:=D=:NPAGES
055233             DO WHILE CURRPAGE<<NPAGES
055237                A:=CURRPAGE; T:=KMPM4; CALL SMEMTYPE
055242                CURRPAGE+100=:CURRPAGE
055245             OD
055246          OD
055252   *"
"055252          GO FN5MEM; *)FILL
055255
055255   *PL046=*
055255
055255   FPMPMPAGE: K:="0"; GO FMPMFELLS                  % FIND FIRST PAGE IN MPM MEMORY
055257   LPMPMPAGE: K:=1                                  % FIND FIRST PAGE NOT IN MPM MEMORY
055260   FMPMFELLS:
055260          A=:D
055261          DO WHILE D<<ENDPAGE
055264             A:=D SHZ -7+MEMARRAY=:X; T:=MBMEMARRAY; *LDATX
055272             IF D BIT 6 THEN A/\377 ELSE A SHZ -10 FI
055277             IF A=KMPM3 OR A=KMPM4 OR A=KMPM5 THEN
055310                IF K NBIT THEN A:=D; EXITA FI                    % FIRST PAGE IN MPM PART
055314             ELSE
055315                IF K THEN A:=D; EXITA FI                         % FIRST PAGE IN NOT-MPM PART
055321             FI; A:=100; D+A
055323          OD; A:=D; EXIT
055326          *)FILL
055332
055332   FN5MEM:
055332          A:=0; CALL FPMPMPAGE; A:=-1; A=:FPIMPM                 % DETERMINE FIRST PAGE IN MULTIPORT
055336          IF X:=PN500D><0 AND X.ADRZERO=-1 THEN                  % MEMORY NOT DEFINED FOR ND-500
055344             0=:0CINX; 0=:CURRPAGE
055346             DO WHILE 0CINX<20                                   % 20 IS MAX MERMORY PARTS
055352                CURRPAGE; CALL FPMPMPAGE; GO FMPM5; A=:CURRPAGE  % FIRST MPM PAGE IN MEMORY PART
055356                IF PN500D.ADRZERO=-1 THEN CURRPAGE=:X.ADRZERO FI % ND-500 PAGE ZERO
055365                CURRPAGE-X.ADRZERO; T:=0CINX; *AAX AMEMT         % START OF MEMORY PART
055371                X+T; A=:X.S0; PN500D+"TYPMTAB"=:T
055376                A:=7; X:=0CINX; *SBYT                            % MEMORY PART TYPE
055401                MIN 0CINX
055402                CURRPAGE; CALL LPMPMPAGE; P+0; A=:CURRPAGE       % FIRST PAGE IN NEXT MEMORY PART
055406                A-PN500D.ADRZERO; T:=0CINX; *AAX AMEMT
055412                X+T; A=:X.S0; PN500D+"TYPMTAB"=:T
055417                A:=0; X:=0CINX; *SBYT                            % MEMORY PART TYPE (NOT MPM MEMORY)
055422                MIN 0CINX
055423             OD
055424          FI
055424   FMPM5: X:=MEMARRAY; A:=X+200=:D
055430          DO WHILE X<<D
055432             T:=MBMEMARRAY; *LDATX
055434             IF A SHZ -10=KMPM5 GO SMPM5
055440             T:=MBMEMARRAY; *LDATX
055442             IF A/\377=KMPM5 GO SMPM5
055446             X+1
055447          OD; GO MEMFINE
055451   SMPM5: MEMTYPE BONE BMPM5=:MEMTYPE
055454          GO MEMFINE; *)FILL
055465
055465   *PL047=*
055465
055465   MEMFINE:
055465          A:=RTSGFPHPAGE=:RTSYSG              % FIRST FPHYS.PAGE IN RT'S SYS.SEG
055467          A:=CDABLPAGE+XXSWTYPE=:D:=0; AD=:DDASA
055474          A:="9ESGT"=:D:=0; T:=5SEGSIZE; *RDIV ST
055501          A-1=:SGMAX
055503          5FILSEG*5SEGSIZE+SEGSTART=:FILSEGM
055507   *"8FLMN
"055507          55MOSEG*5SEGSIZE+SEGSTART=:5NSEGM
055513   *"8RFAC
"055513          5FIUS  *5SEGSIZE+SEGSTART=:FUSEGM
055517   *"
"055517   % INITIALIZE ALL BACKGROUND PROGRAMS WITH SYSTEM SEGMENT AND OP.COM SEGMENT
055517          CFSYSEG=:D
055521          X:="9FBPR"
055522          DO WHILE X<<="9LBPR"-5RTSIZE
055526             A:=5OPSEG; AD=:X.DSEGM; D+1; D+1
055532             X+5RTSIZE
055533          OD
055534
055534   *PL048=*
055534
055534   % BUILD SEGMENTS.
055534
055534          AD:=ECODPHPAGE; T:=5ECOM; CALL FAR SGBUILD
055537          AD:=RPIDPHPAGE; T:=5RPIT; CALL FAR SGBUILD
055542          AD:=MPIDPHPAGE; T:=5MPIT; CALL FAR SGBUILD
055545          AD:=IPIDPHPAGE; T:=5IPIT; CALL FAR SGBUILD
055550          AD:=DPIDPHPAGE; T:=5DPIT; CALL FAR SGBUILD
055553          AD:=DEDPHPAGES; T:=42; CALL FAR SGBUILD
055556          AD:=5PIDPHPAGES; T:=55PIT; CALL FAR SGBUILD
055561   *"8FLMN
"055561          GO DOCOMPRESS; *)FILL
055576
055576   INTEGER POINTER TMTCLREG
055577   TMTCOMPRESS: A:=L=:"TMTCLREG"
055601          DO WHILE X<<TMRADDR
055604             T:=RPIBANK; *LDATX
055606             IF A=0 THEN
055607                A:=ETMRADDR; CALL COMPTMRTABLE
055611                TMRADDR-1=:TMRADDR
055614             ELSE
055615                X+1
055616             FI
055616          OD; GO TMTCLREG
055620
055620   *PL049=*
055620
055620   DOCOMPRESS:
055620   % COMPRESS THE EXTENDED-IDENT-CODE TABLES
055620          X:="ITE10"; CALL FAR EIDCMPIT
055622          X:="ITE11"; CALL FAR EIDCIPIT
055624          X:="ITE12"; CALL FAR EIDCMPIT
055626          X:="ITE13"; CALL FAR EIDCMPIT
055630
055630   % COMPRESS THE FIRST PART OF THE TIMER TABLE
055630          A:=RPIFPHPAGE SHZ 12=:D
055633          "M1TMR"-"PITEX"+1+D=:X
055640          "9SXTD"-"PITEX"-1+D=:ETMRADDR
055645          "8USTM"-"PITEX"+D=:TMRADDR
055651          CALL TMTCOMPRESS
055652
055652   % COMPRESS THE LAST PART OF THE TIMER TABLE
055652          A:=RPIFPHPAGE SHZ 12=:D
055655          "9SXTD"-"PITEX"+1+D=:X
055662          "ETMRT"-"PITEX"+D=:ETMRADDR=:TMRADDR
055667          CALL TMTCOMPRESS
055670
055670   % CHANGE CLEAR-CACHE INSTRUCTION WITH "RAND 0 0"
055670          IF HWINFO(0)/\ 377 >=3  THEN        % ND-110/CX , ND-120/CX
055676             "PITEX"=:L; MPIFPHPAGE SH 12=:D
055703             D-L; 0=:0CINX
055705             DO WHILE X:=CCMPIT(0CINX)><-1
055712                IF X><0 THEN
055713                   X+D; T:=MPIBANK; *LDA (RAND; STATX
055717                FI; MIN 0CINX
055720             OD; RPIFPHPAGE SH 12=:D
055724             D-L; 0=:0CINX
055726             DO WHILE X:=CCRPIT(0CINX)><-1
055733                IF X><0 THEN
055734                   X+D; T:=RPIBANK; *LDA (RAND; STATX
055740                FI; MIN 0CINX
055741             OD
055742          FI; GO UPDMICP; *)FILL
055764
055764   *PL050=*
055764
055764   UPDMICP:
055764
055764   % UPDATE THE SEGMENT ADMINISTRATION WITH THE ALTERNATIVE ROUTINES
055764   % IF THIS CPU HAS THE NEW "K-VERSION MICRO PROGRAM"
055764          IF HWINFO(0)/\377 >=3 THEN             % ND-110/CX , ND-120 OR LATER VERSION
055772             T:=MPIFPHPAGE SHZ -6                % MEMORY BANK FOR MPIT
055774             "PITEX"=:L; MPIFPHPAGE/\77 SH 12=:D
056002             D-L
056003             0=:0CINX
056004             DO WHILE X:=VSXMMICP(0CINX)><A:=-1
056011                IF X >< 0 THEN
056012                    X+D; *LDA (RAND; STATX
056015                FI
056015                MIN 0CINX
056016             OD
056017             T:=IPIFPHPAGE SHZ -6                % MEMORY BANK FOR IPIT
056021             "PITEX"=:L; IPIFPHPAGE/\77 SH 12=:D
056027             D-L
056030             0=:0CINX
056031             DO WHILE X:=VSXIMICP(0CINX)><A:=-1
056036                IF X >< 0 THEN
056037                    X+D; *LDA (RAND; STATX
056042                FI
056042                MIN 0CINX
056043             OD
056044          FI
056044          GO SETPTABL
056045   RBUS
056053
056053   SUBR MAKETDFS
056053   %=============================================================================
056053   %            M A K E T D F S       M A K T A D D F
056053   %
056053   % LOCAL SUBROUTINES TO THE INTDFIELDS ROUTINE
056053   %
056053   % MAKEDFS:   CREATES TERMINAL DATAFIELDS OUTSIDE RESIDENT
056053   %            0DFADDR= RESIDENT DATAFIELD ADDR
056053   %            L= DISPLACEMENT OF DATAFIELD RELEATIVE TO START OF DATAFIELD AREA
056053   %            CTIOBENTRY= CURRENT TIOBTAB ENTRY
056053   %
056053   % MAKTADDF:  CREATES TAD DATAFIELDS OUTSIDE RESIDENT
056053   %            X-REG = RESIDENT DATAFIELD, T-REG = TAD INDEX
056053   %
056053
056053   INTEGER IDFTFLAG=?,ODFTFLAG=?,IZPAIRDF=?,OZPAIRDF=?
056053
056053       INTEGER SVA
056054       INTEGER SVD
056055       DOUBLE  SVDD=SVA
056055
056055   MAKETDFS: A:=:L=:"CLINK"
056057          A:=TDFPAGE=:D:=0; AD SHZ 12
056063          AD =: SVDD ; L=:D    ; A:=0
056066          AD SH 10   ; A:=:D   ; A+SVD
056071          A:=:D      ; A:=A+C  ; A+SVA
056074          AD=:CDDMADDR                                  % CDDMADDR=PHYS. ADDR. OUTSIDE RESIDENT
056075          FOR X:="XTDFELT" TO "XEDFELT"-1 DO 0=:X.S0 OD % CLEAR WORKING AREA
056105   %
056105   %      INITIALIZE INPUT DF OUTSIDE RESIDENT
056105   %
056105          0DFADDR=:B; IF TYPRING NBIT 5TERM THEN CALL ERRFATAL FI
056113          X:="XTDFELT"+TDINDI; *LDA ,B ZTINF+9CXTI
056116          A=:X.TINFO; IF A NBIT 5PRINT THEN T:=ZDBPROG=:X.DBPROG FI
056123          T:="TTGET"=:X."IOTRANS"; T:="TEXIT"=:X."STDEV"
056127          T:="CTRTI"=:X."SETDV"; "0" BONE 5LBLOG=:X.FLAGB        % ALWAYS LOGOUT ON MISSING CARRIERE
056134          HDEV=:X.HDEV; ZCESCP=:X.CESCP; ZDFLAG=:X.DFLAG
056142          -1=:X.RSISTE; ZROUSPEC=:X."ROUSPEC"; ZCTTYP=:X.CTTYP
056150          "ECH0"=:X.ECHOTAB; "BRK0"=:X.BRKTAB; 5TMR=:X.TMR=:X.TTMR
056157          TYPRING=:X.TYPRING; A:=B=:X.TDRADDR
056163          "SBFIELD"=:B
056165          A:=2CDDMADR/\1777+"WND41*2000"+TDISIZ+BINSZ+TDONDI=:X.DFOPP
056174          TDIPDI+1+BINSZ+TDONDI=:X.XOPPDF
056201          A:=2CDDMADR/\1777+TDISIZ=:X.BUFST
056205          BINSZ+BINSZ=:X.MAX=:X.CFREE
056211          0DFADDR=:B+"9CXTI"=:X.XDFOPP
056215   *IFILL
056231   %
056231   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056231   %
056231          *LDA ,B ZDFTY+9CXTI
056232          A=:IDFTFLAG GOSW ITRM,ITFX,ITFX,INTS,IMTA
056241   *)FILL
056241   ITRM:  "TYENT"=:X."DRIVER"; "STTIN"=:X."STDRIV"
056245          "TTIMR"=:X."TMSUB"
056247          ZXONOFCR/\377=:X.XONCR; ZXONOFCR SHZ -10=:X.XOFCR
056255          ZTSPEED=:X.TSPEED; ZCNTREG=:X.CNTREG
056261          GO MOVI
056262   ITFX:  T:=ZPAIRDF=:X.PAIRDF=:IZPAIRDF
056265          IF A=1 THEN
056270             "ERRFATAL"=:X."STDRIV"
056272             "TFRSTDEV"=:X."TMSUB"=:X."STDEV"
056275             "TFRSETDV"=:X."SETDV"; "TFRGET"=:X."IOTRANS"
056301          ELSE
056302             "TFINPUT"=:X."STDRIV"; "TEXIT"=:X."TMSUB"
056306          FI
056306          GO MOVI
056307   INTS:  *LDA ,B 9CXTI                                      % WINDOW ADDRESS
056310          A=:X.MNWAD; *LDA ,B 9CXTI+2                        % CONTROLLER ADDRESS
056312          A=:X.MNCDF:=0=:X.MNTMFL=:X.TMR=:X.TTMR
056317          "MNITI"=:X."TMSUB"; "MNINS"=:X."STDRIV"
056323          "MNMAI"=:X."DRIVER"
056325          X.FLAGB BONE 5LSTA=:X.FLAGB
056330          GO MOVI
056331   IMTA:  BMTDFLI=:X.MTDFLI; A:=B=:BMTDFLI                 % LINK DF
056335          0=:X.MTMBPH; 1=:X.MTFLAG
056340          "MTITI"=:X."TMSUB"; "MTINS"=:X."STDRIV"
056344          "MTIND"=:X."DRIVER"
056346          0=:X.TMR=:X.TTMR; X.FLAGB BONE 5LSTA=:X.FLAGB
056353   MOVI:  "SBFIELD"=:B
056355          X:=1CDDMADR; T:=2CDDMADR; A:=TDISIZ=:L:="XTDFELT"=:D:=0; *MOVAP
056365          GO RDFI
056366   *)FILL
056411   INTEGER IDFTFLAG,IZPAIRDF
056413   %
056413   %      INITIALIZE INPUT RESIDENT DF
056413   %
056413   RDFI:  A:=2CDDMADR+TDINDI=:0DFADDR.TDFLGADDR
056417          AD:=CDDMADR SHZ -12; A:=D=:X.TDFPHPAGE
056423          0=:X.RESLINK=:X.RTRES; X=:X.BWLINK; 0=:X.ISTATE=:X.MLINK
056430   %
056430   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056430   %
056430          IDFTFLAG GOSW IRTR,IRTF,IRTF,IRNT,IRMT
056437   *)FILL
056437   IRTR:  "STTIN"=:X."STDRIV"; "TYENT"=:X."DRIVER"
056443          GO OUTPUT
056444   IRTF:  T:=IZPAIRDF=:X.PAIRDF
056446          IF A=1 THEN "ERRFATAL" ELSE "TFINPUT" FI; A=:X."STDRIV"
056455          GO OUTPUT
056456   IRNT:  T:="MNINS"=:X."STDRIV":="MNMAIN"=:X."DRIVER"
056462          GO OUTPUT
056463   IRMT:  T:="MTINS"=:X."STDRIV":="MTIND"=:X."DRIVER"        % DRIVER ADDRESSES IN RES. OUTP. DF
056467   *IFILL
056500   OUTPUT:
056500          FOR X:="XTDFELT" TO "XEDFELT" DO 0=:X.S0 OD            % CLEAR WORKING AREA
056507          0DFADDR+"9CXTI"=:B
056512          IF TYPRING NBIT 5TERM THEN CALL ERRFATAL FI
056516          X:="XTDFELT"+TDONDI
056520   %
056520   %      INITIALIZE OUTPUT DF OUTSIDE RESIDENT
056520   %
056520          "TTOMR"=:X."TMSUB"; "DMOUT"=:X."STDEV"
056524          "0" BONE 5EMPT=:X.BITFLAG; -10=:X.TTMR
056531          HDEV=:X.HDEV; "TRTPUT"=:X."IOTRANS"; "CTRTO"=:X."SETDV"
056537          TYPRING=:X.TYPRING
056541          "SBFIELD"=:B
056543          A:=2CDDMADR/\1777+"WND41*2000"+TDINDI=:X.DFOPP
056550          TDIPDI+1+BINSZ+TDONDI-=:X.XOPPDF
056556          A:=2CDDMADR/\1777+TDISIZ+TDOSIZ+BINSZ=:X.BUFST
056564          BOUSZ+BOUSZ=:X.MAX=:X.CFREE SHZ -1=:X.MINBHOLD
056572          0DFADDR+"9CXTI"=:B=:X.TDRADDR; A-"9CXTI"=:X.XDFOPP
056600   *IFILL
056613   %
056613   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056613   %
056613          ZDFTYP=:ODFTFLAG GOSW OTRM,OTFX,OTFX,ONTS,OMTA
056623   *)FILL
056623   OTRM:  "DWRITE"=:X."DRIVER"=:X."STDRIV"
056626          ZXONOFCR/\377=:X.XONCR; ZXONOFCR SHZ -10=:X.XOFCR
056634          GO MOVO
056635   OTFX:  T:=ZPAIRDF=:X.PAIRDF=:OZPAIRDF
056640          IF A=1 THEN
056643             "ERRFATAL"=:X."STDRIV"
056645             "TEXIT"=:X."TMSUB"; "TFRSTDEV"=:X."STDEV"
056651          ELSE
056652             "TFWRITE"=:X."STDRIV"; "TTOMR"=:X."STDEV"
056656          FI
056656          GO MOVO
056657   ONTS:  *LDA ,B 1                               % BANK NO OF WINDOW AREA
056660          A=:X.MNWBNK
056661          "MNOTI"=:X."TMSUB"; "MNOUS"=:X."STDRIV"
056665          "MNMAIN"=:X."DRIVER"; "MNOST"=:X."STDEV"
056671          GO MOVO
056672   OMTA:  0=:X.TMR=:X.TTMR
056674          "MTOTI"=:X."TMSUB"; "MTOUS"=:X."STDRIV"
056700          "MTOUD"=:X."DRIVER"; "MTOST"=:X."STDEV"
056704
056704   MOVO:  "SBFIELD"=:B
056706          X:=1CDDMADR; A:=2CDDMADR+TDISIZ+BINSZ=:T
056713          A:=TDOSIZ=:L:="XTDFELT"=:D:=0; *MOVAP
056721          GO RDFO
056722   *)FILL
056743   INTEGER ODFTFLAG,OZPAIRDF
056745   %
056745   %      INITIALIZE OUTPUT RESIDENT DF
056745   %
056745   RDFO:  0DFADDR+"9CXTI"=:X
056750          A:=2CDDMADR+TDISIZ+TDONDI+BINSZ=:X.TDFLGADDR
056755          AD:=CDDMADR SHZ -12; A:=D=:X.TDFPHPAGE
056761          0=:X.ISTATE=:X.RESLINK=:X.RTRES=:X.MLINK; X=:X.BWLINK
056766   %
056766   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056766   %
056766          ODFTFLAG GOSW ORTR,ORTF,ORTF,ORNT,ORMT
056775   ORTR:  "DWRITE"=:X."DRIVER"=:X."STDRIV"
057000          GO END
057001   ORTF:  T:=OZPAIRDF=:X.PAIRDF
057003          IF A=1 THEN "ERRFATAL" ELSE "TFWRITE" FI; A=:X."STDRIV"
057012          GO END
057013   ORNT:  T:="MNOUS"=:X."STDRIV":="MNMAIN"=:X."DRIVER"
057017          GO END
057020   ORMT:  T:="MTOUS"=:X."STDRIV":="MTOUD"=:X."DRIVER"
057024
057024   END:   AD:=CDDMADR; T:=400; D+T; A:=A+C; AD=:CDDMADR
057031          GO CLINK
057032   *)FILL
057042
057042   SYMBOL TSLAK=3               % ADDITIONAL LOCATIONS IN INPUT DATAFIELD
057042
057042   MAKTADDF: A:=L=:"CLINK"; X=:0DFADDR
057045          A:=FTADPAGE=:D:=0; AD SHZ 12=:DTDFADDR; A:=200; *RMPY ST DA
057054          A:=:D+2TDFADDR; A:=:D; A:=A+C+1TDFADDR; AD=:DTDFADDR
057062          FOR X:="XTDFELT" TO "XEDFELT" DO 0=:X.S0 OD
057071          0DFADDR=:B; IF TYPRING NBIT 5BAD THEN CALL ERRFATAL FI
057077          X:="XTDFELT"+TAINDI
057101          ZDBPROG=:X.DBPROG; ZNOBUF=:X.NOBUF; ZFBSIZ=:X.FBSIZ
057107          ZTADTYP=:X.TADTYP; ZCTTYP=:X.CTTYP; ZCESCP=:X.CESCP
057115          TYPRING=:X.TYPRING
057117          "ECH0"=:X.ECHOTAB; "BRK0"=:X.BRKTAB; "TEXIT"=:X."TMSUB"
057125          "BDGET"=:X."IOTRANS"; "TEXIT"=:X."STDEV"; "CTIBAD"=:X."SETDV"
057133          A:=B=:X.TDRADDR
057135          "SBFIELD"=:B; 0DFADDR+"9CXTI"=:X.XDFOPP
057142          A:=2TDFADDR/\1777+"WND41*2000"+TAISIZ+TSLAK+TAONDI=:X.DFOPP
057151          A:=2TDFADDR+TAINDI=:0DFADDR.TDFLGADDR
057155          AD:=DTDFADDR SHZ -12; A:=D=:X.TDFPHPAGE
057161          0=:X.RESLINK=:X.RTRES; A:=X=:X.BWLINK; 0=:X.ISTATE=:X.MLINK
057167          GO MKTD1; *)FILL
057204
057204   MKTD1: 0DFADDR+"9CXTI"=:0DFADDR=:B
057210          IF TYPRING NBIT 5BAD THEN CALL ERRFATAL FI
057214          X:="XTDFELT"+TAISIZ+TSLAK+TAONDI
057220          TYPRING=:X.TYPRING
057222          "BDTOU"=:X."TMSUB"; -3=:X.TTMR; "BDPUT"=:X."IOTRANS"
057230          "TEXIT"=:X."STDEV"; "CTOBAD"=:X."SETDV"
057234          A:=B=:X.TDRADDR
057236          "SBFIELD"=:B
057240          A:=2TDFADDR/\1777+"WND41*2000"+TAINDI=:X.DFOPP
057245          0DFADDR-"9CXTI"=:X.XDFOPP
057250          X:=1TDFADDR; T:=2TDFADDR
057252          A:=TAISIZ+TSLAK+TAOSIZ=:L:="XTDFELT"=:D:=0; *MOVAP
057262          A:=2TDFADDR+TAISIZ+TSLAK+TAONDI=:0DFADDR.TDFLGADDR
057270          AD:=DTDFADDR SHZ -12; A:=D=:X.TDFPHPAGE
057274          0=:X.ISTATE=:X.RESLINK=:X.RTRES=:X.MLINK; A:=X=:X.BWLINK
057302          GO CLINK
057303   RBUS
057314
057314   %=======================================================================
057314   %       (C)   M N H D S J
057314   %
057314   % ROUTINE TO FIND NOTS INTERFACES
057314   %
057314   % MEMORY ACCESSES ARE DISABLED TO HIDE MEMORY FOR SINTRAN
057314   %
057314   SUBR MNHDSJ
057314   INTEGER FLG:=0,CC1
057316   INTEGER POINTER LREG
057317   MNHDSJ: A:=L=:"LREG":=200; *TRR IIE; TRA IIC         % ENABLE IOX-ERRORS
057324           "MNTAB"=:CC1
057326           DO WHILE X:=CC1.S0 >< -1
057333              IF X >< 0 THEN
057334                 T:=X.HDEV+5; 20; *IOXT; TRA IIC        % TRY TO CLEAR MBNIU
057341                 IF A-7=0 THEN                          % IOX ERROR
057343                    "0"=:CC1.S0                         % CLEAR ELEMENT IN MNTAB
057346                 ELSE
057347                    IF FLG=0 THEN X=:CURNOTS; CC1=:PMNTA; 1=:FLG FI
057356                    T-1; *IOXT; SHA ZIN SHR 10          % READ BANK NO
057361                    A+1=:X.MNCBNK
057363              FI;FI
057363              MIN CC1
057364           OD
057365           GO LREG
057366   RBUS
057372
057372   %=======================================================================
057372   %       (C)   M N A L L O C
057372   %
057372   % ROUTINE TO ALLOCATE TERMINAL DATAFIELDS TO A NOTS CONTROLLER
057372   % CALLED FROM "XCHIOX" WHEN IOX ERROR
057372   %
057372   % ENTRY: X = DF ADDRESS
057372   % EXIT:  DF IS USED FOR NOTS
057372   % EXITA: DF IS NOT USED FOR NOTS
057372   %
057372   SUBR MNALLOC
057372   INTEGER CCN:=0
057373   MNALLOC:IF CURNOTS = -1 THEN EXITA FI                      % NO MORE MBNIUS
057400           X=:D
057401           IF X.HDEV NBIT 2 THEN
057404              CURNOTS."MNIDF"+CCN=:X                          % INPUT DF
057410              A:=D=:X.S0; D=:X
057413              0=:X.HDEV
057414           ELSE
057415              CURNOTS."MNODF"+CCN=:X                          % OUTPUT DF
057421              A:=D=:X.S0; D=:X; "0"=:X.HDEV; 3=:X.ZDFTYP      % 3 IN ZDFTYP TO INDICATE NOTS TERMINAL
057430              CCN*4000=:X.S0; CURNOTS.MNCBNK-1=:D.S1          % WINDOW ADDRESS AND WINDOW BANK NO.
057440              CURNOTS=:X.S2; CCN+1=:CCN
057445           FI
057445           IF CCN=40 THEN                                     % THIS MBNIU FILLED UP ?
057451              X:=PMNTA+1                                      % POINTS TO NEXT ELEMENT IN MNTAB
057453              DO WHILE X.S0=0 AND A><-1; X+1; OD              % FIND NEXT ELEMENT
057462              A=:CURNOTS; X=:PMNTA; 0=:CCN                    % CURNOTS = -1 AT END
057465           FI
057465           EXIT
057466   RBUS
057471
057471   %=======================================================================
057471   %       (C)   M T A L L O C
057471   %
057471   % ROUTINE TO ALLOCATE TERMINAL DATAFIELDS TO MTAD
057471   % CALLED FROM "XCHIOX" WHEN IOX ERROR
057471   %
057471   % ENTRY: X=DF ADDRESS
057471   % EXIT:  DF ALLOCATED TO MTAD
057471   % EXITA: DF NOT ALLOCATED
057471   %
057471   SUBR MTALLOC
057471   INTEGER CNO:=1
057472   MTALLOC:IF CNO > MTMAX THEN EXITA FI                      % NO MORE MTADS
057477           IF X.HDEV BIT 2 THEN
057502              4=:X.ZDFTYP; MIN CNO                          % INDICATE MTAD
057505           FI
057505           0=:X.HDEV
057506           EXIT
057507   RBUS
057510
057510   %==============================================================================
057510   %            C O M P T M R T A B L E
057510   %
057510   % SUBROUTINE TO COMPRESS THE TIMER-TABLE
057510   %
057510   % ENTRY:     X=DESTINATION ADDR IN TIMER TABLE
057510   %            T=MEMORY BANK OF TIMER TABLE
057510   %            A=END OF TIMER TABLE
057510   %
057510   SUBR COMPTRMTABLE
057510
057510   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
057514   INTEGER POINTER LREG
057515
057515   COMPTMRTABLE: TAD=:TADREG; X=:XREG:=:L=:"LREG"
057521          X:=L:=:T; L:=:A-A; D:=T+1; A:=X; *MOVPP
057530          TAD:=TADREG; X:=XREG
057532          GO LREG
057533   RBUS
057533
057533   %==============================================================================
057533   %            C L B C K T A B E N T R Y
057533   %
057533   % SUBROUTINE TO CLEAR AN ENTRY IN THE BACKGROUND TABLE
057533   %
057533   % ENTRY:     A=DATAFIELD ADDRESS TO CLEAR FROM THE BACKGROUND TABLE
057533   %
057533   SUBR CLBCKTABENTRY
057533   INTEGER TREG,AREG,DEREG,XREG; TRIPLE TADREG=TREG
057537   INTEGER POINTER LREG
057540   CLBCKTABENTRY: TAD=:TADREG; X=:XREG:=L=:"LREG"
057544          X:=0
057545          DO WHILE BACKTAB(X)><-1
057551             IF A=AREG THEN
057554                0=:BACKTAB(X)
057555   *"-8BACS
"057555                GO OUT
057556             FI; X+1
057557          OD
057560   OUT:   TAD:=TADREG; X:=XREG
057562          GO LREG
057563   RBUS
057564
057564   %===============================================================================
057564   %       G E T A R E A     Y G E T A R E A
057564   %
057564   %  SUBROUTINE TO ALLOCATE CONTINUOUS AREA IN MEMORY
057564   %
057564   % ENTRY: A=FIRST PAGE TO TEST
057564   %        B=SBFIELD IN SINTR
057564   %        X=NUMBER OF PAGES IN AREA
057564   %        T=LAST POSSIBLE PAGE IN AREA
057564   %
057564   %         GETAREA: ALLOCATES PAGES FROM A UPP TO T
057564   %                  AND TEST THAT WHOLE AREA IS IN ONE BANK
057564   %        YGETAREA: ALLOCATES PAGES FROM A DOWN TO T
057564   %                  (CALLED WHEN ALLOCATING PAGES TO RT-COMMON)
057564   %        ZGETAREA: SAME AS GETAREA BUT CAN CROSS MEMORY BANK
057564   % EXIT:  AREA NOT FOUND
057564   %
057564   % EXIT+1: AREA FOUND, A=FIRST PAGE IN AREA
057564   %
057564   SUBR GETAREA,YGETAREA,ZGETAREA
057564
057564   INTEGER ROUTSWITCH=?,PIOCTESTED=?,CCAA=?
057564
057564   YGETAREA: TAD=:XTAD; T:=0; GO XGT1
057567   GETAREA:  TAD=:XTAD; T:=1; GO XGT1
057572   ZGETAREA: TAD=:XTAD; T:=2
057574   XGT1:  X=:NPAGES; X-=:XXX; A:=L=:"CLINK"
057601          "EMMLIM"-"DMMLIM"=:0CINX
057604          XA=:CCAA; T=:ROUTSWITCH; 0=:PIOCTESTED
057610          GO AGAIN; *)FILL
057613   AGAIN: XXX=:CCOUNT; XA=:CURRPAGE
057617          FOR CCOUNT DO
057617             X:=0
057620             DO WHILE X<<0CINX
057623                AD:=DMMLIMS(X)
057624                IF T:=CURRPAGE>>=A AND T<<=D GO FAR TRNX
057631                X+2
057632             OD
057633             X:=0
057634             IF ROUTSWITCH><0 THEN
057636               DO WHILE ACCTAB(X)><-1                         % RT COMMON
057642                  X+1; IF ACCTAB(X)=CURRPAGE GO FAR TRNX; X+1
057650               OD; X:=0
057652             FI
057652             DO WHILE X<<"NINSZ+1*2"
057655                *1BANK
057656                AD:=NINITPAGE(X); *2BANK
057660                IF A><0 AND A<<=CURRPAGE AND D>>=T GO FAR TRNX
057666                X+2
057667             OD; X:=0
057671             DO WHILE X<<"NINSZ+1*2"
057674                *1BANK
057675                AD:=LAMARR(X); *2BANK
057677                IF A><0 AND A<<=CURRPAGE AND D>>=T GO FAR TRNX
057705                X+2
057706             OD; X:=0
057710             DO WHILE X<<"CUMSIZE*2"
057713                *1BANK
057714                AD:=CUMTABLE(X)
057715                *2BANK
057716                IF A><0 AND A<<=CURRPAGE AND D>>=T GO TRNX
057724                X+2
057725             OD
057726             IF PIOCTESTED=0 THEN
057730                X:=0
057731                DO WHILE X<<50
057734                   *1BANK
057735                   AD:=MMPIOCS(X)
057736                   *2BANK
057737                   IF A><0 AND A<<=CURRPAGE AND D>>=T GO TRNX
057745                   X+2
057746                OD
057747             FI; GO BYP; *)FILL
057755   INTEGER ROUTSWITCH,PIOCTESTED,CCAA
057760   BYP:      CURRPAGE; CALL PHYSPTEST; GO TRNX
057763             IF ROUTSWITCH><0 THEN
057765                IF A=1 THEN
057770                   CURRPAGE/\177700=:T
057773                   IF XA/\177700><T THEN               % CHECK THAT WHOLE IS IN ONE BANK
057777                      IF CURRPAGE+NPAGES>>XT GO MBNOTFOUND
060004                      CURRPAGE=:XA; GO AGAIN
060007                   FI
060007                FI; MIN CURRPAGE
060010             ELSE
060011                CURRPAGE-1=:CURRPAGE
060014             FI
060014          OD
060016          MIN "CLINK"; A:=XA; GO CLINK          % AREA FOUND
060021   TRNX:  IF ROUTSWITCH><0 THEN
060023             IF NPAGES+CURRPAGE>>XT GO MBNOTFOUND
060030             CURRPAGE+1=:XA
060033          ELSE
060034             IF CURRPAGE-NPAGES<<XT GO MBNOTFOUND
060041             CURRPAGE-1=:XA
060044          FI; GO FAR AGAIN
060045
060045   MBNOTFOUND: IF PIOCTESTED=0 THEN
060047                  MIN PIOCTESTED; CCAA=:XA; GO FAR AGAIN
060053               FI; GO CLINK                    % AREA NOT FOUND
060054   RBUS
060057
060057   SUBR 1BAREA
060057   %------------------------------------------------------------------------
060057   % SUBROUTINE TO ALLOCATE CONTINUOUS AREA IN MEMORY NOT CROSSING BANK BOUNDARY
060057   %
060057   % ENTRY: B=SBFIELD IN SINTR
060057   %        A=FIRST PAGE TO TEST
060057   %        X=NUMBER OF PAGES IN AREA
060057   %        T=LAST POSSIBLE PAGE IN AREA
060057   %
060057   % EXIT : NO AREA FOUND
060057   % EXITA: AD= FIRST, LAST PAGE
060057   %
060057   %------------------------------------------------------------------------
060057   INTEGER POINTER LREG
060060   INTEGER LPAG,AREG,XREG
060063   1BAREA:
060063          T=:LPAG:=L=:"LREG"; A=:AREG; X=:XREG
060070          DO WHILE AREG+X<<LPAG
060075             A-X=:T; T:=:A; A\/77:=:T
060102             X:=XREG; CALL GETAREA; GO TRN;
060105             MIN "LREG"; A /\ A;
060107             A=:D+XREG-1; A:=:D; GO RETU
060114   TRN:      AREG+100/\ 177700=:AREG    % TRY NEXT BANK
060120          OD
060121   RETU:   GO LREG
060122   RBUS
060125
060125   %========================================================================
060125   %      X C H I O X
060125   %
060125   % CHECK FOR EXISTING TERMINAL INTERFACES.
060125   % IF A TERMINAL INTERFACE NOT EXIST, THEN THE POINTER
060125   % TO THIS DATAFIELD IS REMOVED FROM THE TIMER TABLE, FROM THE LOGICAL
060125   % UNIT TABLE, AND FROM THE TIOBUTAB
060125   %
060125   % WHEN GETTING IOX-ERRORS WHEN ADDRESSING A INTEFACE, THE INTERFACE
060125   % IS DEFINED AS NOT PRESENT.
060125   %
060125   % THIS ROUTINE WILL CHECK IF THE IDENT-CODE FOR THE TERMINALS ARE
060125   % CORRECT, IF NOT AN ERROR MESAGE WILL BE WRITTEN WHEN THE SYSTEM
060125   % IS STARTED.
060125   %
060125   % ENTRY:         A=FIRST PHYSICAL PAGE IN RPIT
060125   %                T=FIRST PHYSICAL PAGE IN MPIT
060125   SUBR XCHIOX
060125
060125   INTEGER POINTER LREG
060126   INTEGER XREG,TREG,AREG,DREG; TRIPLE TADREG=TREG
060132   INTEGER C1ETMRADDR=?,C2ETMRADDR=?
060132   INTEGER PI12T=?,PI12B=?,PI10T=?,PI10B=?
060132
060132   OUT:   TAD:=TADREG; X:=XREG
060134          GO LREG
060135
060135   INTEGER POINTER CL
060136   INTEGER CLUG,CLOGNO,CEND,CCDFAD
060142   CSUBR: T:=L=:"CL"; A SHZ -6=:CLUG
060146          X:=CNVRT(A); A:=X+200=:CEND
060153          DO WHILE X<<=CEND
060156             T:=LOGDBANK; *LDDTX 10
060160             IF A=CCDFAD OR D=T THEN EXIT FI
060166             X+2
060167          OD; EXITA
060171
060171   % LOCAL SUBROUTINE TO CLEAR A ENTRY IN THE LOGICAL UNIT TABLE AND IN
060171   % THE TIOBUTAB
060171   %
060171   INTEGER POINTER LRG
060172   ZEROENTRIES: A=:CCDFADR
060173          A:=L=:"LRG"
060175          A:=0; CALL CSUBR; GO LGFOUND
060200          A:=1000; CALL CSUBR; GO LGFOUND
060203          A:=2000; CALL CSUBR; GO LGFOUND
060206          A:=2700; CALL CSUBR; GO LGFOUND
060211          A:=3000; CALL CSUBR; GO LGFOUND
060214          GO LRG
060215   LGFOUND: IF A><CCDFADDR THEN X+1 FI
060221          T:=LOGDBANK; *STZTX 10                    % CLEAR ENTRY IN LOG.UN.TABLE
060223          X=:D; A:=X-CNVRT(CLUG) SHZ -1; T:=X SH 6
060232          A+T=:CLOGNO
060234          T:=LOGDBANK; *1BANK
060236          X:="TIOBU"
060237          DO WHILE X.S0><-1
060243             IF A=CLOGNO THEN
060246                0=:X.S0; *2BANK
060250                GO LRG
060251             FI; X+3
060252          OD; *2BANK
060254          GO LRG
060255
060255   *)FILL
060265
060265   XCHIOX: TAD=:TADREG; X=:XREG:=L=:"LREG"
060271          RPIFPHPAGE SH 12=:D
060274          "TMRTE"+1-"PITEX"+D=:TMRADDR              % "START-POINT" IN TIMER TABLE
060301          "9EXTD"-"PITEX"+D=:C1ETMRADDR               % "END-POINT" IN TIMER TABLE
060305          "ETMRT"-"PITEX"+D=:C2ETMRADDR              % END OF TIMER TABLE
060311          T:=MPIFPHPAGE SH 12
060313          "ID12T"-"PITEX"+T=:PI12T                  % PHYS.ADDR OF ID12T
060317          "ITB12"-"PITEX"+T=:PI12B                  % PHYS.ADDR OF ITB12
060323          "ID10T"-"PITEX"+T=:PI10T                  % PHYS.ADDR OF IT10T
060327          "ITB10"-"PITEX"+T=:PI10B                  % PHYS ADDR OF ITB10
060333          GO LABL1
060334
060334   *)FILL
060344
060344   INTEGER PI12T                % PHYS ADDR OF ID12T
060345   INTEGER PI12B                % PHYS ADDR OF ID12B
060346   INTEGER PI10T                % PHYS ADDR OF ID10T
060347   INTEGER PI10B                % PHYS ADDR OF ID10B
060350   INTEGER C1ETMRADDR           % LAST TERM.DF. ENTRY IN TIMER TABLE
060351   INTEGER C2ETMRADDR           % END OF TIMER TABLE
060352
060352   LABL1: A:=200; *TRR IIE; TRA IIC
060355          DO WHILE X:=TMRADDR<<C1ETMRADDR
060361             *TRA IIC
060362             T:=RPIBANK; *LDXTX
060364             IF X=-1 GO FAR OUT                     % -1: END-OF-TABLE
060367             IF X=0 OR X.TYPRING NBIT 5TERM GO FAR NXT
060373             IF X.HDEV><0 THEN
060375                X=:0DFADDR
060376                T:=A+2; *IOXT; TRA IIC
060402                IF A=7 THEN                         % IOX-ERROR ?
060405                   CALL MNALLOC; GO IDOK            % SHOULD DF BE USED FOR NOTS ?
060407                   CALL MTALLOC; GO IDOK            % SHOULD DF BE USED FOR MTAD ?
060411                   T:=RPIBANK; X:=TMRADDR; *STZTX   % DO NOT USE IT, CLEAR ENTRY
060414                ELSE
060415                   GO IDOK                          % MOL/% OOP
060416                   IF X.HDEV NBIT 2 THEN            % CHECK IDENT CODE IF INPUT DEVICE
060421                      X=:D; T:=X.HDEV+3; A:=30; *IOXT
060426                      *IDENT PL10; IDENT PL12; TRA IIC
060431                      15; *IOXT
060433                      A:=0; T+"5-3"; *IOXT
060436                      0=:CCOUNT; FOR CCOUNT DO OD; FOR CCOUNT DO OD
060443                      5; T+"7-5"; *IOXT
060446                      A:=0; *IDENT PL12
060450                      IF A=0 GO FAR ERRID; A-1
060453                      IF A<<="HIDTERM" AND A>>="LIDTERM" THEN
060461                         IF A-T>>"MXX12" GO FAR ERRID
060465                         A+PI12T
060466                      ELSE
060467                         A+PI12B
060470                      FI; X:=A; T:=MPIBANK; *LDATX
060473                      IF A><D GO FAR ERRID; A:=0; *IDENT PL10
060477                      IF A=0 GO FAR ERRID; A-1
060502                      IF A<<="HIDTERM" AND A>>="LIDTERM" THEN
060510                         IF A-T>>"MXX10" GO FAR ERRID
060514                         A+PI10T
060515                      ELSE
060516                         A+PI10B
060517                      FI; X:=A; T:=MPIBANK; *LDATX
060522                      T:="9CXTI"; D+T
060524                      IF A><D GO FAR ERRID
060526                      T+"3-7"; A:=30; *IOXT; IDENT PL10; IDENT PL12; TRA IIC
060534   IDOK:           FI
060534                FI
060534             FI; T:=RPIBANK; X:=TMRADDR; *LDATX
060537             IF A=0 THEN
060540                A:=0DFADDR; CALL FAR ZEROENTRIES
060542                A:=0DFADDR; CALL CLBCKTABENTRY
060544             FI
060544   NXT:      MIN TMRADDR
060545          OD; GO FAR OUT
060547   *)FILL
060563
060563   ERRID: GO IDOK                                % MAY BE PATCHED TO 124001
060564          D.HDEV; T:=0; CALL 9ERR(#23); GO IDOK  % TO GET IOX ERROR !
060572
060572   RBUS
060573
060573
060573   %============================================================================
060573   %
060573   % SUBROUTINE TO INITIALIZE A PAGE (READ AND WRITE IN EVERY ADDRESS IN THE PAGE)
060573   %
060573   % ENTRY: A=PAGE NUMBER
060573   %
060573   % 36.19      I N I T P A G E
060573   %
060573   SUBR INITPAGE
060573   INTEGER XREG,TREG,AREG,DREG
060577   TRIPLE TADR=TREG
060577   INITPAGE:
060577          TAD=:TADR; X=:XREG
060601          X:=0; *1BANK
060603          DO WHILE X<<"NINSZ+1*2"
060606             AD:=NINITPAGE(X)
060607             IF A><0 AND A<<=AREG AND D>>=T GO OUT
060615             X+2
060616          OD; *2BANK
060620          A:=AREG=:D:=162000; X:=177776; *POF
060625          AD=:X.DOU0; *PON
060627          FOR X:=176000 DO X.S0=:X.S0 OD
060633   OUT:   TAD:=TADR; X:=XREG; *2BANK
060636          EXIT
060637   RBUS
060642
060642
060642   %============================================================================
060642   % 36.21       F P G N O
060642   %
060642   %
060642   % SUBROUTINE TO CONVERT ADDRESS TO PAGE NUMBER
060642   %
060642   % ENTRY: A=ADDRESS
060642   %
060642   % EXIT:  A=PAGE NUMBER
060642   %        D=0 WHEN ADDRESS IS MODULO 2K BYTE ELSE D=1
060642   %
060642   SUBR FPGNO
060642   FPGNO: D:=0; AD SHZ -12; IF D><0 THEN D:=1 FI; EXIT
060650   RBUS
060650
060650
060650   %============================================================================
060650   % 36.11       P H Y S P T E S T
060650   %
060650   % SUBROUTINE TO TEST IF PAGE EXIST IN MEMORY
060650   %
060650   % ENTRY: A=PAGE NUMBER
060650   %
060650   % EXIT:  PAGE DOES NOT EXIST
060650   %
060650   % EXIT+1: PAGE EXSIST
060650   %
060650   SUBR PHYSPTEST
060650   INTEGER XREG,TREG,AREG,DREG
060654   TRIPLE TADR=TREG
060654   PHYSPTEST:
060654          TAD=:TADR; X=:XREG:=0
060657          *1BANK
060660          DO WHILE X<<"NINSZ+1*2"
060663             AD:=NINITPAGE(X)
060664             IF A><0 AND A<<=AREG AND D>>=T GO NOTOK
060672             X+2
060673          OD; *2BANK
060675          A:=AREG=:D:=162000; X:=177776; *POF
060702          AD=:X.DOU0
060703          A:=1000; *TRR IIE; PON; TRA IIC           % TEST FOR MEMORY OUT OF RANGE
060707          X:=-1; X.S0; *TRA IIC
060712          IF A=0 THEN L+1 FI; A:=0; *TRR IIE
060716   NOTOK: TAD:=TADR; X:=XREG; *2BANK
060721          EXIT
060722   RBUS
060725
060725   %==============================================================================
060725   %            O U T L I N K   -   I O U T L I N K
060725   %
060725   % SUBROUTINE TO LINK OUT AN AREA FROM THE MEMORY MAP
060725   % IMOUTLINKL WILL ALSO INITIALIZE THE AREA (READ AND WRITE IN ALL LOCATIONS)
060725   %
060725   % ENTRY:     A=FIRST PAGE TO LINK OUT
060725   %            D=LAST PAGE TO LINK OUT
060725   SUBR MOUTLINKL,IMOUTLINKL
060725   INTEGER TREG,AREG,DREG,XREG
060731   TRIPLE TADR=TREG
060731   INTEGER POINTER LREG
060732   INTEGER CFMMENTRY,CLMMENTRY,CPREV
060735
060735   IMOUTLINKL: K:=1; GO FELLS
060737   MOUTLINKL: K:="0"
060740   FELLS: TAD=:TADR; X=:XREG:=L=:"LREG"
060744          IF A=-1 GO OUT
060747          IF K THEN
060751             TAD:=TADR
060752             DO CALL INITPAGE; WHILE A><D; A+1; OD
060757          FI; TAD:=TADR
060760          D-A; A:=D+1=:NPAGES
060763          AREG SH 2=:CFMMENTRY; DREG SH 2=:CLMMENTRY
060771          T:=SEGTBANK; X:=XSGRT; *BPAGL@3 LDXTX
060774          DO WHILE X><0
060775             IF X=CFMMENTRY GO FOUND
061000             T:=CORMBANK
061001             *PAGLI@3 LDXTX
061002          OD; CALL ERRFATAL               % MEMORY MAP ELEMENT NOT FOUND
061004   FOUND: T:=CORMBANK; *PREVI@3 LDATX
061006          A=:CPREV
061007          DO NPAGES-1=:NPAGES WHILE NPAGES><0
061014             *PAGLI@3 LDXTX
061015             IF X=0 THEN CALL ERRFATAL FI % INCOSISTENT MEMORY MAP
061020          OD
061021          IF X><CLMMENTRY THEN CALL ERRFATAL FI
061025          T:=CORMBANK; *PAGLI@3 LDATX; PAGLI@3 STZTX
061030          IF X:=A><0 THEN
061032             CPREV; *PREVI@3 STATX        % SET PREVIOUS
061034          FI
061034          IF CPREV/\3=0 THEN              % FIRST IN LISTE?
061037             A:=CPREV:=:X; *PAGLI@3 STATX % NO, SET PAGLINK
061042          ELSE
061043             T:=SEGTBANK; A:=X; X:=XSGRT; *BPAGL@3 STATX
061047          FI; X:=CFMMENTRY
061050          DO WHILE X<<=CLMMENTRY
061053             T:=CORMBANK; A:=0 BONE 5CMSYS; *PROTE@3 STATX    % MARK MEMORY MAP ELEMENT IN USE BY "SYSTEM AREA"
061057             IF X+4=0 GO OUT
061061          OD
061062   OUT:   TAD:=TADR; X:=XREG
061064          GO LREG
061065   RBUS
061073
061073
061073   %=============================================================================
061073   %      Z E R O P A G E
061073   %
061073   % SUBROUTINE TO FILL A PAGE WITH ZEROES
061073   %
061073   % ENTRY:     A=PHYSICAL PAGE NUMBER
061073   %
061073   SUBR ZEROPAGE
061073   INTEGER XREG; TRIPLE TADR
061077   ZEROPAGE: TAD=:TADR; X=:XREG
061101          A=:D:=162000; X:=177776; *POF
061105          AD=:X.DOU0; *PON
061107          FOR X:=176000 DO 0=:X.S0 OD
061112          TAD:=TADR; X:=XREG; EXIT
061115   RBUS
061117
061117
061117   *9ERST=*                     % FIRST FREE LOCATION FOR BUFFER AREAS
061117
061117   %=============================================================================
061117   %  38.10     S Y S E V A L
061117   %
061117   %  ROUTINE TO DEDUCT CPU/SYSTEM INFORMATION AND UPDATE THE GLOBAL
061117   %  SINTRAN VARIABLES WITH THIS INFORMATION
061117   %
061117   %  A 12 WORD (14 OCTAL) ARRAY CONTAIN VARIOUS INFORMATION ABOUT THE SYSTEM.
061117   %  THE ARRAY IS SUBDIVIDED INTO SEVERAL FIELDS FOR VARIOUS TYPE OF INFORMATION.
061117   %  THE FOLLOWING GIVES A DETAILED DESCRIPTION OF THE INFORMATION PRESENT IN
061117   %  THE VARIOUS ENTRIES
061117   %
061117   %-----------------------------------------------------------------------------
061117   %
061117   %  DISP  NAME            DESCRIPTION
061117   %
061117   %   0    SYSNO           SYSTEM NUMBER (NORMALLY CPU NUMBER), 16 BIT INTEGER
061117   %
061117   %   1    HWINFI(0)       HARWARE INFORMATION
061117   %                        LEFT BYTE = CPU TYPE
061117   %                                    0 = NORD-10  48 BIT FLOATING
061117   %                                    1 = NORD-10  32 BIT FLOATING
061117   %                                    2 = ND-100   48 BIT FLOATING
061117   %                                    3 = ND-100   32 BIT FLOATING
061117   %                                    4 - ND-110   48 BIT FLOATING
061117   %                                    5 - ND-110   32 BIT FLOATING
061117   %                                    6 - ND-120   48 BIT FLOATING
061117   %                                    7 - ND-120   32 BIT FLOATING
061117   %                        RIGHT BYTE = INSTRUCTION SET
061117   %                                    0 = STANDARD (NORD-10 OR ND-100)
061117   %                                    1 = NORD-10 COMMERCIAL, ND-100/CE
061117   %                                    2 - ND-100/CX
061117   %                                    3 - ND-110 PCX
061117   %                                    4 - ND-120 PCX
061117   %                                    5 - NOT USED
061117   %                                    6 - NOT USED
061117   %                                    7 - NOT USED
061117   %                                   10 - ND-120/CX
061117   %                                   11 - ND-110/CX  PRINT 3095
061117   %                                   12 - ND-110/CX  PRINT 3090
061117   %                                   13 - 255 NOT USED
061117   %
061117   %   2    HWINFO(1)       ND-110 MICROPROGRAM VERSION
061117   %
061117   %   3    HWINFO(2)       SYSTEM TYPE  (100,102,500,502,5561..)
061117   %
061117   %   4    SINVER(0)       OPERATING SYSTEM
061117   %                        LEFT BYTE = OPERATING SYSTEM
061117   %                                    0 = SINTRAN III VS
061117   %                                    1 = SINTRAN III VSE
061117   %                                    2 = SINTRAN III VSE/500
061117   %                                    3 = SINTRAN III RTP
061117   %                                    4 = SINTRAN III VSX
061117   %                                    5 = SINTRAN III VSX/500
061117   %                                    6 - 255 NOT USED
061117   %                        RIGHT BYTE = VERSION LETTER
061117   %                                     ASCII CHARACTER WITHOUT PARITY (A-Z)
061117   %
061117   %   5    SINVER(1)       NOT USED  (SIBAS SYSTEM NO)
061117   %
061117   %   6    REVLEV          PATCH/CORRECTION LEVEL INDICATIOR, 16 BIT INTEGER
061117   %                        (SYSTEM DEPENDANT CODING)
061117   %
061117   %   7    GENDAT(0)       SYSTEM GENERATION TIME  (MINUTES)
061117   %   8    GENDAT(1)       SYSTEM GENERATION TIME  (HOURS)
061117   %   9    GENDAT(2)       SYSTEM GENERATION TIME  (DAY)
061117   %  10    GENDAT(3)       SYSTEM GENERATION TIME  (MONTH)
061117   %  11    GENDAT(4)       SYSTEM GENERATION TIME  (YEAR)
061117   %
061117   %-----------------------------------------------------------------------------
061117
061117   SUBR SYSEVAL
061117
061117   INTEGER SXREG,SBREG,STREG,AREG,SDREG,CHWINFO
061125   TRIPLE TADR=STREG
061125   INTEGER POINTER SLREG
061126
061126   SYSEVAL:
061126         TAD=:TADR; X=:SXREG:=B=:SBREG:=L=:"SLREG"
061134
061134   %  32/48 BIT FLOATING?
061134          T:=0; A:=1; *NLZ 20
061137          IF T=0 THEN T:=1 ELSE T:=0 FI
061144
061144   %  NORD-10 OR ND-100?
061144          CPSTA/\10000 SHZ -13+T SH 10
061151          A=:CHWINFO
061152
061152   %  INSTRUCTION SET
061152   %  COMMERCIAL INSTRUCTION SET?
061152          *TRA IIC
061153          A:=20; *TRR IIE
061155          A:=0; *TRR PIE; TRR PID
061160          A:=40000; *MST PIE
061162          *POF
061163          A:="CLEV14"; *IRW 160 DP; ION
061166          T:="L1"=:L:=0; *140130; JMP *+1; TRA IIC            % BFILL
061174   L1:    IF A=0 THEN
061175             "L2"=:L
061177             B:=0; D:=0; A:=0; X:=0; *142700; TRA IIC         % GECO
061205   L2:       IF A><0 GO OUT
061206          FI
061206          *143500                                             % SLWCS
061207          MIN CHWINFO
061210          T:="L3"=:L; X:=0; *ICLEP; TRA IIC
061215   L3:    IF A=0 THEN MIN CHWINFO FI
061217          T:="LL3"=:L; X:=0; *WGLOB; TRA IIC                  % (MICRO-SEGADM FOR 16 PITS?
061224   LL3:   IF A=0 THEN MIN CHWINFO FI
061226          T:="LL4"=:L; *VERSN; TRA IIC                        % ND-110?
061232   LL4:   IF A=0 THEN
061233             *VERSN
061234             A SHZ -15 ; A+CHWINFO=:CHWINFO
061237             A:=0 ; *TRR PIE; TRR PID; PON
061243             T=:HWINFO(1)                                     % ND-110/ND-120 MICROPROGRAM VERSION
061245             CHWINFO/\174777+2000=:CHWINFO
061251             IF T BIT 17 THEN                                 % ND-120?
061253                A+1000=:CHWINFO
061255             FI
061255          FI
061255   OUT:   A:=0; *TRR PIE; TRR PID; PON
061261          CHWINFO=:HWINFO(0)
061264          A:=4
061265          IF T:=PN500D><0 THEN A+1 FI                         % ND-500 INCLUDED
061271          A SH 10+##L                                         % VERSION LETTER
061273          A=:SINVER(0)
061275          *IOF; TRA IIC
061277          A:=0; *TRR PIE; TRR PID; TRR IIC
061303          TAD:=TADR; X:=SBREG=:B:=SXREG
061307          GO SLREG
061310   % ROUTINE ON LEVEL 14 TO CHECK FOR ILLEGAL INSTRUCTION
061310   CLEV14: *TRA IIC
061311          IF A><4 THEN CALL ERRFATAL FI
061315          *IRW DA; IRR DL; IRW DP
061320          *WAIT
061321          GO CLEV14
061322
061322   RBUS
061342   %============================================================================
061342   %       G C P U N R
061342   %
061342   %       ROUTINE TO GET CPU NUMBER FROM BACK WIRING PROM.
061342   %       CALLED ONLY IF 110/120 CPU.
061342   %
061342   %       DUE TO ERROR IN MICROPROGRAM THE VERSN INSTRUCTION HAS TO BE
061342   %       EXECUTED ON THE LEVEL CORRESPONDING TO THE BYT NO. TO BE READ.
061342   %
061342   SUBR GCPUNR
061342   INTEGER INF0,INF1,INF2,INF3
061346   GCPUNR: *PIOF
061347           400;  *IRW 10 DA; LDA (EXVE; IRW 10 DP
061353           1000; *IRW 20 DA; LDA (EXVE; IRW 20 DP
061357           1400; *IRW 30 DA; LDA (EXVE; IRW 30 DP
061363           2000; *IRW 40 DA; LDA (EXVE; IRW 40 DP
061367           2400; *IRW 50 DA; LDA (EXVE; IRW 50 DP
061373           3000; *IRW 60 DA; LDA (EXVE; IRW 60 DP
061377           3400; *IRW 70 DA; LDA (EXVE; IRW 70 DP
061403           377; *TRR PIE; TRR PID; ION; IOF; PON
061411           A:=0; *TRR PIE; VERSN; 1BANK
061415           T:="INF0"; X:=0; A:=D; *SBYT
061421           X+1; *IRR 10 DD; SBYT
061424           X+1; *IRR 20 DD; SBYT
061427           X+1; *IRR 30 DD; SBYT
061432           X+1; *IRR 40 DD; SBYT
061435           X+1; *IRR 50 DD; SBYT
061440           X+1; *IRR 60 DD; SBYT
061443           X+1; *IRR 70 DD; SBYT; 2BANK
061447           IF INF3><52652 THEN EXIT FI             % NOT CORRECT PROM
061454           IF INF0><-1 THEN
061460              A=:SYSNO=:FCPUN; 1=:PRFLAG           % CPU NUMBER (PRFLAG IS USED BY NEW-SYSTEM)
061464           FI
061464           IF INF1><-1 THEN A=:HWINFO(2) FI        % CPU TYPE
061472           IF INF2 SHZ -10><377 THEN A=:NLEGU FI   % NUMBER OF LEGAL USERS
061500           EXIT
061501   EXVE:   *VERSN; WAIT
061503   RBUS
061531   %============================================================================
061531   %       T I O B U T A B
061531   @MAC

)9SCLC
061531
061531  TIOBU=*
061531
061531              1;    44;    134
061534  "8TR5 -9SMO1;     44;    44;    134
061537  "8TR6;     45;    44;    134
061542  "8TR7;     46;    44;    134
061545  "8TR8;     47;    44;    134
061550  "8TR9 -9SMO2;     60;    44;    134
061553  "8TR10;    61;    44;    134
061556  "8TR11;    62;    44;    134
061561  "8TR12;    63;    44;    134
061564  "8TR13 -9SMO3;    64;    44;    134
061567  "8TR14;    65;    44;    134
061572  "8TR15;    66;    44;    134
061575  "8TR16;    67;    44;    134
061600  "8TR17 -9SMO4;     7;    44;    134
061603  "8TR18;    17;    44;    134
061606  "8TR19;    52;    44;    134
061611  "8TR20;    53;    44;    134
061614  "8TR21 -9SMO5;    54;    44;    134
061617  "8TR22;    55;    44;    134
061622  "8TR23;    56;    44;    134
061625  "8TR24;    57;    44;    134
061630  "8TR25 -8SMO9;    70;    44;    134
061633  "8TR26;    71;    44;    134
061636  "8TR27;    72;    44;    134
061641  "8TR28;    73;    44;    134
061644  "8TR29 -9SMO6;    74;    44;    134
061647  "8TR30 -9SMO7;    75;    44;    134
061652  "8TR31;    76;    44;    134
061655  "8TR32;    77;    44;    134
061660  "8TR33;  1040;    44;    134
061663  "8TR34;  1041;    44;    134
061666  "8TR35 -8SMO7;  1042;    44;    134
061671  "8TR36 -8SMO8;  1043;    44;    134
061674  "8TR37 -8SMO9;  1044;    44;    134
061677  "8TR38 -9SMO1;  1045;    44;    134
061702  "8TR39 -9SMO2;  1046;    44;    134
061705  "8TR40 -9SMO3;  1047;    44;    134
061710  "8TR41 -9SMO4;  1050;    44;    134
061713  "8TR42 -9SMO5;  1051;    44;    134
061716  "8TR43 -9SMO6;  1052;    44;    134
061721  "8TR44 -9SMO7;  1053;    44;    134
061724  "8TR45;  1054;    44;    134
061727  "8TR46;  1055;    44;    134
061732  "8TR47;  1056;    44;    134
061735  "8TR48;  1057;    44;    134
061740  "8TR49;  1060;    44;    134
061743  "8TR50;  1061;    44;    134
061746  "8TR51;  1062;    44;    134
061751  "8TR52;  1063;    44;    134
061754  "8TR65;  2000;    44;    134
061757  "8TR66;  2001;    44;    134
061762  "8TR67;  2002;    44;    134
061765  "8TR68;  2003;    44;    134
061770  "8TR69;  2004;    44;    134
061773  "8TR70;  2005;    44;    134
061776  "8TR71;  2006;    44;    134
062001  "8TR72;  2007;    44;    134
062004  "8TR73;  2010;    44;    134
062007  "8TR74;  2011;    44;    134
062012  "8TR75;  2012;    44;    134
062015  "8TR76;  2013;    44;    134
062020  "8TR77;  2014;    44;    134
062023  "8TR78;  2015;    44;    134
062026  "8TR79;  2016;    44;    134
062031  "8TR80;  2017;    44;    134
062034  "8TR81;  2020;    44;    134
062037  "8TR82;  2021;    44;    134
062042  "8TR83;  2022;    44;    134
062045  "8TR84;  2023;    44;    134
062050  "8TR85;  2024;    44;    134
062053  "8TR86;  2025;    44;    134
062056  "8TR87;  2026;    44;    134
062061  "8TR88;  2027;    44;    134
062064  "8TR89;  2030;    44;    134
062067  "8TR90;  2031;    44;    134
062072  "8TR91;  2032;    44;    134
062075  "8TR92;  2033;    44;    134
062100  "8TR93;  2034;    44;    134
062103  "8TR94;  2035;    44;    134
062106  "8TR95;  2036;    44;    134
062111  "8TR96;  2037;    44;    134
062114  "8TR97;  2040;    44;    134
062117  "8TR98;  2041;    44;    134
062122  "8TR99;  2042;    44;    134
062125  "9TR00;  2043;    44;    134
062130  "9TR01;  2044;    44;    134
062133  "9TR02;  2045;    44;    134
062136  "9TR03;  2046;    44;    134
062141  "9TR04;  2047;    44;    134
062144  "9TR05;  2050;    44;    134
062147  "9TR06;  2051;    44;    134
062152  "9TR07;  2052;    44;    134
062155  "9TR08;  2053;    44;    134
062160  "9TR09;  2054;    44;    134
062163  "9TR10;  2055;    44;    134
062166  "9TR11;  2056;    44;    134
062171  "9TR12;  2057;    44;    134
062174  "9TR13;  2060;    44;    134
062177  "9TR14;  2061;    44;    134
062202  "9TR15;  2062;    44;    134
062205  "9TR16;  2063;    44;    134
062210  "9TR17;  2064;    44;    134
062213  "9TR18;  2065;    44;    134
062216  "9TR19;  2066;    44;    134
062221  "9TR20;  2067;    44;    134
062224  "9TR21;  2070;    44;    134
062227  "9TR22;  2071;    44;    134
062232  "9TR23;  2072;    44;    134
062235  "9TR24;  2073;    44;    134
062240  "9TR25;  2074;    44;    134
062243  "9TR26;  2075;    44;    134
062246  "9TR27;  2076;    44;    134
062251  "9TR28;  2077;    44;    134
062254  "9TR29;  2700;    44;    134
062257  "9TR30;  2701;    44;    134
062262  "9TR31;  2702;    44;    134
062265  "9TR32;  2703;    44;    134
062270  "9TR33;  2704;    44;    134
062273  "9TR34;  2705;    44;    134
062276  "9TR35;  2706;    44;    134
062301  "9TR36;  2707;    44;    134
062304  "9TR37;  2710;    44;    134
062307  "9TR38;  2711;    44;    134
062312  "9TR39;  2712;    44;    134
062315  "9TR40;  2713;    44;    134
062320  "TEFX1;  1540;    44;    134
062323           1560;    44;     20
062326  "
062326  -1; -1; -1
062331  )9RCLC
)9SLPL
062331

062331   %==============================================================================
062331   %  27.1      L O A D   P R O G R A M
062331   %
062331
062331   @MAC

)9SCLC
062331  %
062331  % "LOAD" PROGRAM
062331  %
062331
062331  LOLOG=-2
062331  LOUNI=-1
062331  LKONS=177000
062331
062331
062331  % SET CACHE INHIBIT LIMIT AND CLEAR CACHE
062331  RELOA, PIOF; TRA STS; BSKP ONE 140 DA; JMP *+5; SAA 0
062336         TRR 11; SAA 77; JMP *+2; LDA (37400; TRR 12; TRR 10
062344  % MOVE RELOAD PROGRAM TO ADDRESS LKONS-WORD2
062344         LDX ADR3; LDA I ,X ADR1; STA I ,X ADR2; JNC *-2
062350         LDA ADR1; ADD (SWDSI; STA ADR1
062353  % MOVE DRIVER TO THE CORRECT ADDRESS
062353         LDX (-SWDSI; LDA I ,X ADR1; STA I ,X ADR2B; JNC *-2
062357         JMP I *+1; LKONS-WORD2
062361  ADR1,  TRANS+WORD2-RELOA
062362  ADR2,  LKONS
062363  ADR3,  -WORD2
062364
062364  )FILL
062367  TRANS, LDA (LKONS-WORD6; COPY SA DB
062371         LDT YSWTY; AAT -1; SKP DT EQL 0; JMP NBDI
062375         AAA NWLBB-4; COPY SA DD; SAA 0; STD NWLBB,B      % SPARE TRACK ADDR.
062401         JMP NALOA
062402  NBDI,  AAT -1; SKP DT EQL 0; JMP SCDI
062405  LOWDI, AAA ALTPO; COPY SA DD; SAA 0; STD WNLBA,B        % SPARE TRACK ADDR
062411         JMP NALOA
062412  SCDI,  AAT -1; SKP DT EQL 0; JMP NALOA
062415         SAT 42; JPL I LDRAD; JMP *-2; JMP *-2
062421         JMP NALOA
062422  NOBLK, 0
062423  ADR2B, 0
062424  DYBLS, 0;0
062426  LDRAD, 0
062427  XSWTP, 0
062430  YSWTY, 0         % 1=BDIS; 2=WDIS
062431
062431  NALOA, LDX NOBLK; LDT LOUNI,B; SHT 6
062434         LDA XSWTP; RADD SA DT; LDD DYBLS
062437  NALO4, JPL I LDRAD; JMP NALOA; JMP *+2; JMP NALO3   % CALL DRIVER
062443         STA NALO5
062444  NALOY, MCL PID; MCL PID; MCL PID; MCL PID
062450  KLIOX, IOX 4; BSKP ZRO 20 DA; JMP NALOY; LDA NALO5; JMP NALO4
062455  NALO3=*
062455  NALO2, IDENT PL11; JMP I (SINTR
062457  NALO5, 0
062460  )FILL
062462
062462  DFELT=*+110
062462  KLOLO=DFELT+LOLOG
062462  KLHDE=DFELT+HDEV
062462  KLRC1=DFELT+ERRC1
062462  KBLSZ=DFELT+BLSZ
062462
062462  *<DFELT+20
062462  )ZERO
062462
062462  DFELT-72/ 0; *+1             % ADDRESS TO SCSI IO-BUFFER
062502  DFELT+DEDFA+1/
062631  WORD2=*-TRANS
062631  UPADR=*+1400
062631  LDEND=*
062631  WORD6=*-DFELT
062631
062631  )KILL NOBLK DYBLS TOUT TOUT1 CHOUT TINN TINN1 TINN2 OUTR TINN3 NALOY
062631  )KILL NALOA NALO4 KLIOX NALO3 NALO2 CHSWD NALO5 KLOLO KLHDE WORD2
062631  )KILL UPADR DFELT WORD3 WORD4 WORD5 WORD6
062631  )KILL ADR1 ADR2 ADR3 TRANS ALO1 TX0 TX1 TX2 LOLOG LOUNI LKONS
062631  )KILL YSWTY LOWDI
062631  )9RCLC
)9SLPL
062631
062631
062631   %=============================================================================
062631   %            T N I N I T P
062631   %
062631   % SUBROUTINE TO TEST IF A PAGE IN A MEMORY-BANK CAN BE ACCESSED, I.E.
062631   % THE WHOLE MEMORY-BANK IS NOT SETUP IN NINITPAGES
062631   %
062631   % ENTRY:     A=FIRST PAGE IN MEMORY-BANK
062631   %
062631   % EXIT:      NO PAGES IN MEMORY BANK CAN BE ACCESSED
062631   %
062631   % EXIT+1:    A=PAGE NUMBER TO ACCESS IN MEMORY BANK
062631   %
062631   SUBR TNINITP
062631   TRIPLE TRARDR
062634   INTEGER XR,CENDPAGE
062636   TNINITP: TAD=:TRARDR; A=:CURRPAGE; X=:XRG
062641          A\/77=:CENDPAGE
062643   LOOP:  DO WHILE CURRPAGE<<=CENDPAGE
062647             X:=0
062650             DO WHILE X<<="NINSZ+1*2"
062653                *1BANK
062654                AD:=NINITPAGE(X)
062655                *2BANK
062656                IF A><0 AND A<<=CURRPAGE AND D>>=T THEN
062664                   T+1=:CURRPAGE; GO LOOP
062667                FI; X+2
062670             OD; L+1; GO OUT
062673          OD
062674   OUT:   TAD=:TRARDR; A:=CURRPAGE; X:=XR
062677          EXIT
062700   RBUS
062702
062702
062702   %==============================================================================
062702   %            M P M 3 M A P   -   M P M 4 M A P
062702   %
062702   % SUBROUTINE TO FIND MPM3 AND MPM4 MEMORY
062702   %
062702   SUBR MPM3MAP,MPM4MAP
062702
062702   INTEGER POINTER LREG
062703   INTEGER TR,AR,DR,XR; TRIPLE TRARDR=TR
062707   INTEGER ROUTSWITCH,ORGCONT
062711
062711   MPM3MAP: TAD=:TRARDR; 1=:ROUTSWITCH; GO FELLS
062715   MPM4MAP: TAD=:TRARDR; 0=:ROUTSWITCH
062717   FELLS: X=:XR:=L=:"LREG"
062722          A:=400; *TRR IIE                          % ENABLE FOR MEMORY PARITY ERROR
062724          *TRA PGS; TRA PEA; TRA IIC                % CLEAR INTERNAL REGISTERS
062727          0=:CURRPAGE
062730          DO WHILE CURRPAGE<<=ENDPAGE
062734             CALL TTMMAP; GO NXT                    % TEST IF MEM.BANK EXIST
062736             CALL TNINITP; GO NXT                   % TEST IF MEM IS INVISIBLE
062740             A=:D:=162000; X:=177776
062743             T:=0; *STDTX                           % INITIALIZE PIT ENTRY
062745             X.S0=:ORGCONT; *TRA IIC; TRA PEA
062751             IF ROUTSWITCH=0 THEN                   % MPM4
062753                A:=11; *TRR ECCR
062755                0=:X.S0; A:=4; *TRR ECCR; TRR 10
062761                X.S0; *TRA IIC
062763                IF A=10 THEN T:=KMECCR; A:=CURRPAGE; CALL SMEMTYPE FI
062771             ELSE                                   % MPM3
062772                A:=140751; *IOX 751
062774                0=:X.S0; A:=140764; *IOX 751; TRR 10
063000                X.S0; *TRA IIC
063002                IF A=10 THEN T:=KMPM3; A:=CURRPAGE; CALL SMEMTYPE FI
063010             FI; ORGCOUNT=:X.S0                     % RESET ORIGINAL CONTENT
063012             *TRA PES; TRA PEA; TRA IIC; TRA PGS    % CLEAR INTERNAL REGISTERS
063016   NXT:      CURRPAGE+100=:CURRPAGE
063021          OD
063022          A:=10; *TRR ECCR
063024          A:=4; *TRR ECCR
063026          TAD:=TRARDR; X:=XR
063030          GO LREG
063031   RBUS
063041
063041
063041   %=============================================================================
063041   %            S M E M T Y P E
063041   %
063041   % SUBROUTINE TO SETUP MEMORY-TYPE OF A MEMORY BANK
063041   %
063041   % ENTRY:     A=PHYS.PAGE
063041   %            T=MEMORY TYPE
063041   %
063041   SUBR SMEMTYPE
063041   INTEGER TR,AR,DR,XR; TRIPLE TRARDR=TR
063045   SMEMTYPE: TAD=:TRARDR; X=:XR
063047          A=:D SHZ -7+MEMARRAY=:X; T:=MBMEMARRAY; *LDATX
063055          IF D BIT 6 THEN
063057             A/\177400\/TR
063061          ELSE
063062            A/\377; T:=TR SH 10; A\/T; T:=MBMEMARRAY
063067          FI; *STATX
063070          X:=XR; TAD:=TRARDR
063072          EXIT
063073   RBUS
063077
063077   %=============================================================================
063077   %               C H 5 C P U P R E S E N T
063077   %
063077   % Subroutine called from the start-up (SINTR) sequence to check if
063077   % the generated ND-500 cpu's (SAMSON) exists or not
063077   %
063077   % EXIT:   No ND-500 cpu is presnet
063077   %
063077   % EXIT+1: ND-500 cpu is present
063077   %
063077   SUBR CH5CPUPRESENT
063077   *"8N500
"063077   INTEGER CBSET(0); *BSET ONE DA
063100   INTEGER COMD,CCPU,CCSAM,COLD
063104
063104   CH5CPUPRESENT: B=:D; A:="S5CPUDF"=:B:=0; *TRR IIE
063111          0=:COMD=:CCSAM=:COLD; 1=:CCPU
063116          DO WHILE B<<="E5CPUDF"
063121             IF CPUAVAILABLE BIT 5NOTPRESENT GO 2CH5CPU
063124             IF CCSAM><0 GO 1CH5CPU
063126             T:=HDEV+RSTA5; *TRA IIC
063131             A:=200; *TRR IIE; IOXT; TRA IIC
063135             IF A=0 THEN                                % If not IOX-error then
063136                CPUAVAILABLE/\140000\/OLD500
063141                A BONE 5ALIVE
063142                MIN COLD
063143             ELSE
063144                IF COLD><0 GO 2CH5CPU
063146   1CH5CPU:     *TRA IIC                                % Read octobus if. status
063147                A:=200; *TRR IIE
063151                T:=100406; *IOXT; TRA IIC
063154                IF A=0 THEN                             % Octobus present? - (assumes Samson)
063155                   DO                                   % Wait for data ready
063155                      *IOXT
063156                   WHILE A NBIT 3
063160                   OD
063161                   ASTATION\/COMD=:5STATION
063164                   A SH 10 BONE CBIT BONE EBIT=:X       % To start Samson selftest:
063170                   T:=100405; A\/CMMACLE; *IOXT         % - send "masterclear Samson system" frame
063173                   A:=X\/CMACONT; *IOXT                 % - send "continue accp" frame
063176                   MIFLAG BONE MUDOM=:MIFLAG
063201                   CPUAVAILABLE/\140000\/SAMSON
063204                   MIN CCSAM
063205                ELSE
063206   2CH5CPU:        A:=0
063207                FI
063207             FI
063207             A=:CPUAVAILABLE
063210             MIN CCPU; MIN COMD; B+5CPUDDFSZ
063213          OD; D=:B
063215          EXITA
063216   *"-8N500
"063216   RBUS
063230
063230   %==============================================================================
063230   %  (R)    C B P O O L
063230   %
063230   % CREATE BUFFER POOL. CALLED FROM ROUTINE OCSTART
063230   %
063230   % ENTRY:   T - BANK NUMBER
063230   %          X - ADDRESS WITHIN BANK
063230   %          D - NUMBER OF BUFFERS
063230   %          A - ADDRESS TO START OF BUFFER DESCRITORS
063230   % EXIT:    X - ADDRESS TO LAST ENTRY
063230   %
063230   SUBR CBPOOL
063230   INTEGER TADDR,XADDR
063232   CBPOOL:
063232          T=:TADDR; X=:XADDR:=A
063235          DO WHILE D>0
063237              MBFREC+1=:MBFREC
063242              TADDR=:X.MBYA1            % SET BANK OF BUFFERS
063244              XADDR=:X.MBYA2            % ADDRESS WITHIN BANK
063246              XADDR+OBSIZE=:XADDR       % NEXT BUFFER ADDRESS
063251              IF D-1>0 THEN             % NOT LAST BUFFER?
063254                  A:=X+DSIZE            % DESCRIPTOR ADDRESS OF NEXT BUFFER.
063256              ELSE                      %
063257                  A:=0                  % END OF DESCRIPTOR CHAIN.
063260              FI                        %
063260              A=:X.MBLINK; X:=A         %
063262          OD
063263          X:=XADDR; EXIT
063265   RBUS
063267
063267   %==============================================================================
063267   %  (R)    C E N T R Y
063267   %
063267   % CREATE IDENT TABLES, LAST PART FOR OMD DATAFIELDS AND KICK ENTRIES.
063267   % CALLED FROM ROUTINE OCSTART.
063267   % ENTRY:   T - BANK NUMBER
063267   %          X - ADDRESS WITHIN BANK
063267   %          B - ADDRESS TO OCTOBUS INPUT CONTROLLER
063267   % EXIT:    X - ADDRESS TO LAST ENTRY
063267   %
063267   SUBR CENTRY
063267   INTEGER POINTER LREG
063270
063270   CENTRY:A:=L=:"LREG"
063272          IF X=0 THEN X+1 FI                      %
063275          A:=17=:D; X=:A:=0                       % LAST PART FOR OMD:
063301          DO WHILE X <= D                         %
063303              A=:OMDENT(X); A:=:X                 % SET ADDRESS TO OMD ENTRIES.
063305              *OLINK@3 STZTX; DLEVE@3 STZTX       % SET ZERO IN LAST PART.
063307              *DFADD@3 STZTX                      %
063310              A:=:X; A+3; X+1                     %
063313          OD                                      %
063314          X:=17=:D; X:=0                          % KICK ENTRIES:
063317          DO WHILE X <= D                         %
063321              A=:KICKENT (X); A:=:X               % SET ADDRESS TO KICK ENTRIES
063323              *OLINK@3 STZTX; DLEVE@3 STZTX       % ZEROSET
063325              *DFADD@3 STZTX                      %
063326              A:=:X; A+3; X+1                     %
063331          OD                                      %
063332                                                  % IDENT ENTRIES:
063332          X:=A; D:=0                              % X= ADDRESS WITHIN BANK
063334          DO WHILE D <= 77                        % MAKE IDENT ENTRIS FOR FOR SOURCE STATIONS.
063337             X:=:D                                %
063340             A:=SOUIDEN (X); X:=:D                %
063342             IF A>0 THEN                          % IDENT ENTRIES FOR THIS SOURCE?
063344                T:=IENTBANK; *STATX               % NUMBER OF IDENT ENTRIES FOR SOURCE STATION.
063346                L:=A; A:=X; X:=:D                 %
063351                A=:SOUIDEN (X); X:=:D; X+1        % SET ADDRESS TO START OF IDENT ENTRIES.
063354                DO WHILE L>0                      % SET ZERO IN IDENT ENTRIES.
063356                   *OLINK@3 STZTX                 %
063357                   *DLEVE@3 STZTX                 %
063360                   *DFADD@3 STZTX                 %
063361                   L-1                            %
063362                   X+3                            %
063363                OD                                %
063364             FI                                   %
063364             D+1                                  %
063365         OD                                       %
063366         GO LREG
063367   RBUS
063367
063367
063367   %==============================================================================
063367   %         O C S T A R T
063367   %
063367   % START UP ROUTINE FOR OCTOBUS
063367   % CHECK IF OCTOBUS INTERFACE IS PRESENT AND ALLOCATE MEMORY FOR
063367   % BUFFER POOL AND TABLES IN PHYSICAL MEMORY.
063367   %
063367   % NOTE !!! THIS OCTOBUS DRIVER ONLY HANDLE ONE OCTOBUS INTERFACE (DEVICE 0)
063367   %
063367   %
063367   SUBR OCSTART
063367   INTEGER BREG,BPAGS,NPAGS
063372   INTEGER POINTER LREG
063373
063373   OCSTART:
063373         A:=L=:"LREG"
063375         A:=B=:BREG
063377         OCTICON(0)=:B                            %
063402         IF B=0 GO OUT                            % GENERATED WITH THIS OCTOBUS
063404         A:=200; *TRR IIE; TRA IIC                % ENABLE FOR IOX-ERROR
063407         T:=HDEV+2; *IOXT; TRA IIC                %
063413         IF A=7 THEN                              % IOX-ERROR ?
063416             0=:TMR; 0=:OCTICONT(0)               % RESET TIMER COUNTER
063421             0=:OCTOCONT(0); GO OUT               %
063424         FI                                       %
063424         T:=HDEV+DCONT; 20; *IOXT                 % CLEAR INTERFACE
063430         T+4; *IOXT                               %
063432         A:="ONOBU"=:D                            % GET NUMBERS OF BUFFERS TO BE CREATED
063434         X:="STOCT"=:MBPOOL                       % START OF BUFFER POOL DESCRIPTORS
063436         A:=D*OBSIZE SHZ -12 +1 =: BPAGS          % NUMBER OF PAGES FOR BUFFERS.
063443         X:=0; T:=77=:D:=0                        % CALCULATE NUMBER OF WORDS FOR
063447         DO WHILE X <= D                          % IDENT ENTRY IN PHYSICAL MEMORY
063451            IF SOUIDENT(X)><0 THEN                %
063453               A*3+1+T=:T                         % T= NUMBERS OF WORDS REQUIRED.
063457            FI                                    %
063457            X+1                                   %
063460         OD                                       %
063461         A:=40*3                                  % KICK AND OMDS
063463         A+T SHZ -12 +1                           % KICK TABLES IN PHYSICAL MEMORY
063466         A+BPAGS=:X; "SBFIELD"=:B; X=:MMSIZE      % TOTAL NUMBER OF PAGES
063473         A:=100; T:=LPHYSPAGE                     %
063475         CALL GETAREA; CALL ERRFATAL              %
063477         A=:D-1+MMSIZE:=:D; AD=:OCPHYSPAGE        % FIRST AND LAST PAGE
063504         A=:D:=0; AD SH 12                        %
063507         T:=OCTICONT(0)=:B; A=:IENTBANK           %
063513         T:=A; X:=D                               %
063515         A:="ONOBU"=:D; A:=MBPOOL; CALL CBPOOL    % CREATE BUFFER POOL.
063521         A:="SBFIELD"=:B                          %
063523         AD:=OCPHYSPAGE; A+BPAGS                  %
063525         A=:D:=0; AD SH 12                        %
063530         T:=OCTICONT(0)=:B                        %
063533         A=:T; D=:X; CALL CENTRY                  % OCTOBUS TABLES IN PHYSICAL MEMORY
063536         IENTBANK=:"OCD12".OCTBANK                % SET BANK NO FOR LEVEL LINK...
063541         A=:"OCD11".OCTBANK                       % .. ELEMENTS FOR OCTOBUS.
063543         A=:"OCD10".OCTBANK                       %
063545   OUT:  A:=BREG=:B                               %
063547         GO LREG
063550   RBUS
063570
063570
063570   %==============================================================================
063570   %         N U C S T
063570   %
063570   % START UP ROUTINE FOR NUCLEUS.
063570   % ALLOCATE MEMORY FOR NUCLEUS SERVER MAILBOX, BUFFER FOR ROUTINE NCALL,
063570   % ABORT TABEL IN PHYSICAL MEMORY.
063570   %
063570   %
063570   %
063570   SUBR NUCST
063570   INTEGER POINTER LREG
063571   NUCST:
063571         A:=L=:"LREG"
063573         "SBFIELD"=:B
063575         "NXRTP" * 2 =: ABTSIZE                   % SIZE OF ABORT TABEL FOR NUCLEUS
063600         A SHZ -12+3=:X; A=:MMSIZE; A:=100        % +3 BECAUSE 2 EXTRA PAGES NEEDED
063605         T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL%
063610         A=:D-1+MMSIZE:=:D; AD=:NUPHYSPAGE        % FIRST AND LAST PAGE
063615         A=:D:=0; AD SH 12                        %
063620         A=:NMAA1;A=:SMAA1; A=:ABTBNK             % BANK NO
063623         A:=D=:NMAA2; A+2000=:SMAA2               % ADDRESS WITHIN BANK
063627         A+2000=:ABTSTART                         %
063631         0=:ABTPUT=:ABTGET                        % ABORT TABEL PUT AND GET POINTERS
063633         GO LREG
063634   RBUS
063653
063653
063653   *)KILL 99END
063653   * 99END=*
063653
063653   @DEV 1
063653   @EOF
063653

063653  %============================================================================
063653  % 47.0       B U F F E R   S I Z E S
063653  %
063653  )MCDEF ACE9I $SIZB
99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+$SIZB ; )KILL 99EIO
]
063653
063653  %============================================================================
063653  % 47.1       I O B U T
063653  %
063653  9EIOB=0          % USED TO CALCULATE THE TOTAL SIZE OF THE I/O BUFFERS
063653  IOBUT=*
063653         276   ;2000       % INTERNAL DEVICE FOR ERS
063655         277   ;100        % INTERNAL DEVICE FOR FTX ERROR LOGGER
063657         ACE9I 100

063657  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+100; )KILL 99EIO
063657
063657  "8PUN1;100003;100
063661         ACE9I 100

063661  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+100; )KILL 99EIO
063661
063661  "8LP1; 100005;120
063663         ACE9I 120

063663  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+120; )KILL 99EIO
063663
063663  "8SMO1+NSBM1
063663         20006 ;MIBU1
063665         120006;MOBU1
063667  "8LP2; 100015;120
063671         ACE9I 120

063671  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+120; )KILL 99EIO
063671
063671  "8SMO2+NSBM2
063671         20016 ;MIBU2
063673         120016;MOBU2
063675  "IND01;200   ;IDBUS
063677         ACE9I IDBUS

063677  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063677
063677  "IND02;201   ;IDBUS
063701         ACE9I IDBUS

063701  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063701
063701  "IND03;202   ;IDBUS
063703         ACE9I IDBUS

063703  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063703
063703  "IND04;203   ;IDBUS
063705         ACE9I IDBUS

063705  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063705
063705  "IND05;204   ;IDBUS
063707         ACE9I IDBUS

063707  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063707
063707  "IND06;205   ;IDBUS
063711         ACE9I IDBUS

063711  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063711
063711  "IND07;206   ;IDBUS
063713         ACE9I IDBUS

063713  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063713
063713  "IND08;207   ;IDBUS
063715         ACE9I IDBUS

063715  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063715
063715  "IND09;210   ;IDBUS
063717         ACE9I IDBUS

063717  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063717
063717  "IND10;211   ;IDBUS
063721         ACE9I IDBUS

063721  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063721
063721  "IND11;212   ;IDBUS
063723         ACE9I IDBUS

063723  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063723
063723  "IND12;213   ;IDBUS
063725         ACE9I IDBUS

063725  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063725
063725  "IND13;214   ;IDBUS
063727         ACE9I IDBUS

063727  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063727
063727  "IND14;215   ;IDBUS
063731         ACE9I IDBUS

063731  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063731
063731  "IND15;216   ;IDBUS
063733         ACE9I IDBUS

063733  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063733
063733  "IND16;217   ;IDBUS
063735         ACE9I IDBUS

063735  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063735
063735  "IND17;220   ;IDBUS
063737         ACE9I IDBUS

063737  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063737
063737  "IND18;221   ;IDBUS
063741         ACE9I IDBUS

063741  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063741
063741  "IND19;222   ;IDBUS
063743         ACE9I IDBUS

063743  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063743
063743  "IND20;223   ;IDBUS
063745         ACE9I IDBUS

063745  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063745
063745  "IND21;224   ;IDBUS
063747         ACE9I IDBUS

063747  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063747
063747  "IND22;225   ;IDBUS
063751         ACE9I IDBUS

063751  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063751
063751  "IND23;226   ;IDBUS
063753         ACE9I IDBUS

063753  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063753
063753  "IND24;227   ;IDBUS
063755         ACE9I IDBUS

063755  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063755
063755  "IND25;230   ;IDBUS
063757         ACE9I IDBUS

063757  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063757
063757  "IND26;231   ;IDBUS
063761         ACE9I IDBUS

063761  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063761
063761  "IND27;232   ;IDBUS
063763         ACE9I IDBUS

063763  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063763
063763  "IND28;233   ;IDBUS
063765         ACE9I IDBUS

063765  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063765
063765  "IND29;234   ;IDBUS
063767         ACE9I IDBUS

063767  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063767
063767  "IND30;235   ;IDBUS
063771         ACE9I IDBUS

063771  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+IDBUS; )KILL 99EIO
063771
063771  "RQIBM;540   ;200
063773         ACE9I 200

063773  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+200; )KILL 99EIO
063773
063773  "RQUNI;541   ;200
063775         ACE9I 200

063775  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+200; )KILL 99EIO
063775
063775  "RQHON;542   ;200
063777         ACE9I 200

063777  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+200; )KILL 99EIO
063777
063777  "RQCDC;543   ;200
064001         ACE9I 200

064001  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+200; )KILL 99EIO
064001
064001  "8BCH1;1237  ;300
064003         ACE9I 300

064003  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064003
064003  "8BCH2;1241  ;300
064005         ACE9I 300

064005  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064005
064005  "8BCH3;1243  ;300
064007         ACE9I 300

064007  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064007
064007  "8BCH4;1245  ;300
064011         ACE9I 300

064011  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064011
064011  "8BCH5;1247  ;300
064013         ACE9I 300

064013  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064013
064013  "8BCH6;1251  ;300
064015         ACE9I 300

064015  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064015
064015  "8BCH7;1253  ;300
064017         ACE9I 300

064017  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064017
064017  "8BCH8;1255  ;300
064021         ACE9I 300

064021  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064021
064021  "8BCH9;1257  ;300
064023         ACE9I 300

064023  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064023
064023  "8BC10;1261  ;300
064025         ACE9I 300

064025  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+300; )KILL 99EIO
064025
064025  "8ABAT 8BCH1;3300;40
064027  "8ABAT 8BCH2;3301;40
064031  "8ABAT 8BCH3;3302;40
064033  "8ABAT 8BCH4;3303;40
064035  "8ABAT 8BCH5;3304;40
064037  "8ABAT 8BCH6;3305;40
064041  "8ABAT 8BCH7;3306;40
064043  "8ABAT 8BCH8;3307;40
064045  "8ABAT 8BCH9;3310;40
064047  "8ABAT 8BC10;3311;40
064051  "8C1HD; 41360;4
064053       141361;4
064055         ACE9I 10

064055  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064055
064055  "8C2HD;41362;4
064057        141363;4
064061         ACE9I 10

064061  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064061
064061  "8C3HD; 41364;4
064063        141365;4
064065         ACE9I 10

064065  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064065
064065  "8C4HD; 41366;4
064067        141367;4
064071         ACE9I 10

064071  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064071
064071  "8C5HD; 41370;4
064073        141371;4
064075         ACE9I 10

064075  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064075
064075  "8C6HD; 41372;4
064077        141373;4
064101         ACE9I 10

064101  99EIO=9EIOB; )KILL 9EIOB; 9EIOB=99EIO+10; )KILL 99EIO
064101
064101  "8HMO1;21360;MIBU1
064103        121360;MOBU1
064105  "8HMO2;21362;MIBU2
064107        121362;MOBU2
064111  "8HMO3;21364;MIBU3
064113        121364;MOBU3
064115  "8HMO4;21366;MIBU4
064117        121366;MOBU4
064121  "8HMO5;21370;MIBU5
064123        121370;MOBU5
064125  "8HMO6;21372;MIBU6
064127        121372;MOBU6
064131  "
064131  -1
064132  EIOBU=*
064132
064132  )LINE

064132  *+1777@-12@12/
066000  *<*+24@7+24
066000  )ZERO
066000  %==============================================================================
066000  %      C X - L O G N O - T A B L E
066000  %==============================================================================
066000  %
066000  %
066000  %      L O G I C A L   N U M B E R   T A B L E S
066000  %
066000  %==============================================================================
066000  % 42.1       D V 0 0 0
066000  %
066000  DV000, 100
066001         0;0                   % 0 - DUMMY
066003
066003         DT01R;DT01W           % 1 - TERMINAL 1
066005
066005  DV000+6/DT01W                % 2 OUTPUT: ERROR DEVICE
066007  "8PUN1
066007  DV000+10/DPNCH               % 3 - FAST PUNCH
066011  "8LP1
066011  DV000+14/DLPR                % 5 - LINE PRINTER
066015  "8DLP1+8DVE1
066015  DV000+14/DILP1
066015  "8NLP1
066015  DV000+14/IDMP1
066015  "8SMO1
066015  DV000+15/IDMO1;UDMO1         % 6 - SYNCRON MODEM
066017  "8TR17 -9SMO4
066017  DV000+17/DT17R;DT17W         % 7 - TERMINAL 17
066021  "8LP2
066021  DV000+34/DLPR2               % 15 - LINE PRINTER 2
066035  "8DLP2+8DVE2
066035  DV000+34/DILP2
066035  "8NLP2
066035  DV000+34/IDMP2
066035  "8SMO2
066035  DV000+35/IDMO2;UDMO2         % 16 - SYNKRON MODEM 2
066037  "8TR18
066037  DV000+37/DT18R;DT18W         % 17 - TERMINAL 18
066041  "8DMVC
066041  DV000+46/VEDO1               % 22 - VERSATEC 1
066047  "8DMV2
066047  DV000+47/0;VEDO2             % 23 - VERSATEC 2
066051  "8M1U2
066051  DV000+53/MTDI3;MTDO3         % 25 - MAG.TAPE 1 - UNIT 3
066055  "8M2U0
066055  DV000+65/M2DI1;M2DO1         % 32 - MAG.TAPE 2 - UNIT 0
066067  "8M1U3
066067  DV000+67/MTDI4;MTDO4         % 33 - MAG.TAPE 1 UNIT 3
066071  "8M2U1
066071  DV000+71/M2DI2;M2DO2         % 34 - MAG.TAPE 2 - UNIT 1
066073  "8M1U0
066073  DV000+101/MTDI1;MTDO1        % 40 - MAGTAPE UNIT 0
066103  "8M1U1
066103  DV000+103/MTDI2;MTDO2        % 41 - MAGTAPE UNIT 1
066105  "8TR5 -8SMO8
066105  DV000+111/DT05R;DT05W        % 44 - TERMINAL 5
066113  "8TR6
066113  DV000+113/DT06R;DT06W        % 45 - TERMINAL 6
066115  "8TR7
066115  DV000+115/DT07R;DT07W        % 46 - TERMINAL 7
066117  "8TR8
066117  DV000+117/DT08R;DT08W        % 47 - TERMINAL 8
066121  "8TR19
066121  DV000+125/DT19R;DT19W        % 52 - TERMINAL 19
066127  "8TR20
066127  DV000+127/DT20R;DT20W        % 53 - TERMINAL 20
066131  "8TR21 -9SMO5
066131  DV000+131/DT21R;DT21W        % 54 - TERMINAL 21
066133  "8TR22
066133  DV000+133/DT22R;DT22W        % 55 - TERMINAL 22
066135  "8TR23
066135  DV000+135/DT23R;DT23W        % 56 - TERMINAL 23
066137  "8TR24
066137  DV000+137/DT24R;DT24W        % 57 - TERMINAL 24
066141  "8TR9 -9SMO1
066141  DV000+141/DT09R;DT09W        % 60 - TERMINAL 9
066143  "8TR10
066143  DV000+143/DT10R;DT10W        % 61 - TERMINAL 10
066145  "8TR11
066145  DV000+145/DT11R;DT11W        % 62 - TERMINAL 11
066147  "8TR12
066147  DV000+147/DT12R;DT12W        % 63 - TERMINAL 12
066151  "8TR13 -9SMO3
066151  DV000+151/DT13R;DT13W        % 64 - TERMINAL 13
066153  "8TR14
066153  DV000+153/DT14R;DT14W        % 65 - TERMINAL 14
066155  "8TR15
066155  DV000+155/DT15R;DT15W        % 66 - TERMINAL 15
066157  "8TR16
066157  DV000+157/DT16R;DT16W        % 67 - TERMINAL 16
066161  "8TR25 -8SMO9
066161  DV000+161/DT25R;DT25W        % 70 - TERMINAL 25
066163  "8TR26
066163  DV000+163/DT26R;DT26W        % 71 - TERMINAL 26
066165  "8TR27
066165  DV000+165/DT27R;DT27W        % 72 - TERMINAL 27
066167  "8TR28
066167  DV000+167/DT28R;DT28W        % 73 - TERMINAL 28
066171  "8TR29 -9SMO6
066171  DV000+171/DT29R;DT29W        % 74 - TERMINAL 29
066173  "8TR30 -9SMO7
066173  DV000+173/DT30R;DT30W        % 75 - TERMINAL 30
066175  "8TR31
066175  DV000+175/DT31R;DT31W        % 76 - TERMINAL 31
066177  "8TR32
066177  DV000+177/DT32R;DT32W        % 77 - TERMINAL 32
066201  "
066201  EN000=DV000+201
066201  EN000/
066201
066201
066201
066201  %==============================================================================
066201  % 42.2       D V 2 0 0
066201  %
066201  DV200, 100
066202  "IND01+IBL01; ID01I;ID01O
066204  "IND02+IBL02; ID02I;ID02O
066206  "IND03+IBL03; ID03I;ID03O
066210  "IND04+IBL04; ID04I;ID04O
066212  "IND05+IBL05; ID05I;ID05O
066214  "IND06; ID06I;ID06O
066216  "IND07;      ID07I;ID07O
066220  "IND08;      ID08I;ID08O
066222  "IND09;      ID09I;ID09O
066224  "IND10;      ID10I;ID10O
066226  "IND11;      ID11I;ID11O
066230  "IND12;      ID12I;ID12O
066232  "IND13;      ID13I;ID13O
066234  "IND14;      ID14I;ID14O
066236  "IND15;      ID15I;ID15O
066240  "IND16;      ID16I;ID16O
066242  "IND17;      ID17I;ID17O
066244  "IND18;      ID18I;ID18O
066246  "IND19;      ID19I;ID19O
066250  "IND20;      ID20I;ID20O
066252  "IND21; ID21I;ID21O
066254  "IND22; ID22I;ID22O
066256  "IND23; ID23I;ID23O
066260  "IND24; ID24I;ID24O
066262  "IND25; ID25I;ID25O
066264  "IND26; ID26I;ID26O
066266  "IND27; ID27I;ID27O
066270  "IND28; ID28I;ID28O
066272  "IND29; ID29I;ID29O
066274  "IND30; ID30I;ID30O
066276  "8SIBA
066276  DV200+101/SI01I;SI01O
066304         SI02I;SI02O
066306         SI03I;SI03O
066310         SI04I;SI04O
066312         SI05I;SI05O
066314         SI06I;SI06O
066316  "8SIBX
066316  DV200+115/SI07I;SI07O
066320         SI08I;SI08O
066322         SI09I;SI09O
066324         SI10I;SI10O
066326         SI11I;SI11O
066330         SI12I;SI12O
066332  "
066332  DV200+175/ERSIN;ERSUT     % INTERNAL DEVICE FOR ERS
066400  DV200+177/IDXIN;IDXUT     % INTERNAL DEVICE FOR FTX ERROR LOGGER
066402
066402  EN200=DV200+201
066402  EN200/
066402
066402
066402  %==============================================================================
066402  % 42.3       D V 3 0 0
066402  %
066402  DV300, 100
066403         SEMI1;0
066405         SEMI2;0
066407         SEMI3;0
066411         SEMI4;0
066413         SEMI5;0
066415  "8SM10+8SM20+8SM30+8SM40+8SM50
066415         SEMI6;0
066417         SEMI7;0
066421         SEMI8;0
066423         SEMI9;0
066425         SEM10;0
066427  "8SM20+8SM30+8SM40+8SM50
066427         SEM11;0
066431         SEM12;0
066433         SEM13;0
066435         SEM14;0
066437         SEM15;0
066441         SEM16;0
066443         SEM17;0
066445         SEM18;0
066447         SEM19;0
066451         SEM20;0
066453  "8SM30+8SM40+8SM50
066453         SEM21;0
066455         SEM22;0
066457         SEM23;0
066461         SEM24;0
066463         SEM25;0
066465         SEM26;0
066467         SEM27;0
066471         SEM28;0
066473         SEM29;0
066475         SEM30;0
066477  "8SM40+8SM50
066477         SEM31;0
066501         SEM32;0
066503         SEM33;0
066505         SEM34;0
066507         SEM35;0
066511         SEM36;0
066513         SEM37;0
066515         SEM38;0
066517         SEM39;0
066521         SEM40;0
066523  "8SM50
066523         SEM41;0
066525         SEM42;0
066527         SEM43;0
066531         SEM44;0
066533         SEM45;0
066535         SEM46;0
066537         SEM47;0
066541         SEM48;0
066543         SEM49;0
066545         SEM50;0
066547  "
066547  % SEMAPHORES USED BY THE BACKUP-SYSTEM
066547  DV300+167/SEM60;0            % LOGICAL DEVICE NUMBER 373B
066573         SEM61;0
066575         SEM62;0
066577         SEM63;0
066601         SEM64;0
066603  EN300=DV300+201
066603  EN300/
066603
066603
066603  %==============================================================================
066603  % 42.4       D V 4 0 0
066603  %
066603  DV400, 100
066604
066604
066604
066604
066604
066604
066604
066604
066604
066604
066604  % END OF LOG. NO TABLE FOR DIGIO   (KGS)
066604  "8CD01; DV400+121/CDF01;0
066726  "8CD02; DV400+123/CDF02;0
066730  "
066730  EN400=DV400+201
066730  EN400/
067004
067004
067004  %==============================================================================
067004  % 42.5       D V 5 0 0
067004  %
067004  DV500, 100
067005         IERRF;OERRF
067007         CLFIE;0
067011  "-8DI1
067011         0;0
067013  "
067013         RTLFI;0
067015         FS4;0
067017         FS5;0
067021         FS6;0
067023         FS7;0
067025
067025  DV500+33/
067037         DF1;0
067041         DF2;0
067043         NAMSE;0
067045         FS20;0                % GRAFS SEMAPHORE NO. 2
067047         FS21;0
067051  "8MT1
067051  DV500+55/
067061         DF3;0
067063  "-8S3C
067063  DV500+57/FS27;0
067065         ACSEM;0
067067  "SLP4
067067  DV500+65/FS532;0
067073         FS533;0
067075  "SLP5
067075  DV500+71/FS534;0
067077         FS535;0
067101  "SLP6
067101  DV500+75/FS536;0
067103         FS537;0
067105  "RQIBM
067105  DV500+101/IIBMI;IIBMO
067107  "RQUNI
067107  DV500+103/IUNII;IUNIO
067111  "RQHON
067111  DV500+105/IHONI;IHONO
067113  "RQCDC
067113  DV500+107/ICDCI;ICDCO
067115  "99TM1
067115  DV500+141/
067145         TMMT1;0
067147  "99SM1
067147  DV500+141/
067145         STMT1;0
067147  "8MT1+8MT2+8MT3+8MT4
067147  DV500+143/
067147         FS61;0                % (561) ALL MAGTAPES, DIRECTORY LOCK
067151  "SLP11
067151  DV500+145/
067151         FS62;0                % SPOOLING DEVICE 11, QUEUE SEMAPHORE.
067153  "8M2U2
067153  DV500+147/M2DI3;M2DO3        % (563) MAGTAPE 2, UNIT 2, I/O-DATAFIELD
067155  "8M2U3
067155  DV500+151/M2DI4;M2DO4        % (564) MAGTAPE 2, UNIT 3, I/O-DATAFIELD
067157  "8DMVC
067157  DV500+175/
067201         DF5;0
067203         VEFIE;0
067205  "
067205  EN500=DV500+201
067205  EN500/
067205
067205
067205  %==============================================================================
067205  % 42.6       D V 6 0 0
067205  %
067205  DV600, 100
067206  "BADAD
067206  DV600+1/BDSEM;0              % 600 - BADMIN SEMAPHORES
067210  DV600+3/F601;0               % 601 - (BASEM)
067212  "
067212  DV600+5/F602;0               % 602 - DEFAULT SUB.SYS LOC
067214
067214
067214  EN600=DV600+201
067214  EN600/
067406
067406  %==============================================================================
067406  % 42.7       D V 7 0 0
067406  %
067406  DV700, 100
067407
067407  EN700=DV700+201
067407  EN700/
067607
067607
067607  %==============================================================================
067607  % 42.8       D 1 0 0 0
067607  %
067607  D1000,100                    % PERIPHERALS
067610  "8F1U0
067610  D1000+1/F1U0I;F1U0O
067612  "8F1U1
067612  D1000+3/F1U1I;F1U1O
067614  "8F1U2
067614  D1000+5/F1U2I;F1U2O
067616  "8F2U0
067616  D1000+7/F2U0I;F2U0O
067620  "8F2U1
067620  D1000+11/F2U1I;F2U1O
067622  "8F2U2
067622  D1000+13/F2U2I;F2U2O
067624  "8HDM1;D1000+15/HDFI1;HDFO1  % 1006
067626  "8TR33;D1000+101/DT33R;DT33W
067712  "8TR34;D1000+103/DT34R;DT34W
067714  "8TR35 -8SMO7;D1000+105/DT35R;DT35W
067716  "8TR36 -8SMO8;D1000+107/DT36R;DT36W
067720  "8TR37 -8SMO9;D1000+111/DT37R;DT37W
067722  "8TR38 -9SMO1;D1000+113/DT38R;DT38W
067724  "8TR39 -9SMO2;D1000+115/DT39R;DT39W
067726  "8TR40 -9SMO3;D1000+117/DT40R;DT40W
067730  "8TR41 -9SMO4;D1000+121/DT41R;DT41W
067732  "8TR42 -9SMO5;D1000+123/DT42R;DT42W
067734  "8TR43 -9SMO6;D1000+125/DT43R;DT43W
067736  "8TR44 -9SMO7;D1000+127/DT44R;DT44W
067740  "8TR45;D1000+131/DT45R;DT45W
067742  "8TR46;D1000+133/DT46R;DT46W
067744  "8TR47;D1000+135/DT47R;DT47W
067746  "8TR48;D1000+137/DT48R;DT48W
067750  "8TR49;D1000+141/DT49R;DT49W
067752  "8TR50;D1000+143/DT50R;DT50W
067754  "8TR51;D1000+145/DT51R;DT51W
067756  "8TR52;D1000+147/DT52R;DT52W
067760  "
067760  E1000=D1000+201
067760  E1000/
070010
070010  %==============================================================================
070010  % 42.9       D 1 1 0 0
070010  %
070010  D1100,100                    % SYSTEM DEVICES
070011  "8BD1
070011  BIGDI;0
070013  "3B1U0+6B1U0+7B1U0+2B1U0+4B1U0+3C1U0+6C1U0+9C1U0+3D1U0+2D1U0+1E1U0+2E1U0+3E1U0+5E1U0+7E1U0+8E1U0+EE1U0+FE1U0+GE1U0+HE1U0+8S1U0
070013  F1101;0
070015  F1102;0
070017  "99TM2
070017  D1100+23/TMMT2;0             % 1111 - MAGTAPE CONTROLLER 2 DATAFIELD
070035  "99SM2
070035  D1100+23/STMT2;0             % 1111 - MAGTAPE CONTROLLER 2 DATAFIELD
070035  "8MT2
070035  D1100+35/DF7;0               % 1116 - DF7 DATAFIELD
070047  "3B1U1+6B1U1+7B1U1+2B1U1+4B1U1+3C1U1+6C1U1+9C1U1+3D1U1+2D1U1+1E1U1+2E1U1+3E1U1+5E1U1+7E1U1+8E1U1+EE1U1+FE1U1+GE1U1+HE1U1+8S1U1
070047  D1100+37/F1117;0
070051         F1120;0
070053  "3B1U2+6B1U2+7B1U2+2B1U2+4B1U2+3C1U2+6C1U2+9C1U2+3D1U2+2D1U2+1E1U2+2E1U2+3E1U2+5E1U2+7E1U2+8E1U2+EE1U2+FE1U2+GE1U2+HE1U2
070053  D1100+43/F1121;0
070055         F1122;0
070057  "3B1U3+6B1U3+7B1U3+2B1U3+4B1U3+3C1U3+6C1U3+9C1U3+3D1U3+2D1U3+1E1U3+2E1U3+3E1U3+5E1U3+7E1U3+8E1U3+EE1U3+FE1U3+GE1U3+HE1U3
070057  D1100+47/F1123;0
070061         F1124;0
070063  "8DMV2
070063  D1100+53/VE2FI;0
070065         DF8;0
070067  "SLP1+SLP12
070067  D1100+75/
070105  F1136;0
070107  F1137;0
070111  "SLP2
070111  D1100+101/
070111  F1140;0
070113  F1141;0
070115  "
070115  D1100+105/
070115  F1142;0
070117  F1143;0
070121  F1144;0
070123  % ************
070123  "8FDI1+8BFD1
070123  D1100+113/FDID1;0
070125         DF9;0
070127  "8F1U0
070127  D1100+121/F1150;0
070133         F1151;0
070135  "8F1U1
070135  D1100+125/F1152;0
070137         F1153;0
070141  "8F1U2
070141  D1100+131/F1154;0
070143         F1155;0
070145  "8FDI2+8BFD2
070145  D1100+135/FDID2;0
070147         DF10;0
070151  "8F2U0
070151  D1100+143/F1161;0
070155         F1162;0
070157  "8F2U1
070157  D1100+147/F1163;0
070161         F1164;0
070163  "8F2U2
070163  D1100+153/F1165;0
070165         F1166;0
070167  "8DLP1+8DVE1
070167  D1100+157/DMLP1;0
070171  "8NLP1
070171  D1100+157/DMPR1;0            % 1167: DMA LINEPRINTER #1
070171  "8DLP1+8DVE1+8NLP1
070171  D1100+161/DF11; 0
070173  "SLP3
070173  D1100+167/F1173;0
070201         F1174;0
070203  "8DLP2+8DVE2
070203  D1100+173/DMLP2;0
070205  "8NLP2
070205  D1100+173/DMPR2;0            % 1175: DMA LINEPRINTER #2
070205  "8DLP2+8DVE2+8NLP2
070205  D1100+175/DF12; 0
070207  "
070207  D1100+177/F1177;0
070211  E1100=D1100+201
070211  E1100/
070211
070211  %==============================================================================
070211  % 42.10      D 1 2 0 0
070211  %
070211  D1200,100
070212         F1200;0               % *** SPECIAL FOR NORD TPS ***
070214         D1201;0
070216  "8LOG
070216  D1200+5/F1202;0              % RT-PROGRAM-LOG
070220  "8HIST
070220  D1200+7/F1203;0              % HISTOGRAM LOCK.
070222  "-8S3C
070222  D1200+11/F1204;0             % LOCK FOR SINTRAN SERVICE PROGRAM
070224  D1200+13/F1205;0             % MAIL
070226  "
070226  D1200+15/DT01R;DT01W         % 1206 - TERMINAL 1
070230  "8BD2
070230  D1200+17/BIGD2               % 1207 - BIG DISC CONTROLLER 2
070231  "IBL01
070231  D1200+21/IB01I;IB01O
070234         DF13;0
070236  "IBL02
070236  D1200+25/IB02I;IB02O
070240         DF14;0
070242  "
070242  D1200+45/F1222;0             % TERMINATION COMMAND BUFFER LOCK
070260         F1223;0               % GRAFS SEMAPHORE NO. 1
070262  "8WD1+8MD1
070262  D1200+51/WIGDI;0             % 1224 WINCHESTER CONTROLLER 1 (14,21,23 OR 45MB).
070264  "8M3U0
070264  D1200+65/M3DI1;M3DO1         % 1232 MAGTAPE CONTROLLER 3, UNIT 0, I/O-DATAF.
070300  "8BCH1
070300  D1200+75/BT01R;BT01W         %1236
070310         BT01I;BT01O
070312  "8BCH2
070312  D1200+101/BT02R;BT02W        %1240
070314         BT02I;BT02O
070316  "8BCH3
070316  D1200+105/BT03R;BT03W        %1242
070320         BT03I;BT03O
070322  "8BCH4
070322  D1200+111/BT04R;BT04W        %1244
070324         BT04I;BT04O
070326  "8BCH5
070326  D1200+115/BT05R;BT05W        %1246
070330         BT05I;BT05O
070332  "8BCH6
070332  D1200+121/BT06R;BT06W        %1250
070334         BT06I;BT06O
070336  "8BCH7
070336  D1200+125/BT07R;BT07W        %1252
070340         BT07I;BT07O
070342
070342  "8BCH8
070342  D1200+131/BT08R;BT08W        % 1254
070344         BT08I;BT08O
070346  "8BCH9
070346  D1200+135/BT09R;BT09W        % 1256
070350         BT09I;BT09O
070352  "8BC10
070352  D1200+141/BT10R;BT10W
070354         BT10I;BT10O
070356  "SLP7
070356  D1200+145/F1262;0
070360         F1263;0
070362  "SLP8
070362  D1200+151/F1264;0
070364         F1265;0
070366  "SLP9
070366  D1200+155/F1266;0
070370         F1267;0
070372  "SLP10
070372  D1200+161/F1270;0
070374         F1271;0
070376  "IBL01
070376  D1200+165/DF20;0
070400  "IBL02
070400  D1200+167/DF21;0
070402  "
070402         0;0;0;0;0;0
070410
070410  E1200=D1200+201
070410  E1200/
070412
070412  %==============================================================================
070412  % 42.11      D 1 3 0 0
070412  %
070412  D1300,100
070413  "8HDM1
070413  D1300+7/HDMI1;0
070423          HDMO1;0
070425          DF25;0
070427          DF26;0
070431  "3B2U0+6B2U0+7B2U0+2B2U0+4B2U0+3C2U0+6C2U0+9C2U0+3D2U0+2D2U0+1E2U0+2E2U0+3E2U0+5E2U0+7E2U0+8E2U0+EE2U0+FE2U0+GE2U0+HE2U0+8S2U0
070431  D1300+67/F1333;0
070503           F1334;0
070505  "3B2U1+6B2U1+7B2U1+2B2U1+4B2U1+3C2U1+6C2U1+9C2U1+3D2U1+2D2U1+1E2U1+2E2U1+3E2U1+5E2U1+7E2U1+8E2U1+EE2U1+FE2U1+GE2U1+HE2U1+8S2U1
070505  D1300+73/F1335;0
070507           F1336;0
070511  "3B2U2+6B2U2+7B2U2+2B2U2+4B2U2+3C2U2+6C2U2+9C2U2+3D2U2+2D2U2+1E2U2+2E2U2+3E2U2+5E2U2+7E2U2+8E2U2+EE2U2+FE2U2+GE2U2+HE2U2
070511  D1300+77/F1337;0
070513           F1340;0
070515  "3B2U3+6B2U3+7B2U3+2B2U3+4B2U3+3C2U3+6C2U3+9C2U3+3D2U3+2D2U3+1E2U3+2E2U3+3E2U3+5E2U3+7E2U3+8E2U3+EE2U3+FE2U3+GE2U3+HE2U3
070515  D1300+103/F1341;0
070517           F1342;0
070521  "SLP11
070521  D1300+117/F1347;0            % 1347 : SPOOLING DEVICE 11, QUEUE I/O SEMAPHORE.
070533  "SLP12
070533  D1300+121/F1350;0            % 1350 : SPOOLING DEVICE 12, QUEUE SEMAPHORE.
070535            F1351;0            % 1351 : SPOOLING DEVICE 12, QUEUE I/O SEMAPHORE.
070537  "8LOG
070537  D1300+125/F1352;0
070541  "8HMO1
070541  D1300+141/IDHM1;UDHM1        % 1360              SYNC MODEM FOR HDLC INTERFACE
070555  "8C1HD
070555  D1300+141/HDIF1;0            % 1360              HDLC-1 INPUT
070555  D1300+143/0;HDOF1            % 1361              HDLC-1 OUTPUT
070557  "8HMO2
070557  D1300+145/IDHM2;UDHM2        % 1362              SYNC MODEM FOR HDLC INTERFACE
070561  "8C2HD
070561  D1300+145/HDIF2;0            % 1362              HDLC-2 INPUT
070561  D1300+147/0;HDOF2            % 1363              HDLC-2 OUTPUT
070563  "8HMO3
070563  D1300+151/IDHM3;UDHM3        % 1364              SYNC MODEM FOR HDLC INTERFACE
070565  "8C3HD
070565  D1300+151/HDIF3;0            % 1364              HDLC-3 INPUT
070565  D1300+153/0;HDOF3            % 1365              HDLC-3 OUTPUT
070567  "8HMO4
070567  D1300+155/IDHM4;UDHM4        % 1366              SYNC MODEM FOR HDLC INTERFACE
070571  "8C4HD
070571  D1300+155/HDIF4;0            % 1366              HDLC-4 INPUT
070571  D1300+157/0;HDOF4            % 1367              HDLC-4 OUTPUT
070573  "8HMO5
070573  D1300+161/IDHM5;UDHM5        % 1370              SYNC MODEM FOR HDLC INTERFACE
070575  "8C5HD
070575  D1300+161/HDIF5;0            % 1370              HDLC-5 INPUT
070575  D1300+163/0;HDOF5            % 1371              HDLC-5 OUTPUT
070577  "8HMO6
070577  D1300+165/IDHM6;UDHM6        % 1372              SYNC MODEM FOR HDLC INTERFACE
070601  "8C6HD
070601  D1300+165/HDIF6;0            % 1372              HDLC-6 INPUT
070601  D1300+167/0;HDOF6            % 1373              HDLC-6 OUTPUT
070603  "8C1X2
070603  D1300+171/X21F1;0            % 1374              X21 LINE 1
070605  "8C2X2
070605  D1300+173/X21F2;0            % 1375              X21 LINE 2
070607  "
070607  E1300=D1300+201
070607  E1300/
070613
070613
070613  %==============================================================================
070613  % 42.11.01   D 1 4 0 0
070613  %
070613  D1400, 100
070614  "BAD01;D1400+1/BD01R;BD01W             % 1400 - BACKGROUND-ACCESS-DEVICE  1
070616  "BAD02;D1400+3/BD02R;BD02W             % 1401 - BACKGROUND-ACCESS-DEVICE  2
070620  "BAD03;D1400+5/BD03R;BD03W             % 1402 - BACKGROUND-ACCESS-DEVICE  3
070622  "BAD04;D1400+7/BD04R;BD04W             % 1403 - BACKGROUND-ACCESS-DEVICE  4
070624  "BAD05;D1400+11/BD05R;BD05W            % 1404 - BACKGROUND-ACCESS-DEVICE  5
070626  "BAD06;D1400+13/BD06R;BD06W            % 1405 - BACKGROUND-ACCESS-DEVICE  6
070630  "BAD07;D1400+15/BD07R;BD07W            % 1406 - BACKGROUND-ACCESS-DEVICE  7
070632  "BAD08;D1400+17/BD08R;BD08W            % 1407 - BACKGROUND-ACCESS-DEVICE  8
070634  "BAD09;D1400+21/BD09R;BD09W            % 1410 - BACKGROUND-ACCESS-DEVICE  9
070636  "BAD10;D1400+23/BD10R;BD10W            % 1411 - BACKGROUND-ACCESS-DEVICE 10
070640  "BAD11;D1400+25/BD11R;BD11W            % 1412 - BACKGROUND-ACCESS-DEVICE 11
070642  "BAD12;D1400+27/BD12R;BD12W            % 1413 - BACKGROUND-ACCESS-DEVICE 12
070644  "BAD13;D1400+31/BD13R;BD13W            % 1414 - BACKGROUND-ACCESS-DEVICE 13
070646  "BAD14;D1400+33/BD14R;BD14W            % 1415 - BACKGROUND-ACCESS-DEVICE 14
070650  "BAD15;D1400+35/BD15R;BD15W            % 1416 - BACKGROUND-ACCESS-DEVICE 15
070652  "BAD16;D1400+37/BD16R;BD16W            % 1417 - BACKGROUND-ACCESS-DEVICE 16
070654  "BAD17;D1400+41/BD17R;BD17W            % 1420 - BACKGROUND-ACCESS-DEVICE 17
070656  "BAD18;D1400+43/BD18R;BD18W            % 1421 - BACKGROUND-ACCESS-DEVICE 18
070660  "BAD19;D1400+45/BD19R;BD19W            % 1422 - BACKGROUND-ACCESS-DEVICE 19
070662  "BAD20;D1400+47/BD20R;BD20W            % 1423 - BACKGROUND-ACCESS-DEVICE 20
070664  "BAD21;D1400+51/BD21R;BD21W            % 1424 - BACKGROUND-ACCESS-DEVICE 21
070666  "BAD22;D1400+53/BD22R;BD22W            % 1425 - BACKGROUND-ACCESS-DEVICE 22
070670  "BAD23;D1400+55/BD23R;BD23W            % 1426 - BACKGROUND-ACCESS-DEVICE 23
070672  "BAD24;D1400+57/BD24R;BD24W            % 1427 - BACKGROUND-ACCESS-DEVICE 24
070674  "BAD25;D1400+61/BD25R;BD25W            % 1430 - BACKGROUND-ACCESS-DEVICE 25
070676  "BAD26;D1400+63/BD26R;BD26W            % 1431 - BACKGROUND-ACCESS-DEVICE 26
070700  "BAD27;D1400+65/BD27R;BD27W            % 1432 - BACKGROUND-ACCESS-DEVICE 27
070702  "BAD28;D1400+67/BD28R;BD28W            % 1433 - BACKGROUND-ACCESS-DEVICE 28
070704  "BAD29;D1400+71/BD29R;BD29W            % 1434 - BACKGROUND-ACCESS-DEVICE 29
070706  "BAD30;D1400+73/BD30R;BD30W            % 1435 - BACKGROUND-ACCESS-DEVICE 30
070710  "BAD31;D1400+75/BD31R;BD31W            % 1436 - BACKGROUND-ACCESS-DEVICE 31
070712  "BAD32;D1400+77/BD32R;BD32W            % 1437 - BACKGROUND-ACCESS-DEVICE 32
070714  "BAD33;D1400+101/BD33R;BD33W           % 1440 - BACKGROUND-ACCESS-DEVICE 33
070716  "BAD34;D1400+103/BD34R;BD34W           % 1441 - BACKGROUND-ACCESS-DEVICE 34
070720  "BAD35;D1400+105/BD35R;BD35W           % 1442 - BACKGROUND-ACCESS-DEVICE 35
070722  "BAD36;D1400+107/BD36R;BD36W           % 1443 - BACKGROUND-ACCESS-DEVICE 36
070724  "BAD37;D1400+111/BD37R;BD37W           % 1444 - BACKGROUND-ACCESS-DEVICE 37
070726  "BAD38;D1400+113/BD38R;BD38W           % 1445 - BACKGROUND-ACCESS-DEVICE 38
070730  "BAD39;D1400+115/BD39R;BD39W           % 1446 - BACKGROUND-ACCESS-DEVICE 39
070732  "BAD40;D1400+117/BD40R;BD40W           % 1447 - BACKGROUND-ACCESS-DEVICE 40
070734  "BAD41;D1400+121/BD41R;BD41W           % 1450 - BACKGROUND-ACCESS-DEVICE 41
070736  "BAD42;D1400+123/BD42R;BD42W           % 1451 - BACKGROUND-ACCESS-DEVICE 42
070740  "BAD43;D1400+125/BD43R;BD43W           % 1452 - BACKGROUND-ACCESS-DEVICE 43
070742  "BAD44;D1400+127/BD44R;BD44W           % 1453 - BACKGROUND-ACCESS-DEVICE 44
070744  "BAD45;D1400+131/BD45R;BD45W           % 1454 - BACKGROUND-ACCESS-DEVICE 45
070746  "BAD46;D1400+133/BD46R;BD46W           % 1455 - BACKGROUND-ACCESS-DEVICE 46
070750  "BAD47;D1400+135/BD47R;BD47W           % 1456 - BACKGROUND-ACCESS-DEVICE 47
070752  "BAD48;D1400+137/BD48R;BD48W           % 1457 - BACKGROUND-ACCESS-DEVICE 48
070754  "BAD49;D1400+141/BD49R;BD49W           % 1460 - BACKGROUND-ACCESS-DEVICE 49
070756  "BAD50;D1400+143/BD50R;BD50W           % 1461 - BACKGROUND-ACCESS-DEVICE 50
070760  "BAD51;D1400+145/BD51R;BD51W           % 1462 - BACKGROUND-ACCESS-DEVICE 51
070762  "BAD52;D1400+147/BD52R;BD52W           % 1463 - BACKGROUND-ACCESS-DEVICE 52
070764  "BAD53;D1400+151/BD53R;BD53W           % 1464 - BACKGROUND-ACCESS-DEVICE 53
070766  "BAD54;D1400+153/BD54R;BD54W           % 1465 - BACKGROUND-ACCESS-DEVICE 54
070770  "BAD55;D1400+155/BD55R;BD55W           % 1466 - BACKGROUND-ACCESS-DEVICE 55
070772  "BAD56;D1400+157/BD56R;BD56W           % 1467 - BACKGROUND-ACCESS-DEVICE 56
070774  "BAD57;D1400+161/BD57R;BD57W           % 1470 - BACKGROUND-ACCESS-DEVICE 57
070776  "BAD58;D1400+163/BD58R;BD58W           % 1471 - BACKGROUND-ACCESS-DEVICE 58
071000  "BAD59;D1400+165/BD59R;BD59W           % 1472 - BACKGROUND-ACCESS-DEVICE 59
071002  "BAD60;D1400+167/BD60R;BD60W           % 1473 - BACKGROUND-ACCESS-DEVICE 60
071004  "BAD61;D1400+171/BD61R;BD61W           % 1474 - BACKGROUND-ACCESS-DEVICE 61
071006  "BAD62;D1400+173/BD62R;BD62W           % 1475 - BACKGROUND-ACCESS-DEVICE 62
071010  "BAD63;D1400+175/BD63R;BD63W           % 1476 - BACKGROUND-ACCESS-DEVICE 63
071012  "BAD64;D1400+177/BD64R;BD64W           % 1477 - BACKGROUND-ACCESS-DEVICE 64
071014  "
071014  E1400=D1400+201
071014  E1400/
071014
071014
071014  %==============================================================================
071014  % 42.11.02   D 1 5 0 0
071014  %
071014  D1500, 100
071015  "BAD65;D1500+1/BD65R;BD65W             % 1500 - BACKGROUND-ACCESS-DEVICE 65
071017  "BAD66;D1500+3/BD66R;BD66W             % 1501 - BACKGROUND-ACCESS-DEVICE 66
071021  "BAD67;D1500+5/BD67R;BD67W             % 1502 - BACKGROUND-ACCESS-DEVICE 67
071023  "BAD68;D1500+7/BD68R;BD68W             % 1503 - BACKGROUND-ACCESS-DEVICE 68
071025  "BAD69;D1500+11/BD69R;BD69W            % 1504 - BACKGROUND-ACCESS-DEVICE 69
071027  "BAD70;D1500+13/BD70R;BD70W            % 1505 - BACKGROUND-ACCESS-DEVICE 70
071031  "
071031  9EBAD=*
071031
071031  "TEFX1;D1500+101/TR01R;TR01W           % 1540 - TELEFIX-TERMINAL 1
071117  "TEFX1;D1500+141/TB01R;TB01W           % 1560 - TELEFIX-BACKGROUND-TERMINAL 1
071157  "
071157
071157  E1500=D1500+201
071157  E1500/
071215
071215
071215  %==============================================================================
071215  % 42.11.03   D 1 6 0 0
071215  D1600, 100
071216  "8BU0+8BU1+8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
071216  D1600+1/  F1600; 0
071220  "8BU1+8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
071220  D1600+3/  F1601; 0
071222  "8BU2+8BU3+8BU4+8BU5+8BU6+8BU7
071222  D1600+5/  F1602; 0
071224  "8BU3+8BU4+8BU5+8BU6+8BU7
071224  D1600+7/  F1603; 0
071226  "8BU4+8BU5+8BU6+8BU7
071226  D1600+11/ F1604; 0
071230  "8BU5+8BU6+8BU7
071230  D1600+13/ F1605; 0
071232  "8BU6+8BU7
071232  D1600+15/ F1606; 0
071234  "8BU7
071234  D1600+17/ F1607; 0
071236  %
071236  %      THE REMAINING DEVICE BUFFER HEADERS ARE ALLOCATED IN GROUPS OF 10
071236  %
071236  "8BU10+8BU20+8BU30+8BU40+8BU50+8BU60+8BU70
071236  D1600+21/ F1610; 0
071240            F1611; 0
071242            F1612; 0
071244            F1613; 0
071246            F1614; 0
071250            F1615; 0
071252            F1616; 0
071254            F1617; 0
071256  "8BU20+8BU30+8BU40+8BU50+8BU60+8BU70
071256  D1600+41/ F1620; 0
071260            F1621; 0
071262            F1622; 0
071264            F1623; 0
071266            F1624; 0
071270            F1625; 0
071272            F1626; 0
071274            F1627; 0
071276  "8BU30+8BU40+8BU50+8BU60+8BU70
071276  D1600+61/ F1630; 0
071300            F1631; 0
071302            F1632; 0
071304            F1633; 0
071306            F1634; 0
071310            F1635; 0
071312            F1636; 0
071314            F1637; 0
071316  "8BU40+8BU50+8BU60+8BU70
071316  D1600+101/F1640; 0
071320            F1641; 0
071322            F1642; 0
071324            F1643; 0
071326            F1644; 0
071330            F1645; 0
071332            F1646; 0
071334            F1647; 0
071336  "8BU50+8BU60+8BU70
071336  D1600+121/F1650; 0
071340            F1651; 0
071342            F1652; 0
071344            F1653; 0
071346            F1654; 0
071350            F1655; 0
071352            F1656; 0
071354            F1657; 0
071356  "8BU60+8BU70
071356  D1600+141/F1660; 0
071360            F1661; 0
071362            F1662; 0
071364            F1663; 0
071366            F1664; 0
071370            F1665; 0
071372            F1666; 0
071374            F1667; 0
071376  "8BU70
071376  D1600+161/F1670; 0
071400            F1671; 0
071402            F1672; 0
071404            F1673; 0
071406            F1674; 0
071410            F1675; 0
071412            F1676; 0
071414            F1677; 0
071416  "
071416  E1600=D1600+201
071416  E1600/
071416
071416
071416  %==============================================================================
071416  % 42.11.04   D 1 7 0 0
071416
071416  D1700, 100
071417  "8PC01; D1700+1/PIO01;PIO01            % 1700 PIOC #  1
071421  "8PC02; D1700+3/PIO02;PIO02            % 1701 PIOC #  2
071423  "8PC03; D1700+5/PIO03;PIO03            % 1702 PIOC #  3
071425  "8PC04; D1700+7/PIO04;PIO04            % 1703 PIOC #  4
071427  "
071427
071427  "SLP13
071427  D1700+45/    F1722;0                   % 1722 : SPOOLING DEVICE 13, QUEUE SEMAPHORE.
071465               F1723;0                   % 1723 : SPOOLING DEVICE 13, QUEUE I/O SEMAPHORE.
071467  "SLP14
071467  D1700+51/    F1724;0                   % 1724 : SPOOLING DEVICE 14, QUEUE SEMAPHORE.
071471               F1725;0                   % 1725 : SPOOLING DEVICE 14, QUEUE I/O SEMAPHORE.
071473  "SLP15
071473  D1700+55/    F1726;0                   % 1726 : SPOOLING DEVICE 15, QUEUE SEMAPHORE. (AND COSMOS SPOOLING)
071475               F1727;0                   % 1727 : SPOOLING DEVICE 15, QUEUE I/O SEMAPHORE.
071477  "8RFAC
071477  D1700+61/    DFRRT;0                   % 1730 : REMOTE FILE ACCESS, DF DATAFIELD
071501  "8COSP
071501  D1700+63/    0;F1731                   % 1731 : COSMOS SPOOLING PERIPHERAL DEVICE
071503  "4M1U0+2M1U0+1M1U0+3M1U0+7M1U0
071503  D1700+65/    F1732;0                   % 1732 : 45/23 MBYTE DIRECTORY, UNIT 0 DIRECTORY LOCK.
071505  "4M1U1+2M1U1+1M1U1+3M1U1+7M1U1
071505  D1700+67/    F1733;0                   % 1733 : 45/23 MBYTE DIRECTORY, UNIT 1 DIRECTORY LOCK.
071507  "4M1U0+2M1U0+1M1U0+3M1U0+7M1U0
071507  D1700+71/    F1734;0                   % 1734 : 45/23 MBYTE DIRECTORY, UNIT 0 BIT FILE LOCK.
071511  "4M1U1+2M1U1+1M1U1+3M1U1+7M1U1
071511  D1700+73/    F1735;0                   % 1735 : 45/23 MBYTE DIRECTORY, UNIT 1 BIT FILE LOCK.
071513
071513  "8SIBA+8SIBX+8SIBM+8SIBN
071513  D1700+121/DSI0;DIA0                    % 1750 : SIBAS # 0
071541            DSI1;DIA1                    % 1751 : SIBAS # 1
071543            DSI2;DIA2                    % 1752 : SIBAS # 2
071545  "8SIBX+8SIBM+8SIBN
071545            DSI3;DIA3                    % 1753 : SIBAS # 3
071547            DSI4;DIA4                    % 1754 : SIBAS # 4
071551            DSI5;DIA5                    % 1755 : SIBAS # 5
071553  "8SIBM+8SIBN
071553            DSI6;DIA6                    % 1756 : SIBAS # 6
071555            DSI7;DIA7                    % 1757 : SIBAS # 7
071557            DSI8;DIA8                    % 1760 : SIBAS # 8
071561            DSI9;DIA9                    % 1761 : SIBAS # 9
071563            DSI10;DIA10                  % 1762 : SIBAS # 10
071565            DSI11;DIA11                  % 1763 : SIBAS # 11
071567  "
071567
071567
071567  E1700=D1700+201
071567  E1700/
071617
071617  %==============================================================================
071617  % 42.11.05   D 2 0 0 0
071617
071617  D2000, 100
071620  "8TR65;D2000+001/DT65R;DT65W           % TERMINAL #65
071622  "8TR66;D2000+003/DT66R;DT66W           % TERMINAL #66
071624  "8TR67;D2000+005/DT67R;DT67W           % TERMINAL #67
071626  "8TR68;D2000+007/DT68R;DT68W           % TERMINAL #68
071630  "8TR69;D2000+011/DT69R;DT69W           % TERMINAL #69
071632  "8TR70;D2000+013/DT70R;DT70W           % TERMINAL #70
071634  "8TR71;D2000+015/DT71R;DT71W           % TERMINAL #71
071636  "8TR72;D2000+017/DT72R;DT72W           % TERMINAL #72
071640  "8TR73;D2000+021/DT73R;DT73W           % TERMINAL #73
071642  "8TR74;D2000+023/DT74R;DT74W           % TERMINAL #74
071644  "8TR75;D2000+025/DT75R;DT75W           % TERMINAL #75
071646  "8TR76;D2000+027/DT76R;DT76W           % TERMINAL #76
071650  "8TR77;D2000+031/DT77R;DT77W           % TERMINAL #77
071652  "8TR78;D2000+033/DT78R;DT78W           % TERMINAL #78
071654  "8TR79;D2000+035/DT79R;DT79W           % TERMINAL #79
071656  "8TR80;D2000+037/DT80R;DT80W           % TERMINAL #80
071660  "8TR81;D2000+041/DT81R;DT81W           % TERMINAL #81
071662  "8TR82;D2000+043/DT82R;DT82W           % TERMINAL #82
071664  "8TR83;D2000+045/DT83R;DT83W           % TERMINAL #83
071666  "8TR84;D2000+047/DT84R;DT84W           % TERMINAL #84
071670  "8TR85;D2000+051/DT85R;DT85W           % TERMINAL #85
071672  "8TR86;D2000+053/DT86R;DT86W           % TERMINAL #86
071674  "8TR87;D2000+055/DT87R;DT87W           % TERMINAL #87
071676  "8TR88;D2000+057/DT88R;DT88W           % TERMINAL #88
071700  "8TR89;D2000+061/DT89R;DT89W           % TERMINAL #89
071702  "8TR90;D2000+063/DT90R;DT90W           % TERMINAL #90
071704  "8TR91;D2000+065/DT91R;DT91W           % TERMINAL #91
071706  "8TR92;D2000+067/DT92R;DT92W           % TERMINAL #92
071710  "8TR93;D2000+071/DT93R;DT93W           % TERMINAL #93
071712  "8TR94;D2000+073/DT94R;DT94W           % TERMINAL #94
071714  "8TR95;D2000+075/DT95R;DT95W           % TERMINAL #95
071716  "8TR96;D2000+077/DT96R;DT96W           % TERMINAL #96
071720  "8TR97;D2000+101/DT97R;DT97W           % TERMINAL #97
071722  "8TR98;D2000+103/DT98R;DT98W           % TERMINAL #98
071724  "8TR99;D2000+105/DT99R;DT99W           % TERMINAL #99
071726  "9TR00;D2000+107/T100R;T100W           % TERMINAL #100
071730  "9TR01;D2000+111/T101R;T101W           % TERMINAL #101
071732  "9TR02;D2000+113/T102R;T102W           % TERMINAL #102
071734  "9TR03;D2000+115/T103R;T103W           % TERMINAL #103
071736  "9TR04;D2000+117/T104R;T104W           % TERMINAL #104
071740  "9TR05;D2000+121/T105R;T105W           % TERMINAL #105
071742  "9TR06;D2000+123/T106R;T106W           % TERMINAL #106
071744  "9TR07;D2000+125/T107R;T107W           % TERMINAL #107
071746  "9TR08;D2000+127/T108R;T108W           % TERMINAL #108
071750  "9TR09;D2000+131/T109R;T109W           % TERMINAL #109
071752  "9TR10;D2000+133/T110R;T110W           % TERMINAL #110
071754  "9TR11;D2000+135/T111R;T111W           % TERMINAL #111
071756  "9TR12;D2000+137/T112R;T112W           % TERMINAL #112
071760  "9TR13;D2000+141/T113R;T113W           % TERMINAL #113
071762  "9TR14;D2000+143/T114R;T114W           % TERMINAL #114
071764  "9TR15;D2000+145/T115R;T115W           % TERMINAL #115
071766  "9TR16;D2000+147/T116R;T116W           % TERMINAL #116
071770  "9TR17;D2000+151/T117R;T117W           % TERMINAL #117
071772  "9TR18;D2000+153/T118R;T118W           % TERMINAL #118
071774  "9TR19;D2000+155/T119R;T119W           % TERMINAL #119
071776  "9TR20;D2000+157/T120R;T120W           % TERMINAL #120
072000  "9TR21;D2000+161/T121R;T121W           % TERMINAL #121
072002  "9TR22;D2000+163/T122R;T122W           % TERMINAL #122
072004  "9TR23;D2000+165/T123R;T123W           % TERMINAL #123
072006  "9TR24;D2000+167/T124R;T124W           % TERMINAL #124
072010  "9TR25;D2000+171/T125R;T125W           % TERMINAL #125
072012  "9TR26;D2000+173/T126R;T126W           % TERMINAL #126
072014  "9TR27;D2000+175/T127R;T127W           % TERMINAL #127
072016  "9TR28;D2000+177/T128R;T128W           % TERMINAL #128
072020  "
072020
072020  E2000=D2000+201
072020  E2000/
072020
072020  %==============================================================================
072020  % 42.11.06   D 2 1 0 0
072020
072020  D2100, 100
072021  "8UD01+8VI01
072021  D2100+ 1/UDI01;UDO01                   % 2100: UNIVERSAL DMA/VICOM INTERFACE 1
072023  "8UD02+8VI02
072023  D2100+ 3/UDI02;UDO02                   % 2101: UNIVERSAL DMA/VICOM INTERFACE 2
072025  "
072025  "8GPI0; D2100+41/ DTGP0;0              % 2120    GPIB INTERFACE  # 0
072063  "
072063  "SLP16; D2100+61/ F2130;0              % 2130    SPOOLING DEVICE 16, QUEUE SEMA
072103          D2100+63/ F2131;0              % 2131    SPOOLING DEVICE 16, I/O SEMA
072105  "SLP17; D2100+65/ F2132;0              % 2132    SPOOLING DEVICE 17, QUEUE SEMA
072107          D2100+67/ F2133;0              % 2133    SPOOLING DEVICE 17, I/O SEMA
072111  "SLP18; D2100+71/ F2134;0              % 2134    SPOOLING DEVICE 18, QUEUE SEMA
072113          D2100+73/ F2135;0              % 2135    SPOOLING DEVICE 18, I/O SEMA
072115  "SLP19; D2100+75/ F2136;0              % 2136    SPOOLING DEVICE 19, QUEUE SEMA
072117          D2100+77/ F2137;0              % 2137    SPOOLING DEVICE 19, I/O SEMA
072121  "SLP20; D2100+101/ F2140;0             % 2140    SPOOLING DEVICE 20, QUEUE SEMA
072123          D2100+103/ F2141;0             % 2141    SPOOLING DEVICE 20, I/O SEMA
072125  "SLP21; D2100+105/ F2142;0             % 2142    SPOOLING DEVICE 21, QUEUE SEMA
072127          D2100+107/ F2143;0             % 2143    SPOOLING DEVICE 21, I/O SEMA
072131  "SLP22; D2100+111/ F2144;0             % 2144    SPOOLING DEVICE 22, QUEUE SEMA
072133          D2100+113/ F2145;0             % 2145    SPOOLING DEVICE 22, I/O SEMA
072135  "8COSP
072135          D2100+155/ F2166;0             % 2166    COSMOS SPOOLING   , QUEUE SEMA
072177          D2100+157/ F2167;0             % 2167    COSMOS SPOOLING   , I/O SEMA
072201  "
072201  E2100=D2100+201
072201  E2100/
072221
072221  %==============================================================================
072221  % 42.11.07   D 2 2 0 0
072221
072221  D2200, 100
072222  "8DILG
072222         DFDIL;0               % 2200: DISC-ACCESS-LOG DATAFIELD
072224         SEMDL;0               % 2201: DISC-ACCESS-LOG-BUFFER LOCK
072226  "8SCS1
072226  D2200+5/SCSI1;0              % 2202: SCSI HOST INTERFACE 1
072230  "8SCS2
072230  D2200+7/SCSI2;0              % 2203: SCSI HOST INTERFACE 2
072232  "8SCS3
072232  D2200+11/SCSI3;0             % 2204: SCSI HOST INTERFACE 3
072234  "7S1U0
072234  D2200+15/SCST1;0             % 2206: SCSI STREAMER-1
072240  "7S2U0
072240  D2200+17/SCST2;0             % 2207: SCSI STREAMER-2
072242  "7D1U0+7D1U1+7D1U2+7D1U3
072242  D2200+21/SCDI1;0             % 2210: DISK-SCSI-1
072244  "7D2U0+7D2U1+7D2U2+7D2U3
072244  D2200+23/SCDI2;0             % 2211: DISK-SCSI-2
072246  "7D3U0+7D3U1+7D3U2+7D3U3
072246  D2200+25/SCDI3;0             % 2212: DISK-SCSI-3
072250  "7D4U0+7D4U1+7D4U2+7D4U3
072250  D2200+27/SCDI4;0             % 2213: DISK-SCSI-4
072252  "7D5U0+7D5U1+7D5U2+7D5U3
072252  D2200+31/SCDI5;0             % 2214: DISK-SCSI-5
072254  "7D6U0+7D6U1+7D6U2+7D6U3
072254  D2200+33/SCDI6;0             % 2215: DISK-SCSI-6
072256  "7D7U0+7D7U1+7D7U2+7D7U3
072256  D2200+35/SCDI7;0             % 2216: DISK-SCSI-7
072260  "7D8U0+7D8U1+7D8U2+7D8U3
072260  D2200+37/SCD10;0             % 2217: DISK-SCSI-8
072262  "7S1U0
072262  D2200+55/SS1I0;SS1O0         % 2226: SCSI STREAMER 1 I/O, UNIT 0
072300  "7S2U0
072300  D2200+57/SS2I0;SS2O0         % 2227: SCSI STREAMER 2 I/O, UNIT 0
072302  "7S1U0
072302  D2200+61/DF41;0              % 2230: SCSI STREAMER 1 DF DATAFIELD
072304  "7S2U0
072304  D2200+63/DF42;0              % 2231: SCSI STREAMER 2 DF DATAFIELD
072306  "7O1U0+7O1U1+7O1U2+7O1U3
072306  D2200+65/SCOD1;0             % 2232: OPTICAL DISK 1
072310  "7O2U0+7O2U1+7O2U2+7O2U3
072310  D2200+67/SCOD2;0             % 2233: OPTICAL DISK 2
072312  "
072312  %=====================================================
072312  %% DEVICE NUMBERS 2240-2250 ARE RESERVED FOR ETHERNET.
072312  %=====================================================
072312  "8ETR1;D2200+101/ETRN1;ETRN1           % 2240 ETHERNET # 1
072324  "8ETR2;D2200+103/ETRN2;ETRN2           % 2241 ETHERNET # 2
072326  "8ETR3;D2200+105/ETRN3;ETRN3           % 2242 ETHERNET # 3
072330  "
072330  "8BDIO
072330  %=================================================================
072330  %  DEVICE NUMBERS 2257-2277 ARE FOR DOMINO/BDIO
072330  %=================================================================
072330  D2200+137/ ADOML;0                 % 2257 DOMINO ALLOCATION LOCK
072362  D2200+141/ DOM01;0                 % 2260 BDIO POOL 1
072364  D2200+143/ DOM02;0                 % 2261 BDIO POOL 2
072366  D2200+145/ DOM03;0                 % 2262 BDIO POOL 3
072370  D2200+147/ DOM04;0                 % 2263 BDIO POOL 4
072372  D2200+151/ DOM05;0                 % 2264 BDIO POOL 5
072374  D2200+153/ DOM06;0                 % 2265 BDIO POOL 6
072376  D2200+155/ DOM07;0                 % 2266 BDIO POOL 7
072400  D2200+157/ DOM10;0                 % 2267 BDIO POOL 8
072402  D2200+161/ DOM11;0                 % 2270 BDIO POOL 9
072404  D2200+163/ DOM12;0                 % 2271 BDIO POOL 10
072406  D2200+165/ DOM13;0                 % 2272 BDIO POOL 11
072410  D2200+167/ DOM14;0                 % 2273 BDIO POOL 12
072412  D2200+171/ DOM15;0                 % 2274 BDIO POOL 13
072414  D2200+173/ DOM16;0                 % 2275 BDIO POOL 14
072416  D2200+175/ DOM17;0                 % 2276 BDIO POOL 15
072420  D2200+177/ DOM20;0                 % 2277 BDIO POOL 16
072422  "
072422  E2200=D2200+201
072422  E2200/
072422
072422  %==============================================================================
072422  % 42.11.08   D 2 3 0 0
072422
072422  D2300, 100
072423
072423  *+NULDN+NULDN/           %  USER  LOGICAL DEVICE NUMBERS
072443
072443  E2300=D2300+201
072443  E2300/
072623
072623  %==============================================================================
072623  % 42.11.09   D 2 4 0 0
072623
072623  D2400, 100
072624
072624  E2400=D2400+201
072624  E2400/
073024
073024
073024  D2500,  100
073025
073025  "8VSX0
073025  % THESE LOGICAL DEVICE NUMBERS ARE USED FOR DIRECTORY LOCKS
073025  % AND BITFILE-BUFFER LOCKS IN THE "SINTRAN STANDARD CONFIGURATIONS"
073025  % THERE ARE 2 LOCKS FOR EACH DIRECTORY AND THE DIRECTORY INDEX
073025  % IS USED TO COMPUTE THE LOCK NUMBERS, I.E. DIRECTORY INDEX #0
073025  % USES LOCKS F2500 AND F2501, DIRECTORY INDEX #1 USES LOCKS
073025  % F2502 AND F2503 ETC.
073025
073025          F2500;0
073027          F2501;0
073031          F2502;0
073033          F2503;0
073035          F2504;0
073037          F2505;0
073041          F2506;0
073043          F2507;0
073045          F2510;0
073047          F2511;0
073051          F2512;0
073053          F2513;0
073055          F2514;0
073057          F2515;0
073061          F2516;0
073063          F2517;0
073065          F2520;0
073067          F2521;0
073071          F2522;0
073073          F2523;0
073075          F2524;0
073077          F2525;0
073101          F2526;0
073103          F2527;0
073105          F2530;0
073107          F2531;0
073111          F2532;0
073113          F2533;0
073115          F2534;0
073117          F2535;0
073121          F2536;0
073123          F2537;0
073125          F2540;0
073127          F2541;0
073131          F2542;0
073133          F2543;0
073135          F2544;0
073137          F2545;0
073141          F2546;0
073143          F2547;0
073145          F2550;0
073147          F2551;0
073151          F2552;0
073153          F2553;0
073155          F2554;0
073157          F2555;0
073161          F2556;0
073163          F2557;0
073165          F2560;0
073167          F2561;0
073171          F2562;0
073173          F2563;0
073175          F2564;0
073177          F2565;0
073201          F2566;0
073203          F2567;0
073205          F2570;0
073207          F2571;0
073211          F2572;0
073213          F2573;0
073215          F2574;0
073217          F2575;0
073221          F2576;0
073223          F2577;0
073225  "
073225  E2500=D2500+201
073225  E2500/
073225
073225  D2600,  100
073226  "8VSX0
073226          F2600;0
073230          F2601;0
073232          F2602;0
073234          F2603;0
073236          F2604;0
073240          F2605;0
073242          F2606;0
073244          F2607;0
073246          F2610;0
073250          F2611;0
073252          F2612;0
073254          F2613;0
073256          F2614;0
073260          F2615;0
073262          F2616;0
073264          F2617;0
073266          F2620;0
073270          F2621;0
073272          F2622;0
073274          F2623;0
073276          F2624;0
073300          F2625;0
073302          F2626;0
073304          F2627;0
073306          F2630;0
073310          F2631;0
073312          F2632;0
073314          F2633;0
073316          F2634;0
073320          F2635;0
073322          F2636;0
073324          F2637;0
073326  "
073326  E2600=D2600+201
073326  E2600/
073426
073426  %============================================================================
073426  %                D 2 7 0 0
073426  D2700,  100
073427  "9TR29;  D2700+  1/T129R;T129W         % TERMINAL #129
073431  "9TR30;  D2700+  3/T130R;T130W         % TERMINAL #130
073433  "9TR31;  D2700+  5/T131R;T131W         % TERMINAL #131
073435  "9TR32;  D2700+  7/T132R;T132W         % TERMINAL #132
073437  "9TR33;  D2700+ 11/T133R;T133W         % TERMINAL #133
073441  "9TR34;  D2700+ 13/T134R;T134W         % TERMINAL #134
073443  "9TR35;  D2700+ 15/T135R;T135W         % TERMINAL #135
073445  "9TR36;  D2700+ 17/T136R;T136W         % TERMINAL #136
073447  "9TR37;  D2700+ 21/T137R;T137W         % TERMINAL #137
073451  "9TR38;  D2700+ 23/T138R;T138W         % TERMINAL #138
073453  "9TR39;  D2700+ 25/T139R;T139W         % TERMINAL #139
073455  "9TR40;  D2700+ 27/T140R;T140W         % TERMINAL #140
073457  "
073457  E2700=D2700+201
073457  E2700/
073627
073627  %===========================================================
073627  %           D 3 0 0 0
073627  D3000,  100
073630
073630  E3000=D3000+201
073630  E3000/
074030
074030  %=========================================================================
074030  %       D 3 1 0 0
074030  D3100, 100
074031
074031  %  BATCH DEVICES.
074031  %
074031
074031  E3100=D3100+201
074031  E3100/
074231
074231  %=========================================================================
074231  %       D 3 2 0 0
074231  % THE LOGICAL DEVICE NUMBERS 3200-3277 IS USED FOR REMOTE OPEN FILES.
074231  %
074231
074231  %=========================================================================
074231  %       D 3 3 0 0
074231  D3300, 100
074232
074232  % EXTRA BATCH QUE DEVICE    LOG DEV 3300 - 3333
074232  "8ABAT 8BCH1; D3300+001/BQ01I; BQ01O  %  3300
074234  "8ABAT 8BCH2; D3300+003/BQ02I; BQ02O  %  3301
074236  "8ABAT 8BCH3; D3300+005/BQ03I; BQ03O  %  3302
074240  "8ABAT 8BCH4; D3300+007/BQ04I; BQ04O  %  3303
074242  "8ABAT 8BCH5; D3300+011/BQ05I; BQ05O  %  3304
074244  "8ABAT 8BCH6; D3300+013/BQ06I; BQ06O  %  3305
074246  "8ABAT 8BCH7; D3300+015/BQ07I; BQ07O  %  3306
074250  "8ABAT 8BCH8; D3300+017/BQ08I; BQ08O  %  3307
074252  "8ABAT 8BCH9; D3300+021/BQ09I; BQ09O  %  3310
074254  "8ABAT 8BC10; D3300+023/BQ10I; BQ10O  %  3311
074256  "
074256  E3300=D3300+201
074256  E3300/
074432                            %
074432  D3400, 0
074433  D3500, 0
074434  D3600, 0
074435  D3700, 0
074436  EN999=*          % END OF LOGICAL DEVICE NUMBER TABLES.
074436  )LINE

074436  "8BDIS+8BDIM+8ZBDI
074436

074436
074436  %==============================================================================
074436  % 43.5       B D I S K                 VERSION A      26/11-81    CORR. BY TP
074436  %                                      VERSION B      30/12-81    CORR. BY TP
074436  %                                      VERSION C.6    16/ 4-82    CORR. BY TP
074436  %                                      VERSION D       6/10-82    CORR. BY TP
074436  %                                      VERSION E      10/11-82    CORR. BY TP
074436  %                                      VERSION E.1    29/ 3-83    CORR. BY TP
074436  %                                      VERSION E.2    31/ 8-83    CORR. BY TP
074436  %                                      VERSION E.3    26/ 9-83    CORR. BY TP
074436  %                                      VERSION E.4    19/ 3-84    CORR. BY TP
074436  %                                      VERSION F.0     2/ 4-84    CORR. BY TP
074436  %                                      VERSION F.1     3/ 5-84    CORR. BY TP
074436  %                                      VERSION F.2    26/ 6-84    CORR. BY TP
074436  %                                      VERSION F.3     7/ 8-84    CORR. BY TP
074436  %                                      VERSION F.4     3/ 9-84    CORR. BY TP
074436  %                                      VERSION F.5    19/ 9-84    CORR. BY TP
074436  %                                      VERSION F.6     6/11-84    CORR. BY TP
074436  %                                      VERSION F.7    15/11-84    CORR. BY TP
074436  %                                      VERSION G.0    20/ 3-85    CORR. BY TP
074436  %                                      VERSION G.1     8/ 5-85    CORR. BY TP
074436  %                                      VERSION G.2    21/ 5-85    CORR. BY TP
074436  %                                      VERSION G.3    17/ 6-85    CORR. BY TP
074436  %                                      VERSION G.4    16/ 9-85    CORR. BY TP
074436  %                                      VERSION G.5    12/12-85    CORR. BY TP
074436  %                                      VERSION G.6    28/ 4-86    CORR. BY TP
074436  %                                      VERSION G.7    23/ 6-86    CORR. BY TP
074436  %                                      VERSION G.8    19/ 8-86    CORR. BY TP
074436  %                                      VERSION G.9     4/11-86    CORR. BY TP
074436  %                                      VERSION G.A    20/ 5-87    CORR. BY TP
074436  %
074436  %   SUPER DISK (AND ECC CARTRIDGE DISKS) TRANSFER ROUTINE
074436  %
074436  %            THERE ARE 3 VERSIONS OF THE DRIVER, ACCORDING TO LIBRARY MARKS:
074436  %
074436  %                            8BDIS = NORMAL SINTRAN DRIVER
074436  %                            8BDIM = TEST PROGRAM DRIVER
074436  %                            8ZBDI = SWAP DRIVER (READ ONLY)
074436  %
074436  %      8BDIS AND 8BDIM
074436  %
074436  %            THE ARRAY ',B HTABL' MUST BE CORRECT (SEE BELOW).
074436  %
074436  %      8BDIS
074436  %
074436  %            THE DISC-DESCRIBING TABLES ARE EXTERNAL (SEE BELOW).
074436  %
074436  %      8ZBDI
074436  %
074436  %            THE CORRECT DEVICE DESCRIPTOR IS GENERATED AT ASSEMBLY TIME!!!
074436  %            PLDWO AND PSTWO WILL NOT WORK FOR N10.
074436  %
074436  %      FOR ALL:
074436  %
074436  %            IF THE ROUTINES 'PLDWO' AND 'PSTWO' ARE UNDEFINED, THEY WILL
074436  %            BE INCLUDED AFTER THE DRIVER!!!
074436  %            FOR N10, PAGING MUST BE OFF WHEN PLDWO AND PSTWO ARE ENTERED
074436  %            (USED BY ERROR CORRECTION). NOT FOR 8ZBDI. SEE 8ZBDI ABOVE.
074436  %            ERROR CORRECTION ASSUMES THAT THE CPU CAN REACH ALL THE MEMORY
074436  %            ACCESSIBLE TO THE DISK.
074436  %
074436  %
074436  "8BDIS+8BDIM
074436  %
074436  %     CALL:
074436  %     JPL I (BDISK
074436  %     JMP   ERROR           %ERROR EXIT
074436  %     JMP   BUSY            % BUSY EXIT
074436  %     JMP   FINIS           %FINISHED EXIT
074436  %
074436  "8ZBDI+8BDIS+8BDIM
074436  %
074436  %     REGISTER CONTENTS WHEN ROUTINE IS CALLED
074436  %
074436  %     T-  BIT 0-5:  DEVICE OPERATION  (FOR 8ZBDI, READ ONLY)
074436  %                    0 READ TRANSFER
074436  %                    1 WRITE TRANSFER
074436  %                    2 READ PARITY TRANSFER
074436  %                    3 COMPARE TRANSFER
074436  %                   20 READ LAST STATUS
074436  %                   35 RELEASE              (NOT FOR THE SWAP DRIVER)
074436  %                    6 PRIORITY-SELECT      (NOT FOR THE SWAP DRIVER)
074436  %                   37 THIS FUNCTION BELONGS TO FUNCTION 42 AND IS STARTED
074436  %                      BY THE DRIVER. IT SHOULD NOT BE USED IN A CALL.
074436  %                   42 TEST IF SPARE TRACKS AND IF SPARE SECTOR FORMAT.
074436  %                      (NOT FOR THE SWAP DRIVER).
074436  %                      IT IS ASSUMED THAT NO OF SECTORS IN X IS 1 AND THAT
074436  %                      SECTOR NUMBER (LOGICAL DISK ADDR) IN AD IS 0 (EXCEPT
074436  %                      THE FIXED BIT IN D 017) WHEN THIS FUNCTION CALLS THE
074436  %                      DRIVER THE FIRST TIME.
074436  %                   43 READ  FORMAT TABLE (NOT FOR THE SWAP DRIVER)
074436  %                   44 WRITE FORMAT TABLE (NOT FOR THE SWAP DRIVER)
074436  %        BIT 6-8:   UNIT SELECT
074436  %        BIT 9-11:          SURFACE NUMBER FOR PHOENIX DISK
074436  %        BIT 12-13: CORE ADDRESS BITS 16-17 (N10)
074436  %        BIT 14:    DEVICE TYPE
074436  %                           1= 30/60/90 MBYTE
074436  %                           0= ANY OTHER TYPE
074436  %
074436  %        BIT 15:    0: NORMAL TRANSFER
074436  %                   1: BIT 6 IS ADDED TO THE SECTOR NUMBER
074436  %                      (USED TO READ SPARE TRACKS. ONLY POSSIBLE FOR
074436  %                      THE LIBRARY MARK 8BDIM).
074436  %
074436  %     A- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 16-31
074436  %
074436  %     D- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 0-15
074436  %                           LOGICAL ADDRESS BIT 15 MEANS ANY FIXED
074436  %                           SURFACE FOR CARTRIDGE DISK
074436  %
074436  %     X- NUMBER OF SECTORS TO BE TRANSFERED
074436  %
074436  %       ****  ,B MEMAD CONTAINS THE 24-BIT MEMORY ADRESS
074436  %                      IN A DOUBLE WORD.
074436  %       ****  ,B HDEV  CONTAINS HARDWARE DEVICE NUMBER
074436  %
074436  "8BDIS+8BDIM
074436  %
074436  %       ****  ,B HTABL IS A 4 ENTRY INTEGER ARRAY OF POINTERS TO
074436  %                      DISC ADRESS LAYOUT FOR UNITS 0,1,2 AND 3.
074436  %
074436  "8ZBDI+8BDIS+8BDIM
074436  %
074436  %      DISC LAYOUT DEFINITION:
074436  %
074436  %                             WORD 0 (BSECW) = WORDS/SECTOR
074436  %                                  1 (BSECT) = SECTORS/TRACK
074436  %                                  2 (BSECY) = SECTORS/CYLINDER
074436  %                                  3 (BMXCY) = MAXIMUM VALUE OF CYLINDER
074436  %                                  4           FIRST CYL OF SPARE TRACK AREA
074436  %                                  5           FORMAT IN ECC CONTROL WORD
074436  %                                  6           FIRST CYL OF EXTRA AREA
074436  %                                  7           POINTER TO RELATED LAYOUT
074436  %
074436  %     EXIT INFORMATION:
074436  %
074436  %     ERROR EXIT: X- HARDWARE STATUS REG.
074436  %                 T- BIT  9: SEEK ERROR. RETURN TO ZERO SEEK HAS BEEN DONE.
074436  %                    BIT 10: CORE ADDR. REG NOT AS EXPECTED
074436  %                    BIT 11: LOG. BLOCK ADDR. OUT OF RANGE, OR
074436  %                            TRANSFER BIGGER THAN 63.5K
074436  %                    BIT 12: DATA CORRECTION INFORMATION ERROR
074436  %                    BIT 13: DRIVE TYPE DEFINITION ERROR
074436  %                    BIT 14: ILL. DEVICE OP. CODE
074436  %                    BIT 15: CONTROLLER NOT ACTIVE AFTER ACTIVATE
074436  %     EVERY TIME THE DRIVER ERROR EXITS, IT STORES 11 WORDS AT THE END OF
074436  %     THE CODE. THESE WORDS, THEREFORE, WILL CONTAIN SIGNIFICANT INFORMATION
074436  %     ABOUT THE LAST ERROR THAT OCCURED. THE ADDRESS OF THIS FIELD CAN BE
074436  %     FOUND IN BDISK+2.
074436  %
074436  %     BUSY EXIT:     THE ROUTINE MUST BE CALLED AGAIN AT ONCE, OR
074436  %                    AFTER INTERRUPT. THE NEW CALL IS DONE WITH T,A,D AND
074436  %                    X-REG. UNCHANGED.
074436  %
074436  %     FINISHED EXIT: X-HARDWARE STATUS REG.
074436  %                    WITH FUNCTION 042, X WILL BE:
074436  %                    0: NOT SPARE TRACKS, NOT SPARE SECTOR FORMAT
074436  %                    1:     SPARE TRACKS, NOT SPARE SECTOR FORMAT
074436  %                    2: NOT SPARE TRACKS,     SPARE SECTOR FORMAT
074436  %                    3:     SPARE TRACKS,     SPARE SECTOR FORMAT
074436  %
074436  %     B-REG. IS NOT CHANGED BY THE ROUTINE
074436  %
074436  %       THE ROUTINE CONVERTS LOGICAL (SECTOR NUMBER) ADDR. (LA)
074436  %       TO HARDWARE (CYLINDER/HEAD/SECTOR) ADDR. (HA)
074436  %       ACCORDING TO TABLE HTABL FOR THE CORRESPONDING UNIT.
074436  %
074436  %     **** THE NUMBER OF SECTORS FOR THE VARIOUS DISK PACKS, AND THE ACTUAL TABLE NAMES:
074436  %
074436  %          37 MB =  110176                    : DT037
074436  %          70 MB =  220526                    : DT070
074436  %          75 MB =  220526                    : DT075
074436  %         135 MB =  421206                    : DT135   SPARE SECTOR FORMAT
074436  %         140 MB =  441254                    : DT140
074436  %         160 MB =  441254                    : DT160
074436  %         288 MB = 1045572                    : DT288
074436  %         285 MB = 1066450                    : DT285   SPARE SECTOR FORMAT
074436  %         300 MB = 1127720                    : DT300
074436  %         450 MB = 1542420                    : DT450   SPARE SECTOR FORMAT
074436  %         460 MB = 1603760                    : DT460
074436  %
074436  %          30 MB = 0034736 FOR EACH SURFACE   : DT030
074436  %          60 MB = 0034736 FOR EACH SURFACE   : DT030
074436  %          90 MB = 0034736 FOR EACH SURFACE   : DT030
074436  %
074436  %
074436  %        WHEN CALLING, THE LOGICAL ADDR. IN AD MUST
074436  %        BE REPRESENTED AS AN UNSIGNED MAGNITUDE NUMBER.
074436  %
074436  %
074436  %        THE SECTORS WITHIN THE LAST CYLINDER ARE TRANSFERED
074436  %        FIRST, THEN THE SECTORS WITHIN THE PREVIOUS CYLINDER ETC....
074436  %        FOR THE OLD INTERFACE (10 KHZ), WITHIN ONE CYLINDER,
074436  %        THE GREATEST SINGLE TRANSFER IS  64K-BSECW, WHERE BSECW IS NUMBER
074436  %        OF WORDS PER SECTOR (THE WORD COUNT REGISTER HAS ONLY 16 BITS).
074436  %        FOR THE NEW INTERFACE (15KHZ), STILL WITHIN ONE CYLINDER,
074436  %        THE GREATEST SINGLE TRANSFER CAN BE A WHOLE CYLINDER, SINCE
074436  %        THE WORD COUNT REGISTER HAS 24 BITS.
074436  %
074436  %     DISPLACEMENTS FOR IOX INSTRUCTIONS:
074436  %
074436         RCA=0                 % READ CORE ADDRESS
074436         LCA=1                 % LOAD CORE ADDRESS
074436         RSC=2                 % READ SEEK CONDITION / ECC COUNT
074436         LBA=3                 % LOAD BLOCK ADDRESS  I/II
074436         RSR=4                 % READ STATUS REG / ECC PATTERN
074436         LCO=5                 % LOAD CONTROL WORD
074436         LWC=7                 % LOAD WORD COUNT / ECC CONTROL
074436       INIOX=165540            % INITIAL IOX INSTRUCTION
074436
074436  % THE DISK DRIVER MAY BE CALLED WITH 11 DIFFERENT DEVICE OPERATIONS.
074436  % IN THE FOLLOWING, READ, READ PARITY, AND COMPARE, ARE CALLED NON-WRITE.
074436  % THE WRITE OPERATION IS CALLED WRITE. THE READ-STATUS OPERATION IS QUITE
074436  % SPECIAL. IT IS REALLY A READ-LAST-STATUS OPERATION, AS IT WILL READ
074436  % LAST STATUS FROM THE VARIABLE SSTAT. IT WILL ALSO INITIATE THE DISK DATA
074436  % FIELD VARIABLES BUSFL, ECCFL, MARGC, AND SMARG BY STORING ZERO INTO THEM,
074436  % AND BY SETTING ERRC1 TO -4 AND ERRC2 TO -28.
074436  % THE TEST-IF-SPARE-TRACK OPERATION WILL BE EXECUTED FIRST AS A PARITY READ
074436  % FROM THE LAST POSSIBLE SECTOR ON THE FIRST TRACK, AND THEN AS A PARITY READ
074436  % FROM THE FIRST SECTOR IN THE SPARE TRACK AREA. IT IS NOT FOR THE SWAP DRIVER.
074436  % RELEASE AND PRIORITY-SELECT ARE NOT FOR THE SWAP DRIVER EITHER. THEY ARE
074436  % USED WHEN MORE THAN ONE CPU USE THE DISK.
074436  %
074436  % ***** THE READ-STATUS OPERATION SHOULD NOT BE USED WHEN BUSFL IS NONZERO.****
074436  %
074436  % IF THE DISK DRIVER IS CALLED WITH READ-ZERO-SECTORS, THE STATUS REGISTER
074436  % WILL BE READ AND PUT IN THE X REGISTER, AND THE DISK DRIVER WILL EXIT
074436  % AT THE FINISHED EXIT. IF NOT-ON-CYLINDER (STATUS BIT 14),
074436  % THE DISK DRIVER WILL EXIT AT THE ERROR EXIT.
074436  %
074436  %
074436  % THE VARIABLES IN THE DISK DATA FIELD USED BY THE DISK DRIVER:
074436  %
074436  % ARG
074436  %
074436  % USED TO SAVE THE VALUE OF THE A-REGISTER AT ENTRY.
074436  %
074436  % BMXCY
074436  %
074436  % (BMXCY=BSECW+3)
074436  % MAX CYLINDER NUMBER. THIS IS THE LAST (PHYSICAL) CYLINDER NUMBER ON THE DISK.
074436  %
074436  % BSECT
074436  %
074436  % (BSECT=BSECW+1)
074436  % NUMBER OF SECTORS PER TRACK.
074436  %
074436  % BSECW
074436  %
074436  % NUMBER OF WORDS PER SECTOR.
074436  %
074436  % BSECY
074436  %
074436  % (BSECY=BSECW+2)
074436  % NUMBER OF SECTORS PER CYLINDER.
074436  %
074436  % BTSTA
074436  %
074436  % THE MAIN PART OF THE DISK CONTROL WORD.
074436  %
074436  % BUSFL
074436  %
074436  % BUSY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
074436  % MUST BE ZERO THE FIRST TIME THE DISK DRIVER IS CALLED. THE DISK DRIVER
074436  % WILL SET BUSFL TO NONZERO WHEN A TRANSFER IS STARTED, AND WILL SET IT BACK
074436  % TO ZERO WHEN A TRANSFER IS FINISHED, OR WHEN IT ERROR EXITS.
074436  % NEW (15/11-84, VERSION F.7):
074436  % WHEN THE DISK DRIVER WANTS TO ERROR EXIT UNDER SINTRAN, IT FIRST DOES A BUSY
074436  % EXIT AFTER THE RETURN-TO-ZERO SEEK HAS BEEN STARTED, WITH BUSFL:=STATUS.
074436  % WHEN THE INTERRUPT OCCURS, STATUS IS RESET (STATUS:=BUSFL), AND ERROR EXIT.
074436  %
074436  % CDISP
074436  %
074436  % USED FOR ECC COUNT AND SECTOR WORD NUMBER.
074436  % WHEN THE DISK DRIVER TRIES TO DO ERROR CORRECTION ON A SECTOR, IT READS
074436  % THE ECC COUNT AND STORES IT IN CDISP. IF 1 < CDISP < 8204, IT IS CHANGED
074436  % INTO A SECTOR WORD NUMBER IN THE RANGE 0-0777, POINTING TO A DOUBLE WORD
074436  % IN THE SECTOR THAT MAY BE CHANGED, DEPENDING ON THE ECC PATTERN (SEE
074436  % CPAT1 AND CPAT2). IF ERROR CORRECTION HAS TAKEN PLACE (SEE CORCU), THEN
074436  % IT IS POSSIBLE FOR THE CALLING PROGRAM TO KNOW WHERE THE CORRECTION TOOK
074436  % PLACE, BY INSPECTING CDISP.
074436  %
074436  % CMAD1
074436  %
074436  % POINTS TO THE FIRST WORD OF A DOUBLE WORD CONTAINING CURRENT MEMORY ADDRESS.
074436  % THE CURRENT MEMORY ADDRESS IS THE MEMORY ADDRESS USED BY THE DRIVER
074436  % WHEN IT STARTS A TRANSFER. IT IS NOT NECESSARILY EQUAL TO THE MEMORY
074436  % ADDRESS SUPPLIED IN THE CALL (SEE MEMA1, MEMA2).
074436  % IF THE DISK DRIVER BREAKS A TRANSFER INTO SMALLER TRANSFERS, FOR INSTANCE,
074436  % IT HAS TO CALCULATE A NEW MEMORY ADDRESS AND STORE IT IN CMAD1 AND CMAD2.
074436  %
074436  % CMAD2
074436  %
074436  % POINTS TO THE SECOND WORD OF A DOUBLE MEMORY ADDRESS. SEE CMAD1.
074436  %
074436  % CORCU
074436  %
074436  % CORRECTION COUNTER. EVERY TIME THAT ERROR CORRECTION OCCURS,
074436  % CORCU IS INCREMENTED BY 1. ERROR CORRECTION IS ALWAYS DONE ON SINGLE SECTORS.
074436  % THE NOT-WRITE RETRY COUNTER (SEE SRTRY) IS USUALLY ALSO INCREMENTED (ONCE
074436  % FOR EACH SECTOR IN THE TRANSFER) WHEN CORCU IS INCREMENTED.
074436  % CORCU IS INCREMENTED ON READ AND PARITY-CHECK OPERATIONS.
074436  % THE FAILING BITS CAN BE IN THE DATA PART AND/OR IN THE ECC POLYNOMIAL.
074436  %
074436  % CPAT1
074436  %
074436  % WHEN THE DISK DRIVER WANTS TO DO ERROR CORRECTION, IT READS THE ELEVEN BITS
074436  % OF THE ECC PATTERN, INVERTS THE BIT ORDER (SWAPS BIT 0 AND 10, BIT 1 AND 9,
074436  % ETC.), AND STORES IT TEMPORARILY IN CPAT1. CPAT1 SHOULD NOT BE ZERO.
074436  % THEN CPAT1 IS SHIFTED ACCORDING TO THE LEAST SIGNIFICANT BITS OF THE ECC
074436  % COUNT IN CDISP. THE RESULT IS STORED IN CPAT1 AND CPAT2, READY TO BE
074436  % EXCLUSIVE OR'ED INTO THE SECTOR JUST READ.
074436  %
074436  % CPAT2
074436  %
074436  % SEE CPAT1.
074436  % ALSO USED TO SAVE TRG WHILE WAITING FOR ON-CYL AFTER RETURN-TO-ZERO SEEK.
074436  %
074436  %
074436  % DED01 ==> DED13
074436  % IS USED
074436  % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
074436  % DED01  THE 11-WORD FIELD GOES FROM DED01 TO DED13.
074436  %
074436  % DRG
074436  %
074436  % USED TO SAVE THE VALUE OF THE D-REGISTER AT ENTRY.
074436  %
074436  % ECCFL
074436  %
074436  % RUN-ECC OPERATION FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
074436  % THIS FLAG IS USUALLY ZERO, BUT WHEN THE DISK DRIVER WANTS TO DO ERROR
074436  % CORRECTION, IT SETS ECCFL TO NONZERO AND STARTS THE RUN-ECC OPERATION.
074436  % WHEN RUN-ECC IS FINISHED, ECCFL IS SET BACK TO ZERO.
074436  % ECCFL IS SET TO ZERO AT THE ERROR EXIT AND THE FINISHED EXIT.
074436  %
074436  % ERRC1
074436  %
074436  % ERROR COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK DRIVER IS CALLED
074436  % THE FIRST TIME, ERRC1 USUALLY SHOULD HAVE THE VALUE -4. A FAILING WRITE
074436  % TRANSFER WILL THEN BE RETRIED THREE TIMES. IF THE CALLING PROGRAM WANTS
074436  % NOT TO HAVE WRITE RETRIES, IT SHOULD STORE -1 IN ERRC1 BEFORE CALLING
074436  % THE DISK DRIVER. FOR FAILING NOT-WRITE TRANSFERS, ERRC1 SHOULD BE HANDLED
074436  % IN THE SAME WAY, BUT THEN ERRC2 MUST ALSO BE TAKEN INTO ACCOUNT.
074436  % ERRC1 IS SET TO -4 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS
074436  % IN ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
074436  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
074436  %
074436  % ERRC2
074436  %
074436  % MARGINAL RECOVERY COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK
074436  % DRIVER IS CALLED THE FIRST TIME, ERRC2 USUALLY SHOULD HAVE THE VALUE -28.
074436  % A FAILING NOT-WRITE TRANSFER WILL FIRST DO SOME RETRIES ACCORDING TO THE
074436  % VALUE OF ERRC1. WHEN ERRC1 HAS BEEN COUNTED UP TO ZERO, THERE WILL BE NO
074436  % MORE ORDINARY RETRIES. INSTEAD, THE DISK DRIVER WILL TRY TO DO MARGINAL
074436  % RECOVERY CYCLES, ACCORDING TO THE VALUE OF ERRC2. IT WILL FIRST SET MARGC
074436  % NONZERO. USUALLY, THE DISK DRIVER WILL DO 27 MARGINAL RECOVERIES (THREE
074436  % FULL CYCLES). BUT IF THE CALLING PROGRAM SETS BOTH ERRC1 AND ERRC2 TO -1,
074436  % THE DISK DRIVER WILL DO NO ORDINARY RETRIES AND NO MARGINAL RECOVERY CYCLES.
074436  % ERRC2 IS SET TO -28 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS IN
074436  % ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
074436  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
074436  %
074436  % HDEV
074436  %
074436  % CONTAINS HARDWARE DEVICE NUMBER (01540 OR 01550).
074436  %
074436  % HTABL
074436  %
074436  % THERE ARE FOUR WORDS IN THE DATAFIELD (ONE FOR EACH UNIT), EACH POINTING TO
074436  % AN EIGHT-WORD DISK LAYOUT VECTOR. HTABL POINTS TO THE FIRST OF THE FOUR DATA
074436  % FIELD WORDS.
074436  %
074436  % MARGC
074436  %
074436  % MARGINAL RECOVERY FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
074436  % WHEN ALL THE ORDINARY NOT-WRITE RETRIES HAVE BEEN DONE (IF A TRANSFER FAILS),
074436  % THE MARGINAL RECOVERY BIT IN THE CONTROL WORD IS TURNED ON, MARGC IS SET
074436  % TO NONZERO, AND TYPEC IS INCREMENTED IN BIT 9.
074436  % MARGC IS SET TO ZERO WHEN THE DISK DRIVER IS IN ERROR RECOVERY
074436  % MODE (SEE SMARG), AND WHEN A TRANSFER IS FINISHED (BOTH OK EXIT AND ERROR
074436  % EXIT).
074436  %
074436  % MEMA1
074436  %
074436  % THE MOST SIGNIFICANT PART OF A DOUBLE WORD CONTAINING MEMORY ADDRESS.
074436  %
074436  % MEMA2
074436  %
074436  % THE LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS (SEE MEMA1).
074436  %
074436  % NWLBA
074436  %
074436  % LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS OF NEW CYLINDER NUMBER, AND
074436  % NEW SURFACE AND SECTOR. USED WHEN SPARE TRACK ALLOCATION IS ACTIVE.
074436  % A TRACK THAT IS FLAGGED AS A BAD TRACK, CONTAINS THE ADDRESS OF THE
074436  % RESERVE TRACK IN EVERY DOUBLE WORD. THE FIRST PART OF THE DOUBLE WORD
074436  % CONTAINS THE NEW CYLINDER NUMBER, AND THE SECOND PART CONTAINS THE NEW
074436  % SURFACE NUMBER IN THE LEFTMOST 8 BITS, AND THE SECTOR NUMBER IN THE
074436  % RIGHTMOST 8 BITS. THIS SECTOR NUMBER IS IRRELEVANT, AS THE OLD SECTOR
074436  % NUMBER (THE SECTOR NUMBER IN THE ORIGINAL DISK TRANSFER) IS USED INSTEAD.
074436  % NWLBA MUST BE NWLBB+1. (*****)
074436  %
074436  % NWLBB
074436  %
074436  % MOST SIGNIFICANT PART OF THE MEMORY ADDRESS OF
074436  % NEW CYLINDER NUMBER. SEE NWLBA. MUST BE NWLBA-1 !!
074436  %
074436  % OCMD1
074436  %
074436  % OLD COMPUTED MEMORY ADDRESS, BITS 23-16. USED TO SAVE THE MEMORY ADDRESS
074436  % OF A DISK TRANSFER DURING SPARE TRACK ALLOCATION.
074436  %
074436  % OCMD2
074436  %
074436  % OLD COMPUTED MEMORY ADDRESS, BITS 15-0. SEE OCMD1.
074436  %
074436  % OSVBA
074436  %
074436  % OLD SURFACE AND SECTOR. USED TO SAVE THE OLD VALUES OF THE DISK ADDRESS
074436  % DURING SPARE TRACK ALLOCATION.
074436  %
074436  % OSVBB
074436  %
074436  % OLD CYLINDER. SEE OSVBA.
074436  %
074436  % OSVCO
074436  %
074436  % OLD CONTROL WORD. USED TO SAVE THE OLD CONTROL WORD DURING SPARE TRACK
074436  % ALLOCATION.
074436  %
074436  % OSVWC
074436  %
074436  % OLD WORD COUNT, LEAST SIGNIFICANT 16 BITS.
074436  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
074436  %
074436  % OSVWK
074436  %
074436  % OLD WORD COUNT, MOST SIGNIFICANT 8 BITS.
074436  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
074436  %
074436  % SCADR
074436  %
074436  % THE LEAST SIGNIFICANT PART OF THE EXPECTED CORE ADDRESS REGISTER WHEN
074436  % A TRANSFER HAS FINISHED. IT IS COMPUTED BY THE DISK DRIVER (CMAD2+SVLWC).
074436  %
074436  % SLONG
074436  %
074436  % COUNTER FOR ERROR-RECOVERY (SEE SMARG). WHEN THE DISK DRIVER INITIATES
074436  % ERROR-RECOVERY MODE, SLONG IS SET TO 1-N, WHERE N IS THE NUMBER OF SECTORS
074436  % IN THE TRANSFER.
074436  %
074436  % SMARG
074436  %
074436  % ERROR-RECOVERY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
074436  % WHEN A NOT-WRITE TRANSFER FAILS, OR A WRITE GIVES DMA-ERROR,
074436  % THE DISK DRIVER INITIATES ERROR-RECOVERY BY SETTING SMARG TO NONZERO.
074436  % ERROR-RECOVERY MEANS THAT THE TRANSFER IS BROKEN INTO SINGLE-SECTOR TRANSFERS.
074436  % EACH OF THESE TRANSFERS IS THEN DONE AND CHECKED FOR ERRORS.
074436  % IF THE TRANSFER IS READ, AND IT FAILS, ERROR CORRECTION IS TRIED.
074436  % IF THIS FAILS, OR IF THE TRANSFER IS PARITY CHECK OR COMPARE,
074436  % THE USUAL RETRIES AND MARGINAL RECOVERIES ARE DONE.
074436  % SMARG IS SET TO ZERO WHEN A NEW TRANSFER IS STARTED, AND WHEN A TRANSFER
074436  % IS FINISHED (BOTH OK EXIT AND ERROR EXIT).
074436  %
074436  % SPACO
074436  %
074436  % SPARE TRACK ALLOCATION COUNTER. EVERY TIME A DISK TRANSFER HAS SUCCESSFULLY
074436  % USED A RESERVE TRACK, THIS COUNTER IS INCREMENTED BY ONE.
074436  %
074436  % SPAFL
074436  %
074436  % SPARE TRACK ALLOCATION FLAG.
074436  % 0:  NORMAL TRANSFER (NO SPARE TRACKS INVOLVED).
074436  % 1:  ADDRESS MISMATCH HAS OCCURED. SPARE TRACK ADDRESS-READ HAS BEEN STARTED.
074436  % 2:  TRANSFER IN THE SPARE TRACK AREA HAS BEEN STARTED.
074436  %
074436  % SRTRY
074436  %
074436  % NOT-WRITE RETRY COUNTER. IT IS INCREMENTED EVERY TIME AN ORDINARY NOT-WRITE
074436  % RETRY IS STARTED. MARGINAL RECOVERY CYCLE RETRIES ARE COUNTED IN TYPEC,
074436  % BITS 15-9, EVERY TIME MARGC IS SET NONZERO.
074436  %
074436  % SSTAT
074436  %
074436  % CURRENT DISK STATUS.
074436  %
074436  % SVLBA
074436  %
074436  % SAVED DISK ADDRESS (SURFACE AND SECTOR).
074436  %
074436  % SVLBB
074436  %
074436  % SAVED DISK ADDRESS (CYLINDER NUMBER).
074436  %
074436  % SVLCA
074436  %
074436  % SAVED LEAST SIGNIFICANT PART OF THE CURRENT MEMORY ADDRESS (EQUAL TO CMAD2).
074436  %
074436  % SVLCO
074436  %
074436  % SAVED CONTROL WORD, EXCEPT WHEN RUN-ECC OPERATION IS STARTED.
074436  %
074436  % SVLWC
074436  %
074436  % SAVED WORD COUNT, LEAST SIGNIFICANT 16 BITS (NUMBER OF SECTORS * BSECW).
074436  %
074436  % SVLWK
074436  %
074436  % SAVED WORD COUNT, MOST SIGNIFICANT 8 BITS (NUMBER OF SECTORS * BSECW).
074436  %
074436  % SWTRY
074436  %
074436  % WRITE RETRY COUNTER. SWTRY IS INCREMENTED BY ONE EACH TIME A WRITE TRANSFER
074436  % FAILS.
074436  %
074436  % TRG
074436  %
074436  % USED TO SAVE THE VALUE OF THE T-REGISTER AT ENTRY.
074436  %
074436  % TYPEC
074436  %
074436  % BIT   0:   1: ECC INTERFACE                 0: 33/66MB INTERFACE
074436  %       1:   1: HEAD ADVANCE                      0: NOT HEAD ADVANCE
074436  %       2:   1: ERROR CORRECTION NOT ALLOWED      0: ERROR CORRECTION ALLOWED
074436  %       3:   1: MARGINAL RECOVERY NOT ALLOWED     0: MARGINAL RECOVERY ALLOWED
074436  %       4:   1: HEAD ADVANCE NOT ALLOWED, UNIT 0  0: HEAD ADVANCE ALLOWED, UNIT 0
074436  %               (SPARE TRACK ALLOC. ALLOWED)         (NO SPARE TRACK ALLOCATION)
074436  %       5:   1: DITTO FOR UNIT 1                  0: DITTO FOR UNIT 1
074436  %       6:   1: DITTO FOR UNIT 2                  0: DITTO FOR UNIT 2
074436  %       7:   1: DITTO FOR UNIT 3                  0: DITTO FOR UNIT 3
074436  %       8:   1: AUTOMATIC RELEASE NOT ALLOWED     0: ALLOWED
074436  %       9:   1: NEW (15 KHZ) INTERFACE            0: OLD (10 KHZ) INTERFACE
074436  %   15-10:   MARG. REC. COUNTER (INCREMENTED EACH TIME MARGC IS SET NONZERO)
074436  %
074436  %    BITS 0 AND 1 ARE SET INSIDE THE DISK DRIVER.
074436  %    BITS 2, 3, AND 4-7 ARE SET BY THE CALLING PROGRAM.
074436  %           BITS 4-7 CAN ALSO BE SET BY THE FUNCTION TEST-IF-SPARE-TRACK (042)
074436  %    BIT  8 IS SET BY THE FUNCTION PRIORITY-SELECT, AND RESET BY THE FUNCTION
074436  %           RELEASE. IT MAY ALSO BE SET/RESET BY THE CALLING PROGRAM.
074436  %    BIT  9 IS SET INSIDE THE DISK DRIVER.
074436  %
074436  % XRG
074436  %
074436  % USED TO SAVE THE VALUE OF THE X-REGISTER AT ENTRY.
074436  %
074436  % 9LREG
074436  %
074436  % USED TO SAVE THE VALUE OF THE L-REGISTER.
074436  %
074436
074436  "8BDIS+8BDIM
074436
074436  BDISK=*
074436         JMP   MORE9
074437         #GA                   % VERSION LETTER AND NUMBER
074440         DRIAR                 % ADDRESS OF ERROR FIELD
074441
074441  "8BDIM+8BDIS+8ZBDI
074441
074441  % DEFINITION OF EXTENSION TO DISK DATA FIELD
074441
074441  BSECW=DED01                  % WORDS/SECTOR
074441  BSECT=DED02                  % SECTORS/TRACK
074441  BSECY=DED03                  % SECTORS/CYLINDER
074441  BMXCY=DED04                  % MAX CYLINDER VALUE
074441                               % FIRST CYL NO OF THE SPARE TRACK AREA
074441                               % FORMAT (0 OR 020)
074441                               % FIRST CYLINDER OF EXTRA AREA
074441                               % POINTER TO RELATED LAYOUT
074441  9LREG=DED11                  % SAVED L-REG
074441  SSTAT=DED12                  % CURRENT DISK ADDRESS
074441  BTSTA=DED13                  % MAIN PART OF CURRENT DISK CONTROL WORD
074441
074441  "8BDIS+8BDIM
074441
074441  MORE9, STF   TRG ,B
074442         STX   XRG ,B
074443         SHT   SHR 6
074444         SAX   7               % MASK FOR UNIT
074445         RAND  ST DX           % X = UNIT NO.
074446         AAX   HTABL
074447         RADD  SB DX
074450         LDX   ,X              % X => DISC DEFINITION
074451         LDF   ,X 0            % GET DEFINITION
074452         STF   BSECW ,B        % TO CURRENT COPY
074453         LDF   ,X 3
074454         STF   BSECW+3 ,B
074455         LDD   6 ,X
074456         STD   BSECW+6 ,B
074457         LDF   TRG ,B
074460         LDX   XRG ,B
074461         LDA   HDEV,B          % HARDWARE DEVICE NUMBER
074462         ADD   (IOX  LCO       % CONSTRUCT FIRST IOX
074463         BSET                  % NOT APT
074464         SUB I (BLCOG          % TEST FIRST IOX IF INITIALIZED
074465         JAF   NOIOX           % BRANCH IF NOT INITIALIZED
074466         ADD I (BLCOG
074467         SUB I (BLCO4          % TEST LAST IOX
074470         JAF   NOIOX           % NONZERO: NOT INITIALISED
074471         BSET  ONE             % APT
074472         JMP   BRCHK
074473  NOIOX, ADD I (BLCO4          % INITIALIZE ALL IOX
074474         AAA   -5
074475         STA I (BRCA
074476         STA I (BRCA2
074477         AAA   2
074500         STA I (BRSC1
074501         STA I (BRSC2
074502         STA I (BRSC3
074503         STA I (BRSC4
074504         STA I (BRSC5
074505         STA I (BRSC6
074506         STA I (BRSC7
074507         STA I (BRSC8
074510         AAA   2
074511         STA I (BRSR1
074512         STA I (BRSR2
074513         STA I (BRSR3
074514         STA I (BRSR4
074515         STA I (BRSR5
074516         STA I (BRSR6
074517         STA I (BRSR8
074520         AAA   -3
074521         STA I (BLCA1
074522         STA I (BLCA3
074523         AAA   2
074524         STA I (BLBA1
074525         STA I (BLBA3
074526         AAA   2
074527         STA I (BLCO1
074530         STA I (BLCO3
074531         STA I (BLCO4
074532         STA I (BLCO8
074533         STA I (BLCOF
074534         STA I (BLCOG
074535         STA I (BLCOH
074536         AAA   2
074537         STA I (BLWC1
074540         STA I (BLWC2
074541         STA I (BLWC3
074542         BSET  ONE             % APT
074543
074543  "8ZBDI+8BDIS+8BDIM
074543
074543         JMP   BRCHK
074544
074544  )FILL
074604
074604  BRCHK, COPY  SL DA           % SAVE L
074605         STA   9LREG ,B
074606
074606  "8BDIS
074606
074606         LDA   BUSFL ,B
074607         JAZ   L43
074610         AAA   1
074611         JAZ   L43
074612         AAA   -1              % BUSFL CONTAINS STATUS.  LAST OP. WAS RET-TO-ZER
074613         STA   SSTAT ,B        % RESET STATUS
074614         LDT   CPAT2 ,B        % UNSAVE TRG
074615         JMP I (ERREK          % ERROR EXIT
074616  L43=*
074616
074616  "8ZBDI+8BDIS+8BDIM
074616
074616         SAA   77
074617         AND   TRG ,B
074620
074620  "8BDIS+8BDIM
074620
074620         AAA   -042
074621         JAZ   L41             % ZERO: TEST-IF-SPARE-TRACK
074622         AAA   042-043
074623         JAZ   L41             % ZERO: READ-FORMAT-TABLE
074624         AAA   043-044
074625         JAZ   L41             % ZERO: WRITE-FORMAT-TABLE
074626         AAA   044-037
074627         JAZ   L41             % ZERO: PART OF TEST-IF-SPARE-TRACK
074630         AAA   037-035
074631         JAZ   L47             % ZERO: RELEASE
074632         AAA   035-6
074633         JAF   L48
074634         JMP I (L49            % PRIORITY-SELECT
074635  L47,   JMP I (L50
074636  L48,   AAA   6-020
074637         JAF   L25
074640         LDA   BUSFL ,B        % OPERATION IS READ LAST STATUS
074641         JAF   L39             % NONZERO: BUSY. DONT READ LAST STATUS
074642         JMP I (FINEX
074643  L25,   AAA   14
074644         SKP   IF DA LST 0
074645
074645  "8BDIS+8BDIM+8ZBDI
074645
074645         JMP I (ILCOD          % ILL. DEVICE OP. CODE
074646  L41,   LDA   TRG ,B
074647         AND   (0700           % MASK FOR UNIT ADDRESS BITS.
074650         SHA   ZIN  1          % SHIFT TO POSITION FOR CWR.
074651         STA   BTSTA ,B        % STORE VALUE
074652         LDA   SVLCO,B         % GET LAST COMMAND
074653         AND   (16000          % MASK FOR WRITE AND COMPARE BIT, AND MARG.REC. BIT
074654         ADD   BTSTA ,B        % ADD TO NEW COMMAND IN ORDER NOT TO
074655         STA   BTSTA ,B        % REVERSE THE FIFO DIRECTION IN BLCOG
074656         LDA   BUSFL,B         % PREVIOUS X-FER TO BE CHECKED?
074657         JAF   BRSR1           % NO - ,CONTINUE
074660         STZ   SPAFL ,B        % RESET SPARE TRACK ALLOCATION FLAG
074661         LDA   BTSTA ,B
074662  BLCOG, INIOX LCO             % SET CWR15=0
074663  BRSR1, INIOX RSR             % READ STATUS
074664         BSKP  ZRO 20 DA       % CONTROLLER ACTIV?
074665  L39,   JMP I (EXBUS          % YES, BUSY EXIT
074666         LDA   BUSFL,B         % PREVIOUS TRANSFER TO BE CHECKED?
074667         JAF   BRSR2           % YES. SKIP UNIT SELECT
074670         LDA   TRG ,B
074671         AND   (0700
074672         SHA   ZIN 1
074673         JMP *+1               % BSET  ONE 30 DA (TEST MODE)
074674         JPL   BLCO1           % SELECT UNIT
074675  "8BDIS+8BDIM+8ZBDI
074675  BRSR2, INIOX RSR             % READ STATUS
074676         STA   SSTAT ,B        % SAVE IT
074677         BSKP  ONE 160 DA      % ON CYLINDER?
074700         JPL   ERKYL           % NO. PERHAPS ERROR
074701         LDA   BUSFL,B
074702         JAZ   L18             % ZERO: NO PREVIOUS TRANSFER. JUMP TO BCONT
074703         JMP   I *+1           % JUMP TO SPARE TRACK ALLOCATION HANDLER
074704         SPHAN
074705  L33,   LDA   SMARG,B         % ERROR RECOVERY CYCLE ?
074706         JAF   SECPR           % NONZERO: YES. JUMP TO SECTOR PROCESSING
074707         LDA   SSTAT ,B        % TEST STATUS
074710         AND   (037760
074711         JAF   BREX            % NONZERO: ERRORS IN THE PREVIOUS TRANSFER
074712         JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
074713         JMP I (ECADR
074714  L18,   JMP I (BCONT          % NO ERRORS, CONTINUE
074715
074715  BREX=*
074715
074715  "8BDIS+8BDIM
074715
074715         LDA   SVLCO,B         % PREVIOUS CONTROL WORD
074716         SHA   SHR 13
074717         AAA   -1
074720         JAZ   BWTRY           % ZERO: PREVIOUS DEVICE OP. WAS WRITE
074721
074721  "8BDIS+8BDIM+8ZBDI
074721
074721         LDA   TYPEC ,B        % IS ERROR CORRECTION ALLOWED ?
074722         BSKP  ZRO 020 DA
074723         JMP I (BRTRY          % NO
074724
074724  % PREPARE ERROR RECOVERY BY INITIATING SECTOR-BY-SECTOR PROCESSING
074724
074724  L45,   SAA   -1
074725         STA   SMARG,B         % SET SECTOR RECOVERY FLAG
074726         LDD   SVLWC-1 ,B      % GET LEAST WORD COUNT TO D-REG
074727         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
074730         LDX   BSECW ,B
074731         RDIV  SX              % CONVERT TO NUMBER OF SECTORS
074732         LDX   XRG ,B
074733         COPY  SA DA CM2
074734         COPY  SA DA AD1
074735         STA   SLONG,B         % STORE SECTOR CONTROL NUMBER
074736         LDA   BSECW ,B
074737         STA   SVLWC,B         % SET WORD COUNT TO ONE SECTOR
074740         STZ   SVLWK ,B
074741
074741  "8BDIS+8BDIM
074741
074741         LDA   SVLCO ,B
074742         SHA   SHR 013
074743         AAA   -1
074744         JAZ   L44             % OPERATION WAS WRITE
074745
074745  "8BDIS+8BDIM+8ZBDI
074745
074745         JMP I (BRTRY
074746
074746  "8BDIM+8BDIS
074746
074746  % WRITE-RETRY AFTER ERROR
074746
074746  BWTRY, LDA   SSTAT ,B
074747         BSKP  ONE 0130 DA
074750         JMP   L44             % NOT DMA-ERROR
074751         LDA   SVLWK ,B
074752         JAF   L45             % WORD COUNT > 64K
074753         LDD   SVLWC-1 ,B
074754         LDA   BSECW ,B
074755         AAA   1
074756         SKP   DD MLST SA
074757         JMP   L45             % WORD COUNT > ONE SECTOR
074760  L44,   MIN   ERRC1,B
074761         JMP   L8
074762         JMP I (ERR            % NO MORE RETRIES ALLOWED
074763  L8,    MIN   SWTRY,B         % COUNT ONE RETRY
074764         0
074765         JMP I (BOM
074766
074766  "8BDIM+8BDIS+8ZBDI
074766
074766  ERKYL, LDA   BUSFL ,B
074767         JAZ   L22             % ZERO: NO PREVIOUS TRANSFER
074770         LDA   SVLCO ,B
074771         BSKP  ONE 0120 DA
074772         JMP   L22             % NOT MARGINAL RECOVERY
074773         LDA   SSTAT ,B        % A MARG. REC. TRANSFER FINISHED. IGNORE NOT-ON-CYL
074774         BSET  ONE 0160 DA
074775         STA   SSTAT ,B
074776         EXIT
074777  L22,   JMP   I (ERCYL
075000
075000  )FILL
075020
075020  BLCO1, INIOX LCO             % LOAD CONTROL WORD
075021         EXIT
075022

075022  % ERROR RECOVERY (SECTOR-BY-SECTOR PROCESSING)
075022  %
075022  SECPR, LDA   SSTAT ,B        % GET STATUS
075023         AND   (037760
075024         JAF   ERRAN           % NONZERO: ERROR DURING PREVIOUS TRANSFER
075025  L4,    JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
075026         JMP I (ECADR
075027         LDA   SLONG,B         % TEST SECTOR RETRY NUMBER
075030         JAP   L18             % POS: SECTOR RETRY COMPLETED. JUMP TO BCONT
075031         SAA   037
075032         AND   SVLBA ,B        % MASK OUT SECTOR BITS
075033         SUB   BSECT ,B        % SECTORS/TRACK
075034         AAA   1               % FIRST=0 NOT 1!!
075035         JAF   L10             % JUMP IF NOT LAST SECTOR ON TRACK
075036         LDA   SVLBA,B
075037         AND   (17400          % MASK FOR HEAD BITS
075040         ADD   (400            % INCR. HEAD ADDR.
075041         STA   SVLBA,B
075042         JMP   L11
075043  L10,   MIN   SVLBA,B         % INCREMENT SECTOR ADDRESS
075044  L11,   MIN   SLONG,B         % INCREMENT SECTOR CONTROL NUMBER
075045         0
075046         LDA   CMAD2,B
075047         ADD   BSECW ,B        % ADD ONE SECTOR
075050         STA   SVLCA,B         % NEW CORE ADDR.    (16 LOWER)
075051         STA   CMAD2,B
075052         LDA   CMAD1,B
075053         COPY  SA DA ADC
075054         STA   CMAD1,B         % NEW CORE ADDR.   (BANK BITS)
075055         JPL I (BQERR          % SUCCESSFULL SECTOR RETRY. RESET ERROR COUNTERS
075056         STZ   MARGC,B         % RESET MARGINAL CYCLE FLAG
075057         LDA   SVLCO,B
075060         BSET  ZRO 120 DA
075061         STA   SVLCO,B         % RESET COMMAND WORD
075062         AND   (017600
075063         STA   BTSTA ,B
075064
075064  "8BDIS+8BDIM
075064
075064         SHA   SHR 013
075065         AAA   -1
075066         JAZ   L8              % ZERO: OPERATION WAS WRITE
075067
075067  "8BDIS+8BDIM+8ZBDI
075067
075067         JMP I (BRTRY
075070

075070  % PREPARE FOR ERROR CORRECTION (CHECK IF CONDITIONS ARE FAVORABLE)
075070  %
075070  ERRAN=*
075070
075070  "8BDIS+8BDIM
075070
075070         LDA   SVLCO,B
075071         SHA   SHR 13
075072         AAA   -3
075073         JAZ   RETRY           % JUMP IF COMPARE COMMAND
075074         AAA   2
075075         JAZ   L44             % ZERO: OPERATION WAS WRITE
075076         BSKP  ZRO 0140
075077         JMP   L24             % N100
075100         LDA   CMAD1,B         % TEST FOR CORE ADDR. > 256K
075101         SHA   ZIN SHR 2
075102         JAF   RETRY           % CORE ADDR. TOO BIG FOR ECC
075103
075103  "8BDIS+8BDIM+8ZBDI
075103
075103  L24,   LDA   SSTAT ,B        % GET STATUS
075104         BSKP  ONE 110 DA      % SKIP IF DATA ERROR
075105         JMP   RETRY           % IF NOT --RETRY.
075106         AND   (036740         % MASK FOR ALL ERRORS (OTHERS)
075107         JAF   RETRY           % JUMP TO RETRY IF ANY ERRORS
075110  BRSC5, INIOX RSC             % READ SEEK CONDITION
075111         BSKP  ZRO 170 DA      % SKIP IF NOT ADDRESS FIELD
075112         JMP   RETRY           % ADDRESS FIELD,-GO TO RETRY
075113         COPY  SA DT           % SAVE SEEK CONDITION
075114         LDA   ECCFL,B         % IS ECC OP. FLAG SET?
075115         JAZ   RECOP           % JUMP IF FLAG NOT SET
075116         BSKP  ZRO 150 DT      % SKIP IF MAX ECC COUNT
075117         JMP   ECCOP           % CORRECTABLE !
075120         STZ   ECCFL,B         % PREPARE FOR RETRY
075121         LDA   BTSTA ,B
075122         BSET  ONE 170 DA
075123         JPL   BLCO1           % SET CWR15=1.
075124  BRSC3, INIOX RSC             % READ ECC COUNT
075125         SUB   (20071          % COUNT SHOULD BE =8249
075126         JAF   ERREC
075127  RETRY, JPL I (RESEC          % RESET ECC
075130         JMP I (BRTRY          % MARGINAL RECOVERY CYCLE EXIT
075131  RECOP, SAA   -1
075132         STA   ECCFL,B
075133         LDA   BTSTA ,B
075134         BSET  ZRO 0140 DA     % REMOVE BIT 12 IF PARITY CHECK
075135         ADD   (40005          % SET CWR14=0,ACTIVATE,ENBL.INTRPT.
075136         JPL   BLCO1           % START ECC-OP.
075137         JMP I (EXBUS
075140
075140  )FILL
075155

075155  % ERROR CORRECTION
075155  %
075155  ECCOP, STZ   ECCFL,B         % ECCFL:=0
075156         LDA   BTSTA ,B
075157         BSET  ONE 170 DA
075160         JPL   BLCO1           % SET CWR15=1.
075161  BRSR4, INIOX RSR             % READ ECC PATTERN
075162         SAT   -13
075163         STT   CDISP ,B
075164         SAT   0
075165         JMP   L2              % START PATTERN MIRRORING
075166  L1,    SHA   SHR 1
075167         SHT   ZIN 1
075170  L2,    BSKP  ZRO 0 DA
075171         BSET  ONE 0 DT
075172         MIN   CDISP ,B
075173         JMP   L1
075174         COPY  ST DA
075175         STA   CPAT1,B         % STORE PATTERN TEMPORARILY
075176         JAZ   ERREC
075177  BRSC4, INIOX RSC             % READ ECC COUNT ( 2-020001 FOR BIT IN SECTOR)
075200         JAN   ERREC
075201         STA   CDISP ,B        % SAVE ECC COUNT
075202         AAA   -2
075203         JAN   ERREC           % NEG: COUNT < 2
075204         SUB   K8191
075205         AAA   -071
075206         JAP   ERREC           % POS: COUNT > 8249
075207         AAA   056
075210         JAP   AYPAS           % POS: COUNT > 8203.  DATA ALREADY OK
075211         LDA   BTSTA ,B
075212         JPL   BLCO1           % SET CWR15=0.
075213         LDA   CDISP ,B        % ECC COUNT
075214         AAA   -014
075215         RCLR  DL              % L:=0
075216         JAP   L6
075217         RINC  DL              % L:=1
075220         AAA   012             % WORDNO MUST NOT BE NEGATIVE
075221  L6,    SAD   SHR 4
075222         STA   CDISP ,B        % WORDNO IN SECTOR
075223         SAA   0
075224         SAD   4
075225         COPY  SA DD
075226         SAA   0105
075227         SKP   DL EQL 0
075230         AAA   012             % BECAUSE OF WORDNO COMPENSATION ABOVE
075231         RSUB  SD DA
075232         ADD   SADIN           % SAD 0
075233         COPY  SA DX
075234         LDA   CPAT1 ,B        % ECC PATTERN
075235         RCLR  DD
075236         EXR   SX              % SHIFT PATTERN
075237         STA   CPAT1 ,B        % SAVE CORRECTION PATTERNS
075240         COPY  SD DA
075241         STA   CPAT2 ,B
075242
075242  "8BDIM+8BDIS
075242
075242         LDA   BTSTA ,B
075243         BSKP  ZRO 0140 DA     % TEST IF PARITY COMMAND
075244         JMP   AYPAS           % BYPASS CORRECTION ON PARITY COMMAND
075245
075245  "8BDIM+8BDIS+8ZBDI
075245
075245         LDD   CMAD1-1 ,B      % CMAD1 TO D
075246         LDA   CDISP ,B        % WORDNO IN SECTOR
075247         ADD   CMAD2 ,B
075250         SWAP  SA DD
075251         COPY  SA ADC DA
075252         STD   ADSAV           % SAVE CORRECTION ADDR
075253         LDX   CPAT1 ,B        % PATTERN 1
075254         JXZ   L5
075255
075255  "8BDIM+8BDIS
075255
075255         JPL I (L46            % GET DATA
075256
075256  "8BDIM+8BDIS+8ZBDI
075256
075256         REXO  SX DT           % CORRECT DATA
075257
075257  "8BDIM+8BDIS
075257
075257         LDD   ADSAV           % 24-BIT ADRESS
075260         JPL I (L57            % STORE CORRECTED DATA
075261
075261  "8BDIM+8BDIS+8ZBDI
075261
075261  L5,    LDD   ADSAV           % 24-BIT ADRESS
075262         RINC  DD
075263         COPY  ADC SA DA
075264         STD   ADSAV           % SAVE NEXT 24 BIT ADRESS
075265         LDX   CDISP ,B        % WORDNO IN SECTOR
075266         AAX   1
075267         BSKP  ZRO 0110 DX
075270         JMP   AYPAS           % WORDNO IS 01000.  DONT CORRECT
075271         LDX   CPAT2 ,B        % PATTERN 2
075272         JXZ   AYPAS
075273
075273  "8BDIM+8BDIS
075273
075273         JPL I (L46            % NEXT DATA WORD
075274
075274  "8BDIM+8BDIS+8ZBDI
075274
075274         REXO  SX DT           % CORRECT DATA
075275
075275  "8BDIM+8BDIS
075275
075275         LDD   ADSAV           % 24-BIT ADRESS
075276         JPL I (L57            % STORE CORRECTED DATA
075277
075277  "8BDIM+8BDIS+8ZBDI
075277
075277  AYPAS, MIN   CORCU ,B        % INCREASE CORRECTION COUNTER
075300         0
075301         LDA   SSTAT ,B        % REMOVE DATA ERROR BIT FROM STATUS
075302         AND   (176757
075303         STA   SSTAT ,B
075304         LDD   ARG ,B          % RESET AD
075305         LDX   XRG ,B
075306         JPL I (RESEC          % RESET ECC
075307         JMP I (L4
075310
075310  ERREC, JMP I (ERREB          % JUMP-HELP
075311
075311  K8191, 017777
075312  SADIN, SAD   0
075313  ADSAV, 0; 0
075315
075315  )FILL
075323

075323  % TRY AGAIN AFTER ERROR (NOT WRITE)
075323  %
075323  BRTRY, LDA   MARGC,B         % MARC. REC. CYCLE FLAG ALREADY SET?
075324         JAF   BMARG           % NONZERO: YES
075325         STZ   ECCFL,B         % RESET ECC PROCESSING FLAG
075326         MIN   ERRC1,B         % ORDINARY RETRIES DONE?
075327         JMP   L12             % NO. TRY ONCE MORE
075330         LDA   TYPEC ,B        % MARG REC ALLOWED ?
075331         BSKP  ZRO 030 DA
075332         JMP I (ERR            % NO
075333         ADD   (02000          % INCREMENT MARG REC COUNTER (BITS 15-10)
075334         STA   TYPEC ,B
075335         SAA   -1
075336         STA   MARGC,B         % SET MARG REC. CYCLE FLAG
075337         LDA   SVLCO,B
075340         BSET  ONE 120 DA      % SET BIT 10 IN CONTROL WORD(MARG. REC.)
075341         STA   SVLCO ,B
075342         AND   (017600
075343         STA   BTSTA ,B
075344  BMARG, MIN   ERRC2,B         % ALL MARG. REC.'S DONE?
075345         JMP   BOM
075346         JMP I (ERR            % 3 MARG. REC. CYCLES DONE. ERROR
075347  L12,   MIN   SRTRY ,B
075350         0
075351  %
075351  % TRANSFER ROUTINE
075351  %
075351  BOM,   LDA   BTSTA ,B
075352  "8BDIM+8BDIS+8ZBDI
075352         JPL   BLCOF           % CWR 15:=0
075353         SAA   -0100
075354         SHA   3
075355         STA   CPAT1 ,B        % TEMPORARILY USED FOR TIMEOUT
075356  BRSR8, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
075357         BSKP  ZRO 0160 DA
075360         JMP   L58             % ON-CYL
075361         MIN   CPAT1 ,B
075362         JMP   BRSR8
075363  L58,   LDA   SVLBA,B         % HEAD AND SECTOR
075364
075364  "8BDIS+8BDIM+8ZBDI
075364
075364  BLBA1, INIOX LBA             % LOAD HEAD AND SECTOR
075365         LDA   BTSTA ,B
075366         BSET  ONE 170 DA
075367         JPL   BLCOF           % CWR 15:=1
075370         LDA   SVLBB,B
075371
075371  "8BDIS+8BDIM
075371
075371         SAA   077
075372         AND   TRG ,B
075373         AAA   -043
075374         JAZ   L13
075375         AAA   043-044
075376         JAZ   L13
075377         SAA   0
075400         BSET  ONE 0170 DA
075401  L13,   BSET  BCM 0170 DA
075402         ADD   SVLBB ,B
075403
075403  "8BDIS+8BDIM+8ZBDI
075403
075403  BLBA3, INIOX LBA             % LOAD CYLINDER ADDRESS
075404         JPL I (RESEC          % RESET ECC.  SET CWR15:=0
075405         LDA   CMAD1,B
075406  BLCA1, INIOX LCA             % LOAD BANK NO
075407         LDA   CMAD2,B
075410  BLCA3, INIOX LCA             % LOAD MEMORY ADDR WITHIN BANK
075411         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
075412  BLWC2, INIOX LWC
075413         LDA   SVLWC,B
075414  BLWC1, INIOX LWC             % LOAD WORD COUNT
075415         LDA   SVLCO,B
075416         JPL   BLCOF           % START TRANSFER
075417  BRSR3, INIOX RSR             % READ STATUS
075420         STA   SSTAT ,B
075421         BSKP  ONE 20 DA       % CONTROLLER ACTIVE ?
075422         JMP I (ERACT          % NO
075423         LDA   SVLWC ,B        % WORD COUNT
075424         ADD   CMAD2 ,B        % LEAST SIGN. PART OF MEMORY ADDR
075425         STA   SCADR ,B        % EXP. LEAST SIGN. PART OF THE CORE ADDR REG
075426  EXBUS, SAA   -1
075427  EXBU2, STA   BUSFL,B         % SET BUSY FLAG
075430         LDA   9LREG ,B
075431         COPY  SA DL
075432         LDF   TRG ,B
075433         EXIT  AD1             % BUSY EXIT!!!
075434
075434  )FILL
075441

075441  % START A NEW TRANSFER WHEN X IS NONZERO
075441  %
075441  BCONT, SKP   IF DX UEQ 0
075442         JMP I (FINEX          % ALL BLOCKS TRANSFERED
075443         STZ   SMARG,B
075444  BRSC6, INIOX RSC             % READ SEEK COND.
075445         COPY  SA DT
075446         LDA   BTSTA ,B
075447         BSET  ONE 170 DA
075450         JPL   BLCOF           % SET CWR 15 =1.
075451         LDA   TYPEC ,B
075452         COPY  SA DL
075453         BSET  ONE 0110 DL     % BIT FOR 15KHZ INTERFACE
075454  BRSR5, INIOX RSR             % READ ECC PATTERN
075455         AND   (174000         % MASK FOR BITS 11-15 OF A-REG.
075456         SUB   (134000
075457         JAZ   NEWIE           % ZERO: 15KHZ INTERFACE
075460         BSET  ZRO 0110 DL
075461         BSET  ZRO 0160 DA
075462         JAZ   NEWIE           % ZERO: 10 KHZ INTERFACE
075463         JMP I (ERTYP          % ERROR.
075464  %
075464  % DECIDE IF HEAD-ADVANCE SHOULD BE USED
075464  %
075464  NEWIE, COPY  SL DA
075465         STA   TYPEC ,B
075466         COPY  AD1 DL          % L:=1
075467
075467  "8BDIS+8BDIM
075467
075467         LDA   TRG ,B
075470         BSKP  ZRO 0160 DA
075471         JMP   L19             % PHOENIX
075472         SHA   075
075473         AND   (030            % UNIT NUMBER IN BITS 4-3
075474         ADD   (BSKP  ZRO 040 DA
075475         STA   *+2
075476         LDA   TYPEC ,B        % IS HEAD ADVANCE ALLOWED ?
075477         0                     % BSKP  ZRO 040 DA   FOR UNIT 0
075500         JMP   L19             % NO
075501         BSKP  ZRO 0140 DT
075502         BSET  ONE 010 DL      % HEAD ADVANCE. L:=3
075503
075503  "8BDIS+8BDIM+8ZBDI
075503
075503  L19,   SAA   -4
075504         AND   TYPEC ,B        % REMOVE BITS 1-0 FROM TYPEC
075505         RADD  SL DA
075506         STA   TYPEC ,B        % 1 OR 3 IN BITS 1-0
075507  %
075507  % COMPUTE THE BLOCK ADDRESS OF THE LAST BLOCK (SECTOR) IN THE TRANSFER
075507  %
075507         LDA   ARG ,B          % MOST SIGN. OF LOG. DISK ADDR
075510         LDT   TRG ,B
075511         BSKP  ONE 0160 DT     % PHOENIX DISK ?
075512         JMP   XY              % NO
075513         BLDA  170 DD          % SAVE FIXED/REMOV INDICATOR IN K
075514         BSET  ZRO 170 DD
075515         SAT   0
075516         BSET  BAC 140 DT      % SURFACE ALWAYS 20+N FOR FIXED DISK
075517         STT   SAVT
075520         JMP   XY
075521
075521  SAVT,  0
075522
075522  )FILL
075530  K7000, 07000
075531
075531  BLCOF, INIOX LCO             % LOAD CONTROL WORD
075532         EXIT
075533
075533  XY,    AAX   -1
075534         RADD  SX DD
075535         COPY  SA ADC DA       % ADDR OF LAST SECTOR NOW IN AD
075536         AAX   1
075537         LDT   BSECY ,B        % SECTORS/CYL
075540         SKP   DA MLST ST
075541         JMP   L40             % CYL > MAX CYL
075542         RDIV  ST
075543         LDT   BMXCY ,B
075544         SKP   DT MGRE SA
075545  L40,   JMP I (ILAD           % CYLINDER > MAX CYLINDER
075546         STA   SVLBB,B         % SAVE CYLINDER ARGUMENT
075547         COPY  SD DA AD1
075550         STA   HESEC           % 0 < HESEC <= BSECY
075551         SKP   DX GRE SA       % CHECK IF TRANSFER IS GREATER THAN 63.5K
075552         COPY  SX DA
075553         LDT   BSECW ,B        % A IS NO. OF SECTORS IN TRANSFER
075554         RMPY  ST DA
075555         JAZ   L20             % ZERO: LESS THAN 64K
075556         SWAP  SA DD
075557         RADD  ST DA
075560         RADD  ADC CM1 DD
075561         SWAP  SA DD
075562         RDIV  ST              % AFTER THIS, A HOLDS NUMBER OF SURPLUS SECTORS
075563         LDT   TYPEC ,B
075564         BSKP  ZRO 0110 DT
075565         SAA   0               % 15 KHZ INTERFACE. ALLOW MORE THAN 63.5K
075566  L20,   COPY  SA DL           % SAVE IT IN L FOR A LITTLE WHILE
075567         LDA   HESEC
075570         COPY  SA DD
075571  %
075571  % COMPUTE SURFACE AND SECTOR NUMBER
075571  %
075571         LDA   TYPEC,B
075572         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
075573         JMP   L14
075574         COPY  SX DA
075575         SKP   IF DA LST SD    % SKIP IF WHOLE TRANSFER WITHIN CYLINDER
075576         COPY  SD DA
075577         RSUB  SA DD
075600         RADD  SL DD           % SURPLUS SECTORS
075601         JMP   L23
075602  L14,   RDCR  DD
075603  L23,   SAA   0
075604         LDT   BSECT ,B        % GET SECTORS/TRACK
075605         RDIV  ST              % A:=SURFACE NO.
075606         COPY  SD DT           % D&T=NUMBER OF SECTORS IN LAST CYLINDER
075607         SHA   ZIN  10         % SURFACE IN LEFT BYTE
075610         RADD  SA DD           % MERGE SURFACE AND SECTOR
075611         AAT   1               % NO. OF SECTORS IN LAST CYLINDER
075612         LDA   TRG ,B
075613         BSKP  ONE 160 DA      % IF CARTRIDGE DISK
075614         JMP   NOTPH
075615         AND   K7000           % MASK FOR SURFACE (LA BIT 16-18)
075616         SHA   ZIN SHR 1       % MOVE TO BIT 8-10
075617         ADD   SAVT            % ADD SECTOR AND FIXED/REMOVABLE SURFACE FLAG
075620         ADD   HESEC
075621         AAA   -1
075622         COPY  SA DD
075623         AND   (03400
075624         JAZ   NOTPH           % ZERO: SURFACE 0 OR 020
075625         BSKP  ONE 0140 DD
075626         JMP   L40             % REMOVABLE, AND SURFACE # 0 !!
075627  NOTPH, LDA   TYPEC,B
075630         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
075631         JMP   L15
075632         COPY  SD DA
075633         JMP   L3
075634  L15,   SKP   IF DX GRE ST
075635         COPY  SX DT           % T: NO. OF SECTORS TO TRANSFER
075636         COPY  SD DA AD1
075637         RSUB  ST DA           % A: HARDWARE BLOCK ADR.
075640  L3,    STA   SVLBA,B         % SAVE HEAD AND SECTOR
075641  %
075641  % DECREMENT X
075641  %
075641         LDA   TYPEC,B
075642         BSKP  ONE 10 DA
075643         JMP   L7              % JUMP IF NOT HEAD ADVANCE
075644         LDT   HESEC           % LOAD HEAD + SECTOR
075645         SKP   IF DX GRE ST
075646         COPY  SX DT
075647         RSUB  SL DT           % SURPLUS SECTORS
075650  L7,    RSUB  ST DX           % X: NO. OF BLOCKS LEFT TO THE NEXT TRANSFER
075651         STX   XRG ,B
075652  %
075652  % X IS NOW NO. OF BLOCKS TO BE TRANSFERRED NEXT TIME.
075652  % T IS NOW NO. OF BLOCKS TO TRANSFER THIS TIME.
075652  % COMPUTE SVLCA, CMAD1, CMAD2, SVLWC.
075652  %
075652         LDA   BSECW ,B
075653         RMPY  SX DA           % AD: X*BSECW=NO. OF WORDS LEFT
075654         SWAP  SA DD
075655         ADD   MEMA2 ,B
075656         COPY  SD ADC DD
075657         STA   SVLCA ,B
075660         SWAP  SA DD
075661         ADD   MEMA1 ,B
075662         STD   CMAD1 ,B
075663         LDA   BSECW ,B
075664         RMPY  ST DA           % AD: T*BSECW=NO. OF WORDS TO TRANSFER
075665         STA   SVLWK ,B        % SAVE MOST SIGN WORD COUNT
075666         COPY  SD DA
075667         STA   SVLWC,B         % SAVE WORD COUNT
075670  %
075670  % PREPARE BTSTA AND THE CONTROL WORD (SVLCO)
075670  %
075670  "8BDIS+8BDIM
075670
075670         SAA   3
075671         AND   CMAD1 ,B
075672         SHA   5               % CORE ADDR BITS 17-16
075673         COPY  SA DT
075674
075674  "8BDIS+8BDIM+8ZBDI
075674
075674         LDA   TRG ,B
075675         AND   K0700
075676         SHA   ZIN 1           % UNIT NO
075677
075677  "8BDIS+8BDIM
075677
075677         RADD  SA DT
075700         SAA   077
075701         AND   TRG ,B
075702         AAA   -042
075703         JAZ   L54             % FUNCTION 042
075704         AAA   042-043
075705         JAZ   L56             % FUNCTION 043
075706         AAA   043-044
075707         JAZ   L55             % FUNCTION 044
075710         AAA   044
075711         JMP   L56
075712  L54,   AAA   1
075713  L55,   AAA   1
075714  L56,   SHA   013             % DEVICE OPERATION
075715         RADD  ST DA
075716
075716  "8BDIS+8BDIM+8ZBDI
075716
075716         STA   BTSTA ,B
075717         AAA   5               % ACTIVATE & ENABLE INTERRUPT
075720         STA   SVLCO,B         % SAVE CONTROL WORD
075721
075721  "8BDIS+8BDIM
075721
075721         SAA   077             % CHECK FOR FUNCTION 042 (TEST IF SPARE-SECTOR FORMAT)
075722         AND   TRG ,B
075723         AAA   -042
075724         JAF   L42
075725         JMP I (L60            % YES, FUNCTION 042
075726
075726  % THE CODE BELOW IS FOR FUNCTION 037, WHICH IS A SUBFUNCTION OF FUNCTION 042.
075726  % IT WILL START A PARITY CHECK ON THE SPARE TRACK AREA.
075726
075726  L65,   LDA   BMXCY+1 ,B      % FIRST CYL IN SPARE TRACK AREA
075727         STA   SVLBB ,B
075730         JAF   L42
075731         JMP I (L64            % NO SPARE TRACKS
075732
075732  "8BDIS+8BDIM+8ZBDI
075732
075732  L42,   JMP I (BOM            % JUMP TO TRANSFER ROUTINE
075733
075733  )FILL
075740  K0700, 0700
075741  HESEC, 0
075742

075742  % THIS IS THE FINISHED-AND-OK EXIT
075742  %
075742  FINEX, LDX   SSTAT ,B
075743         JPL   BQERR           % RESET ERROR COUNTERS
075744         STZ   ECCFL,B
075745         STZ   SMARG,B
075746         STZ   MARGC,B
075747         STZ   BUSFL,B
075750         STZ   SPAFL ,B
075751
075751  "8BDIS+8BDIM
075751
075751         JPL I (L52            % AUTOMATIC RELEASE
075752
075752  "8BDIS+8BDIM+8ZBDI
075752
075752         LDA   9LREG ,B
075753         COPY  SA AD1 DL
075754         LDF   TRG ,B
075755         EXIT  AD1             % FINISHED EXIT
075756  %
075756  % RESET-ECC SUBROUTINE
075756  %
075756  RESEC, LDA   BTSTA ,B
075757         BSET  ONE 170 DA
075760  BLCOH, INIOX LCO             % SET CWR15 = 1
075761         SAA   1
075762         ADD   BMXCY+2 ,B
075763  BLWC3, INIOX LWC             % RESET ECC
075764         LDA   BTSTA ,B
075765  BLCO8, INIOX LCO             % SET CWR15=0.
075766         EXIT
075767  %
075767  % READ-AND-CHECK THE CORE ADDR REG
075767  %
075767  BRSR6, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
075770
075770  "8BDIS+8BDIM
075770
075770         SAA   077
075771         AND   TRG ,B
075772         AAA   -2
075773         JAZ   L38             % ZERO: PARITY CHECK
075774
075774  "8BDIS+8BDIM+8ZBDI
075774
075774  BRCA,  INIOX RCA             % READ CORE ADDR. REG
075775         STA   DRIAR
075776         SUB   SCADR,B
075777         JAF   L37             % NONZERO: CORE ADDR. REG NOT AS EXPECTED
076000         LDA   SVLWC ,B        % WORD COUNT
076001         ADD   CMAD2 ,B        % LEAST MEM ADDR
076002         LDA   CMAD1 ,B        % BANK NO
076003         COPY  SA ADC DA       % EXP. BANK NO
076004         ADD   SVLWK ,B        % MOST SIGN WORD COUNT
076005         STA   SAVBN
076006  BRCA2, INIOX RCA             % READ BANK NO
076007         AND   K0377
076010         SUB   SAVBN
076011         STA   SAVBN           % SAVE RESULT TEMP.
076012  BRSC1, INIOX RSC
076013         BSKP  ONE 0140 DA
076014  L38,   EXIT  AD1             % N10 INTERFACE, OR OK
076015         LDA   SAVBN
076016         JAZ   L38
076017  L37,   EXIT                  % BANK NO, OR ADDR, NOT AS EXPECTED
076020
076020  SAVBN, 0
076021  K0377, 0377
076022
076022  )FILL
076023
076023  % RESET ERROR COUNTERS
076023
076023  BQERR, SAA   -4
076024         STA   ERRC1 ,B
076025         SAA   -034
076026         STA   ERRC2 ,B
076027         EXIT
076030

076030  % BELOW FOLLOW THE DIFFERENT ERROR EXITS
076030  %
076030  ERACT, SAT   0100            % NOT ACTIVE AFTER ACTIVATE
076031         JMP   L9              % SET BIT 017 IN T
076032
076032  ILCOD, SAT   040             % ILLEGAL DEVICE OPERATION
076033         JMP   L9              % SET BIT 016 IN T
076034
076034  ERTYP, SAT   020             % CONTROLLER DEFINITION PROBLEM
076035         JMP   L9              % SET BIT 015 IN T
076036
076036  ERREB, SAT   010             % ECC PROBLEM
076037         JMP   L9              % SET BIT 014 IN T
076040
076040  ILAD, SAT   4                % LOGICAL DISK ADDR IS TOO BIG
076041         JMP   L9              % SET BIT 013 IN T
076042
076042  ECADR, SAT   2               % CORE ADDR REG ERROR. SET BIT 012 IN T
076043
076043  L9,    SHT   011             % SHIFT ERROR BIT TO CORRECT PLACE
076044         LDA   TRG ,B
076045         AND   BMASK
076046         RADD  SA DT
076047         SAA   0
076050         JPL   BLCO8           % CWR15:=0
076051  BRSC7, INIOX RSC
076052         STA   RSCON
076053         JPL   BQERR           % RESET ERROR COUNTERS
076054         JMP   ERREK
076055
076055  ERCYL, SAX   0               % NOT ON-CYLINDER
076056         JMP   L36             % CONTINUE WITH X=0
076057
076057  ERR,   SAX   -1              % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS
076060  L36,   JPL   BQERR           % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS ARE DONE
076061         LDA   TRG ,B
076062         AND   BMASK
076063         COPY  SA DT
076064  BRSC2, INIOX RSC
076065         STA   RSCON
076066         BSKP  ZRO 130 DA
076067         BSET  ONE 110 DT      % SEEK ERROR
076070         BSKP  ONE 130 DA
076071         JXZ   ERREK           % JUMP TO ERREK IF X=0 AND NOT SEEK ERROR
076072         LDA   TRG ,B
076073         AND   K0700
076074         SHA   ZIN 1
076075         AAA   20
076076  BLCO3, INIOX LCO             % DEVICE CLEAR
076077         ADD   (033775         % RETURN-TO-ZERO SEEK (TEST MODE)
076100         LDX   RSCON
076101         BSKP  ONE 0140 DX
076102         BSET  ZRO 030 DA      % N-10.  REMOVE TEST MODE
076103  BLCO4, INIOX LCO
076104
076104  "8BDIS
076104
076104         STT   TRG ,B          % SAVE ERROR INFORMATION
076105         STT   CPAT2 ,B        % SAVE TRG UNTIL ERROR EXIT
076106         LDA   SSTAT ,B        % SAVE STATUS IN BUSY FLAG, AND BUSY-EXIT
076107         JMP I (EXBU2
076110
076110  "8BDIS+8BDIM+8ZBDI
076110
076110  ERREK, LDA   BTSTA ,B
076111         AAA   20
076112         JPL I (BLCOF          % CLEAR DEVICE
076113         STZ   BUSFL,B
076114         STZ   ECCFL,B
076115         STZ   SMARG,B
076116         STZ   MARGC,B
076117         STZ   SPAFL ,B
076120
076120  "8BDIS+8BDIM
076120
076120         JPL I (L52            % AUTOMATIC RELEASE
076121
076121  "8BDIS+8BDIM+8ZBDI
076121
076121         LDX   SSTAT ,B
076122
076122  "8BDIS+8BDIM
076122
076122         STX   QQQST           % DISK STATUS
076123         STT   TREGI           % ERROR INFORMATION
076124         LDA   SVLCO ,B
076125         STA   CONTR           % CONTROL WORD
076126         LDA   HDEV ,B
076127         STA   DEVNO           % DEVICE NUMBER
076130         LDA   CMAD1 ,B
076131         STA   BANKN           % BANK NUMBER
076132         LDA   CMAD2 ,B
076133         STA   ADRES           % MEMORY ADDRESS
076134         LDA   SVLBB ,B
076135         STA   QQQCY           % DISK CYLINDER
076136         LDA   SVLBA ,B
076137         STA   SRFSC           % DISK SURFACE AND SECTOR
076140         LDA   SVLWC ,B
076141         STA   WORDC           % WORD COUNT
076142
076142  "8BDIS+8BDIM+8ZBDI
076142
076142         LDA   ARG ,B
076143         JMP I 9LREG ,B        % EXIT
076144
076144  )FILL
076150
076150  BMASK, 0777
076151
076151  % BELOW FOLLOW 11 WORDS THAT CONTAIN ERROR INFORMATION ABOUT THE LAST ERROR.
076151  % THEY ARE STORED THERE WHEN THE DRIVER ERROR EXITS. PLEASE NOTE THAT THE
076151  % LOWER PART OF THE CORE ADDRESS REGISTER IS STORED IN DRIAR EVERY TIME THAT
076151  % REGISTER IS CHECKED, AND THIS IMPLIES THAT THE STATUS REGISTER MUST BE OK.
076151
076151  DRIAR, 0     % LOWER 16 BITS OF CORE ADDR REG AFTER TRANSFER (STATUS IS OK)
076152
076152  "8BDIM+8BDIS
076152
076152  QQQST, 0     % STATUS REGISTER
076153
076153  "8BDIM+8BDIS+8ZBDI
076153
076153  RSCON, 0     % SEEK CONDITION
076154
076154  "8BDIM+8BDIS
076154
076154  TREGI, 0     % BITS 017-011 ARE ERROR INDICATORS, 010-6 UNIT, 5-0 DEV. OP.
076155  CONTR, 0     % CONTROL WORD
076156  DEVNO, 0     % DEVICE NUMBER (01540 OR 01550)
076157  BANKN, 0     %  8 MOST  SIGNIFICANT BITS OF THE MEMORY ADDRESS
076160  ADRES, 0     % 16 LEAST SIGNIFICANT BITS OF THE MEMORY ADDRESS
076161  QQQCY, 0     % CYLINDER           PART OF THE DISK ADDRESS
076162  SRFSC, 0     % SURFACE AND SECTOR PART OF THE DISK ADDRESS
076163  WORDC, 0     % WORD COUNT
076164
076164  "8BDIS+8BDIM+8ZBDI
076164

076164  % SPARE TRACK ALLOCATION HANDLER.
076164  % ACTIVATED WHEN A TRANSFER GIVES ADDRESS MISMATCH STATUS ERROR.
076164  % CHECKS BIT 4 IN TYPEC ,B TO SEE IF SPARE TRACK ALLOCATION IS ALLOWED.
076164  % THE SPARE TRACK ALLOCATION PARAMETERS (I.E. THE NEW CYLINDER AND SURFACE)
076164  % ARE READ FROM THE BAD TRACK, BY READING WITH THE SAME CYLINDER AND SURFACE
076164  % AS IN THE ORIGINAL ACCESS, BUT WITH SECTOR 0100, 0101, AND SO ON, UNTIL
076164  % TWO WORDS ARE READ CORRECTLY. THOSE TWO WORDS (CYLINDER AND SURFACE) ARE THEN
076164  % USED, TOGETHER WITH THE ORIGINAL SECTOR INCREMENTED BY 0100, TO ACCESS THE
076164  % SPARE TRACK.
076164
076164  SPHAN=*
076164
076164  "8BDIS+8BDIM
076164
076164         SAA   077
076165         AND   TRG ,B
076166         AAA   -042
076167         JAF   *+2
076170         JMP I (L62            % FUNCTION IS TEST-IF-SPARE-TRACK
076171         AAA   042-037
076172         JAF   *+2
076173         JMP I (L66
076174
076174  "8BDIS+8BDIM+8ZBDI
076174
076174         LDA   SPAFL ,B        % THE SPARE TRACK ALLOCATION FLAG CAN BE 0/1/2
076175         JAF   L27
076176
076176  "8BDIS+8BDIM
076176
076176         LDA   TRG ,B
076177         SHA   075
076200         AND   (030            % UNIT NO NOW IN BITS 4-3
076201         ADD   (BSKP  ONE 040 DA
076202         STA   *+2
076203         LDA   TYPEC ,B        % SPARE TRACK ALLOCATION ALLOWED ?
076204         0                     % BSKP  ONE 040 DA   FOR UNIT 0
076205         JMP I (L33            % NO
076206
076206  "8BDIS+8BDIM+8ZBDI
076206
076206         LDA   SSTAT ,B        % ADDRESS MISMATCH ?
076207         BSKP  ONE 0100 DA
076210         JMP I (L33            % NO
076211  BRSC8, INIOX RSC             % READ SEEK CONDITION
076212         BSKP  ZRO 0130 DA
076213         JMP   ERR             % SEEK ERROR
076214         SAA   1               % FLAG:=1
076215         STA   SPAFL ,B
076216         LDA   CMAD1 ,B        % SAVE PART OF THE DATA FIELD
076217         STA   OCMD1 ,B
076220         LDA   CMAD2 ,B
076221         STA   OCMD2 ,B
076222         LDA   SVLBA ,B
076223         STA   OSVBA ,B
076224         LDA   SVLBB ,B
076225         STA   OSVBB ,B
076226         LDA   SVLCO ,B
076227         STA   OSVCO ,B
076230         LDA   SVLWC ,B
076231         STA   OSVWC ,B
076232         LDA   SVLWK ,B
076233         STA   OSVWK ,B
076234         LDA   SVLBA ,B        % SET SECTOR 0100
076235         AND   (177400
076236         BSET  ONE 060 DA
076237         STA   SVLBA ,B
076240         LDA   SVLCO ,B        % PUT READ-OP IN CONTROL WORD
076241         AND   (163777
076242         STA   SVLCO ,B
076243         AND   (177740         % AND IN BTSTA
076244         STA   BTSTA ,B
076245  L26,   SAA   2
076246         STA   SVLWC ,B        % WORD COUNT := 2
076247         STZ   SVLWK ,B
076250         LDA   NWLBB ,B        % DMA-ADDR OF EXTRA PAGE
076251         STA   CMAD1 ,B        % MEMORY ADDR IN DATA FIELD
076252         LDA   NWLBA ,B
076253         STA   CMAD2 ,B        % NWLBB AND NWLBA
076254         JMP I (BOM            % TRANSFER
076255  L27,   AAA   -1
076256         JAF   L31             % NONZERO: SPAFL IS NOT 1
076257         LDA   SSTAT ,B        % STATUS ERROR ?
076260         AND   (017760
076261         JAF   L30             % NONZERO: YES. TRY NEXT SECTOR
076262         JPL I (BRSR6          % NO. CHECK THE CORE ADDR REG
076263         JMP   L30             % CORE ADDR REG ERROR
076264         STF   BQTAD           % SAVE T AND D
076265         LDD   NWLBB ,B
076266
076266  "8BDIS+8BDIM
076266
076266         JPL I (L46            % FETCH WORD
076267         STT   BQTAD+3         % NEW CYL
076270         JPL I (L46            % FETCH WORD
076271
076271  "8BDIS+8BDIM+8ZBDI
076271
076271         STT   BQTAD+4         % NEW SURF/SECT
076272         LDF   BQTAD           % RESET T AND D
076273
076273  "8BDIS+8ZBDI
076273
076273         LDA   BQTAD+3         % CHECK THE NEW CYLINDER NUMBER
076274         JAN   L30             % NEG: ILLEGAL
076275
076275  "8BDIS+8BDIM+8ZBDI
076275
076275         SUB   BMXCY ,B
076276         AAA   -1
076277         JAP   L30             % POS: ILLEGAL
076300         LDA   TRG ,B
076301         BSKP  ZRO 0160 DA
076302         JMP   L28             % PHOENIX
076303         LDA   BQTAD+4         % CHECK THE NEW SURFACE
076304         JAN   L30             % NEG: ILLEGAL
076305         SHA   070
076306         AAA   1
076307         MPY   BSECT ,B
076310         SUB   BSECY ,B
076311         AAA   -1
076312         JAP   L30             % POS: ILLEGAL
076313         JMP   L29             % THE NEW CYL AND SURFACE OK (NOT PHOENIX)
076314
076314  )FILL
076330
076330  BQTAD, 0; 0; 0               % SAVED REGS
076333         0; 0                  % NEW DISK ADDR
076335
076335  L28,   LDA   BQTAD+4         % CHECK PHOENIX SURFACE
076336         JAN   L30             % NEG: ILLEGAL
076337         SHA   070
076340         JAZ   L29             % ZERO: OK
076341         AAA   -020
076342         JAN   L30             % NEG: ILLEGAL
076343         AAA   -5
076344         JAP   L30             % POS: ILLEGAL
076345  L29,   SAA   2               % FLAG:=2
076346         STA   SPAFL ,B
076347         LDA   OCMD1 ,B        % RESET DATA FIELD
076350         STA   CMAD1 ,B
076351         LDA   OCMD2 ,B
076352         STA   CMAD2 ,B
076353         LDA   OSVCO ,B
076354         STA   SVLCO ,B
076355         AND   (177740
076356         STA   BTSTA ,B
076357         LDA   OSVWC ,B
076360         STA   SVLWC ,B
076361         LDA   OSVWK ,B
076362         STA   SVLWK ,B
076363         LDA   BQTAD+3
076364         STA   SVLBB ,B        % NEW CYL
076365         LDA   BQTAD+4
076366         AND   (177400
076367         STA   BQTAD+4
076370         SAA   077
076371         AND   OSVBA ,B        % OLD SECTOR (+0100, OF COURSE)
076372         AAA   0100
076373         ADD   BQTAD+4         % NEW SURFACE
076374         STA   SVLBA ,B
076375         JMP I (BOM            % TRANSFER
076376  L30,   LDA   SVLBA ,B        % TRY NEXT SECTOR, IF POSSIBLE
076377         AAA   1
076400         STA   SVLBA ,B
076401         AND   (0377
076402         SUB   BSECT ,B
076403         AAA   -0100
076404         JAN   L26             % NEG: TRY NEXT
076405         LDA   OCMD1 ,B        % RESET DATA FIELD
076406         STA   CMAD1 ,B
076407         LDA   OCMD2 ,B
076410         STA   CMAD2 ,B
076411         LDA   OSVBA ,B
076412         STA   SVLBA ,B
076413         LDA   OSVBB ,B
076414         STA   SVLBB ,B
076415         LDA   OSVCO ,B
076416         STA   SVLCO ,B
076417         LDA   OSVWC ,B
076420         STA   SVLWC ,B
076421         LDA   OSVWK ,B
076422         STA   SVLWK ,B
076423         JMP I (ERR
076424  L31,   AAA   -1
076425         SKP   DA EQL 0
076426         JMP I (ERR            % SPAFL IS NOT 2
076427         LDA   SSTAT ,B
076430         AND   (017760
076431         JAF   L32             % NONZERO: STATUS ERROR
076432         JPL I (BRSR6          % CHECK THE CORE ADDR REG
076433         JMP I (ECADR          % ERROR
076434         LDA   OSVBA ,B        % RESET DISK ADDRS
076435         STA   SVLBA ,B
076436         LDA   OSVBB ,B
076437         STA   SVLBB ,B
076440         STZ   SPAFL ,B        % FLAG:=0
076441         MIN   SPACO ,B        % INCREMENT COUNTER
076442         0
076443  L32,   JMP I (L33            % BACK TO DRIVER
076444
076444  )FILL
076455
076455  "8BDIS+8BDIM
076455
076455  % PRIORITY-SELECT AND RELEASE IS HANDLED HERE
076455
076455  L49,   LDA   BUSFL ,B        % PRIORITY-SELECT. CHECK IF DRIVER IS BUSY
076456         SKP   DA EQL 0
076457         JMP I (EXBUS
076460         LDA   TRG ,B          % GET UNIT NO
076461         AND   (0700
076462         SHA   1
076463         ADD   (044010
076464         JPL I (BLCO8
076465         ADD   (134010         % GIVING 020 + UNIT NO
076466         JPL I (BLCO8
076467         LDA   TYPEC ,B        % SET RELEASE-NOT-ALLOWED BIT
076470         BSET  ONE 0100 DA
076471         STA   TYPEC ,B
076472         JMP   L51
076473  L50,   LDA   BUSFL ,B        % RELEASE. CHECK IF DRIVER IS BUSY
076474         SKP   DA EQL 0
076475         JMP I (EXBUS
076476         JPL I (BLCO8          % SELECT. A IS ZERO
076477         LDA   (044020
076500         JPL I (BLCO8          % RELEASE
076501         LDA   (002010
076502         JPL I (BLCO8          % DESELECT
076503         LDA   TYPEC ,B        % RESET RELEASE-NOT-ALLOWED BIT
076504         BSET  ZRO 0100 DA
076505         STA   TYPEC ,B
076506  L51,   LDX   (040011
076507         STX   SSTAT ,B
076510         JMP I (FINEX
076511
076511  % AUTOMATIC RELEASE IS HANDLED HERE. IT IS CALLED FROM FINEX AND ERREK
076511
076511  L52,   LDA   TYPEC ,B
076512         0                     % BSKP  ZRO 0100 DA  (175105)     **************
076513         EXIT                  % AUTOMATIC RELEASE IS NOT ALLOWED
076514         COPY  SL DA
076515         STA   L53             % SAVE L-REG
076516         SAA   0
076517         JPL I (BLCO8
076520         LDA   (044020
076521         JPL I (BLCO8
076522         LDA   (002010
076523         JPL I (BLCO8
076524         JMP I L53
076525
076525  L53,   0
076526
076526  )FILL
076537
076537  % FUNCTION 042 WILL BE STARTED HERE
076537
076537  L60,   LDA   BMXCY+4 ,B      % POINTER TO RELATED LAYOUT
076540         JAZ   L63             % ZERO: NO RELATED LAYOUT
076541         COPY  SA DX
076542         LDA   1 ,X            % SECTORS/TRACK FOR RELATED LAYOUT
076543         SUB   BSECT ,B        % SECTORS/TRACK FOR ACTUAL LAYOUT
076544         JAN   L61             % NEG: ACTUAL LAYOUT ALREADY NON-S-S
076545         LDT   TRG ,B          % CHANGE LAYOUT TO NON-S-S FORMAT
076546         SHT   072
076547         SAA   7
076550         RAND  ST DA           % UNIT NO
076551         AAA   HTABL
076552         RADD  SB DA
076553         SWAP  SA DX
076554         STA   ,X              % STORE RELATED POINTER IN DATA FIELD
076555         COPY  SA DX
076556         LDF   ,X              % CHANGE LAYOUT
076557         STF   BSECW ,B
076560         LDF   3 ,X
076561         STF   BSECW+3 ,B
076562         LDD   6 ,X
076563         STD   BSECW+6 ,B
076564  L61,   LDX   XRG ,B
076565         LDA   TYPEC ,B
076566         BSKP  ONE 0110 DA
076567         JMP   L63             % 10MHZ INTERFACE
076570         LDA   BMXCY+4 ,B
076571         JAZ   L63             % ZERO: NO RELATED POINTER
076572         LDA   BSECT ,B
076573         AAA   -1
076574         STA   SVLBA ,B        % LAST SECTOR
076575         JMP I (BOM
076576
076576  % PARITY CHECK ON LAST SECTOR, CYLINDER 0, SURFACE 0, JUST FINISHED.
076576
076576  L62,   LDA   SSTAT ,B
076577         BSKP  ONE 0100 DA
076600         JMP   L63             % NOT ADDR MISM.  USE NON-S-S FORMAT
076601         LDT   TRG ,B
076602         SHT   072
076603         SAX   7
076604         RAND  ST DX           % UNIT NO
076605         AAX   HTABL
076606         RADD  SB DX
076607         LDA   BMXCY+4 ,B      % POINTER TO RELATED LAYOUT
076610         STA   ,X              % CHANGE POINTER IN DATA FIELD
076611         COPY  SA DX
076612         LDF   ,X              % CHANGE LAYOUT
076613         STF   BSECW ,B
076614         LDF   3 ,X
076615         STF   BSECW+3 ,B
076616         LDD   6 ,X
076617         STD   BSECW+6 ,B
076620         LDX   XRG ,B
076621  L63,   LDA   TRG ,B
076622         SHA   075
076623         AND   (030
076624         ADD   (BSET ONE 040 DA
076625         STA   *+2
076626         LDA   TYPEC ,B
076627         0                     % SET BIT IN TYPEC
076630         STA   TYPEC ,B
076631         LDA   TRG ,B
076632         BSKP  ZRO 0160 DA
076633         JMP   L64             % PHOENIX
076634         SAA   -0100
076635         AND   TRG ,B          % REMOVE FUNCTION 042
076636         AAA   037             % INSERT FUNCTION 037
076637         STA   TRG ,B
076640         STZ   SVLBA ,B        % SURFACE 0, SECTOR 0
076641         LDA   SVLCO ,B
076642         BSET  ZRO 0120 DA
076643         STA   SVLCO ,B
076644         LDA   BTSTA ,B
076645         BSET  ZRO 0120 DA
076646         STA   BTSTA ,B
076647         JMP I (L65
076650
076650  % PARITY CHECK ON SPARE TRACK AREA JUST FINISHED
076650
076650  L66,   LDA   SSTAT ,B
076651         BSKP  ZRO 0100 DA
076652         JMP   L64             % ADDR MISM
076653         LDA   TRG ,B
076654         SHA   075
076655         AND   (030
076656         ADD   (BSET ZRO 040 DA
076657         STA   *+2
076660         LDA   TYPEC ,B
076661         0                     % RESET BIT IN TYPEC
076662         STA   TYPEC ,B
076663  L64,   SAA   -0100           % RESET FUNCTION 042
076664         AND   TRG ,B
076665         AAA   042
076666         STA   TRG ,B
076667         SAX   0
076670         LDA   TRG ,B
076671         SHA   075
076672         AND   (030
076673         ADD   (BSKP ZRO 040 DA
076674         STA   *+2
076675         LDA   TYPEC ,B
076676         0
076677         AAX   1               % MEANS SPARE TRACKS
076700         LDA   BMXCY+2 ,B      % FORMAT (0 OR 020)
076701         JAZ   L67
076702         AAX   2               % MEANS SPARE SECTOR FORMAT
076703  L67,   STX   SSTAT ,B
076704         JMP I (FINEX
076705
076705  )FILL
076714  )PCL MORE9
076714  )KILL RCA RSC LBA RSR LCO LWC LCA INIOX MORE9
076714
076714  "8BDIS+8BDIM
076714  )KILL BSECW BSECT BSECY BMXCY 9LREG SSTAT BTSTA
076714
076714  "8BDIS
076714
076714  L57,   DEPO                  % STORE DATA (OLD PSTWO)
076715         JMP   L71
076716  L46,   STA   L68             % SAVE A. PREPARE IMITATION OF CACHE CLEAR
076717         JAF   L69
076720         SAA   1
076721         JMP   L70
076722  L69,   SAA   0
076723  L70,   EXAM
076724         LDA   L68             % RESET A
076725         EXAM                  % FETCH DATA (OLD PLDWO)
076726  L71,   RINC  DD
076727         COPY  ADC SA DA
076730         EXIT
076731
076731  L68,   0
076732
076732  )PCL L57
076732  )KILL L57
076732
076732  "8BDIS; 8BDIS=0
076732  "
076732  )LINE
076732   SUBR WIDIS,ZWDIS
076732
076732   *"8WDIS+8WDIM+8ZWDI
"076732

076732   *)9SLPL
076732   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
076732   %                                                                                 %
076732   %   FILE NAME   : WINCHESTER:NPL                                                  %
076732   %   PROGRAM NO. : HUT-2475 A.6                                                    %
076732   %   ISSUED      : 82.02.18        BY: DG AND TP                                   %
076732   %                                                                                 %
076732   %   LAST CHANGED: 83.10.03        BY: MJH                                         %
076732   %   LAST CHANGED: 85.09.04        BY: KGT USE AD-REG FOR SECTOR ADDRESS           %
076732   %   LAST CHANGED: 86.01.29        BY: KGT CLEAR CACHE AFTER  SPARE TRACK IS READ  %
076732   %                                                                                 %
076732   % T R A N S F E R   R O U T I N E   F O R    8"   W I N C H E S T E R    D I S K  %
076732   %                                                                                 %
076732   % INCLUDING BAD TRACK REALLOCATION, BUT NO ERROR CORRECTION                       %
076732   %                                                                                 %
076732   %                                                                                 %
076732   %                                                                                 %
076732   % CALLING SEQUENCE:                                                               %
076732   %      JPL I (WIDIS          % OR  JPL I (ZWDIS  IF SWAP DRIVER                   %
076732   %      JMP   ERROR           % ERROR    EXIT                                      %
076732   %      JMP   BUSY            % BUSY     EXIT                                      %
076732   %      JMP   FINIS           % FINISHED EXIT                                      %
076732   %                                                                                 %
076732   % CALLING PARAMETERS:                                                             %
076732   %      X-REG = NUMBER OF SECTORS TO TRANSFER                                      %
076732   %      T-REG (BIT 0-5)  = FUNCTION CODE:                                          %
076732   %                          0 - READ                                               %
076732   %                          1 - WRITE                                              %
076732   %                          2 - READ PARITY                                        %
076732   %                          3 - COMPARE                                            %
076732   %                         20 - READ STATUS                                        %
076732   %                         42 - DUMMY
076732   %             BIT  6-7  = UNIT NUMBER                                             %
076732   %             BIT     8 = TRACK TEST                                              %
076732   %             BIT     9 = NOT USED                                                %
076732   %             BIT    10 = LATE DATA STROBE                                        %
076732   %             BIT 11-13 = NOT USED                                                %
076732   %             BIT    14 = EARLY DATA STROBE                                       %
076732   %             BIT    15 = BAD TRACK                                               %
076732   %      AD-REG = SECTOR ADDRESS (LOGICAL)                                          %
076732   %                                                                                 %
076732   %      THE MEMORY ADDRESS (24 BITS) IS FOUND IN THE DATAFIELD DOUBLE WORD CMAD1   %
076732   %                                                                     AND CMAD2   %
076732   %                                                                                 %
076732   %                                                                                 %
076732   % RETURN INFORMATION:                                                             %
076732   %      ERROR    EXIT: X = HARDWARE STATUS                                         %
076732   %      BUSY     EXIT: THE ROUTINE MUST BE CALLED AFTER INTERRUPT                  %
076732   %      FINISHED EXIT: X = HARDWARE STATUS                                         %
076732   %                                                                                 %
076732   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
076732
076732   *"8ZWDI -8WDIS
"076732
076732   WIDIS: *JMP WISTA
076733
076733   *"8WDIS+8WDIM+8ZWDI
"076733
076733   SYMBOL ACTIV=2 , ICERR=4 , ADDMI=10 , ONCYL=16 , TEST=10
076733   SYMBOL STREARLY=16, STRLATE=12         % BIT IN CONTR. WORD TO SET READ STROBE
076733   @LIB 8WDIM
076733   % DATA FIELD VARIABLES USED BY THE DRIVER:
076733   % WNLBA -I   MEMORY ADDRESS USES TO READ REALOCATED TRACK POINTER
076733   % WNLBB -I   CONTAIN NORMALLY ADDRESS TO ALTPO
076733   % ADMIA      SAVED ADDR MISMATCH BLOCK ADDR
076733   % ADMIS      SAVED ADDR MISMATCH STATUS
076733   % ALTPO      ADDRESS OF ALTERNATIVE TRACK POINTER
076733   % BADDR      BAD ADDR
076733   % BADIP      BAD ADDR IN PROCESS (EXTRA ADDRESS BIT)
076733   % BADTR      BAD TRACK FLAG
076733   % BUSFL      BUSY FLAG
076733   % CMAD1      MEM ADDR
076733   % CMAD2       "   "
076733   % ERRC1      RETRY COUNTER
076733   % HDEV       DEVICE NUMBER (0500,0510)
076733   % HTABL(2)   DISK DESCRIPTOR TABLE
076733   % LCYLI(2)   LAST CYLINDER
076733   % NOSEC      NO. OF SECTORS IN TRANSFER
076733   % RTZFL      RETURN-TO-ZERO FLAG
076733   % SEEKF      SEEK FLAG
076733   % SHEAD      HEAD NO.
076733   % SSEC       NO. OF SECTORS IN LAST TRANSFER
076733   % SSTEP      SAVED LAST STEP COUNT
076733   % SVLBB      SAVED DISK ADDR (CYLINDER AND SECTOR)
076733   % SVLCA      SAVED LEAST MEM ADDR
076733   % SVLCO      SAVED CONTROL WORD
076733   % SVLWC      SAVED WORD COUNT
076733   % TRTZ       RETURN-TO-ZERO FLAG
076733   % WANKN      SAVED MOST MEM ADDR
076733   % DEDFA
076733   %
076733   % THIS DISPLACEMENT IS THE LAST BEFORE A 11-WORD FIELD (13B) WHICH IS USED
076733   % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
076733   % DEDFA+1. THE 11-WORD FIELD GOES FROM DEDFA+1 TO DEDFA+13.
076733

076733   INTEGER STAT1=?
076733   INTEGER STAT3=?
076733
076733   *"8WDIS+8WDIM+8ZWDI
"076733
076733   % DRIVER INITIALIZE ------------------------------------------------
076733
076733
076733   % IOX DISPLACEMENTS:
076733
076733   @LIB CXCPU-,
076733   SYMBOL RSEE=2       % READ SEEK CONDITION
076733   SYMBOL LDAD=3       % LOAD DISK   ADDRESS REGISTER
076733   SYMBOL RSTA=4       % READ HARDWARE STATUS
076733   SYMBOL LCON=5       % LOAD CONTROL WORD
076733   SYMBOL RDAD=6       % READ DISK ADDRESS REGISTER
076733   SYMBOL LWOR=7       % LOAD WORDCOUNT
076733   SYMBOL IOXIN=164500 % IOX 500 DISC SYSTEM 1
076733   SYMBOL IOXRR=164004 % IOX READ STATUS (WITHOUT DEV. NO)
076733
076733   %  @LIB 8WDIM-,
076733   % DEFINITION OF EXTENSION TO DISK DATA FIELD
076733
076733   DISP 0
076733     INTEGER WSECW=DED01                % WORDS/SECTOR
076733     INTEGER WSECT=DED02                % SECTORS/TRACK
076733     INTEGER WSECY=DED03                % SECTORS/CYLINDER
076733     TRIPLE DISDE=WSECW
076733     INTEGER WMXCY=DED04                % MAX CYLINDER VALUE
076733     INTEGER IRETR=DED05                % DRIVER RETRY COUNTER
076733     INTEGER SSTAT=DED06                % TEMP. HARDW. STATUS
076733     INTEGER ELCOU=DED07                % DRIVER RETRY COUNTER
076733     INTEGER NOCOU=DED10                % DRIVER RETRY COUNTER
076733   PSID
076733
076733   %  @ELIB
076733
076733   DISP 0 ; TRIPLE CDISD ; INTEGER CMAXC ; PSID   % DISC LAYOUT TABLE
076733
076733   *"8WDIM
"076733

076733   %        WDISC:
076733   %  >>>>>>>>>>>>V
076733   %              V
076733   %              V
076733   %   -----------V----------------- YES
076733   %   * IS IOX STAT1 OR IOX CONT4 >>>>>>>>>>>>>>>>>>>V
076733   %   * WRONG                     *                  V
076733   %   -----------V-----------------          --------V------------
076733   %              V NO                        * GENERATE AL IOX'S *
076733   %              V                           --------V------------
076733   %              V                                   V
076733   %              V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
076733   %              V
076733   %   -----------V---------------------
076733   %   * READ STATUS. SAVE IT IN SSTAT *
076733   %   -----------V---------------------
076733   %              V
076733   %         -----V---- YES
076733   %         * BUSY ? >>>>>>>> WBUSY:
076733   %         -----V----
076733   %              V NO
076733   %         -----V--------- YES
076733   %         * ON CYLINDER ? >>>>>>>> RETZ:
076733   %         -----V---------
076733   %              V NO
076733   %     NO  -----V-------- YES
076733   %    <<<<<< BUSFL><0 ? >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
076733   %    V    --------------                                  V
076733   %    V                                                    V
076733   %  --V-------------------------------------   ------------V------------
076733   %  * SELECT UNIT AND READ STATUS AND SAVE *   * INCLUSIVE OR OF ERROR * YES
076733   %  * RESET SEEKF, BADTR, RTZFL AND TRTZ   *   * IN STATUS ?           >>>>>>>> IERR:
076733   %  --V-------------------------------------   ------------V------------
076733   %    V                                                    V NO
076733   %    V                                             -------V----- YES
076733   %  --V-------------                                * TRTZ><0 ? >>>>>>>> DSEEK:
076733   %  * IS OPERATION *                                -------V-----
076733   %  * READ STATUS  * YES                                   V NO
076733   %  * (20) ?       >>>>>>>>>> DFIN:                 -------V------ YES
076733   %  --V-------------                                * SEEKF><O ? >>>>>>> RWDIS:
076733   %    V NO                                          -------V------
076733   %  --V-------------                                       V NO
076733   %  * IS OPERATION * YES                         ----------V-------------- NO
076733   %  * >=4 ?        >>>>>>> DILLC:                * MAR=OLDMAR+OLDWORDC ? >>>>>>> MEMER:
076733   %  --V-------------                             ----------V--------------
076733   %    V NO                                                 V YES
076733   %    V                                                ----V--------- YES
076733   %    V                                                * BADTR><0 ? >>>>>>>> DBAD:
076733   %    V                                                ----V---------
076733   %    V                                                    V NO
076733   %    V>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<V
076733   %                     V
076733   %                 ----V---- YES
076733   %                 * X=0 ? >>>>>>> DFIN:
076733   %                 ----V----
076733   %                     V NO
076733   %                     V>>>>>>>>>> DSEEK:
076733

076733   WISTA: TAD=:TADRG ; X=:XRG             % SAVE T,A,D,X
076735
076735   *"8WDIS+8WDIM
"076735
076735          T SHZ 10 SHZ -16=:X             % UNIT NO IN X
076740          X:=HTABL(X)                     % POINTER TO DESCRIPTOR FIELD IN X
076741          TAD:=X.CDISD=:DISDE             % PUT WORDS/SECTOR, SECTORS/TRACK AND SECTORS/CYLINDER
076743          X:=X.CMAXC=:WMXCY               % PUT MAX CYL. VALUE
076745          X:=XRG
076746
076746   *"8WDIS+8WDIM+8ZWDI
"076746          A:=HDEV=:T                      % SAVE HDEV IN T-REGISTER
076750          *1BANK
076751          IF A+IOXRR-STAT1><0 THEN  % TEST FIRST IOX, IF NOT INITIALIZED THEN DO SO
076754               A:=T   +IOXRR  ; * STA    STAT1; STA    STAT2;  STA I (STAT3
076761               A+"LDAD-RSTA"  ; * STA I (DAD1 ; STA I (DAD3
076764               A+"RDAD-LDAD"  ; * STA I (DAD2
076766               A+"LOMAR-RDAD" ; * STA I (LMAR1; STA I (LMAR2; STA I (LMAR3; STA I (LMAR4
076773               A+"LCON-LOMAR" ; * STA    CONT1; STA    CONT2; STA I (CONT3; STA    CONT4; STA I (CONT5; STA I (CONT6
077002               A+"LWOR-LCON"  ; * STA I (WORD1; STA I (WORD2; STA I (WORD3; STA I (WORD4
077007               A+"REMAR-LWOR" ; * STA    RMAR1; STA    RMAR2
077012          FI
077012          *2BANK
077013
077013   % DRIVER MAIN ENTRY -----------------------------------------------
077013
077013   INTEGER STAT1:= IOXIN+RSTA                               % READ STATUS
077014           A=:SSTAT
077015           IF A BIT ACTIV  GO FAR WBUSY             % GO IF CONTROLLER BUSY
077017           IF A NBIT ONCYL GO FAR RETZ              % IF NOT ON CYLINDER, ERROR, RECALIBRATE
077021           IF T:=BUSFL><0                           % IF LAST LEAVE WAS A BUSY RETURN
077022              THEN                                  % THEN  OLD TRANSFER IS TO BE CHECKED
077024                IF A BIT ICERR GO     IERR          % GO IF INCLUSIVE OR OF ERRORS SET
077026                IF A:=TRTZ><0  GO FAR DSEEK         % NEW SEEK IF LAST COMMAND WAS RECALIBRATE
077031                IF A:=SEEKF><0 GO FAR RWDIS         % GO TO READ/WRITE ROUTINE IF SEEK FLAG SET
077034   *RMAR1,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. LOWER 16 BITS
077035                T:=A
077036   *RMAR2,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. UPPER 8 BITS
077037                A/\377:=:T-SVLCA
077042                T:=T+C-1
077044                A-SVLWC
077045                T:=T+C-1
077047                A:=:T-WANKN
077051                IF A><0 OR T><0 GO FAR MEMER        % MEMORY ADDRESS ERROR
077054                IF A:=BADTR><0  GO FAR DBAD         % GO TO BAD TRACK ROUTINE
077057              ELSE                                  % ELSE NEW TRANSFER
077060                A:=TRG/\300 SHZ 3 BONE 4
077064   *CONT1,      IOXIN LCON                          % SELECT UNIT, CLEAR DISC UNIT
077065   *CONT2,      IOXIN LCON                          % CLEAR DISC INTERFACE
077066   *STAT2,      IOXIN RSTA                          % READ STATUS
077067                A=:SSTAT
077070                0=:SEEKF=:BADTR
077072                0=:RTZFL=:TRTZ=:NOSEC
077075                IF A:=77/\ TRG-20=0 OR A+"20-42"=0 GO FAR DFIN     % GO IF READ STATUS COMMAND
077104                IF A+"42-3" > 0      GO FAR DILLC   % GO IF ILLEGAL COMMAND
077107          FI
077107          IF X=0 GO FAR DFIN                        % GO IF ALL WORDS TRANSFERRED, FINISHED  !!!!!!!!
077111          0=:BADIP
077112          GO FAR DSEEK                              % EXECUTE SEEK
077113
077113   *)FILL
077145

077145   % ROUTINE TO HANDLE DISK STATUS ERROR -------------------------------
077145   %
077145   %      >>>>>>>>>>>>>>>>V
077145   %                IERR: V
077145   %            ----------V----------
077145   %            * CLEAR DEVICE      *
077145   %            ----------V----------
077145   %                      V
077145   %            ----------V---------- YES
077145   %            * TRG BIT TEST      >>>>>>>> HDERR:
077145   %            ----------V----------
077145   %                      V NO
077145   %            ----------V---------- YES
077145   %            * SEEKF><0 ?        >>>>>>>> RETZ:
077145   %            ----------V----------
077145   %                      V NO
077145   %            ----------V---------- YES
077145   %            * TRTZ><0 ?         >>>>>>>> HDERR:
077145   %            ----------V----------
077145   %                      V NO
077145   %         NO ----------V---------- YES
077145   %       V<<<<< BADTR><0 ?        >>>>>>>>>>>>>>>>>>
077145   %       V    ---------------------                V
077145   %       V                                         V
077145   %  -----V-----------------   ---------------------V--------------------
077145   %  * CALCULATE THE VALUE *   * STEP THE BLOCK ADDRESS TO POINT TO THE *
077145   %  * OF XRG PRIOR TO     *   * NEXT SECTOR ON THE BAD TRACK. DID THAT * YES
077145   %  * LAST TRANSFER       *   * GIVE A TO BIG SECTOR NO. ?             >>>>>>>V
077145   %  -----V-----------------   ---------------------V--------------------      V
077145   %       V                                         V NO                       V
077145   %  -----V--------------                           V           ---------------V----------------
077145   %  * HAS AL RETRYS    * NO                        V           * RESTORE BLOCK ADD AND STATUS *
077145   %  * BEEN DONE (ERRC1)>>>>>>> RWDIS:              V           * OF THE ORIGINAL ERROR        *
077145   %  -----V--------------                           V           ---------------V----------------
077145   %       V YES                                     V                          V
077145   %  -----V------------                             V                          V
077145   %  * RESET RETRIES  *                             V                          V>>>>>> RETZ:
077145   %  * (IRETR=:ERRC1) *                             V
077145   %  -----V------------                             V
077145   %       V                                         V
077145   %  -----V----------------                         V
077145   %  * WAS THE ERROR      * NO                      V
077145   %  * ADDRESS MISMATCH ? >>>>> RETZ:               V
077145   %  -----V----------------                         V
077145   %       V YES                                     V
077145   %  -----V-----------------------------------      V
077145   %  * SSTAT=:ADMIS. READ FAILING BLOCK ADD. *      V
077145   %  * FROM THE INTERFACE. SAVE IT IN ADMIA. *      V
077145   %  * CALCULATE BLOCK ADDRESS FOR THE FIRST.*      V
077145   %  * SECTOR ON THAT TRACK.                 *      V
077145   %  * SET AND BADIP BADTR><0.               *      V
077145   %  -----V-----------------------------------      V
077145   %       V                                         V
077145   %       >>>>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<
077145   %                          V
077145   %               -----------V----------------------
077145   %               * LOAD BLOCK ADDRESS             *
077145   %               * LOAD MAR WITH ADDRESS OF ALTPO *
077145   %               * PHYS ADDR IN WNLBA AND WNLBB   *
077145   %               * LOAD WORDC WITH 1.             *
077145   %               * SET BIT 15 IN T (SEEK)         >>>>>>> WDACT:
077145   %               ----------------------------------
077145

077145
077145   IERR:   A:=20
077146   *CONT4, IOXIN LCON                            % DEVICE CLEAR
077147           IF A:=TRG BIT TEST GO FAR HDERR       % IF TEST SPECIFIED, NO ERROR HANDLING
077152           IF A:=SEEKF><0       GO RETZ          % IF THE ERROR OCCURED DURING SEEK DO RETURN TO ZERO ZEEK
077154           IF A:=TRTZ ><0       GO FAR HDERR     % IF RETURN TO ZERO SEEK ALREADY HAS BEEN DONE, ERROR RETURN
077157           IF A:=BADTR><0                        % IF BAD TRACK FLAG SET THEN
077160              THEN                               % TRY NEXT SECTOR ON THE TRACK
077161                T:=BADDR+1                       % ERROR IN ALTERNATIVE ADDRESS FETCH INCR. SECT. ADDR. TO FIND A GOOD SECTOR
077163                IF A:=37/\T-WSECT>=0             % TEST LEGAL SEC. COUNT
077166                   THEN                          % THEN ALL SECTORS ON THE TRACK TRIED
077167                     A:=ADMIA=:SVLBB             % REPORT THE ORIGINAL ERROR
077171                     A:=ADMIS=:SSTAT
077173                     GO RETZ
077174                FI
077174                A:=T                             % BLOCK ADDRESS OF NEXT SECTOR IN A
077175              ELSE
077176                A:=XRG+NOSEC=:XRG=:X             % RESTORE X AND XRG
077202                MIN ERRC1 ; GO FAR ELTE          % DO ALL RETRIES FIRST
077204                TRG BZERO STREARLY BZERO STRLATE=:TRG  % CLEAR STROBE BITS
077210                IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESTORE RETRY COUNTER
077214                IF A:=SSTAT NBIT ADDMI GO RETZ   % NOT ADDRESS MISMATCH,  RECALIBRATE  !
077217                A=:ADMIS                         % SAVE ADDRESS MISMATCH STATUS IN CASE OF REAL ADDRESS MISMATCH
077220                A:=100000=:BADTR=:BADIP          % SET BAD TRACK FLAG
077223   *DAD2,       IOXIN RDAD                       % READ LAST DISK ADDRESS
077224                A-1=:ADMIA                       % SAVE FAILING BLOCK ADDRESS REG IN CASE OF REAL ADDRESS MISMATCH
077226                A/\177740                        % BACK TO FIRST SECTOR ON THE TRACK
077227                                                 % IT IS AN ADDRESS MISMATCH, TRY BAD TRACK BIT
077227           FI
077227   *DAD3,  IOXIN LDAD                            % LOAD FAILING ADDRESS
077230           A=:BADDR
077231           A:=WNLBA=:WANKN
077233   *LMAR3, IOXIN LOMAR                            % LOAD UPPER MEM. ADDR.
077234           A:=WNLBB=:SVLCA
077236   *LMAR4, IOXIN LOMAR                            % LOAD LOWER MEM. ADDR.
077237           A:=1=:SVLWC
077241   *WORD4, IOXIN LWOR                            % LOAD WORD COUNT = 1 (READ NEW SECTOR)
077242           T:=100000                             % SET BAD TRACK BIT IN COMMAND
077243           GO FAR WDACT                          % TRY TO READ FAILING SECTOR WITH BAD TRACK BIT SET
077244

077244   % ROUTINE TO DO RETURN TO ZERO SEEK       ------------------------------
077244
077244   RETZ:   IF A:=RTZFL><0 GO FAR HDERR      % RECALIBRATE ALREADY DONE ?
077247           0=:BADTR=:SEEKF=:SHEAD=:BADIP    % RESET BAD TRACK FLAG
077253           A:=TRG SHZ 10 SHZ -16 =:X        % UNIT INTO X
077257           0=:LCYLI(X)                      % CLEAR CYLINDER NO IN BASE FIELD
077260           IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESET RETRY COUNT
077264           T:=34000                         % RETURN TO ZERO SEEK, RECALIBRATE
077265           T=:RTZFL=:TRTZ                   % SET RECALIBRATE AND FLAG
077267           GO FAR WDACT                     % ACTIVATE
077270

077270   % ROUTINE TO GET ALTERNATIVE DISK ADDRESS ------------------------------
077270
077270   % ENTER HERE WHEN A SECTOR CONTAINING POINTERS TO THE ALTERNATIVE TRACK
077270   % IS READ CORRECT
077270   % PICK UP THE POINTER TO THE ALTERNATIVE TRACK FROM THE FIRST WORD IN THE MEMORY BUFFER
077270   % FIND THE CYLINDER PART OF THE POINTER. SUBTRACT IT FROM THE CURRENT CYLINDER (LCYLI)
077270   % THE DIFFERENCE (NO. CYLINDERS TO SEEK) IS WRITTEN OUT AS WORD COUNT.
077270   % STORE THE NEW CYLINDER NO. IN LCYLI.
077270   % FIND THE ALTERNATIVE TRACK'S HEAD NO., AND STORE IT IN SHEAD.
077270
077270   DBAD:   T:=2; X:=WNLBB; *LDATX         % TO ENSURE NOT HIT IN CACHE
077273           T:=WNLBA;       *LDATX
077275           T:=A                           % T <== ALTERNATIVE DISK CYL. ADDR.
077276           A:=TRG SHZ 10 SHZ -16=:X       % UNIT NO. IN X
077302           A:=T ; AD SHZ -5               % HEAD INTO UPPER 5 BITS OF D, CYLINDER IN A
077304           A-LCYLI(X)                     % A <== NO. OF CYL'S TO GO
077305   *WORD3, IOXIN LWOR
077306           T SHZ -5 =:LCYLI(X)            % NEW CYL. ADDR. AFTER THIS SEEK
077310           A:=0 ; AD SHZ 5 ; A=:SHEAD     % HEAD TO USE ON ALT TRACK
077313           A:=-1=:SEEKF                   % SET SEEK FLAG
077315           0=:BADTR                       % RESET BAD TRACK FLAG
077316           T:=60000                       % SEEK COMMAND
077317           GO FAR WDACT                   % ACTIVATE
077320
077320   *)FILL
077327

077327   % ROUTINE TO SEEK ON DISK ---------------------------------------------
077327
077327   INTEGER TEMPX
077330
077330   DSEEK:  0=:TRTZ                        % RESET RECALIBRATE FLAG
077331           A:=DRG=:D
077333           A:=TRG/\300 SHZ 3 BONE 4
077337   *CONT5, IOXIN LCON                     % DEVICE CLEAR
077340   *CONT6, IOXIN LCON                     % DEVICE CLEAR
077341           A:=ARG
077342           X-1;D+X;IF C THEN A+1;FI; X+1  % AD= LAST LOGICAL DISK ADDR.
077350           T:=WSECY ; * RDIV ST % A<= CYL. NO.    D<= NO. OF SEC'S IN LAST CYL
077352           IF A>>T:=WMXCY GO FAR LAOUR    % GO IF WANTED LOGICAL ADDRES>MAX LOGICAL ADDRESS
077355           X=:TEMPX
077356           T:=TRG SHZ 10 SHZ-16=:X        % UNIT NO. IN X
077362           T:=LCYLI(X)
077363           A=:LCYLI(X)
077364           X:=TEMPX
077365           A-T ; * BLDC 170 DA            % SAVE SEEK DIRECTION IN K
077367           IF A<0 THEN A:=A- FI           % NEGATIVE STEP COUNT
077371   *WORD1, IOXIN LWOR                     % LOAD WORD COUNT WITH TRACK DIFFERENCE
077372           A=:SSTEP
077373           A:=0 ; T:=WSECT ; * RDIV ST    % A<= HEAD NO.     D<= NO. OF SEC'S ON LAST TRACK
077376           A=:SHEAD
077377           A:=D+1=:SSEC
077401           IF A:=SSTEP><0
077402              THEN                        % IF NOT ON CORR. CYL
077403                A=:SEEKF                  % SET SEEK FLAG
077404                T:=20000 ; * BSTA 160 DT  % STEP COMMAND INCLUDE DIRECTION
077406                GO WDACT                  % ACTIVATE
077407          FI
077407          GO RWDIS
077410   *)FILL
077413

077413   % MOD. EARLY/LATE-STROBE BIT IN CONTR.REG
077413   ELTE:  T:=3; 0=:D
077415          IF ERRC1 /\ T = T THEN
077421             D BONE STREARLY
077422          ELSE IF T-1 = A   THEN
077426             D BONE STRLATE
077427          FI FI
077427          IF D BIT STREARLY OR BIT STRLATE THEN
077433            MIN ELCOU; A /\ A                   % COUNT SETTING EARLY/LATE STROBE
077435          ELSE
077436            MIN NOCOU; A /\ A                   % COUNT SETTING NOMINEL STROBE
077440          FI
077440          TRG BZERO STREARLY BZERO STRLATE \/D=:TRG
077445
077445   % ROUTINE TO READ OR WRITE ON DISK -----------------------------------
077445   RWDIS:  0=:SEEKF                                 % RESET SEEK FLAG
077446           T:=SSEC=:D
077450           IF X<<T THEN T:=X FI                     % IF WHOLE TRANSFER WITHIN THIS TRACK THEN T<= NO. OF SEC'S TO TRANSFER
077453           T=:NOSEC
077454           X-T=:XRG                                 % X<= REMAINING SECTORS
077456           D-T                                      % D<= FIRST SECTOR
077457           A:=TRG SHZ 10 SHZ -16=:X                 % UNIT NO. IN X
077463           A:=LCYLI(X) SHZ 5 \/D                    % SHIFT CYLINDER ADDR. TO CORR. POSITION COMBINE CYL. & SEC. ADDRESS
077466   *DAD1,  IOXIN LDAD
077467           A=:SVLBB
077470           A:=WSECW ; X:=XRG ; * RMPY SA DX         % AD<= REMAINING WORDCOUNT
077473           A:=:D+CMAD2:=:D
077476           A:=A+C+CMAD1
077500   *LMAR1, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, UPPER PART
077501           A=:WANKN
077502           IF A-400>=0 GO MORER                     % MEMORY OUT OF RANGE
077504           A:=D
077505   *LMAR2, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, LOWER PART
077506           A=:SVLCA
077507           A:=T*WSECW                               % A<= WORDCOUNT
077511   *WORD2, IOXIN LWOR
077512           A=:SVLWC
077513           A:=3/\TRG SHZ 13 =:T                     % FUNCTION CODE IN T
077517
077517
077517   % ROUTINE TO CREATE CONTROLWORD FOR ACTIVATION -----------------------
077517
077517   WDACT:  A:=SHEAD SHZ 5   ; T\/A        % SHIFT HEAD NO. TO CORR. POSITION
077522           A:=TRG/\142000
077524           A\/BADIP ; T\/A
077526           A:=TRG SHZ 3/\3000\/T+5        % + UNIT NO. + ACTIVATE & INT. ENABLE
077533   *CONT3, IOXIN LCON
077534           A=:SVLCO
077535   INTEGER STAT3:=IOXIN+RSTA
077536           IF A NBIT ACTIV GO CNACT       % ERROR, NOT BUSY
077540           A=:BUSFL
077541   WBUSY:  TAD:=TADRG ; X:=XRG
077543           GO RETUR                       % BUSY EXIT
077544   *)FILL
077547

077547   % FINISHED & ERROR EXITS ----------------------------------------------
077547
077547   DFIN:   T:=TRG
077550           L+1 ; GO WFINI                       % FINISHED EXIT
077552
077552   MORER:  T:=1   ; GO DERR                     % ATTEMPT TO USE BANK NO. >>377.         BIT  8
077554   MEMER:  T:=4   ; GO DERR                     % CORE ADDRESS REGISTER NOT AS EXPECTED  BIT 10
077556   LAOUR:  T:=10  ; GO DERR                     % LOGICAL ADDRESS OUTSIDE DICE DEVICE    BIT 11
077560   DILLC:  T:=100 ; GO DERR                     % ILLEGAL CODE                           BIT 14
077562   CNACT:  T:=200 ; GO DERR                     % CONTROLLER NOT ACTIVE AFTER ACTIVATE   BIT 15
077564   HDERR:  T:=0                                 % HARDWARE ERROR NO ADDITIONAL STATUS
077565
077565   DERR:   L-1                                  % ERROR RETURN
077566           T SHZ 10                             % GET THE ADDITIONAL STATUS
077567           A:=TRG/\377 ; T\/A
077572   WFINI:  X:=SSTAT
077573           IF IRETR >=0 THEN -5 FI;A=:ERRC1
077577           0=:BUSFL
077600   RETUR:  EXITA                                % GENERAL EXIT
077601   RBUS
077603
077603   *)KILL LDAD  RSTA LCON LWOR
077603   *)KILL SATAD WSECW WSECY ACTIV ICERR ADDMI ONCYL TEST
077603   *)KILL WSECT WMXCY RMAR1 RMAR2 CONT1 STAT2 CONT4
077603   *)KILL DAD2  DAD3  LMAR3 LMAR4 WORD4 WORD3 WORD1 DAD1  LMAR1 LMAR2
077603   *)KILL WORD2 CONT3 DISDE CONT2
077603   *)KILL CONT5 CONT6
077603   *)KILL STREA STRLA
077603
077603   *"8ZWDI -8WDIS
"077603   *"8WDIM; 8WDIM=0
"077603
077603   @DEV 1
077603   @EOF
077603

077603  "8BDIS+8BDIM+8ZBDI
077603

077603
077603  %==============================================================================
077603  % 43.5       B D I S K                 VERSION A      26/11-81    CORR. BY TP
077603  %                                      VERSION B      30/12-81    CORR. BY TP
077603  %                                      VERSION C.6    16/ 4-82    CORR. BY TP
077603  %                                      VERSION D       6/10-82    CORR. BY TP
077603  %                                      VERSION E      10/11-82    CORR. BY TP
077603  %                                      VERSION E.1    29/ 3-83    CORR. BY TP
077603  %                                      VERSION E.2    31/ 8-83    CORR. BY TP
077603  %                                      VERSION E.3    26/ 9-83    CORR. BY TP
077603  %                                      VERSION E.4    19/ 3-84    CORR. BY TP
077603  %                                      VERSION F.0     2/ 4-84    CORR. BY TP
077603  %                                      VERSION F.1     3/ 5-84    CORR. BY TP
077603  %                                      VERSION F.2    26/ 6-84    CORR. BY TP
077603  %                                      VERSION F.3     7/ 8-84    CORR. BY TP
077603  %                                      VERSION F.4     3/ 9-84    CORR. BY TP
077603  %                                      VERSION F.5    19/ 9-84    CORR. BY TP
077603  %                                      VERSION F.6     6/11-84    CORR. BY TP
077603  %                                      VERSION F.7    15/11-84    CORR. BY TP
077603  %                                      VERSION G.0    20/ 3-85    CORR. BY TP
077603  %                                      VERSION G.1     8/ 5-85    CORR. BY TP
077603  %                                      VERSION G.2    21/ 5-85    CORR. BY TP
077603  %                                      VERSION G.3    17/ 6-85    CORR. BY TP
077603  %                                      VERSION G.4    16/ 9-85    CORR. BY TP
077603  %                                      VERSION G.5    12/12-85    CORR. BY TP
077603  %                                      VERSION G.6    28/ 4-86    CORR. BY TP
077603  %                                      VERSION G.7    23/ 6-86    CORR. BY TP
077603  %                                      VERSION G.8    19/ 8-86    CORR. BY TP
077603  %                                      VERSION G.9     4/11-86    CORR. BY TP
077603  %                                      VERSION G.A    20/ 5-87    CORR. BY TP
077603  %
077603  %   SUPER DISK (AND ECC CARTRIDGE DISKS) TRANSFER ROUTINE
077603  %
077603  %            THERE ARE 3 VERSIONS OF THE DRIVER, ACCORDING TO LIBRARY MARKS:
077603  %
077603  %                            8BDIS = NORMAL SINTRAN DRIVER
077603  %                            8BDIM = TEST PROGRAM DRIVER
077603  %                            8ZBDI = SWAP DRIVER (READ ONLY)
077603  %
077603  %      8BDIS AND 8BDIM
077603  %
077603  %            THE ARRAY ',B HTABL' MUST BE CORRECT (SEE BELOW).
077603  %
077603  %      8BDIS
077603  %
077603  %            THE DISC-DESCRIBING TABLES ARE EXTERNAL (SEE BELOW).
077603  %
077603  %      8ZBDI
077603  %
077603  %            THE CORRECT DEVICE DESCRIPTOR IS GENERATED AT ASSEMBLY TIME!!!
077603  %            PLDWO AND PSTWO WILL NOT WORK FOR N10.
077603  %
077603  %      FOR ALL:
077603  %
077603  %            IF THE ROUTINES 'PLDWO' AND 'PSTWO' ARE UNDEFINED, THEY WILL
077603  %            BE INCLUDED AFTER THE DRIVER!!!
077603  %            FOR N10, PAGING MUST BE OFF WHEN PLDWO AND PSTWO ARE ENTERED
077603  %            (USED BY ERROR CORRECTION). NOT FOR 8ZBDI. SEE 8ZBDI ABOVE.
077603  %            ERROR CORRECTION ASSUMES THAT THE CPU CAN REACH ALL THE MEMORY
077603  %            ACCESSIBLE TO THE DISK.
077603  %
077603  %
077603  "8ZBDI -8BDIS
077603  %
077603  %     CALL:
077603  %     JPL I (ZBDIS
077603  %     JMP   ERROR           %ERROR EXIT
077603  %     JMP   BUSY            % BUSY EXIT
077603  %     JMP   FINIS           %FINISHED EXIT
077603  %
077603  "8ZBDI+8BDIS+8BDIM
077603  %
077603  %     REGISTER CONTENTS WHEN ROUTINE IS CALLED
077603  %
077603  %     T-  BIT 0-5:  DEVICE OPERATION  (FOR 8ZBDI, READ ONLY)
077603  %                    0 READ TRANSFER
077603  %                    1 WRITE TRANSFER
077603  %                    2 READ PARITY TRANSFER
077603  %                    3 COMPARE TRANSFER
077603  %                   20 READ LAST STATUS
077603  %                   35 RELEASE              (NOT FOR THE SWAP DRIVER)
077603  %                    6 PRIORITY-SELECT      (NOT FOR THE SWAP DRIVER)
077603  %                   37 THIS FUNCTION BELONGS TO FUNCTION 42 AND IS STARTED
077603  %                      BY THE DRIVER. IT SHOULD NOT BE USED IN A CALL.
077603  %                   42 TEST IF SPARE TRACKS AND IF SPARE SECTOR FORMAT.
077603  %                      (NOT FOR THE SWAP DRIVER).
077603  %                      IT IS ASSUMED THAT NO OF SECTORS IN X IS 1 AND THAT
077603  %                      SECTOR NUMBER (LOGICAL DISK ADDR) IN AD IS 0 (EXCEPT
077603  %                      THE FIXED BIT IN D 017) WHEN THIS FUNCTION CALLS THE
077603  %                      DRIVER THE FIRST TIME.
077603  %                   43 READ  FORMAT TABLE (NOT FOR THE SWAP DRIVER)
077603  %                   44 WRITE FORMAT TABLE (NOT FOR THE SWAP DRIVER)
077603  %        BIT 6-8:   UNIT SELECT
077603  %        BIT 9-11:          SURFACE NUMBER FOR PHOENIX DISK
077603  %        BIT 12-13: CORE ADDRESS BITS 16-17 (N10)
077603  %        BIT 14:    DEVICE TYPE
077603  %                           1= 30/60/90 MBYTE
077603  %                           0= ANY OTHER TYPE
077603  %
077603  %        BIT 15:    0: NORMAL TRANSFER
077603  %                   1: BIT 6 IS ADDED TO THE SECTOR NUMBER
077603  %                      (USED TO READ SPARE TRACKS. ONLY POSSIBLE FOR
077603  %                      THE LIBRARY MARK 8BDIM).
077603  %
077603  %     A- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 16-31
077603  %
077603  %     D- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 0-15
077603  %                           LOGICAL ADDRESS BIT 15 MEANS ANY FIXED
077603  %                           SURFACE FOR CARTRIDGE DISK
077603  %
077603  %     X- NUMBER OF SECTORS TO BE TRANSFERED
077603  %
077603  %       ****  ,B MEMAD CONTAINS THE 24-BIT MEMORY ADRESS
077603  %                      IN A DOUBLE WORD.
077603  %       ****  ,B HDEV  CONTAINS HARDWARE DEVICE NUMBER
077603  %
077603  "8ZBDI+8BDIS+8BDIM
077603  %
077603  %      DISC LAYOUT DEFINITION:
077603  %
077603  %                             WORD 0 (BSECW) = WORDS/SECTOR
077603  %                                  1 (BSECT) = SECTORS/TRACK
077603  %                                  2 (BSECY) = SECTORS/CYLINDER
077603  %                                  3 (BMXCY) = MAXIMUM VALUE OF CYLINDER
077603  %                                  4           FIRST CYL OF SPARE TRACK AREA
077603  %                                  5           FORMAT IN ECC CONTROL WORD
077603  %                                  6           FIRST CYL OF EXTRA AREA
077603  %                                  7           POINTER TO RELATED LAYOUT
077603  %
077603  %     EXIT INFORMATION:
077603  %
077603  %     ERROR EXIT: X- HARDWARE STATUS REG.
077603  %                 T- BIT  9: SEEK ERROR. RETURN TO ZERO SEEK HAS BEEN DONE.
077603  %                    BIT 10: CORE ADDR. REG NOT AS EXPECTED
077603  %                    BIT 11: LOG. BLOCK ADDR. OUT OF RANGE, OR
077603  %                            TRANSFER BIGGER THAN 63.5K
077603  %                    BIT 12: DATA CORRECTION INFORMATION ERROR
077603  %                    BIT 13: DRIVE TYPE DEFINITION ERROR
077603  %                    BIT 14: ILL. DEVICE OP. CODE
077603  %                    BIT 15: CONTROLLER NOT ACTIVE AFTER ACTIVATE
077603  %     EVERY TIME THE DRIVER ERROR EXITS, IT STORES 11 WORDS AT THE END OF
077603  %     THE CODE. THESE WORDS, THEREFORE, WILL CONTAIN SIGNIFICANT INFORMATION
077603  %     ABOUT THE LAST ERROR THAT OCCURED. THE ADDRESS OF THIS FIELD CAN BE
077603  %     FOUND IN BDISK+2.
077603  %
077603  %     BUSY EXIT:     THE ROUTINE MUST BE CALLED AGAIN AT ONCE, OR
077603  %                    AFTER INTERRUPT. THE NEW CALL IS DONE WITH T,A,D AND
077603  %                    X-REG. UNCHANGED.
077603  %
077603  %     FINISHED EXIT: X-HARDWARE STATUS REG.
077603  %                    WITH FUNCTION 042, X WILL BE:
077603  %                    0: NOT SPARE TRACKS, NOT SPARE SECTOR FORMAT
077603  %                    1:     SPARE TRACKS, NOT SPARE SECTOR FORMAT
077603  %                    2: NOT SPARE TRACKS,     SPARE SECTOR FORMAT
077603  %                    3:     SPARE TRACKS,     SPARE SECTOR FORMAT
077603  %
077603  %     B-REG. IS NOT CHANGED BY THE ROUTINE
077603  %
077603  %       THE ROUTINE CONVERTS LOGICAL (SECTOR NUMBER) ADDR. (LA)
077603  %       TO HARDWARE (CYLINDER/HEAD/SECTOR) ADDR. (HA)
077603  %       ACCORDING TO TABLE HTABL FOR THE CORRESPONDING UNIT.
077603  %
077603  %     **** THE NUMBER OF SECTORS FOR THE VARIOUS DISK PACKS, AND THE ACTUAL TABLE NAMES:
077603  %
077603  %          37 MB =  110176                    : DT037
077603  %          70 MB =  220526                    : DT070
077603  %          75 MB =  220526                    : DT075
077603  %         135 MB =  421206                    : DT135   SPARE SECTOR FORMAT
077603  %         140 MB =  441254                    : DT140
077603  %         160 MB =  441254                    : DT160
077603  %         288 MB = 1045572                    : DT288
077603  %         285 MB = 1066450                    : DT285   SPARE SECTOR FORMAT
077603  %         300 MB = 1127720                    : DT300
077603  %         450 MB = 1542420                    : DT450   SPARE SECTOR FORMAT
077603  %         460 MB = 1603760                    : DT460
077603  %
077603  %          30 MB = 0034736 FOR EACH SURFACE   : DT030
077603  %          60 MB = 0034736 FOR EACH SURFACE   : DT030
077603  %          90 MB = 0034736 FOR EACH SURFACE   : DT030
077603  %
077603  %
077603  %        WHEN CALLING, THE LOGICAL ADDR. IN AD MUST
077603  %        BE REPRESENTED AS AN UNSIGNED MAGNITUDE NUMBER.
077603  %
077603  %
077603  %        THE SECTORS WITHIN THE LAST CYLINDER ARE TRANSFERED
077603  %        FIRST, THEN THE SECTORS WITHIN THE PREVIOUS CYLINDER ETC....
077603  %        FOR THE OLD INTERFACE (10 KHZ), WITHIN ONE CYLINDER,
077603  %        THE GREATEST SINGLE TRANSFER IS  64K-BSECW, WHERE BSECW IS NUMBER
077603  %        OF WORDS PER SECTOR (THE WORD COUNT REGISTER HAS ONLY 16 BITS).
077603  %        FOR THE NEW INTERFACE (15KHZ), STILL WITHIN ONE CYLINDER,
077603  %        THE GREATEST SINGLE TRANSFER CAN BE A WHOLE CYLINDER, SINCE
077603  %        THE WORD COUNT REGISTER HAS 24 BITS.
077603  %
077603  %     DISPLACEMENTS FOR IOX INSTRUCTIONS:
077603  %
077603         RCA=0                 % READ CORE ADDRESS
077603         LCA=1                 % LOAD CORE ADDRESS
077603         RSC=2                 % READ SEEK CONDITION / ECC COUNT
077603         LBA=3                 % LOAD BLOCK ADDRESS  I/II
077603         RSR=4                 % READ STATUS REG / ECC PATTERN
077603         LCO=5                 % LOAD CONTROL WORD
077603         LWC=7                 % LOAD WORD COUNT / ECC CONTROL
077603       INIOX=165540            % INITIAL IOX INSTRUCTION
077603
077603  % THE DISK DRIVER MAY BE CALLED WITH 11 DIFFERENT DEVICE OPERATIONS.
077603  % IN THE FOLLOWING, READ, READ PARITY, AND COMPARE, ARE CALLED NON-WRITE.
077603  % THE WRITE OPERATION IS CALLED WRITE. THE READ-STATUS OPERATION IS QUITE
077603  % SPECIAL. IT IS REALLY A READ-LAST-STATUS OPERATION, AS IT WILL READ
077603  % LAST STATUS FROM THE VARIABLE SSTAT. IT WILL ALSO INITIATE THE DISK DATA
077603  % FIELD VARIABLES BUSFL, ECCFL, MARGC, AND SMARG BY STORING ZERO INTO THEM,
077603  % AND BY SETTING ERRC1 TO -4 AND ERRC2 TO -28.
077603  % THE TEST-IF-SPARE-TRACK OPERATION WILL BE EXECUTED FIRST AS A PARITY READ
077603  % FROM THE LAST POSSIBLE SECTOR ON THE FIRST TRACK, AND THEN AS A PARITY READ
077603  % FROM THE FIRST SECTOR IN THE SPARE TRACK AREA. IT IS NOT FOR THE SWAP DRIVER.
077603  % RELEASE AND PRIORITY-SELECT ARE NOT FOR THE SWAP DRIVER EITHER. THEY ARE
077603  % USED WHEN MORE THAN ONE CPU USE THE DISK.
077603  %
077603  % ***** THE READ-STATUS OPERATION SHOULD NOT BE USED WHEN BUSFL IS NONZERO.****
077603  %
077603  % IF THE DISK DRIVER IS CALLED WITH READ-ZERO-SECTORS, THE STATUS REGISTER
077603  % WILL BE READ AND PUT IN THE X REGISTER, AND THE DISK DRIVER WILL EXIT
077603  % AT THE FINISHED EXIT. IF NOT-ON-CYLINDER (STATUS BIT 14),
077603  % THE DISK DRIVER WILL EXIT AT THE ERROR EXIT.
077603  %
077603  %
077603  % THE VARIABLES IN THE DISK DATA FIELD USED BY THE DISK DRIVER:
077603  %
077603  % ARG
077603  %
077603  % USED TO SAVE THE VALUE OF THE A-REGISTER AT ENTRY.
077603  %
077603  % BMXCY
077603  %
077603  % (BMXCY=BSECW+3)
077603  % MAX CYLINDER NUMBER. THIS IS THE LAST (PHYSICAL) CYLINDER NUMBER ON THE DISK.
077603  %
077603  % BSECT
077603  %
077603  % (BSECT=BSECW+1)
077603  % NUMBER OF SECTORS PER TRACK.
077603  %
077603  % BSECW
077603  %
077603  % NUMBER OF WORDS PER SECTOR.
077603  %
077603  % BSECY
077603  %
077603  % (BSECY=BSECW+2)
077603  % NUMBER OF SECTORS PER CYLINDER.
077603  %
077603  % BTSTA
077603  %
077603  % THE MAIN PART OF THE DISK CONTROL WORD.
077603  %
077603  % BUSFL
077603  %
077603  % BUSY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
077603  % MUST BE ZERO THE FIRST TIME THE DISK DRIVER IS CALLED. THE DISK DRIVER
077603  % WILL SET BUSFL TO NONZERO WHEN A TRANSFER IS STARTED, AND WILL SET IT BACK
077603  % TO ZERO WHEN A TRANSFER IS FINISHED, OR WHEN IT ERROR EXITS.
077603  % NEW (15/11-84, VERSION F.7):
077603  % WHEN THE DISK DRIVER WANTS TO ERROR EXIT UNDER SINTRAN, IT FIRST DOES A BUSY
077603  % EXIT AFTER THE RETURN-TO-ZERO SEEK HAS BEEN STARTED, WITH BUSFL:=STATUS.
077603  % WHEN THE INTERRUPT OCCURS, STATUS IS RESET (STATUS:=BUSFL), AND ERROR EXIT.
077603  %
077603  % CDISP
077603  %
077603  % USED FOR ECC COUNT AND SECTOR WORD NUMBER.
077603  % WHEN THE DISK DRIVER TRIES TO DO ERROR CORRECTION ON A SECTOR, IT READS
077603  % THE ECC COUNT AND STORES IT IN CDISP. IF 1 < CDISP < 8204, IT IS CHANGED
077603  % INTO A SECTOR WORD NUMBER IN THE RANGE 0-0777, POINTING TO A DOUBLE WORD
077603  % IN THE SECTOR THAT MAY BE CHANGED, DEPENDING ON THE ECC PATTERN (SEE
077603  % CPAT1 AND CPAT2). IF ERROR CORRECTION HAS TAKEN PLACE (SEE CORCU), THEN
077603  % IT IS POSSIBLE FOR THE CALLING PROGRAM TO KNOW WHERE THE CORRECTION TOOK
077603  % PLACE, BY INSPECTING CDISP.
077603  %
077603  % CMAD1
077603  %
077603  % POINTS TO THE FIRST WORD OF A DOUBLE WORD CONTAINING CURRENT MEMORY ADDRESS.
077603  % THE CURRENT MEMORY ADDRESS IS THE MEMORY ADDRESS USED BY THE DRIVER
077603  % WHEN IT STARTS A TRANSFER. IT IS NOT NECESSARILY EQUAL TO THE MEMORY
077603  % ADDRESS SUPPLIED IN THE CALL (SEE MEMA1, MEMA2).
077603  % IF THE DISK DRIVER BREAKS A TRANSFER INTO SMALLER TRANSFERS, FOR INSTANCE,
077603  % IT HAS TO CALCULATE A NEW MEMORY ADDRESS AND STORE IT IN CMAD1 AND CMAD2.
077603  %
077603  % CMAD2
077603  %
077603  % POINTS TO THE SECOND WORD OF A DOUBLE MEMORY ADDRESS. SEE CMAD1.
077603  %
077603  % CORCU
077603  %
077603  % CORRECTION COUNTER. EVERY TIME THAT ERROR CORRECTION OCCURS,
077603  % CORCU IS INCREMENTED BY 1. ERROR CORRECTION IS ALWAYS DONE ON SINGLE SECTORS.
077603  % THE NOT-WRITE RETRY COUNTER (SEE SRTRY) IS USUALLY ALSO INCREMENTED (ONCE
077603  % FOR EACH SECTOR IN THE TRANSFER) WHEN CORCU IS INCREMENTED.
077603  % CORCU IS INCREMENTED ON READ AND PARITY-CHECK OPERATIONS.
077603  % THE FAILING BITS CAN BE IN THE DATA PART AND/OR IN THE ECC POLYNOMIAL.
077603  %
077603  % CPAT1
077603  %
077603  % WHEN THE DISK DRIVER WANTS TO DO ERROR CORRECTION, IT READS THE ELEVEN BITS
077603  % OF THE ECC PATTERN, INVERTS THE BIT ORDER (SWAPS BIT 0 AND 10, BIT 1 AND 9,
077603  % ETC.), AND STORES IT TEMPORARILY IN CPAT1. CPAT1 SHOULD NOT BE ZERO.
077603  % THEN CPAT1 IS SHIFTED ACCORDING TO THE LEAST SIGNIFICANT BITS OF THE ECC
077603  % COUNT IN CDISP. THE RESULT IS STORED IN CPAT1 AND CPAT2, READY TO BE
077603  % EXCLUSIVE OR'ED INTO THE SECTOR JUST READ.
077603  %
077603  % CPAT2
077603  %
077603  % SEE CPAT1.
077603  % ALSO USED TO SAVE TRG WHILE WAITING FOR ON-CYL AFTER RETURN-TO-ZERO SEEK.
077603  %
077603  %
077603  % DED01 ==> DED13
077603  % IS USED
077603  % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
077603  % DED01  THE 11-WORD FIELD GOES FROM DED01 TO DED13.
077603  %
077603  % DRG
077603  %
077603  % USED TO SAVE THE VALUE OF THE D-REGISTER AT ENTRY.
077603  %
077603  % ECCFL
077603  %
077603  % RUN-ECC OPERATION FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
077603  % THIS FLAG IS USUALLY ZERO, BUT WHEN THE DISK DRIVER WANTS TO DO ERROR
077603  % CORRECTION, IT SETS ECCFL TO NONZERO AND STARTS THE RUN-ECC OPERATION.
077603  % WHEN RUN-ECC IS FINISHED, ECCFL IS SET BACK TO ZERO.
077603  % ECCFL IS SET TO ZERO AT THE ERROR EXIT AND THE FINISHED EXIT.
077603  %
077603  % ERRC1
077603  %
077603  % ERROR COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK DRIVER IS CALLED
077603  % THE FIRST TIME, ERRC1 USUALLY SHOULD HAVE THE VALUE -4. A FAILING WRITE
077603  % TRANSFER WILL THEN BE RETRIED THREE TIMES. IF THE CALLING PROGRAM WANTS
077603  % NOT TO HAVE WRITE RETRIES, IT SHOULD STORE -1 IN ERRC1 BEFORE CALLING
077603  % THE DISK DRIVER. FOR FAILING NOT-WRITE TRANSFERS, ERRC1 SHOULD BE HANDLED
077603  % IN THE SAME WAY, BUT THEN ERRC2 MUST ALSO BE TAKEN INTO ACCOUNT.
077603  % ERRC1 IS SET TO -4 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS
077603  % IN ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
077603  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
077603  %
077603  % ERRC2
077603  %
077603  % MARGINAL RECOVERY COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK
077603  % DRIVER IS CALLED THE FIRST TIME, ERRC2 USUALLY SHOULD HAVE THE VALUE -28.
077603  % A FAILING NOT-WRITE TRANSFER WILL FIRST DO SOME RETRIES ACCORDING TO THE
077603  % VALUE OF ERRC1. WHEN ERRC1 HAS BEEN COUNTED UP TO ZERO, THERE WILL BE NO
077603  % MORE ORDINARY RETRIES. INSTEAD, THE DISK DRIVER WILL TRY TO DO MARGINAL
077603  % RECOVERY CYCLES, ACCORDING TO THE VALUE OF ERRC2. IT WILL FIRST SET MARGC
077603  % NONZERO. USUALLY, THE DISK DRIVER WILL DO 27 MARGINAL RECOVERIES (THREE
077603  % FULL CYCLES). BUT IF THE CALLING PROGRAM SETS BOTH ERRC1 AND ERRC2 TO -1,
077603  % THE DISK DRIVER WILL DO NO ORDINARY RETRIES AND NO MARGINAL RECOVERY CYCLES.
077603  % ERRC2 IS SET TO -28 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS IN
077603  % ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
077603  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
077603  %
077603  % HDEV
077603  %
077603  % CONTAINS HARDWARE DEVICE NUMBER (01540 OR 01550).
077603  %
077603  % HTABL
077603  %
077603  % THERE ARE FOUR WORDS IN THE DATAFIELD (ONE FOR EACH UNIT), EACH POINTING TO
077603  % AN EIGHT-WORD DISK LAYOUT VECTOR. HTABL POINTS TO THE FIRST OF THE FOUR DATA
077603  % FIELD WORDS.
077603  %
077603  % MARGC
077603  %
077603  % MARGINAL RECOVERY FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
077603  % WHEN ALL THE ORDINARY NOT-WRITE RETRIES HAVE BEEN DONE (IF A TRANSFER FAILS),
077603  % THE MARGINAL RECOVERY BIT IN THE CONTROL WORD IS TURNED ON, MARGC IS SET
077603  % TO NONZERO, AND TYPEC IS INCREMENTED IN BIT 9.
077603  % MARGC IS SET TO ZERO WHEN THE DISK DRIVER IS IN ERROR RECOVERY
077603  % MODE (SEE SMARG), AND WHEN A TRANSFER IS FINISHED (BOTH OK EXIT AND ERROR
077603  % EXIT).
077603  %
077603  % MEMA1
077603  %
077603  % THE MOST SIGNIFICANT PART OF A DOUBLE WORD CONTAINING MEMORY ADDRESS.
077603  %
077603  % MEMA2
077603  %
077603  % THE LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS (SEE MEMA1).
077603  %
077603  % NWLBA
077603  %
077603  % LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS OF NEW CYLINDER NUMBER, AND
077603  % NEW SURFACE AND SECTOR. USED WHEN SPARE TRACK ALLOCATION IS ACTIVE.
077603  % A TRACK THAT IS FLAGGED AS A BAD TRACK, CONTAINS THE ADDRESS OF THE
077603  % RESERVE TRACK IN EVERY DOUBLE WORD. THE FIRST PART OF THE DOUBLE WORD
077603  % CONTAINS THE NEW CYLINDER NUMBER, AND THE SECOND PART CONTAINS THE NEW
077603  % SURFACE NUMBER IN THE LEFTMOST 8 BITS, AND THE SECTOR NUMBER IN THE
077603  % RIGHTMOST 8 BITS. THIS SECTOR NUMBER IS IRRELEVANT, AS THE OLD SECTOR
077603  % NUMBER (THE SECTOR NUMBER IN THE ORIGINAL DISK TRANSFER) IS USED INSTEAD.
077603  % NWLBA MUST BE NWLBB+1. (*****)
077603  %
077603  % NWLBB
077603  %
077603  % MOST SIGNIFICANT PART OF THE MEMORY ADDRESS OF
077603  % NEW CYLINDER NUMBER. SEE NWLBA. MUST BE NWLBA-1 !!
077603  %
077603  % OCMD1
077603  %
077603  % OLD COMPUTED MEMORY ADDRESS, BITS 23-16. USED TO SAVE THE MEMORY ADDRESS
077603  % OF A DISK TRANSFER DURING SPARE TRACK ALLOCATION.
077603  %
077603  % OCMD2
077603  %
077603  % OLD COMPUTED MEMORY ADDRESS, BITS 15-0. SEE OCMD1.
077603  %
077603  % OSVBA
077603  %
077603  % OLD SURFACE AND SECTOR. USED TO SAVE THE OLD VALUES OF THE DISK ADDRESS
077603  % DURING SPARE TRACK ALLOCATION.
077603  %
077603  % OSVBB
077603  %
077603  % OLD CYLINDER. SEE OSVBA.
077603  %
077603  % OSVCO
077603  %
077603  % OLD CONTROL WORD. USED TO SAVE THE OLD CONTROL WORD DURING SPARE TRACK
077603  % ALLOCATION.
077603  %
077603  % OSVWC
077603  %
077603  % OLD WORD COUNT, LEAST SIGNIFICANT 16 BITS.
077603  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
077603  %
077603  % OSVWK
077603  %
077603  % OLD WORD COUNT, MOST SIGNIFICANT 8 BITS.
077603  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
077603  %
077603  % SCADR
077603  %
077603  % THE LEAST SIGNIFICANT PART OF THE EXPECTED CORE ADDRESS REGISTER WHEN
077603  % A TRANSFER HAS FINISHED. IT IS COMPUTED BY THE DISK DRIVER (CMAD2+SVLWC).
077603  %
077603  % SLONG
077603  %
077603  % COUNTER FOR ERROR-RECOVERY (SEE SMARG). WHEN THE DISK DRIVER INITIATES
077603  % ERROR-RECOVERY MODE, SLONG IS SET TO 1-N, WHERE N IS THE NUMBER OF SECTORS
077603  % IN THE TRANSFER.
077603  %
077603  % SMARG
077603  %
077603  % ERROR-RECOVERY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
077603  % WHEN A NOT-WRITE TRANSFER FAILS, OR A WRITE GIVES DMA-ERROR,
077603  % THE DISK DRIVER INITIATES ERROR-RECOVERY BY SETTING SMARG TO NONZERO.
077603  % ERROR-RECOVERY MEANS THAT THE TRANSFER IS BROKEN INTO SINGLE-SECTOR TRANSFERS.
077603  % EACH OF THESE TRANSFERS IS THEN DONE AND CHECKED FOR ERRORS.
077603  % IF THE TRANSFER IS READ, AND IT FAILS, ERROR CORRECTION IS TRIED.
077603  % IF THIS FAILS, OR IF THE TRANSFER IS PARITY CHECK OR COMPARE,
077603  % THE USUAL RETRIES AND MARGINAL RECOVERIES ARE DONE.
077603  % SMARG IS SET TO ZERO WHEN A NEW TRANSFER IS STARTED, AND WHEN A TRANSFER
077603  % IS FINISHED (BOTH OK EXIT AND ERROR EXIT).
077603  %
077603  % SPACO
077603  %
077603  % SPARE TRACK ALLOCATION COUNTER. EVERY TIME A DISK TRANSFER HAS SUCCESSFULLY
077603  % USED A RESERVE TRACK, THIS COUNTER IS INCREMENTED BY ONE.
077603  %
077603  % SPAFL
077603  %
077603  % SPARE TRACK ALLOCATION FLAG.
077603  % 0:  NORMAL TRANSFER (NO SPARE TRACKS INVOLVED).
077603  % 1:  ADDRESS MISMATCH HAS OCCURED. SPARE TRACK ADDRESS-READ HAS BEEN STARTED.
077603  % 2:  TRANSFER IN THE SPARE TRACK AREA HAS BEEN STARTED.
077603  %
077603  % SRTRY
077603  %
077603  % NOT-WRITE RETRY COUNTER. IT IS INCREMENTED EVERY TIME AN ORDINARY NOT-WRITE
077603  % RETRY IS STARTED. MARGINAL RECOVERY CYCLE RETRIES ARE COUNTED IN TYPEC,
077603  % BITS 15-9, EVERY TIME MARGC IS SET NONZERO.
077603  %
077603  % SSTAT
077603  %
077603  % CURRENT DISK STATUS.
077603  %
077603  % SVLBA
077603  %
077603  % SAVED DISK ADDRESS (SURFACE AND SECTOR).
077603  %
077603  % SVLBB
077603  %
077603  % SAVED DISK ADDRESS (CYLINDER NUMBER).
077603  %
077603  % SVLCA
077603  %
077603  % SAVED LEAST SIGNIFICANT PART OF THE CURRENT MEMORY ADDRESS (EQUAL TO CMAD2).
077603  %
077603  % SVLCO
077603  %
077603  % SAVED CONTROL WORD, EXCEPT WHEN RUN-ECC OPERATION IS STARTED.
077603  %
077603  % SVLWC
077603  %
077603  % SAVED WORD COUNT, LEAST SIGNIFICANT 16 BITS (NUMBER OF SECTORS * BSECW).
077603  %
077603  % SVLWK
077603  %
077603  % SAVED WORD COUNT, MOST SIGNIFICANT 8 BITS (NUMBER OF SECTORS * BSECW).
077603  %
077603  % SWTRY
077603  %
077603  % WRITE RETRY COUNTER. SWTRY IS INCREMENTED BY ONE EACH TIME A WRITE TRANSFER
077603  % FAILS.
077603  %
077603  % TRG
077603  %
077603  % USED TO SAVE THE VALUE OF THE T-REGISTER AT ENTRY.
077603  %
077603  % TYPEC
077603  %
077603  % BIT   0:   1: ECC INTERFACE                 0: 33/66MB INTERFACE
077603  %       1:   1: HEAD ADVANCE                      0: NOT HEAD ADVANCE
077603  %       2:   1: ERROR CORRECTION NOT ALLOWED      0: ERROR CORRECTION ALLOWED
077603  %       3:   1: MARGINAL RECOVERY NOT ALLOWED     0: MARGINAL RECOVERY ALLOWED
077603  %       4:   1: HEAD ADVANCE NOT ALLOWED, UNIT 0  0: HEAD ADVANCE ALLOWED, UNIT 0
077603  %               (SPARE TRACK ALLOC. ALLOWED)         (NO SPARE TRACK ALLOCATION)
077603  %       5:   1: DITTO FOR UNIT 1                  0: DITTO FOR UNIT 1
077603  %       6:   1: DITTO FOR UNIT 2                  0: DITTO FOR UNIT 2
077603  %       7:   1: DITTO FOR UNIT 3                  0: DITTO FOR UNIT 3
077603  %       8:   1: AUTOMATIC RELEASE NOT ALLOWED     0: ALLOWED
077603  %       9:   1: NEW (15 KHZ) INTERFACE            0: OLD (10 KHZ) INTERFACE
077603  %   15-10:   MARG. REC. COUNTER (INCREMENTED EACH TIME MARGC IS SET NONZERO)
077603  %
077603  %    BITS 0 AND 1 ARE SET INSIDE THE DISK DRIVER.
077603  %    BITS 2, 3, AND 4-7 ARE SET BY THE CALLING PROGRAM.
077603  %           BITS 4-7 CAN ALSO BE SET BY THE FUNCTION TEST-IF-SPARE-TRACK (042)
077603  %    BIT  8 IS SET BY THE FUNCTION PRIORITY-SELECT, AND RESET BY THE FUNCTION
077603  %           RELEASE. IT MAY ALSO BE SET/RESET BY THE CALLING PROGRAM.
077603  %    BIT  9 IS SET INSIDE THE DISK DRIVER.
077603  %
077603  % XRG
077603  %
077603  % USED TO SAVE THE VALUE OF THE X-REGISTER AT ENTRY.
077603  %
077603  % 9LREG
077603  %
077603  % USED TO SAVE THE VALUE OF THE L-REGISTER.
077603  %
077603
077603  "8BDIM+8BDIS+8ZBDI
077603
077603  % DEFINITION OF EXTENSION TO DISK DATA FIELD
077603
077603  BSECW=DED01                  % WORDS/SECTOR
077603  BSECT=DED02                  % SECTORS/TRACK
077603  BSECY=DED03                  % SECTORS/CYLINDER
077603  BMXCY=DED04                  % MAX CYLINDER VALUE
077603                               % FIRST CYL NO OF THE SPARE TRACK AREA
077603                               % FORMAT (0 OR 020)
077603                               % FIRST CYLINDER OF EXTRA AREA
077603                               % POINTER TO RELATED LAYOUT
077603  9LREG=DED11                  % SAVED L-REG
077603  SSTAT=DED12                  % CURRENT DISK ADDRESS
077603  BTSTA=DED13                  % MAIN PART OF CURRENT DISK CONTROL WORD
077603
077603  "8ZBDI -8BDIS
077603
077603  ZBDIS=*
077603         STF   TRG ,B
077604         STX   XRG ,B
077605
077605  "8ZBDI+8BDIS+8BDIM
077605
077605         JMP   BRCHK
077606
077606  )FILL
077606
077606  BRCHK, COPY  SL DA           % SAVE L
077607         STA   9LREG ,B
077610
077610  "8ZBDI+8BDIS+8BDIM
077610
077610         SAA   77
077611         AND   TRG ,B
077612
077612  "8ZBDI -8BDIS
077612
077612         JAZ   L41             % THE ONLY LEGAL OPCODE IS 0
077613
077613  "8BDIS+8BDIM+8ZBDI
077613
077613         JMP I (ILCOD          % ILL. DEVICE OP. CODE
077614  L41,   LDA   TRG ,B
077615         AND   (0700           % MASK FOR UNIT ADDRESS BITS.
077616         SHA   ZIN  1          % SHIFT TO POSITION FOR CWR.
077617         STA   BTSTA ,B        % STORE VALUE
077620         LDA   SVLCO,B         % GET LAST COMMAND
077621         AND   (16000          % MASK FOR WRITE AND COMPARE BIT, AND MARG.REC. BIT
077622         ADD   BTSTA ,B        % ADD TO NEW COMMAND IN ORDER NOT TO
077623         STA   BTSTA ,B        % REVERSE THE FIFO DIRECTION IN BLCOG
077624         LDA   BUSFL,B         % PREVIOUS X-FER TO BE CHECKED?
077625         JAF   BRSR1           % NO - ,CONTINUE
077626         STZ   SPAFL ,B        % RESET SPARE TRACK ALLOCATION FLAG
077627         LDA   BTSTA ,B
077630  BLCOG, INIOX LCO             % SET CWR15=0
077631  BRSR1, INIOX RSR             % READ STATUS
077632         BSKP  ZRO 20 DA       % CONTROLLER ACTIV?
077633  L39,   JMP I (EXBUS          % YES, BUSY EXIT
077634         LDA   BUSFL,B         % PREVIOUS TRANSFER TO BE CHECKED?
077635         JAF   BRSR2           % YES. SKIP UNIT SELECT
077636         LDA   TRG ,B
077637         AND   (0700
077640         SHA   ZIN 1
077641         JMP *+1               % BSET  ONE 30 DA (TEST MODE)
077642         JPL   BLCO1           % SELECT UNIT
077643  "8BDIS+8BDIM+8ZBDI
077643  BRSR2, INIOX RSR             % READ STATUS
077644         STA   SSTAT ,B        % SAVE IT
077645         BSKP  ONE 160 DA      % ON CYLINDER?
077646         JPL   ERKYL           % NO. PERHAPS ERROR
077647         LDA   BUSFL,B
077650         JAZ   L18             % ZERO: NO PREVIOUS TRANSFER. JUMP TO BCONT
077651         JMP   I *+1           % JUMP TO SPARE TRACK ALLOCATION HANDLER
077652         SPHAN
077653  L33,   LDA   SMARG,B         % ERROR RECOVERY CYCLE ?
077654         JAF   SECPR           % NONZERO: YES. JUMP TO SECTOR PROCESSING
077655         LDA   SSTAT ,B        % TEST STATUS
077656         AND   (037760
077657         JAF   BREX            % NONZERO: ERRORS IN THE PREVIOUS TRANSFER
077660         JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
077661         JMP I (ECADR
077662  L18,   JMP I (BCONT          % NO ERRORS, CONTINUE
077663
077663  BREX=*
077663
077663  "8BDIS+8BDIM+8ZBDI
077663
077663         LDA   TYPEC ,B        % IS ERROR CORRECTION ALLOWED ?
077664         BSKP  ZRO 020 DA
077665         JMP I (BRTRY          % NO
077666
077666  % PREPARE ERROR RECOVERY BY INITIATING SECTOR-BY-SECTOR PROCESSING
077666
077666  L45,   SAA   -1
077667         STA   SMARG,B         % SET SECTOR RECOVERY FLAG
077670         LDD   SVLWC-1 ,B      % GET LEAST WORD COUNT TO D-REG
077671         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
077672         LDX   BSECW ,B
077673         RDIV  SX              % CONVERT TO NUMBER OF SECTORS
077674         LDX   XRG ,B
077675         COPY  SA DA CM2
077676         COPY  SA DA AD1
077677         STA   SLONG,B         % STORE SECTOR CONTROL NUMBER
077700         LDA   BSECW ,B
077701         STA   SVLWC,B         % SET WORD COUNT TO ONE SECTOR
077702         STZ   SVLWK ,B
077703
077703  "8BDIS+8BDIM+8ZBDI
077703
077703         JMP I (BRTRY
077704
077704  "8BDIM+8BDIS+8ZBDI
077704
077704  ERKYL, LDA   BUSFL ,B
077705         JAZ   L22             % ZERO: NO PREVIOUS TRANSFER
077706         LDA   SVLCO ,B
077707         BSKP  ONE 0120 DA
077710         JMP   L22             % NOT MARGINAL RECOVERY
077711         LDA   SSTAT ,B        % A MARG. REC. TRANSFER FINISHED. IGNORE NOT-ON-CYL
077712         BSET  ONE 0160 DA
077713         STA   SSTAT ,B
077714         EXIT
077715  L22,   JMP   I (ERCYL
077716
077716  )FILL
077730
077730  BLCO1, INIOX LCO             % LOAD CONTROL WORD
077731         EXIT
077732

077732  % ERROR RECOVERY (SECTOR-BY-SECTOR PROCESSING)
077732  %
077732  SECPR, LDA   SSTAT ,B        % GET STATUS
077733         AND   (037760
077734         JAF   ERRAN           % NONZERO: ERROR DURING PREVIOUS TRANSFER
077735  L4,    JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
077736         JMP I (ECADR
077737         LDA   SLONG,B         % TEST SECTOR RETRY NUMBER
077740         JAP   L18             % POS: SECTOR RETRY COMPLETED. JUMP TO BCONT
077741         SAA   037
077742         AND   SVLBA ,B        % MASK OUT SECTOR BITS
077743         SUB   BSECT ,B        % SECTORS/TRACK
077744         AAA   1               % FIRST=0 NOT 1!!
077745         JAF   L10             % JUMP IF NOT LAST SECTOR ON TRACK
077746         LDA   SVLBA,B
077747         AND   (17400          % MASK FOR HEAD BITS
077750         ADD   (400            % INCR. HEAD ADDR.
077751         STA   SVLBA,B
077752         JMP   L11
077753  L10,   MIN   SVLBA,B         % INCREMENT SECTOR ADDRESS
077754  L11,   MIN   SLONG,B         % INCREMENT SECTOR CONTROL NUMBER
077755         0
077756         LDA   CMAD2,B
077757         ADD   BSECW ,B        % ADD ONE SECTOR
077760         STA   SVLCA,B         % NEW CORE ADDR.    (16 LOWER)
077761         STA   CMAD2,B
077762         LDA   CMAD1,B
077763         COPY  SA DA ADC
077764         STA   CMAD1,B         % NEW CORE ADDR.   (BANK BITS)
077765         JPL I (BQERR          % SUCCESSFULL SECTOR RETRY. RESET ERROR COUNTERS
077766         STZ   MARGC,B         % RESET MARGINAL CYCLE FLAG
077767         LDA   SVLCO,B
077770         BSET  ZRO 120 DA
077771         STA   SVLCO,B         % RESET COMMAND WORD
077772         AND   (017600
077773         STA   BTSTA ,B
077774
077774  "8BDIS+8BDIM+8ZBDI
077774
077774         JMP I (BRTRY
077775

077775  % PREPARE FOR ERROR CORRECTION (CHECK IF CONDITIONS ARE FAVORABLE)
077775  %
077775  ERRAN=*
077775
077775  "8BDIS+8BDIM+8ZBDI
077775
077775  L24,   LDA   SSTAT ,B        % GET STATUS
077776         BSKP  ONE 110 DA      % SKIP IF DATA ERROR
077777         JMP   RETRY           % IF NOT --RETRY.
100000         AND   (036740         % MASK FOR ALL ERRORS (OTHERS)
100001         JAF   RETRY           % JUMP TO RETRY IF ANY ERRORS
100002  BRSC5, INIOX RSC             % READ SEEK CONDITION
100003         BSKP  ZRO 170 DA      % SKIP IF NOT ADDRESS FIELD
100004         JMP   RETRY           % ADDRESS FIELD,-GO TO RETRY
100005         COPY  SA DT           % SAVE SEEK CONDITION
100006         LDA   ECCFL,B         % IS ECC OP. FLAG SET?
100007         JAZ   RECOP           % JUMP IF FLAG NOT SET
100010         BSKP  ZRO 150 DT      % SKIP IF MAX ECC COUNT
100011         JMP   ECCOP           % CORRECTABLE !
100012         STZ   ECCFL,B         % PREPARE FOR RETRY
100013         LDA   BTSTA ,B
100014         BSET  ONE 170 DA
100015         JPL   BLCO1           % SET CWR15=1.
100016  BRSC3, INIOX RSC             % READ ECC COUNT
100017         SUB   (20071          % COUNT SHOULD BE =8249
100020         JAF   ERREC
100021  RETRY, JPL I (RESEC          % RESET ECC
100022         JMP I (BRTRY          % MARGINAL RECOVERY CYCLE EXIT
100023  RECOP, SAA   -1
100024         STA   ECCFL,B
100025         LDA   BTSTA ,B
100026         BSET  ZRO 0140 DA     % REMOVE BIT 12 IF PARITY CHECK
100027         ADD   (40005          % SET CWR14=0,ACTIVATE,ENBL.INTRPT.
100030         JPL   BLCO1           % START ECC-OP.
100031         JMP I (EXBUS
100032
100032  )FILL
100047

100047  % ERROR CORRECTION
100047  %
100047  ECCOP, STZ   ECCFL,B         % ECCFL:=0
100050         LDA   BTSTA ,B
100051         BSET  ONE 170 DA
100052         JPL   BLCO1           % SET CWR15=1.
100053  BRSR4, INIOX RSR             % READ ECC PATTERN
100054         SAT   -13
100055         STT   CDISP ,B
100056         SAT   0
100057         JMP   L2              % START PATTERN MIRRORING
100060  L1,    SHA   SHR 1
100061         SHT   ZIN 1
100062  L2,    BSKP  ZRO 0 DA
100063         BSET  ONE 0 DT
100064         MIN   CDISP ,B
100065         JMP   L1
100066         COPY  ST DA
100067         STA   CPAT1,B         % STORE PATTERN TEMPORARILY
100070         JAZ   ERREC
100071  BRSC4, INIOX RSC             % READ ECC COUNT ( 2-020001 FOR BIT IN SECTOR)
100072         JAN   ERREC
100073         STA   CDISP ,B        % SAVE ECC COUNT
100074         AAA   -2
100075         JAN   ERREC           % NEG: COUNT < 2
100076         SUB   K8191
100077         AAA   -071
100100         JAP   ERREC           % POS: COUNT > 8249
100101         AAA   056
100102         JAP   AYPAS           % POS: COUNT > 8203.  DATA ALREADY OK
100103         LDA   BTSTA ,B
100104         JPL   BLCO1           % SET CWR15=0.
100105         LDA   CDISP ,B        % ECC COUNT
100106         AAA   -014
100107         RCLR  DL              % L:=0
100110         JAP   L6
100111         RINC  DL              % L:=1
100112         AAA   012             % WORDNO MUST NOT BE NEGATIVE
100113  L6,    SAD   SHR 4
100114         STA   CDISP ,B        % WORDNO IN SECTOR
100115         SAA   0
100116         SAD   4
100117         COPY  SA DD
100120         SAA   0105
100121         SKP   DL EQL 0
100122         AAA   012             % BECAUSE OF WORDNO COMPENSATION ABOVE
100123         RSUB  SD DA
100124         ADD   SADIN           % SAD 0
100125         COPY  SA DX
100126         LDA   CPAT1 ,B        % ECC PATTERN
100127         RCLR  DD
100130         EXR   SX              % SHIFT PATTERN
100131         STA   CPAT1 ,B        % SAVE CORRECTION PATTERNS
100132         COPY  SD DA
100133         STA   CPAT2 ,B
100134
100134  "8BDIM+8BDIS+8ZBDI
100134
100134         LDD   CMAD1-1 ,B      % CMAD1 TO D
100135         LDA   CDISP ,B        % WORDNO IN SECTOR
100136         ADD   CMAD2 ,B
100137         SWAP  SA DD
100140         COPY  SA ADC DA
100141         STD   ADSAV           % SAVE CORRECTION ADDR
100142         LDX   CPAT1 ,B        % PATTERN 1
100143         JXZ   L5
100144
100144  "8ZBDI -8BDIS
100144
100144         EXAM                  % GET DATA
100145
100145  "8BDIM+8BDIS+8ZBDI
100145
100145         REXO  SX DT           % CORRECT DATA
100146
100146  "8ZBDI -8BDIS
100146
100146         DEPO
100147
100147  "8BDIM+8BDIS+8ZBDI
100147
100147  L5,    LDD   ADSAV           % 24-BIT ADRESS
100150         RINC  DD
100151         COPY  ADC SA DA
100152         STD   ADSAV           % SAVE NEXT 24 BIT ADRESS
100153         LDX   CDISP ,B        % WORDNO IN SECTOR
100154         AAX   1
100155         BSKP  ZRO 0110 DX
100156         JMP   AYPAS           % WORDNO IS 01000.  DONT CORRECT
100157         LDX   CPAT2 ,B        % PATTERN 2
100160         JXZ   AYPAS
100161
100161  "8ZBDI -8BDIS
100161
100161         EXAM                  % NEXT DATA WORD
100162
100162  "8BDIM+8BDIS+8ZBDI
100162
100162         REXO  SX DT           % CORRECT DATA
100163
100163  "8ZBDI -8BDIS
100163
100163         DEPO
100164
100164  "8BDIM+8BDIS+8ZBDI
100164
100164  AYPAS, MIN   CORCU ,B        % INCREASE CORRECTION COUNTER
100165         0
100166         LDA   SSTAT ,B        % REMOVE DATA ERROR BIT FROM STATUS
100167         AND   (176757
100170         STA   SSTAT ,B
100171         LDD   ARG ,B          % RESET AD
100172         LDX   XRG ,B
100173         JPL I (RESEC          % RESET ECC
100174         JMP I (L4
100175
100175  ERREC, JMP I (ERREB          % JUMP-HELP
100176
100176  K8191, 017777
100177  SADIN, SAD   0
100200  ADSAV, 0; 0
100202
100202  )FILL
100206

100206  % TRY AGAIN AFTER ERROR (NOT WRITE)
100206  %
100206  BRTRY, LDA   MARGC,B         % MARC. REC. CYCLE FLAG ALREADY SET?
100207         JAF   BMARG           % NONZERO: YES
100210         STZ   ECCFL,B         % RESET ECC PROCESSING FLAG
100211         MIN   ERRC1,B         % ORDINARY RETRIES DONE?
100212         JMP   L12             % NO. TRY ONCE MORE
100213         LDA   TYPEC ,B        % MARG REC ALLOWED ?
100214         BSKP  ZRO 030 DA
100215         JMP I (ERR            % NO
100216         ADD   (02000          % INCREMENT MARG REC COUNTER (BITS 15-10)
100217         STA   TYPEC ,B
100220         SAA   -1
100221         STA   MARGC,B         % SET MARG REC. CYCLE FLAG
100222         LDA   SVLCO,B
100223         BSET  ONE 120 DA      % SET BIT 10 IN CONTROL WORD(MARG. REC.)
100224         STA   SVLCO ,B
100225         AND   (017600
100226         STA   BTSTA ,B
100227  BMARG, MIN   ERRC2,B         % ALL MARG. REC.'S DONE?
100230         JMP   BOM
100231         JMP I (ERR            % 3 MARG. REC. CYCLES DONE. ERROR
100232  L12,   MIN   SRTRY ,B
100233         0
100234  %
100234  % TRANSFER ROUTINE
100234  %
100234  BOM,   LDA   BTSTA ,B
100235  "8BDIM+8BDIS+8ZBDI
100235         JPL   BLCOF           % CWR 15:=0
100236         SAA   -0100
100237         SHA   3
100240         STA   CPAT1 ,B        % TEMPORARILY USED FOR TIMEOUT
100241  BRSR8, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
100242         BSKP  ZRO 0160 DA
100243         JMP   L58             % ON-CYL
100244         MIN   CPAT1 ,B
100245         JMP   BRSR8
100246  L58,   LDA   SVLBA,B         % HEAD AND SECTOR
100247
100247  "8BDIS+8BDIM+8ZBDI
100247
100247  BLBA1, INIOX LBA             % LOAD HEAD AND SECTOR
100250         LDA   BTSTA ,B
100251         BSET  ONE 170 DA
100252         JPL   BLCOF           % CWR 15:=1
100253         LDA   SVLBB,B
100254
100254  "8BDIS+8BDIM+8ZBDI
100254
100254  BLBA3, INIOX LBA             % LOAD CYLINDER ADDRESS
100255         JPL I (RESEC          % RESET ECC.  SET CWR15:=0
100256         LDA   CMAD1,B
100257  BLCA1, INIOX LCA             % LOAD BANK NO
100260         LDA   CMAD2,B
100261  BLCA3, INIOX LCA             % LOAD MEMORY ADDR WITHIN BANK
100262         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
100263  BLWC2, INIOX LWC
100264         LDA   SVLWC,B
100265  BLWC1, INIOX LWC             % LOAD WORD COUNT
100266         LDA   SVLCO,B
100267         JPL   BLCOF           % START TRANSFER
100270  BRSR3, INIOX RSR             % READ STATUS
100271         STA   SSTAT ,B
100272         BSKP  ONE 20 DA       % CONTROLLER ACTIVE ?
100273         JMP I (ERACT          % NO
100274         LDA   SVLWC ,B        % WORD COUNT
100275         ADD   CMAD2 ,B        % LEAST SIGN. PART OF MEMORY ADDR
100276         STA   SCADR ,B        % EXP. LEAST SIGN. PART OF THE CORE ADDR REG
100277  EXBUS, SAA   -1
100300  EXBU2, STA   BUSFL,B         % SET BUSY FLAG
100301         LDA   9LREG ,B
100302         COPY  SA DL
100303         LDF   TRG ,B
100304         EXIT  AD1             % BUSY EXIT!!!
100305
100305  )FILL
100312

100312  % START A NEW TRANSFER WHEN X IS NONZERO
100312  %
100312  BCONT, SKP   IF DX UEQ 0
100313         JMP I (FINEX          % ALL BLOCKS TRANSFERED
100314         STZ   SMARG,B
100315  BRSC6, INIOX RSC             % READ SEEK COND.
100316         COPY  SA DT
100317         LDA   BTSTA ,B
100320         BSET  ONE 170 DA
100321         JPL   BLCOF           % SET CWR 15 =1.
100322         LDA   TYPEC ,B
100323         COPY  SA DL
100324         BSET  ONE 0110 DL     % BIT FOR 15KHZ INTERFACE
100325  BRSR5, INIOX RSR             % READ ECC PATTERN
100326         AND   (174000         % MASK FOR BITS 11-15 OF A-REG.
100327         SUB   (134000
100330         JAZ   NEWIE           % ZERO: 15KHZ INTERFACE
100331         BSET  ZRO 0110 DL
100332         BSET  ZRO 0160 DA
100333         JAZ   NEWIE           % ZERO: 10 KHZ INTERFACE
100334         JMP I (ERTYP          % ERROR.
100335  %
100335  % DECIDE IF HEAD-ADVANCE SHOULD BE USED
100335  %
100335  NEWIE, COPY  SL DA
100336         STA   TYPEC ,B
100337         COPY  AD1 DL          % L:=1
100340
100340  "8BDIS+8BDIM+8ZBDI
100340
100340  L19,   SAA   -4
100341         AND   TYPEC ,B        % REMOVE BITS 1-0 FROM TYPEC
100342         RADD  SL DA
100343         STA   TYPEC ,B        % 1 OR 3 IN BITS 1-0
100344  %
100344  % COMPUTE THE BLOCK ADDRESS OF THE LAST BLOCK (SECTOR) IN THE TRANSFER
100344  %
100344         LDA   ARG ,B          % MOST SIGN. OF LOG. DISK ADDR
100345         LDT   TRG ,B
100346         BSKP  ONE 0160 DT     % PHOENIX DISK ?
100347         JMP   XY              % NO
100350         BLDA  170 DD          % SAVE FIXED/REMOV INDICATOR IN K
100351         BSET  ZRO 170 DD
100352         SAT   0
100353         BSET  BAC 140 DT      % SURFACE ALWAYS 20+N FOR FIXED DISK
100354         STT   SAVT
100355         JMP   XY
100356
100356  SAVT,  0
100357
100357  )FILL
100363  K7000, 07000
100364
100364  BLCOF, INIOX LCO             % LOAD CONTROL WORD
100365         EXIT
100366
100366  XY,    AAX   -1
100367         RADD  SX DD
100370         COPY  SA ADC DA       % ADDR OF LAST SECTOR NOW IN AD
100371         AAX   1
100372         LDT   BSECY ,B        % SECTORS/CYL
100373         SKP   DA MLST ST
100374         JMP   L40             % CYL > MAX CYL
100375         RDIV  ST
100376         LDT   BMXCY ,B
100377         SKP   DT MGRE SA
100400  L40,   JMP I (ILAD           % CYLINDER > MAX CYLINDER
100401         STA   SVLBB,B         % SAVE CYLINDER ARGUMENT
100402         COPY  SD DA AD1
100403         STA   HESEC           % 0 < HESEC <= BSECY
100404         SKP   DX GRE SA       % CHECK IF TRANSFER IS GREATER THAN 63.5K
100405         COPY  SX DA
100406         LDT   BSECW ,B        % A IS NO. OF SECTORS IN TRANSFER
100407         RMPY  ST DA
100410         JAZ   L20             % ZERO: LESS THAN 64K
100411         SWAP  SA DD
100412         RADD  ST DA
100413         RADD  ADC CM1 DD
100414         SWAP  SA DD
100415         RDIV  ST              % AFTER THIS, A HOLDS NUMBER OF SURPLUS SECTORS
100416         LDT   TYPEC ,B
100417         BSKP  ZRO 0110 DT
100420         SAA   0               % 15 KHZ INTERFACE. ALLOW MORE THAN 63.5K
100421  L20,   COPY  SA DL           % SAVE IT IN L FOR A LITTLE WHILE
100422         LDA   HESEC
100423         COPY  SA DD
100424  %
100424  % COMPUTE SURFACE AND SECTOR NUMBER
100424  %
100424         LDA   TYPEC,B
100425         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
100426         JMP   L14
100427         COPY  SX DA
100430         SKP   IF DA LST SD    % SKIP IF WHOLE TRANSFER WITHIN CYLINDER
100431         COPY  SD DA
100432         RSUB  SA DD
100433         RADD  SL DD           % SURPLUS SECTORS
100434         JMP   L23
100435  L14,   RDCR  DD
100436  L23,   SAA   0
100437         LDT   BSECT ,B        % GET SECTORS/TRACK
100440         RDIV  ST              % A:=SURFACE NO.
100441         COPY  SD DT           % D&T=NUMBER OF SECTORS IN LAST CYLINDER
100442         SHA   ZIN  10         % SURFACE IN LEFT BYTE
100443         RADD  SA DD           % MERGE SURFACE AND SECTOR
100444         AAT   1               % NO. OF SECTORS IN LAST CYLINDER
100445         LDA   TRG ,B
100446         BSKP  ONE 160 DA      % IF CARTRIDGE DISK
100447         JMP   NOTPH
100450         AND   K7000           % MASK FOR SURFACE (LA BIT 16-18)
100451         SHA   ZIN SHR 1       % MOVE TO BIT 8-10
100452         ADD   SAVT            % ADD SECTOR AND FIXED/REMOVABLE SURFACE FLAG
100453         ADD   HESEC
100454         AAA   -1
100455         COPY  SA DD
100456         AND   (03400
100457         JAZ   NOTPH           % ZERO: SURFACE 0 OR 020
100460         BSKP  ONE 0140 DD
100461         JMP   L40             % REMOVABLE, AND SURFACE # 0 !!
100462  NOTPH, LDA   TYPEC,B
100463         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
100464         JMP   L15
100465         COPY  SD DA
100466         JMP   L3
100467  L15,   SKP   IF DX GRE ST
100470         COPY  SX DT           % T: NO. OF SECTORS TO TRANSFER
100471         COPY  SD DA AD1
100472         RSUB  ST DA           % A: HARDWARE BLOCK ADR.
100473  L3,    STA   SVLBA,B         % SAVE HEAD AND SECTOR
100474  %
100474  % DECREMENT X
100474  %
100474         LDA   TYPEC,B
100475         BSKP  ONE 10 DA
100476         JMP   L7              % JUMP IF NOT HEAD ADVANCE
100477         LDT   HESEC           % LOAD HEAD + SECTOR
100500         SKP   IF DX GRE ST
100501         COPY  SX DT
100502         RSUB  SL DT           % SURPLUS SECTORS
100503  L7,    RSUB  ST DX           % X: NO. OF BLOCKS LEFT TO THE NEXT TRANSFER
100504         STX   XRG ,B
100505  %
100505  % X IS NOW NO. OF BLOCKS TO BE TRANSFERRED NEXT TIME.
100505  % T IS NOW NO. OF BLOCKS TO TRANSFER THIS TIME.
100505  % COMPUTE SVLCA, CMAD1, CMAD2, SVLWC.
100505  %
100505         LDA   BSECW ,B
100506         RMPY  SX DA           % AD: X*BSECW=NO. OF WORDS LEFT
100507         SWAP  SA DD
100510         ADD   MEMA2 ,B
100511         COPY  SD ADC DD
100512         STA   SVLCA ,B
100513         SWAP  SA DD
100514         ADD   MEMA1 ,B
100515         STD   CMAD1 ,B
100516         LDA   BSECW ,B
100517         RMPY  ST DA           % AD: T*BSECW=NO. OF WORDS TO TRANSFER
100520         STA   SVLWK ,B        % SAVE MOST SIGN WORD COUNT
100521         COPY  SD DA
100522         STA   SVLWC,B         % SAVE WORD COUNT
100523  %
100523  % PREPARE BTSTA AND THE CONTROL WORD (SVLCO)
100523  %
100523  "8BDIS+8BDIM+8ZBDI
100523
100523         LDA   TRG ,B
100524         AND   K0700
100525         SHA   ZIN 1           % UNIT NO
100526
100526  "8BDIS+8BDIM+8ZBDI
100526
100526         STA   BTSTA ,B
100527         AAA   5               % ACTIVATE & ENABLE INTERRUPT
100530         STA   SVLCO,B         % SAVE CONTROL WORD
100531
100531  "8BDIS+8BDIM+8ZBDI
100531
100531  L42,   JMP I (BOM            % JUMP TO TRANSFER ROUTINE
100532
100532  )FILL
100535  K0700, 0700
100536  HESEC, 0
100537

100537  % THIS IS THE FINISHED-AND-OK EXIT
100537  %
100537  FINEX, LDX   SSTAT ,B
100540         JPL   BQERR           % RESET ERROR COUNTERS
100541         STZ   ECCFL,B
100542         STZ   SMARG,B
100543         STZ   MARGC,B
100544         STZ   BUSFL,B
100545         STZ   SPAFL ,B
100546
100546  "8BDIS+8BDIM+8ZBDI
100546
100546         LDA   9LREG ,B
100547         COPY  SA AD1 DL
100550         LDF   TRG ,B
100551         EXIT  AD1             % FINISHED EXIT
100552  %
100552  % RESET-ECC SUBROUTINE
100552  %
100552  RESEC, LDA   BTSTA ,B
100553         BSET  ONE 170 DA
100554  BLCOH, INIOX LCO             % SET CWR15 = 1
100555         SAA   1
100556         ADD   BMXCY+2 ,B
100557  BLWC3, INIOX LWC             % RESET ECC
100560         LDA   BTSTA ,B
100561  BLCO8, INIOX LCO             % SET CWR15=0.
100562         EXIT
100563  %
100563  % READ-AND-CHECK THE CORE ADDR REG
100563  %
100563  BRSR6, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
100564
100564  "8BDIS+8BDIM+8ZBDI
100564
100564  BRCA,  INIOX RCA             % READ CORE ADDR. REG
100565         STA   DRIAR
100566         SUB   SCADR,B
100567         JAF   L37             % NONZERO: CORE ADDR. REG NOT AS EXPECTED
100570         LDA   SVLWC ,B        % WORD COUNT
100571         ADD   CMAD2 ,B        % LEAST MEM ADDR
100572         LDA   CMAD1 ,B        % BANK NO
100573         COPY  SA ADC DA       % EXP. BANK NO
100574         ADD   SVLWK ,B        % MOST SIGN WORD COUNT
100575         STA   SAVBN
100576  BRCA2, INIOX RCA             % READ BANK NO
100577         AND   K0377
100600         SUB   SAVBN
100601         STA   SAVBN           % SAVE RESULT TEMP.
100602  BRSC1, INIOX RSC
100603         BSKP  ONE 0140 DA
100604  L38,   EXIT  AD1             % N10 INTERFACE, OR OK
100605         LDA   SAVBN
100606         JAZ   L38
100607  L37,   EXIT                  % BANK NO, OR ADDR, NOT AS EXPECTED
100610
100610  SAVBN, 0
100611  K0377, 0377
100612
100612  )FILL
100612
100612  % RESET ERROR COUNTERS
100612
100612  BQERR, SAA   -4
100613         STA   ERRC1 ,B
100614         SAA   -034
100615         STA   ERRC2 ,B
100616         EXIT
100617

100617  % BELOW FOLLOW THE DIFFERENT ERROR EXITS
100617  %
100617  ERACT, SAT   0100            % NOT ACTIVE AFTER ACTIVATE
100620         JMP   L9              % SET BIT 017 IN T
100621
100621  ILCOD, SAT   040             % ILLEGAL DEVICE OPERATION
100622         JMP   L9              % SET BIT 016 IN T
100623
100623  ERTYP, SAT   020             % CONTROLLER DEFINITION PROBLEM
100624         JMP   L9              % SET BIT 015 IN T
100625
100625  ERREB, SAT   010             % ECC PROBLEM
100626         JMP   L9              % SET BIT 014 IN T
100627
100627  ILAD, SAT   4                % LOGICAL DISK ADDR IS TOO BIG
100630         JMP   L9              % SET BIT 013 IN T
100631
100631  ECADR, SAT   2               % CORE ADDR REG ERROR. SET BIT 012 IN T
100632
100632  L9,    SHT   011             % SHIFT ERROR BIT TO CORRECT PLACE
100633         LDA   TRG ,B
100634         AND   BMASK
100635         RADD  SA DT
100636         SAA   0
100637         JPL   BLCO8           % CWR15:=0
100640  BRSC7, INIOX RSC
100641         STA   RSCON
100642         JPL   BQERR           % RESET ERROR COUNTERS
100643         JMP   ERREK
100644
100644  ERCYL, SAX   0               % NOT ON-CYLINDER
100645         JMP   L36             % CONTINUE WITH X=0
100646
100646  ERR,   SAX   -1              % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS
100647  L36,   JPL   BQERR           % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS ARE DONE
100650         LDA   TRG ,B
100651         AND   BMASK
100652         COPY  SA DT
100653  BRSC2, INIOX RSC
100654         STA   RSCON
100655         BSKP  ZRO 130 DA
100656         BSET  ONE 110 DT      % SEEK ERROR
100657         BSKP  ONE 130 DA
100660         JXZ   ERREK           % JUMP TO ERREK IF X=0 AND NOT SEEK ERROR
100661         LDA   TRG ,B
100662         AND   K0700
100663         SHA   ZIN 1
100664         AAA   20
100665  BLCO3, INIOX LCO             % DEVICE CLEAR
100666         ADD   (033775         % RETURN-TO-ZERO SEEK (TEST MODE)
100667         LDX   RSCON
100670         BSKP  ONE 0140 DX
100671         BSET  ZRO 030 DA      % N-10.  REMOVE TEST MODE
100672  BLCO4, INIOX LCO
100673
100673  "8BDIS+8BDIM+8ZBDI
100673
100673  ERREK, LDA   BTSTA ,B
100674         AAA   20
100675         JPL I (BLCOF          % CLEAR DEVICE
100676         STZ   BUSFL,B
100677         STZ   ECCFL,B
100700         STZ   SMARG,B
100701         STZ   MARGC,B
100702         STZ   SPAFL ,B
100703
100703  "8BDIS+8BDIM+8ZBDI
100703
100703         LDX   SSTAT ,B
100704
100704  "8BDIS+8BDIM+8ZBDI
100704
100704         LDA   ARG ,B
100705         JMP I 9LREG ,B        % EXIT
100706
100706  )FILL
100710
100710  BMASK, 0777
100711
100711  % BELOW FOLLOW 11 WORDS THAT CONTAIN ERROR INFORMATION ABOUT THE LAST ERROR.
100711  % THEY ARE STORED THERE WHEN THE DRIVER ERROR EXITS. PLEASE NOTE THAT THE
100711  % LOWER PART OF THE CORE ADDRESS REGISTER IS STORED IN DRIAR EVERY TIME THAT
100711  % REGISTER IS CHECKED, AND THIS IMPLIES THAT THE STATUS REGISTER MUST BE OK.
100711
100711  DRIAR, 0     % LOWER 16 BITS OF CORE ADDR REG AFTER TRANSFER (STATUS IS OK)
100712
100712  "8BDIM+8BDIS+8ZBDI
100712
100712  RSCON, 0     % SEEK CONDITION
100713
100713  "8BDIS+8BDIM+8ZBDI
100713

100713  % SPARE TRACK ALLOCATION HANDLER.
100713  % ACTIVATED WHEN A TRANSFER GIVES ADDRESS MISMATCH STATUS ERROR.
100713  % CHECKS BIT 4 IN TYPEC ,B TO SEE IF SPARE TRACK ALLOCATION IS ALLOWED.
100713  % THE SPARE TRACK ALLOCATION PARAMETERS (I.E. THE NEW CYLINDER AND SURFACE)
100713  % ARE READ FROM THE BAD TRACK, BY READING WITH THE SAME CYLINDER AND SURFACE
100713  % AS IN THE ORIGINAL ACCESS, BUT WITH SECTOR 0100, 0101, AND SO ON, UNTIL
100713  % TWO WORDS ARE READ CORRECTLY. THOSE TWO WORDS (CYLINDER AND SURFACE) ARE THEN
100713  % USED, TOGETHER WITH THE ORIGINAL SECTOR INCREMENTED BY 0100, TO ACCESS THE
100713  % SPARE TRACK.
100713
100713  SPHAN=*
100713
100713  "8BDIS+8BDIM+8ZBDI
100713
100713         LDA   SPAFL ,B        % THE SPARE TRACK ALLOCATION FLAG CAN BE 0/1/2
100714         JAF   L27
100715
100715  "8BDIS+8BDIM+8ZBDI
100715
100715         LDA   SSTAT ,B        % ADDRESS MISMATCH ?
100716         BSKP  ONE 0100 DA
100717         JMP I (L33            % NO
100720  BRSC8, INIOX RSC             % READ SEEK CONDITION
100721         BSKP  ZRO 0130 DA
100722         JMP   ERR             % SEEK ERROR
100723         SAA   1               % FLAG:=1
100724         STA   SPAFL ,B
100725         LDA   CMAD1 ,B        % SAVE PART OF THE DATA FIELD
100726         STA   OCMD1 ,B
100727         LDA   CMAD2 ,B
100730         STA   OCMD2 ,B
100731         LDA   SVLBA ,B
100732         STA   OSVBA ,B
100733         LDA   SVLBB ,B
100734         STA   OSVBB ,B
100735         LDA   SVLCO ,B
100736         STA   OSVCO ,B
100737         LDA   SVLWC ,B
100740         STA   OSVWC ,B
100741         LDA   SVLWK ,B
100742         STA   OSVWK ,B
100743         LDA   SVLBA ,B        % SET SECTOR 0100
100744         AND   (177400
100745         BSET  ONE 060 DA
100746         STA   SVLBA ,B
100747         LDA   SVLCO ,B        % PUT READ-OP IN CONTROL WORD
100750         AND   (163777
100751         STA   SVLCO ,B
100752         AND   (177740         % AND IN BTSTA
100753         STA   BTSTA ,B
100754  L26,   SAA   2
100755         STA   SVLWC ,B        % WORD COUNT := 2
100756         STZ   SVLWK ,B
100757         LDA   NWLBB ,B        % DMA-ADDR OF EXTRA PAGE
100760         STA   CMAD1 ,B        % MEMORY ADDR IN DATA FIELD
100761         LDA   NWLBA ,B
100762         STA   CMAD2 ,B        % NWLBB AND NWLBA
100763         JMP I (BOM            % TRANSFER
100764  L27,   AAA   -1
100765         JAF   L31             % NONZERO: SPAFL IS NOT 1
100766         LDA   SSTAT ,B        % STATUS ERROR ?
100767         AND   (017760
100770         JAF   L30             % NONZERO: YES. TRY NEXT SECTOR
100771         JPL I (BRSR6          % NO. CHECK THE CORE ADDR REG
100772         JMP   L30             % CORE ADDR REG ERROR
100773         STF   BQTAD           % SAVE T AND D
100774         LDD   NWLBB ,B
100775
100775  "8ZBDI -8BDIS
100775
100775         EXAM
100776         STT   BQTAD+3         % NEW CYL
100777         RINC  DD
101000         EXAM
101001
101001  "8BDIS+8BDIM+8ZBDI
101001
101001         STT   BQTAD+4         % NEW SURF/SECT
101002         LDF   BQTAD           % RESET T AND D
101003
101003  "8BDIS+8ZBDI
101003
101003         LDA   BQTAD+3         % CHECK THE NEW CYLINDER NUMBER
101004         JAN   L30             % NEG: ILLEGAL
101005
101005  "8BDIS+8BDIM+8ZBDI
101005
101005         SUB   BMXCY ,B
101006         AAA   -1
101007         JAP   L30             % POS: ILLEGAL
101010         LDA   TRG ,B
101011         BSKP  ZRO 0160 DA
101012         JMP   L28             % PHOENIX
101013         LDA   BQTAD+4         % CHECK THE NEW SURFACE
101014         JAN   L30             % NEG: ILLEGAL
101015         SHA   070
101016         AAA   1
101017         MPY   BSECT ,B
101020         SUB   BSECY ,B
101021         AAA   -1
101022         JAP   L30             % POS: ILLEGAL
101023         JMP   L29             % THE NEW CYL AND SURFACE OK (NOT PHOENIX)
101024
101024  )FILL
101033
101033  BQTAD, 0; 0; 0               % SAVED REGS
101036         0; 0                  % NEW DISK ADDR
101040
101040  L28,   LDA   BQTAD+4         % CHECK PHOENIX SURFACE
101041         JAN   L30             % NEG: ILLEGAL
101042         SHA   070
101043         JAZ   L29             % ZERO: OK
101044         AAA   -020
101045         JAN   L30             % NEG: ILLEGAL
101046         AAA   -5
101047         JAP   L30             % POS: ILLEGAL
101050  L29,   SAA   2               % FLAG:=2
101051         STA   SPAFL ,B
101052         LDA   OCMD1 ,B        % RESET DATA FIELD
101053         STA   CMAD1 ,B
101054         LDA   OCMD2 ,B
101055         STA   CMAD2 ,B
101056         LDA   OSVCO ,B
101057         STA   SVLCO ,B
101060         AND   (177740
101061         STA   BTSTA ,B
101062         LDA   OSVWC ,B
101063         STA   SVLWC ,B
101064         LDA   OSVWK ,B
101065         STA   SVLWK ,B
101066         LDA   BQTAD+3
101067         STA   SVLBB ,B        % NEW CYL
101070         LDA   BQTAD+4
101071         AND   (177400
101072         STA   BQTAD+4
101073         SAA   077
101074         AND   OSVBA ,B        % OLD SECTOR (+0100, OF COURSE)
101075         AAA   0100
101076         ADD   BQTAD+4         % NEW SURFACE
101077         STA   SVLBA ,B
101100         JMP I (BOM            % TRANSFER
101101  L30,   LDA   SVLBA ,B        % TRY NEXT SECTOR, IF POSSIBLE
101102         AAA   1
101103         STA   SVLBA ,B
101104         AND   (0377
101105         SUB   BSECT ,B
101106         AAA   -0100
101107         JAN   L26             % NEG: TRY NEXT
101110         LDA   OCMD1 ,B        % RESET DATA FIELD
101111         STA   CMAD1 ,B
101112         LDA   OCMD2 ,B
101113         STA   CMAD2 ,B
101114         LDA   OSVBA ,B
101115         STA   SVLBA ,B
101116         LDA   OSVBB ,B
101117         STA   SVLBB ,B
101120         LDA   OSVCO ,B
101121         STA   SVLCO ,B
101122         LDA   OSVWC ,B
101123         STA   SVLWC ,B
101124         LDA   OSVWK ,B
101125         STA   SVLWK ,B
101126         JMP I (ERR
101127  L31,   AAA   -1
101130         SKP   DA EQL 0
101131         JMP I (ERR            % SPAFL IS NOT 2
101132         LDA   SSTAT ,B
101133         AND   (017760
101134         JAF   L32             % NONZERO: STATUS ERROR
101135         JPL I (BRSR6          % CHECK THE CORE ADDR REG
101136         JMP I (ECADR          % ERROR
101137         LDA   OSVBA ,B        % RESET DISK ADDRS
101140         STA   SVLBA ,B
101141         LDA   OSVBB ,B
101142         STA   SVLBB ,B
101143         STZ   SPAFL ,B        % FLAG:=0
101144         MIN   SPACO ,B        % INCREMENT COUNTER
101145         0
101146  L32,   JMP I (L33            % BACK TO DRIVER
101147
101147  )FILL
101160
101160  "8ZBDI -8BDIS
101160
101160  )PCL ZBDIS
101160  )KILL RCA RSC LBA RSR LCO LWC LCA INIOX NOIOX
101160  )KILL BSECW BSECT BSECY BMXCY 9LREG SSTAT BTSTA
101160
101160  "8ZBDI -8BDIS
101160  )KILL 9ESWP; 9ESWP=*
101160  "
101160  )LINE
101160   SUBR WIDIS,ZWDIS
101160
101160   *"8WDIS+8WDIM+8ZWDI
"101160

101160   *)9SLPL
101160   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
101160   %                                                                                 %
101160   %   FILE NAME   : WINCHESTER:NPL                                                  %
101160   %   PROGRAM NO. : HUT-2475 A.6                                                    %
101160   %   ISSUED      : 82.02.18        BY: DG AND TP                                   %
101160   %                                                                                 %
101160   %   LAST CHANGED: 83.10.03        BY: MJH                                         %
101160   %   LAST CHANGED: 85.09.04        BY: KGT USE AD-REG FOR SECTOR ADDRESS           %
101160   %   LAST CHANGED: 86.01.29        BY: KGT CLEAR CACHE AFTER  SPARE TRACK IS READ  %
101160   %                                                                                 %
101160   % T R A N S F E R   R O U T I N E   F O R    8"   W I N C H E S T E R    D I S K  %
101160   %                                                                                 %
101160   % INCLUDING BAD TRACK REALLOCATION, BUT NO ERROR CORRECTION                       %
101160   %                                                                                 %
101160   %                                                                                 %
101160   %                                                                                 %
101160   % CALLING SEQUENCE:                                                               %
101160   %      JPL I (WIDIS          % OR  JPL I (ZWDIS  IF SWAP DRIVER                   %
101160   %      JMP   ERROR           % ERROR    EXIT                                      %
101160   %      JMP   BUSY            % BUSY     EXIT                                      %
101160   %      JMP   FINIS           % FINISHED EXIT                                      %
101160   %                                                                                 %
101160   % CALLING PARAMETERS:                                                             %
101160   %      X-REG = NUMBER OF SECTORS TO TRANSFER                                      %
101160   %      T-REG (BIT 0-5)  = FUNCTION CODE:                                          %
101160   %                          0 - READ                                               %
101160   %                          1 - WRITE                                              %
101160   %                          2 - READ PARITY                                        %
101160   %                          3 - COMPARE                                            %
101160   %                         20 - READ STATUS                                        %
101160   %                         42 - DUMMY
101160   %             BIT  6-7  = UNIT NUMBER                                             %
101160   %             BIT     8 = TRACK TEST                                              %
101160   %             BIT     9 = NOT USED                                                %
101160   %             BIT    10 = LATE DATA STROBE                                        %
101160   %             BIT 11-13 = NOT USED                                                %
101160   %             BIT    14 = EARLY DATA STROBE                                       %
101160   %             BIT    15 = BAD TRACK                                               %
101160   %      AD-REG = SECTOR ADDRESS (LOGICAL)                                          %
101160   %                                                                                 %
101160   %      THE MEMORY ADDRESS (24 BITS) IS FOUND IN THE DATAFIELD DOUBLE WORD CMAD1   %
101160   %                                                                     AND CMAD2   %
101160   %                                                                                 %
101160   %                                                                                 %
101160   % RETURN INFORMATION:                                                             %
101160   %      ERROR    EXIT: X = HARDWARE STATUS                                         %
101160   %      BUSY     EXIT: THE ROUTINE MUST BE CALLED AFTER INTERRUPT                  %
101160   %      FINISHED EXIT: X = HARDWARE STATUS                                         %
101160   %                                                                                 %
101160   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
101160
101160   *"8ZWDI -8WDIS
"101160
101160   ZWDIS: *JMP   WISTA
101161
101161   *"8WDIS+8WDIM
"101161
101161   SYMBOL ACTIV=2 , ICERR=4 , ADDMI=10 , ONCYL=16 , TEST=10
101161   SYMBOL STREARLY=16, STRLATE=12         % BIT IN CONTR. WORD TO SET READ STROBE
101161   @LIB 8WDIM
101161   % DATA FIELD VARIABLES USED BY THE DRIVER:
101161   % WNLBA -I   MEMORY ADDRESS USES TO READ REALOCATED TRACK POINTER
101161   % WNLBB -I   CONTAIN NORMALLY ADDRESS TO ALTPO
101161   % ADMIA      SAVED ADDR MISMATCH BLOCK ADDR
101161   % ADMIS      SAVED ADDR MISMATCH STATUS
101161   % ALTPO      ADDRESS OF ALTERNATIVE TRACK POINTER
101161   % BADDR      BAD ADDR
101161   % BADIP      BAD ADDR IN PROCESS (EXTRA ADDRESS BIT)
101161   % BADTR      BAD TRACK FLAG
101161   % BUSFL      BUSY FLAG
101161   % CMAD1      MEM ADDR
101161   % CMAD2       "   "
101161   % ERRC1      RETRY COUNTER
101161   % HDEV       DEVICE NUMBER (0500,0510)
101161   % HTABL(2)   DISK DESCRIPTOR TABLE
101161   % LCYLI(2)   LAST CYLINDER
101161   % NOSEC      NO. OF SECTORS IN TRANSFER
101161   % RTZFL      RETURN-TO-ZERO FLAG
101161   % SEEKF      SEEK FLAG
101161   % SHEAD      HEAD NO.
101161   % SSEC       NO. OF SECTORS IN LAST TRANSFER
101161   % SSTEP      SAVED LAST STEP COUNT
101161   % SVLBB      SAVED DISK ADDR (CYLINDER AND SECTOR)
101161   % SVLCA      SAVED LEAST MEM ADDR
101161   % SVLCO      SAVED CONTROL WORD
101161   % SVLWC      SAVED WORD COUNT
101161   % TRTZ       RETURN-TO-ZERO FLAG
101161   % WANKN      SAVED MOST MEM ADDR
101161   % DEDFA
101161   %
101161   % THIS DISPLACEMENT IS THE LAST BEFORE A 11-WORD FIELD (13B) WHICH IS USED
101161   % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
101161   % DEDFA+1. THE 11-WORD FIELD GOES FROM DEDFA+1 TO DEDFA+13.
101161

101161   INTEGER STAT1=?
101161   INTEGER STAT3=?
101161
101161   *"8WDIS+8WDIM+8ZWDI
"101161
101161   % DRIVER INITIALIZE ------------------------------------------------
101161
101161
101161   % IOX DISPLACEMENTS:
101161
101161   @LIB CXCPU-,
101161   SYMBOL RSEE=2       % READ SEEK CONDITION
101161   SYMBOL LDAD=3       % LOAD DISK   ADDRESS REGISTER
101161   SYMBOL RSTA=4       % READ HARDWARE STATUS
101161   SYMBOL LCON=5       % LOAD CONTROL WORD
101161   SYMBOL RDAD=6       % READ DISK ADDRESS REGISTER
101161   SYMBOL LWOR=7       % LOAD WORDCOUNT
101161   SYMBOL IOXIN=164500 % IOX 500 DISC SYSTEM 1
101161   SYMBOL IOXRR=164004 % IOX READ STATUS (WITHOUT DEV. NO)
101161
101161   %  @LIB 8WDIM-,
101161   % DEFINITION OF EXTENSION TO DISK DATA FIELD
101161
101161   DISP 0
101161     INTEGER WSECW=DED01                % WORDS/SECTOR
101161     INTEGER WSECT=DED02                % SECTORS/TRACK
101161     INTEGER WSECY=DED03                % SECTORS/CYLINDER
101161     TRIPLE DISDE=WSECW
101161     INTEGER WMXCY=DED04                % MAX CYLINDER VALUE
101161     INTEGER IRETR=DED05                % DRIVER RETRY COUNTER
101161     INTEGER SSTAT=DED06                % TEMP. HARDW. STATUS
101161     INTEGER ELCOU=DED07                % DRIVER RETRY COUNTER
101161     INTEGER NOCOU=DED10                % DRIVER RETRY COUNTER
101161   PSID
101161
101161   %  @ELIB
101161
101161   DISP 0 ; TRIPLE CDISD ; INTEGER CMAXC ; PSID   % DISC LAYOUT TABLE
101161
101161   *"8WDIM
"101161

101161   %        WDISC:
101161   %  >>>>>>>>>>>>V
101161   %              V
101161   %              V
101161   %   -----------V----------------- YES
101161   %   * IS IOX STAT1 OR IOX CONT4 >>>>>>>>>>>>>>>>>>>V
101161   %   * WRONG                     *                  V
101161   %   -----------V-----------------          --------V------------
101161   %              V NO                        * GENERATE AL IOX'S *
101161   %              V                           --------V------------
101161   %              V                                   V
101161   %              V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
101161   %              V
101161   %   -----------V---------------------
101161   %   * READ STATUS. SAVE IT IN SSTAT *
101161   %   -----------V---------------------
101161   %              V
101161   %         -----V---- YES
101161   %         * BUSY ? >>>>>>>> WBUSY:
101161   %         -----V----
101161   %              V NO
101161   %         -----V--------- YES
101161   %         * ON CYLINDER ? >>>>>>>> RETZ:
101161   %         -----V---------
101161   %              V NO
101161   %     NO  -----V-------- YES
101161   %    <<<<<< BUSFL><0 ? >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
101161   %    V    --------------                                  V
101161   %    V                                                    V
101161   %  --V-------------------------------------   ------------V------------
101161   %  * SELECT UNIT AND READ STATUS AND SAVE *   * INCLUSIVE OR OF ERROR * YES
101161   %  * RESET SEEKF, BADTR, RTZFL AND TRTZ   *   * IN STATUS ?           >>>>>>>> IERR:
101161   %  --V-------------------------------------   ------------V------------
101161   %    V                                                    V NO
101161   %    V                                             -------V----- YES
101161   %  --V-------------                                * TRTZ><0 ? >>>>>>>> DSEEK:
101161   %  * IS OPERATION *                                -------V-----
101161   %  * READ STATUS  * YES                                   V NO
101161   %  * (20) ?       >>>>>>>>>> DFIN:                 -------V------ YES
101161   %  --V-------------                                * SEEKF><O ? >>>>>>> RWDIS:
101161   %    V NO                                          -------V------
101161   %  --V-------------                                       V NO
101161   %  * IS OPERATION * YES                         ----------V-------------- NO
101161   %  * >=4 ?        >>>>>>> DILLC:                * MAR=OLDMAR+OLDWORDC ? >>>>>>> MEMER:
101161   %  --V-------------                             ----------V--------------
101161   %    V NO                                                 V YES
101161   %    V                                                ----V--------- YES
101161   %    V                                                * BADTR><0 ? >>>>>>>> DBAD:
101161   %    V                                                ----V---------
101161   %    V                                                    V NO
101161   %    V>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<V
101161   %                     V
101161   %                 ----V---- YES
101161   %                 * X=0 ? >>>>>>> DFIN:
101161   %                 ----V----
101161   %                     V NO
101161   %                     V>>>>>>>>>> DSEEK:
101161

101161   WISTA: TAD=:TADRG ; X=:XRG             % SAVE T,A,D,X
101163
101163   *"8WDIS+8WDIM
"101163          A:=HDEV=:T                      % SAVE HDEV IN T-REGISTER
101165          *1BANK
101166          IF A+IOXRR-STAT1><0 THEN  % TEST FIRST IOX, IF NOT INITIALIZED THEN DO SO
101171               A:=T   +IOXRR  ; * STA    STAT1; STA    STAT2;  STA I (STAT3
101176               A+"LDAD-RSTA"  ; * STA I (DAD1 ; STA I (DAD3
101201               A+"RDAD-LDAD"  ; * STA I (DAD2
101203               A+"LOMAR-RDAD" ; * STA I (LMAR1; STA I (LMAR2; STA I (LMAR3; STA I (LMAR4
101210               A+"LCON-LOMAR" ; * STA    CONT1; STA    CONT2; STA I (CONT3; STA    CONT4; STA I (CONT5; STA I (CONT6
101217               A+"LWOR-LCON"  ; * STA I (WORD1; STA I (WORD2; STA I (WORD3; STA I (WORD4
101224               A+"REMAR-LWOR" ; * STA    RMAR1; STA    RMAR2
101227          FI
101227          *2BANK
101230
101230   % DRIVER MAIN ENTRY -----------------------------------------------
101230
101230   INTEGER STAT1:= IOXIN+RSTA                               % READ STATUS
101231           A=:SSTAT
101232           IF A BIT ACTIV  GO FAR WBUSY             % GO IF CONTROLLER BUSY
101234           IF A NBIT ONCYL GO FAR RETZ              % IF NOT ON CYLINDER, ERROR, RECALIBRATE
101236           IF T:=BUSFL><0                           % IF LAST LEAVE WAS A BUSY RETURN
101237              THEN                                  % THEN  OLD TRANSFER IS TO BE CHECKED
101241                IF A BIT ICERR GO     IERR          % GO IF INCLUSIVE OR OF ERRORS SET
101243                IF A:=TRTZ><0  GO FAR DSEEK         % NEW SEEK IF LAST COMMAND WAS RECALIBRATE
101246                IF A:=SEEKF><0 GO FAR RWDIS         % GO TO READ/WRITE ROUTINE IF SEEK FLAG SET
101251   *RMAR1,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. LOWER 16 BITS
101252                T:=A
101253   *RMAR2,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. UPPER 8 BITS
101254                A/\377:=:T-SVLCA
101257                T:=T+C-1
101261                A-SVLWC
101262                T:=T+C-1
101264                A:=:T-WANKN
101266                IF A><0 OR T><0 GO FAR MEMER        % MEMORY ADDRESS ERROR
101271                IF A:=BADTR><0  GO FAR DBAD         % GO TO BAD TRACK ROUTINE
101274              ELSE                                  % ELSE NEW TRANSFER
101275                A:=TRG/\300 SHZ 3 BONE 4
101301   *CONT1,      IOXIN LCON                          % SELECT UNIT, CLEAR DISC UNIT
101302   *CONT2,      IOXIN LCON                          % CLEAR DISC INTERFACE
101303   *STAT2,      IOXIN RSTA                          % READ STATUS
101304                A=:SSTAT
101305                0=:SEEKF=:BADTR
101307                0=:RTZFL=:TRTZ=:NOSEC
101312                IF A:=77/\ TRG-20=0 OR A+"20-42"=0 GO FAR DFIN     % GO IF READ STATUS COMMAND
101321                IF A+"42-3" > 0      GO FAR DILLC   % GO IF ILLEGAL COMMAND
101324          FI
101324          IF X=0 GO FAR DFIN                        % GO IF ALL WORDS TRANSFERRED, FINISHED  !!!!!!!!
101326          0=:BADIP
101327          GO FAR DSEEK                              % EXECUTE SEEK
101330
101330   *)FILL
101362

101362   % ROUTINE TO HANDLE DISK STATUS ERROR -------------------------------
101362   %
101362   %      >>>>>>>>>>>>>>>>V
101362   %                IERR: V
101362   %            ----------V----------
101362   %            * CLEAR DEVICE      *
101362   %            ----------V----------
101362   %                      V
101362   %            ----------V---------- YES
101362   %            * TRG BIT TEST      >>>>>>>> HDERR:
101362   %            ----------V----------
101362   %                      V NO
101362   %            ----------V---------- YES
101362   %            * SEEKF><0 ?        >>>>>>>> RETZ:
101362   %            ----------V----------
101362   %                      V NO
101362   %            ----------V---------- YES
101362   %            * TRTZ><0 ?         >>>>>>>> HDERR:
101362   %            ----------V----------
101362   %                      V NO
101362   %         NO ----------V---------- YES
101362   %       V<<<<< BADTR><0 ?        >>>>>>>>>>>>>>>>>>
101362   %       V    ---------------------                V
101362   %       V                                         V
101362   %  -----V-----------------   ---------------------V--------------------
101362   %  * CALCULATE THE VALUE *   * STEP THE BLOCK ADDRESS TO POINT TO THE *
101362   %  * OF XRG PRIOR TO     *   * NEXT SECTOR ON THE BAD TRACK. DID THAT * YES
101362   %  * LAST TRANSFER       *   * GIVE A TO BIG SECTOR NO. ?             >>>>>>>V
101362   %  -----V-----------------   ---------------------V--------------------      V
101362   %       V                                         V NO                       V
101362   %  -----V--------------                           V           ---------------V----------------
101362   %  * HAS AL RETRYS    * NO                        V           * RESTORE BLOCK ADD AND STATUS *
101362   %  * BEEN DONE (ERRC1)>>>>>>> RWDIS:              V           * OF THE ORIGINAL ERROR        *
101362   %  -----V--------------                           V           ---------------V----------------
101362   %       V YES                                     V                          V
101362   %  -----V------------                             V                          V
101362   %  * RESET RETRIES  *                             V                          V>>>>>> RETZ:
101362   %  * (IRETR=:ERRC1) *                             V
101362   %  -----V------------                             V
101362   %       V                                         V
101362   %  -----V----------------                         V
101362   %  * WAS THE ERROR      * NO                      V
101362   %  * ADDRESS MISMATCH ? >>>>> RETZ:               V
101362   %  -----V----------------                         V
101362   %       V YES                                     V
101362   %  -----V-----------------------------------      V
101362   %  * SSTAT=:ADMIS. READ FAILING BLOCK ADD. *      V
101362   %  * FROM THE INTERFACE. SAVE IT IN ADMIA. *      V
101362   %  * CALCULATE BLOCK ADDRESS FOR THE FIRST.*      V
101362   %  * SECTOR ON THAT TRACK.                 *      V
101362   %  * SET AND BADIP BADTR><0.               *      V
101362   %  -----V-----------------------------------      V
101362   %       V                                         V
101362   %       >>>>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<
101362   %                          V
101362   %               -----------V----------------------
101362   %               * LOAD BLOCK ADDRESS             *
101362   %               * LOAD MAR WITH ADDRESS OF ALTPO *
101362   %               * PHYS ADDR IN WNLBA AND WNLBB   *
101362   %               * LOAD WORDC WITH 1.             *
101362   %               * SET BIT 15 IN T (SEEK)         >>>>>>> WDACT:
101362   %               ----------------------------------
101362

101362
101362   IERR:   A:=20
101363   *CONT4, IOXIN LCON                            % DEVICE CLEAR
101364           IF A:=TRG BIT TEST GO FAR HDERR       % IF TEST SPECIFIED, NO ERROR HANDLING
101367           IF A:=SEEKF><0       GO RETZ          % IF THE ERROR OCCURED DURING SEEK DO RETURN TO ZERO ZEEK
101371           IF A:=TRTZ ><0       GO FAR HDERR     % IF RETURN TO ZERO SEEK ALREADY HAS BEEN DONE, ERROR RETURN
101374           IF A:=BADTR><0                        % IF BAD TRACK FLAG SET THEN
101375              THEN                               % TRY NEXT SECTOR ON THE TRACK
101376                T:=BADDR+1                       % ERROR IN ALTERNATIVE ADDRESS FETCH INCR. SECT. ADDR. TO FIND A GOOD SECTOR
101400                IF A:=37/\T-WSECT>=0             % TEST LEGAL SEC. COUNT
101403                   THEN                          % THEN ALL SECTORS ON THE TRACK TRIED
101404                     A:=ADMIA=:SVLBB             % REPORT THE ORIGINAL ERROR
101406                     A:=ADMIS=:SSTAT
101410                     GO RETZ
101411                FI
101411                A:=T                             % BLOCK ADDRESS OF NEXT SECTOR IN A
101412              ELSE
101413                A:=XRG+NOSEC=:XRG=:X             % RESTORE X AND XRG
101417                MIN ERRC1 ; GO FAR ELTE          % DO ALL RETRIES FIRST
101421                TRG BZERO STREARLY BZERO STRLATE=:TRG  % CLEAR STROBE BITS
101425                IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESTORE RETRY COUNTER
101431                IF A:=SSTAT NBIT ADDMI GO RETZ   % NOT ADDRESS MISMATCH,  RECALIBRATE  !
101434                A=:ADMIS                         % SAVE ADDRESS MISMATCH STATUS IN CASE OF REAL ADDRESS MISMATCH
101435                A:=100000=:BADTR=:BADIP          % SET BAD TRACK FLAG
101440   *DAD2,       IOXIN RDAD                       % READ LAST DISK ADDRESS
101441                A-1=:ADMIA                       % SAVE FAILING BLOCK ADDRESS REG IN CASE OF REAL ADDRESS MISMATCH
101443                A/\177740                        % BACK TO FIRST SECTOR ON THE TRACK
101444                                                 % IT IS AN ADDRESS MISMATCH, TRY BAD TRACK BIT
101444           FI
101444   *DAD3,  IOXIN LDAD                            % LOAD FAILING ADDRESS
101445           A=:BADDR
101446           A:=WNLBA=:WANKN
101450   *LMAR3, IOXIN LOMAR                            % LOAD UPPER MEM. ADDR.
101451           A:=WNLBB=:SVLCA
101453   *LMAR4, IOXIN LOMAR                            % LOAD LOWER MEM. ADDR.
101454           A:=1=:SVLWC
101456   *WORD4, IOXIN LWOR                            % LOAD WORD COUNT = 1 (READ NEW SECTOR)
101457           T:=100000                             % SET BAD TRACK BIT IN COMMAND
101460           GO FAR WDACT                          % TRY TO READ FAILING SECTOR WITH BAD TRACK BIT SET
101461

101461   % ROUTINE TO DO RETURN TO ZERO SEEK       ------------------------------
101461
101461   RETZ:   IF A:=RTZFL><0 GO FAR HDERR      % RECALIBRATE ALREADY DONE ?
101464           0=:BADTR=:SEEKF=:SHEAD=:BADIP    % RESET BAD TRACK FLAG
101470           A:=TRG SHZ 10 SHZ -16 =:X        % UNIT INTO X
101474           0=:LCYLI(X)                      % CLEAR CYLINDER NO IN BASE FIELD
101475           IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESET RETRY COUNT
101501           T:=34000                         % RETURN TO ZERO SEEK, RECALIBRATE
101502           T=:RTZFL=:TRTZ                   % SET RECALIBRATE AND FLAG
101504           GO FAR WDACT                     % ACTIVATE
101505

101505   % ROUTINE TO GET ALTERNATIVE DISK ADDRESS ------------------------------
101505
101505   % ENTER HERE WHEN A SECTOR CONTAINING POINTERS TO THE ALTERNATIVE TRACK
101505   % IS READ CORRECT
101505   % PICK UP THE POINTER TO THE ALTERNATIVE TRACK FROM THE FIRST WORD IN THE MEMORY BUFFER
101505   % FIND THE CYLINDER PART OF THE POINTER. SUBTRACT IT FROM THE CURRENT CYLINDER (LCYLI)
101505   % THE DIFFERENCE (NO. CYLINDERS TO SEEK) IS WRITTEN OUT AS WORD COUNT.
101505   % STORE THE NEW CYLINDER NO. IN LCYLI.
101505   % FIND THE ALTERNATIVE TRACK'S HEAD NO., AND STORE IT IN SHEAD.
101505
101505   DBAD:   T:=2; X:=WNLBB; *LDATX         % TO ENSURE NOT HIT IN CACHE
101510           T:=WNLBA;       *LDATX
101512           T:=A                           % T <== ALTERNATIVE DISK CYL. ADDR.
101513           A:=TRG SHZ 10 SHZ -16=:X       % UNIT NO. IN X
101517           A:=T ; AD SHZ -5               % HEAD INTO UPPER 5 BITS OF D, CYLINDER IN A
101521           A-LCYLI(X)                     % A <== NO. OF CYL'S TO GO
101522   *WORD3, IOXIN LWOR
101523           T SHZ -5 =:LCYLI(X)            % NEW CYL. ADDR. AFTER THIS SEEK
101525           A:=0 ; AD SHZ 5 ; A=:SHEAD     % HEAD TO USE ON ALT TRACK
101530           A:=-1=:SEEKF                   % SET SEEK FLAG
101532           0=:BADTR                       % RESET BAD TRACK FLAG
101533           T:=60000                       % SEEK COMMAND
101534           GO FAR WDACT                   % ACTIVATE
101535
101535   *)FILL
101544

101544   % ROUTINE TO SEEK ON DISK ---------------------------------------------
101544
101544   INTEGER TEMPX
101545
101545   DSEEK:  0=:TRTZ                        % RESET RECALIBRATE FLAG
101546           A:=DRG=:D
101550           A:=TRG/\300 SHZ 3 BONE 4
101554   *CONT5, IOXIN LCON                     % DEVICE CLEAR
101555   *CONT6, IOXIN LCON                     % DEVICE CLEAR
101556           A:=ARG
101557           X-1;D+X;IF C THEN A+1;FI; X+1  % AD= LAST LOGICAL DISK ADDR.
101565           T:=WSECY ; * RDIV ST % A<= CYL. NO.    D<= NO. OF SEC'S IN LAST CYL
101567           IF A>>T:=WMXCY GO FAR LAOUR    % GO IF WANTED LOGICAL ADDRES>MAX LOGICAL ADDRESS
101572           X=:TEMPX
101573           T:=TRG SHZ 10 SHZ-16=:X        % UNIT NO. IN X
101577           T:=LCYLI(X)
101600           A=:LCYLI(X)
101601           X:=TEMPX
101602           A-T ; * BLDC 170 DA            % SAVE SEEK DIRECTION IN K
101604           IF A<0 THEN A:=A- FI           % NEGATIVE STEP COUNT
101606   *WORD1, IOXIN LWOR                     % LOAD WORD COUNT WITH TRACK DIFFERENCE
101607           A=:SSTEP
101610           A:=0 ; T:=WSECT ; * RDIV ST    % A<= HEAD NO.     D<= NO. OF SEC'S ON LAST TRACK
101613           A=:SHEAD
101614           A:=D+1=:SSEC
101616           IF A:=SSTEP><0
101617              THEN                        % IF NOT ON CORR. CYL
101620                A=:SEEKF                  % SET SEEK FLAG
101621                T:=20000 ; * BSTA 160 DT  % STEP COMMAND INCLUDE DIRECTION
101623                GO WDACT                  % ACTIVATE
101624          FI
101624          GO RWDIS
101625   *)FILL
101630

101630   % MOD. EARLY/LATE-STROBE BIT IN CONTR.REG
101630   ELTE:  T:=3; 0=:D
101632          IF ERRC1 /\ T = T THEN
101636             D BONE STREARLY
101637          ELSE IF T-1 = A   THEN
101643             D BONE STRLATE
101644          FI FI
101644          IF D BIT STREARLY OR BIT STRLATE THEN
101650            MIN ELCOU; A /\ A                   % COUNT SETTING EARLY/LATE STROBE
101652          ELSE
101653            MIN NOCOU; A /\ A                   % COUNT SETTING NOMINEL STROBE
101655          FI
101655          TRG BZERO STREARLY BZERO STRLATE \/D=:TRG
101662
101662   % ROUTINE TO READ OR WRITE ON DISK -----------------------------------
101662   RWDIS:  0=:SEEKF                                 % RESET SEEK FLAG
101663           T:=SSEC=:D
101665           IF X<<T THEN T:=X FI                     % IF WHOLE TRANSFER WITHIN THIS TRACK THEN T<= NO. OF SEC'S TO TRANSFER
101670           T=:NOSEC
101671           X-T=:XRG                                 % X<= REMAINING SECTORS
101673           D-T                                      % D<= FIRST SECTOR
101674           A:=TRG SHZ 10 SHZ -16=:X                 % UNIT NO. IN X
101700           A:=LCYLI(X) SHZ 5 \/D                    % SHIFT CYLINDER ADDR. TO CORR. POSITION COMBINE CYL. & SEC. ADDRESS
101703   *DAD1,  IOXIN LDAD
101704           A=:SVLBB
101705           A:=WSECW ; X:=XRG ; * RMPY SA DX         % AD<= REMAINING WORDCOUNT
101710           A:=:D+CMAD2:=:D
101713           A:=A+C+CMAD1
101715   *LMAR1, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, UPPER PART
101716           A=:WANKN
101717           IF A-400>=0 GO MORER                     % MEMORY OUT OF RANGE
101721           A:=D
101722   *LMAR2, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, LOWER PART
101723           A=:SVLCA
101724           A:=T*WSECW                               % A<= WORDCOUNT
101726   *WORD2, IOXIN LWOR
101727           A=:SVLWC
101730           A:=3/\TRG SHZ 13 =:T                     % FUNCTION CODE IN T
101734
101734
101734   % ROUTINE TO CREATE CONTROLWORD FOR ACTIVATION -----------------------
101734
101734   WDACT:  A:=SHEAD SHZ 5   ; T\/A        % SHIFT HEAD NO. TO CORR. POSITION
101737           A:=TRG/\142000
101741           A\/BADIP ; T\/A
101743           A:=TRG SHZ 3/\3000\/T+5        % + UNIT NO. + ACTIVATE & INT. ENABLE
101750   *CONT3, IOXIN LCON
101751           A=:SVLCO
101752   INTEGER STAT3:=IOXIN+RSTA
101753           IF A NBIT ACTIV GO CNACT       % ERROR, NOT BUSY
101755           A=:BUSFL
101756   WBUSY:  TAD:=TADRG ; X:=XRG
101760           GO RETUR                       % BUSY EXIT
101761   *)FILL
101764

101764   % FINISHED & ERROR EXITS ----------------------------------------------
101764
101764   DFIN:   T:=TRG
101765           L+1 ; GO WFINI                       % FINISHED EXIT
101767
101767   MORER:  T:=1   ; GO DERR                     % ATTEMPT TO USE BANK NO. >>377.         BIT  8
101771   MEMER:  T:=4   ; GO DERR                     % CORE ADDRESS REGISTER NOT AS EXPECTED  BIT 10
101773   LAOUR:  T:=10  ; GO DERR                     % LOGICAL ADDRESS OUTSIDE DICE DEVICE    BIT 11
101775   DILLC:  T:=100 ; GO DERR                     % ILLEGAL CODE                           BIT 14
101777   CNACT:  T:=200 ; GO DERR                     % CONTROLLER NOT ACTIVE AFTER ACTIVATE   BIT 15
102001   HDERR:  T:=0                                 % HARDWARE ERROR NO ADDITIONAL STATUS
102002
102002   DERR:   L-1                                  % ERROR RETURN
102003           T SHZ 10                             % GET THE ADDITIONAL STATUS
102004           A:=TRG/\377 ; T\/A
102007   WFINI:  X:=SSTAT
102010           IF IRETR >=0 THEN -5 FI;A=:ERRC1
102014           0=:BUSFL
102015   RETUR:  EXITA                                % GENERAL EXIT
102016   RBUS
102020
102020   *)KILL LDAD  RSTA LCON LWOR
102020   *)KILL SATAD WSECW WSECY ACTIV ICERR ADDMI ONCYL TEST
102020   *)KILL WSECT WMXCY RMAR1 RMAR2 CONT1 STAT2 CONT4
102020   *)KILL DAD2  DAD3  LMAR3 LMAR4 WORD4 WORD3 WORD1 DAD1  LMAR1 LMAR2
102020   *)KILL WORD2 CONT3 DISDE CONT2
102020   *)KILL CONT5 CONT6
102020   *)KILL STREA STRLA
102020
102020   *"8ZWDI -8WDIS
"102020   *)KILL 9ESWP; 9ESWP=*
102020
102020   *"8WDIS; 8WDIS=0
"102020
102020   @DEV 1
102020   @EOF
102020
102020   SUBR SCSWD
102020   %
102020   % SCSI SWAP DRIVER
102020   %
102020   % CALL SEQUENCE
102020   %
102020   %       JPL I (SCSWD
102020   %       JMP BUSY
102020   %       JMP ERROR
102020   %       JMP FIN
102020   %
102020   % ENTRY:
102020   %
102020   %       B = DATAFIELD ADDRESS
102020   %
102020   %       T = FUNCTION
102020   %             BIT  0- 5: FUNCTION TYPE
102020   %                          0: READ
102020   %                          1: WRITE
102020   %                         42: RESET/READ CAPACITY
102020   %             BIT  6-10: LOGICAL UNIT
102020   %             BIT 11-13: SCSI DEVICE NUMBER
102020   %             BIT 14-17: SHOULD BE ZERO
102020   %
102020   %      AD = DISK ADDRESS
102020   %
102020   %       X = AMOUNT
102020   %
102020   %   MEMAD = MEMORY ADDRESS (32 BITS)
102020   %
102020   %
102020   %      BLOCK SIZE FOR DISK ADDRESS AND AMOUNT ARE 512 WORDS
102020   %
102020   %      FIRST CALL SHOULD ALWAYS BE FUNCTION 42
102020   %
102020   %
102020   %  AFTER BUSY RETURN THE DRIVER MUST BE CALLED AT ONCE
102020   %  OR AFTER INTERRUPT
102020   %
102020   %
102020   %
102020   %  VARIABLES IN DATAFIELD
102020   %
102020   %    HDEV = HARDWARE DEVICE NUMBER
102020   %
102020   %   BUSFL = MUST BE ZERO BEFORE ENTRY THE FIRST TIME
102020   %
102020   %   COMP1 = PHYSICAL ADDRESS OF I/O BUFFER
102020   %   COMP2   (USUALLY COMB1)
102020   %
102020   %
102020   %  ORIGINAL VERSION   1/ 1-87
102020   %           CHANGED  24/ 4-87  NEW RESET WAIT/SCSI DEVICE NUMBER
102020   %           CHANGED  28/12-87  CHECK ON BUSY STATUS
102020   %           CHANGED  22/ 2-87  INITIALIZE TOTAL COMMAND BLOCK MEMORY
102020
102020   %..............................
102020   % DEFINITIONS FOR SCSI DRIVER .
102020   %..............................
102020
102020   SYMBOL RLMAR=00           % READ MEMORY ADDRESS REGISTER BITS 14-0
102020   SYMBOL WLMAR=01           % WRITE MEMORY ADDRESS REGISTER BITS 14-0
102020   SYMBOL REDAT=02           % READ DATA
102020   SYMBOL WRDAT=03           % WRITE DATA
102020   SYMBOL RSTAU=04           % READ STATUS
102020   SYMBOL CTBUS=02           % CONTROLLER BUSY
102020   SYMBOL NCRIT=11           % INTERRUPT FROM NCR
102020   SYMBOL SCREQ=15           % REQ FROM SCSI BUS
102020   SYMBOL WCONT=05           % WRITE CONTROL
102020   SYMBOL ENDMA=05           % ENABLE DMA
102020   SYMBOL RHMAR=06           % READ MEMORY ADDRESS REGISTER BITS 23-15
102020   SYMBOL WHMAR=07           % WRITE MEMORY ADDRESS REGISTER BITS 23-15
102020   SYMBOL RNDAT=40           % READ NCR DATA REGISTER
102020   SYMBOL WNDAT=41           % WRITE NCR DATA REGIISTER
102020   SYMBOL RNCOM=42           % READ NCR COMMAND REGISTER
102020   SYMBOL WNCOM=43           % WRITE NCR COMMAND REGISTER
102020   SYMBOL RNCNT=44           % READ NCR CONTROL REGISTER
102020   SYMBOL WNCNT=45           % WRITE NCR CONTROL REGISTER
102020   SYMBOL RDESI=46           % READ DESTINATION ID REGISTER
102020   SYMBOL WDESI=47           % WRITE DESTINATION ID REGISTER
102020   SYMBOL RAUXS=50           % READ AUXILIARY STATUS
102020   SYMBOL DARGF=07           % DATA REGISTER FULL
102020   SYMBOL WAUXS=51           % WRITE AUXILIARY STATUS
102020   SYMBOL ROIDN=52           % READ OWN ID NUMBER
102020   SYMBOL RITRG=54           % READ INTERRUPT REGISTER
102020
102020   SYMBOL ILCOM=16           % ILLEGAL COMMAND
102020   SYMBOL RECON=14           % RECONNECT
102020   SYMBOL CONEC=13           % CONNECT
102020   SYMBOL DISCO=12           % DISCONNECT
102020   SYMBOL BUSSI=11           % BUS SERVICE INTERRUPT
102020   SYMBOL FUCOM=10           % FUNCTION COMPLETE
102020   SYMBOL PARIT=06           % PARITY ERROR
102020   SYMBOL PAUSE=02           % PAUSED
102020   SYMBOL TCZRO=01           % TRANSFER COUNT ZERO
102020
102020   SYMBOL RSOUI=56           % READ SOURCE ID
102020   SYMBOL RDIST=62           % READ DIAGNOSTIC STATUS
102020   SYMBOL SLFCO=07           % SELFTEST COMPLEAT NCR 5386
102020   SYMBOL RTCM=70            % READ TRANSFER COUNTER MOST
102020   SYMBOL WTCM=71            % WRITE TRANSFER COUNTER MOST
102020   SYMBOL RTC2=72            % READ TRANSFER COUNTER 2ND.
102020   SYMBOL WTC2=73            % WRITE TRANSFER COUNTER 2ND.
102020   SYMBOL RTCL=74            % READ TRANSFER COUNTER LEAST
102020   SYMBOL WTCL=75            % WRITE TRANSFER COUNTER LEAST
102020
102020   SYMBOL 6SFUN=17              % FUNCTION STARTED
102020   SYMBOL 6STMS=16              % TARGET SUPPORTS OPTIONAL MESSAGES
102020   SYMBOL 6SBCZ=13              % BYTECOUNT ZERO
102020   SYMBOL 6SMSO=12              % MESSAGE OUT PENDING
102020   SYMBOL 6SRFD=11              % RETURN ON COMMAND ACCEPTED (I.E. FIRST DISCONNECT)
102020   SYMBOL 6SDIS=10              % DISCONNECT MESSAGE RECEIVED
102020   SYMBOL 6SCCO=7               % COMMAND COMPLETE MESSAGE RECEIVED
102020   SYMBOL 6SMSI=6               % MESSAGE RECEIVED
102020   SYMBOL 6SARB=5               % ARBITRATION PHASE
102020   SYMBOL 6SSBT=4               % SINGLE BYTE TRANSFER
102020   SYMBOL 6SCRP=3               % CONNECT/RECONNECT PHASE
102020
102020
102020   DISP -72
102020       INTEGER COMP1, COMP2     % PHYSICAL ADDRESS OF COMMAND BLOCK/DATA BUFFER
102020       DOUBLE COMPN=COMP1
102020       INTEGER CMBU1,CMBU2,CMBU3,CMBU4,CMBU5,CMBU6
102020       DOUBLE CMB12=CMBU1, CMB23=CMBU2, CMB34=CMBU3, CMB45=CMBU4
102020       TRIPLE CMB13=CMBU1
102020       INTEGER CDBP1, CDBP2     % CURRENT DATA BYTE POINTER
102020       DOUBLE CDABP=CDBP1
102020       INTEGER CDBC1, CDBC2     % CURRENT DATA BYTE COUNT
102020       DOUBLE CDABC=CDBC1
102020       INTEGER EIMSK            % EXPECTED INTERRUPT MASK
102020       INTEGER POINTER EISRT    % EXPECTED INTERRUPT HANDLER
102020       DOUBLE EIHAN=EIMSK
102020       INTEGER CURCW            % CURRENT CONTROLL WORD
102020       INTEGER MSGRV            % LAST MESSAGE
102020       INTEGER LRG              % RETURN ADDRESS
102020       INTEGER CURFN            % INITIAL FUNCTION
102020       INTEGER TESTS            % NCR TEST STATUS
102020
102020       DOUBLE ADRG=ARG
102020   PSID
102020
102020
102020   DOUBLE RBSIR=?
102020   INTEGER IFLAG=?
102020
102020   SCSWD: TAD=:TADRG; X=:XRG; A:=L=:LRG
102024
102024   % INTERRUPT HANDLER
102024   SCHII: 0=:CURCW                             % CLEAR TO MEMORY
102025          IF X:=BUSFL=0 THEN
102030             IF 77/\TRG=42 THEN
102035                CALL RESET; GO FAR ERREX       % RESET SCSI BUS
102037             FI
102037             T:=TRG
102040   SCRTS:    T=:CURFN
102041             IF TESTS><0 GO FAR ERREX
102044             77/\T; T:=COMP1; X:=COMP2
102050             *STZTX 30; STZTX 40; STZTX 50
102053             IF A-77=0 THEN
102055                1400; *STATX 00; STZTX 10
102060                4000; *STATX 20
102062                AD SHZ -30=:CDABC
102064                COMPN SHZ 1=:CDABP
102067             ELSE
102070             IF A-"42-77"=0 THEN
102072                22400; *STATX 0
102074                AD SHZ -40; *STDTX 10; STDTX 30
102077                COMPN SHZ 1=:CDABP
102102                10; AD SHZ -20=:CDABC
102105             ELSE
102106             IF A-"1-42"<=0 THEN
102111                IF A=0 THEN 25000 ELSE 24000 FI; *STATX 00
102116                MEMAD SHZ 1=:CDABP
102121                T:=BLSZ; X:=XRG; ADRG
102124                DO WHILE T NBIT 12
102126                   AD SHZ 1; T SHZ 1
102130                   A:=:X SHZ 1:=:X
102133                OD
102134                T:=COMP1; X=:L:=COMP2; *STDTX 10
102140                A:=0; D:=L; AD SHZ 10; *STDTX 30
102144                A:=XRG; AD SHZ -20 SHZ 12=:CDABC
102150             ELSE
102151                GO FAR ERREX
102152                *)FILL
102161             FI FI FI
102161             700/\CURFN; AD SHZ -21; *LDATX 0
102165             A\/D; *STATX 0
102167             "0"; T:=HDEV+WCONT; *IOXT         % CLEAR TO MEMORY
102173             7000/\CURFN SHZ -11               % SCSI DEVICE NUMBER
102176             T+"WDESI-WCONT"; *IOXT
102200             "0"; T+"WTCM-WDESI"; *IOXT
102203             T+"WTC2-WTCM"; *IOXT
102205             320; T+"WTCL-WTC2"; *IOXT         % SET WAITING TIME INTO TRANSFER COUNTER
102210             11; T+"WNCOM-WTCL"; *IOXT         % SELECT COMMAND TO NCR
102213             0=:EIMSK; T:=IFLAG=:BUSFL
102216          ELSE
102217             T:=HDEV+RSTAU; *IOXT              % READ DEVICE STATUS
102222             IF A BIT 2 GO FAR BUSRE           % BUSY
102224             IF A BIT 5 GO FAR SCDIS
102226             IF A BIT 11 THEN                  % INTERRUPT FROM NCR
102230                "0"; T:=HDEV+WCONT; *IOXT      % CLEAR TO MEMORY
102234                T+"RAUXS-WCONT"; *IOXT         % READ AUXILIARY STATUS
102236                AD SHZ -10
102237                T+"RITRG-RAUXS"; *IOXT         % READ INTERRUPT REGISTER
102241                AD SHZ 10
102242
102242                IF A=:D/\177500=EIMSK AND T><0 THEN
102251                   CALL EISRT                  % EXPECTED INTERRUPT
102252                ELSE
102253                   A SHZ -10; X:=BUSFL
102255                   IF A=4 AND X NBIT 6SARB THEN
102262                      T:=0; GO FAR FINEX
102264                   ELSE
102265                   IF A=1 AND X BIT 6SARB THEN
102272                      X BZERO 6SARB BONE 6SCRP=:BUSFL
102275                      RBSIR=:EIHAN             % ALLOW BUS SERVICE INTERRUPTS
102277                   ELSE
102300                      GO FAR SCDIS             % ILLEGAL INTERRUPT
102301                   FI FI
102301                FI
102301             FI
102301          FI
102301          5\/CURCW; T:=HDEV+WCONT; *IOXT       % ACTIVATE+ENABLE INTERRUPT
102306   BUSRE: TADRG; X:=LRG=:L:=XRG; EXITA
102313   *)FILL
102322   INTEGER IFLAG(0); * 0; *-1/ 1@6SFUN+^; *-1/1@6SARB+^
102323   DOUBLE RBSIR(0); * 1@BUSSI; NEWPH
102325
102325   @ICR;
102325   INTEGER ARRAY NEWST:=
102325         (040000, 040001, 100022, 140023, 140224, 140025, 140026, 040027,
102335          040030, 140031, 150032, 140033, 040034, 040035, 142036, 140037);
102345   @CR;
102345
102345   % FATAL ERROR: RESET SCSI BUS
102345   SCDIS: CALL RESET; 0/\0                     % RESET SCSI BUS
102347
102347   ERREX: T:=-1
102350
102350   % EXIT DRIVER: X = LUN DATAFIELD OR 0. T = STATUS
102350   FINEX: X:=20
102351          IF T=0 THEN
102353             IF BUSFL BIT 6SCCO THEN
102356                IF T:=HSTAT=0 THEN
102361                   IF 77/\CURFN=77 THEN
102366                      T:=COMP1; X:=COMP2
102370                      *TRR CCLR; LDATX 10
102372                      IF A SHZ -10=6 THEN
102376                         T:=TRG; GO FAR SCRTS
102400                      FI
102400                      X:=A
102401                   ELSE
102402                      IF A=42 THEN
102405                         T:=COMP1; X:=COMP2
102407                         *TRR CCLR; LDATX 30
102411                         A=:BLSZ
102412                      FI
102412                      X:=0
102413                   FI
102413                ELSE
102414                IF 2=T OR 10=T THEN
102422                   IF CURFN=TRG THEN
102426                      T:=77\/A; GO FAR SCRTS
102431                   FI
102431                FI FI
102431             FI
102431          FI
102431          *BSET ZRO 00
102432          17/\X:=:X\/NEWST(X)=:X
102437          *BSET ONE 00
102440          A:=LRG; IF X NBIT 4 THEN A+2 FI; A=:L
102445          0=:BUSFL=:EIMSK; ADRG; EXIT          % INDICATE FREE
102451   *)FILL
102454
102454   % MSGIN: MESSAGE IN HANDLING
102454
102454   DOUBLE BSISR(0); * 1@BUSSI; NEWPH
102456
102456   MSGIN: IF T:=BUSFL BIT 6SMSI THEN           % MESSAGE IN HANDLING
102461             IF MSGRV><0 GO FAR SCDIS
102464             T BZERO 6SMSI BONE 6SCCO=:BUSFL   % "COMMAND COMPLETE"
102467          FI
102467          4; T:=HDEV+WNCOM; *IOXT              % "Message Accepted" TO NCR
102473          BSISR=:EIHAN; EXIT                   % ALLOW BUS SERVICE INTERRUPTS
102476
102476   *)FILL
102477
102477   % CLEAR SCSI BUS
102477   INTEGER RWCNT
102500
102500   RESET: -1=:TESTS
102502          "0"; T:=HDEV+WNCOM; *IOXT            % DISCONNECT TO NCR
102506          2000; T+"WCONT-WNCOM"; *IOXT         % SET RESET ON SCSI BUS
102511          FOR X:=-5000 DO OD                   % WAIT AT LEAST 250 us
102513          "0"; *IOXT                           % CLEAR RESET ON SCSI BUS
102515          20; *IOXT                            % CLEAR CONTROLLER
102517          T+"RDIST-WCONT"; 0=:RWCNT
102521          FOR RWCNT DO
102521             *IOXT
102522             WHILE A NBIT SLFCO                % WHILE NOT SELFTEST COMPLETE
102524          OD
102526          IF A NBIT SLFCO OR A/\77><0 THEN EXIT FI
102533          FOR X:=-4 DO                         % ALLOW DEVICE TO POWER UP
102534             D:=0                              % COUNT BASIC TIME UNITS
102535             DO
102535                "20000"; *IOX 13               % REMOVE CLOCK INTERRUPT
102537                DO
102537                   *IOX 12                     % READ RT CLOCK STATUS
102540                   WHILE A NBIT 3              % WHILE NOT CLOCK INTERRUPT
102542                OD
102543                WHILE D+1><62                  % REPEAT UNTIL 1 SECOND
102547             OD
102550          OD
102551          14; T+"WNCNT-RDIST"; *IOXT           % WRITE NCR CONTROLL
102554          0=:TESTS; EXITA
102556   *)FILL
102562
102562   % NEW PHASE
102562
102562   TRIPLE SAVRG
102565
102565   NEWPH: T:=BUSFL                             % OLD STATUS
102566          IF 36/\T=0 THEN                      % OLD PHASE WAS DATA
102571             TAD=:SAVRG
102572             IF D NBIT TCZRO THEN
102574                T:=HDEV+RTCL; *IOXT            % READ LSB OF BYTECOUNT
102577                AD SHZ -10
102600                T+"RTC2-RTCL"; *IOXT           % READ BYTE 2 OF BYTECOUNT
102602                AD SHZ -10
102603                T+"RTCM-RTC2"; *IOXT           % READ MSB OF BYTECOUNT
102605             ELSE
102606                AD SHZ -40                     % ZERO BYTECOUNT
102607             FI
102607             T:=CDBC1; X:=CDBC2; AD=:CDABC     % SAVE OLD AND STORE NEW BYTECOUNT
102612             *RADD SD CM2 DX; RADD SA CM1 ADC DT    % GET BYTES TRANSFERED
102614             CDABP; *RADD SX DD; RADD ST ADC DA     % AND NEW MEMORY ADDRESS
102617             AD=:CDABP
102620             IF D BIT 0 AND BUSFL BIT 0 THEN   % ODD BYTECOUNT TO ND-100 MEMORY
102625                150; T:=HDEV+WCONT; *IOXT      % SET TEST MODE
102631                T+"RLMAR-WCONT"; *IOXT         % FORCE LAST BYTE TO MEMORY
102633                "0"; T+"WCONT-RLMAR"; *IOXT    % CLEAR TEST MODE
102636             FI
102636             SAVRG
102637          FI
102637          AD SHZ 32 SHZ -15                    % GET NEW PHASE
102641          X:=177600/\T\/A=:BUSFL               % SET NEW STATUS
102645
102645          GOSW DAOPH,DAIPH,COMPH,STAPH,FAR SCDIS,FAR SCDIS,FAR SCDIS,FAR MSIPH
102656   *)FILL
102660
102660   INTEGER WP1, WP2
102662   DOUBLE DWP=WP1
102662
102662   % #0: DATA OUT PHASE
102662
102662   DAOPH: 40=:CURCW; GO DATPH
102665
102665   % #1 DATA IN PHASE
102665
102665   DAIPH: 140=:CURCW
102667   DATPH: IF X NBIT 6SFUN GO FAR SCDIS         % PHASE ILLEGAL
102671          T:=HDEV+WCONT; *IOXT                 % SET TRANSFER DIRECTION
102674          CDABP SHZ -1; T+"WHMAR-WCONT"; *IOXT % WRITE MSW OF MAR
102700          A:=D; T+"WLMAR-WHMAR"; *IOXT         % WRITE LSW OF MAR
102703          CDABC; IF A=D AND D=0 GO FAR SCDIS   % CHECK BYTECOUNT
102710          T+"WTCM-WLMAR"; *IOXT                % MSB OF TRANSFERCOUNTER
102712          AD SHZ 10; T+"WTC2-WTCM"; *IOXT      % 2B OF TRANSFER COUNTER
102715          AD SHZ 10; T+"WTCL-WTC2"; *IOXT      % LSB OF TRANSFER COUNTER
102720          224; T+"WNCOM-WTCL"; *IOXT           % DMA MODE + TRANSFER INFO
102723          EXIT
102724
102724   *)FILL
102726
102726   % #2 COMMAND PHASE
102726
102726   COMPH: 40=:CURCW; T:=HDEV+WCONT; *IOXT      % SET TRANSFER DIRECTION
102733          COMPN; T+"WHMAR-WCONT"; *IOXT        % WRITE MSW OF MAR
102736          A:=D; T+"WLMAR-WHMAR"; *IOXT         % WRITE LSW OF MAR
102741          "0"; T+"WTCM-WLMAR"; *IOXT           % MSB OF TRANSFERCOUNTER
102744          T+"WTC2-WTCM"; *IOXT                 % 2B OFTRANSFER COUNTER
102746          14; T+"WTCL-WTC2"; *IOXT             % LSB OF TRANSFER COUNTER
102751          224; T+"WNCOM-WTCL"; *IOXT           % DMA MODE + TRANSFER INFO
102754          EXIT
102755   *)FILL
102756
102756   % #3 STATUS PHASE
102756
102756   STAPH: 124; T:=HDEV+WNCOM; *IOXT            % "Transfer info, single byte" TO NCR
102762          L=:D; CALL RDINF; A=:HSTAT; D=:P     % READ STATUS BYTE
102766   *)FILL
102767
102767   % #7 MESSAGE IN PHASE
102767
102767   DOUBLE MSFCS(0); * 1@FUCOM; MSGIN           % MESSAGE IN HANDLER
102771
102771   MSIPH: 124; T:=HDEV+WNCOM; *IOXT            % "Transfer Info, single byte" TO NCR
102775          L=:D; CALL RDINF; A=:MSGRV           % READ MESSAGE
103000          BUSFL BONE 6SMSI=:BUSFL              % INDICATE MESSAGE READY
103003          D=:L; MSFCS=:EIHAN; EXIT             % RETURN
103007   *)FILL
103010
103010   % READ A INFORMATION BYTE FROM SCSI BUS
103010
103010   INTEGER RDCNT
103011
103011   RDINF: T:=HDEV+RAUXS; -20=:RDCNT
103015          FOR RDCNT DO
103015             *IOXT
103016             IF A BIT DARGF THEN
103020                T+"RNDAT-RAUXS"; *IOXT
103022                A/\377; EXIT
103024             FI
103024          OD
103026          GO FAR SCHII                         % CHECK FOR INTERRUPT
103027   *)FILL
103031
103031   RBUS
103031   @DEV 1
103031   @EOF
103031
041130   %$--:RPIT                      % FOR SPLITTING AV LISTING.
041130   *P2RPI/
066341   @DEV (S-S-L)RP-P2-SEGADM:NPL
066341   % TAB S8,4
066341

066341   %%%%%%%%%%%%%%%%%%%%%%% C X - R P I T - S E G A D M %%%%%%%%%%%%%%%%%%%%%%%%%%
066341   %=============================================================================
066341   %            C L R B M A P
066341   %
066341   % CLRBMAP:   CLEAR THE REENTRANT BITMAP
066341   %      ENTRY:  X=RTDESCRIPTION; INTERRUPT MUST BE OFF OR MLEV DISABLED
066341   %
066341   SUBR CLRBMAP
066341
066341   CLRBMAP:
066341          X:=X.RTDLGADDR; *AAX BITMA
066343          T:=0
066344          *STZTX 00; STZTX 10; STZTX 20; STZTX 30
066350          *STZTX 40; STZTX 50; STZTX 60; STZTX 70
066354          EXIT
066355   RBUS
066355   %==============================================================================
066355   %
066355   %                S E G M E N T  M O N I T O R  C A L L S
066355   %
066355   %==============================================================================
066355   % 36.5    (R)   M C A L L   M E X I T
066355
066355   % MONITOR CALLS MCALL AND MEXIT - TO CHANGE SEGMENTS
066355   % APPL. LEVEL
066355
066355   SUBR SGMTY,MCALL,MEXIT,0LEGSEG,LEGSEG,R15ERRD,RLEGSEG
066355
066355   DISP 0
066355       DOUBLE MSTADR
066355       INTEGER MSEGM=D0
066355       INTEGER FUNCTION=D0, ADRESS=D1, SEG1=D2, SEG2=D3, PITS=D4
066355       DOUBLE SVSEG=D5
066355   PSID
066355   INTEGER MSEG1=?, MSEG2=?
066355   DOUBLE DMSEG=?
066355   INTEGER STRA=?,LA=?,STRB=?,LB=?
066355
066355   MCALL: CALL GET0; X:=ZTREG % T POINTS TO PARAMETERS
066357          A:=OLDPAG           % TO SET UP WINDOW.
066360          CALL USALTPIT       % SET UP USERS APT AS APT.
066361          MLEV; *MST PIE      % ENABLE MON LEVEL FOR PAGEFAULT HANDLING
066363          AD:=X.MSTADR        % GET PARAMETERS FROM USERS PIT.
066364          CALL SINALTPIT      % RESET APT.
066365          T:=ZPREG=:ZLREG     % SAVE RETURN ADDRESS
066367          A=:ZPREG:=D=:MSEGM  % NEW P AND SEGMENTS
066372          MLEV; *MCL PIE
066374          RTREF.DACTSEG=:SVSEG
066377          IF A>376 OR D>T GO FAR ERRIL
066404          D SH 10; A+D; A=:ZTREG        % SAVE OLD SEGMENTS IF MCALL
066407          GO MMC
066410
066410   MEXIT: CALL GET0; ZLREG=:ZPREG; ZTREG=:MSEGM
066415          AD:=RTREF.DACTSEG
066417          IF A<=376 AND D<=376 THEN   % MEXIT ON "OLD" SEGENT NUMBERS SHOULD
066425              D SH 10;A+D             % RETURN CURRENT SEGMENT NUMBERS IN
066427              A=: ZTREG               % CALLERS T-REG
066430          FI                          %
066430   MMC:   IF MSEGM SHZ -10=377 THEN -1 FI; A=:SEG2; IF A-1=0 GO FAR ERRIL % SEGNO 1
066442          IF MSEGM /\ T   = T  THEN -1 FI; A=:SEG1; IF A-1=0 GO FAR ERRIL % IS ILLEGAL
066453          GO FELLS
066454   *)FILL
066463

066463   %=============================================================================
066463   %
066463   % (R)  S G M T Y       SEGMENT MULTI FUNCTION MONITOR CALL.
066463   %                      T-REGISTER POINTS TO PARAMETER ADDRESS LIST:
066463   %                          FUNCTION CODE
066463   %                          ADDRESS
066463   %                          SEGMENT 1
066463   %                          SEGMENT 2
066463   %                          PITS
066463   %      FUNCTIONS: 0 - MCALL                1 - MEXIT
066463   %                 2 - MCALL W/PIT CHANGE   3 - MEXIT W/PIT CHANGE
066463   %                 4 - REMSG (REMOVE SEGMENT ENTEREED WITH ENTSG)
066463   %
066463   %      EXIT:   MCALL:  T = SEGMENT 1
066463   %                      D = SEGMENT 2
066463   %                      L = RETURN ADDRESS
066463   %                      X = OLD PITS IF PITS CHANGED (FUNCTION 2)
066463   %
066463   %              MEXIT:  NO REGISTER CHANGE
066463   %
066463   %              REMSG:  A = STATUS (SEE REMSG)
066463   %
066463   SGMTY: T=:B; CALL GET5
066465          IF FUNCTION >> 4 GO FAR ERRFUNC
066471          A GOSW KMCALL, KMEXIT, PMCALL, PMEXIT, GOTOREMSG
066477   GOTOREMSG:
066477          CALL XREMSG
066500
066500   PMEXIT:
066500   PMCALL:PITS=:D/\377    % ALT. PIT
066503          CALL LEGPIT     % CHECK IT
066504          A:=D SHZ -10    % NORM. PIT
066506          CALL LEGPIT     % CHECK IT
066507          A:=0
066510          AD SH 10; D SH 4; AD SHZ -5 % ALIGN NIBBLES
066513          OLDPAG=:T/\100177\/D=:OLDPAG
066520          IF FUNCTION-2=0 THEN % IF PMCALL
066523              A:=T SHZ -7/\17:=:T SHZ -3/\7400\/T=:ZXREG % REALIGN NIBBLES AS BYTES
066533          ELSE
066534              GO KMEXIT
066535          FI
066535   KMCALL:RTREF.ACT1SEG=:ZTREG    % RETURN OLD SEGMENT NUMBERS
066540          X.ACT2SEG=:ZDREG
066542          ZPREG=:ZLREG            % SAVE RETURN ADDRESS
066544   KMEXIT:ADRESS=:ZPREG           % SET NEW ADDRESS
066546   FELLS: X:=RTREF
066547          IF SEG1=-1 THEN X.ACT1SEG FI        % IF SEG.NO. = -1 KEEP OLD SEG.NO.
066554          A=:MSEG1; CALL DECO; A=:STRA        % FIND START AND LENGTH OF SEGMENT
066557          T=:LA; X:=RTREF
066561          IF SEG2=-1 THEN X.ACT2SEG FI        % IF SEG.NO. = -1 KEEP OLD SEG.NO.
066566          A=:MSEG2; CALL DECO; T=:LB          % FIND START AND LENGTH OF SEGMENT
066571          % CHECK FOR OVERLAP
066571          IF A>STRA THEN IF A-LA<T GO ERRO
066577                    ELSE IF A+LB>T GO ERRO
066603          FI
066603          DMSEG=:RTREF.DACTSEG
066606          GO RETSTUPR
066607
066607   INTEGER STRA,LA,STRB,LB
066613   *)FILL
066626   % LOCAL SUBROUTINE TO VALIDATE PIT NUMBERS.
066626   LEGPIT:IF A=1 OR=2 OR=17 THEN EXIT FI  % RING 0/1 PROGRAMS ONLY IN PITS 1,2,17
066640          IF A><0 AND OLDPAG/\3 >= 2 THEN EXIT FI  % RING 2/3 PROGRAMS ANY PIT EXCEPT 0
066647          CALL 9ERRA(#94) % ILLEGAL PAGE INDEX TABLE
066651          GO RETXIT
066652
066652   INTEGER MSEG1, MSEG2
066654   DOUBLE DMSEG=MSEG1
066654   INTEGER POINTER LREG
066655

066655   % DECODE SEGMENT ELEMENT
066655   % ENTRY: A=SEGMENT NUMBER; X=RTREF
066655   % EXIT:  A=FIRST LOGICAL PAGE IN SEGMENT; T=NUMBER OF PAGES IN SEGMENT
066655   DECO:  IF A=0 THEN T:=0; EXIT FI
066660          T:=L=:"LREG"; IF A=X.RSEGM GO ERRIL
066665          CALL LEGSEG
066666          CALL SHRSOVERLAP
066667          X:=:B
066670          *LDASG SEGLE
066700          A=:T
066701          *LDASG LOGAD
066711          X:=:B
066712          GO LREG
066713
066713   % SUBROUTINE TO CHECK FOR LEGAL SEGMENT
066713   % SHOULD BE CALLES IN IOF OR WITH MONITOR LEVEL DISABLED.
066713   % ENTRY:     A=SEGMENT NUMBER
066713   % EXIT:      A=SEGMENT FLAG; D=SEGMENT NUMBER; X=SEGMENT TABLE ADDRESS
066713   % RETURN TO RETXIT IF ERROR
066713
066713   INTEGER TTTTT  % FOR SAVING T
066714
066714   0LEGSEG: IF A=0 GO ERRIL
066715   LEGSEG:  IF A>>X:=SGMAX OR A=X:=1 GO ERRIL
066723            A=:D*5SEGSIZE+SEGSTART=:X
066727            T=:TTTTT:=SEGTBANK
066731            *SGSTA@3 LDATX % A:=SGSTATUS
066732            IF A = 0 GO ERRNL
066733            *FLAG@3 LDATX % A:=FLAG
066734            T:=TTTTT
066735            IF A BIT 5INHB GO ERRNL
066737            EXIT
066740
066740   *)FILL
066751   ERRRIL:X:=:B;A:=D0   % ILLEGAL REENTRANT SEGMENT
066753   R15ERRD:
066753   ERRIL: CALL 9ERRA(#15); GO RETXIT                % ILL.SEGM.NO.
066756   ERRNL: A:=D; CALL 9ERRA(#16); GO RETXIT          % SEGMENT NOT LOADED
066762   ERRO:  A:=MSEG1; T:=MSEG2                        % OVERLAP
066764          CALL 9ERRA(#42); GO RETXIT
066767   ERRFUNC: CALL 9ERRA(#95); GO RETXIT              % ILLEGAL FUNCTION CODE
066772
066772   % CHECK FOR LEGAL SEGMENT NUMBER IN MON REENT/SREENT CALLED FROM BACKGROUND
066772   % PROGRAMS. ONLY SEGMENTS ON PIT 1 AND PIT 2 WITH PROTECTION RING ZERO
066772   % IS LEGAL
066772   %
066772   RLEGSEG: IF BACKGROUND><0 AND OLDPAGE/\3=0 THEN
066777                X:=:B; *LDASG LOGAD
067010                IF A/\1700><100 AND A><200 GO ERRRIL  % ILLEGAL PIT
067017                *LDASG SGSTA
067027                IF A/\3000><0 GO ERRRIL               % ILLEGAL RING
067031                X:=:B
067032            FI; EXIT
067033   RBUS
067043

067043   %=======================================================================
067043   %       MON SPCHG         CHANGE SEGMENT AND PIT
067043   %
067043   %      PERFORMS THE SAME FUNCTIONS AS MCALL AND MEXIT,
067043   %      BUT ALSO MAKES IT POSSIBLE TO CHANGE THE NORMAL
067043   %      AND ALTERNATIVE PAGE TABLES FOR THE PROGRAM.
067043   %      ONLY PRESENT TO OBTAIN COMPATABILITY WITH VSE AND
067043   %      EARLIER SINTRAN VERSIONS. ONLY ALLOWED WITH PITS 1 & 2.
067043   %
067043   %      PARAMETERS:
067043   %           D-REG BIT 15 IS SET IF MEXIT (MON 132) IS WANTED
067043   %                   IT IS RESET IF MCALL (MON 133) IS WANTED
067043   %
067043   %        IF MCALL: D BIT 2-3 CONTAIN NEW NORMAL PIT
067043   %                  D BIT 0-1 CONTAIN NEW ALTERNATIVE PIT
067043   %                  T LIKE MCALL
067043   %                    (POINTS TO ADDRESS AND SEGMENT NOS)
067043   %        RETURN:   T AND L LIKE MCALL
067043   %                  D CONTAINS OLD PAGE TABLES.
067043   %
067043   %        IF MEXIT: D CONTAINS D-REG FROM MCALL RETURN
067043   %                    (BUT BIT 15 SET)
067043   %                  T AND L FROM MCALL RETURN (LIKE MEXIT)
067043   %
067043   %
067043   SUBR SPCHG
067043
067043   SPCHG:
067043           IF X.ZDREG BIT 17 GO PMEXIT % D BIT 15 IS SET FOR MEXIT WITH PIT CHANGE
067046                                       % ELSE FOR MCALL WITH PIT CHANGE
067046
067046   PMCALL: A/\17; AD SHZ -2        % NEW PITS IN A BITS 0-1
067050           D SHZ -16               % AND D BITS 0-1
067051           IF A=T:=0 OR D=0 OR A=3 OR D=T GO ILLPIT
067063           A SHZ 13; D SHZ 7\/A    % ALIGN PITS FOR PCR
067066           X.OLDPAG=:X.ZDREG/\NACLEAR\/D=:X.OLDPAG    % MASK INTO SAVED ACTPRI
067073           GO MCALL                % CONTINUE IN MCALL
067074
067074   PMEXIT: A/\77600=:D             % OLD PITS IN BITS 7-16
067076           IF A/\74000=T:=0 OR A:=D/\3600=0 GO ILLPIT
067106           X.OLDPAG/\NACLEAR\/D=:X.OLDPAG   % MASK INTO SAVED ACTPRI
067112           GO MEXIT                % CONTINUE IN MEXIT
067113
067113   ILLPIT: A:=T; CALL 9ERRA(#94)   % ILLEGAL PAGE INDEX TABLE
067116           GO RETXIT
067117   RBUS
067130

067130   %==============================================================================
067130   % 36.6    (R)   M F I X   M U N F I X
067130
067130   %MONITOR CALLS: CALL FIX(SEGNO),CALL UNFIX(SEGNO)
067130   SUBR MOFIX,MUNFIX
067130   DISP 0; INTEGER SGADR=D1; DOUBLE OLDSGNO=D2; INTEGER ERFLAG=D4; PSID
067130
067130   MOFIX: CALL GET1; D0; CALL 0LEGSEG
067133          X=:SGADR:=:B
067135          IF A BIT 5DEMAND GO FAR ERRD
067137          IF A BIT 5FIXC GO RETU
067141          *LDASG SGSTA
067151          IF A BIT 5FIX OR A BIT 5SPTFIXED GO RETU
067155          *LDASG SEGLE
067165          IF A=0 GO FAR ERRNL
067167          A=:D
067170          IF A+FIXPAGES>FIXMAX GO FAR ERRF
067174          A=:FIXPAGES
067175          A:=D+MINSWPAGES; CALL CHNSWPAGES; GO FAR ERRF
067201          X=:B
067202          RTREF.DACTSEG=:OLDSGNO  % SAVE OLD SEGMENT NUMBERS
067205          D0=:D:=0;AD=:X.DACTSEG  % USE THE SEGMENT TO BE FIXED INSTEAD
067211          "STUPR"; *IRW MLEVB DP
067213          MLEV; *MST PID; MST PIE
067216   %RETURN WITH CHANGED SEGMENT
067216          MLEV; *MCL PIE      % DISABLE MONITOR LEVEL
067220          OLDSGNO=:X.DACTSEG  % CHANGE BACK
067222          "1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067225   *"8FLMN                                % FOR FLOMEN FOX FIXING SEGMENT 3
"067225   NTSPIT:SLEV; *MST PID; ION             % TO GET SEGMENT OUT OF PAGE TABLES.
067230          X:=SGADR:=:B
067232          *LDASG SGSTA
067242          A BONE 5FIX; *STASG SGSTA
067253          *LDASG SEGLI
067263          IF A=0 THEN CALL ERRFATAL FI    % CHECK THAT SEGMENT IS IN SEGMENT LIST
067265          X=:D
067266          *LDXSG BPAGL
067275          T:=CORMBANK
067276          DO WHILE X><0       % FOR ALL PAGES IN MEMORY
067277              *PROTE@3 LDATX
067300              A BONE 5FIX     % SET 5FIX BIT IN PROTECT WORD
067301              *PROTE@3 STATX
067302              *PAGLI@3  LDXTX
067303          OD
067304          X:=B; B:=D
067306          A:="1OUTSEGLINK"        % LINK SEGMENT OUT OF SEGMENT LIST
067307          *IOF; IRW SLEVB DP      % MUST BE DONE ON SEGADM LEVEL
067311          SLEV; *MST PID; ION
067314          GO RETSTUPR
067315
067315   RETU:  B:=X; GO RET    % RESTORE B AND END MONITOR CALL
067317
067317   *)FILL
067341   MUNFIX: CALL GET1; IF D0=0 OR A>>SGMAX GO FAR ERRIL
067347          A*5SEGSIZE+SEGSTART
067351          B=:X:=A; *LDASG FLAG
067363          A=:T; *LDASG SGSTA
067374          IF A BIT 5SPTFIXED GO FAR ERRPF
067376          IF A BIT 5FIX OR T BIT 5FIXC THEN
067402              A BZERO 5FIX; *STASG SGSTA
067413              A:=T BZERO 5FIXC; *STASG FLAG
067425              IF B=NSEGA OR B=NSEGB THEN
067433                  "1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067436                  SLEV; *MST PID; ION             % TO GET SEGMENT OUT OF PAGE TABLES.
067441              FI
067441              *LDASG SEGLI
067451              IF A><0 THEN CALL ERRFATAL FI
067453              X:=:B
067454              DO  A:=D0       % SEGMENT NUMBER.
067455                  CALL UREMSG % REMOVE SEGMENT FROM PIT, SKIP RETURN IF NOT ENTERED.
067456              OD
067457              GO L1; *)FILL
067474   L1:        X:=:B=:D
067476              *LDXSG BPAGL
067505              T:=CORMBANK
067506              DO WHILE X><0       % FOR ALL PAGES IN MEMORY
067507                  *PROTE@3 LDATX
067510                  A BZERO 5FIX    % RESET 5FIX BIT IN PROTECT WORD
067511                  *PROTE@3 STATX
067512                  *PAGLI@3  LDXTX
067513              OD
067514              *LDASG SEGLE        % CHECK NUMBER OF PAGES FIXED.
067524              IF A- +FIXPAGES < 0 THEN A:=0; K:="1"
067531                                  ELSE       K:="0" FI
067533              A=:FIXPAGES
067534              B=:X:=D
067536              A:="1INSEGLINK"     % LINK SEGMENT INTO LINK (ON SEGADM LEVEL)
067537              *IOF; IRW SLEVB DP
067541              SLEV; *MST PID; ION
067544              IF K THEN X:=B; GO ERRF FI
067550              IF X=NSEGA OR X=NSEGB GO RETSTUPR
067556          ELSE
067557              B:=:X
067560          FI
067560          GO RET
067561   *)FILL
067571
067571   ERRNL: B:=X; D0; CALL 9ERRA(#16); GO RETXIT    % EMPTY SEGMENT (NOT LOADED)
067576   ERRD:  B:=X; D0; CALL 9ERRA(#17); GO RETXIT    % FIXING DEMAND
067603   ERRF:  B:=X; D0; CALL 9ERRA(#18); GO RETXIT    % TOO MANY FIXED
067610   ERRIL:       D0; CALL 9ERRA(#15); GO RETXIT    % ILLEGAL SEGMENT NUMBER
067614   ERRPF: B:=X; D0; CALL 9ERRA(#96); GO RETXIT    % SEGMENT IS FIXED IN PIT
067621   RBUS
067623

067623   %==============================================================================
067623   % 36.8   (R)    R E E N T
067623
067623   % MONITOR CALL REENT(SEGNO) - ATTACH REENTRANT SEGMENT
067623   SUBR REENT,IMREENT
067623   DISP 0; INTEGER RESEG=D1; PSID
067623
067623   REENT: CALL GET1
067624   IMREENT:"1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067627           SLEV; *MST PID; ION
067632           IF D0><0 THEN
067634               CALL LEGSEG
067635               X=:RESEG; IF A NBIT 5DEMAND GO ERRD
067640               IF X=NSEGA OR X=NSEGB GO RETSTUPR
067646               CALL RLEGSEG
067647               GO NEWWAY
067650               CALL WIPCHECK
067651   NEWWAY:     X:=NSEGA:=:B; *LDASG FLAG
067663               X:=:B; T:=D0; CALL SHRSOVERLAP
067666               X:=NSEGB:=:B; *LDASG FLAG
067700               X:=:B; T:=D0; CALL SHRSOVERLAP
067703               NSEGA; T:=RESEG; CALL OVERLAP
067706               NSEGB; T:=RESEG; CALL OVERLAP
067711           FI
067711           X:=RTREF; CALL CLRBMAP
067713   OUT:    D0=:RTREF.RSEGM; GO RETSTUPR
067717
067717   ERRD:   CALL 9ERRA(#45); GO RETXIT  % NOT DEMAND SEGMENTS
067722   *)FILL
067741   %=====================================================================
067741   %
067741   %      W I P C H E C K         CHECK WHETHER REENTRANT SEGMENT IS
067741   %                              MODIFIED AND WRITE IT BACK BEFORE USING IT.
067741   %                              CALLED WITH X=SEGMENT TABLE POINTER.
067741   DISP 0;INTEGER POINTER LREG=D2; PSID
067741
067741   WIPCHECK:
067741          A:=L=:"LREG"
067743          T:=SEGTBANK; *BPAGL@3 LDXTX             % GET PAGE LIST OF REENTRANT SEGMENT.
067745          T:=CORMBANK
067746          DO WHILE X><0                           % FOR WHOLE PAGE LIST DO
067747              *PROTE@3 LDATX
067750              IF A BIT 5WIP THEN                  % IF RSEGM HAS MODIFIED PAGE THEN
067752                  A:=D0; X:=RESEG; CALL WSEGX     % WRITE SEGMENT TO DISK.
067755                  GO LREG                         % CONTINUE WITH MON REENT.
067756              FI
067756              *PAGLI@3 LDXTX                      % GET NEXT PAGE.
067757          OD
067760          GO LREG                                 % CONTINUE WITH MON REENT
067761
067761   RBUS
067764

067764   %===========================================================================
067764   %
067764   %       E N T S G       MON ENTSG   ENTER A FIXED SEGMENT INTO A PAGE TABLE
067764   %
067764   %       PARAMETERS:     A - PARAMETER LIST
067764   %                               SEGMENT NUMBER
067764   %                               PAGE INDEX TABLE
067764   %                               INTERRUPT LEVEL
067764   %                               START ADDRESS
067764   %
067764   %       RETURN:         A - STATUS
067764   %                           0  - OK
067764   %                           <0 - ERROR:
067764   %                                -1  : ATTEMPT TO ENTER TOO MANY SEGMENTS
067764   %                                -2  : ILLEGAL SEGMENT NUMBER
067764   %                                -3  : ILLEGAL PAGE INDEX TABLE SPECIFIED
067764   %                                -4  : SEGMENT IS NOT FIXED
067764   %                                -5  : ILLEGAL INTERRUPT LEVEL
067764   %                                -6  : WANTED PIT ENTRY WAS IN USE
067764   %
067764   SUBR ENTSG
067764   %               GLOBAL VARIABLES AND SYMBOLS
067764   %
067764   %               ESMAX   : MAX NUMBER OF SEGMENTS THAT MAY BE ENTERED.
067764   %               ESCNT   : NUMBER OF SEGMENTS CURRENTLY ENTERED.
067764   %               ESDATA  : ARRAY OF SEGMENTS ENTERED (3 WORDS PER SEGMENT)
067764   %               ESBANK  : PHYSICAL BANK OF ESDATA.
067764   %               ESEDATA : END OF ESDATA.
067764   %
067764   %               SGMAX   : HIGHEST POSSIBLE SEGMENT NUMBER
067764   %
067764   %               LAYOUT OF ESDATA ENTRIES
067764   DISP 0
067764       INTEGER ESSGNO          % NUMBER OF ENTERED SEGMENT.
067764       INTEGER ESPTLV          % PIT (LEFT BYTE) AND LEVEL (RIGHT BYTE) OF SEGMENT
067764       INTEGER ESADR           % START ADDRESS FOR THIS LEVL
067764   PSID
067764
067764   DISP 0
067764       INTEGER SGNO=D0         % SEGMENT NUMBER    (PARAMETER)
067764       INTEGER PITNO=D1        % PIT NUMBER        (PARAMETER)
067764       INTEGER ILNO=D2         % INTERRUPT LEVEL   (PARAMETER)
067764       INTEGER STAD=D3         % START ADDRESS     (PARAMETER)
067764       INTEGER SGAD=D4         % SEGMENT TABLE ADDRESS
067764       TRIPLE  ESPAR=D5        % PARAMETER TO DOENTSG ROUTINE
067764       INTEGER ES1PAR=D5       % FIRST WORD OF ESPAR
067764       DOUBLE  ES23PAR=D6      % SECOND AND THIRD WORD OF ESPAR
067764   PSID
067764
067764   ENTSG:  CALL GET4                       % GET PARAMETERS AND DISABLE MLEV
067765           IF ESCNT >= ESMAX GO FAR ERRMX  % TOO MANY SEGMENTS ENTERED
067771           IF SGNO >> SGMAX GO FAR ERRSG   % ILLEGAL SEGMENT NUMBER
067775           A*5SEGSIZE+SEGSTART=:SGAD       % COMPUTE SEGMENT TABLE ADDRESS
070000           IF PITNO><6 AND <=7 OR >>17 GO FAR ERRPT% ILLEGAL PAGE INDEX TABLE (MUST BE 10B TO 17B OR 6)
070012           T:=SEGTBANK; X:=SGAD; *SGSTA@3 LDATX    % A:=SGAD.SGSTA
070015           IF A NBIT 5FIX GO FAR ERRFX     % SEGMENT MUST BE FIXED
070017           IF ILNO<5 OR >11 GO FAR ERRLV   % INTERRUPT LEVEL MUST BE IN 5 TO 11 (OCT)
070026           X:="ESPAR"+B                    % X POINTS TO ESPAR.
070030           SGNO=:X.ESSGNO              % BUILD ESDATA ENTRY IN ESPAR (SEGNO)
070032           PITNO SH 10 +ILNO=:X.ESPTLV %                     (PIT AND LEVEL)
070036           STAD=:X.ESADR               %                     (START ADDRESS)
070040           T:= ESBANK
070041           A:=ESEDATA=:L
070043           X:=ESDATA                   % MAKE IT POSSIBLE TO ENTER A SEGMENT
070044           DO                          % ON SEVERAL INTERRUPT LEVEL
070044              *LDDTX
070045              IF A-SGNO=0 THEN
070047                  D SHZ -10 =: A
070051                  IF A-PITNO= 0  THEN
070053                     AD:= ES23PAR
070054                     GO DOLVENT        % GO IN ROUTINE DOENTSG
070055                  FI
070055              FI
070055              X+3
070056                  WHILE X << L
070060           OD
070061
070061           PITNO SH 7+174000=:L        % POINTER TO PIT.
070065                                       % CHECK WHETHER PIT ENTRIES ARE USED OR NOT.
070065           T:=SEGTBANK; X:=SGAD; *BPAGL@3 LDXTX    % GET PAGE LIST OF SEGMENT
070070           T:=CORMBANK
070071           DO WHILE X >< 0             % TO END OF PAGE LIST
070072               *LOGPA@3 LDATX          % FIND LOGICAL PAGE NUMBER OF PAGE
070073               X=:D                    % SAVE X IN D
070074               A/\77 SH 1\/L=:X        % COMPUTE PIT POINTER FOR THIS PAGE
070100               T:=0; *LDATX            % READ PIT ENTRY
070102               IF A >< 0 GO ERRPIT     % PIT WAS NOT EMPTY
070103               X:=D; T:=CORMBANK       % RESTORE X
070105               *PAGLI@3 LDXTX          % NEXT PAGE IN LIST
070106           OD
070107           GO L1; *)FILL               % PIT ENTRIES ARE NOT USED
070133   L1:     TAD:=ESPAR                  % PARAMETERS FOR DOENTSG
070134           CALL DOENTSG                % SET UP PIT, PIE, PCR AND P-REG.
070135           T:=ESBANK; X:=ESDATA        % TX POINTS TO ESDATA ARRAY
070137           ESEDATA=:D                  % END OF ESDATA
070141           DO                          % FIND A FREE ENTRY IN ESDATA
070141               *LDATX                  % READ THE FIRST WORD OF AN ENTRY
070142           WHILE A><0                  % WHILE ENTRY TAKEN
070143               X+3                     % NEXT ENTRY
070144           WHILE X << D OD             % UNTIL END OF TABLE
070147           IF X>>=D THEN CALL ERRFATAL FI % AN ENTRY SHOULD ALWAYS BE FOUND HERE
070152           A:=ES1PAR;   *STATX 00      % MOVE ESPAR TO ESDATA
070154           AD:=ES23PAR; *STDTX 10
070156           MIN ESCNT                   % INCREASE NUMBER OF USED ESDATA ENTRIES
070157           0=:ZAREG                    % INDICATE SUCCESSFUL COMPLETION
070160           GO RET                      % END OF MONITOR CALL
070161
070161   % ERROR HANDLING
070161   %
070161   ERRMX:  -1; GO ERRRR    % ATTEMPT TO ENTER TOO MANY SEGMENTS
070163   ERRSG:  -2; GO ERRRR    % ILLEGAL SEGMENT NUMBER
070165   ERRPT:  -3; GO ERRRR    % ILLEGAL PAGE INDEX TABLE SPECIFIED
070167   ERRFX:  -4; GO ERRRR    % SEGMENT IS NOT FIXED
070171   ERRLV:  -5; GO ERRRR    % ILLEGAL INTERRUPT LEVEL
070173   ERRPIT: -6              % WANTED PIT ENTRY WAS IN USE
070174
070174   ERRRR:  A=:ZAREG        % SET ERROR CODE IN A REGISTER
070175           GO RET          % END OF MONITOR CALL
070176   RBUS
070205

070205   %=======================================================================
070205   %
070205   %       U R E M S G     CALLED FROM UNFIX TO REMOVE SEGMENT FROM PITS
070205   %                       BEFORE UNFIXING.
070205   %
070205   %       R E M S G       MON SGMTY
070205   %                       FUNCTION 4: REMOVE SEGMENT (ENTERED W/ENTSG) FROM PIT
070205   %
070205   %       PARAMETERS:     T - PARAMETER LIST
070205   %                              FUNCTION (4)
070205   %                              ZERO (0)
070205   %                              SEGMENT NUMBER
070205   %                              ZERO (0)
070205   %                              ZERO (0)
070205   %
070205   %       RETURN:         A - STATUS
070205   %                           0  - OK
070205   %                           <0 - ERROR:
070205   %                                -1  : SEGMENT NOT ENTERED
070205   %                                -2  : ILLEGAL SEGMENT NUMBER
070205   %                                -3  : NO SEGMENTS ENTERED
070205   %                                -4  : ILLEGAL PARAMETER
070205   %
070205   SUBR XREMSG, UREMSG
070205
070205   DISP 0
070205       INTEGER SGNO=D2     % SEGMENT NUMBER (PARAMETER)
070205       INTEGER SGAD=D5     % SEGMENT TABLE ADDRESS
070205       INTEGER LREG=D6     % RETURN ADDRESS IF UREMSG
070205       INTEGER SAVX=D7     % SAVED X-REG IN UREMSG
070205   PSID
070205
070205   UREMSG: A=:D:=L=:LREG               % D:=SEGNO, SAVE RETURN ADDRESS.
070210           X=:SAVX                     % SAVE X-REG.
070211           IF T:=ESCNT=0 GO UERR       % NO SEGMENTS ENTERED, RETURN.
070214           A:=D                        % RESTORE A.
070215           GO FELLS
070216
070216   XREMSG: 0=:LREG                     % PARAMETERS ARE FETCHED AND MLEV IS DISABLED BY SGMTY.
070217           IF D1><0 OR D3><0 OR D4><0 GO ERRIL    % ILLEGAL PARAMETER.
070226           IF ESCNT=0 GO ERRNS         % NO SEGMENTS ENTERED.
070230           SGNO=:D                     % SEGMENT NUMBER IS HELD IN D-REGISTER.
070232           IF A>SGMAX GO ERRSG         % VERIFY SEGMENT NUMBER.
070235
070235   FELLS:  A*5SEGSIZE+SEGSTART=:SGAD   % COMPUTE SEGMENT TABLE ADDRESS.
070240           ESEDATA=:L                  % L POINTS TO END OF ESDATA.
070242           T:=ESBANK; X:=ESDATA        % TX POINTS TO ESDATA.
070244           DO                          % LOOP THROUGH ESDATA.
070244               *LDATX 00               % READ FIRST WORD OF EACH ENTRY.
070245           WHILE A >< D                % UNTIL WANTED ENTRY FOUND.
070247               X+3                     % NEXT ENTRY
070250           WHILE X << L                % UNTIL END OF TABLE
070252           OD
070253           IF A = D THEN               % IF ENTRY WAS FOUND
070255               *LDATX 10; STZTX 00     % READ PIT AND LEVEL, RESET SEGMENT NUMBER.
070257               A SHZ -10               % SEPARATE PIT NUMBER.
070260               A SHZ 7 + 174000=:D     % COMPUTE PIT POINTER.
070263               T:=SEGTBANK; X:=SGAD    % TX POINTS TO SEGMENT ENTRY.
070265               *BPAGL@3 LDXTX          % GET PAGE LIST.
070266               CALL DOREMSG            % CLEAR PIT FOR THIS SEGMENT.
070267               ESCNT-1=:ESCNT          % DECREASE NUMBER OF ENTERED SEGMENTS.
070272               IF A<0 THEN CALL ERRFATAL FI % SHOULD NEVER BECOME NEGATIVE.
070274               IF LREG><0 GO UOK       % UREMSG OK.
070276               0=:ZAREG                % OK
070277           ELSE
070300               IF LREG><0 GO UERR      % UREMSG ERROR.
070302               -1=:ZAREG               % SEGMENT NOT PREVIOUSLY ENTERED.
070304           FI
070304           GO RET                      % END OF MONITOR CALL
070305
070305   % ERROR HANDLING
070305   %
070305   ERRSG:  -2; GO ERRRR    % ILLEGAL SEGMENT NUMBER
070307   ERRNS:  -3; GO ERRRR    % NO SEGMENTS ENTERED
070311   ERRIL:  -4              % ILLEGAL PARAMETER
070312
070312   ERRRR:  A=:ZAREG        % SET ERROR CODE IN A-REGISTER
070313           GO RET          % END OF MONITOR CALL
070314
070314                           % UREMSG RETURNS, CALLED WITH RETURN ADDRESS IN A.
070314   UERR:   A+1             % SEGMENT NOT ENTERED, SKIP RETURN.
070315   UOK:    X:=SAVX; A=:P   % SEGMENT REMOVED, NORMAL RETURN.
070317   RBUS
070333

070333   *"8SREE
"070333

070333   %==============================================================================
070333   %      (R)      S G A N D   S G O R
070333   %
070333   % SUBROUTINES TO THE SEGMENT-WRITE-PERMIT AND SEGMENT-WRITE-PROTECT COMMANDS
070333   % ENTRY: T=SEGMENT TABLE ENTRY
070333   %
070333   SUBR SGAND,SGOR
070333
070333   SGAND: K:="0"; GO FELLS
070335   SGOR:  K:="1"
070336
070336   FELLS: MLEV; *MCL PIE
070340
070340          "1XCSEGS"; *IOF; IRW SLEVB DP   % CLEAR USERS SEGMENTS FROM PIT
070343          SLEV; *MST PID; ION
070346
070346          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR S3SEG FROM PIT
070351          SLEV; *MST PID
070353          S3SEG; *ION
070355          0=:S3SEG
070356
070356          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR FILE SYSTEM FROM PIT
070361          SLEV; *MST PID
070363          FILSEGM; *ION
070365   *"8RFAC
"070365          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR RFA SEGMENT FROM PIT
070370          SLEV; *MST PID
070372          FUSEGM; *ION
070374   *"8N500
"070374          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR ND500 SEGMENT FROM PIT
070377          SLEV; *MST PID
070401          5NSEGM; *ION
070403   *"
"070403          B=:D:=T
070405          *LDASG SGSTA
070415          IF K THEN A BONE 5WPM ELSE A BZERO 5WPM FI
070422          *STASG SGSTA
070432          *LDXSG BPAGL
070441          B:=D
070442          T:=CORMBANK
070443          DO WHILE X><0
070444              *PROTE@3 LDATX
070445              IF K THEN
070447                  A BONE 5WPM
070450              ELSE
070451                  A BZERO 5WPM
070452              FI
070452              *PROTE@3 STATX
070453              *PAGLI@3 LDXTX
070454          OD
070455
070455          T:=SEGTBANK
070456          X:=FILSEGM; *BPAGL@3 LDXTX
070460          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER FILE SYSTEM INTO PIT
070463          SLEV; *MST PID; ION
070466   *"8RFAC
"070466          X:=FUSEGM; *BPAGL@3 LDXTX
070470          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER RFA SEGMENT INTO PIT
070473          SLEV; *MST PID; ION
070476   *"8N500
"070476          X:=5NSEGM; *BPAGL@3 LDXTX
070500          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER ND500 SEGMENT INTO PIT
070503          SLEV; *MST PID; ION
070506   *"
"070506          "STUPR"; *IOF; IRW MLEVB DP     % SET UP USER SEGMENTS.
070511          MLEV; *MST PIE; MST PID; ION
070515          EXIT
070516   RBUS
070530
070530
070530   %============================================================================
070530   % 37.18   (R)   A T R N S E G
070530   %
070530   % SUBROUTINE ON APPLICATION LEVEL TO START
070530   % TRNSEG ON MONITOR LEVEL
070530   %
070530   % ENTRY:     A=NUMBER OF PAGES TO TRANSFER
070530   %            X=ADDRESS OF CORMAP ENTRY
070530   %            D=READ/WRITE FLAG
070530   %            T=SEGMENT ADDRESS
070530   %
070530   SUBR ATRNSEG
070530   INTEGER CT,CA,CD,CX,CB; TRIPLE CTAD=CT
070535   INTEGER POINTER CLR
070536   ATRNSEG: TAD=:CTAD; X=:CX:=L=:"CLR":=B=:CB
070544   LOOP:  *IOF
070545          "XTRNSEG"; *IRW SLEVB DP
070547          CT; *IRW SLEVB DB
070551          CX; *IRW SLEVB DX
070553          CD; *IRW SLEVB DA
070555          CA; *IRW SLEVB DD
070557          "SLEV+MLEV";*MST PID; MST PIE; ION
070563          TAD:=CTAD; X:=CB=:B:=CX
070567          GO CLR
070570   RBUS
070571
070571   %==============================================================================
070571   %
070571   %   (R)   INTERFACE FOR CALLING XOVERLAP ON SLEV.
070571   %
070571   SUBR OVERLAP
070571   OVERLAP:
070571          *IOF
070572          *IRW SLEVB DA
070573          A:=T; *IRW SLEVB DT
070575          A:="XOVERLAP"
070576          *IRW SLEVB DP
070577          SLEV; *MST PID; ION
070602          EXIT
070603   RBUS
070604
070604
070604   %==============================================================================
070604   %
070604   %   S H R S O V E R L A P          SHADOW & REENTRANT SEGMENTS OVERLAP
070604   %
070604   % ENTRY:   A=SEGMENT FLAG OF SHADOW SEGMENT
070604   %          X=SEGMENT TABLE ADDRESS OF SHADOW SEGMENT
070604   %          T=SEGMENT NUMBER OF REENTRANT SEGMENT
070604   % EXIT:    NO OVERLAP
070604   %
070604   % IF ERROR: RETURN TO RETXIT (TERMINATE CALLING PROGRAM)
070604   %
070604   SUBR SHRSOVERLAP
070604   INTEGER XREG,CSTRA,CLA; DOUBLE CSTLA=CSTRA
070607
070607   SHRSOVERLAP:
070607          IF A BIT 5DEMAND OR T=0 OR X=0 THEN EXIT FI
070616          X=:XREG
070617          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *LOGAD@3 LDDTX
070625          AD=:CSTLA               % START AND LENGTH
070626          X:=XREG; *LOGAD@3 LDDTX
070630          IF A>CSTRA THEN
070633              IF A-CLA<T GO 45ERR
070636          ELSE
070637              IF A+D>T GO 45ERR
070642          FI
070642          EXIT           % OK, NO OVERLAP
070643
070643   % ERROR, REENTRANT SEGMENT OVERLAP NONDEMAND SEGMENT
070643   45ERR: CALL 9ERRA(#45); GO RETXIT
070646
070646   RBUS
070653
070653   %=============================================================================
070653   %       (R)     S S S W P
070653   %
070653   % RT-PROGRAM RESERVING THE SWAPPING-SEMAPHORE (CLFIE) AND WAITING FOR
070653   % THE DISC ON BEHALF OF THE SWAPPING-REQUESTING PROGRAM
070653   % THE SWAPPING-REQUESTING PROGRAM WILL BE SET IN SWAPPING-WAIT
070653   %
070653   SUBR SSSWP
070653   INTEGER XREGG
070654   SSSWP: *IOF
070655          "XRTEX"; *IRW MLEVB DP
070657          MLEV; *MST PID; ION
070662          GO SSSWP
070663   RBUS
070665

070665   %===========================================================================
070665   %            S P L R E E
070665   % MON SPLREE(SGNO,FP1,NP1,FP2,LP2,FLAG)
070665   %            FP1= FIRST PAGE IN LOG.AREA 1 TO OVERLAP BACKGROUND SEGMENT
070665   %            NP1= NUMBER OF PAGES IN AREA 1
070665   %            FP2= FIRST PAGE IN LOG.AREA 2 TO OVERLAP BACKGROUND SEGMENT
070665   %            NP2= NUMBER OF PAGES IN AREA 2
070665   %            FLAG><0: CLEAR PAGE-OWNER TABLE
070665   %
070665   SUBR SPLRE
070665   DISP 26                      % D5+1
070665   INTEGER CBSGNO,CPOTADDR,CCFP,CCLP,CORSEGM,CCBMX,CCPOTADDR,CREBMAP,CURRX
070665   INTEGER NEXTX=CCPOTADDR,CBPIDX=CPOTADDR
070665   INTEGER CFP1=D1,CLP1=D2,CFP2=D3,CLP2=D4
070665   DOUBLE DDDS1=CFP1,DDDS2=CFP2,DDDD0=D0,DDDD2=D2,DDDD4=D4,CCLMS=CCFP
070665   PSID
070665
070665   DISP 0; TRIPLE 3BM0,3BM3; DOUBLE 2BM6; PSID
070665
070665   % COMPUTE ADDRESSES AND SIZES USED BY SEVERAL ROUTINES
070665   %
070665   GTVALUES:
070665          AD=:CCLMS
070666          T:=D-A; AD SHZ -4; A+CREBMAP=:CCBMX
070673          AD SHZ 7; A/\170=:D
070676          CCFP+CPOTADDR=:CCPOTADDR
070701          EXIT
070702
070702   % FOR ALL PAGES IN PREVIOUS LOGICAL ADDRESS AREA DO
070702   %      IF BIT OF CORRESPONDING PAGE IN BITMAP IS SET THEN
070702   %         SET CORRESPONDING POT-TABLE ENTRY EQUAL CURRENT REENTRANT SEGMENT
070702   %      FI
070702   % OD
070702   %
070702   INTEGER POINTER LREG=?
070702   INTEGER ENDINSTR(0); *BSKP ONE 170 DT
070703   INTEGER CINSTR(0); *BSKP ONE 00 DT
070704   STPOTTABLE: T:=L=:"LREG"; CALL GTVALUES
070707           T=:L; A:=CINSTR; D\/A
070712           DO WHILE L>>0                            % FOR ALL BITMAP LOCATIONS DO:
070714              X:=CCBMX;T:=0;*LDATX
070717              A=:T
070720              IF T><0 THEN                    % IF UNEQUAL ZERO
070722                  *EXR SD                     % TEST EACH BIT
070723                  GO NOTSET                   % DON'T CHANGE POT IF BIT NOT SET
070724                  A:=CORSEG                   % A = RSEGM FROM RT-DESC
070725                  T:=SREBBANK                 % T = BANK OF POT
070726                  X:=CCPOTADDR                % X = ADDRESS OF POT ENTRY
070727                  *STATX                      % STORE IT
070730   NOTSET:        MIN CCPOTADDR; 0/\0         % INCREMENT POT POINTER
070732                  L-1
070733                  T:=10
070734                  IF D+T>>ENDINSTR GO INELSE  % MODIFY BSKP INSTRUCTION TO TEST FOR NEXT BIT
070740             ELSE % BITMAP WORD IS 0
070741                  A:=D SHZ -3/\17; T:=20-A    % T = NUMBER OF APPLICABLE BITS IN THIS WORD
070746                  L-T                         % DECREASE LOOP COUNTER
070747                  CCPOTADDR+T=:CCPOTADDR      % INCREASE POT POINTER
070752   INELSE:        CINSTR=:D; MIN CCBMX        % MAKE READY TO TEST NEXT BITMAP WORD
070755             FI
070755           OD
070756           GO LREG
070757
070757   INTEGER CBSET(0); *BSET ZRO 00 DA
070760   INTEGER LBSET(0); *BSET ZRO 170 DA
070761   INTEGER POINTER LREG
070762   MBCLBITS:T:=L=:"LREG"; CALL GTVALUES
070765          T=:L; A:=CBSET; D\/A
070770          DO WHILE L><0                       % FOR ALL PAGES IN LOGICAL AREA DO:
070772              X:=CCPOTADDR; T:=SREBBANK; *LDATX   % READ A WORD FROM POT-TABLE
070775              IF A-D0><0 THEN                     % IF UNEQUAL SEGMENT NO IN PARAMETERLIST
070777                  A:=CBSGNO
071000                  *STATX                          % UPDATE POT WITH BG SEGM
071001                  X:=CCBMX; T:=0                  % AND BITMAP
071003                  *LDATX; EXR SD; STATX           % SET THE RESPECTIVE BIT TO 0
071006              FI
071006              T:=10
071007              IF D+T>>LBSET THEN                  % IF LAST BIT IN THIS LOC. HAS BEEN SET
071013                  CBSET=:D; MIN CCBMX; 0/\0       %   MAKE READY FOR THE NEXT ONE
071017              FI
071017              MIN CCPOTADDR; 0/\0
071021              L-1
071022          OD                                  % END FOR
071023          GO LREG
071024   *)FILL
071027
071027   DOUBLE ALLONES=?
071027
071027   CCHLIMS: D+A; IF C OR A>>200 OR D>>T GO CR15ERRD
071037            EXIT
071040
071040   CR15ERRD: D0; GO R15ERRD
071042
071042   INTEGER SVDFLAG
071043   ESPLRE: IF SVDFLAG NBIT 5IESC THEN
071046              CALL GETDATAFIELD; *IOF
071050              T:="DFLAG"; CALL XGTDFADDR
071052              A BZERO 5IESC
071053              T:="DFLAG"; CALL XSTDFADDR
071055              *ION
071056           FI
071056           GO RETSTUPR
071057   *)FILL
071066
071066   SPLRE:  CALL GET6
071067           "BFIELD".BPIUSINDX=:CBPIDX                         % GET BP IDX BEFORE CLEARING PITS
071072           X.TTIFIELD.DFLAG=:SVDFLAG BONE 5IESC =:X.DFLAG     % DISABLE ESCAPE AND REMEMBER ESCAPE STATE.
071077           "1XCSEGS"; *IOF; IRW SLEVB DP                      % CALL XCSEGS ON SEGADM LEVEL
071102           SLEV; *MST PID; ION
071105           RTREF.SEGM2+1=:CBSGNO                              % GET BACKGROUND SEGMENT NO (SYS.SEGM.+1)
071111           IF A*5SEGSIZE+SEGSTART><NSEGB GO RETSTUPR          % IF UNEQUAL NSEGB START THEN SOMETHING WRONG, RETURN
071116           CBPIDX*POTESIZE+SREBADDR=:CPOTADDR                 % CPOTADDR = POINTER TO POT-ENTRY
071122           RTREF.RSEGM=:CORSEGM                               % SAVE REENTRANT SEGMENT NUMBER
071125           X.RTDLGADDR+5BITMAP=:CREBMAP
071130           IF D0=0 AND CORSEGM=0 THEN
071134              X:=NSEGB; CBSGNO; CALL WSEGX                    % WRITE SHADOW SEGMENT BACK
071137           FI
071137           IF D0><0 THEN                                      % IF SEGMENT NUMBER UNEQUAL O
071141              CALL LEGSEG; IF A NBIT 5SREEP GO CR15ERRD       % LEGAL SEGMENT ? DEMAND SEGMENT?
071144              T:=SEGTBANK; *SGSTA@3 LDATX
071146              IF A SHZ -11/\3><0 GO CR15ERRD                  % RING ><0 ?
071151              *LOGAD@3 LDATX
071152              IF A SHZ -6/\17<1 OR A>2 GO CR15ERRD      % PAGE TABLE MUST BE 1 OR 2
071162           FI
071162           AD:=DDDS1; CALL CCHLIMS; AD=:DDDS1                 % LOGICAL AREA 1 TOO LARGE?
071165           AD:=DDDS2; CALL CCHLIMS; AD=:DDDS2                 % LOGICAL AREA 2 TOO LARGE?
071170           GO OVFI; *)FILL
071210   OVFI:   IF D5><0 THEN                                      % IF POT-ENTRY FOR THIS PROGRAM IS TO BE CLEARED
071212              X:=CPOTADDR; A:=X+200=:L                        %    X POINTS TO START OF POT-ENTRY, L POINTS TO THE NEXT
071216              CBSGNO=:D; T:=SREBBANK
071221              DO WHILE X><L                                   %    FOR ALL BYTES IN THE POT-ENTRY
071223                 *STDTX; AAX 2                                %    FILL IN BACKGROUND SEGMENT NUMBER
071225              OD;
071226           ELSE
071227              IF CORSEGM><0 THEN
071231                 X:=CPOTADDR; T:=SREBBANK; *AAX 177; LDDTX 10 % AD:=<T,X+200> PREVIOUS LOG. AREA
071235                 CALL FAR STPOTTABLE
071236                 X:=CPOTADDR; T:=SREBBANK; *AAX 177; LDDTX 30 % AD:=<T,X+202> PREVIOUS LOG. AREA
071242                 CALL FAR STPOTTABLE
071243              FI
071243           FI
071243           X:=CREBMAP;AD:=ALLONES;T:=0
071246           *STDTX; STDTX 20; STDTX 40; STDTX 60               % SET WHOLE BITMAP TO 1
071252           IF D0><0 THEN
071254              AD:=DDDS1; CALL FAR MBCLBITS
071256              AD:=DDDS2; CALL FAR MBCLBITS
071260           FI; GO L1; *)FILL
071265
071265
071265   DOUBLE ALLONES(0); DATA(-1,-1)
071267   INTEGER POINTER PPBPAG1:=BPAG1
071270   INTEGER CBSKP(0); *BSKP ZRO 00 DT
071271
071271   L1:     AD:=DDDS1; T:=SREBBANK; X:=CPOTADDR; *AAX 177; STDTX 10 % AD=:<T,X+200> SET PREVIOUS LOG. AREA
071276           T:=100; A+T; D+T; AD=:DDDS1
071302           AD:=DDDS2; T:=SREBBANK; *STDTX 30                       % AD=:<T,X+202> SET PREVIOUS LOG. AREA
071305           T:=100; A+T; D+T; AD=:DDDS2
071311           IF D0=0 GO FAR ENDIF         % IF D0><0 THEN
071314              B=:L
071315              X:=NSEGB
071316              T:=SEGTBANK; *BPAGL@3 LDXTX
071320              DO WHILE X><0       % FOR ALL PAGES IN BACKGROUND SEGMENT DO
071321                  *LDACM PAGLI
071327                  A=:NEXTX; X=:CURRX
071331                  *LDACM LOGPA
071337                  IF A>=CFP1 AND A<CLP1 GO COVERLAP
071345                  IF A<CFP2 OR A>=CLP2 GO NOVERLAP
071353                  GO COVERLAP;    *)FILL
071361   COVERLAP:      A-100; AD SHZ -4; A+CREBMAP=:X  % IF PAGE IS WITHIN NEW RSEGM
071365                  AD SH 7; A/\170+CBSKP;          % AND BIT NOT SET IN BITMAP
071370                  T:=0; *LDXTX; COPY SX DT ;EXR SA
071374                  GO NOVERLAP
071375                  X:=CURRX                        % THEN REMOVE PAGE FROM SEGMENT
071376                  *2REMP
071414                  XSGRT=:B
071416                  *2INSP                          % AND LINK TO DUMMY SEGMENT
071440                  *LDASG SGSTA                    % COPY DUMMY SEGS PROTECT ENTRY
071450                  *STACM PROTE
071456                  B:=L
071457   NOVERLAP:      X:=NEXTX
071460              OD
071461              T:=SEGTBANK; X:=XSGRT
071463              *SEGLI@3 LDATX
071464              A=:D; *BPAGL@3 LDATX
071466              GO L2; *)FILL                       % IF DUMMY SEGMENT WAS EMPTY
071475   L2:        IF A><0 AND D=0 THEN                % AND NOT IN SEGMENT LIST
071500                  "1INSEGLINK"; *IOF; IRW SLEVB DP    % THEN LINK IT INTO LIST
071503                  SLEV; *MST PID; ION        % ON SEGADM LEVEL
071506                  X:=BSEGLINK; T:=SEGTBANK
071510                  *SEGLI@3 LDATX
071511                  A=:BSEGLINK
071512              FI
071512
071512          ENDIF: %  FI
071512          D0=:RTREF.RSEGM                     % SET NEW RSEGM
071515          GO FAR ESPLRE
071516   RBUS
071523

071523   %============================================================================
071523   % 36.15    (R)   S T M L E V   Y T R N S E G
071523   %
071523   SUBR STMLEV,YTRNSEG
071523   STMLEV:    *ION; EXIT
071525
071525   YTRNSEG:   "XTRNSEG"; *IOF; IRW SLEVB DP   % START XTRNSEG ON SEGADM LEVEL.
071530              SLEV; *MST PID; ION
071533              EXIT
071534   RBUS
071535
071535   %==============================================================================
071535   % 36.7   (R)  W S E G   -   W S E G X   -  W S O U T
071535   %
071535   % MONITOR CALL: CALL WSEG(SEGNO) - WRITE BACK SEGMENT
071535   %
071535   SUBR WSEG, WSEGX, WSOUT
071535
071535   INTEGER POINTER CRETADR    % RETURN ADDRESS
071536   INTEGER SVFLG              % SAVED FLAG
071537
071537   WSEG:  CALL GET1
071540          "RET"=:"CRETADR"
071542          D0=:WSSG  ; A BZERO 17      % CLEAR BIT 17
071545          CALL 0LEGSEG                % LEGAL SEGMENT
071546          T:=SEGTBANK; *SGSTA@3 LDATX
071550          IF A BIT 5SPTFIXED GO RET   % IGNORE WSEG OF SEGMENTS FIXED IN PIT.
071552   FELLS: X=:WSSGA
071553          CALL SRESER             % RESERVE SWAPPING RESOURCES
071554          T:=SEGTBANK; X:=WSSGA; *FLAG@3 LDATX
071557          A=:SVFLG BZERO 5OK;    *FLAG@3 STATX
071562          RTREF=:SRTREF; X=:SEGREF
071565          *IOF
071566          A:=X;     *IRW SLEVB DB
071570          "SMWSEG"; *IRW SLEVB DP % START SMWSEG ON SEGADM LEVEL
071572          "MLEV+SLEV"; *MST PID   % TO DO THE ACTUAL WRITEBACK
071574          MLEV; *MST PIE
071576          *ION; IOF
071600          MLEV; *MCL PIE
071602          *ION
071603          A:=SVFLG; *FLAG@3 STATX % RESET OLD FLAG
071605          CALL SRELES             % RELEASE SWAPPING RESOURCES
071606   WSOUT: GO CRETADR
071607
071607   % CALLED FROM 3SPLREE
071607   % ENTRY:     A=SEGMENT NUMBER
071607   %            X=ADDRESS OF SEGMENT TABLE ENTRY
071607   %
071607   WSEGX: A=:WSSG:=L=:"CRETADR"; GO FELLS
071613   RBUS
071627

071627   %==============================================================================
071627   %      (R)   S R E S E R   -   S R E L E S
071627   %
071627   % SUBROUTINES TO RESERVE AND RELEASE ALL SWAPPING RESOURCES
071627   %
071627   % ENTRY:     B=MONITOR CALL WORKING FIELD
071627   %
071627   SUBR SRESER,SRELES,ZSRELES
071627   INTEGER BRG,CINDX,XREGG
071632   INTEGER POINTER CLR
071633
071633   SRESER: A:=L=:"CLR":=B=:BRG; X=:XREGG
071640          X:=RTREF; "CLFIE"=:B
071643          CALL BRESERVE
071644          IF A<0 THEN
071645             CALL SRELES
071646             X.STATUS BONE 5WAIT BONE 5SWWAIT=:X.STATUS
071652             GO VENT
071653          FI
071653          0=:CINDX
071654          DO WHILE X:=CINDX<=7
071660             IF MASSNO(X)><0 THEN
071662                CALL LOGPH; A=:B; X:=RTREF; CALL BRESERVE
071666                IF A<0 THEN
071667                   CALL SRELES; CALL FREXQU; CALL TOWQU
071672                   GO VENT
071673                FI
071673             FI
071673             MIN CINDX
071674          OD
071675          BRG=:B; X:=XREGG; GO CLR
071701
071701   VENT:  BRG=:B; ZPREG-1=:ZPREG; GO M61RET
071707
071707   INTEGER CPROG,XINDX,BBRG,XXRG
071713   INTEGER POINTER CLLR
071714
071714   ZSRELES: X=:CPROG=:XXRG; GO FELLS
071717   SRELES: RTREF=:CPROG; X=:XXRG
071722   FELLS: A:=L=:"CLLR":=B=:BBRG
071726          0=:XINDX
071727          DO WHILE X:=XINDX<=7
071733             IF MASSNO(X)><0 THEN
071735                CALL LOGPH
071736                IF A.RTRES=CPROG THEN X=:B; X:=CPROG; CALL BRELEASE FI
071746             FI
071746             MIN XINDX
071747          OD
071750          "CLFIE"=:B; X:=CPROG; IF RTRES=X THEN CALL BRELEASE FI
071757          BBRG=:B; X:=XXRG; GO CLLR
071763   RBUS
071776
071776   @DEV 1
071776   @DEV (S-S-L)RP-P2-1:NPL
071776   %

071776   %==============================================================================
071776   %      C X - R P I T - C D E P C
071776   %=============================================================================
071776   %
071776   %       PREDECLARATIONS
071776   %
071776   SUBR BISIZ, ENTOPCOM
071776   RBUS
071776
071776   %==============================================================================
071776   % 12.1         E R R M O N         ( R )
071776
071776   %MONITOR CALL FOR USER ERRORS, APPL. LEVEL
071776   %A=ERROR NO.,#DD, T=ADDRESS
071776   SUBR ERRMON
071776   INTEGER MERRNO=?
071776   ERRMON: CALL GET0
071777          AD:=ZADREG
072000          IF A><#35 AND ><#90 AND ><#91 AND <#50 OR >#69 THEN #41 FI
072020          A=:MERRNO; ZTREG; CALL 9ERRA
072023   INTEGER MERRNO
072024          GO RET
072025   RBUS
072036
072036
072036   %==============================================================================
072036   % 4.12       G T R T               ( R )
072036
072036   % MONITOR CALL: IRT=GETRT(0)
072036   SUBR GTRT
072036   GTRT:  CALL GET0; CURPROG=:ZAREG; GO RET
072042   RBUS
072045
072045
072045   %==============================================================================
072045   % 4.13       R T O N   R T O F F   ( R )
072045
072045   % MONITOR CALLS TO ALLOW OR INHIBIT RT-ROGRAMS
072045   % CALL RTON(PROG)
072045   % CALL RTOFF(PROG)
072045   SUBR RTON,RTOFF
072045   RTON:  CALL GET1; CALL RTCHECK; X.STATUS BZERO 5RTOFF; GO RTO
072052   RTOFF: CALL GET1; CALL RTCHECK; X.STATUS BONE 5RTOFF
072056   RTO:   A=:X.STATUS; GO RET
072060   RBUS
072063
072063   *"8BACS
"072063

072063   @LIB OLD
072063   %=============================================================================
072063   %       BACKGROUND ALLOCATION ROUTINES
072063   %
072063   SUBR 9BPTMOUT
072063
072063   %=============================================================================
072063   %       U S S L O G F A C I L I T Y
072063   %
072063   % LOCAL SUBROUTINE TO CHECK IF A PROGRAM IS USING
072063   % ANY OF THE "SYSTEM-LOGGING-FACILITIES"
072063   %
072063   % ENTRY:         X=DATAFIELD
072063   %
072063   % EXIT:          USING "SYSTEM-LOGGING-FACILITY"
072063   %
072063   % EXIT+1:        NOT USING ANY "SYSTEM-LOGGING-FACILITIES"
072063   %
072063   USSLOGFACILITY:
072063          IF X.RTRES><0 THEN
072065             A=:D
072066             IF "F1352".RTRES=D OR "F1202".RTRES=D THEN EXIT FI % IN @PROGRAM-LOG OR @RT-PROG-LOG
072077             IF "F1203".RTRES=D THEN
072103                 X:="HISTO"; *AAX -1   % AAX FLGH
072105                 IF X.S0=1 THEN EXIT FI                         % USING @SYSTEM-HISTOGRAM
072112             FI
072112             IF "F1204".RTRES=D AND D.STATUS BIT 5INT THEN EXIT FI % USING LOGGING FACILITY IN @SIN-SERV-PROG
072123          FI; EXITA
072124   *)FILL
072131
072131   %============================================================================
072131   %      X S T Y P R I N G   -   X R T Y P R I N G
072131   %
072131   % XSTYPRING: LOCAL SUBROUTINE TO SAVE TYPRING AND THEN SET BIT 5NORESERV IN TYPRING
072131   % XRTYPRING: LOCAL SUBROUTINE TO UNSAVE THE SAVED TYPRING
072131   %
072131   % ENTRY:     X=TERMINAL/TAD INPUT DATAFIELD (CBPTERM)
072131   %
072131   % EXIT:      ALL REGISTERS DESTROYED
072131   %
072131   INTEGER OTYPRING
072132   XSTYPRING:
072132              X+"9CXTI"; X.TYPRING=:OTYPRING BONE 5NORESERV=:X.TYPRING
072137              T:="TYPRING"; GO XSTDFADDR                            % RETURN TO ROUTINE CALLING XSTYPRING
072141   XRTYPRING:
072141              X+"9CXTI"; OTYPRING=:X.TYPRING
072144              T:="TYPRING"; GO XSTDFADDR                            % RETURN TO ROUTINE CALLING XRTYPRING
072146
072146   %=============================================================================
072146   %            C P R L O G O U T
072146   %
072146   % LOGOUT BACKGROUND PROGRAM   (SIMULATE @STOP-TERMINAL)
072146   %
072146   % ENTRY:     X=TERMINAL/TAD INPUT DATAFIELD (CBPTERM)
072146   %
072146   % EXIT:      ALL REGISTERS DESTROYED
072146   %
072146   INTEGER POINTER LRG
072147   INTEGER SVX
072150   CPRLOGOUT: A:=L=:"LRG"; X=:SVX; *IOF
072154          A:=CURPROG;CALL GBPIU;GO L3
072157          T:=MBSPRTAB
072160          A*BPRTSIZE; X:=ASBPRTAB;X+A;*AAX BPUER
072164          A:=3; *STATX
072166   L3:    X:=SVX
072167          T:="FLAGB"; CALL XGTDFADDR; A/\ESCMASK; T:="FLAGB"; CALL XSTDFADDR
072174          T:="LAST"; A:=-1; CALL XSTDFADDR
072177          T:="DFLAG"; CALL XGTDFADDR; A BZERO 5IESC; T:="DFLAG"; CALL XSTDFADDR
072204          X=:B; CALL STESCAPE
072206          *ION
072207          GO LRG
072210
072210   %=============================================================================
072210   %            C T X T O U T
072210   %
072210   % LOCAL SUBROUTINE TO OUTPUT A TEXT STRING
072210   %
072210   % ENTRY:     A=ADDRESS OF TEXT STRING TERMINATED BY '
072210   %
072210   %
072210   CTXTOUT: A=:D; X:=0
072212          DO
072212             T:=D; *1BANK; LBYT; 2BANK
072216          WHILE A><##'
072221             T:=CBPLOGDV; *MON 2OUTB; JMP *+1
072224             X+1
072225          OD
072226          EXIT
072227   *)FILL
072245
072245   %============================================================================
072245   % LOCAL SUBROUTINE TO CALCULATE THE TIME LEFT BEFORE LOGGED OUT, AND
072245   % TO WRITE THE MESSAGE ON THE TERMINAL/TAD
072245   %
072245   INTEGER POINTER CLRET
072246   CSUBR: A:=L=:"CLRET"
072250          A:=ONTTMCOUNT-CTTMCOUNT=:BVALUE
072253          A=:D:=0; T:=4; *RDIV ST                    % 4 ACTIVATIONS OF BPTMP PER MINUTE
072257          A=:BXVALUE; 0=:BCBYTP
072261          FOR X:=-5 DO                               % COMPUTE HOW MANY MINUTES LEFT
072262             A:=BXVALUE=:D:=0; T:=BCONST(X); *RDIV ST
072267             T:=D=:BXVALUE
072271             IF A><0 OR X=-1 OR T:=BCBYTP><0 THEN
072300                A+60; X=:D:=BCBYTP; T:="XTMLEFT"; *1BANK; SBYT; 2BANK
072307                X+1=:BCBYTP:=D
072312             FI
072312          OD; X:=BCBYTP=:D:=0
072316          *1BANK
072317          DO
072317             T:="TXMINS"; *LBYT
072321          WHILE A><##'
072324             X+1:=:D; T:="XTMLEFT"; *SBYT
072330             X+1:=:D
072332          OD; *2BANK
072334          IF BVALUE><4 THEN                         %IF =4  THEN ONE MINUTE LEFT, NO 'S'
072340             ##S; X:=D; T:="XTMLEFT"; *1BANK; SBYT; 2BANK
072346             D+1
072347          FI; X:=D; ##'; T:="XTMLEFT"; *1BANK; SBYT; 2BANK
072355          X:=CCBPTERM; CALL FAR XSTYPRING
072357          IF CBPRFLG NBIT BPWARN THEN               % WARNING GIVEN?
072362             A BONE BPWARN; X:=BCINDX               % NO, GIVE WARNING AND MARK
072364             T:=MBSPRTAB; *BPRFL@3 STATX            % THAT WARNING IS GIVEN
072366             "TXCRLF"; CALL FAR CTXTOUT
072370          FI; "TXWARN"; CALL FAR CTXTOU             % GIVE WARNING
072372          "TXXBELL"; CALL FAR CTXTOUT
072374          "TXBLA";   CALL FAR CTXTOUT
072376          X:=CCBPTERM; CALL FAR XRTYPRING
072400          GO CLRET
072401   *)FILL
072424
072424   %=============================================================================
072424   %            9 B P T M O U T
072424   %
072424   % RT PROGRAM TO LOGOUT BACKGROUND PROCESSES
072424   %
072424   % THE PROGRAM IS RUNNING WITH AN INTERVAL OF 15 SECS.
072424   %
072424   9BPTMOUT: *2BANK
072425          X:=ASBPRTAB
072426   LOOP:  IF X>>=AEBPRTAB GO FAR FINI                         % SEARCH ALL ELEMENTS IN TABLE FOR TIMOUT
072431          X=:BCINDX=:B; T:=MBSPRTAB; *CBPTE@3 LDDTX           % A=CBPTERM, D=BPRFLG
072435          IF A=0 OR D NBIT BPRTMOUT GO FAR EDO                % NOT TIMOUT ON THIS ELEMENT
072440          AD=:DCCBPTERM
072441          IF A.RTRES=0 OR A.STATUS NBIT 5BACKGR GO FAR EDO    % NOT USED OR RESERVED BY RT-PROGRAM
072450          IF X.WLINK=0 AND X.TLINK=0 GO FAR EDO               % BACKGROUND PROGRAM IS PASSIVE
072455          T:=MBSPRTAB; X:=:B; *BBPRO@3 LDATX
072460          IF A><B GO FAR EDO                                  % NOT THE PROGRAM FOUND IN SBPRTAB USING THE TERMINAL/TAD
072462          A=:CBBPROC-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
072470          A*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; *CPUTI@3 LDDTX
072475          AD=:BCDTINT                                         % ND-100 CPU TIME USED
072476          X:=CCBPTERM; T:="FYLLE"; CALL XGTDFADDR; A=:B1COUNT
072502          T:="HENTE"; CALL XGTDFADDR; A+B1COUNT=:B1COUNT      % INPUT CHECKSUM
072506   *"8BACS 8N500
"072506          *IOF
072507          CBBPROC=:D; CALL FSEMA; GO NO500; *ION              % CHECK IF PROGRAM USING ND-500
072514          X:=X.MESSBUFF
072515          T:=5MBBANK; *AAX 500TU; LDDTX
072520          AD=:BD5TUSED                                        % ND-500 TIME USED
072521          X:=BCINDX; T:=MBSPRTAB; *AAX 5DTU1; LDDTX
072525          IF D><B5TU2 OR A><B5TU1 GO FAR SAMPLE               % ANY ND-500 CPU TIME USED?
072533   *"8BACS
"072533   NO500: *ION
072534          T:=MBSPRTAB; X:=BCINDX; *AAX 1TUSE; LDDTX
072540          IF D><BCD2TI OR A><BCD1TI GO FAR SAMPLE             % ANY ND-100 CPU TIME USED?
072546          T:=MBSPRTAB; *AAX 9IVAL-1TUSE; LDATX
072551          IF A><B1COUNT GO FAR SAMPLE                         % ANY TERMINAL I/O?
072554          GO MBTMOUT; *)FILL
072607
072607   INTEGER CTLREP
072610   MBTMOUT: T:=MBSPRTAB; X:=BCINDX; *TTMCO@3 LDATX            % NO ACTIVITY, INCREMENT PASSIVE TIME
072613          A+1=:CTTMCOUNT; *TTMCO@3 STATX
072616          *BPLOG@3 LDATX
072617          A=:CBPLOGDV
072620          X:=CCBPTERM; CALL FAR USSLOGFACILITY; GO FAR EDO    % CHECK IF USING ANY LOGGING FACILITY
072623          X:=CCBPTERM; T:="BSTATE"; CALL XGTDFADDR
072626          IF A=5ENMAX GO FAR EDO                              % TOO MANY ATTEMPTS TO ENTER
072631          IF A=5LOGIN THEN                                    % NOT LOGGED IN
072634             X:=CCBPTERM; CALL FAR XSTYPRING                  % SET BIT 5NORESERV
072636             A:="TXBELL"; CALL FAR CTXTOUT                    % GIVE BELL
072640             X:=CCBPTERM; CALL FAR XRTYPRING                  % RESET BIT 5NORESERV
072642             IF CTTMCOUNT>>=NONTTMCOUNT THEN                  % IDLE TOO LONG?
072646                X:=CCBPTERM; CALL FAR CPRLOGOUT               % YES, LOGOUT BACKGROUND PROGRAM
072650             FI
072650          ELSE
072651             IF CTTMCOUNT>>=TTMWARNING THEN                   % SHOULD WARNING BE GIVEN?
072655                X:=CCBPTERM; T:="FLAGB"; CALL XGTDFADDR; A/\1=:CTLREP
072662                IF A=0 AND CCBPTERM.TYPRING BIT 5TERM THEN
072667                   X+"9CXTI"
072670                   -5; T:="TMR"; CALL XSTDFADDR
072673                   T:="BITFLAG"; CALL XGTDFADDR
072675                   A BONE 5CLOU; T:="BITFLAG"; CALL XSTDFADDR % TIMER SHOULD CLEAR OUTPUT BUFFER
072700                FI
072700                IF CTLREP=0 AND ONTTMCOUNT-CTTMCOUNT<<4 THEN  % GIVE BELL EATCH TIME IN LAST MINUTE BEFORE LOGOUT
072707                   X:=CCBPTERM; CALL FAR XSTYPRING            % SET BIT 5NORESERV
072711                   "TXBELL"; CALL FAR CTXTOUT                 % GIVE BELL ON TERMINAL\
072713                   X:=CCBPTERM; CALL FAR XRTYPRING            % RESET BIT 5NORESERV
072715                FI
072715                IF CTTMCOUNT>>=ONTTMCOUNT THEN                % SHOULD USER BE LOGGED OUT?
072721                   IF CTLREP><0 THEN                          % YES
072723                      X:=CCBPTERM; T:="FLAGB"; CALL XGTDFADDR % THE RUNNING PROGRAM HAS THE REPONSIBILITY TO
072726                      A BONE 5LOGOUT; T:="FLAGB"; CALL XSTDFADDR  % TERMINATE
072731                   ELSE
072732                      X:=CCBPTERM; CALL FAR CPRLOGOUT         % LOGOUT USER
072734                   FI; GO EDO
072735                FI
072735                IF CTTMCOUNT/\3=0 THEN CALL FAR CSUBR FI      % GIVE WARNING EACH MINUTE
072741             FI
072741          FI
072741   EDO:   X:=BCINDX+BPRTSIZE; GO FAR LOOP
072744
072744   FINI:  *MON 2RTXT
072745
072745   % PROGRAM IS ACTIVE, SAMPLE NEW VALUES TO TEST AGAINST NEXT TIME
072745   SAMPLE: A:=CBBPROC-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
072753           A*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; *CPUTI@3 LDDTX
072760           T:=MBSPRTAB; X:=BCINDX; *AAX 1TUSE; STDTX
072764           A:=B1COUNT; *AAX 9IVAL-1TUSE; STATX
072767           *AAX TTMCO-9IVAL; STZTX
072771           CBPRFLG BZERO BPWARN; *AAX BPRFL-TTMCO; STATX
072775   *"8BACS 8N500
"072775           AD:=BD5TUSED; *AAX 5TUSE-BPRFL; STDTX
073000   *"8BACS
"073000           GO EDO
073001   *)FILL
073043
073043   INTEGER TXCRLF(0); *6412; 6412; #''
073046   INTEGER TXBELL(0); *3407; #''
073050   INTEGER TXWARN(0); *3407; 3407; 3415
073053   *'IF NO ACTIVITY ON THE TERMINAL, YOU WILL BE LOGGED OUT IN  '
073111   * *-1/
073110   INTEGER XTMLEFT(0); *'              '
073120   INTEGER TXMINS:=' MINUTE'
073124   INTEGER TXXBEL(0); *3407; 3407; #''
073127   INTEGER TXBLA:='  '
073131   RBUS
073131   *"
"073131
073131   %=============================================================================
073131   %            C L R B M A P   B M F R T D   B M T R T D
073131   %            B M O R
073131   %
073131   % ROUTINES TO MANIPULATE WITH THE RT-DESCRIPTION'S REENTRANT BITMAP
073131   %
073131   SUBR BMFRTD,BMTRTD,BMOR
073131
073131   % CLRBMAP:   CLEAR THE REENTRANT BITMAP
073131   %      ENTRY:  X=RTDESCRIPTION; INTERRUPT MUST BE OFF OR MLEV DISABLED
073131   %      EXIT:   PAGING IS ON
073131   %
073131   @LIB JZK
073131   % BMFRTD:    COPY BITMAP FROM RT-DESCRIPTION TO ARRAY POINTED AT BY B-REG
073131   %      ENTRY:  X=RTDESCRIPTION; B=ARRAY ADDR
073131   %      EXIT:   T,A,D,X ARE DESTROYED
073131   %
073131   BMFRTD:
073131           X.RTDLGADDR+5BITMAP=:D; A:=0; X:=10:=:L; T:=B+BXBITMAP; *MOVPN
073142           X=:P
073143
073143   % BMTRTD:    COPY BITMAP FROM ARRAY POINTED AT BY B-REG TO RT-DESCRIPTION
073143   %      ENTRY:  X=RTDESCRIPTION; B=ARRAY ADDR
073143   %      EXIT:   T,A,D,X ARE DESTROYED
073143   %
073143   BMTRTD:
073143           T:=X.RTDLGADDR+5BITMAP; X:=0; A:=B+BXBITMAP=:D:=10:=:L; *MOVNP
073154           A=:P
073155
073155   % BMOR:      RT-DESCRIPTION.BITMAP OR SAVED-BITMAP =: RTDESCRIPTION.BITMAP
073155   %      ENTRY: X=RTDESCRIPTION ADDR; B=ARRAY ADDR
073155   %             MUST BE CALLED IN IOF AND ARRAY POINTED TO BY B-REG MUST
073155   %             BE IN MEMORY WHEN BMOR IS CALLED
073155   %      EXIT:  T,A,D,X ARE DESTROYED
073155   %
073155   BMOR:  X:=X.RTDLGADDR+5BITMAP; T:=0
073160          *LDATX 00; ORA XUBIM,B; STATX 00
073163          *LDATX 10; ORA XUBI1,B; STATX 10
073166          *LDATX 20; ORA XUBI2,B; STATX 20
073171          *LDATX 30; ORA XUBI3,B; STATX 30
073174          *LDATX 40; ORA XUBI4,B; STATX 40
073177          *LDATX 50; ORA XUBI5,B; STATX 50
073202          *LDATX 60; ORA XUBI6,B; STATX 60
073205          *LDATX 70; ORA XUBI7,B; STATX 70
073210          EXIT
073211   RBUS
073211
073211
073211   %==============================================================================
073211   %            X X O N C H E C K
073211   %
073211   % SUBROUTINE TO TERMINAL IOTRANS ROUTINE CAUSE SENDING OF XON
073211   % IF SPACE IS AVAILABLE IN INPUT BUFFER.
073211   % XON IS GIVEN WHEN HALF THE BUFFER IS FREE AND "XOFF" HAS
073211   % PREVIOUSLY BEEN GIVEN
073211   %
073211   SUBR XXONCHECK
073211   XXONCHECK:
073211   *"8RON
"073211          IF X=0 OR HDEV=0 THEN EXIT FI
073215          IF DFLAG BIT 5RDEVICE THEN
073220             IF A BIT 5XON OR A NBIT 6XOFF THEN EXIT FI
073225             IF CFREE=MAX SHZ -1 THEN
073232                DFLAG BONE 5XON BZERO 6XOFF=:DFLAG
073236                IF BRECHOFL NBIT 5PINFL THEN
073241                   T:=HDEV+7; A:=1; *IOXT               % PIN TO START OUTPUT DRIVER
073245                FI
073245             FI
073245          ELSE
073246             IF MAX SHZ -1=CFREE THEN
073253                CNTREG BONE 7=:CNTREG
073256                T:=HDEV+"DCONT"; *IOXT                  % SET PIN 19 (V.24)
073261             FI
073261          FI
073261   *"
"073261          EXIT
073262   RBUS
073262
073262   *"8PACL
"073262   %====================================================================
073262   %
073262   % 33.24      R E A D C L O C K     ( R )
073262   %
073262   %
073262   %   ROUTINE TO READ PANEL CLOCK ON N-100 AND UPDATE THE
073262   %   INTERNAL SINTRAN CLOCK.
073262   %
073262   SUBR READCLOCK
073262   INTEGER POINTER LREG=?
073262   READCLOCK:
073262          IF PWRFREST><0 THEN EXIT FI
073265          A:=L=:"LREG"
073267          A:=0; CALL PANEL
073271          IF A NBIT 17 THEN GO LREG FI               % PANEL NOT PRESENT
073274          A:="22000"; CALL PANEL                     % READ LOW SECONDS
073276          A/\377=:D; A:="22400"; CALL PANEL          % READ HIGH SECONDS
073302          A SHZ 10\/D=:SECOND; A:="23000"; CALL PANEL% READ LOW HDAYS
073307          A/\377=:D; A:="23400"; CALL PANEL          % READ HIGH HDAYS
073313          A SHZ 10\/D=:HDAYES
073316          7=:L; T:="X9CL1"; "9CLO0"=:D; *MOVAA       % SIMULATE MON CLOCK
073324          0=:DAYES; GO L1; *)FILL
073342
073342   %  UPDATE CALENDER
073342   L1:    X:=-1; PXCLX(X)-TBASE(X)=:ADDYEAR
073346          DO WHILE ADDYEAR>0
073351             0=:PERIOD
073352             FOR PERIOD TO 3 DO WHILE ADDYEAR>0
073361                DAYEAR(PERIOD)+DAYES=:DAYES
073365                ADDYEAR-1=:ADDYEAR
073370             OD
073374          OD; GO L2; *)FILL
073403
07340LSE 34 FI A=:DAMONTH(1)
073710                X:=-2; ACL7(X)-TBASE(X)-1=:ADDMONTH
073715                FOR X:=0 TO ADDMONTH DO
073721                   DAMONTH(X)+DAYES=:DAYES
073724                OD
073726                X:=-3; ACL7(X)-TBASE(X)+DAYES=:DAYES SHZ 1=:HDAYES
073735                X:=-4; A:=ACL7(X)=:HOURS=:D:=0; T:=14; *RDIV ST
073744                A+HDAYES=:HDAYES; A:=D=:HOURS*7020=:SECOND; X:=-5
073753                ACL7(X)*74+SECOND=:SECOND; X:=-6; ACL7(X)+SECOND=:SECOND
073763                GO PANUP; *)FILL
074003
074003   INTEGER POINTER LREG
074004
074004   PANUP:       SECOND; A=:D/\377\/2000; CALL PANEL
074011                A:=D; A SHZ -10\/2400; CALL PANEL
074015                HDAYES; A=:D/\377\/3000; CALL PANEL
074022                A:=D; A SHZ -10\/3400; CALL PANEL
074026             FI
074026          FI; GO LREG
074027   RBUS
074037
074037   *"-8PACL
"074037   *"
"074037

074037   %=============================================================================
074037   %
074037   %=============================================================================
074037   *"8MT1+8MT2+8MT3+8MT4
"074037   %==============================================================================
074037   %      ( R )      M G T M R
074037   %
074037   SUBR MGTMR
074037
074037   % TIMEOUT SUBROUTINE FOR MAGTAPE
074037
074037   MGTMR: IF TRG/\77=10 OR =11 THEN EXIT FI %ADVANCE/RETURN TO EOF
074050          IF ><13 AND ><17 THEN 22=:TRG; "MFIN"=:"CLRG" FI
074062          IF A=17 THEN "MFIN"=:"DRIVER" FI
074067          GO MTMRSUB                      % STANDARD MASS STORAGE TIMEOUT
074070   RBUS
074073
074073   *"99SM1+99SM2
"074073   %==============================================================================
074073   % 34.2       S T M R S U B
074073   %
074073   %      ROUTINE FOR SERVING STC-MAGTAPE
074073   %
074073   %      STMRSUB:              TIMEOUT-ROUTINE FOR REWINDING
074073   %                            WITH ASYNCHROUNOUS TIMEOUT FOR
074073   %                            EACH DRIVE EXECUTED BY INBT-DATAFIELDS
074073
074073   SUBR STMRSUB
074073
074073   STMRSUB:
074073          IF X := NRDYF = 0 THEN EXIT FI
074077          0=:ISTATE                       % SIMULATE RDATA
074100          X.STATUS BZERO 5WAIT =: X.STATUS
074103          EXIT                            % RETURN AFTER RESTARTING USER.
074104
074104   RBUS
074104
074104   *"
"074104

074104   *"8MT1+8DMVC+8CDLI+8FDI1+8FDI2+8BFD1+8BFD2+8MT2+8MT3+8MT4
"074104   %==============================================================================
074104   % 34.10      C B G E T   C B P U T   C A I C L   S M T R A   C A O C L    (R)
074104   %
074104   %
074104   % IOTRANS ROUTINE FOR MAG.TAPE, VERSATEC ON DMA
074104   % AND FLOPPY DISC
074104   %
074104
074104   SUBR CBGET,CBPUT,CAICL,CAOCL,CAIC4
074104
074104   CBGET: A:=L=:LREGC; *ION               % LEVEL 4
074107          CALL CBF1
074110          IF BHOLD><0 THEN
074112             IF A=1 AND CERROR><0 THEN A=:DERROR FI
074120             CALL DBGET
074121             MIN LREGC; GO PLREGC
074123          FI
074123          A:=B; *IRW MLEVB DB
074125          "CGMLEV"; *IRW MLEVB DP
074127          MLEV; *MST PID; WAIT
074132          CALL ERRFATAL
074133   ERR1:  A:=172                % NO DEVICE BUFFER AVAILABLE
074134   ERR:   A=:DERROR; GO PLREGC
074136
074136   INTEGER POINTER REGL
074137
074137   % RESERVE THE DFOPP-DATAFIELD AND RESERVE DEVICE BUFFER
074137
074137   CBF1:  T:=L=:"REGL"
074141          CALL CHDVBUF; GO CNBUF; GO L1
074144   CNBUF: CLOGDV; CALL LOGPH; IF A=0 THEN 2; GO ERR FI
074151          IF A.TYPRING BIT 5FLOP THEN
074155                X=:D; A:=X+CASUN+"FDIFORM"=:X; X.S0+D+"WDSCT"=:X
074166                X.S0 SH 1=:MAX
074171          FI
074171          T:=CIOLOG; MAX SHZ -1; CALL G4BUF; GO ERR1
074176          AD=:MBPAG; A:=D=:BUFST; T=:ADRBHEAD       % PUT ADDRESS OF DEVICE BUFFER AND DEVICE BUFFER HEADER
074202          0=:BHOLD=:FYLLE=:HENTE; MAX=:CFREE        % IN THE FLOPPY INBYTE/OUTBYTE DATA FIELD.
074207   L1:    IF X:=DFOPP=0 GO REGL
074212          IF X.RTRES><RTREF THEN
074216             B=:D:=X; X:=T; CALL BRESERVE; D=:B
074223             IF A<0 THEN A:=205; GO ERR FI          % DEV. ALREADY RESERVED
074226          FI; GO REGL
074227
074227
074227   CBPUT: X:=L=:LREGC;A=:LASTC; *ION      % LEVEL 4
074233          CALL CBF1
074234          IF CFREE><0 THEN
074236             LASTC; CALL DBPUT
074240             MIN LREGC; GO PLREGC
074242          FI
074242          A:=B; *IRW MLEVB DB
074244          "CBMLEV"; *IRW MLEVB DP
074246          MLEV; *MST PID; WAIT
074251
074251   *)FILL
074270   %==============================================================================
074270   %             C A I C L    C A O C L
074270   % IOSET ROUTINES FOR MAG.TAPE, VERSATEC ON DMA, LINE-PRINTER AND FLOPPY DISK
074270   %
074270
074270   INTEGER POINTER LREG=?
074270
074270   % ENTRY POINT FOR INPUT
074270   CAICL: IF A><-1 AND ><-2 THEN EXIT FI
074277   CAICF: A:=L=:"LREG"
074301          CALL CHDVBUF; GO CAIC1
074303          "CAIC4"; *IRW BLEVB DP
074305          CIOLOG; *IRW BLEVB DT
074307          BLEV; *MST PID
074311   CAIC1: 0=:BHOLD=:HENTE=:BUFST=:ADRBHEAD; MAX=:CFREE
074317          A:=0; GO LREG
074321   CAIC4: *2BANK
074322          CALL R4BUF; CALL ERRFATAL; *WAIT
074325          CALL ERRFATAL
074326
074326   INTEGER SAVEB
074327   INTEGER POINTER LREG
074330   INTEGER REGB,XREG
074332
074332   % ENTRY POINT FOR OUTPUT
074332   CAOCL: IF A><-1 THEN IF A=-2 GO CAICF; EXIT FI
074341          IF BHOLD=0 GO CAICF
074343          A:=L=:"LREG"; CALL CHDVBUF; GO CAIC1
074347          X=:XREG
074350          A:=B=:REGB;CLOGDV; CALL LOGPH; A=:B
074355          X:=XREG; X:=RTREF; CALL BRESERVE
074360          IF A<0 THEN           % WAIT FOR "DMA"DEVICE
074361             CALL FREXQU;CALL TOWQU; XREG=:B; ZPREG-1=:ZPREG; GO RETSTUPR; *)FILL
074403          FI
074403          RTREF=:MRTREF; X:=REGB; X:=:B; CALL CHDVBUF; GO UT; X=:B
074412          IF TYPRING BIT 5FLOP THEN
074415             IF REGB.BHOLD><X.MAX THEN
074422                A:=B=:SAVEB; X=:B
074425                DO WHILE BHOLD><MAX
074431                   A:=0; CALL DBPUT
074433                OD; A:=SAVEB=:B
074436             FI
074436          FI
074436          REGB=:BREGC=:B; "SMTRA"=:MFUNC
074443          IF BHOLD BIT "0" THEN           % ODD NUMBER OF BYTES IN BUFFER
074446             A:=0; CALL DBPUT
074450          FI
074450          IF TYPRING BIT 5MT THEN
074453             DO WHILE BHOLD<22            % RECORD OF AT LEAST 22 BYTES MUST
074457                                          % BE WRITTEN ON MAG TAPE FOR IT TO
074457                A:=0; CALL DBPUT          % BE DISTINGUISHED FROM NOISE
074461             OD
074462          FI
074462          A:=BHOLD SHZ -1=:NOWRE
074465          A:=MLEV; *MST PIE               % ENABLE MONITOR LEVEL , INTERRUPT OFF
074467          X:=XREG; CALL RTACT             % RTACT DOES ION
074471          A=:X.ZAREG; CALL CHDVBUF; GO UT % RESTARTED HERE WHEN DRIVER HAS FINISHED
074474          A:=OFLDN; CALL XLOCK;           % LOCK STACK BEFORE USING IT
074476          T:=CIOLOG; CALL RRBUFF; CALL ERRFATAL         % RELEASE DEVICE BUFFER
074501          A:=OFLDN; CALL XUNLOCK
074503   UT:    0=:BHOLD=:FYLLE=:HENTE=:BUFST=:ADRBHEAD; MAX=:CFREE
074512          X=:B; GO RET
074514   RBUS
074527
074527
074527   *"8HDMA
"074527   %

074527   %==============================================================================
074527   %==============================================================================
074527   %    ( R )     H I T M R   H O T M R
074527   %
074527   %  TIMER ROUTINES FOR BSC-DMA/HDLC
074527   %
074527
074527   SUBR HITMR,HOTMR
074527
074527   HITMR: *IOF
074530          "HDITIM"; *IRW LV13B DT
074532          B=:A; *IRW LV13B DB
074534          "SLV13"; *IRW LV13B DP
074536          LV13; *MST PID
074540          *ION
074541          EXIT
074542
074542
074542   HOTMR: *IOF
074543          "HDOTIM"; *IRW LV12B DT
074545          B=:A; *IRW LV12B DB
074547          "SLV12"; *IRW LV12B DP
074551          LV12; *MST PID
074553          *ION
074554          EXIT
074555
074555   RBUS
074563
074563   *"8NLP1+8NLP2+8NLP3+8NLP4
"074563

074563   %==============================================================================
074563   %  ROUTINES FOR DMA LINEPRINTERS
074563   %
074563   %==============================================================================
074563   %       D M S L P R
074563   %
074563   % IOSET (SET-DEVICE ROUTINE)
074563   %
074563   SUBR DMSLPR
074563
074563   INTEGER BREG; INTEGER POINTER LREG
074565
074565   DMSLPR: T:=L=:"LREG":=B=:BREG
074571           IF A=-1 THEN
074574              IF BHOLD><0 AND A><MAX THEN
074601                 A:=15; CALL DBPUT
074603                 IF BHOLD BIT "0" THEN
074606                    A:=15; CALL DBPUT
074610                 FI
074610              FI; CALL CAOCL
074611              BREG=:B; A:=0; GO LREG
074615           FI
074615           IF A=30 THEN 11; GO SVFUN FI
074622           IF A=31 THEN 10; GO SVFUN FI
074627           EXIT
074630   SVFUN:  X=:D:=BREG=:B; A=:VEFUNC; X:=D; A:=0; GO LREG
074637   RBUS
074641
074641
074641   %=============================================================================
074641   %       D M T L P
074641   %
074641   % TIMEOUT ROUTINE
074641   %
074641   SUBR DMTLP
074641   DMTLP:  "CVCALL"; *IRW LV11B DT
074643           B=:A;     *IRW LV11B DB
074645           "SLV11";  *IRW LV11B DP
074647           TTMR=:TMR; LV11; *MST PID
074653           EXIT
074654   RBUS
074657
074657   *"8DMVC
"074657

074657   %==============================================================================
074657   %      ( C )   V E I C L
074657   %
074657   %
074657   % IOSET ROUTINE FOR VERSATEC (DMA)
074657   %
074657
074657   SUBR VEICL
074657
074657   INTEGER POINTER LREG
074660   INTEGER BREG
074661
074661   VEICL: T:=L=:"LREG":=B=:BREG
074665          IF A=-1 THEN CALL CAOCL;BREG=:B;A:=0;GO LREG FI
074675          IF A=30 THEN 11;GO SVFUN FI
074702          IF A=31 THEN 10;GO SVFUN FI
074707          EXIT
074710   SVFUN: X=:D;X:=BREG=:B;A=:VEFUNC;D=:X; A:=0;GO LREG
074717
074717   RBUS
074720
074720   %==============================================================================
074720   % 34.16      V E T M R
074720   %
074720   % TIMER ROUTINE FOR VERSATEC ON DMA
074720
074720   SUBR VETMR
074720   SYMBOL RST=4
074720   INTEGER POINTER LREG
074721   VETMR: HDEV+RST=:T; *IOXT          % READ STATUS
074725          IF A BIT 15 THEN
074727             A=:X:=L=:"LREG"; HDEV; T:=0; CALL 9ERR(#26)
074736             12=:CERRC; X=:A; *IRW LV11B DX; 1BANK
074743             "LREG"; *2BANK; COPY SA DL
074746             "FEILV+1"
074747          ELSE
074750             "CVCALL"
074751          FI
074751          *IRW LV11B DT
074752          B=:A; *IRW LV11B DB
074754          "SLV11"; *IRW LV11B DP
074756          TTMR=:TMR; LV11; *MST PID
074762          EXIT
074763   RBUS
074770
074770   *"8DLP1+8DLP2+8DVE1+8DVE2
"074770   %

074770   %==============================================================================
074770   % 34.18      C L P U T   C L C L O S E
074770   %
074770
074770   %
074770   % IOTRANS ROUTINE FOR LINE-PRINTER AND VERSATEC
074770   %
074770
074770   SUBR CLPUT,CLCLOS
074770   INTEGER POINTER REGL
074771
074771   CLPUT: *ION
074772          A=:LASTC:=L=:"REGL"
074775          CALL CHDVBUF; GO CNBUF; GO L1
075000   CNBUF: T:=CIOLOG; MAX SHZ -1; CALL G4BUF; GO ERR; A=:MBUFB; D=:A
075007          A=:BUFST=:MABUF; T=:ADRBHEAD
075012          0=:BHOLD=:FYLLE=:HENTE; MAX=:CFREE
075017   L1:    IF CFREE=0 THEN
075021                A:=B; *IRW MLEVB DB
075023                "CLMLEV"; *IRW MLEVB DP
075025                MLEV; *MST PID; WAIT
075030          FI
075030          LASTC; CALL DBPUT
075032          MIN "REGL"; GO REGL
075034   ERR:   172=:DERROR; GO REGL  % NO DEVICE BUFFER AVAILABLE
075037
075037   *)FILL
075043   %
075043   % ROUTINE TO CLOSE LINE-PRINTER/VERSATEC
075043   %
075043
075043   INTEGER XREG,BREG
075045   CLCLOS: IF A><-1 THEN
075050                IF A=-2 THEN
075053                   A:=L=:"REGL"; CALL CHDVBUF; GO L2
075057                   "CAIC4"; *IRW BLEVB DP      % TO LEVEL 4 TO RELEASE BUFFER
075061                   CIOLOG; *IRW BLEVB DT
075063                   BLEV; *MST PID
075065   L2:             0=:ADRBHEAD; "REGL"=:L
075070                   0=:BHOLD=:FYLLE; MAX=:CFREE
075074                FI; EXIT
075075          FI
075075          X=:XREG:=B=:BREG; MDATAF=:B; X:=RTREF; CALL BRESERVE
075104          IF A<0 THEN
075105                CALL FREXQU; CALL TOWQU; XREG=:B
075111                ZPREG-1=:ZPREG; GCHECK IF PROGRAM USING ND-500
072514          X:=X.MESSBUFF
072515          T:=5MBBANK; *AAX 500TU; LDDTX
072520          AD=:BD5TUSED                                        % ND-500 TIME USED
072521          X:=BCINDX; T:=MBSPRTAB; *AAX 5DTU1; LDDTX
072525          IF D><B5TU2 OR A><B5TU1 GO FAR SAMPLE               % ANY ND-500 CPU TIME USED?
072533   *"8BACS
"072533   NO500: *ION
072534          T:=MBSPRTAB; X:=BCINDX; *AAX 1TUSE; LDDTX
072540          IF D><BCD2TI OR A><BCD1TI GO FAR SAMPLE             % ANY ND-100 CPU TIME USED?
072546          T:=MBSPRTAB; *AAX 9IVAL-1TUSE; LDATX
072551          IF A><B1COUNT GO FAR SAMPLE                         % ANY TERMINAL I/O?
072554          GO MBTMOUT; *)FILL
072607
072607   INTEGER CTLREP
072610   MBTMOUT: T:=MBSPRTAB; X:=BCINDX; *TTMCO@3 LDATX            % NO ACTIVITY, INCREMENT PASSIVE TIME
072613          A+1=:CTTMCOUNT; *TTMCO@3 STATX
072616          *BPLOG@3 LDATX
072617          A=:CBPLOGDV
072620          X:=CCBPTERM; CALL FAR USSLOO RETSTUPR
075115          FI; X=:MRTREF; BREG=:B
075120          "CLTRA"=:MFUNC; A:=MLEV; *MST PIE    % ENABLE MONITOR LEVEL, INTERRUPT OFF
075124          X:=XREG; CALL RTACT                  % RTACT DOES ION
075126          A=:X.ZAREG                           % RESTARTED HERE AFTER DRIVER HAS FINISHED
075127          A:=OFLDN; CALL XLOCK                 % LOCK FILE SYSTEM STACK
075131          T:=CIOLOG; CALL RRBUFF; CALL ERRFATAL
075134          A:=OFLDN; CALL XUNLOCK
075136          0=:BHOLD=:HENTE=:FYLLE=:BUFST=:ADRBHEAD; MAX=:CFREE
075145          X=:B; GO RET
075147   RBUS
075166
075166
075166   %==============================================================================
075166   % 34.20      D L P T M R
075166   %
075166   %  TIME-OUT SUBROUTINE FOR LINE-PRINTER AND VERSATEC
075166   %
075166
075166   SUBR DLPTMR
075166   DLPTMR: TTMR=:TMR
075170          IF VEFLG><0 THEN
075172             IF PVEFUNC=10 THEN 101; GO L1 FI
075200          FI; A:=1
075201   L1:    T:=IOXWC; *EXR ST; EXIT
075204   RBUS
075204   *"
"075204   %===========================================================================
075204   % 34.21      C H D V B U F
075204   %
075204   % SUBROUTINE TO CHECK IF A DEVICE BUFFER IS RESERVED FOR THIS LOGICAL
075204   % DEVICE UNIT BY THE PROGRAM WHICH HAS RESERVED THE LOGICAL
075204   % DEVICE UNIT
075204   %
075204   % ENTRY:     B=ADDRESS OF I/O DATAFILELD
075204   % EXIT:      NO DEVICE BUFFER RESERVED
075204   % EXITA:     DEVICE BUFFER RESERVED
075204   %
075204   SUBR CHDVBUF
075204   DISP 5; INTEGER LGIOLOG; PSID          % LOGICAL DEVICE NUMBER IN BUFFER
075204
075204   CHDVBUF:
075204          X=:D
075205          IF ADRBHEAD=0 OR A.RTRES><RTRES OR X.LGIOLOG><CIOLOG THEN
075220             X:=D
075221             EXIT
075222          FI
075222          X:=D; EXITA
075224   RBUS
075224
075224   *"8FDI1+8FDI2
"075224   %==============================================================================
075224   %                             R T R E C                                  (R)
075224   %               RT-PROGRAM FOR RECONNECTING TO BDIO POOL
075224   %   STARTED BY TIMER RT PROGRAM 30 SECS AFTER AN UNSUCCESSFUL BDIO TRANSFER
075224   %                 B D T M U                B D T M V
075224   %                 TIMEOUT SUBROUTINES TO START RTREC
075224   %
075224   SUBR RECST,BDTMU,BDTMV
075224   INTEGER ARRAY X1ARR=?   % CONTAINS D.F. ADDR OF POOLS TO BE RECONNECTED
075224   INTEGER ARRAY X2ARR=?   % CONTAINS D.F. ADDR OF POOLS TO BE SWITCHED TO MIRROR POOL
075224   INTEGER XREG
075225   RECST:  *1BANK
075226           FOR X:=0 TO 17 DO                   % RECONNECT TO BDIO POOL
075232               IF X1ARR(X)><0 THEN
075234                  X=:XREG; *2BANK
075236                  A=:B; CALL XBDTU; *1BANK
075241                  X:=XREG; 0=:X1ARR(X)
075243               FI
075243           OD
075245           FOR X:=0 TO 17 DO                   % SWITCH TO MIRROR POOL
075251               IF X2ARR(X)><0 THEN
075253                  X=:XREG; *2BANK
075255                  A=:B; CALL XBDTV; *1BANK
075260                  X:=XREG; 0=:X2ARR(X)
075262               FI
075262           OD
075264           *MON 0
075265
075265   INTEGER ARRAY X1ARR(20)   % CONTAINS D.F. ADDR OF POOLS TO BE RECONNECTED
075305   INTEGER ARRAY X2ARR(20)   % CONTAINS D.F. ADDR OF POOLS TO BE SWITCHED TO MIRROR POOL
075325
075325   % TIMEOUT SUBROUTINE FOR POOL/AREA DATAFIELDS
075325   % CALLED FROM TIMER WITH INTERRUPT OFF
075325   INTEGER POINTER LREG
075326   BDTMU:  *1BANK
075327           A:=L=:"LREG"
075331           FOR X:=0 TO 17 DO
075335               IF X1ARR(X)=B GO UT1   % ALREADY IN X1ARR
075340           OD
075342           FOR X:=0 TO 17 DO
075346               IF X1ARR(X)=0 THEN     % PUT DATAFIELD INTO ARRAY
075350                  A:=B=:X1ARR(X); GO UT1
075353               FI
075353           OD
075355           GO UT1
075356
075356   % TIMEOUT SUBROUTINE FOR POOL/AREA DATAFIELDS
075356   % CALLED FROM TIMER WITH INTERRUPT OFF
075356
075356   BDTMV:  *1BANK
075357           A:=L=:"LREG"
075361           FOR X:=0 TO 17 DO
075365               IF X2ARR(X)=B GO UT1   % ALREADY IN X2ARR
075370           OD
075372           FOR X:=0 TO 17 DO
075376               IF X2ARR(X)=0 THEN     % PUT DATAFIELD INTO ARRAY
075400                  A:=B=:X2ARR(X); GO UT1
075403               FI
075403           OD
075405   UT1:    *2BANK                     % START RECONNECT PROCESS
075406           X:="RTREC"; CALL RTENTRY; GO LREG
075411   RBUS
075423
075423   %==============================================================================
075423   %                       X B D T U                                      (R)
075423   % CALLS FILESYSTEM TO RECONNECT TO A POOL WHICH GAVE ERROR ON A DISK TRANSFER
075423   % ENTRY: B-REG: ADDRESS OF POOL/AREA DATAFIELD
075423   %
075423   SUBR XBDTU
075423   XBDTU:  A:=L=:"BDTMR"                       % SAVE RETURN ADDRESS IN POOL DF
075425           A:="OFLDN"; CALL XLOCK              % RT-PROG: LOCK OPEN FILE TABLE
075427           T:=PLDNO; CALL FILSYS(RGPOOL)
075432           GO ERR;  1=:RSFLA; GO OUT
075436   ERR:    IF A><-1 THEN
075441              *IOF
075442              A=:SINEC; X:=RTREF; CALL 9FLEX(SINEC,1)
075447              *ION
075450           FI
075450   OUT:    A:="OFLDN"; CALL XUNLOCK            % UNLOCK OPEN FILE TABLE
075452           GO BDTMR                            % RETURN TO RTREC LOOP
075453   RBUS
075462
075462   %==============================================================================
075462   %                       X B D T V                                      (R)
075462   % TRIES TO RECONNECT TO MIRROR POOL IF BDIO HAS SWITCHED TO MIRROR POOL
075462   % IF NOT SUCCESSFUL, RECONNECT IS NOT TRIED ANYMORE
075462   % ENTRY: B-REG: ADDRESS OF POOL/AREA DATAFIELD
075462   SUBR XBDTV
075462   XBDTV:  A:=L=:"BDTMR"                       % SAVE RETURN ADDRESS IN POOL DF
075464           A:="OFLDN"; CALL XLOCK              % RT-PROG: LOCK OPEN FILE TABLE
075466           T:=PLDNO; CALL FILSYS(RCPOOL)
075471           GO ERR;  1=:RSFLA; GO OUT
075475   ERR:    IF A><-1 THEN
075500              *IOF
075501              A=:SINEC; X:=RTREF; CALL 9FLEX(SINEC,1)
075506              *ION
075507           FI
075507   OUT:    A:="OFLDN"; CALL XUNLOCK            % UNLOCK OPEN FILE TABLE
075511           GO BDTMR                            % RETURN
075512   RBUS
075521
075521
075521   *"8MODI
"075521

075521   %==============================================================================
075521   % 33.1       M O S T I   M O T R I   M O S T O   M O T R O
075521   %            M O T M O   M O T M I
075521   %
075521
075521   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
075521   %    SYNCRONOUS MODEM DRIVER                 %
075521   %    AND HANDLING ROUTINES FOR SINTRAN III   %
075521   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
075521
075521   % SUBR MOSTI,MOTRI,MOSTO,MOTRO,MOTMO,MOTMI,TDBPUT,TDBGET
075521   SUBR MOSTI,MOTRI,MOSTO,MOTRO,MOTMO,MOTMI
075521   DISP -12
075521   INTEGER MOWSTAT
075521   INTEGER TERSW,MOSW
075521   PSID
075521   % SET STATUS FOR MODEM INPUT
075521   % A=-3: READ MOSW, AND RETURN IT TO THE USER
075521   % A=-2: INITIATE BLOCK RECEIVE (SEARCH FOR SYNC)
075521   % A=-1: CLEAR INPUT BUFFER
075521   % A= 0: UNDEFINED TERMINATE CONDITION
075521   % A= 1: SET DCT-2000 TERMINATE CONDITION
075521   % A= 2: SET CD-200USER TERMINATE CONDITION
075521   % A= 3: SET GERTS-115 TERMINATE CONDITION
075521   % A= 4: SET IBM-3780/2780 TERMINATE CONDITION
075521   % A= 5: SET VIP TERMINATE CONDITION
075521   % A= 6: SET HASP WS TERMINATE CONDITION
075521   % A= 7: SET UNIVAC NTR TERMINATE CONDITION
075521   % A=10: SET MSV2 TERMINATE CONDITION
075521   % A=11: SET IBM-3270 TERMINATE CONDITION
075521   % A=12: SET BTH/VIP7700 TERMINATE CONDITION
075521   % A=13: SET STANSAAB TERMINATE CONDITION
075521   % A=14: SET UTS-400  TERMINATE CONDITION
075521   %
075521   %
075521   %      SET STATUS FOR MODEM INPUT
075521   %
075521   MOSTI: IF A<0 GO MOSI5
075522          IF A>14 GO MOSI6
075525          A=:TERSW; EXIT                  % SET TERMINATE CONDITION
075527   MOSI5: IF A+4<0 GO MOSI6
075531          GOSW MOSI4, MOSI3, MOSI2, MOSI1
075536   MOSI4: EXIT
075537   %
075537   %      CHECK IF A COMPLETE BLOCK IS RECEIVED
075537   %
075537   MOSI3: A:=0
075540          IF T:=MOSW-4=0 THEN 5=:MOSW; A:=1 FI
075547          EXIT
075550   %
075550   %      INITIATE BLOCK RECEIVE (SEARCH FOR SYNC), CLEAR INPUT BUFFER
075550   %
075550   MOSI2: T:=HDEV; *EXR ST; EXR ST        % DUMMY READ
075553          2204; T:=HDEV+DCONT; *EXR ST
075557          2205; GO MOSI7
075561   %
075561   %      RECEIVER RESET, CLEAR BUFFER
075561   %
075561   MOSI1: 2204
075562   MOSI7: T:=HDEV+DCONT;*EXR ST
075565          0=:MOSW
075566          A:=0 BONE 14; *MCL PID          % DISABLE DRIVER ON LEVEL 12
075571          GO CLBUF
075572   MOSI6: EXIT
075573   %
075573   %      TIMER ROUTINE FOR MODEM INPUT
075573   %
075573   MOTMI: 4=:MOSW
075575          2204; T:=HDEV+DCONT; *EXR ST
075601          GO RTACT
075602   %
075602   %      IOTRANS ROUTINE FOR MODEM INPUT
075602   %
075602   MOTRI: L+1
075603          IF BHOLD>0 THEN T:=MBSYMOD; GO TDBGET FI
075610          A:=-1; EXIT
075612   *)FILL
075620   %
075620   %      SET STATUS FOR MODEM OUTPUT :
075620   %
075620   % A=-1: CLEAR MODEM OUTPUT BUFFER
075620   % A= 0: START SENDING OF CURRENT BLOCK
075620   % A= 1: SET 377 - BYTES TO SEND BETWEEN DATA
075620   % A= 2: SET ASCII SYNC TO SEND
075620   % A= 3: SET EBCDIC SYNC TO SEND
075620   % A= 4: SYNCRONIZE ON 26 RECEIVED (ASCII)
075620   % A= 5: SYNCRONIZE ON 62 RECEIVED (EBCDIC)
075620   % A= 6: SYNCRONIZE ON 226 RECEIVED (ASCII)
075620   % A= 7: SET ASCII SYNC (226 TO SEND BETWEEN DATA)
075620   %
075620   MOSTO: IF A+1<0 OR >10 THEN EXIT FI
075626          GOSW MOSCL,MOS0,MOS1,MOS2,MOS3,MOS4,MOS5,MOS6,MOS7
075640   MOS1:  777;  GO MOS11
075642   MOS2:  426;  GO MOS11
075644   MOS3:  462;  GO MOS11
075646   MOS4:  1026; GO MOS11
075650   MOS5:  1062; GO MOS11
075652   MOS6:  1226; GO MOS11
075654   MOS7:  626;
075655   MOS11: T:=HDEV-3;*EXR ST;EXIT          % UPDATE HARDWARE SYNCREGISTERS
075661
075661   MOSCL: 0=:MOWSTAT=:TMR=:DERROR
075664          GO CLBUF
075665
075665   MOS0:  5; T:=HDEV+DCONT; *EXR ST
075671          TTMR=:TMR; 2=:MOWSTAT; EXIT     % SET WAIT CONDITION
075676   %
075676   %      IOTRANS ROUTINE FOR MODEM OUTPUT
075676   %
075676   MOTRO: IF T:=MOWSTAT-2=0 THEN EXIT FI  % CALLING PROGR WILL WAIT
075703          IF T:=CFREE=0 THEN
075706              131=: DERROR  % NO MORE BUFFER SPACE
075710              EXIT          % ERROR RETURN
075711          FI
075711          L+1; T:=MBSYMOD; GO TDBPUT
075714   %
075714   %      TIME-OUT SUBROUTINE FOR MODEM OUTPUT
075714   %
075714   MOTMO: 12=:DERROR
075716          "0"; T:=HDEV+DCONT; *EXR ST
075722          IF ISTATE>0 GO RTACT
075725          0=:MOWSTAT
075726          EXIT
075727   RBUS
075742   *"8HMO1+8HMO2+8HMO3+8HMO4+8HMO5+8HMO6
"075742
075742   %==============================================================================
075742   % 33.11      H O S T I   H O T R I   H O S T O   H O T R O
075742   %            H O T M O   H O T M I
075742   %
075742
075742   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
075742   % SYNCRONOUS MODEM DRIVER FOR HDLC INTERFACE
075742   % AND HANDLING ROUTINES FOR SINTRAN III
075742   %
075742   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
075742
075742   SUBR HOSTI,HOTRI,HOSTO,HOTRO,HOTMO,HOTMI
075742   DISP -14
075742          INTEGER HTFIL                   % OUTPUT UNDERRUN FILL CHAR
075742          INTEGER HOWSTAT
075742          INTEGER HERSW
075742          INTEGER HDXOK                   % CLEARED BY X21
075742          INTEGER MOSW
075742   PSID
075742   % SET STATUS FOR MODEM INPUT
075742   % A=-3: READ MOSW, AND RETURN IT TO THE USER
075742   % A=-2: INITIATE BLOCK RECEIVE (SEARCH FOR SYNC)
075742   % A=-1: CLEAR INPUT BUFFER
075742   % A= 0: UNDEFINED TERMINATE CONDITION
075742   % A= 1: SET DCT-2000 TERMINATE CONDITION
075742   % A= 2: SET CD-200USER TERMINATE CONDITION
075742   % A= 3: SET GERTS-115 TERMINATE CONDITION
075742   % A= 4: SET IBM-3780/2780 TERMINATE CONDITION
075742   % A= 5: SET VIP TERMINATE CONDITION
075742   % A= 6: SET HASP WS TERMINATE CONDITION
075742   % A= 7: SET UNIVAC NTR TERMINATE CONDITION
075742   % A=10: SET MSV2 TERMINATE CONDITION
075742   % A=11: SET IBM-3270 TERMINATE CONDITION
075742   % A=12: SET BTH/VIP7700 TERMINATE CONDITION
075742   % A=13: SET STANSAAB TERMINATE CONDITION
075742   % A=14: SET UTS-400  TERMINATE CONDITION
075742   %
075742   %
075742   % SET STATUS FOR MODEM INPUT
075742   HOSTI: A=:D
075743          IF HDXOK><X21OP THEN 12=:DERROR; EXIT FI
075752          D=:A
075753          IF A<0 GO MOSI5
075754          IF A>14 GO MOSI6
075757          A=:HERSW; EXIT        % SET TERMINATE CONDITION
075761   MOSI5: IF A+4<0 GO MOSI6
075763          GOSW MOSI4, MOSI3, MOSI2, MOSI1
075770   MOSI4: EXIT
075771   MOSI3: "0"; IF T:=MOSW-4=0 THEN 5=:MOSW;1 FI;EXIT
076002   MOSI2: T:=HDEV+BRRDR;*EXR ST;EXR ST    % DUMMY READ
076006          100; T+"BWRTC-BRRDR"; *EXR ST   % STOP RECEIVER
076011          105; *EXR ST                    % START AND SEARCH FOR SYN
076013          1=:HOWSTAT
076015          0=:MOSW; GO FAR CLBUF
076017   MOSI1: A:=100; T:=HDEV+BWRTC; *EXR ST
076023          A:=0; T+"BWCHL-BWRTC"; *EXR ST  % 8 BITS BYTE
076026          0=:MOSW
076027          GO FAR CLBUF
076030   MOSI6: EXIT
076031   %
076031   % TIMER ROUTINE FOR MODEM INPUT
076031   HOTMI: 4=:MOSW
076033          100; T:=HDEV+BWRTC; *EXR ST
076037          GO FAR RTACT
076040   % IOTRANS ROUTINE FOR MODEM INPUT
076040   HOTRI: L+1
076041          IF BHOLD>0 THEN T:=MBSYMOD; GO TDBGET FI
076046          A:=-1;EXIT;*)FILL
076054   %
076054   %
076054   % SET STATUS FOR MODEM OUTPUT
076054   % A=-1: CLEAR MODEM OUTPUT BUFFER
076054   % A= 0: START SENDING OF CURRENT BLOCK
076054   % A= 1: SET 377 - BYTES TO SEND BETWEEN DATA
076054   % A= 2: SET ASCII SYNC TO SEND
076054   % A= 3: SET EBCDIC SYNC TO SEND
076054   % A= 4: SYNCRONIZE ON 26 RECEIVED (ASCII)
076054   % A= 5: SYNCRONIZE ON 62 RECEIVED (EBCDIC)
076054   % A= 6: SYNCRONIZE ON 226 RECEIVED (ASCII)
076054   % A= 7: SET ASCII SYNC (226 TO SEND BETWEEN DATA)
076054   %
076054   HOSTO: A=:D
076055          IF T:=HDXOK><X21OP THEN 12=:DERROR; EXIT FI
076064          D=:A
076065          IF A+1<0 OR >10 THEN EXIT FI
076073          GOSW MOSCL,MOS0,MOS1,MOS2,MOS3,MOS4,MOS5,MOS6,MOS7
076105   MOS1:  377=:HTFIL; T:=HDEV+BWTDR; *EXR ST   % DUMMY SYNC CHAR
076112          107; T+"BWPCR-BWTDR"; *EXR ST   % SYNC AS UNDERRUN FILL CHAR
076115          EXIT
076116   MOS4:  26=:HTFIL
076120   MOS2:  26; GO MOS11
076122   MOS5:  62=:HTFIL
076124   MOS3:  62; GO MOS11
076126   MOS7:  226=:HTFIL
076130   MOS6:  226
076131   MOS11: T:=HDEV+BWSAR; *EXR ST;         % UPDATE HARDWARE SYNCREGISTER
076134          IF HTFIL=377 THEN 117 ELSE 107 FI
076143          T:=HDEV+BWPCR; *EXR ST
076146          EXIT
076147   MOSCL: 0=:HOWSTAT=:TMR=:DERROR
076152          GO FAR CLBUF
076153   MOS0:  "MODXX"=:"DRIVER"               % ENTRY POINT FIRST INTERRUPT
076155          1; T:=HDEV+BWTCR; *EXR ST       % SEND SYNC CHAR, AND START TRANSMITTER
076161          105; T+"BWTTC-BWTCR"; *EXR ST   % ENABLE OUTPUT
076164          TTMR=:TMR;2=:HOWSTAT;EXIT       % SET WAIT CONDITION
076171   % IOTRANS ROUTINE FOR MODEM OUTPUT
076171   HOTRO: IF T:=HOWSTAT-2=0 THEN EXIT FI   % CALLING PROGR WILL WAIT
076176          L+1; T:=MBSYMOD; GO TDBPUT
076201   %
076201   % TIME-OUT SUBROUTINE FOR MODEM OUTPUT
076201   HOTMO: 12=:DERROR
076203          A:=0; T:=HDEV+BWTTC; *EXR ST
076207          IF ISTATE>0 GO FAR RTACT
076212          0=:HOWSTAT
076213          EXIT
076214   RBUS
076223   *"
"076223   *"8SIBA 8OSIB
"076223
076223   @DEV 1
076223   @DEV (S-S-L)RP-P2-MONCALLS:NPL
076223   % TAB S8,4
076223   %

076223   %======================= C X - R P I T - M O N C A L L S ======================
076223
076223   %===========================================================================
076223   %      ( R )      F I X C  -   F I X C 5 0 0
076223   %
076223
076223   SUBR FIXC,FIXC500
076223
076223   DISP 26            % DISP D6
076223   INTEGER FIXFLAG
076223   INTEGER SGADR
076223   INTEGER NPAG
076223   INTEGER CURPAGE
076223   INTEGER FPHYS
076223   INTEGER CECORMAP
076223   INTEGER CCORMSTART
076223   INTEGER CMMENTRY
076223   INTEGER CSEGAD
076223   INTEGER COLDFLAG
076223   INTEGER CFXCTADDR
076223   INTEGER SVFLAGB
076223   INTEGER AFPHYS
076223   INTEGER ALPHYS
076223   INTEGER PGFOUND
076223   INTEGER PARTINDX
076223   INTEGER RETINDX
076223   INTEGER CPEND
076223   PSID
076223   %
076223   % MON FIXC(SEGMENT NUMBER,PHYSICAL PAGE NUMBER)
076223   %
076223
076223   FIXC:  CALL GET2                                 % D0=SEG.NO, D1=PHYSICAL PAGE NO.
076224          IF D0 BZERO 17<<2 OR A>>SGMAX GO ERRIL    % ILLEGAL SEGMENT NUMBER
076234          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
076237          T:=SEGTBANK; X:=SGADR; *SEGLE@3 LDATX     % A=SEGMENT SIZE
076242          IF A=0 GO ERRNL                           % EMPRY SEGEMENT
076243          A=:NPAG
076244          *FLAG@3 LDATX                             % A=SEGMENT FLAG
076245          IF A BIT 5INHB GO ERRNL                   % SEGMENT NOT LOADED
076247          IF A BIT 5DEMAND GO ERRD                  % DEMAND SEGMENT NOT LEGAL
076251          *SGSTA@3 LDATX                            % A=SEGMENT STATUS
076252          IF A=0 GO ERRNL                           % SEGMENT NOT LOADED
076253          IF A BIT 5FIX THEN                        % SEGMENT IS FIXED
076255             D1=:CURPAGE; *BPAGL@3 LDXTX            % CHECK IF FIXED CONTIGUOUS IN CORRECT MEMORY ADDR
076260             T:=CORMBANK
076261             DO
076261                IF A:=X SHZ -2 -CURPAGE><0 GO ERRFX % FIXED IN WRONG ADDR
076265                MIN CURPAGE; *PAGLI@3 LDXTX
076267             WHILE X><0
076270             OD; GO FXOKRET                         % SEGMENT FIXED CONTIGUOUS IN CORRECT ADDR
076272          FI; *FLAG@3 LDATX                         % A=SEGMENT FLAG
076273          IF A BIT 5FIXC THEN                       % SEGMENT ALREADY FIXED CONTIGUOUS
076275             *BPAGL@3 LDATX
076276             IF A SHZ -2=D1 GO FXOKRET              % OK, FIXED CONTIGUOUS IN CORRECT ADDR.
076302             GO ERRFX                               % ERROR, FIXED CONTIGUOUS IN WRONG ADDR.
076303          FI
076303          IF NPAG+FIXPAGES>>FIXMAX GO ERRF          % TOO MANY FIXED PAGES
076310          NPAG+MINSWPAGES; CALL CHNSWPAGES; GO ERRF
076314          D1=:FPHYS                                 % FIRST PHYSICAL PAGE
076316          0=:FIXFLAG                                % ROUTINE SWITCH IN PFIXC
076317          GO FAR PFIXC                              % GO TO COMMON ROUTINE FOR MON FIXC AND MON FIXC5
076320
076320   ERRIL: IF D0 BIT 17 THEN A:=-2; GO FXRET FI
076325          CALL 9ERRA(#15); GO RETXIT                % ILL.SEGM.NO.
076330   ERRNL: IF D0 BIT 17 THEN A:=-3; GO FXRET FI
076335          CALL 9ERRA(#16); GO RETXIT                % NOT LOADED
076340   ERRD:  IF D0 BIT 17 THEN A:=-4; GO FXRET FI
076345          CALL 9ERRA(#17); GO RETXIT                % FIXING DEMAND
076350   ERRF:  IF D0 BIT 17 THEN A:=-5; GO FXRET FI
076355          CALL 9ERRA(#18); GO RETXIT                % TOO MANY PAGES FIXED
076360   ERRFX: IF D0 BIT 17 THEN A:=-6; GO FXRET FI
076365          CALL 9ERRA(#25); GO RETXIT                % ALREADY FIXED
076370   FXOKRET: X:=SGADR; T:=SEGTBANK; *FLAG@3 LDATX
076373          A BONE 5FIXC; *FLAG@3 STATX               % MARK SEGMENT FIXED CONTIGUOUS
076375          IF D0 BIT 17 THEN A:=0 FI                 % FIXED CONTIGUOUS OK.
076401   FXRET: A=:ZAREG; GO RETSTUPR                     % RETURN TO USER PROGRAM
076403   *)FILL
076421
076421   %=========================================================================
076421   %      ( R )      F I X C 5 0 0
076421   %
076421   % MONITOR CALL TO ALLOCATE MEMORY SPACE FOR NORD-500 SEGMENTS
076421   % AND/OR FIXC (IN MEMORY AREA)/ ALLOCATE BUFFER (IN MEMORY AREA)
076421   %
076421   %
076421   % FUNCTION=1:      ALLOCATE MEMORY FOR ND-500.
076421   %
076421   % PAR1:      NUMBER OF PAGES IN SEGMENT
076421   % PAR2:      FIRST LEGAL PHYSICAL PAGE FOR SEGMENT
076421   % PAR3:      LAST LEGAL PHYSICAL PAGE FOR SEGMENT
076421   % PAR4:      MUST BE ZERO! (NUMBER OF SINTRAN III/N500 SHARED AREAS)
076421   % PAR5:      DUMMY         (ADDRESS OF SHARED INFORMATION ARRAY (PHYSICAL ADDRESS))
076421   %
076421   % RETURN:    ERROR - NO AREA ALLOCATED FOR NORD-500
076421   %
076421   % SKIP RETURN:  MEMORY ALLOCATED FOR ND-500.
076421   %               A=FIRST PHYSICAL PAGE IN NORD-500 SEGMENT
076421   %
076421   %
076421   % FUNCTION=2:    GIVE N500 SWAPPING PAGES
076421   %
076421   % PAR1:      NO. OF PAGES
076421   % PAR2:      NO. OF N500 HARDWARE CONFIGURATION MEMORY PARTS
076421   % PAR3:      ADDRESS OF N500 HARDWARE CONFIGURATION MEMORY PARTS TABLE
076421   %            (PHYSICAL ADDRESS)
076421   % PAR4:      MAX NO. OF MEMORY INTERVALS TO RETURN
076421   % PAR5:      ADDRESS OF TABLE TO RETURN THE AVAILABLE MEMORY PARTS INTO
076421   %            (PHYSICAL ADDRESS)
076421   %
076421   % RETURN:    ERROR
076421   % SKIP RETURN: A = NO. OF MEMORY INTERVALS
076421   %
076421   %
076421   % FUNCTION=3:   ILLEGAL FUNCTION (TAKE PAGES FROM N500)
076421   %
076421   % PAR1:      (NO. OF PAGES)
076421   % PAR2:      (NO. OF MEMORY PARTS)
076421   % PAR3:      (ADDRESS OF MEMORY PARTS TABLE (PHYSICAL ADDRESS))
076421   % PAR4:      (DUMMY)
076421   % PAR5:      (DUMMY)
076421   %
076421   % RETURN:    ERROR
076421   % SKIP RETURN: OK
076421   %
076421   %
076421   % FUNCTION=4:   FIX A SEGMENT CONTIGOUSLY AT ANY ADDRESS WITHIN A
076421   %               SPECIFIED AREA
076421   %
076421   % PAR1:      SEGMENT NUMBER
076421   % PAR2:      FIRST (LOWER) LEGAL PHYSICAL PAGE NUMBER
076421   % PAR3:      LAST (UPPER) LEGAL PHYSICAL PAGE NUMBER
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    A=0: AREA OCCUPIED
076421   %            A=1: "PAR2">>LAST PAGE IN MEMORY MAP
076421   %            A=2: SOMETHING WRONG WITH THE SEGMENT (DEMAND, ALREADY FIXED...)
076421   %
076421   % SKIP RETURN:  SEGMENT IS FIXED CONTIGOUSLY, A=FIRST PHYSICAL PAGE IN SEGMENT
076421   %
076421   %
076421   % FUNCTION=5:   RESERVE A CONTIGOUS MEMORY AREA
076421   %
076421   % PAR1:      NUMBER OF PAGES TO RESERVE
076421   % PAR2:      FIRST (LOWER) LEGAL PHYSICAL PAGE
076421   % PAR3:      LAST (UPPER) LEGAL PHYSICAL PAGE
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR:
076421   %            A=0: AREA OCCUPIED
076421   %            A=1: "PAR2" >> LAST PAGE IN MEMORY MAP
076421   %            A=2: NO FREE TABLE ELEMENT (TRYING TO RESERVE TO MANY AREAS)
076421   %            A=3: WRONG PARAMETERS OR TOO MANY FIXED
076421   %
076421   % SKIP RETURN:  OK, A=FIRST PHYSICAL PAGE IN AREA, T=TABLE INDEX
076421   %
076421   %
076421   % FUNCTION=6:   RELEASE MEMORY AREA RESERVED BY FUNCTION=5
076421   %
076421   % PAR1:      TABLE INDEX (RETURN PARAMETER FROM FUNCTION=5)
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA (FROM FUNCTION=5)
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR
076421   %
076421   % SKIP RETURN:  OK
076421   %
076421   %
076421   % FUNCTION=7:   RELEASE ALL MEMORY AREAS RESERVED BY A SPECIFIC PROGRAM.
076421   %               THE MEMORY AREAS MUST BE RESERVED BY FUNCTION=5 IN MON 61.
076421   %
076421   % PAR1:      RT-PROGRAM WHICH HAS RESERVED THE MEMORY AREAS
076421   %            PAR1=0 MEANS CALLING PROGRAM.
076421   % PAR2:      DUMMY
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR
076421   %
076421   % SKIP RETURN: OK
076421   %
076421   %
076421   %
076421   % FUNCTION=10:  GET SEGMENT'S FIXED-STATUS
076421   %
076421   % PAR1:      SEGMENT NUMBER
076421   % PAR2:      PAGE NUMBER WITHIN SEGMENT TO FIND THE PHYSICAL MEMORY PAGE OF,
076421   %            IF THE SEGMENT IS FIXED.
076421   %            <PAR2>=0 IS ALLWAYS FIRST PAGE IN SEGMENT.
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR; A=174 : ILLEGAL SEGMENT NUMBER <PAR1> OR ILLEGAL PAGE
076421   %                           NUMBER WITHIN SEGMENT <PAR2>
076421   %                   A=2   : SEGMENT NOT LOADED
076421   %
076421   % SKIP RETURN: OK, T=FIXED STATUS
076421   %                  T=0 : SEGMENT NOT FIXED
076421   %                  T=1 : SEGMENT FIXED SCATTERED
076421   %                  T=2 : SEGMENT FIXED CONTIGUOUSLY
076421   %                  A=PHYSICAL PAGE NUMBER WHER <PAR2> PAGE RESIDE IN MEMORY
076421   %                  D=SEGMENT-TABLE-ELEMENT.FLAG
076421   %
076421   %
076421   %
076421   % FUNCTION=11:  GET INFORMATION ABOUT A PROGRAMS ATTATCHED SEGMENTS.
076421   %               (MON.CALL WHAMI).
076421   %
076421   % PAR1:      ACTUAL RT-PROGRAM (=0 MEANS CALLING PROGRAM)
076421   % PAR2:      ADDR OF ARRAY WHERE THE SEGMENT INFO IS STORED
076421   %            THE SIZE OF THE ARRAY MUST BE AT LEAST 18 WORDS.
076421   %            THE LAYOUT OF THE INFORMATION IS:
076421   %      ELEMENT # 0: SEGMENT NUMBER OF ACTSEG 1 (BIT 0-7 IN ACSEG; J-VERS AND VSE)
076421   %      ELEMENT # 1: FIRST LOGICAL PAGE IN ACSEG 1
076421   %      ELEMENT # 2: SEGMENT SIZE IN NUMBER OF PAGES
076421   %      ELEMENT # 3: SEGMENT DESCRIPTOR
076421   %              BIT 17B:     WRITE PERMITTED
076421   %              BIT 16B:     READ PERMITTED
076421   %              BIT 15B:     FETCH PERMITTED
076421   %              BIT 11B-12B: PROTECTION RING OF SEGMENT
076421   %              BIT  5B:     DEMAND SEGMENT
076421   %              BIT  4B:     SEGMENT IS FIXED CONTIGUOUSLY
076421   %              BIT  3B:     SEGMENT IS FIXED.
076421   %              BIT  2B:     REENTRANT SUBSYSTEM SEGMENT
076421   %              BIT  1B:     PROTECTED SEGMENT
076421   %              BIT  0B:     SYSTEM SEGMENT
076421   %      ELEMENT # 4: FIRST PHYS.PAGE OF SEGMENT IF FIXED CONTIGUOUSLY.
076421   %
076421   %      ELEMENT # 5 - 9 : SAME AS ELEMENT # 0 - 4, BUT FOR ACTSEG2, (BIT 8-15 IN ACTSEG
076421   %                                                 VSE AND J-VERSION).
076421   %
076421   %      ELEMENT #10 -14 : SAME AS ELEMENT # 0 - 4, BUT FOR REENTRANT SEGMENT
076421   %
076421   %      ELEMENT #15: FIRST LOGICAL PAGE OF RTCOMMON (=0 IF NO RTCOMMON).
076421   %      ELEMENT #16: SIZE OF RTCOMMON IN PAGES.
076421   %      ELEMENT #17: FIRST PHYSICAL PAGE OF RTCOMMON (=0 IF RTCOMMON NOT CONTIGUOUS)
076421   %
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   %
076421   % FUNCTION=12:  RELEASE NINITPAGES OR MEMORY AREA RESERVED BY FUNCTION=5 IN FIXC5
076421   %
076421   % PAR1:      ><0 : SAME AS FOR FUNCTION=6, (TABLE INDEX RETURNED IN FUNCTION=5)
076421   %            =0  : RELEASE A WHOLE AREA IN NINITPAGES
076421   %
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA.
076421   % PAR3:      NUMBER OF PAGES IN AREA (DUMMY IF PAR1><0)
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % FUNCTION=13:  RELEASE LAMARPAGES OR MEMORY AREA RESERVED BY FUNCTION=5 IN FIXC5
076421   %
076421   % PAR1:      ><0 : SAME AS FOR FUNCTION=6, (TABLE INDEX RETURNED IN FUNCTION=5)
076421   %            =0  : RELEASE A WHOLE AREA IN NINITPAGES
076421   %
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA.
076421   % PAR3:      NUMBER OF PAGES IN AREA (DUMMY IF PAR1><0)
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421
076421
076421
076421   FIXC500:
076421          CALL GET6
076422          IF D0>>13 OR A=0 OR A=3 GO ERET           % ILLEGAL FUNCTION CODE
076432          A=:FIXFLAG                                % SET ROUTINE SWITCH (1 TO 10)
076433          IF A<4 AND PN500=0 GO ERET                % FUNCTION CODE << 4 ILLEGAL WHEN SYSTEM
076440                                                    % NOT GENERATED WITH ND-500
076440          IF FIXFLAG=11 THEN
076444             X:=ZAREG+2; CALL USALTPIT; X.S0; CALL SINALTPIT
076451             A=:D2                                  % ADDR OF CALLER'S ARRAY
076452             MLEV; *MCL PIE                         % INCASE PAGE-FAULT.
076454          FI; GO FAR PFIXC
076455   ERET:  174=:ZAREG; GO RET                        % ILLEGAL PARAMETER
076460   *)FILL
076466
076466

076466   %=====================================
076466   % C L E A L L S E G S
076466   %
076466   % LOCAL SUBROUTINE TO CLEAR ALL SEGMENTS FROM PITS
076466   %
076466   CCCLS: IF T><0 THEN
076470             "1XCLSEG"; *IOF; IRW SLEVB DP
076473             SLEV; *MST PID
076475             A:=T; *ION
076477             X:=A; T:=SEGTBANK; *FLAG@3 LDATX
076502             A BZERO 5OK; *FLAG@3 STATX
076504          FI; EXIT
076505
076505   CSNOK: A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *FLAG@3 LDATX
076512          A BZERO 5OK; *FLAG@3 STATX
076514          EXIT
076515
076515   CLEALLSEGS: L=:D
076516          "1XCSEGS"; *IOF; IRW SLEVB DP
076521          SLEV; *MST PID; ION
076524          T:=S3SEG; 0=:S3SEG; CALL CCCLS  % CLEAR SEGMENTS FROM PITS
076527          T:=FILSEGM; CALL CCCLS
076531          T:=5NSEGM; CALL CCCLS
076533          T:=FUSEGM; CALL CCCLS
076535          5OPSEG;   CALL CSNOK            % SET SPIT-SEGMENTS NOT OK
076537          5RTSG;    CALL CSNOK
076541          5MACDSEG; CALL CSNOK
076543          ECODSEG;  CALL CSNOK
076545          5BADM;    CALL CSNOK
076547          5SMSEG;   CALL CSNOK; 5NKSERV; CALL CSNOK
076553          5PROMAN;  CALL CSNOK; 5EVME;   CALL CSNOK
076557          5BOPC;    CALL CSNOK; 5MTSE;   CALL CSNOK
076563          D=:P
076564   *)FILL
076575   %======================================
076575   % I D U M L I N K
076575   %
076575   % LOCAL SUBROUTINE TO LINK A PAGE INTO THE DUMMY SEGMENT (FREE PAGE LINK)
076575   %
076575   % ENTRY: X=MEMORY MAP ELEMENT
076575   %
076575   IDUMLINK:
076575          T:=CORMBANK; *PROTE@3 LDATX
076577          IF A BIT 5CMIDUM THEN                     % DOES PAGE BELONG TO DUMMY SEGMENT?
076601             A BZERO 5CMIDUM; *PROTE@3 STATX        % YES, RESET TEMPORARY MARK
076603             X=:D:=XSGRT; T:=SEGTBANK; *BPAGL@3 LDXTX
076607             IF X><0 THEN
076610                A:=D; T:=CORMBANK; *PREVI@3 STATX   % ACTUAL MM-ELEMENT=:(XSGRT.BPAGLINK).PREVIOUS
076613                A:=:X; *PAGLI@3 STATX               % XSGRT.BPAGLINK=:ACTUAL MM-ELEMENT.PAGLINK
076615             ELSE
076616                X:=D; T:=CORMBANK; *PAGLI@3 STZTX   % 0=:ACTUAL MM-ELEMENT.PAGLINK
076621             FI; A:=7; *PREVI@3 STATX               % SET ACTUAL MM-ELEMENT.PREVIOUS
076623             X:=XSGRT; T:=SEGTBANK; A:=D; *BPAGL@3 STATX % ACTUAL MM-ELEMENT=:XSGRT.BPAGLINK
076627             *SEGLI@3 LDATX
076630             IF A=0 THEN
076631                "1INSEGLINK"; *IOF; IRW SLEVB DP    % INSERT DUMMY.SEGM. IN SEGMENT LISTE
076634                SLEV; *MST PID; ION
076637                T:=SEGTBANK; *IOF; SEGLI@3 LDATX
076642                A=:BSEGLINK; *ION                   % SET DUMMY.SEGM LAST IN SEGMENT LISTE
076644             FI; X:=D
076645          FI; EXIT
076646   *)FILL
076653
076653   %======================================
076653   % S O R T D U M M Y
076653   %
076653   % LOCAL SUBROUTINE TO SORT THE PAGE FREE LIST
076653   %
076653   % ENTRY: A=FIRST PHYSICAL PAGE IN ACTUAL AREA
076653   %        D=LAST PHYSICAL PAGE IN ACTUAL AREA
076653   %        T>=0: SORTING IN ASCENDING PAGE NUMBERS
076653   %        T<0:  SORTING IN FALLING PAGE NUMBERS
076653   %
076653   INTEGER POINTER SORTRET
076654   INTEGER SORTFPAGE,SORTLPAGE,SORTXREG,SORT
076660
076660   SORTDUMMY: A=:SORTFPAGE:=D=:SORTLPAGE:=L=:"SORTRET"
076665          X=:SORTXREG; T=:SORT
076667          X:=XSGRT; T:=SEGTBANK; *BPAGL@3 LDATX
076672          IF A=0 GO SORTOUT                         % PAGE FREE LIST EMPTY?
076673          *BPAGL@3 STZTX                            % NO, 0=:XSGRT.BPAGLINK
076674          T:=CORMBANK; X:=A
076676          DO
076676             *PROTE@3 LDATX
076677             A BONE 5CMIDUM; *PROTE@3 STATX         % MARK ALL PAGES IN DUMMY TEMPORARY
076701             *PAGLI@3 LDXTX
076702          WHILE X><0
076703          OD
076704          IF SORTFPAGE><0 THEN
076706             A-1 SH 2=:CECORMAP; X:=CORMSTART       % INSERT PAGES BELOW ACTUAL AREA IN DYMMY AGAIN
076712             DO WHILE X><CECORMAP; CALL IDUMLINK; X+4 OD
076720          FI; SORTLPAGE+1 SH 2=:X; IF X=0 GO CONT   % INSERT PAGES ABOVE ACTUAL AREA IN DUMMY AGAIN
076725          DO WHILE X<<=ECORMAP; CALL IDUMLINK; IF X+4=0 GO CONT; OD
076734   CONT:  IF SORT>=0 THEN
076736             SORTFPAGE SH 2=:CECORMAP               % SORT IN ASCEDING ORDER
076741             SORTLPAGE SH 2=:X
076744             DO WHILE X>>=CECORMAP; CALL IDUMLINK; X-4 OD
076752          ELSE
076753             SORTLPAGE SH 2=:CECORMAP               % SORT IN FALLING ORDER
076756             SORTFPAGE SH 2=:X
076761             DO WHILE X<<=CECORMAP; CALL IDUMLINK; IF X+4=0 GO SORTOUT; OD
076770          FI
076770   SORTOUT: X:=SORTXREG; GO SORTRET
076772   *)FILL
076777
076777   %===========================================
076777   % R L S A R E A
076777   %
076777   % LOCAL SUBROUTINE TO  RELEASE AN ALLOCATED MEORY AREA
076777   %
076777   % ENTRY: X=ADDR IN FXCTAB
076777   %
076777   INTEGER POINTER RLSRRET
077000   INTEGER RLSAXREG,RLSAFPAGE,RLSALPAGE
077003   RLSAREA: X=:RLSAXREG; A:=L=:"RLSRRET"
077006          T:=MBFXCTAB; *LDATX
077010          A=:X SHZ -2=:RLSAFPAGE
077013          T:=CORMBANK
077014          DO
077014             A:=0 BONE 5CMIDUM; *PROTE@3 STATX; PAGLI@3 LDATX % MARK ELEMNT SHALL BE INSERTED IN DUMMY
077020          WHILE A><0
077021             X:=A
077022          OD; A:=X SHZ -2=:RLSALPAGE
077026          RLSAFPAGE SH 2=:X
077031          DO CALL FAR IDUMLINK WHILE X><RLSALPAGE SH 2; X+4 OD
077040          T:=MBFXCTAB; X:=RLSAXREG; *STZTX  % CLEAR ELEMENT IN FXCTAB
077043          GO RLSRRET
077044   *)FILL
077047
077047   %========================
077047   % C F I N D S E G M E N T
077047   %
077047   % LOCAL SUBROUTINE TO FIND THE SEGMENT TABLE ENTRY
077047   % A MEMORY MAP ELEMENT BELONGS TO
077047   %
077047   % ENTRY:   X=MEMORY MAP ELEMENT
077047   %
077047   % EXIT:    A=SEGMENT TABLE ELEMENT ADDR OF SEGMENT OWNING THE MEMORY MAP ELEMENT
077047   %
077047   CFINDSEGMENT: X=:D; T:=CORMBANK
077051          DO
077051             *PREVI@3 LDATX
077052             IF A BIT 0 OR A BIT 1 THEN
077056                A SHZ -2*5SEGSIZE+SEGSTART          % A=SEGMENT TABLE ELEMENT ADDR
077061                X:=D; EXIT
077063             FI; *PREVI@3 LDXTX
077064          OD
077065   *)FILL
077070
077070   %========================
077070   % S G F I X C
077070   %
077070   % LOCAL SUBROUTINE TO FIND A CONTIGUOUS MEMORY AREA
077070   % AND RESERVE THIS AREA.
077070   %
077070   % ENTRY: FPHYS   = FIRST PHYSICAL PAGE
077070   %        CURPAGE = LAST PHYSICAL PAGE
077070   %
077070   % EXIT:  ERROR
077070   %
077070   % EXIT+1: OK
077070   %
077070   INTEGER POINTER SGFLREG
077071   SGFIXC: A:=L=:"SGFLREG"
077073          CURPAGE SH 2=:CCORMSTART                  % FIRST MEMORYMAP ELEMENT (LAST PHYS PAGE)
077076          FPHYS SH 2=:CECORMAP                      % LAST MEMORYMAP ELEMENT (FIRST PHYS PAGE)
077101          IF X:=CCORMSTART >> ECORMAP GO SGFLREG    % OUTSIDE PHYS. MEMORY
077105          DO
077105             T:=CORMBANK; X=:CMMENTRY; *PROTE@3 LDATX % A=PROTECT
077110             IF A/\5CMMASK><0 GO SGFLREG            % CAN MEMEORY MAP ELEMENT BE USED?
077113             CALL CFINDSEGMENT; A=:CSEGAD           % YES, FIND SEGMENT OWNING THE PAGE
077115             CALL OUTLINK                           % LINK PAGES TO DUMMY SEGMENT IF NON DEMAND SEG.
077116             X:=CSEGAD; T:=SEGTBANK; *FLAG@3 LDATX
077121             A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX   % SET SEGM TEMPORARLY NOT-OK
077124             X:=CMMENTRY; T:=CORMBANK; *PROTE@3 LDATX
077127             IF A BIT 5WIP THEN                     % WRITTEN IN PAGE?
077131                T:=CSEGAD; A:=1=:D; CALL ATRNSEG    % YES, WRITE PAGE TO DISK
077135             FI
077135             IF COLDFLAG BIT 5DEMAND THEN
077140                X:=CSEGAD; T:=SEGTBANK; *FLAG@3 STATX % RESET SEGM.FLAG
077143             FI; X:=CMMENTRY
077144             IF FIXFLAG=0 OR A=4 THEN A:=CSEGAD; T:=SGADR; CALL XLINKOVER FI
077154             IF FIXFLAG=1 OR A=2 THEN A:=CSEGAD; CALL X5LINKOVER FI
077165             IF FIXFLAG=5 THEN A:=CSEGAD; T:=CFXCTADDR; CALL XALINKOVER FI
077174             IF X=CECORMAP THEN                     % ALL PAGES FOUND?
077177                IF FIXFLAG=0 OR A=4 THEN            % YES, FIX-SEGMENT-CONTIGUOUS?
077204                   T:=SEGTBANK; X:=SGADR; *FLAG@3 LDATX
077207                   A BONE 5FIXC BONE 5OK; *FLAG@3 STATX  % SET SEGMENT FIXC AND OK
077212                   *SGSTA@3 LDATX
077213                   A BONE 5FIX=:D; *SGSTA@3 STATX        % SET SEGMENT FIXED
077216                   *LOGAD@3 LDATX; BPAGL@3 LDXTX         % A=LOGADR; X=BPAGLINK
077220                   A:=:D; T:=CORMBANK
077222                   DO WHILE X><0
077223                      *PROTE@3 STDTX                     % SET PROTECT AND LOGPAG
077224                      D+1; *PAGLI@3 LDXTX
077226                   OD
077227                   T:=SEGTBANK; X:=SGADR; *SEGLE@3 LDATX % A=SEGMENT LENGTH
077232                   *BPAGL@3 LDXTX                        % X=SGADR.BPAGLINK
077233                   D:=0; T:=SGADR; CALL ATRNSEG          % TRANSFER SEGMENT TO MEMORY
077236                FI; MIN "SGFLREG"; GO SGFLREG            % OK RETURN
077240             FI; X:=CMMENTRY-4
077242          OD
077243   *)FILL
077254
077254   %===================
077254   % X R E L E S
077254   %
077254   % LOCAL SUBROUTINE TO RELEASE THE "SWAPPING SYSTEM".
077254   %
077254   CCSTSEG: IF X><0 THEN
077255               T:=SEGTBANK; *BPAGL@3 LDXTX
077257               "1XSSEG"; *IOF; IRW SLEVB DP
077262               SLEV; *MST PID; ION
077265            FI; EXIT
077266
077266   CSOK:  A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *FLAG@3 LDATX
077273          A BONE 5OK; *FLAG@3 STATX
077275          EXIT
077276
077276   INTEGER POINTER XRELLREG
077277   XRELES: A:=L=:"XRELLREG"
077301          MLEV; *MCL PIE
077303          X:=FILSEGM; CALL CCSTSEG        % SET SEGMENTS INTO PITS
077305          X:=5NSEGM; CALL CCSTSEG
077307          X:=FUSEGM; CALL CCSTSEG
077311   *FLOME=*                               % FOR FLOMEM
077311          *JMP *+1
077312          5OPSEG;   CALL CSOK             % SET SPIT-SEGMENT OK
077314          ECODSEG;  CALL CSOK             % SET SEGMENT ERROR 14
077316          5RTSG;    CALL CSOK
077320          5MACDSEG; CALL CSOK
077322          5BADM;    CALL CSOK
077324          CALL SRELES                               % RELEASE SWAPPING-DEVS AND SWAPPING SEMAPHORE
077325          0=:FIXCRT                                 % MARK THAT NONE IS EXECUTING FIXC/FIXC5
077326          IF BACKGROUND><0 AND SVFLAGB BIT 5ESCON THEN CALL ESCON FI
077334          MLEV; *MST PIE
077336          GO XRELLREG
077337   *)FILL
077352
077352   %===========================================
077352   % M B S R E M O V E  -  X M B S R E M O V E
077352   %
077352   % LOCAL SUBROUTINE TO REMOVE ALL PAGES OF A SEGMENT FROM MEMORY
077352   %
077352   INTEGER POINTER MBSLREG
077353   INTEGER MBRFLG
077354   XMBSREMOVE: 1=:MBRFLG; GO MBFELLS
077357   MBSREMOVE:  0=:MBRFLG
077360   MBFELLS: A:=L=:"MBSLREG"
077362          X:=SGADR; T:=SEGTBANK; *SEGLI@3 LDATX
077365          IF A><0 THEN                              % HAS SEGMENT PAGES IN MEMORY?
077366             "1OUTSEGLINK"; *IOF; IRW SLEVB DP      % YES, REMOVE SEGMENT FROM SEGLINK.
077371             SLEV; *MST PID; ION
077374          FI; *FLAG@3 LDATX
077375          A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX      % SET SEGMENT NOT AVAILABLE (NOT OK)
077400          DO                                        % REMOVE ALL PAGES CURRENTLY IN SEGMENT
077400             X:=SGADR; T:=SEGTBANK; *BPAGL@3 LDXTX  % X:=SGADR.BPAGLINK
077403          WHILE X><0
077404             T:=CORMBANK; *PROTE@3 LDATX            % A:=(SGADR.BPAGLINK).PROTECT
077406             IF A BIT 5WIP AND MBRFLG=0 THEN        % WRITTEN IN PAGE?
077412                A:=1=:D; T:=SGADR; CALL ATRNSEG     % YES, WRITE PAGE TO MASS STORAGE
077416             FI; T:=XSGRT; SGADR; CALL XLINKOVER   % LINK PAGE TO DUMMY SEGMENT
077421          OD
077422          IF COLDFLAG BIT 5DEMAND THEN
077425             X:=SGADR; T:=SEGTBANK; *FLAG@3 STATX
077430          FI; GO MBSLREG
077431   *)FILL
077437
077437   %===================
077437   % P F I X C
077437   %
077437   % COMMON ROUTINE FOR MON FIXC AND MON FIXC5
077437   %
077437   INTEGER POINTER PPTTIF:=TTIFIELD
077440
077440   PFIXC: IF BACKGROUND><0 THEN
077442             PPTTIF.FLAGB=:SVFLAGB; CALL ESCOFF     % SAVE CURRENT ESCON/ESCOFF STATUS AND SET ESCOFF
077446          FI; CALL SRESER                           % RESERVE "SWAPPING SYSTEM"
077447          RTREF=:FIXCRT                             % CURRENT PROGRAM EXECUTING FIXC/FIXC5
077451          CALL FAR CLEALLSEGS                       % CLEAR ALL SEGMENTS FROM PIT
077452          0=:PAGPN
077453          MLEV; *MST PIE
077455   @ICR
077455          FIXFLAG GOSW 0F500,FAR 1F500,FAR 2F500,FAR 3F500,FAR 4F500,
077464         FAR 5F500,FAR 6F500,FAR 7F500,FAR 10F500,FAR 11F500,FAR 12F500,
077472         FAR 13F500;
077473   @CR;
077473   %
077473   % FIXFLAG=0: NORMAL MON FIXC
077473   % D0: SEGMENT NUMBER
077473   % D1: FIRST PHYSICAL PAGE
077473   %
077473   0F500: CALL FAR MBSREMOVE              % REMOVE SEGMENT FROM MEMORY
077474          NPAG-1+FPHYS=:CURPAGE           % CURRPAGE=LAST PHYSICAL PAGE NEEDED BY THE SEGMENT
077500          CALL FAR SGFIXC; GO 0ERR        % FIX SEGMENT CONTIGUOUSLY
077502          FIXPAGES+NPAG=:FIXPAGES         % UPDATE NUMBER OF PAGES FIXED IN THE SYSTEM
077505          CALL FAR XRELES                 % RELEASE SWAPPING SYSTEM
077506          IF D0 BIT 17 THEN 0=:ZAREG FI
077512          GO RETSTUPR                     % RETURN TO USER AFTER MON FIXC
077513
077513   0ERR:  CALL FAR XMBSREMOVE             % REMOVE ALL PAGES FROM THE SEGMENT
077514          CALL FAR XRELES                 % RELEASE SWAPPING SYSTEM
077515          IF D0 BIT 17 THEN -1=:ZAREG; GO RETSTUPR FI % GIVE ERROR RETURN
077523          CALL 9ERRA(#28); GO RETXIT      % ERROR MESSAGE AND TERMINATE CALLER
077526   *)FILL
077560
077560   %
077560   % FIXFLAG=1: RESERVE CONTIGUOUS MEMORY FOR ND-500
077560   % D1=NUMBER OF PAGES
077560   % D2=FIRST LEGAL PHYSICAL PAGE IN AREA TO RESERVE
077560   % D3=LAST LEGAL PHYSICAL PAGE IN AREA TO RESERVE
077560   % D4 MUST BE ZERO (IN PREVIOUS VERSIONS: NUMBER OF ND-500/ND-100 SHARED AREAS)
077560   %
077560   1F500: IF D4><0 GO 1E174                         % ILLEGAL PARAMETER (NO. OF SHARED AREAS)
077562          IF D1=0 GO 1E174                          % ZERO PAGES TO RESERVE IS ILLEGAL
077564          A+MINSWPAGES; CALL CHNSWPAGES; GO 1E174
077567          IF D2=0 THEN A:=1 FI; A=:AFPHYS           % FIRST PHYS.PAGE TO TEST
077573          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS    % LAST PHYS.PAGE TO TEST
077601          IF AFPHYS>>ALPHYS OR A+D1-1>>T GO 1E174   % ILLEGAL PARAMETERS (AREA NOT AVAILABLE)
077611          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY % SORT PAGE FREE LIST IN DESCENDING ORDER
077616          ALPHYS SH 2=:CECORMAP                     % MEMORY MAP ELEMENT OF LAST LEGAL PAGE
077621          AFPHYS SH 2=:X                            % X=MEMORY MAP OF FIRST PAGE IN AREA
077624   1LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND
077630          DO WHILE X<<=CECORMAP                     % SEARCH LEGAL AREA FOR AVAILABLE CONTIGUOUS PAGES
077633             T:=CORMBANK; *PROTE@3 LDATX
077635             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
077637                IF D1 SH 2+X>>CECORMAP GO 1ERR2     % NO, STILL POSSIBLE TO RESERVE AREA?
077645                X+4; GO 1LOOP                       % YES
077647             FI
077647             IF PGFOUND+1=D1 THEN                   % SUFFICIENT NO. OF PAGES FOUND?
077654                FPHYS+D1-1=:CURPAGE                 % LAST PAGE IN RESERVED AREA
077660                CALL FAR SGFIXC; CALL ERRFATAL      % LINK PAGES TO "ND-500"
077662                CALL FAR XRELES
077663                FPHYS=:ZAREG; PAGPN=:ZTREG; 0=:PAGPN % A=FIRST PAGE RESERVED, T=MEMORY MAP OF THIS PAGE
077670                MIN ZPREG; 0/\0
077672                GO RETSTUPR                         % OK RETURN
077673             FI; A=:PGFOUND; IF X+4=0 GO 1ERR2
077676          OD
077677   1ERR2: A:=0; GO 1ERRF                            % AREA NOT AVAILABLE
077701   1E174: A:=174
077702   1ERRF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
077705   *)FILL
077720
077720   % LOCAL SUBROUTINE FOR 2F500 TO RETURN A RESERVED MEMORY AREA
077720   % INTO THE USER SPECIFIED ADDR ON DPIT
077720   CRETMAREA: A:=D5+RETINDX:=:X                     % X=ADDR WHER THE RESULT WILL BE RETURNED
077723          A SHZ -2; T:=CPEND=:D; AD=:X.DS0          % A=FIRST PHYS.PAGE; D=LAST PHYS.PAGE IN RESERVED AREA
077727          IF RETINDX+2 SHZ -1+1>D4 GO FAR 2ERR2     % NO MORE SPACE FOR RETURNING MEMORY AREAS
077736          RETINDX+2=:RETINDX; 0=:CPEND
077742          EXIT
077743   *)FILL
077744   %
077744   % FIXFLAG=2: RESERVE SWAPPING PAGES FOR ND-500
077744   % D1=NUMBER OF PAGES
077744   % D2=NUMBER OF DIFFERENT MEMORY PARTS
077744   % D3=ADDR OF MEMEORY PART TABLE (ADDR IN DPIT)
077744   % D4=MAX NUMBER OF AREAS TO RESERVE
077744   % D5=ADDR WHER THE RESULT SHOULD BE RETURNED (ADDR IN DPIT)
077744   %
077744   2F500: IF D2=0 OR D4=0 GO FAR 2ERR1              % ILLEGAL PARAMETERS
077751          D1+MINSWPAGES; CALL CHNSWPAGES; GO FAR 2ERR1
077755          0=:PARTINDX=:RETINDX=:PGFOUND
077760          FOR PARTINDX DO WHILE PARTINDX<<=D2       % SEARCH ALL MEMEORY PARTS FOR AVAILABLE PAGES
077764             A SH 1+D3=:X; AD:=X.DS0                % A=FIRST PH.PAGE, D=LAST PH.PAGE IN MEMORY PART
077770             IF A=0 THEN A:=1 FI; A=:AFPHYS
077773             IF A:=D>>ENDPAGE THEN A:=T FI; A=:ALPHYS
100001             IF A<<AFPHYS GO NXPART                 % ILLEGAL MEMORY PART DESCR.
100004             A=:D:=AFPHYS
100006             T:=-1; CALL FAR SORTDUMMY              % SORT PAGE FREE LIST IN FALLING ORDER
100010             AFPHYS SH 2=:CECORMAP
100013             ALPHYS SH 2=:X
100016             0=:CPEND
100017             DO
100017                X=:CMMENTRY; T:=CORMBANK; *PROTE@3 LDATX
100022                IF A/\5CMMASK=0 THEN                % IS PAGE AVAILABLE?
100024                   IF CPEND=0 THEN A:=X SHZ -2=:CPEND FI % CPEND IS FIRST PAGE IN AN AREA
100031                   CALL FAR CFINDSEGMENT; A=:CSEGAD % FIND SEGMENT TABLE ENTRY OF PAGE-OWNER
100033                   CSEGAD; CALL OUTLINK             % LINK OUT REST OF SEGMENT IF NON DEMAND SEGMENT
100035                   T:=CORMBANK; *PROTE@3 LDATX
100037                   IF A BIT 5WIP THEN               % WRITTEN IN PAGE?
100041                      T:=SEGTBANK; X:=CSEGAD; *FLAG@3 LDATX % YES WRITE PAGE TO MASS STORAGE
100044                      A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX
100047                      X:=CMMENTRY; T:=CSEGAD; A:=1=:D; CALL ATRNSEG
100054                      IF COLDFLAG BIT 5DEMAND THEN
100057                         X:=CSEGAD; T:=SEGTBANK; *FLAG@3 STATX
100062                      FI
100062                   FI; X:=CMMENTRY; A:=CSEGAD; CALL X5LINKOVER   % RESERVE PAGE FOR ND-500
100065                   PGFOUND+1=:PGFOUND
100070                   IF A=D1 THEN                     % SUFFICIENT NUMBER OF PAGES RESERVED?
100073                      CALL FAR CRETMAREA            % YES
100074                      RETINDX SHZ -1=:ZAREG; PAGPN=:ZTREG   % A=NUMBER OF INTERVALS; T=START OF "LINKED-MEMORY-ELEMENTS"
100101                      MIN ZPREG; 0/\0               % SKIP-RETURN
100103                      CALL FAR XRELES
100104                      GO RETSTUPR
100105                      *)FILL
100125                   FI
100125                ELSE
100126                   IF CPEND><0 THEN                 % AREA RESERVED?
100130                      X+4; CALL FAR CRETMAREA       % YES, UPDATE REUR INFO
100132                   FI
100132                FI
100132             WHILE X:=CMMENTRY>>CECORMAP
100136                X-4
100137             OD
100140             IF CPEND><0 THEN
100142                X+4; CALL FAR CRETMAREA
100144             FI
100144   NXPART:
100144         OD; GO 2ERR2
100147   *)FILL
100150   2ERR1: CALL FAR XRELES
100151          174=:ZAREG; GO RETSTUPR
100154
100154   % NOT SUFFICIENT NUMBER OF PAGES AVAIALBLE,
100154   % RELEASE THE PAGES ALREADY RESERVED
100154   2ERR2: X:=PAGPN; T:=CORMBANK
100156          DO WHILE X><0
100157             A:=0 BONE 5CMIDUM; *PROTE@3 STATX
100162             *PAGLI@3 LDXTX
100163          OD; X:=4; ENDPAGE SH 2=:CECORMAP
100170          DO CALL FAR IDUMLINK WHILE X><CECORMAP; X+4; OD
100176          2=:ZAREG; CALL FAR XRELES
100201          GO RETSTUPR
100202   *)FILL
100210
100210
100210   %
100210   % FIXFLAG=3: ILLEGAL IN K-VERSION
100210   %
100210   3F500: 174=:ZAREG; CALL FAR XRELES; GO RETSTUPR % ERROR RETURN
100214
100214
100214   %
100214   % FIXFLAG=4: FIX A SEGMENT CONTIGUOUS ANYWHERE INSIDE A SPECIFIED AREA
100214   % D1=SEGMENT NUMBER
100214   % D2=FIRST LEGAL PHYSICAL PAGE IN AREA
100214   % D3=LAST LEGAL PHYSICAL PAGE IN AREA
100214   %
100214   4F500: IF D1 <<2 OR A>>SGMAX GO FAR 4ERR2        % ILLEGAL SEGMENT NUMBER
100223          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
100226          X:=A; T:=SEGTBANK; *SEGLE@3 LDATX         % A=SEGMENT SIZE
100231          IF A=0 GO FAR 4ERR2                       % EMPRY SEGEMENT
100233          A=:NPAG
100234
100234          IF NPAG-1+D2>>ECORMAP SHZ -2 GO FAR 4ERR1 % OUTSIDE PHYSICAL MEMORY
100243          IF D2>>=D3 OR D2+NPAG-1>>T GO FAR 4ERR3 % WRONG PARAMETER VALUES
100254          T:=SEGTBANK; *FLAG@3 LDATX                % A=SEGMENT FLAG
100256          IF A BIT 5INHB GO FAR 4ERR2               % SEGMENT NOT LOADED
100260          IF A BIT 5DEMAND GO FAR 4ERR2             % DEMAND SEGMENT NOT LEGAL
100262          *SGSTA@3 LDATX                            % A=SEGMENT STATUS
100263          IF A=0 GO FAR 4ERR2                       % SEGMENT NOT LOADED
100265          IF A BIT 5FIX THEN                        % SEGMENT IS FIXED
100267             *BPAGL@3 LDXTX                         % CHECK IF FIXED CONTIGUOUS
100270             A:=X SHZ -2=:CURPAGE=:FPHYS            % FIRST PAGE IN SEGMENT
100274             T:=CORMBANK
100275             DO
100275                IF A:=X SHZ -2 -CURPAGE><0 GO FAR 4ERR2 % NOT FIXED CONTIGUOUS
100302                MIN CURPAGE; *PAGLI@3 LDXTX
100304             WHILE X><0
100305             OD; GO 4F5L1; *)FILL                   % FIXED CONTIGUOS
100322          FI; *FLAG@3 LDATX                         % A=SEGMENT FLAG
100323          IF A BIT 5FIXC THEN                       % SEGMENT ALREADY FIXED CONTIGUOUS
100325   4F5L1:    T:=SEGTBANK; X:=SGADR; *BPAGL@3 LDATX
100330             IF A SHZ -2>>=D2 AND A-1+NPAG<<=D3 GO 4F5OK % FIXED CONTIGUOUS IN LEGAL ADDRS
100341             GO 4ERR2                               % FIXED CONTIGUOUS IN WRONG ADDR
100342          FI
100342          IF NPAG+FIXPAGES>>FIXMAX GO FAR 4ERR3     % TOO MANY FIXED PAGES
100347          NPAG+MINSWPAGES; CALL CHNSWPAGES; GO FAR 4ERR3
100353          CALL FAR MBSREMOVE
100354          IF D2=0 THEN A+1 FI; A=:AFPHYS            % PAGE #0 IS UNAVAILABLE
100360          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS
100366          IF AFPHYS+NPAG-1>>ALPHYS GO 4ERR3         % TOO SMALL AREA SPECIFIED
100374          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY
100401          AFPHYS SH 2=:X                            % AFPHYS=FIRST LEGAL PHYSICAL PAGE
100404          ALPHYS SH 2=:CECORMAP                     % ALPHYS=LAST LEGAL PHYSICAL PAGE
100407   4LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND            % FPHYS=FIRST PHYS. PAGE USED
100413          DO
100413             T:=CORMBANK; *PROTE@3 LDATX
100415             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
100417                X+4                                 % NO, STILL POSSIBLE TO FIXC SEGMENT WITHIN AREA?
100420                IF A:=X SHZ -2 -1+NPAG>>ALPHYS GO 4ERR0
100427                GO 4LOOP                            % YES
100430             FI
100430             IF PGFOUND+1=NPAG THEN               % AREA FOUND?
100435                FPHYS-1+NPAG=:CURPAGE             % YES, CURRPAGE IS LAST USED PAGE
100441                CALL FAR SGFIXC; CALL ERRFATAL    % FIXC SEGMENT
100443                NPAG+FIXPAGES=:FIXPAGES           % UPDATE NUMBER OF FIXED PAGES COUNTER
100446                GO 4F5OK
100447             FI; A=:PGFOUND
100450          WHILE X<<CECORMAP
100453             X+4
100454          OD
100455   4ERR1: A:=1; GO 4ERRF                            % OUTSIDE MEMORY
100457   4ERR2: A:=2; GO 4ERRF                            % SOMETHING WRONG WITH THE SEGMENT
100461   4ERR3: A:=3                                      % WRONG PARAMETERS OR TOO MANY FIXED
100462   4ERRF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR
100465   4ERR0: 0=:ZAREG; CALL FAR XMBSREMOVE
100467          CALL FAR XRELES; GO RETSTUPR
100471   4F5OK: T:=SEGTBANK; X:=SGADR; *SGSTA@3 LDATX
100474          IF A BIT 5FIX GO 4F5UT; *FLAG@3 LDATX
100477          A BONE 5FIXC; *FLAG@3 STATX               % MARK SEGMENT FIXED CONTIGUOUS
100501   4F5UT: X:=SGADR; T:=SEGTBANK; *BPAGL@3 LDATX
100504          A SHZ -2=:ZAREG                           % FIRST PHYSICA PAGE USED BU THE SEGMENT
100506          CALL FAR XRELES; MIN ZPREG; 0/\0
100511          GO RETSTUPR
100512   *)FILL
100533
100533   %
100533   % RESERVE A CONTIGUOUS MEMORY AREA
100533   % D1=NUMBER OF PAGES TO RESERVE
100533   % D2=FIRST LEGAL PHYSICAL PAGE
100533   % D3=LAST LEGAL PHYSICAL PAGE
100533   %
100533   5F500: IF D1=0 GO 5ERR3                          % ERROR, NO PAGES TO RESERVE
100535          D1+MINSWPAGES; CALL CHNSWPAGES; GO 5ERR3
100541          IF D2>>=D3 OR A+D1-1>>T GO 5ERR3          % ILLEGAL SPECIFIED AREA
100551          X:=FXCTAB                                 % SEARCH FOR FREE ENTRY IN FXCTABLE
100552          DO WHILE X<<EFXCTAB
100555             T:=MBFXCTAB; *LDATX
100557             IF A=0 GO 5F5L1                        % IF ENTRY=0 THEN FREE
100560             X+2
100561          OD; GO 5ERR2                              % NO FREE ENTRY FOUND
100563   5F5L1: X=:CFXCTADDR                              % X=ADDR OF FREE ENTRY IN FXCTAB
100564          D1=:NPAG
100566          IF D2=0 THEN A+1 FI; A=:AFPHYS            % D2=FIRST LEGAL PHYSICAL PAGE
100572          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS    % D3=LAST PHYSICAL PAGE
100600          IF AFPHYS+NPAG-1>>ALPHYS GO 5ERR1         % OUTSIDE MEMORY OR TOO SMALL LIMITS SEPCIFIED
100606          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY
100613          ALPHYS SH 2=:CECORMAP
100616          AFPHYS SH 2=:X
100621   5LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND            % FPHYS=FIRST PHYS. PAGE USED
100625          DO
100625             T:=CORMBANK; *PROTE@3 LDATX
100627             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
100631                X+4                                 % NO, STILL POSSIBLE TO ALLOCATE AREA WITHIN LIMITS?
100632                IF A:=X SHZ -2 -1+NPAG>>ALPHYS GO 5ERR0
100641                GO 5LOOP                            % YES
100642             FI
100642             IF PGFOUND+1=NPAG THEN                 % AREA FOUND?
100647                FPHYS-1+NPAG=:CURPAGE               % YES, CURRPAGE IS LAST USED PAGE
100653                CALL FAR SGFIXC; CALL ERRFATAL      % FIXC SEGMENT
100655                GO 5F5OK
100656             FI; A=:PGFOUND
100657          WHILE X<<CECORMAP
100662             X+4
100663          OD
100664   5ERR0: A:=0; GO 5ERFELLS                        % AREA ALREADY OCCUPIED
100666   5ERR1: A:=1; GO 5ERFELLS                         % OUTSIDE MEMORY
100670   5ERR2: A:=2; GO 5ERFELLS                         % NO FREE ENTRY IN FXCTABLE.
100672   5ERR3: A:=3                                      % WRONG PARAMETERS OR TOO MANY FIXED
100673   5ERFELLS: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR
100676   5F5OK: T:=MBFXCTAB; X:=CFXCTADDR+1; A:=RTREF; *STATX % SET RT-PROGR. RESERVING THE AREA
100703          A:=X-FXCTAB=:ZTREG; FPHYS=:ZAREG           % T=TABLE INDEX, A=FIRST PHYS PAGE ALLOCATED
100710          CALL FAR XRELES; MIN ZPREG; 0/\0
100713          GO RETSTUPR
100714   *)FILL
100732
100732   %
100732   % FIXFLAG=6: RELEASE A CONTIGUOUS MEMORY AREA
100732   % D1: RESERVED MEMORY AREA INDEX OF AREA TO RELEASE
100732   % D2: FIRST PHYSICAL PAGE IN AREA TO BE RELEASED
100732   %
100732   6F500: IF D1-1+FXCTAB>>=EFXCTAB OR A BIT "0" GO 6ERR3 % ILLEGAL INDEX
100742          A=:D1
100743          T:=MBFXCTAB; X:=D1; *LDATX
100746          IF A SHZ -2><D2 GO 6ERR3                     % ILLEGAL PHYSICAL PAGE
100752          IF D2=0 GO 6ERR3                             % ILLEGAL PHYSICAL PAGE
100754          CALL FAR RLSAREA                             % LINK PAGES TO DUMMY SEGMENT
100755          0=:ZAREG; MIN ZPREG; 0/\0
100760          CALL FAR XRELES; GO RETSTUPR                 % OK RETURN
100762   6ERR3: 3=:ZAREG; CALL FAR XRELES; GO RETSTUPR       % ERROR RETURN
100766   *)FILL
100774
100774
100774   %
100774   % FIXFLAG=7: RELEASE ALL MEMORY AREA RESERVED BY A SPECIFIED PROGRAM
100774   % D1: PROGRAM TO RELEASE MEMORY AREAS FOR (=0 MEANS CALLING PROGRAM)
100774   %
100774   7F500: IF D1=0 THEN RTREF=:D1 FI
101000          IF A<<RTSTART OR A>>=RTEND GO 7ERR3       % ILLEGAL RT.PROGR
101006          A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
101013          IF D><0 GO 7ERR3                          % ILLEGAL RT.PROGR
101015          FXCTAB=:CFXCTADDR
101017          DO WHILE X:=CFXCTADDR<<EFXCTAB            % SEARCH TABLE FOR AREA RESERVED BY SPECIFIED PROGR
101023             T:=MBFXCTAB; *LDDTX
101025             IF D=D1 AND A><0 THEN CALL FAR RLSAREA FI
101032             CFXCTADDR+2=:CFXCTADDR
101035          OD; 0=:ZAREG; MIN ZPREG; 0/\0
101041          CALL FAR XRELES; GO RETSTUPR              % OK RETURN
101043   7ERR3: 3=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
101047   *)FILL
101060
101060   %
101060   % FIXFLAG=10; GET SEGMENT INFO
101060   % D1=SEGMENT NUMBER
101060   % D2=LOGICAL PAGE WITHIN SEGMENT
101060   %
101060   10F500:
101060          IF D1>>SGMAX OR A<<2 GO 174ER             % ILLEGAL SEGMENT NUMBER
101067          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
101072          X:=SGADR; T:=SEGTBANK; *FLAG@3 LDATX
101075          IF A BIT 5INHB GO 174ER                   % SEGMENT NOT USED
101077          *SGSTA@3 LDATX
101100          IF A=0 GO 10ER2                           % SEGMENT NOT LOADED
101101          *SEGLE@3 LDATX
101102          IF A=0 GO 174ER                           % EMPTY SEGMENT
101103          IF A<<D2 GO 174ER                         % ILLEGAL LOGICAL PAGE SPECIFIED IN MON.CALL
101106          0=:ZTREG
101107          T:=SEGTBANK; *SGSTA@3 LDATX
101111          IF A BIT 5FIX THEN 1=:ZTREG FI            % SEGMENT IS FIXED
101115          *FLAG@3 LDATX
101116          IF A BIT 5FIXC THEN 2=:ZTREG FI           % SEGMENT IS FIXED CONTIGUOUSLY
101122          IF ZTREG><0 THEN                          % SEGMENT IS FIXED
101124             D:=0                                   % PAGE WITHIN SEGMENT
101125             *BPAGL@3 LDXTX
101126             DO
101126                IF D2=D THEN
101131                   A:=X SHZ -2=:ZAREG               % FPYSICAL PAGE OF ACTUAL PAGE WITHIN SEGMENT
101134                   GO 10FOK
101135                FI; D+1
101136                IF X=0 GO 174ER
101137                T:=CORMBANK; *PAGLI@3 LDXTX
101141             OD
101142          FI; 0=:ZAREG
101143   10FOK: T:=SEGTBANK; X:=SGADR; *FLAG@3 LDATX
101146          A=:ZDREG; MIN ZPREG; 0/\0                 % D=SEGMENT FLAG
101151          CALL FAR XRELES; GO RETSTUPR              % OK RETURN
101153   174ER: 174; GO 10ERF
101155   10ER2: 2
101156   10ERF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
101161   *)FILL
101170
101170   % FIXFLAG=11; GET INFO. ABOUT A PROGRAM'S ATTATCHED SEGMENTS
101170   % D1=RT-PROGRAM
101170   % D2=ADDR OF BUFFER WHERE INFO WILL BE RETURNED.
101170   %
101170   DISP 0; INTEGER POINTER PPD3=D3; PSID
101170
101170   % LOCAL SUBROUTINE TO SAVE "SEGMENT-INFO".
101170   % ENTRY: A=SEGMENT NUMBER; T="SEGMENT-INFO-ELEMENT" INDEX (0-2).
101170   %
101170   SUB11F500:
101170          IF A><0 THEN
101171             A:=:T*5+"D4"+B=:D3                     % ADDR IN SEG.INFO ARRAY
101176             T=:PPD3; MIN D3                        % SEGMENT NUMBER
101200             A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *LOGAD@3 LDATX
101206             A=:PPD3; MIN D3                        % SEGMENT'S FIRST LOGICAL PAGE
101210             *SEGLE@3 LDATX
101211             A=:PPD3; MIN D3                        % SEGMENT LENGTH IN PAGES
101213             *SGSTA@3 LDATX
101214             A=:D; *FLAG@3 LDATX
101216             T:=0
101217             IF A BIT 5SYSEGM THEN T BONE "0" FI    % SYSTEM SEGMENT
101222             IF A BIT 5SPROT THEN T BONE 1 FI       % PROTECTED SEGMENT
101225             IF A BIT 5SREEP THEN T BONE 2 FI       % REENTRANT SUBSYSTEM SEGMENT
101230             IF A BIT 5FIX THEN T BONE 3 FI         % SEGMENT IS FIXED
101233             IF A BIT 5FIXC THEN T BONE 4 FI        % SEGMENT IS FIXED CONTIGUOUSLY
101236             IF A BIT 5DEMAND THEN T BONE 5 FI      % DEMAND SEGMENT
101241             A:=D/\163000; T\/A                     % WP,RP,FP AND RING
101244             T=:PPD3; MIN D3                        % SEGMENT "STATUS"
101246             IF T BIT 5CMSYS THEN
101250                T:=SEGTBANK; *BPAGL@3 LDATX
101252                A SHZ -2=:PPD3                      % PHYSICAL PAGE NUMBER OF SEGMENT
101254             FI
101254          FI; EXIT
101255   *)FILL
101263
101263   11F500:
101263          IF D1=0 THEN RTREF=:D1 FI
101267          IF A<<RTSTART OR A>>=RTEND GO 174ER       % NOT RT-DESCR. ADDR.
101275          A:=A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
101302          IF D><0 GO 174ER                          % NOT RT-DESCR ADDR.
101304          OLDPAGE=:D; A:=D2; T:=22; X:=RTREF
101311          CALL CHLIM; GO 11ERF                      % CHECK ADDR OF USER'S BUFFER
101313          "D4"+B=:D3=:X; T:=X+22
101321          DO WHILE X<<T; 0=:X.S0; X+1; OD           % CLEAR ARRAY
101326          T:=0; D1.ACT1SEG; CALL SUB11F500
101332          T:=1; D1.ACT2SEG; CALL SUB11F500
101336          T:=2; D1.RSEGM; CALL SUB11F500
101342          A:=3*5+"D4"+B=:D3
101347          IF CCFPAGE><100 THEN                      % ANY RT-COMMON IN THIS SYSTEM?
101353             ARTFPAGE=:PPD3; MIN D3                 % YES, SAVE FIRST LOG.PAGE
101356             CCLPAGE-CCFPAGE+1=:PPD3=:T; MIN D3     % RT-COMMON SIZE
101364             ARTFPAGE SH 1+IRTCPIT=:X
101370             X.S1=:D=:L                             % FIRST PHYS.PAGE OF RT-COMMON
101373             DO WHILE T><0                          % IS RT-COMMON CONTIGUOUS IN PHYS.MEM?
101375                IF X.S1><D GO RTCNCONTIG
101400                D+1; X+2; T-1
101403             OD; A:=L=:PPD3                         % FIRST PHYS PAGE OF RT-COMMON
101406   RTCNCONTIG:
101406          FI; CALL FAR XRELES
101407          *IOF
101410          "STUPR"; *IRW MLEVB DP
101412          MLEV; *MST PIE; MST PID; ION
101416          A:=B+"D4"=:D; T:=D2; X:=22; A:=OLDPAGE
101424          K:=1; CALL MOVUS                          % COPY SEGMENT-INFO ARRAY TO USER AREA
101426          MIN ZPREG; 0/\0                           % SKIP-RETURN
101430          GO RET
101431
101431   11ERF: ER92=:ZAREG; CALL FAR XRELES; GO RETSTUPR % ERROR RETURN
101435   *)FILL
101454
101454   % FIXFLAG=12:  RELEASE A MEMORY AREA RESERVED BY FIXC5 OR
101454   %              RELEASE A MEMORY AREA SETUP IN NINITPAGES
101454   % FIXFLAG=13:  RELEASE A MEMORY AREA RESERVED BY FIXC5 OR
101454   %              RELEASE A MEMORY AREA SETUP IN LAMAR
101454   %
101454   % D1: ><0: RESERVED MEMORY AREA INDEX TO RELEASE
101454   %     =0:  RELEASE AN AREA IN NINITPAGES
101454   % D2: FIRST PHYS PAGE IN MEM.AREA
101454   % D3: NUMBER OF PAGES TO RELEASE (DUMMY WHEN PAR1><0)
101454   %
101454   12F500:X:="NINITPAGES";GO 1213F
101456   13F500:X:="LAMAR"
101457   1213F: D2+D3; IF C GO FAR 174ER
101463          IF A=0 GO FAR 174ER; A-1=:D3        % LAST PHYS.PAGE IN AREA
101467          A:=NINSZ SH 1+X=:L                  % L=END OF NINITPAGES TABLE
101473          DO WHILE X<<L
101475             T:=0; *LDDTX
101477             IF A BZERO 17 =D2 AND D=D3 THEN  % BIT 17 SET TO PREVET CRE-LAMU IN AREA
101506                A:=0; D:=0; T:=0; *STDTX      % CLEAR AREA
101512                IF D1><0 THEN                 % RELEASE MEMORY RESERVED BY MON FIXC5
101514                  6=:FIXFLAG; GO FAR 6F500
101517                FI
101517                D2 SH 2=:X; D3 SH 2=:D3
101525                DO
101525                   T:=CORMBANK; A:=0 BONE 5CMIDUM; *PROTE@3 STATX
101531                   *PAGLI@3 STZTX; PREVI@3 STZTX; LOGPA@3 STZTX
101534                   CALL FAR IDUMLINK                % LINK PAGE INTO DUMMY SEGMENT
101535                WHILE X+4<<D3
101541                OD
101542                CALL FAR XRELES; MIN ZPREG; 0/\0    % SKIP-RETURN
101545                GO RETSTUPR
101546             FI; X+2
101547          OD
101550          174=:ZAREG; CALL FAR XRELES; GO RETSTUPR  % NO SUCH AREA IN NINITPAGES TABLE
101554   RBUS
101564
101564
101564   %============================================================================
101564   %      ( R )       C H N S W P A G E S
101564   %
101564   % SUBROUTINE TO CHECK FOR IF THE REQUIRED NUMBER OF PAGES IS AVAILABLE
101564   % FOR SWAPPING
101564   %
101564   % ENTRY:     A=REQUIRED NUMBER OF PAGES FO SWAPPING
101564   %            A=-1 MEANS FIND NUMBER OF PAGES FOR SWAPPING IN THE SYSTEM
101564   %                 (PAGES THAT IS NOT FIXED, NOT RESERVED FOR SPECIAL USE..)
101564   %
101564   % EXIT:      NOT SUFFICIENT PAGES FOR SWAPPING
101564   %            A=ACTUAL NUMBER OF PAGES FOR SWAPPING
101564   %
101564   % EXIT+1:    SUFFICIENT PAGES FOR SWAPPING
101564   %            A=REQUIRED NUMBER OF PAGES FOR SWAPPING
101564   %
101564   SUBR CHNSWPAGES
101564   INTEGER REQPAGS,NPAG,CSEG,XREG
101570   CHNSWPAGES:
101570          IF A=0 THEN EXITA FI
101572          *IOF
101573          A=:REQPAGS; 0=:NPAG; X=:XREG
101576          IF X:=BSEGLINK=0 THEN CALL ERRFATAL FI
101602          DO
101602             X=:CSEG; T:=SEGTBANK; *BPAGL@3 LDXTX
101605             DO WHILE X><0
101606                IF NPAG+1=REQPAGS THEN L+1; GO OUT FI
101615                A=:NPAG; T:=CORMBANK; *PAGLI@3 LDXTX
101620             OD; X:=CSEG; T:=SEGTBANK; *SEGLI@3 LDXTX
101624          WHILE X><BSEGLINK
101627          OD; A:=NPAG
101631   OUT:   X:=XREG
101632          *ION; EXIT
101634   RBUS
101640
101640
101640   %============================================================================
101640   %      ( R )        O U T L I N K
101640   %
101640   % SUBROUTINE TO REMOVE PAGES FROM A NON-DEMAND SEGMENT
101640   %
101640   % ENTRY:     X=MEMORY MAP ELEMENT OF FIRST PAGE NOT TO REMOVE
101640   %            A=SEGMENT ADDR.
101640   %
101640   SUBR OUTLINK
101640   INTEGER POINTER LREG
101641   INTEGER XREG,AREG
101643   OUTLINK: X=:XREG; A=:AREG:=L=:"LREG"
101647          IF AREG=XSGRT GO OUT                      % DUMMY SEGMENT
101653          X:=AREG; T:=SEGTBANK; *FLAG@3 LDATX
101656          IF A BIT 5DEMAND GO OUT                   % DEMAND SEGMENT
101660          *BPAGL@3 LDATX
101661          IF A=XREG GO OUT                          % NO PAGES TO REMOVE
101664          T:=SEGTBANK; *FLAG@3 LDATX
101666          A BZERO 5OK; *FLAG@3 STATX
101670          DO
101670             X:=AREG; T:=SEGTBANK; *BPAGL@3 LDXTX
101673          WHILE X><XREG
101676             T:=CORMBANK; *PROTE@3 LDATX
101700             IF A BIT 5WIP THEN                     % WRITTEN IN PAGE?
101702                A:=1=:D; T:=AREG; CALL ATRNSEG      % YES, WRITE PAGE TO MASS STORAGE
101706             FI; T:=XSGRT; AREG; CALL XLINKOVER
101711          OD
101712   OUT:   X:=XREG; GO LREG
101714   RBUS
101721
101721
101721   %============================================================================
101721   %      ( R )   X S L I N K O V E R   -   X 5 L I N K O V E R
101721   %              X A L I N K O V E R
101721   %
101721   % SUBROUTINE TO LINK A PAGE FROM A SEGMENT INTO
101721   %            ANOTHER SEGMENT       (XLINKOVER)
101721   %            TO ND-500 MEMORY      (X5LINKOVER)
101721   %            ALLOCATED MEMORY AREA (XALINKOVER)
101721   %
101721   % ENTRY:     T=ADDRESS OF SEGMENT TO LINK PAGE INTO
101721   %            X=ADDRESS OF CORMAP ENTRY
101721   %            A=ADDRESS OF SEGMENT TO LINK PAGE FROM
101721   %
101721   SUBR XLINKOVER,X5LINKOVER,XALINKOVER
101721
101721   INTEGER CMMELEMENT=?                             % MEMORY MAP ELEMENT
101721   INTEGER TOSEG=?                                  % SEGMENT TO LINK PAGE INTO
101721   INTEGER FRSEG=?                                  % SEGMENT TO LINK PAGE FROM
101721   INTEGER ROUTSWITCH=?                             % ROUTINE SWITCH
101721   INTEGER CFXCTADDR=?                              % ADDR OF ENTRY IN FXCTAB
101721
101721   X5LINKOVER: A=:FRSEG:=2; GO FELLS
101724   XALINKOVER: A=:FRSEG:=1; GO FELLS
101727   XLINKOVER: A=:FRSEG:=0
101731   FELLS: A=:ROUTSWITCH; T=:TOSEG; X=:CMMELEMENT
101734          T:=CORMBANK; *PAGLI@3 LDATX               % A=CMMELEMENT.PAGLI
101736          A=:D
101737          IF A><0 THEN
101740             *PREVI@3 LDATX                         % A:=CMMELEMENT.PREVIOUS
101741             X:=:D; *PREVI@3 STATX                  % CMMELEMENT.PREVIOUS=:(CMMELEMENT.PAGLINK).PREVIOUS
101743             X:=:D
101744          FI; *PREVI@3 LDATX                        % A:=CMMELEMENT.PREVIOUS
101745          IF A BIT 0 OR A BIT 1 THEN
101751             X:=FRSEG; T:=SEGTBANK; *AAX BPAGL      % CMMELEMENT FIRST IN PAGELINK
101754          ELSE
101755             X:=A
101756          FI; A:=D; *PAGLI@3 STATX                  % CMMELEMENT=:(CMMELEMENT.PREVIOUS).PAGLINK
101760          X:=FRSEG; T:=SEGTBANK; *BPAGL@3 LDATX
101763          IF A=0 THEN                               % HAS FRSEG ANY PAGES LEFT IN MEMORY?
101764             *SEGLI@3 LDATX
101765             IF A><0 THEN                           % NO, IS FRSEG IN SEGLINK?
101766                "1OUTSEGLINK"; *IOF; IRW SLEVB DP   % YES, REMOVE FRSEG FROM SEGLINK
101771                SLEV; *MST PID; ION
101774             FI
101774          FI; GO L1; *)FILL
102000
102000   INTEGER CMMELEMENT                               % MEMORY MAP ELEMENT
102001   INTEGER TOSEG                                    % SEGMENT TO LINK PAGE INTO
102002   INTEGER FRSEG                                    % SEGMENT TO LINK PAGE FROM
102003   INTEGER ROUTSWITCH                               % ROUTINE SWITCH
102004   INTEGER CFXCTADDR=TOSEG                          % INDEX IN FXCTAB
102004
102004   L1:    IF ROUTSWITCH=0 THEN                      % LINK PAGE FROM SEGMENT TO SEGMENT
102006             X:=TOSEG; T:=SEGTBANK; *BPAGL@3 LDATX
102011             A=:D:=CMMELEMENT; *BPAGL@3 STATX       % CMMELEMENT=:TOSEG.BPAGLINK
102014             *SGSTA@3 LDATX
102015             X:=CMMELEMENT; T:=CORMBANK; *PROTE@3 STATX % TOSEG.SGSTATUS=:CMMELEMENT.PROTECT
102020             A:=D; *PAGLI@3 STATX                   % TOSEG.BPAGLINK=:CMMELEMENT.PAGLINK
102022             IF A><0 THEN                           % ONLY THIS PAGE IN TOSEG.PAGLINK?
102023                X:=:A; *PREVI@3 STATX               % NO, CMMELEMENT=:TOSEG.PREVIOUS
102025             FI; A:=TOSEG-SEGSTART=:D:=0; T:=5SEGSIZE; *RDIV ST
102033             IF D><0 THEN CALL ERRFATAL FI          % A=SEGMENT NUMBER OF TOSEG
102036             A SHZ 2+3; X:=CMMELEMENT; T:=CORMBANK  % A BIT 2-15: SEGMENT NO. BIT 0-1:3
102042             *PREVI@3 STATX                         % A=:CMMELEMENT.PREVIOUS
102043             IF X:=TOSEG=XSGRT THEN
102047                T:=SEGTBANK; *SEGLI@3 LDATX
102051                IF A=0 THEN                         % SEGMENT IN SEGLINK?
102052                   "1INSEGLINK"; *IOF; IRW SLEVB DP % NO, INSERT IT IN SEGLINK
102055                   SLEV; *MST PID; ION
102060                FI
102060                T:=SEGTBANK; *IOF; SEGLI@3 LDATX    % SET XSGRT LAST IN SEGLINK
102063                A=:BSEGLINK; *ION
102065             FI
102065          FI
102065          IF ROUTSWITCH=1 THEN                      % LINK TO "RESERVED MEMORY AREA"
102071             X:=CFXCTADDR; T:=MBFXCTAB; *LDATX
102074             X:=CMMELEMENT; T:=CORMBANK; *PAGLI@3 STATX
102077             A:=0 BONE 5CMRES; *PROTE@3 STATX       % MARK PAGE IS IN RESERVED MEMORY AREA
102102             X:=CFXCTADDR; T:=MBFXCTAB
102104             CMMELEMENT; *STATX
102106          FI
102106          IF ROUTSWITCH=2 THEN                      % LINK TO ND-500
102112             PAGPN; X:=CMMELEMENT; T:=CORMBANK; *PAGLI@3 STATX
102116             A:=0 BONE 5CMRES; *PROTE@3 STATX       % MARK THAT PAGE IS RESERVED FOR "SPECIAL USE"
102121             X=:PAGPN
102122          FI; T:=SEGTBANK; X:=FRSEG; *FLAG@3 LDATX
102125          IF A NBIT 5DEMAND THEN
102127             A BZERO 5OK; *FLAG@3 STATX             % SEGMENT NOT OK WHEN NONDEMAND SEG
102131          FI; X:=CMMELEMENT; A:=FRSEG; T:=TOSEG
102134          EXIT
102135   RBUS
102146
102146
102146   %========================================================================
102146   %  34.36     E D T R M
102146   %
102146   % MONITOR CALL TO ENABLE/DISABLE PROGRAM TERMINATION HANDLING
102146   %
102146   % MONITOR CALL (206): ISTAT=EDTRM(<ENABLE/DISABLE>,<RT/UB/FE>
102146   %                                 <  1   /   0   >,< 0/ 1/ 2>
102146   %
102146   %
102146
102146   SUBR EDTRM
102146
102146   EDTRM: CALL GET2
102147          IF BACKGROUND><0 THEN
102151                IF D1=0 GO ILLPA
102153          ELSE
102154                IF D1>0 GO ILLPA
102157          FI
102157          IF D1=0 THEN          % RT
102161                IF D0=0 THEN    % DISABLE
102163                   0=:FLRTTERM
102164                ELSE            % ENABLE
102165                   IF RTTERM=0 GO ILLPA
102167                   1=:FLRTTERM
102171                FI
102171          ELSE                  % BACKGROUND
102172                MLEV; *MST PIE  % ENABLE MONITOR LEVEL
102174                IF TRMDEF=0 GO ILLPA
102176                IF D1 BIT "0" THEN % USER-BREAK
102201                   IF D0=0 THEN   % DISABLE
102203                      FLBGTERM BZERO "0"=:FLBGTERM
102206                   ELSE           % ENABLE
102207                      FLBGTERM BONE "0"=:FLBGTERM
102212                   FI
102212                FI
102212                IF D1 BIT 1 THEN % FATAL-ERROR
102215                   IF D0=0 THEN   % DISABLE
102217                      FLBGTERM BZERO 1=:FLBGTERM
102222                   ELSE           % ENABLE
102223                      FLBGTERM BONE 1=:FLBGTERM
102226                   FI
102226                FI
102226          FI; A:=0; GO OUT
102230
102230   ERR:   -1; GO OUT            % ERROR WHEN ACCESSING OPCOM SEGMENT
102232   ILLPA: 174                   % ILLEGAL PARAMETER
102233   OUT:   A=:ZAREG; GO RET
102235   RBUS
102244
102244
102244
102244   %========================================================================
102244   %  34.37     M P A S E T   M P A G E T
102244   %
102244   %  MONITOR CALL TO SET (56) AND GET (57) USER PARAMETERS
102244   %  CALLABLE FROM BACKGROUND ONLY
102244   %
102244   %  IERR=PASET(APAR),  IERR=PAGET(APAR)
102244   %
102244
102244   SUBR MPASET,MPAGET
102244
102244   MPASET: K:="0"; GO FSGPAR
102246   MPAGET: K:=1
102247   FSGPAR: CALL GETP0                               % GET ADDR OF ARRAY
102250          MLEV; *MST PIE
102252          IF K THEN
102254             "USPAR"=:D; T:=D0                      % GET PARAMETERS
102257          ELSE
102260             D0=:D; T:="USPAR"                      % SET PARAMETERS
102263          FI; X:=5; A:=OLDPAGE; CALL MOVUS          % COPY BETWEEN USER AND SYS.SEG
102266          0=:ZAREG; GO RET                          % A=0 ON RETURN
102270   RBUS
102274
102274
102274   %=============================================================================
102274   %  34.38     R E R R P
102274   %
102274   %  MONITOR CALL (207) TO READ ERROR PARAMETERS (9ERRP+ABPRO)
102274   %
102274   %  CALL RERRP(IARR)
102274   %
102274   %      IARR(1) = ERNUMB (ASCII)
102274   %      IARR(2) = ERPREG
102274   %      IARR(3) = N1 (A-REG)
102274   %      IARR(4) = N2 (T-REG)
102274   %      IARR(5) = RTPROG
102274   %      IARR(6) = ABPRO (0 IF ABORTED BY SYSTEM, ELSE RTPROG)
102274   %
102274
102274   SUBR RERRP
102274
102274   DISP 0; REAL FS0=S0,FS1=S3; PSID
102274
102274   RERRP: CALL GETP0
102275          MLEV; *MST PIE
102277          OLDPAG=:D; D0; T:=6; X:=RTREF; CALL CHLIM; GO ILLAD
102306          "9ERRP"=:D; T:=D0; X:=6; K:="1";  A:=OLDPAGE; CALL MOVUS
102315          A:=0
102316   OUT:   A=:ZAREG; GO RET
102320   ILLAD: 153; GO OUT           % ILLEGAL ADDRESS REF. IN MONITOR CALL
102322
102322   RBUS
102330
102330
102330   %==============================================================================
102330   %      ( R )     M S G
102330
102330   % MONITOR CALLS TO PRINT USER MESSAGE
102330   % X POINTS TO STRING, TERMINATED BY ',AND $ MEANS CRLF
102330   SUBR MSG
102330   TCX:   T:=1; *MON 2OUTB
102332          GO 3FILERR; EXIT
102334
102334   MSG:   CALL GET0
102335          T:=ZXREG; OLDPAGE=:D; CALL DALTON
102341          T=:D; MLEV; *MST PIE
102344          FOR X:=0 TO 1000 DO
102350                T:=D; *LBYT
102352                WHILE><##'
102355                IF A=##$ THEN 15; CALL TCX; 12 FI; CALL TCX
102364          OD; CALL SINALTPIT
102367          A:=X SHZ -1+1+ZXREG=:ZXREG
102374          CALL XBMRET
102375          GO RET
102376   RBUS
102405
102405
102405
102405   %======================================================================
102405   %
102405   %      ( R )      G E R D V
102405   %
102405   %  MONITOR CALL TO RETURN ERROR DEVICE (LOGICAL NUMBER) AND BY WHOM
102405   %  IT MIGHT BE RESERVED.
102405   %  (MON 254)
102405   %
102405
102405   SUBR GERDV
102405   INTEGER POINTER PTTNO:=TTNO
102406
102406   DISP 0
102406   INTEGER SVRSEGM=D1           % CALLERS RSEGM
102406   PSID
102406   GERDV: CALL GET0
102407          MLEV; *MST PIE                            % ENABLE MONITOR LEVEL FOR SWITCHING SEGMENTS
102411          RTREF.ACT2SEG=:D; 0=:X.ACT2SEG            % SAVE CALLERS SEGMENT
102415          X.RSEGM=:SVRSEGM; 0=:X.RSEGM
102420          T:=5ERRSEG; CALL M1MEXY; A:=PTTNO:=:D
102424          A=:X.ACT2SEG                              % RESET CALLERS SEGMENTS
102425          CALL M1MEXY; A:=D=:ZAREG                  % A=LOG.DEV.NO OF ERROR DEVICE
102430          CALL LOGPH; A:=D.RTRES=:ZDREG             % D=PROGR. RESERVING THE ERROR DEVICE
102434          SVRSEGM=:RTREF.RSEGM                      % RESTORE ORIGNAL REENTRANT SEGMENT
102437          GO RETSTUPR                               % FORCE PROGR THROUGH SEGADM
102440   RBUS
102445
102445   *"8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"102445

102445   %=======================================================================
102445   % 34.31     X T L X    S T U S P   S T L 1 2    S T L 1 3
102445   %
102445   %      MONITOR CALL HDLC
102445   %
102445   %=======================================================================
102445   %
102445   %
102445   %PUROSE: SIMULATE XTLX MONITOR CALLS FOR COMMUNICATION
102445   %        WITH HDLC-DRIVER.
102445   %
102445   %
102445   %
102445   %CALLING SEQUENCE:
102445   %
102445   %      LDA (PARAM
102445   %      MON  HDLC
102445   %      JMP ERROR
102445   %
102445   %      PARAM,PARA0
102445   %            PARA1
102445   %            PARA2     % ADDRESS OF USER BUFFER
102445   %            PARA3     % ADDRESS OF BYTECOUNT (USED IF RECEIVE)
102445   %            PARA4
102445   %
102445   %      PARA0 - FUNCTION. SEND OR RECEIVE
102445   %      PARA1 - PORT NO. (LOGICAL UNIT NO.)
102445   %      PARA2 - BUFFER
102445   %      PARA3 - BYTECOUNT
102445   %      PARA4 - P1 - 1  MAX BYTECOUNT OF MESSAGE
102445   %              P1 - 2  WAIT/CONTINUE IF NO MESSAGE IN QUEUE
102445   %
102445   %
102445   %DISP -9
102445   %       INTEGER HXDOK                   %LOCK,OPERATED BY X21(1-LOCKED,0-OPEN)
102445   %       INTEGER HXTMO                   %ADDRESS OF TIMEOUT-ROUTINE IN POF
102445   %PSID
102445   SUBR XTLX
102445   %
102445   %      TEMPORARY WORKING AREA
102445   %
102445   INTEGER TDAFI                          %ADDRESS OF CURRENT DATAFIELD
102446   INTEGER TDEFI                          %ADDRESS OF DEMAND FIELD
102447   %
102447   %ENTRY:X-DEMFIELD, B-PARAMETER POINTER
102447   %      NPT=RPIT, APT=DPIT, MONITOR LEVEL ENABLED, PON, ION
102447   %
102447   XTLX: X.OLDPAG=:X.SVOLDPAG   %%%%; CALL GAPIT; A:=D=:X.OLDPAG; CALL GETHD
102451         IF A/\74000=NDPIT THEN ADPIT ELSE X.OLDPAGE/\3600 FI
102461         A=:T:=X.OLDPAGE/\ACLEAR\/T=:X.OLDPAGE
102466         CALL GETHD
102467         SVOLDPAG=:OLDPAG
102471         IF D0=FRECV OR =FMXRECV THEN
102500            D5=:D3                                 %GET ADDRESS OF RETURN PARAMETER
102502         ELSE
102503            IF D0><FSEND THEN
102507               T:=EFUNC; GO ERET                   %ILLEGAL FUNCTION
102511         FI;FI
102511         X=:TDEFI
102512   %
102512   %     XREG POINTS TO DEMFIELD
102512   %     LEV 3 DISABLED
102512   %     FIND DATAFIELD AND SEE IF IT IS RESERVED BY CURRENT PROGRAM
102512   %
102512         A:=D1; CALL LOGPH;
102514         IF A = 0 THEN A:=D FI                     %TRY OUTPUT-FIELD
102516         IF A = 0 THEN T:=E2; GO ERET; FI
102521         A=:B=:TDAFI
102523         IF TYPRING /\ 177 >< 0 THEN T:=EDEVN; GO ERET FI     %*SIN-K
102530         IF HXCC><HXCOD THEN T:=EDEVN; GO ERET FI  % CORRECT DATAFIELD ?
102536         IF CURPROG><RTRES THEN                    % *80B*
102542           T:=E1;  GO ERET;                        % *80B* *81F*
102544         FI                                        % *80B*
102544   %
102544   %     COPY DATA TO DATAFIELD AND RELEASE DEMFIELD
102544   %
102544         T:="OFSET+ST"+B; ST=:D; D+X; "SP-ST+1"=:L; *MOVAA
102554         TDEFI=:B
102556         X:=CURPROG; CALL BRELEASE;
102560         A:=TDAFI=:B                               %DATAFIELDPOINTER
102562         CALL HDLC
102563   HBACK:IF T><0 THEN        % ERROR IF T><0
102565            B+OFSET
102566            T=:ZAREG; GO RET                        %*81F*
102570         FI
102570         A:=MESSID; B+OFSET; A=:ZAREG               % RETURN MESSAGE IDENTIFIER
102573         ZPREG+1=:ZPREG; GO RET
102577   ERET: X=:B; T=:ZAREG; GO RET                     % *81F*
102602   RBUS
102617
102617   SUBR Z0PHY
102617
102617   % Routines to transfer data between a user V.S. and physical memory.
102617   % The user's alternative page table must be set before copying.
102617   % Source,destination addresses and byte count is found in the datafield.
102617
102617   % On entry: B points to the datafield:
102617   INTEGER BREG
102620   Z0PHY: A:=L=:"XXHOM"
102622          X:=B+OFSET; X.OLDPAGE=:D        %%%%%CALL GAPIT;
102626          T:=XXSBK; X:=XXSBF; DDD3=:L; XXUBF; A:=:B; *IOF
102635          A=:BREG
102636          L=:A; CALL ZDALTON; A SHZ -1=:D; BREG; A:=:B; *ION
102645          A:=:D
102646          X:=:T                                     % XT=Destn address
102647          DO A=:L:=4000:=:L; WHILE A>0              % A=No of words left,L=4000
102654                *SKP IF DA GRE SL; COPY SA DL       % Skip if more than 4000?
102656                A-L; * MOVAP;                       % A=No of words left
102660          OD;
102661          IF M THEN                                 % Odd no of bytes
102663             D:=:X; A:=X.S0; A/\177400=:L
102667             D:=:X; X:=:T; *LDATX 0
102672             A/\377\/L; *STATX 0                    % Mask in lh byte and store
102675          FI;
102675          CALL ALTOF
102676          GO XXHOM
102677   RBUS
102704   SUBR Z0USR
102704   INTEGER BREG
102705   Z0USR: A:=L=:"XXHOM"
102707          X:=B+OFSET; X.OLDPAGE=:D  %%%%%CALL GAPIT;
102713          T:=XXSBK; X:=XXSBF; DDD3=:L; XXUBF; A:=:B; *IOF
102722          A=:BREG
102723          L=:A; CALL ZDALTON; A SHZ -1=:D; BREG; A:=:B; *ION
102732          A:=:T
102733          X:=:D                                     % T=Destn address
102734          DO X=:L:=4000:=:L; WHILE X>0              % X=No of words left,L=4000
102741                *SKP IF DX GRE SL; COPY SX DL       % Skip if more than 4000?
102743                X-L; * MOVPA;                       % X=No of words left
102745          OD;
102746          IF M THEN                                 % Odd no of bytes
102750             D=:X; T=:D; A=:T         % AD=:TX ; Save T in D
102753             *LDATX 0                 % Get remaining byte  from phys. mem.
102754             A/\177400=:L             % Mask and save in L
102756             D=:X;  A:=X.S0           % Get word from user area
102760             A/\377\/L; A=:X.S0       % Mask in lh byte and store
102763          FI;
102763          CALL ALTOF
102764          GO XXHOM
102765   RBUS
102772
102772
102772   %========================================================================
102772   % 39.12
102772   %      H D L C
102772   %
102772   %
102772   % ENTRY:  B-REG POINTS TO DATAFIELD
102772   %
102772   %         ION, LEV 3 DISABLED
102772   %
102772   SUBR HDLC
102772   %
102772   INTEGER MESSM:=0                       % INCREMENTED FOR EACH SEND
102773   HDLC:  A:=L=:"RSRET"                   % SAVE RETURN ADDRESS
102775          IF HINIF >< -1 THEN             % POOL INITIATED ?
103001             MASTB =: XXSBK               % BANKNO TO COPY ROUTINE
103003             MAX -1 SHZ -1 + BUFST =: D
103010             A:=BUFST
103011             X:=B; T:=MASTB; *AAX XBBNK
103014             CALL ZBINI; CALL PZCRA
103016             -1=:HINIF                    % MARK AS INITIATED
103020          FI
103020          IF DDD0 = FSEND THEN
103024   %
103024   % SEND
103024   %
103024             IF DDD3 < 0 THEN T:=EMSGS; GO RSRET FI    % ILLEGAL MESSAGE SIZE
103030             IF A > DDD4 THEN T:=EMAXS; GO RSRET FI    % MAX SIZE < USED SIZE
103035             X:="XBBNK"+B; "BHEAD+BHEAD"+DDD4; CALL ZBGET; CALL ZCRAS  %ALLOCATE BUFFER
103043             IF A = 0 THEN T:=ENBUF; GO RSRET FI
103046             A=:RSCUR=:X                               % USER PART OF MESSAGE
103050             IF MESSM + 1 < 0 THEN 1=:MESSM FI         % ONLY POSITIVE VALUES
103055             A=:MESSM=:MESSID; T:=MASTB; * BBID@3 STATX
103061             DDD4; * BMBYT@3 STATX                     % MAX BYTECOUNT IN MESSAGE
103063             DDD3; * BBYTC@3 STATX
103065             "OCHAIN"; *XCHAI@3 STATX                  % NOT XMSG DCB
103067             DDD2=:XXUBF; T:=DDD3=:D; X+BHEAD=:XXSBF
103075             CALL Z0PHY; * IOF                         % COPY USER DATA TO BUFFER
103077             X:=RSCUR; CALL ICHAIN; *ION               % SET MESSAGE IN QUEUE
103102             CALL STDEV                                % ACTIVATE DRIVER
103103             0=:T; GO RSRET;
103105          FI
103105   %
103105   % RECEIVE
103105   %
103105   REMSG: *IOF
103106          CALL DOCHAIN; GO CHEMTY                   % REMOVE MESSAGE FROM QUEUE
103110          *ION
103111          X=:RSCUR; T:=MASTB; * BBID@3 LDATX
103114          A=:MESSID                                 % MESSID OF CURRENT MESSAGE
103115          * BBYTC@3 LDATX
103116          A=:T
103117          IF DDD0-FMXRECV=0 AND DDD3<<T THEN
103125             T:=EMSGS=:DDD0; T:=A                   % ERROR, DCB GREATHER THAN SPECIFIED IN PARAMETER #4
103130          ELSE
103131             0=:DDD0
103132          FI
103132          % RETURN BYTECOUNT TO USER
103132          MLEV; *MST PIE                            % MUST ALLOW PAGEFAULT
103134          X:=B+OFSET
103136          X.OLDPAG=:D      %%%%CALL GAPIT;
103140          X:=DDD3; CALL DALTON; T=:X.S0
103143          CALL ALTOFF
103144          MLEV; *MCL PIE
103146          DDD2=:XXUBF; T=:DDD3
103151          X:=RSCUR; X+BHEAD=:XXSBF
103154          CALL Z0USR; B=:X; *AAX XBBNK              % COPY TO USER
103157          RSCUR; CALL ZBREL; CALL ZCRAS             % RELEASE BUFFER
103162          T:=DDD0; GO RSRET                         % GO BACK
103164   *)FILL
103201   %
103201   %
103201   CHEMTY:DDD4=:XWAITF
103203          IF A = 1 THEN
103206                X:=CURPR; CALL WDATA
103210                *ION
103211                B+OFSET; ZPREG-1=:ZPREG
103215                CALL RETSTUPR
103216          ELSE
103217                *ION
103220                T:=EEMTY; GO RSRET
103222          FI
103222          GO RSRET
103223   %
103223   PZCRA: IF A = 2 THEN T:=ENBUF; GO RSRET; FI
103230          CALL ZCRAS
103231   RBUS
103235
103235

103235   %=======================================================================
103235   % 39.16
103235   %      Z C R A S             INCONSISTENSY IN HDLC NONRESIDENT PART
103235   %
103235   %      T-REGISTER WILL CONTAIN OLD L-REGISTER WHEN STOP IN ERRFATAL
103235   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
103235   %
103235   SUBR ZCRAS
103235   INTEGER DHAAA                                  % ERRCODE
103236   INTEGER DHLLL                                  % WHERE I COME FROM
103237   ZCRAS: A=:DHAAA; A:=L=:DHLLL
103242          L=:T; A:=B+OFSET=:B; CALL 9ERR(#33)
103250          B-OFSET=:B; T:=HXERF; GO RSRET
103254   RBUS
103255
103255
103255   %=======================================================================
103255   % 34.32     H D T M 2      H D T M 3
103255   %       OUTPUT TIMEOUT ROUTINE
103255   %
103255   %       PURPOSE: ACTIVATE TIMEOUT ROUTINE ON LEVEL 12
103255   %
103255   SUBR   HDTM2
103255   HDTM2: T:=HXTMO; GO STL12                        % *80B*
103257   RBUS
103260   %
103260   %
103260   %       INPUT TIMEOUT ROUTINE
103260   %
103260   %       PURPOSE: ACTIVATE TIMEOUT ROUTINE ON LEVEL 13
103260   %
103260   SUBR HDTM3
103260   HDTM3: T:=HXTMO; GO STL13                        % *80B*
103262   RBUS
103263
103263
103263   %%%SUBR X21IN,X2STA,X21TO
103263   %%%RBUS
103263
103263
103263
103263   *"8XMSG+8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"103263

103263   %==============================================================================
103263   %
103263   % 40.9      GENERAL BUFFER ALLOCATION PACKAGE - ZB... for XMSG and HDLC
103263   %
103263   %==============================================================================
103263   SUBR ZBINI,ZBGET,ZBREL
103263   %
103263   %      THIS PACKAGE IS BASED ON THE CERN SMO MEMORY ALLOCATION PACKAGE. IT
103263   % ALLOCATES BUFFERS OF SIZE MULTIPLE OF FOUR WORDS. THE FIRST WORD OF EACH
103263   % BUFFER IS USED BY THE ALLOCATION PACKAGE AND CONTAINS:
103263   %      BIT 0 : SET IF THE BUFFER IS FREE (ZBCFR)
103263   %          1 : SET IF PRECEDING BUFFER IS FREE (ZBPFR)
103263   %       2-15 : BUFFER LENGTH IN MULTIPLE OF FOUR WORDS
103263   %
103263   %      IF THE BUFFER IS FREE (BIT 0 SET), THE LAST WORD OF THE BUFFER CONTAINS
103263   % THE ADDRESS OF ITS START (FOR CONCATENATION OF FREED BUFFERS.)
103263   %
103263   %      THE USER OF THIS PACKAGE MUST PROVIDE OF BUFFER AREA DESCRIPTOR OF 4
103263   % WORDS, WHICH MUST BE POINTED AT BY X ON ENTRY TO THESE ROUTINES:
103263   %
103263   DISP 0
103263          INTEGER ZBBNK         % BANK NO WHERE BUFFER AREA LIES (=0 IF N10)
103263          INTEGER ZBSTR         % ADDRESS OF FIRST WORD USED IN BANK FOR BUFFERS
103263          INTEGER ZBEND         % ADDRESS OF LAST WORD USED IN BANK FOR BUFFERS
103263          INTEGER ZBSAV         % SAVE LOCATION FOR USER B-REG
103263   PSID
103263   SYMBOL ZBCFR=0,ZBPFR=1       % BITS IN THE HEADER (DO NOT CHANGE - SEE CODE)
103263   %
103263   %      FUNCTIONS PROVIDED MUST BE CALLED WITH X POINTING TO THE DESCRIPTOR.
103263   % THE RETURN WILL BE BY SKIP RETURN UNLESS A FATAL ERROR IS DETECTED IN WHICH
103263   % CASE A WILL CONTAIN AN ERROR CODE:
103263   SYMBOL ZBX01=1               % BANK NO >< 0 AND CPSTA SAYS THIS IS A N10
103263   SYMBOL ZBX02=2               % NOT ENOUGH BUFFER SPACE TO INITIALISE
103263   SYMBOL ZBX03=3               % INCONSISTENCY IN BUFFERS FOUND BY ZBGET
103263   SYMBOL ZBX04=4               % ILLEGAL USER BUFFER ADDRESS TO ZBREL
103263   %
103263   %      FUNCTIONS ARE:            (B -> BUFFER AREA DESCRIPTOR)
103263   %
103263   % ZBINI:     INITIALISE BUFFER AREA
103263   %            T=BANK NO, A=ADDR OF FIRST WORD TO USE, D=ADDR OF LAST WORD
103263   %
103263   % ZBGET:     GET BUFFER SPACE
103263   %            A=NO OF BYTES
103263   %      SKIP: A:=USER BUFFER ADDRESS ( OR 0 IF NONE AVAILABLE )
103263   %            NB: This is the address of the first USABLE word in the buffer
103263   %
103263   % ZBREL:     RELEASE BUFFER SPACE
103263   %            A=USER BUFFER ADDRESS
103263   %
103263   INTEGER ZBMSK:=177774
103264   INTEGER POINTER ZBCPS:=CPSTA
103265
103265   ZBINI: X:=:B=:ZBSAV; T=:ZBBNK;                   % INITIALISE DESCRIPTOR
103270          IF T><0 AND X:=ZBCPS NBIT 5N100 THEN      % BANK><0 AND NOT N100
103275               ZBX01; GO ZBOUT                      % NOT ALLOWED
103277          FI
103277          X:=ZBMSK; A+3/\X=:ZBSTR; X/\D=:ZBEND      % ROUND START UP, END DOWN
103305          IF A+10>>=X THEN ZBX02; GO ZBOUT; FI      % NOT ENOUGH SPACE
103312          X-1; *STATX 0; SAA 2; STATX 10            % BACKPTR. LENG=0, PREV. FREE
103316          X:=ZBSTR; ZBEND-X BONE ZBCFR; *STATX 0    % SET LENGTH & FREE.
103323          GO ZBOKR                                  % SKIP RETURN
103324
103324   ZBGET: X:=:B=:ZBSAV                              % SAVE USER B-REG. B->DESCR.
103326          A SHZ -1; *BSKP ZRO SSM; RINC DA          % A=NUMBER OF USER WORDS
103331          A+4/\ZBMSK=:D; X:=ZBSTR                   % D=NUMBER OF WORDS NEEDED
103335          DO WHILE X><ZBEND                         % SCAN DOWN BUFFERS
103340                ZBX03; IF X>>T OR X<<ZBSTR GO ZBOUT % BUFFERS DESTROYED!
103346                T:=ZBBNK; *LDATX 0                  % GET HEADER WORD
103350                IF A BIT ZBCFR AND A>>=D THEN       % SPACE AVAILABLE?
103354                     A BZERO ZBCFR :=:D; * STATX 0  % SET NEW LENGTH IN HEADER
103357                     % NOW HAVE: X=BUFAD, A=NEWSIZE, D=OLDSIZE, T=BANK NO
103357                     D-A; A+X:=:X                   % D=REMNANT, A=USER BUF, X=NEW
103362                     IF D=0 THEN                    % FILLED WHOLE BUFFER?
103364                          D:=A; * LDATX 0           % GET HEADER OF NEXT BUFFER
103366                          A BZERO ZBPFR; * STATX 0  % CLEAR PREVIOUS FREE
103370                          A:=D                      % RECOVER USER ADDRESS
103371                     ELSE; * STATX 10               % SAVE USER ADDR IN NEW BUF(1)
103373                          A:=D BONE ZBCFR; *STATX 0 % BUILD NEW HEADER
103376                          X=:A+D-1; * STATX 0       % SET BACK POINTER
103402                          X:=A; * LDATX 10          % RECOVER USER ADDRESS
103404                     FI;
103404                     A+1; GO ZBOKR                  % RETURN WITH USER ADDR.
103406                FI; A/\ZBMSK+X=:X                   % TRY NEXT
103411          OD;
103412          A:=0; GO ZBOKR                            % NO SPACE LEFT
103414
103414   ZBREL: X:=:B=:ZBSAV; A-1=:X/\ZBMSK               % CONVERT USER->BUFFER ADDR
103421          IF A><X OR A<<ZBSTR OR A>>=ZBEND GO ZBIOW % CONSISTENCY CHECKING
103431          T:=ZBBNK; * LDATX 0                       % GET BUFFER HEADER
103433          IF A BIT ZBCFR THEN GO ZBIOW; FI          % SHOULD BE ALLOCATED
103436          A/\ZBMSK; X=:D+A; * LDATX 0               % GET HEADER OF NEXT BUFFER
103442          IF A BIT ZBCFR THEN A/\ZBMSK; X+A; FI     % IF FREE FIND ONE AFTER
103446          X:=:D; * LDATX 0                          % GO BACK TO ORIGINAL.
103450          IF A BIT ZBPFR                            % IF PREVIOUS FREE
103450          THEN X-1; * LDATX 0; COPY DX SA           % GET POINTER TO START OF PREV
103455          FI
103455          % WE NOW HAVE X=START OF NEW (CONCATENATED) BUFFER, D=START OF NEXT
103455          A:=D-X BONE ZBCFR; * STATX 0              % SET HEADER OF NEW
103461          X=:A:=D-1; * STATX 0; LDATX 10            % SET BACK PTR, GET NEXT HEAD
103466          A BONE ZBPFR; * STATX 10                  % SET PREVIOUS FREE
103470   ZBOKR: L+1; GO ZBOUT                             % SKIP RETURN SEQUENCE
103472   ZBIOW: ZBX04;                                    % ILLEGAL BUFFER ADDRESS
103473   ZBOUT: X:=ZBSAV:=:B; EXIT                        % RESTORE USER B AND X-REGS
103476   RBUS
103476   %==================== END OF BUFFER ALLOCATION ROUTINES (ZB...) ==============
103476
103476   *"8SIBA+8SIBX+8SIBM
"103476   %==============================================================================
103476   %      ( R )      M A P S I B   -   M S I B B
103476   %
103476   % SIBAS COMMUNICATION MONITOR CALL
103476   %
103476   SUBR MAPSIB,MSIBB,TISIBB
103476
103476   DOUBLE ARRAY CRTCADDR(0)
103476           *0;0;0;0;0;0;0;0;0;0;0;0
103512           *0;0;0;0;0;0;0;0;0;0;0;0
103526           *0;0;0;0;0;0;0;0;0;0;0;0
103542           *0;0;0;0;0;0;0;0;0;0;0;0
103556
103556   MAPSIB: X=:B;  MLEV; *MCL PIE                    % DISABLE MONITOR LEVEL
103561          IF BACKGROUND><0 THEN CALL ESCOFF FI
103564          IF SRTCSTAT><0 GO FAR M2ERR               % WAIT, SIBAS IS ACTIVE.
103567          IF ZTREG >> MXSIB GO FAR M1ERR            % SIBAS DEVNO NOT AVAILABLE
103573          X:=SIBBDEVS(ZTREG)                        % X=MON MSIBB WORKING FIELD
103575          IF X:=X.RTRES=0 GO FAR M1ERR              % SIBAS NOT STARTED
103600          IF X.STATUS NBIT 5WAIT GO FAR M2ERR       % SIBAS RUNNING (NOT WAITING FOR ME)
103603          X:=ZTREG+X; *1BANK
103606          AD:=CRTCADDR(X); *2BANK
103610          IF A=0 AND D=0 THEN                        % FIRST CALL TO THIS SIBAS
103613            X:=SIBBDEVS(ZTREG)
103615            IF X.SIBLAM >< 0 THEN                    % LAMU COMMUNICATION ?
103617               IF A- >= GNSYL  GO FAR M3ERR
103623               X=:L; A*SDTSZ+SYLDT=:X; T:=LAMBANK; *LDDTX
103631               A:=:D; A SHZ 12 =:L.SIBLSZ            % LAMU LENGTH IN WORD
103635               0=:A; AD SHZ 12; X:=ZTREG+X; *1BANK   % AD= PHYS ADDR FOR LAMU
103642               AD=:CRTCADDR(X); *2BANK
103644            ELSE
103645              IF ARTFPAGE=100 GO FAR M1ERR           % NO RTCOMMON IN THIS SYSTEM
103651              A:=CCLPAGE SHZ 12+1000; T:=ZTREG SH 11 % (LOG.START OF RT-COMMON)-(ZTREG*1000B)
103656              A-T SHZ -12+100+A+IRTCP=:X; X.S1       % A=PHYSICAL PAGE OF RT-COMMON
103665              A=:D; CALL DISPC; 0/\0                 % DISABLE PAGE FROM CACHE
103670              0=:A; AD SHZ 12
103672              IF T:=ZTREG NBIT "0" THEN T:=1000
103676              ELSE T:=0 FI
103700              D+T; A:=A+C; X:=ZTREG+X; *1BANK
103705              AD=:CRTCADDR(X); *2BANK                % AD=PHYSICAL ADDR OF SIBAS-MESSAGE-BUFFER
103707            FI
103707          FI; AD=:SIDRTC
103710          T:=SIAD2; X:=ZXREG; OLDPAGE=:D; A:=SIAD1
103715          CALL DALTON                               % USER-ALT-PIT=:CURRENT-ALT-PIT
103716          A=:L; X=:D; MLEV; *MST PIE                % ENABLE MLEV BEFORE FETCHING MESSAGE LENGTH
103722          X.S1                                      % MESSAGE LENGTH
103723          IF A=0 OR A>>X:=177 GO FAR XEE174         % 177*4=774B WORDS IS MAX. MESSAGE SIZE
103727          A SH 2:=:L; A=:X; *MOVAP                  % COPY MESSAGE TO RTCOMMON
103733          CALL ALTOFF                               % SET ALT.PIT=ADPIT
103734          GO OVER; *)FILL
103761   INTEGER CWORDCOUNT
103762   OVER:  *IOF
103763          X:=SIBBDEVS(ZTREG); 0=:X.TMR              % RESET SIBAS TIME OUT COUNTER
103766          IF X.SIB500=0 THEN                        % SIBAS IN ND-500?
103770             IF X:=X.RTRES=0 GO M1ERR               % NO IN ND-100; SIBAS TERMINATED?
103772             IF X.STATUS NBIT 5WAIT GO M1ERR        % NO, WAITING FOR REQUEST?
103775             A BZERO 5WAIT=:X.STATUS                % YES, REACTIVATE SIBAS
103777          ELSE
104000             IF X.RTRES=0 GO M1ERR                  % SIBAS IN ND-500; SIBAS TERMINATED?
104002             A=:D; CALL FSEMA; GO M1ERR             % NO, IS IT STILL IN ND-500?
104005             CALL 5PRACTIVATE; GO M1ERR             % YES, REACTIVATE SIBAS IN ND-500
104007          FI
104007          RTREF.STATUS BONE 5WAIT=:X.STATUS         % SET CALLER IN I/O-WAIT
104013          -1=:SRTCSTAT                              % MARK SIBAS IS ACTIVE
104015          "STUPR"; *IRW MLEVB DP
104017          MLEV; *MST PID; ION
104022          % RESTART HERE WHEN SIBAS RESTARTS ME.
104022          MLEV; *MCL PIE                            % PROTECT NON-REENTRANT SEQUENCE
104024          X:=SIAD2; T:=SIAD1; *LDATX 10             % FETCH SIZE OF ANSWER-MESS. FROM RTCOMMON
104027          IF A=0 OR A>>177 GO EE174                 % (177B*4)B WORDS IS STILL MAX.SIZE
104033          A SH 2=:CWORDCOUNT                        % NO OF WORDS IN ANSWER-MESS.
104035          T:=ZDREG; SIDRTC; X:=OLDPAGE:=:D; CALL DALTON % CALLER'S-ALT-PIT=:CURRENT-ALT-PIT
104042          D:=X; X:=CWORDCOUNT=:L
104045          A=:X:=MLEV; *MST PIE
104050          A:=X; *MOVPA                              % COPY ANSWER-MESSAGE FROM RT-COMMON TO CALLER
104052          CALL ALTOFF
104053   OKRET: 0=:ZAREG; MIN ZPREG; 0/\0                 % SKIP RETURN
104056          GO MXRET
104057   *)FILL
104067   XEE174: CALL ALTOFF
104070   EE174: 174; GO CERET
104072   M3ERR: A:=-3; GO CERET
104074   M2ERR: A:=-2; GO CERET
104076   M1ERR: A:=-1
104077   CERET: A=:ZAREG; *ION
104101          GO MXRET
104102
104102   %
104102   % MONITOR CALL MSIBB
104102   %
104102   MSIBB: X=:B;  MLEV; *MCL PIE                     % DISABLE MONITOR LEVEL
104105          A:=ZTREG SHZ -6
104107          IF A >< 0 AND A \/ 176000 >< SIBLAM THEN
104114            A=:SIBLAM;                              % UPDATE SIBAS LAMU NR
104115            A:=ZTREG /\ 77+A=:X                     % SIBAS INDEX
104121            A:=0=:D; *1BANK
104124            AD=:CRTCADDR(X); *2BANK                 % ZERO PHYS PAGE
104126          FI
104126          A:=ZTREG /\ 77=:X                         % SIBAS INDEX
104131          X:=SIBAPDEVS(X)=:D                        % D=MON MAPSIB'S WORKING FIELD
104133          0=:SIB500                                 % MARK THAT SIBAS RUNNING IN ND-100
104134          *IOF
104135          IF X:=X.RTRES><0 AND X.STATUS BIT 5WAIT THEN % ANY PROGRAM WAITING FOR THIS SIBAS?
104142             A BZERO 5WAIT=:X.STATUS                % YES, REACTIVATE IT
104144          FI
104144          IF ZAREG=0 THEN                           % SIBAS CONTINUE OR WAITING FOR NEW REQUEST?
104146             RTREF.STATUS BONE 5WAIT=:X.STATUS; A:=0 % WAITING FOR NEW REQUEST
104153             T:=TTMR=:TMR
104155          ELSE
104156             A:=1;0=:TMR                            % CONTINUE; MARK THAT SIBAS IS STILL RUNNING
104160          FI; A=:D.SRTCSTAT; MIN ZPREG; 0/\0        % SKIP RETURN
104164          GO RETSTUPR
104165   *)FILL
104175   INTEGER POINTER LREG
104176   TISIBB:
104176   %============================================================================
104176   % TIME OUT ROUTINE FOR MSIBB, ACTIVATED FROM TIMER PROGRAM.
104176   %============================================================================
104176           IF SIB500 = 0 THEN
104200             IF X:=RTRES >< 0 AND X.STATUS BIT 5WAIT THEN  % SIBAS RUNNING ?
104205                 A BZERO 5WAIT=:X.STATUS                   % YES, REACTIVATE IT
104207                 X:=X.RTDLGADDR; T:=0;* DPREG@3 LDATX
104212                 A-1; * DPREG@3 STATX                      % RESET SKIP RETURN
104214                 202; * DAREG@3 STATX                      % RETURN TIME OUT
104216             FI
104216           ELSE
104217             A:=L=:"LREG"
104221             IF RTRES =0 GO LREG; A=:D; CALL FSEMA; GO LREG
104227             CALL 5ERACTIVATE; A/\ A                       % REACTIVATE SIBAS IN ND-500
104231             GO LREG
104232           FI
104232           EXIT
104233   RBUS
104236
104236   *"8NSDB
"104236   %==============================================================================
104236   %      ( R )     S Y M B O L I C   D E B U G G E R
104236   %
104236   INTEGER CUIDX
104237   SUBR BRPNT,DEBUGGER
104237
104237   @MAC

)9SCLC
104237  MAXUS=0
104237  "8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB20+8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB10+8DB20+8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
104237  "8DB01+8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
104237  "8NSDB
104237  )9RCLC
)9SLPL
104237   INTEGER ARRAY DBUGSEG(0); * *+MAXUS/
104277   INTEGER ARRAY OLDSEGS(0); * *+MAXUS/
104337   INTEGER ARRAY BPHANDLER(0); * *+MAXUS/
104377   INTEGER ARRAY REGBL(0); * *+MAXUS/
104437   INTEGER ARRAY APTNO(0); * *+MAXUS/
104477   INTEGER ARRAY DBRSEGM (0);* *+MAXUS/
104537   *)KILL MAXUS
104537
104537   DISP 20                      % D0
104537   INTEGER OOLDPAGE            % TEMPORARY OLDPAGE
104537   INTEGER FILNR                % OPEN FILE NUMBER
104537   INTEGER BLCKNO               % BLOCK NUMBER WITHIN FILE
104537   INTEGER NWRD                 % NUMBER OF WORDS
104537   INTEGER ARRAY RWPAR(5)       % PARAMETER LISTE FOR MON RFILE
104537   INTEGER ARRAY BUFFR(7)       % BUFFER FOR MON RFILE; 7 FIRST WORDS ON PROG.FILE
104537   INTEGER WSPAR=BLCKNO
104537   INTEGER WLIST=NWRD
104537   PSID
104537
104537   % ROUTINE TO CHECK SAVED RT-DESCRIPTION BITMAP FOR A GIVEN ADDRESS
104537   % ENTRY: D = ADDRESS
104537   %        X = START OF SAVED BITMAP
104537   %        A = 0 IF NORMAL PIT; A=1 IF ALTERNATIVE PIT
104537
104537   INTEGER SKPINSTR;* *-1/BSKP ZRO 00 DT
104540   RBITM:   AD SHZ -12 ;D=:A          % PIT+PAGENO IN A
104542            D:=0;AD SHZ-4             % BITMAP WORD IN A;BIT NO. IN D
104544            X+A                       % BITMAP WORD ADDRESS IN X
104545            SKPINSTR;  D SHZ -11 + A  % BUILD BSKP INSTR WITH BITNO FROM D
104550            T:=X.S0 ;A:=0;            % GET BITMAP WORD,INDICATE BIT NOT SET
104552            *EXR SD; SAA 1            % A=1 IF BIT SET, A=0 IF NOT SET
104554            EXIT
104555
104555
104555   % ROUTINE TO CHECK IF SEGMENT NUMBER IS LEGAL AND THAT
104555   % SEGMENT IS AVAILABLE
104555   % ENTRY:      A= SEGMENT NUMBER
104555   % IF OK:      EXIT : X= SEGMENT TABLE FLAG
104555   % IF NOT OK:  GO ERR
104555
104555   SEGOK:  IF A>=2     AND <=SGMAX THEN
104563               A*5SEGSIZE+SEGSTART=: X;T:=SEGTBANK
104567               *FLAG@3 LDATX
104570               IF A BIT 5INHB GO ERR1
104572               *SGSTA@3 LDATX
104573               IF A= 0 GO ERR1
104574               EXIT
104575           FI
104575   ERR1:   A:=371; GO FAR ERR         % ILLEGAL SEGMENT
104577   *)FILL
104605   % ROUTINE TO CHECK FOR USER SYSTEM OR RT
104605   % CALLED FROM FUNCTIONS ACCESSING SEGMENTS
104605   % OK: RETURN TO CALLER
104605   % NOT SYS OR RT: ERROR RETURN FROM MONCALL WITH ERRCODE=25B
104605
104605   INTEGER POINTER PPASS:=PASSTYPE
104606   SYSRT: IF PPASS=0 THEN "ER4";GO FAR ERR FI
104612          EXIT
104613
104613   % SET AND RESET SEGMENT-WRITE-PROTECTION
104613   DWPROTECT: A:=0;GO FELLS
104615   DWPERMIT:  A:=1
104616   FELLS: A=:D
104617          CALL SYSRT;ZAREG; CALL SEGOK
104622          X=:T                                     % EXIT FROM SEGOK: X=SEG.TAB ADDR
104623          IF D=0 THEN
104625              ZAREG=:D;CALL SGAND                   % ENTRY TO SGAND/SGOR:
104630          ELSE                                      % T= SEGM TABLE ELEMENT ADDRESS
104631              ZAREG=:D;CALL SGOR                    %
104634          FI                                        %
104634          MIN ZPREG; 0/\0; GO FAR RETU
104637   *)FILL
104643
104643   INTEGER ARRAY DDRBIT (10)
104653   INTEGER SBREG,SVREE
104655   BRPNT: IF BACKGROUND=0 GO FAR RTBPT
104660          CALL GET0
104661          MLEV; *MST PIE
104663          A:=CURPROG;CALL LAMINHIBIT       % DISABLE LAMU
104665          RTREF.RSEGM=:SVREE
104670          T:=X.ACT1SEG;CALL M1MEXY         % FORCE SEGADM TO UPDATE BITMAP
104672          CALL FINDINDEX; GO FAR RETU      % FIND DEBUGGER-INDEX USED BY CALLER
104674          A:="DDRBIT":=:B=:SBREG
104677          X:=RTREF.RTDLG+5BITM;T:=0        % BITMAPS ARE IN PHYS. BANK 0
104703          *1BANK
104704          *LDDTX 0 ;STD 0,B                % SAVE BITMAP TEMPORARILY IN DDRBIT
104706          *LDDTX 20 ;STD 2,B
104710          *LDDTX 40 ;STD 4,B
104712          *LDDTX 60 ;STD 6,B
104714          A:=SBREG=:B
104716          *2BANK                           % UNSAVE B-REG
104717          MLEV;*MCL PIE
104721          X:=RTREF; CALL CLRBM
104723          *1BANK
104724          X:=CUIDX
104725          T:="SGNUM"+X                     % T=DEBUGGER'S DATA SEGMENT
104727          DBUGSEG(X); *2BANK               % A=DEBUGGER REENTRANT PROGRAM SEGMENT
104731          A=:RTREF.RSEGM
104733          MLEV;*MST PIE
104735          CALL M1MEXY;
104736          AUPIN=:D;CALL DALTON             % USERS NORMAL PIT AS APT (DEBUGGERS DATA SEGMENT)
104741          *1BANK
104742          T=:OLDSEG(CUIDX)
104744          A:=SVREE=:DBRSEGM (X)            % SAVE RSEGM FOR LATER START OF PROGRAM
104746          X:=REGBL(X)
104747          *2BANK; STA 14 ,X                % WRITE RSEGM TO DEBUGGER'S REGISTER BLOCK
104751          X=:T
104752          CALL SINALTPIT                   % RESET DPIT AS APT
104753          ZPREG-1=:ZPREG
104756          OLDPAGE=:OOLDPAGE/\600 SHZ -7+1=:OLDPAGE
104764          A:=B+"ZPREG"=:D; A:=200; X:=11; K:=1; CALL MOVUS
104773          OOLDPAGE/\174177+200=:OLDPAGE; *1BANK
105000          BPHANDLER(CUIDX); *2BANK
105003          A=:ZPREG
105004          IF A:=SVREE>< 0 THEN             % COPY BITMAP TO DEBUGGER'S DATA SEGMENT
105006                MLEV; *MCL PIE;
105010                *1BANK
105011                A:=REGBLO (CUIDX)+20:=:B =:SBREG
105016                X:="DDRBIT"
105017                *2BANK
105020                A:=AUPIN=:D;CALL DALTON
105023                *1BANK; LDD ,X 0; 2BANK; STD ,B 0
105027                *1BANK; LDD ,X 2; 2BANK; STD ,B 2
105033                *1BANK; LDD ,X 4; 2BANK; STD ,B 4
105037                *1BANK; LDD ,X 6; 2BANK; STD ,B 6
105043                CALL SINALTPIT
105044                A:=SBREG=:B
105046          FI
105046          GO FAR RETU
105047   *)FILL
105100
105100   INTEGER RTBRB=?             % BUFFER AREA FOR REGISTER BLOCK + +
105100   RTBPT: CALL GET0
105101          MLEV;*MCL PIE
105103          X:="RTBRB"       % COPY FROM WORKING FIELD TO BUFFER IN RPIT
105104          *LDF 7,B  ;1BANK; STF 0,X;2BANK
105110          *LDF 12,B ;1BANK; STF 3,X;2BANK
105114          *LDF 15,B ;1BANK; STT 6,X ;STA  7,X;2BANK
105121          OLDPAG /\ 600 SH -7+1;*1BANK; STA 10,X ;2BANK
105130          CURPROG;*1BANK;STA 11,X;2BANK
105134          AD:=CURPROG.DACTSEG;T:=X.RSEGM       % GET SEGMENTS AND RSEGM, X IS DESTROYED
105137          X:="RTBRB"                           % RESTORE X
105140          *1BANK; STA 12 ,X; COPY SD DA;STA 13,X; STT 14,X; 2BANK
105146          CURPROG.STATUS BONE 5WAIT=: X.STATUS % BREAKPOINTED PROGRAM IN I/O-WAIT
105152          CALL 9ERRA (-1)    % GIVE MESSAGE ON ERROR DEVICE
105154
105154   RETS:  X:=CURPROG;CALL BRELEASE
105156          GO FAR RETSTUPR
105157   G9ERR: A:=204 ;CALL 9ERRA(#00)
105162          X:=CURPROG
105163          CALL BRELEASE ;GO FAR RETXIT  % ABORT PROGRAM
105165
105165   *)FILL
105176   DEBUGGER: CALL GET0
105177          MLEV; *MST PIE
105201          IF ZTREG>>17 GO FAR RETU
105205   @ICR;
105205   A GOSW FAR GETDSEG,        %  0      GET DATA SEGMENT
105207          FAR PLAC1,          %  1      PLACE
105210          FAR PSTART,         %  2      START PROGRAM OR REENTRANT SUBSYSTEM
105211          FAR READLOC,        %  3      READ LOCATION
105212          FAR WRITLOC,        %  4      WRITE LOCATION
105213          FAR RELDSEG,        %  5      RELEASE DATA SEGMENT
105214          FAR RTGDBSEG,       %  6      GET DATA SEGMENT
105215          FAR CHLGSEG,        %  7      CHECK LEGAL SEGMENT
105216          FAR RRGBLOCK,       %  8      READ REGISTER BLOCK
105217          FAR WRGBLOCK,       %  9      WRITE REGISTER BLOCK
105220          FAR STRRT,          %  10     START RT-PROGRAM
105221          FAR RETU,           %  11     NOT USED
105222          FAR RETU,           %  12     NOT USED
105223          FAR DWPERMIT,       %  13     SEGMENT WRITE-PERMIT
105224          FAR DWPROTECT,      %  14     SEGMENT WRITE-PROTECT
105225          FAR PLREENTRANT     %  15     PLACE REENTRANT SUBSYSTEM
105225   ;@CR;
105226   *)FILL
105246   INTEGER SAVA ,REIND:=1,SEGA
105251   READLOC:
105251   WRITLOC:
105251           CALL FINDINDEX; GO ERR;1=: REIND
105255           T:=RTREF.ACT1SEGM;0=:RTREF.RSEGM;CALL M1MEXY
105262           IF ZAREG SHZ-1 = 0 GO ONBG        % NO SEGMENT NO.,USE BACKG. SEGMENT
105265           CALL FAR SEGOK; X=: SEGA          % X= SEGM TABLE ELEMENT
105267           T:=SEGTBANK; *FLAG@3 LDATX
105271           IF A NBIT 5SREEP GO ONSEG         % NOT REENTRANT SUBSYSTEM
105273           T:=AUPIN=:D
105275           T:=ZDREG
105276           A:=ZAREG /\ 1
105300           CALL DALTON;*1BANK            % GET UPITN AS APT
105302           T=:D
105303           X:=REGBLO (CUIDX)+20
105306           *2BANK
105307           CALL  FAR RBITM               % D=ADDRESS; X= BITMAP; A=0/1 (NPT/APT)
105310           A=: REIND
105311           CALL SINALTPIT                % RESTORE DPIT AS APT
105312           IF A=0 THEN         %SEGMENT
105313   ONSEG:     CALL FAR SYSRT
105314              T:=ZAREG SHR -1
105316           ELSE                %BACKGROUND SEGMENT
105317   ONBG:      T:=RTREF.SEGM2+1
105322              IF ZAREG/\ 1><0 THEN T BONE 17 FI
105326           FI;
105326           T=:SAVA;A:=CURPROG; CALL LAMENABLE;T:=SAVA
105332           X:=ZDREG
105333           IF ZTREG-3=0 THEN
105336                 CALL GET1L; GO ERR0;A=: ZAREG
105341           ELSE
105342               ZXREG; CALL PUT1L; GO ERR0
105345               IF REIND=0  THEN
105347                   A:=ZAREG SHZ -1=:WSPAR
105352                   A:="WSPAR"+B=:WLIST
105355                   A:="WLIST"+B
105357                   *MON 2WSEG
105360               FI
105360           FI
105360   OK:     MIN ZPREG; 0 /\ 0; GO OK1
105363   ERR0:   A:= 372      % ILLEGAL ADDRESS
105364   ERR:    A=: ZAREG
105365   OK1:    A:=CURPROG;CALL LAMINHIBIT     % DISABLE LAMU
105367           *1BANK
105370           X:=CUIDX; T:="SGNUM"+X; A:=DBUGSEG(X); *2BANK
105375           A=:RTREF.RSEGM;CALL M1MEXY
105400           GO FAR RETU
105401   *)FILL
105431   CHLGSEG:ZAREG;CALL FAR SEGOK
105433           MIN ZPREG; 0/\0
105435           GO FAR RETU
105436   *)FILL
105440
105440   INTEGER SSAVB
105441   PSTART: CALL FINDINDEX; GO FAR RETU
105443          T:=ZXREG; A:=ZAREG; *1BANK
105446          T=:BPHANDLER(CUIDX); A=:REGBL(X); *2BANK
105452          X:=10; T:="ZPREG"+B; ZAREG=:D; A:=OLDPAGE      % COPY REGISTER BLOCK FROM
105460          K:="0"; CALL MOVUS                             % DEBUGGERS DATA SEGMENT
105462                                                       % TO MONCALL DATAFIELD
105462          *1BANK
105463          T:=DBRSEGM (CUIDX)                           % SAVED RSEGM, EITHER FROM PLREE
105465          X:=REGBLO(X)                                 % OR FROM LAST BREAKPOINT
105466          *2BANK
105467          AUPIN=:D;CALL DALTON
105472          *LDA ,X 10 ;COPY SA DD                       % WREG, (ALTPIT IN DEBUGGER)
105474          CALL SINALTPIT
105475          MLEV; *MCL PIE
105477          T=: RTREF.RSEGM                              % INSTALL SAVED RSEGM HERE
105501          IF D=3 THEN
105504             *1BANK
105505             T:=APTNO(CUIDX); *2BANK
105510          ELSE
105511             T:=200
105512          FI
105512          T=:D
105513          OLDPAGE/\174177\/D=:OLDPAGE
105517          IF RTREF.RSEGM><0 THEN
105522                *1BANK
105523                A:=REGBLO (CUIDX)+20:=:B =:SSAVB
105530                *2BANK
105531                X:=RTREF.RTDLG+5BITM ;T:=0
105535                AUPIN=:D;CALL DALTON
105540                   *LDD ,B 0; STDTX  0
105542                   *LDD ,B 2; STDTX  20
105544                   *LDD ,B 4; STDTX  40
105546                   *LDD ,B 6; STDTX  60
105550                CALL SINALTPIT
105551                A:=SSAVB=:B
105553          FI
105553          MLEV;*MST PIE
105555          A:=CURPROG;CALL LAMENABLE
105557          *1BANK
105560          T:=OLDSEG(CUIDX); *2BANK
105563          CALL M1MEXY
105564          GO FAR RETU
105565   *)FILL
105607
105607
105607   RTGDBSEG: CALL FAR SYSRT
105610             IF DBGPROGS(0)><0 AND A><CURPROG GO E400
105616             CURPROG=:DBGPROGS(0)
105621             X:=0
105622             GO FAR SGFOUND
105623
105623   E400:     A:= 400
105624   ERR2:     A=: ZAREG; GO FAR RETU
105626   *)FILL
105634
105634   INTEGER BBREG
105635   STRRT: CALL FAR SYSRT
105636          IF ZAREG >>= RTEND  GO ILLRT
105642          IF A - RTSTART <0  GO ILLRT
105644          A=: D:=0; T:= 5RTSIZE; *RDIV ST
105650          IF D>< 0 GO ILLRT
105652   %%% PREPARE COPY OF REGBLOCK FROM DEBUGGER TO RT-DESCRIPTION
105652          A:=B=:BBREG               % SAVE B
105654          X:=ZAREG.RTDLG=:B;T:=0    % PHYS ADDR OF RTDESC'S REGBLOCK
105660          AUPIN=:D; CALL DALTON     % UPITN AS APT
105663          MLEV;*MCL PIE
105665          * 1BANK
105666          X:=REGBL (0)              % GET ADDR OF DEBUGGERS REGBLOCK
105670          *2BANK
105671          B:=:X                     % B = DEBUGGERS REGBLOCK
105672                                    % X = RT-DESCR'S REGBLOCK
105672         * LDD 0,B ; STDTX 0
105674         * LDD 2,B ; STDTX 20
105676         * LDD 4,B ; STDTX 40
105700         * LDD 6,B ; STDTX 60;
105702
105702          A:=BBREG=:B               % UNSAVE B
105704          CALL SINALTPIT            % RESET DPIT AS APT
105705
105705          IF A:=ZAREG.WLINK=0 THEN
105710              CALL RTENTRY          %  RTDESC IN X
105711          ELSE
105712              X.STATUS BZERO 5WAIT =: X.STATUS
105715          FI
105715          MIN ZPREG; 0/\ 0;GO FAR RETS
105720
105720   ILLRT: A:=274; GO FAR ERR2   % ILLEGAL RT-PROGRAM
105722
105722   INTEGER BRG =?              % SAVE LOC.
105722   INTEGER RTBRB ;* 0;0;0;0;0;0;0;0      % BUFFER AREA FOR REGISTER BLOCK + +
105733                  * 0;0;0;0;0;0;0;0
105743   *)FILL
105756   WRGBL: ZXREG
105757          *1BANK
105760          A=:REGBL (0)
105762          *2BANK
105763          MIN ZPREG;0/\0; GO FAR RETU
105766
105766   % COPY FROM REG.BLOCK BUFFER (RTBRB) TO DEBUGGER'S REG. BLOCK
105766   RRGBL: ZXREG
105767          *1BANK
105770          A=:REGBL (0)
105772          *2BANK
105773          AUPIN=:D; CALL DALTON
105776          A:=B=:BRG;X:="RTBRB"=:B
106002          *1BANK
106003          X:=REGBL(0)
106005          *LDF 0,B ;RDCR DT; 2BANK; STF 0,X   ; 1BANK;
106012          *LDF 3,B ;         2BANK; STF 3,X   ; 1BANK;
106016          *LDF 6,B ;         2BANK; STF 6,X   ; 1BANK;
106022          *LDF 11,B ;        2BANK; STF 11,X  ; 1BANK;
106026          *LDA 14,B;         2BANK; STA 14,X
106031          A:=BRG=:B
106033          CALL SINALTPIT
106034          MIN ZPREG;0/\0;GO FAR RETU
106037   *)FILL
106045
106045   INTEGER CLIST:=SEGN,SEGN
106047   INTEGER SVSTA,SAVT,SVCST,BRG
106053   INTEGER POINTER PCSTRI:=CSTRIN,PCPNT:=CPNT
106055
106055   PLREE: CALL FINDINDEX;GO FAR RETU
106057          A:=ZXREG
106060          *1BANK
106061          A=: REGBLO (CUIDX)
106063          *2BANK
106064          T:=ZAREG=:SAVT
106066          FOR X := 0 TO 20 DO            % COPY NAMESTRING
106072          AUPIN=:D; CALL DALTON          % FROM DEBUGGER (UPITN)
106075             T:= SAVT;    *LBYT          % TO
106077          CALL SINALTPIT                 %
106100             T:=PCSTRI; *SBYT          % CSTRING ON SYSTEM SEGMENT(DPIT)
106102             WHILE A >< ##'              %
106105          OD
106107          T:="5OPSEG" ;0=: RTREF.RSEGM; CALL M1MEXY
106113          A:="BFIELD";A:=:B;A=: BRG
106116          0=: PCPNT
106117          X:= "REECOMT";CALL CABLOOK;
106121          0=:PCPNT               % RESTORE COMMAND PROCESSOR POINTER
106122          IF A= 0 THEN           % FOUND IN REECOMT
106123                                 % T=SEGM NO; D= START ADDRESS
106123             IF A:=T><-1 THEN     % NOT 500 STANDARD DOMAIN
106127                A=:SEGN;A:=D=:SVSTA
106132                *1BANK
106133                T:=OLDSEGS (CUIDX);*2BANK
106136                0=:RTREF.RSEGM;CALL M1MEXY   % ACT1SEG= USER SEGM; RSEGM=0
106141                ARPIT=:D;CALL DALTON         % APT= RPIT
106144                "CLIST";*MON 2REEN           % MON REENT TO LINK OUT PAGES
106146                                             % FROM BACKGROUND SEGMENT
106146                CALL SINALTPIT
106147                *1BANK
106150                A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106155                A=:RTREF.RSEGM; CALL M1MEXY
106160
106160                AUPIN=: D; CALL DALTON
106163                *1BANK
106164                A:=SEGN;T:=SVSTA                    % WRITE SEGMENT NUMBER AND
106166                A=:DBRSEGM(CUIDX)                   % SAVE RSEGM FOR LATER STARTS
106170                X:=REGBLO (X)
106171                *2BANK
106172                *STT ,X 0; STA ,X 14                % START ADDRESS AND RSEGM TO DEBUGGER:
106174                CALL SINALTPIT
106175                A:=BRG =:B
106177                MIN ZPREG; 0/\0; GO FAR RETU
106202             FI
106202          FI
106202   %%%    ERRORS FROM ABLOOK:
106202          A=: D
106203          *1BANK
106204          A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106211          A=:RTREF.RSEGM; CALL M1MEXY
106214          A:=D
106215          IF A= -2 THEN % AMBIGUOUS
106220                A:="ER212"
106221          ELSE          % NO SUCH REENTRANT SUBSYSTEM
106222                A:=174  % ILLEGAL PARAMETER
106223          FI
106223          T:=BRG =:B
106225          GO FAR ERR
106226
106226   *)FILL
106252
106252   GETDSEG:
106252          X:=1   % START ON 1; INDEX 0 RESERVED RT-DEBUGGER
106253          DO WHILE X><MXSDBUGGER
106256             IF DBGPROGS(X)=RTREF GO SGFOUND
106262             X+1
106263          OD
106264          X:=1  % START ON 1; INDEX 0 RESERVED RT-DEBUGGER
106265          DO WHILE X><MXSDBUGGER
106270             IF DBGPROGS(X)=0 THEN RTREF=:DBGPROGS(X); GO SGFOUND FI
106275             X+1
106276          OD
106277          GO FAR RETU
106300   SGFOUND:
106300          *1BANK
106301          X=:CUIDX;*2BANK
106303          T:="SGNUM"+X; CALL M1MEXY; *1BANK
106307          T=:OLDSEG(X);0=:DBRSEGM(X)
106311          *2BANK
106312          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
106320          IF A=200 THEN T:=400 ELSE T:=200 FI
106326          A:=RTREF.RSEGM; *1BANK
106331          A=:DBUGSEG(CUIDX); T=:APTNO(X); *2BANK
106335          MIN ZPREG; 0/\0; GO FAR RETU
106340   *)FILL
106360
106360   RELDSEG: CALL FINDINDEX; GO FAR RETU
106362          0=:DBGPROGS(X)
106363          A:=CURPROG;CALL LAMENABLE
106365          MIN ZPREG; 0/\0; GO FAR RETU
106370
106370   PLAC1: CALL FINDINDEX; GO FAR RETU
106372          ZAREG=:FILNR; 0=:BLCKNO; 7=:NWRD
106377          "BUFFR"+B=:RWPAR(2)
106403          "RWPAR"+B; *MON 117
106406          IF A><0 THEN A=:ZAREG; GO FAR RETU FI
106411          GO PLAC2; *)FILL
106421
106421   PLAC2: 0=:RTREF.RSEGM; CALL GETDATAFIELD
106424          5BCOM; T:="BSTATE"; CALL XSTDFADDR
106427          T:=FILNR; X:="BUFFR"+B; CALL 2BDBRECOVER; GO ERET
106434          A:=0; MIN ZPREG; 0/\0
106437   ERET:  A=:ZAREG; CALL GETDATAFIELD
106441          5BUSER; T:="BSTATE"; CALL XSTDFADDR
106444          *1BANK
106445          A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106452          A=:RTREF.RSEGM; CALL M1MEXY
106455          GO FAR RETU
106456   *)FILL
106471
106471
106471   FINDINDEX: X:=0   % START ON 0; FINDINDEX ALSO USED BY RT-DEBUGGER
106472          DO WHILE X><MXSDBUGGER
106475             IF DBGPROGS(X)=RTREF THEN
106501                 *1BANK
106502                 X=:CUIDX
106503                 *2BANK
106504                 EXITA
106505             FI
106505             X+1
106506          OD; EXIT
106510   RETU:  GO MXRET
106511
106511   RBUS
106516   *"
"106516
106516   *"8MOLI
"106516   %==============================================================================
106516   %
106516   % MON LOGIN
106516   %            <LOG.DEV>       : LOGICAL DEVICE NUMBER OF THE TERMINAL
106516   %            <USER NAME>
106516   %            <PASSWORD>
106516   %            <PROJECT PASSWORD>
106516   %            <SUBSYSTEM NAME>
106516   %            <PASET PARAMETERS>
106516   %            <RETURNED STATUS>
106516   %
106516
106516   SUBR MLOGIN
106516
106516   DISP 21
106516          INTEGER AS1,AS2,AS3,AS4,AS5,AS6 % PARAMETER ADDRESSES.
106516          INTEGER POINTER LREG            % RETURN ADDRESS IN CMOVSTR.
106516          INTEGER SUBCNT=AS1              % NUMBER OF 16 BYTE PARTS OF SUBSYSTEM
106516          INTEGER SUBPNT=AS2              % POINTER TO SUBSYSTEM PART.
106516   PSID
106516
106516   CMOVSTR:
106516          T:=L=:"LREG"            % SAVE RETURN ADDRESS.
106520          T:=MLICPNT              % FIRST FREE BYTE IN BUFFER.
106521          *BLDA 00 DT             % K:=(FIRST BYTE IS RIGHT BYTE)
106522          T SHZ -1                % WORD DISPLACEMENT.
106523          X:=T+B                  % X POINTS TO FIRST BUFFER WORD.
106525          T:=21=:D                % MAX 21 BYTES IN EACH PARAMETER.
106527          *BSTA 170 DT            % DESTINATION STARTS ON RIGHT BYTE.
106530          D BONE 16               % SOURCE IS IN ALTERNATIVE PIT.
106531          CALL MLMOV              % MOVE BYTES (IN MICRO COMMON).
106532          "LREG"=:L               % RESTORE RETURN ADDRESS.
106534          MLICPNT+21=:MLIMXADDR   % MAX VALUE OF MLICPNT.
106537          DO WHILE X:=MLICPNT >< MLIMXADDR
106543              T:=B                % B IS BASE ADDRESS FOR BUFFER.
106544              *LBYT               % READ A CHARACTER FROM THE BUFFER.
106545              A/\177              % REMOVE PARITY.
106546              IF A=##' OR =15 GO OUT  % STOP AT ' OR CR.
106554              MIN MLICPNT         % INCREASE BUFFER POINTER.
106555          OD
106556          EXIT                    % ERROR EXIT IF MORE THAN 20(OCT) BYTES IN PARAMETER.
106557
106557   OUT:   A:=15; T:=B; *SBYT      % CR IS PARAMETER DELIMITOR.
106562          MIN MLICPNT             % INCREASE BUFFER POINTER.
106563          EXITA                   % OK: SKIP RETURN.
106564
106564   *)FILL
106566
106566   MLOGIN:CALL GET1
106567          MLEV; *MST PIE
106571          ZAREG+1=:D                              % ADDRESS OF SECOND PARAMETER.
106574          T:="AS1"+B                              % DESTINATION IN DF.
106576          A:=OLDPAG                               % USERS PITS.
106577          X:=6; K:="0"                            % 6 WORDS FROM USER TO DPIT.
106601          CALL MOVUS
106602          AS6=:MLIADDR                            % ADDRESS OF STATUS PARAMETER.
106604          D0; CALL LOGPH; IF A=0 OR D=0 GO EDEV   % FIND TERMINAL DF.
106611          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD GO EDEV % CHECK FOR TERMINAL OR TAD.
106617          IF X.RTRES><0 GO EOCCU                  % CHECK THAT TERM. IS FREE.
106621          X=:MLITERM                              % SAVE DF ADDRESS.
106622          IF UNAFLAG><0 AND RTRES><"STSIN" GO ESUNA   % SYSTEM UNAVAILABLE.
106630          MLISTRNG SH 1=:MLICPNT                  % BYTE DISPLACEMENT OF BUFFER.
106633          AS1; CALL CMOVSTR; GO ESTRNG            % USER NAME.
106636          AS2; CALL CMOVSTR; GO ESTRNG            % PASSWORD.
106641          AS3; CALL CMOVSTR; GO ESTRNG            % PROJECT PASSWORD.
106644          -4=:SUBCNT                              % COPY SUBSYSTEM IN UPTO 4 PARTS.
106646          AS4=:SUBPNT                             % START OF SUBSYSTEM.
106650          FOR SUBCNT DO
106650              CALL CMOVSTR                        % MOVE UPTO 20(OCT) BYTES, SKIP RETURN IF END.
106651              GO NEXT10                           % NORMAL RETURN: END NOT FOUND, RESET END FLAG.
106652              GO SUBEND                           % IF END FLAG SET, FINISH LOOP.
106653   NEXT10:    SUBPNT+10=:SUBPNT                   % NEXT PART OF SUBSYSTEM STRING.
106656          OD
106660          GO ESTRNG                               % IF STRING LONGER THAN 100(OCT) CHARS, THEN ERROR.
106661   SUBEND:                                        % END OF SUBSYSTEM STRING FOUND.
106661          AS5=:D; T:=MLIPASET+B                   % USER PARAMTERS.
106665          A:=OLDPAG; X:=5; K:="0"                 % MOVE 5 WORDS TO DPIT.
106670          CALL MOVUS
106671          MLICPNT=:MLIMXADDR                      % END OF BUFFER.
106673          MLISTRNG SH 1=:MLICPNT                  % START OF BUFFER.
106676          *IOF
106677          IF MLITERM.RTRES><0 GO XEOCCU           % RECHECK THAT TERM. IS FREE.
106702          T:="FLAGB"; CALL XGTDFADDR              % GET FLAGB FOR TERMINAL.
106704          A BONE 5MLGIN                           % SET MLOGIN FLAG.
106705          T:="FLAGB"; CALL XSTDFADDR              % SET FLAGB.
106707   *"8MOLI -8BACS
"106707          A:=X; *IRW MLEVB DX                             % ALLOCATE A PROGRAM FOR THIS TERM.
106711          "CMBABPROC"; *IRW MLEVB DP
106713          MLEV; *MST PID; ION
106716          GO ENOFREE; *IOF                                % IF SKIP RETURN: OK.
106720   *"8MOLI
"106720          CALL RTENTRY                        % START BACKGROUND PROGRAM.
106721          RTREF.STATUS BONE 5WAIT=:X.STATUS   % WAIT FOR RESULT OF MLOGIN.
106725          TTMR=:TMR; "RWAIT"; *IRW MLEVB DP   % WAIT MAX 100(OCT) SECONDS.
106731          MLEV; *MST PID
106733   RETU:  *ION
106734          X:=MLIADDR                          % ADDRESS OF STATUS PARAMETER.
106735          A:=MLIMSTATUS                       % STATUS IN DF.
106736          CALL USALTPIT                       % USERS ALT. PIT.
106737          A=:X.S0                             % RETURN THE STATUS.
106740          CALL SINALTPIT                      % DPIT.
106741          *IOF
106742          X:=RTREF; CALL BRELEASE             % RELEASE MLIDFIELD.
106744          GO RET                              % END OF MONITOR CALL.
106745   *)FILL
106766
106766   ESUNA: A:=-1; GO EFEL              % ALL ERRORS RETURN STATUS -1
106770   XEOCC:                             % TO HIDE THE REASEON FOR FAILURE.
106770   EOCCU: A:=-1; GO EFEL
106772   EDEV:  A:=-1; GO EFEL
106774   XPEND: A:=-1; GO EFEL
106776   ESTRNG:A:=-1; GO EFEL
107000   ENOFREE: A:=-1
107001   EFEL:  A=:MLIMSTATUS; GO RETU
107003
107003   RBUS
107003
107003   %======================================================================
107003   %      M L G T M O U T
107003   %      TIMEOUT SUBROUTINE FOR MON LOGIN
107003   %      CALLED BY TIMER IF NO RESPONSE FROM STARTED BACKGROUND PROGRAM.
107003   %
107003   SUBR MLGTMOUT
107003
107003   MLGTMOUT: -1=:MLIMSTATUS                       % TIMEOUT: LOGIN FAILED.
107005             0=:TMR                               % STOP THE TIMER.
107006             RTRES.STATUS BZERO 5WAIT=:X.STATUS   % RESTART THE WAITING PROGRAM.
107012             EXIT                                 % RETURN TO TIMER PROGRAM.
107013   RBUS
107013   *"
"107013
107013
107013   %==============================================================================
107013   %            T R E P P     (TREPP  MON 332)
107013   %
107013   %      MONITORCALL TO DISABLE/ENABLE AND READ TERMINAL REPPORT
107013   %
107013   %      ENTRY: T = LOGICAL DEVICE NUMBER ( 1: OWN TERMINAL BACKGROUND)
107013   %             A = FUNCTION  = 0: DISABLE TERMINAL-REPPORT
107013   %                           = 1: ENABLE  TERMINAL-REPPORT
107013   %                           = 2: READ    TERMINAL-STATUS
107013   %      ERROR RETURN: A = ERROR NUMBER
107013   %      SKIP  RETURN: FUNCTION 0: OK
107013   %                    FUNCTION 1: OK
107013   %                    FUNCTION 2: OK  A = STATUS
107013   %                                        BIT  0: 1 - TERMINAL LINE DEAD
107013   %                                        BIT  1: 1 - LOGOUT WAITING FOR MON 0
107013   %                                        BIT  2: 1 - OVERRUN IN INPUT BUFFER
107013   %                                        BIT  3: 1 - PARITY ERROR IN INPUT
107013   %                                        BIT  4: 1 - FRAMING ERROR IN INPUT
107013   %      BITS USED IN FLAGB:
107013   %           BIT  0: 5TLREP
107013   %           BIT   : 5LOGOUT
107013   %           BIT 17: 5LSTA
107013   %      BITS USED IN TINFO:
107013   %           BIT 17: 5BFUL   - READ AND CLEAR
107013   %           BIT 16: 5PAER   - -----"-------
107013   %           BIT 15: 5FRER   - -----"-------
107013
107013   SUBR TREPP
107013   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG
107015   INTEGER WNDADDR:=WNDBF*2+174000
107016   TREPP: CALL GET0; MLEV; *MST PIE
107021          IF BACKGROUND><0 AND ZTREG=1 THEN          % BACKGROUND OWN TERMINAL
107027              IF PBCHFLAG=1 GO DUMRE                 % FAKE ALWAYS OK IF BATCH
107033              A:=PTTNO                               % LOG DEV NO OF OWN TERMINAL.
107034          ELSE                                       % RT OR BACKGROUND DEV SPEC.
107035             IF ZTREG/\177700=100 GO ILLDV           % FILE IS ILLEGAL
107042             A:=ZTREG                                % LOG DEV NO FROM PARAMETER.
107043          FI
107043          CALL LOGPH; IF A=0 GO ILLDV                % FIND DATAFIELD
107045          IF A.RTRES><RTREF GO NRESV                 % DEVICE MUST BE RESERVED
107052          IF X.TYPRING BIT 5SPLITDF THEN             % SPLIT DATAFIELD
107055             CALL XSETBFPAGE; K:=1                   % USE BUFFER WINDOW
107057          ELSE
107060             K:="0"                                  % NOT SPLIT DATAFIELD
107061          FI
107061          IF X.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN GO ILLDV FI
107067          IF ZAREG=0 THEN X.FLAGB BZERO 5TLREP=:X.FLAGB; GO DUMRE FI
107075          IF A=1 THEN X.FLAGB BONE 5TLREP=:X.FLAGB; GO DUMRE FI
107104          IF A=2 THEN; *IOF
107110             IF K THEN       % SET WNDBF AGAIN TO BE SURE TO AVOID PAGE FAULT
107112                X=:D; CURPROG.BUFWINDOW
107115                T:=0; X:=WNDADDR; *STATX 10           % PHYS PAGE TO PIT
107120                A:=142000; *STATX                     % PROTECT BITS TO PIT
107122                D=:X
107123             FI
107123             A:="0"; T:=X.TINFO
107125             IF T BIT 5BFUL THEN T BZERO 5BFUL; A BONE 2 FI
107131             IF T BIT 5PAER THEN T BZERO 5PAER; A BONE 3 FI
107135             IF T BIT 5FRER THEN T BZERO 5FRER; A BONE 4 FI; T=:X.TINFO; *ION
107143             IF T:=X.FLAGB BIT 5LOGOUT THEN A BONE 1 FI    % LOGOUT WANTED?
107147             IF T BIT 5LSTA THEN A BONE "0" FI             % LINE DEAD?
107152             GO RERET
107153          FI
107153          GO ILLFU
107154
107154   DUMRE: A:="0"
107155   RERET: MIN ZPREG; 0/\0
107157   RETU:  A=:ZAREG; GO RET
107161   NRESV: A:=5; GO RETU                   % DEVICE NOT RESERVED
107163   ILLDV: A:=240; GO RETU                 % ILLEGAL DEVICE TYPE
107165   ILLFU: A:=201; GO RETU                 % ILLEGAL FUNCTION CODE
107167   RBUS
107202
107202   %=======================================================================
107202   %  11.34     G D E V T Y
107202   %
107202   %  MONITOR CALL TO GET DEVICE-TYPE AND ATTRIBUTES (MON 263)
107202   %
107202   %  ENTRY:        T-REG:   DEVICE NUMBER
107202   %                A-REG:   0=INPUT, 1=OUTPUT
107202   %  SKIP RETURN:  T-REG:   DEVICE TYPE
107202   %                A&D REG: DEVICE ATTRIBUTES
107202   %  RETURN:       A-REG:   ERROR CODE
107202   %
107202   %  DEVICE TYPES RETURNED IN T-REG
107202   %      0 - UNSPECIFIED
107202   %      1 - TERMINAL
107202   %      2 - BACKGROUND ACCESS DEVICE (BAD)
107202   %      3 - COMMUNICATION CHANNEL
107202   %      4 - INTERNAL BLOCK DEVICE
107202   %      5 - FLOPPY-DISK
107202   %      6 - MAG-TAPE
107202   %      7 - MASS-STORAGE-FILE
107202   %
107202   %  ATTRIBUTES  RETURNED IN A&D REG
107202   %     BIT  0: INBT/OUTBT ALLOWED
107202   %     BIT  1: CONCT ALLOWED
107202   %     BIT  2: IOSET ALLOWED
107202   %     BIT  3: BLOCK CALLS ALLOWED
107202   %     BIT  4: CLEAR DEV ROUTINE AVAILABLE
107202   %     BIT  5: NO RESERVATION NECESSARY
107202   %     BIT  6: COSMOS REMOTE OPEN FILE
107202   %     BIT  7: NN-CHANNEL USED FOR REMOTE OPEN
107202
107202   SUBR GDEVTY
107202   SYMBOL 9BTERM=1,9BBAD,9BCOM,9BIBDV,9BFLOP,9BMT,9BRFILE            % TYPES
107202   SYMBOL AIOBT,ACONCT,ATISET,AM144,ACLDV,ANORES,ACOSOP,ANNOP,ANOTS,AMTAD,AREMC  % ATTRIBUTES
107202   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG, PTTIF:=TTIFIELD
107205
107205   GDEVTY:
107205          CALL GET0; MLEV; *MST PIE
107210          IF BACKGROUND><0 AND ZTREG=1 THEN
107216             IF PBCHFLAG=0 THEN
107220                PTTNO
107221             ELSE
107222                X:=PTTIF
107223                IF ZAREG=0 THEN X.RIFIL ELSE X.DFOPP.ROFIL FI
107231             FI
107231          ELSE
107232             ZTREG
107233          FI
107233          CALL LOGPH
107234          IF T:=ZAREG><0 THEN D=:A FI
107240          IF A=0 GO ERR                             % NO SUCH LOGICAL UNIT
107241          IF A.TYPRING BIT 5TERM THEN T:=9BTERM; GO ATRIB FI
107247          IF A BIT 5BAD   THEN T:=9BBAD;   GO ATRIB FI
107253          IF A BIT 5IBDV  THEN T:=9BIBDV;  GO ATRIB FI
107257          IF A BIT 5FLOP  THEN T:=9BFLOP;  GO ATRIB FI
107263          IF A BIT 5MT    THEN T:=9BMT;    GO ATRIB FI
107267          IF A BIT 5RFILE THEN T:=9BRFILE; GO ATRIB FI
107273          T:=0
107274   ATRIB: T=:ZTREG:=0
107276          IF A BIT 5RFILE THEN
107300             A=:D; IF X.OFFLG BIT 5RCFIL THEN T BONE ACOSOP FI
107305             IF A BIT 5REMPO THEN T BONE ANNOP FI
107310             D=:A
107311          FI
107311          IF A BIT 5IOBT  THEN T BONE AIOBT FI
107314          IF A BIT 5CONCT THEN T BONE ACONCT FI
107317          IF A BIT 5ISET  THEN T BONE ATISET FI
107322          IF A BIT M144B  THEN T BONE AM144 FI
107325          IF A BIT 5NORES THEN T BONE ANORES FI
107330          IF A NBIT 5TERM  THEN
107332             IF A BIT 5CLDV  THEN T BONE ACLDV FI
107335          ELSE
107336             T=:D
107337             CALL CHNOTS; GO C1; D BONE ANOTS
107342   C1:       CALL CHMTAD; GO C2; D BONE AMTAD
107345             T:=X.TDFPHPAGE SH -6; X:=X.TDFLGADDR; *AAX MTFLA; LDATX
107352             IF A BIT 5MTRC THEN D BONE AREMC FI
107355   C2:       T:=D
107356          FI
107356   UT:    T=:ZDREG; 0=:ZAREG; MIN ZPREG; 0/\0; GO RET
107363   ERR:   33=:ZAREG; GO RET
107366   RBUS
107374
107374
107374   %=============================================================================
107374   %            G E T X M     (MON 334)
107374   %                      A : ERROR CODE.
107374   %                      X : DATA ADDRESS.
107374   %
107374   SUBR GETXM
107374   DISP 0; INTEGER SVACTSG=D0,SVRSGM=D1; PSID
107374   GETXM: CALL GET0
107375          X:=RTREF; OLDPAG=:D; ZXREG; T:=100
107402          CALL CHLIM; GO FAR ERR                       % CHECK USER'S BUFFER ADDRESS
107404          RTREF.ACT1SEG=:SVACTSG; X.RSEGM=:SVRSGM      % SAVE USER'S SEGMENT
107411          MLEV; *MST PIE
107413          T:=ECODSEG; CALL M1MEXY                      % GET ERROR-PROGRAM SEGMENT
107415          A:=ZAREG
107416          T:="ASPIT"=:D; CALL DALTON                   % TO ACCESS ERRORTEXT
107421          T:="CBUFF"=:D
107423          IF A<<ER0 THEN
107426             ERSTB(A)
107430          ELSE IF A<<ERM THEN
107434             A-ER0
107435             ERTAB(A)
107437          ELSE IF A>>=RX000 AND A<<RXMAX THEN
107446              A-RX000
107447              XRTAB(A)
107451          ELSE IF A>>=1000 AND A<<1100 THEN
107460              A-1000=:X
107462              CALL FAR GET5M
107463              ND5T1(X)
107464          ELSE IF A>>=2000 AND A<<2400 THEN
107473              A-2000=:X
107475              CALL FAR GET5M
107476              ND5T2(X)
107477          ELSE IF A>>=7600 AND A<<7652 THEN
107506              A-7600=:X; T:=D; "T5TRP"=:D; 11=:L; *MOVAN
107516              T=:D; TRAPT(X)
107520          ELSE IF A>>=101400 AND A<<101500 THEN
107527              A-101400=:X; T:=D; "TOCTM"=:D; 11=:L; *MOVAN
107537              T=:D; OCTOT(X)
107541          ELSE IF A>>=150700 AND A<<151000 THEN
107550              A-150700=:X; T:=D; "T5ERR"=:D; 11=:L; *MOVAN
107560              T=:D; NDIXT(X)
107562          ELSE
107563              ERTAB(0)
107565          FI FI FI FI FI FI FI FI
107565          GO L1; *)FILL
107627   L1:    D=:T:=A; "CBUFF+77"-T=:L; *MOVAN                % COPY ERROR-MESSAGE
107635          CALL SINALTPIT
107636          SVRSGM=:RTREF.RSEGM; T:=SVACTSG; CALL M1MEXY    % RESTORE USER'S SEGMENT
107643          ##'=:D; T:="CBUFF"                              % COUNT NUMBER OF BYTES IN ERROR MESSAGE
107646          X:=0; 176=:L; *1BANK
107652          DO
107652              *LBYT
107653          WHILE A><D AND X<L
107657              X+1
107660          OD
107661          *2BANK
107662          A:=X+1 SHZ -1+1=:X                  % X:= NUMBER OW WORDS IN ERROR MESSAGE.
107666          T:=ZXREG                            % POINTER TO USER DATA
107667          OLDPAGE=:D; CALL DALTON
107672          "CBUFF"=:D; X=:L; *MOVNA            % MOVE TO USER'S BUFFER
107676          CALL SINALTPIT
107677          MIN ZPREG; 0/\0; GO RET
107702
107702   ERR:   153=:ZAREG; GO RET                                  % ILLEGAL ADDRESS REFS IN MONCALL
107705   *)FILL
107714   INTEGER ARRAY CBUFF(100)                                   % BUFFER FOR ERROR-MESSAGE
110014
110014   GET5M: IF A>>=2146 AND A<<2300 THEN
110022              IF A<<2165 THEN "TACCP"
110026              ELSE IF A<<2171 THEN "T5TMO"
110033              ELSE IF A<<2200 THEN "T5ERR"
110040              ELSE IF A<<2300 THEN "TMICP"
110045              FI FI FI FI
110045          ELSE
110046              "T5ERR"
110047          FI
110047          T:=D; A=:D; A:=11:=:L; *MOVAN
110054          T=:D; A=:L
110056          EXIT
110057   RBUS
110070
110070   %=========================================================
110070   %         C P L A M
110070   %   CHECK IF A PHYSICAL PAGE IS WITHIN A CONNECTED LAMU
110070   %   RETURNS WITH INTERRUPT ON
110070   %   ENTRY:    T = PHYSICAL PAGE
110070   %             A = RT DESCR
110070   %   EXIT:     NOT WITHIN A CONNECTED LAMU
110070   %   EXIT+1:   OK.
110070
110070   SUBR CPLAM
110070
110070   *"8LAMU
"110070   INTEGER PPAG                 % PHYSICAL PAGE
110071   INTEGER CACL                 % CURRENT ACTIVE LAMU ELEMENT
110072   INTEGER SAVX
110073   INTEGER LC                   % LOOP COUNTER
110074   *"
"110074
110074   CPLAM:
110074   *"8LAMU
"110074     *IOF
110075     X=:SAVX; T=:PPAG:=5RTSIZE; A-RTSTART=:D:=0; *RDIV ST
110104     A*GNLPRT*ALMSZ+LAMACT=:CACL; 0=:LC
110111     FOR LC TO GNLPRT-1 DO
110116           A*ALMSZ+CACL=:X; T:=LAMBANK; *LDATX
110123           IF A >< 0 THEN
110124              IF A > 0 THEN A*LDTSZ+LAMDT
110130              ELSE A-*SDTSZ+SYLDT FI A=:X
110135              *LDDTX LMPP
110136              D+A-1
110140              IF A <<= PPAG  AND D >>= T THEN
110145                  L+1; GO CHLRE
110147              FI
110147           FI
110147     OD
110153   CHLRE: X:=SAVX; *ION
110155   *"
"110155          EXIT
110156   RBUS
110167
110167   %==============================================================================
110167   %            E X A B S       (MON 335)
110167   %
110167   % ENTRY:     X=WORKING AREA
110167   %            B=PARAMETER LISTE
110167   %
110167   SUBR EXABS
110167
110167   DISP 0; TRIPLE TRIP1=ZPREG,TRIP2=ZAREG,TRIP3=ZSREG; PSID
110167
110167   INTEGER SVX=?
110167
110167   EXABS: X=:SVX; X.ZTREG; CALL LOGPH; IF A=0 GO ERR          % CHECK DATAFIELD
110173          IF SVX.OLDPAGE NBIT "1" THEN
110177             IF BACKGROUND=0 OR "BFIELD".PASSTYPE><2 GO ERR   % NOT USER SYSTEM
110206          FI
110206          MLEV; *MCL PIE
110210          FOR X:="FPL3ABS" STEP A3DFSIZE TO "LPL3ABS"-A3DFSIZE DO % FIND PARAMETER FIELD
110215             IF X.RTRES=0 OR A=RTREF GO FOUND
110222          OD
110224          IF X.RTRES=0 THEN X=:B:="DUMMY"; CALL BRESERVE; FI  % RESERVE QUEUEING SEMAPHORE FOR DUMMY
110231          X:=RTREF; CALL FREXQU; CALL TOWQU                   % WAIT FOR ABSTR PARAMETER LISTE
110234          SVX=:B; ZPREG-1=:ZPREG; GO RETSTUPR; *)FILL
110255
110255   ERR:   X:=SVX=:B; -1=:ZAREG; GO RETSTUPR                   % OPERATION REJECTED
110262
110262   INTEGER SVX
110263   FOUND: X=:B:=RTREF; CALL BRESERVE                          % RESERVE ABSTR PARAMETER LISTE
110266          IF A<0 THEN CALL ERRFATAL FI; X:=SVX
110271          TAD:=X.TRIP1=:TRIP1:=X.TRIP2=:TRIP2:=X.TRIP3=:TRIP3
110277          X:=:B=:SVX:=RTREF; CALL BRELEASE                    % RELEASE ORIGINAL WORKING FIELD
110303          SVX=:B; MLEV; *MST PIE
110307          X:=ZAREG:=:B; CALL GETXABS; MLEV; *MST PIE          % GET PARAMETERS
110314          IF BACKGROUND >< 0 THEN
110316             A3MEM SHZ 6; A=:T:=RTREF; CALL CPLAM; GO ERR     % CHECK WITHIN LAMU
110324          FI
110324          T:=ZTREG; "A3PLIST"+B; *MON 2ABST
110330          A=:ZAREG; X:=A3RETADDR; A3NWRD; CALL USALTPIT
110334          AD=:X.DS0; CALL SINALTPIT                           % RETURN LAST PARAMETER
110336          MLEV; *MCL PIE
110340          IF "LPL3ABS".RTRES="DUMMY" THEN
110345             IF X.BWLINK><X THEN
110350                X:=:B; X=:SVX:=A; CALL FRWQU; CALL TOEXQU; SVX=:B
110357             FI
110357          FI; X:=RTREF; CALL BRELEASE
110361          GO RET
110362
110362   RBUS
110402
110402   %==============================================================================
110402   %      ( R )      E L O N     E L O F
110402
110402   % MONITOR CALLS TO TURN ON OFF DELAYED ESCAPE HANDLING
110402   %
110402   % ELON  (ELON  - MON 302)   - NORMAL  ESCAPE/LOCAL DETECTION
110402   % ELOF  (ELOFF - MON 303)   - DELAYED ESCAPE/LOCAL DETECTION
110402   SUBR ELON,ELOF,T2P07
110402   INTEGER POINTER TTIF:=TTIFIELD
110403   ELON:  CALL GET0
110404          IF TTIF=0 THEN 33; GO RETU; FI
110410          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110416             240; GO RETU
110420          FI
110420          IF X.FLAGB BIT 5WLOC THEN
110423                IF A BIT 5LCHAR THEN
110425                   X.LUSADD=:ZPREG        % RETURN IN LOCAL CHAR HANDLING
110427                   GO ESON
110430                FI
110430          FI
110430          IF A BIT 5WESC THEN
110432                X:=:B; *IOF               % ESCAPE RESPONSE IF TAD
110434   T2P07:       CALL CBRERSP; 0/\0; *ION
110437                X:=:B
110440                IF X.FLAGB BIT 5USESC THEN
110443                   X.EUSADD=:ZPREG        % RETURN IN USER ESCAPE HANDLING
110445                   GO ESON
110446                ELSE
110447                   "XBRTWT"               % SYSTEM ESCAPE HANDLING
110450                   *IOF; IRW MLEVB DP
110452                   MLEV; *MST PID; MST PIE; ION
110456                FI
110456          FI
110456          MIN ZPREG; 0/\0
110460   ESON:  X.FLAGB BZERO 5ESCLOFF; GO OUT
110463
110463   ELOFF: CALL GET0; IF TTIF=0 THEN 33; GO RETU; FI
110470          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110476             240; GO RETU
110500          FI
110500          X.FLAGB BONE 5ESCLOFF; MIN ZPREG; 0/\0; GO OFOUT
110505   OUT:   A BZERO 5WLOC BZERO 5WESC
110507   OFOUT: A=:X.FLAGB; A:=0
110511   RETU:  A=:ZAREG; GO RET
110513   RBUS
110520
110520   %==============================================================================
110520   %      ( R )      E L O F U   D L O F U
110520
110520   % MONITOR CALLS TO ENABLE/DISABLE LOCAL FUNCTION
110520   %
110520   % ELOFU - MON 276   - ENABLE  LOCAL FUNCTION
110520   % DLOFU - MON 277   - DISABLE LOCAL FUNCTION
110520   SUBR ELOFU,DLOFU
110520   INTEGER POINTER TTIF:=TTIFIELD
110521   ELOFU: K:=1; GO FELLS
110523   DLOFU: K:="0"
110524   FELLS: CALL GET0
110525          IF TTIF=0 THEN 33; GO RETU; FI
110531          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110537             240; GO RETU
110541          FI
110541          IF K THEN
110543             ZAREG=:X.LUSADD; *IOF
110546             X.FLAGB BONE 5LCHAR=:X.FLAGB; *ION
110552          ELSE
110553             *IOF
110554             X.FLAGB BZERO 5LCHAR BZERO 5WLOC=:X.FLAGB; *ION
110561          FI
110561          MIN ZPREG; 0/\0; A:=0
110564   RETU:  A=:ZAREG; GO RET
110566   RBUS
110571
110571   %==============================================================================
110571   %            E U S E L   D U S E L
110571
110571   % MONITOR CALLS TO ENABLE/DISABLE USER ESCAPE HANDLING
110571   %
110571   % EUSEL - MON 300   - ENABLE  USER ESCAPE HANDLING
110571   % DUSEL - MON 301   - DISABLE USER ESCAPE HANDLING (NORMAL SINTRAN MODE)
110571   SUBR EUSEL,DUSEL
110571   INTEGER POINTER TTIF:=TTIFIELD
110572   EUSEL: K:=1; GO FELLS
110574   DUSEL: K:="0"
110575   FELLS: CALL GET0
110576          IF TTIF=0 THEN 33; GO RETU; FI
110602          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110610             240; GO RETU
110612          FI
110612          IF K THEN
110614             ZAREG=:X.EUSADD; *IOF
110617             X.FLAGB BONE 5USESC=:X.FLAGB; *ION
110623          ELSE
110624             *IOF
110625             X.FLAGB BZERO 5USESC BZERO 5WESC=:X.FLAGB; *ION
110632          FI
110632          MIN ZPREG; 0/\0; A:=0
110635   RETU:  A=:ZAREG; GO RET
110637   RBUS
110642
110642   %=======================================================================
110642   %            I B R S I Z
110642   %
110642   % MONITOR CALL TO RETURN NUMBER OF CHARACTERS IN THE INPUT-BUFFER
110642   % IF BREAK STRATEGY APPLIES TO THE DEVICE, NUMBER OF CHARACTERS
110642   % UNTIL BREAK CONDITION IS ALSO RETURNED.
110642   % MON 313
110642   % ENTRY:       T = DEVICE-NUMBER
110642   % SKIP-RETURN: A = NUMBER OF CHARACTERS IN BUFFER
110642   %              X = BREAK CHARACTER NUMBER
110642   % NOSKIP:      A = ERROR CODE
110642
110642   SUBR IBRSIZ,T2P06
110642   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG
110644   INTEGER BREG=?,BCOUNT=?,BHENTE=?,BBUFS=?
110644   IBRSIZ:CALL GET0
110645          CALL GZTREG; GO FAR ERR; IF A=0 GO FAR ERR
110651          A:=:B=:BREG
110653          IF TYPRING BIT 5TERM THEN; *IOF           % TERMINAL
110657             B=:X; CALL XSETBFPAGE; X=:B
110662             0=:BCOUNT
110663             IF BRKTAB><0 THEN                                          % BREAK APPLIES
110665                IF BHOLD><0 THEN
110667                   IF DFLAG NBIT 5ECHO THEN                             % PAST BREAK IN DRIVER
110672                      HENTE=:BHENTE
110674                      IF RSISTE=-1 THEN                                 % HENTE PAST FIRST BREAK
110700   CHCHR:                1=:BCOUNT
110702                         A:=B/\176000+BUFST=:BBUFS
110706                         FOR X:=BCOUNT TO BHOLD DO; X=:BCOUNT           % SEARCH FOR BREAK
110713                            T:=BBUFS; X:=BHENTE
110715                            *LBYT
110716                            X+1; IF X=MAX THEN X:=0 FI; X=:BHENTE
110724                            X:=BRKTAB; CALL VSXGETBIT; IF A<0 GO RETTR
110727                         X:=BCOUNT; OD
110732                         0=:BCOUNT
110733                         IF BRKMAX><0 THEN
110735                            IF BHOLD+NCBRK>=BRKMAX THEN
110742                               BRKMAX-NCBRK=:BCOUNT
110745                            FI
110745                         FI
110745                      ELSE
110746                         IF BHENTE=RSISTE GO CHCHR
110752                         DO                                             % BREAK FROM DRIVER
110752                            A+1; IF A=MAX THEN A:=0 FI                  % FIND NUMBER
110757                            MIN BCOUNT; IF A=RSISTE GO RETTR
110763                         OD
110764             FI;FI;FI;FI
110764   RETTR:    A:=BHOLD
110765             GO RETU; *)FILL
110774
110774   INTEGER BREG,BCOUNT,BHENTE,BBUFS
111000
111000          FI
111000          IF TYPRING BIT 5BAD THEN                  % TAD
111003              B=:X; BREG=:B; CALL XISWTAD
111007   T2P06:     GO BISIZ; 0/\0                        % RETURN IN BISIZ IF TAD INCLUDED
111011          FI
111011          IF TYPRING BIT 5IOBT THEN
111014             0=:BCOUNT; A:=BHOLD; GO RETU
111017          FI
111017
111017   ERRB:  BREG=:B
111021   ERR:   240=:ZAREG; GO RET
111024   RETU:  T:=BREG=:B; T:=BCOUNT
111027          A=:ZAREG; T=:ZXREG; MIN ZPREG; 0/\0; GO RET
111034   RBUS
111040
111040
111040   *"8UDMA+8VICO
"111040   SUBR UDMA
111040   %------------------------------------------------------------------
111040   % LEVEL 1  PON, ION  RING 2
111040   % ENTRY: X = WORKING FIELD  (IN OUTPUT DATAFIELD)
111040   %        B = PARAMETER LIST
111040   %------------------------------------------------------------------
111040     DISP 20; INTEGER UFUNC; PSID        % FUNCTION CODE
111040     DISP 21; INTEGER UCORA; PSID        % ADDRESS TO USER BUFFER
111040     DISP 22; INTEGER UPA1H
111040              INTEGER UPA1L
111040         DOUBLE UPAR1=UPA1H; PSID        % INPUT PARAMETER (LENGTH)
111040     DISP 24; INTEGER UOUTD; PSID        % OUTPUT DATAFIELD HAS ABSTR PARAMETER LIST
111040     DISP 25; INTEGER UPIOD; PSID        % PIO OUTPUT DATA
111040     DISP 26; INTEGER URETW; PSID        % RETURN PARAMETER ADDRESS
111040     DISP 30; INTEGER UMAXW; PSID        % LOOP COUNTER WHEN COPYING DATA TO/FROM USER
111040     DISP 31; INTEGER UBANK;             % MOST SIGNIFIKANT BUFFER ADDRESS
111040              INTEGER UBADR;             % LEAST SIGNIFIKANT BUFFER ADDRESS
111040         DOUBLE UBUFF=UBANK; PSID        % FULL BUFFER ADDRESS
111040     DISP 35; INTEGER UFLAG; PSID        % USER FUNCTION FLAG
111040       SYMBOL BTUS=0            % COPY BUFFER TO USER
111040       SYMBOL BFUS=1            % COPY BUFFER FROM USER
111040       SYMBOL RETU=2            % RETURN PARAMETER TO USER
111040       SYMBOL DIRT=3            % DIRECT TRANSFER TO/FROM RT-PROG
111040       SYMBOL NRER=4            % NOT RETURN ERROR 171 (FOR READ STATUS)
111040       SYMBOL PIOI=5            % PIO IN PIO DATA IN 1 WORD BUFFER
111040       SYMBOL PIOO=6            % PIO OUT PIO DATA IN 1 WORD BUFFER
111040   DISP  0; DOUBLE POINTER DP2=P2; PSID
111040   DISP 7                     % ABSTRANS PARAMETER LIST IN OUTPUT DATAFIELD
111040       INTEGER POINTER FUNCP          % / *+4
111040       DOUBLE  POINTER MEMOP          % / *+4
111040       INTEGER POINTER BLOCP          % / *+5
111040       DOUBLE  POINTER DATP           % / *+5
111040
111040   PSID
111040   %---------------------------------------------------------------------
111040   % LOCAL SUBROUTINE FOR COPYING DATA TO/FROM DEVICE BUFFER FROM/TO USER ARRY
111040   %---------------------------------------------------------------------
111040   DTTU:  K:="0"; GO DTF
111042   DTFU:  K:=1
111043   DTF:   A:=L=:"MCLRG"; OLDPAGE=:D;     OFLCK; CALL XLOCK
111051          T:=UBANK; X:=UBADR; UCORA; CALL DBTRANS
111055          T:=UMAXW; * BSKP IF ZRO SSK; SWAP SX DA
111060          CALL COPYB; OFLCK; CALL XUNLOCK;
111063          GO MCLRG              % EXIT
111064   *)FILL
111071
111071   UDMA:
111071          CALL GETUD;  % GET PARAMETERS B = WORKING AREA
111072
111072          ZTREG; CALL LOGPH; IF A= 0 GO FAR EE033;
111076          D=:T; T=:UOUTD;    % SAVE OUTPUT DATAFIELD FOR ACCESSING ABSTR PARAMETER LIST
111100          IF A.TYPRING NBIT M144B GO FAR EE240          % UDMA LEGAL ON THIS DEVICE ?
111104          MLEV; *MST PIE;
111106          IF BACKGROUND >< 0 THEN                   % BACKGROUND
111110              X:=B+5REG;     *LRB BLEVB
111113              X:="ESCBLOCK"; *SRB BLEVB
111115              A:=B=:CMDFFIELD
111117          FI
111117
111117          "0"=:D
111121          IF UFUNC=0 THEN
111123             D BONE BTUS; D BONE RETU
111125            ELSE IF A = 1 THEN
111131                 D BONE BFUS
111132              ELSE IF A = 2  OR =  3 THEN
111141                  D BONE DIRT
111142                ELSE IF A = 20 OR = 24 THEN
111151                     D BONE RETU; D BONE NRER
111153                  ELSE IF A = 54 OR= 56 THEN
111162                       D BONE PIOI
111163                    ELSE IF A = 55 OR= 57 THEN
111172                         D BONE PIOO;
111173                      ELSE IF A = 7 OR = 62 THEN
111202                           D BONE RETU;
111203                        ELSE IF A=21 OR=64 OR=65 OR=70 THEN % FUNCTION OK
111220                          ELSE GO FAR EE174; *)FILL
111232           FI FI FI FI FI FI FI FI
111232
111232          A:=D=:UFLAG
111234          T:=OLDPAG=:D; X:=RTREF
111237          IF A BIT BTUS OR BIT BFUS OR BIT PIOI THEN          % CHECK USER ADDRESS SPACE
111245             IF A BIT PIOI THEN
111247                T:=1
111250             ELSE
111251                T:=UPA1L;
111252             FI
111252             A:=UCORA;  CALL CHLIM; GO FAR EE153;
111255          FI
111255          IF UFLAG BIT RETU THEN
111260             A:="IRETW"; T:=2; CALL CHLIM; GO FAR EE153;
111264          FI
111264
111264          IF UFLAG BIT BTUS OR BIT BFUS OR BIT DIRT THEN
111273              OFLCK; CALL XLOCK
111275              IF BACKGROUND >< 0 GO GBUF                  % RT PROGRAM
111277                 A:=RTREF+"ACT1SEG"=:T; X:=OLDPAG; AD:=UPAR1
111304                 UCORA; CALL CXCFR; GO GBUF;      % CHECK IF SEGMENT IS FIXC'ED
111307                 T:=UFLAG BZERO BTUS; T BZERO BFUS=:UFLAG % NO BUFFER TO/FROM USER
111313                 GO SBU; *)FILL
111324   GBUF:      IF UFLAG BIT DIRT GO EE241
111327              UPAR1;IF A >< 0 GO EE174; A:=D=:UMAXW       % DEVICE BUFFER << 64K
111333              T:=ZTREG; CALL GRBUFF; GO EE131
111336   SBU:       X:=UOUTD; X:=:B; AD=:MEMOP; B:=X; AD=:UBUFF
111343              OFLCK; CALL XUNLOCK;
111345          FI
111345          IF UFLAG BIT BFUS THEN CALL FAR DTFU FI      % DATA FROM USER TO BUFFER
111351
111351          IF UFLAG BIT PIOO OR A BIT PIOI THEN
111356            A:=UPIOD=:D; A:=UPA1L; AD=:UPAR1           % UCLIN BIT MASK + PIO DATA
111362          FI
111362          X:=UOUTD; X:=:B
111364          X.UFUNC=:FUNCP; X.UPAR1=:DATP; B:=:X
111371          T:=ZTREG;  A:=X; * AAA FUNCP; MON 2ABST       %  ABSTRANS
111375
111375          IF A < 0 AND UFLAG NBIT NRER THEN "171"  % RETURN ERRORCODE
111402          ELSE "0" FI
111404          A=:ZAREG
111405          IF UFLAG BIT RETU OR A BIT PIOI THEN        % RETURN PARAMETER OR DATA
111412            X:=UOUTD; X:=:B; AD:=DATP; B:=X           % GET RET.PARAM FROM ABSTR
111416            T:=UFLAG
111417            IF T BIT PIOI THEN X:=UCORA ELSE X:=URETW FI
111424            CALL USALTPIT
111425            IF T BIT PIOI THEN                        % RETURN ONE WORD DATA
111427               A:=D=:X.S0;
111431            ELSE                                      % RETURN DOUBLE WORD PARAM
111432               AD=:X.DS0;
111433            FI
111433            CALL SINALTPIT
111434          FI
111434          IF UFLAG BIT BTUS THEN  CALL FAR DTTU FI    % COPY DATA TO USER BUFFER
111440
111440          IF UFLAG BIT BFUS OR BIT BTUS THEN
111445            OFLCK; CALL XLOCK
111447            T:=ZTREG; CALL RRBUF; CALL ERRFATAL % RELEASE BUFFER
111452            OFLCK; CALL XUNLOCK
111454          FI
111454          GO FINE
111455   EE033: "033"; GO ERR                            % NO SUCH LOGICAL UNIT
111457   EE131:  OFLCK; CALL XUNLOCK; "131"; GO ERR       % NO MORE BUFFER SPACE
111463   EE153: "153"; GO ERR                            % ILLEGAL ADDRESS REF.
111465   EE174: "174"; GO ERR                            % ILLEGAL PARAMETER
111467   EE240: "240"; GO ERR                            % ILLEGAL DEVICE TYPE
111471   EE241:  OFLCK; CALL XUNLOCK; "241";              % SEGMENT NOT CONTIGUOSLY FIXED
111474   ERR:    A=:ZAREG;
111475   FINE:   GO RET
111476   RBUS
111513
111513   SUBR UDTMO
111513   UDTMO:
111513   %===================================================================
111513   %      TIMEOUT ROUTINE FOR UNIVERSAL DMA INTERFACE LEVEL 1
111513   %===================================================================
111513         * LDA  (UD11T          % TIME OUT ROUTINE ON LEVEL 11
111514         * IRW   130 DP
111515         * COPY  SB DA
111516         * IRW   130 DB         % SET BREG TO DATAFIELD
111517         * LDA   (4000
111520         * MST   PID            %ENABLE LEVEL 11
111521         * EXIT                 % RETURN
111522   RBUS
111524
111524   *"8F5UD
"111524   %============================================================================
111524   %            U D R x x
111524   %
111524   % RT-PROGRAMS FOR FAST MON UDMA FROM ND-500
111524   %
111524   @ICR
111524   SUBR URT01,URT02,URT03,URT04,URT05,URT06,URT07,URT08,
111524        URT09,URT10,URT11,URT12,URT13,URT14,URT15,URT16,UFELL;
111524   @CR;
111524   *"8F5UD
"111524
111524   DISP 7                     % SPECIAL DF. FOR UDRXX RT-PROG
111524          INTEGER UR5M                          % ADDRESS TO MESSAGE FROM N500 PROC.
111524          INTEGER POINTER FUNCP                 % FUNCTION
111524          DOUBLE  POINTER MEMOP                 % MEMORY ADDRESS
111524          INTEGER POINTER BLOCP                 % NOT USED
111524          DOUBLE  POINTER NWORP                 % NR OF 16 BITS WORDS
111524   PSID
111524          INTEGER SVB=?,SVT=?,HST=?,FUN=?,SBM=?,CLM=?
111524   UFELL: *2BANK; IOF
111526          A+LUDV=:SVT                            %LOG DEV NO
111530          CALL LOGPH; IF A = 0 THEN CALL XERRF;  FI
111533                      IF D = 0 THEN CALL XERRF;  FI
111536          A:=D.N5RDF=:B; X:=RTREF
111542          CALL BRESERVE; IF A < 0 THEN CALL XERRF;  FI
111545          DO %------------------------------------  FOREVER
111545   L1:       T:=SVT;
111546             RTREF.STATUS BONE 5WAIT =:X.STATUS   % SET INTO
111552             "RWAIT";* IRW MLEVB DP               % I/O WAIT
111554             MLEV  ;* MST PIE; MST PID; ION       % UNTIL .....
111560                                                  % ACTIVATED FROM ND-500-DRIVER
111560             A:=B;  * AAA FUNCP; MON 2ABST; IOF   % ABSTR TO ACTIVATE DRIVER
111564             A=:HST; FUNCP=:FUN; T=:SVT
111570             X:=UR5M; CALL RN5STATUS              % READ MESSAGE STATUS
111572             IF A-WFUDMA >< 0 GO L1               % ND-500 PROC NOT WAITING FOR UDMA
111574             IF FUNCP=0 OR =2  THEN               % CLEAR CACHE ON DMA INPUT
111601               7400=:CLM
111603             ELSE
111604               0=:CLM
111605             FI
111605             IF FUNCP=0 OR A=7 OR A=20 OR A=24 OR A=62 THEN
111623               IF A=0 THEN AD:=NWORP SHZ 1        % WORDS TO BYTE
111626               ELSE        AD:=NWORP
111630               FI
111630               T:=5MBBANK;*AAX 5AP5; STDTX        % STORE RETURN PAR (NO 5)
111633               20=:SBM                            % RETUN PARAMETER (NO 5)
111635             ELSE IF A =54 OR A =56 THEN          % PIO INP. DATA
111644               AD:=NWORP; "0"                     % MOVE TO DATA ARRY
111646               T:=5MBBANK;*AAX 5AP2; STDTX        % STORE RETURN PAR (NO 2)
111651               2=:SBM                             % RETUN PARAMETER (NO 2)
111653             ELSE
111654               0=:SBM; T:=5MBBANK
111656               GO NRET; *)FILL                    % NO RETURN PARAMETER
111670               INTEGER SVB,SVT,HST,FUN,SBM,CLM
111676             FI;FI
111676   NRET:     CALL SLOCK; GO N500ERR               % GET GENERAL LOCK WHILE UPDATING FLAGWORD
111700             T:=5MBBANK; X:=UR5M; *AAX 5MSFL
111703             A:=NOWFL; * BLDA 000 DA              % IF NO WAIT
111705             *LDATX; BSTA 000 DA; STATX; AAX -5MSFL % DON'T UNFIX USER FIXED
111711             CALL SUNLOCK
111712             CALL GCPUDF; CALL ERRFATAL
111714             A:=:B=:SVB                           % B= 500-CPU DATAFIELD
111716   *NNT37=*
111716             CALL TER500; GO N500ERR              % STOPP ND-500
111720             SBM=:D
111722             IF HST < 0 AND FUN >< 20 AND A>< 24 THEN % READ STATUS
111733               "171"; CALL 5EMONICO               % RETURN STATUS TO ND-500 PROC.
111735             ELSE
111736               T:=CLM; CALL 5MONICO               % RETURN STATUS TO ND-500 PROC.
111740             FI
111740             CALL ACTRDY                          % RESTART PROCESS
111741             CALL LOWACT500; SVB=:B               % START ND-500
111744          OD
111745   XERRF: *ION; MON 0; )FILL
111761   N500ERR: CALL RSTARTALL; GO XERRF
111763
111763   *"8UD01+8VI01 8F5UD
"111763   URT01: "0";GO UFELL
111765   *"8UD02+8VI02 8F5UD
"111765   URT02:  1 ;GO UFELL
111767   *"8UD03+8VI03 8F5UD
"111767   RBUS
111772   *"
"111772
111772   *"8DILG
"111772
111772   %============================================================================
111772   %            D I L R T
111772   %
111772   % RT-PROGRAM FOR DISC-LOGGING ON FILE DISC-LOGG:LOGG
111772   %
111772
111772   SUBR DILRT
111772
111772   DILRT: *2BANK
111773          "DFDIL"=:B;
111775          *IOF
111776          DILGFLAG BZERO DILBOK=:DILGFLAG
112001          *ION
112002          "DLPMF"; *MON 2UNFI                         % UNFIX DISC-LOG BUFFER SEGEMENT
112004          -1=:DLMLPHPAGE
112006          DO
112006             DLMLPHPAGE+1=:DLMFPHPAGE+77=:DLMLPHPAGE
112013             "DLPM61"; *MON 61; JMP NXT               % ALLOCATE DISC-LOG BUFFER SEGMENT WITHIN A MEMORY BANK
112016             GO OK
112017   NXT:   WHILE DLMLPHPAGE<<ENDPAGE
112023          OD; GO FAR ERR                              % MEMORY NOT AVAILABLE
112025   *)FILL
112034   INTEGER CCCBUF                                     % BUFFER 1/ BUFFER 2 FLAG
112035   OK:    *IOF
112036          DILGFLAG BONE DILBOK=:DILGFLAG
112041          DILFUNIT SH 6+61=:DALFUNC                   % FUNC=61: WRITE
112045          "DILGS"*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *BPAGL@3 LDATX
112053          A SHZ -2                                    % DIV BY 4; PHYS. PAGE
112054          A=:D:=0; AD SH 12=:DDIBADDR                 % PHYS.ADDR OF DISC-LOG BUFFER
112060          A:=D=:DILBPNT                               % PHYS.ADDR WITHIN MEM.BANK
112062          DO
112062   LOOP:     IF T:=DILGFLAG NBIT DILSTART GO OUT          % IF NOT STARTED
112065             IF T BIT 1DILBFULL OR T BIT 2DILBFULL THEN   % ANY DISC-LOG BUFFER FULL?
112071                T BONE DILIABSTR=:DILGFLAG                % YES, MARK TRANSFER GOING ON
112073                AD:=DDIBADDR
112074                IF T BIT 2DILBFULL THEN T:=2000 ELSE T:=0 FI
112101                T=:CCCBUF; D+T; A:=A+C; AD=:DALCMADDR     % PHYS.ADDR OF CURRENT LOG-BUFFER TO TRANSFER
112105                DILDADDR=:DALCDADDR                       % CURRENT MASS STORAGE ADDR
112107                *ION
112110                T:=DILFLOG; "DALM131"; *MON 2ABST
112113                A=:D                                      % TRANSFER STATUS IN D-REG
112114                *IOF
112115                T:=DILGFLAG BZERO DILIABSTR               % MARK THAT TRANSFER IS FINISHED
112117                IF CCCBUF=0 THEN T BZERO 1DILBFULL ELSE T BZERO 2DILBFULL FI
112124                T=:DILGFLAG
112125                IF D<0 GO ERR                             % ERROR IN TRANSFER
112127                AD:=DILLADDR; A=:T; D=:L; AD:=DILDADDR
112133                IF A>>T OR A=T AND D>>=L GO ERR1          % END OF LOG-FILE
112141                T:=2; D+T; A:=A+C; AD=:DILDADDR           % NEXT MASS STORAGE ADDR
112145             ELSE
112146                RTREF.STATUS BONE 5WAIT=:X.STATUS         % WAIT FOR NEXT BUFFER TO BE FULL
112152                "RWAIT"; *IRW MLEVB DP
112154                MLEV; *MST PID; ION
112157             FI
112157          OD
112160   *)FILL
112170
112170   ERR:   *IOF
112171          DILGFLAG BZERO DILSTART BZERO DILBOK=:DILGFLAG
112175          A:=-1
112176          *ION; MON 64                                    % ALL ERRORS EXCEPT END-OF-LOG-FILE
112200   OUT:   *ION
112201          "DLPMF"; *MON 2UNFI
112203          *MON 2RTEX
112204
112204   ERR1:  DILGFLAG BZERO DILSTART BZERO DILBOK=:DILGFLAG
112210          *ION
112211          RX002; *MON 64                                  % END-OF-LOG-FILE
112213          GO OUT
112214   RBUS
112216
112216   *"8STRN+8N500
"112216   %==============================================================================
112216   %      ( R )    3 I N S T R   3 O U T S T
112216   %
112216   % STRING MONITOR CALLS
112216   % I=INSTR(LOG.NO,COREADDR,MAXNO,TERMINATOR)
112216   % I=OUTST(LOG.NO,COREADDR,NUMBER)
112216   SUBR 3INSTR,3OUTST
112216
112216   DISP 24
112216          INTEGER COUN,VAL,DYTYFIELD
112216          INTEGER POINTER LREG
112216          INTEGER ADR=D1,USAPITS=D0,OUSAPIT=D3
112216   PSID
112216   %====================================================================
112216   %      ( R )        C 3 O U T X
112216   %
112216   % LOCAL SUBROUTINE TO CHECK FOR LEGAL DEVICE FOR INSTR/OUTSTR
112216   %
112216   % EXIT:      A=ADDR OF INPUT DATAFIELD
112216   %            D=ADDR OF OUTPUT DATAFIELD
112216   %
112216   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG, PTTIFIELD:=TTIFIELD
112221   C3OUTX: A:=L=:"LREG"
112223          IF BACKGROUND><0 THEN
112225             X:=B+7; *LRB BLEVB           % SAVE REGS INCASE ESCAPE
112230             X:="ESCBLOCK"; *SRB BLEVB
112232             A:=B=:CMDFFIELD
112234             IF D0=1 THEN                 % LOG.DEV=1?
112240                IF PBCHFLAG=0 THEN        % YES, IS IT IN BATCH/MODE?
112242                   A:=PTTNO               % NO, USE LOGICAL DEV OF TERMINAL/TAD
112243                 ELSE
112244                   A:=PTTIFIELD.DFOPP.ROFIL % BATCH/MODE, USE BATCH/MODE OUTPUT FILE
112247                 FI
112247             FI
112247          ELSE
112250             D0                           % RT-PROGR, USE LOG.DEV IN PAR.LISTE
112251          FI; A=:D
112252          IF A/\177700=100 GO FAR ERR2    % NOT ALLOWED ON FILE
112256          A:=D; CALL LOGPH                % GET ADDR OF DATAFIELDS
112260          GO LREG
112261   *)FILL
112267
112267   %==============================================================
112267   %      ( R )     C H E R R
112267   %
112267   % LOCAL SUBROUTINE TO CHECK FOR ERRORS
112267   %
112267   % ENTRY:     X=ACTUAL DATAFIELD ADDR.
112267   %
112267   % RETURN: X=BUFFER ADDR.
112267   %
112267   CHERR: A:=L=:"LREG"
112271          X=:DYTYFIELD                              % X=DF. ADDR
112272          IF X=0 OR X.TYPRING NBIT 5IOBT GO ERR2    % NOT LEGAL ON THIS DEVICE
112276          IF X.RTRES><RTREF THEN 5; GO ERRF FI      % DEVICE NOT RESERVED
112304          IF D2<0 GO ERR; A-,=:COUN                 % NUMBER TO OUTPUT/MAX NUMBER TO INPUT
112310          *IOF
112311          IF X.TYPRING BIT 5SPLITDF THEN            % TERMINAL/TAD
112314             T:="FLAGB"; CALL XGTDFADDR
112316             IF A BIT 5LSTA THEN TER02; GO ERRF FI  % TERMINAL NOT CONNECTED
112322          FI
112322          T:="DERROR"; CALL XGTDFADDR
112324          IF A><0 THEN                              % ANY ERROR OCCURED ON THIS DEVICE?
112325             A\/140000=:ZAREG                       % YES, SET ERROR CODE
112327             A:=0; T:="DERROR"; CALL XSTDFADDR      % CLEAR ERROR INDICATOR
112332             GO FAR RETU
112333          FI; X:=D1                                 % X=BUFFER ADDR
112334          MLEV; *MST PIE; ION
112337          GO LREG
112340
112340   ERR2:  A:=2
112341   ERRF:  A\/140000; GO FERR
112343   ERR:   A:=-1
112344   FERR:  A=:ZAREG; GO FAR RETU
112346   *)FILL
112356
112356
112356   %========================================================
112356   %      ( R )   C S E T B F W I N D O W
112356   %
112356   CSETBFWINDOW:
112356          AD:=DTDFPHPAGE; A:=:D/\1777+"WNDBF*2000"=:B   % B=DF.ADDR IN WINDOW
112363          A:=142000; T:=0; X:="WNDBF+WNDBF+174000"; *STDTX
112367          A:=D=:RTREF.BUFWINDOW
112372          EXIT
112373
112373   %======================================================
112373   %      ( R )     S T D E
112373   %
112373   % SUBROUTINE TO EXECUTE "STDEV"
112373   STDE:  *IOF; IRW BLEVB DB
112375          "4STDE"; *IRW BLEVB DP
112377          BLEV; *MST PID; COPY SD DA
112402          *ION; EXIT
112404
112404   %=======================================================
112404   %      ( R )     4 S T D E
112404   %
112404   % INBT-OUTB LEVEL
112404   4STDE: *IOF; 2BANK
112406          IF TYPRING BIT 5SPLITDF THEN CALL CSETBFWINDOW FI
112412          CALL STDEV; *ION; WAIT
112415          CALL ERRFATAL
112416   *)FILL
112425
112425   %==================================================
112425   %      ( R )     I O T R
112425   %
112425   % SUBROUTINE TO EXECUTE "IOTRANS"
112425   % RETURN: FULL/EMPTY (RT ONLY)
112425   % SKIPRETURN: OK
112425   IOTR:  A=:D; DYTYFIELD; *IOF; IRW BLEVB DB
112431          "BIOTR"; *IRW BLEVB DP
112433          BLEV; *MST PID; COPY SD DA
112436          IF T:=BACKGROUND><0 THEN L-1 FI
112442          *ION; EXIT
112444
112444   %====================================================
112444   %      ( R )     B I O T R
112444   %
112444   % INBT-OUTBT LEVEL:
112444   BIOTR: *IOF; 2BANK
112446          IF TYPRING BIT 5SPLITDF THEN CALL CSETBFWINDOW FI
112452          *IRR ALEVB DA
112453          CALL IOTRANS; GO WWT; *IRW ALEVB DA
112456          *IRR ALEVB DL; AAA 1
112460          IF T:=BACKGROUND><0 THEN A+1 FI
112464          *IRW ALEVB DL
112465   WBIO:  CALL STDEV
112466          *ION; WAIT
112470          CALL ERRFATAL
112471
112471   WWT:   IF BACKGROUND><0 THEN
112473             X:=RTREF
112474             IF TYPRING BIT 5SPLITDF THEN
112477                TDRADDR; A=:D; D:=:B; CALL WDATA; B:=D
112504             ELSE
112505                CALL WDATA
112506             FI; "STUPR"; *IRW MLEVB DP
112510             MLEV; *MST PID
112512          FI; GO WBIO
112513   *)FILL
112521
112521   %===============================================================
112521   %      ( R )   3 I N S T R
112521   %
112521   % MONITOR CALL INSTR:
112521   3INSTR: CALL GET4
112522          CALL FAR C3OUTX                           % FIND DATAFIELD
112523          A=:X; CALL FAR CHERR                      % CHECK FOR LEGAL DEVICE
112525          OLDPAG=:D
112527          X:=ZAREG; CALL DALTON; X.S1; CALL SINALTPIT
112533          A=:ADR                                    % BUFFER ADDR
112534          OLDPAGE/\3600+"NRPIT+ALEVB+ERNG2"=:USAPITS % PCR WHEN ACCESSING USER'S BUFFER
112540          DO        % UNTIL MAX CHAR IS READ OR UNTIL TERMINATOR CHAR IS FOUND
112540                MIN COUN; GO BYP1; GO OUT1
112543   BYP1:        CALL IOTR; GO WEX1; IF =D3 GO TERM1; A SH 10=:VAL
112552                MIN COUN; GO BYP2; GO OUT2
112555   BYP2:        CALL IOTR; GO WEX2; IF =D3 GO TERM2
112562                T:=VAL+A; ADR=:L
112566                USAPITS=:RTREF.ACTPRI; *TRR PCR
112572                T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112577                A=:RTREF.ACTPRI; *ION
112602                MIN ADR; 0/\0
112604          OD
112605   *)FILL
112616
112616   %EXITS FROM LOOP:
112616   OUT2:  T:=VAL; ADR=:L
112621          USAPITS=:RTREF.ACTPRI; *TRR PCR
112625          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112632          A=:RTREF.ACTPRI; *ION
112635   OUT1:  D2=:ZAREG; GO ACTRET
112640
112640   % BUFFER EMPTY(RT ONLY):
112640   WEX2:  T:=VAL; ADR=:L
112643          USAPITS=:RTREF.ACTPRI; *TRR PCR
112647          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112654          A=:RTREF.ACTPRI; *ION
112657          GO WEXX
112660   WEX1:  IF D2+COUN-1=0 GO WTIO
112664   WEXX:  D2+COUN BONE 17=:ZAREG; GO ACTRET
112671   TERM2: A+VAL; GO TERMX
112673   TERM1: A SH 10
112674   TERMX: T:=A; ADR=:L
112677          USAPITS=:RTREF.ACTPRI; *TRR PCR
112703          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112710          A=:RTREF.ACTPRI; *ION
112713          D2+COUN+1 BONE 16=:ZAREG; GO ACTRET
112721
112721   % EXIT WITH ACTIVATION OF DEVICE:
112721   ACTRET: DYTYFIELD; CALL FAR STDE
112723   RETU:  *ION
112724          IF BACKGROUND><0 THEN CALL XBMRET FI
112727          GO RET
112730
112730   WTIO:  MLEV; *IOF; MCL PIE
112733          X:=DYTYFIELD:=:B=:D:=RTREF; CALL WDATA; B=:A:=D
112742          CALL FAR STDE
112743          IF BACKGROUND><0 THEN CALL XBMRET FI
112746          ZPREG-1=:ZPREG; GO RETSTUPR
112752   *)FILL
112762
112762   %============================================================
112762   %      ( R )     3 O U T S T
112762   %
112762   % MONITOR CALL OUTST:
112762   3OUTST: CALL GET3
112763          OLDPAG=:D
112765          X:=ZAREG; CALL DALTON; X.S1; CALL SINALTPIT
112771          A=:ADR                                    % USER'S BUFFER ADDRESS
112772          OLDPAGE/\3600+"NRPIT+ALEVB+ERNG2"=:OUSAPITS % PCR WHEN ACCESSING USER'S BUFFER
112776          CALL FAR C3OUTX                           % FIND LOGICAL DEV.NO
112777          IF D=0 GO FAR ERR2                        % D=ADDR OF OUTPUT DF.
113001          IF D.RTRES><RTREF THEN 5; GO FAR ERRF FI  % DEVICE NOT RESERVED
113010          IF X.TYPRING BIT 5SPLITDF GO OSTERM       % IN MICRO.COMMON (TERM & TAD)
113013          IF BACKGROUND=0 THEN                      % IF RT-PROGRAM
113015             IF D2>>X.MAX GO OUTFULL                % TOO MANY CHAR IN CALL
113021             X=:DYTYFIELD
113022             IF A>>X.CFREE GO WTIO                  % NOT YET ENOUGH SPACE IN BUFFER
113025          FI; CALL FAR CHERR                        % CHECK FOR LEGAL DEVICE
113026          DO                    % UNTIL ALL CHARS ARE IN OUTPUT BUFFER
113026                MIN COUN; GO OBYP1; GO OOUT
113031   OBYP1:       ADR=:L; OUSAPITS=:RTREF.ACTPRI; *TRR PCR
113037                T:=L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
113044                A=:RTREF.ACTPRI; *ION
113047                MIN ADR; 0/\0; A:=T=:VAL SHZ -10
113054                CALL FAR IOTR; GO OUTFULL; MIN COUN; GO OBYP2; GO OOUT
113061   OBYP2:       VAL/\377; CALL FAR IOTR; GO OUTFULL
113065          OD
113066   % EXITS FROM LOOP:
113066   OOUT:  0=:ZAREG; GO FAR ACTRET
113070   OUTFULL: 100000=:ZAREG; GO RET                   % RT ONLY
113073   RBUS
113115   *"
"113115
113115   %==============================================================================
113115   %      ( R )     I P R I V
113115   %
113115   SUBR IPRIV
113115   INTEGER BREG,NBREG,CAREG
113120   IPRIV: CALL GET0
113121          T:=ZTREG; X:=ZXREG; A:=ZDREG=:D
113125          A:=B=:BREG:=ZAREG=:CAREG:=ZBREG=:B:=CAREG
113134          *EXR ST
113135          A=:CAREG:=B=:NBREG:=BREG=:B
113142          A:=NBREG=:ZBREG:=D=:ZDREG
113146          T=:ZTREG; X=:ZXREG; CAREG=:ZAREG
113152          GO RET
113153
113153   RBUS
113155
113155   *"CAMA
"113155

113155   %=====================================================================
113155   %=====================================================================
113155   %                                                                                        %
113155   %                                                                                        %
113155   %            B U F F E R   P O O L     M O N I T O R   C A L L S     %
113155   %                                                                                        %
113155   %                                                                                        %
113155   %=====================================================================
113155   %=====================================================================
113155
113155
113155
113155
113155
113155
113155   SYMBOL SBMAX=100             % MAX NUMBER OF BUFFERS IN PACKET
113155   %
113155   %============================================================================
113155   %         DATA FIELD DESCRIPTORS
113155   %
113155   %============================================================================
113155   % 35.21      P O O L   H E A D
113155
113155   DISP -1
113155   INTEGER WPVER                % VERIFICATION VALUE OF POOL HEAD
113155   SYMBOL SPCOR=125252          % CORRECT VALUE OF WPVER
113155   INTEGER WFREE                % ADDRESS OF FIRST FREE BUFFER, =0 IF EMPTY
113155   INTEGER WNFRE                % NUMBER OF FREE BUFFERS IN POOL
113155   INTEGER WLLIM                % LOWER ADDRESS OF BUFFER POOL
113155   INTEGER WHLIM                % HIGHER ADDRESS OF BUFFER POOL
113155   INTEGER WBFSZ                % BUFFER SIZE , NO. OF WORDS
113155   PSID
113155
113155
113155   %============================================================================
113155   % 35.22      Q U E U E   H E A D
113155
113155   DISP 0
113155   INTEGER WLPAK                % ADDRESS OF LAST PACKET IN QUEUE
113155                                % EQUAL TO QUEUE HEAD IF QUEUE EMPTY
113155   INTEGER WFPAK                % ADDRESS TO FIRST BUFFER IN QUEUE
113155                                % EQUAL TO QUEUE HEAD IF EMPTY
113155   INTEGER WPNUM                % NUMBER OF PACKETS IN QUEUE
113155   INTEGER WPROC                % ADDRESS OF OWNER OF QUEUE
113155   PSID
113155
113155
113155   %============================================================================
113155   % 35.23      P A C K E T   H E A D
113155
113155   %      2.3.1 GENERAL OFFSETS, PACKET HEAD AND WXX
113155   %            TO BE USED WITHIN GLOB-DEF, ONLY !!!
113155
113155   SYMBOL SLHW=400              % MULTIPLIER FOR LEFT HALFWORD
113155   SYMBOL S1QW=10000            % MULTIPLIER FOR 1 QUARTERWORD
113155   SYMBOL S3QW=20               % MULTIPLIER FOR 3 QUARTERWORD
113155   SYMBOL S1OCT=40000           % MULTIPLIER FOR 1 OCTET
113155   SYMBOL S3OCT=2000            % MULTIPLIER FOR 3 OCTET
113155   SYMBOL S5OCT=100             % MULTIPLIER FOR 5 OCTET
113155   SYMBOL S7OCT=4               % MULTIPLIER FOR 7 OCTET
113155   SYMBOL SRHW=1                % MULTIPLIER FOR RIGHT HALFWORD
113155
113155   %============================================================================
113155   % 35.24      GENERAL FIELDS, PACKET HEAD AND WDW'S
113155   %            TO BE USED WITHIN GLOB-DEF ONLY !!!
113155   %
113155   SYMBOL SRHWMASK=377          % RIGHT HALFWORD MASK
113155   SYMBOL SLHWMASK=-SRHWMASK-1  % LEFT HALFWORD MASK
113155   SYMBOL S1QWMASK=17*S1QW      % 1. QUARTER WORD MASK
113155   SYMBOL S2QWMASK=17*SLHW      % 2. QUARTER WORD MASK
113155   SYMBOL S3QWMASK=17*S3QW      % 3. QUARTER WORD MASK
113155   SYMBOL S4QWMASK=17*SRHW      % 4. QUARTER WORD MASK
113155   SYMBOL C1QWMASK=-S1QWMASK-1
113155   SYMBOL C2QWMASK=-S2QWMASK-1
113155   SYMBOL C3QWMASK=-S3QWMASK-1
113155   SYMBOL C4QWMASK=-S4QWMASK-1
113155   %

113155   %============================================================================
113155   % 35.25      ACTUAL PACKET HEAD LAY-OUT
113155   %
113155   DISP SPDISP=0
113155   INTEGER WNBUF                % ADDRESS OF NEXT BUFFER IN PACKET
113155   INTEGER WNPAK                % ADDRESS OF NEXT PACKET IN QUEUE
113155   INTEGER WPOSS                % ADDRESS OF OWNER OF PACKET
113155   INTEGER WDUM                 % DUMMY
113155   INTEGER WTYP,WSCOM=WTYP                          % WORD FOR MESSAGE TYPE &  FORMAT
113155   INTEGER WBC,WSEQ=WBC                             % WORD FOR BYTE COUNT & SEQUENCE CONTROL
113155   INTEGER WDEA,WPRI=WDEA                           % DESTINATION ADDRESS AND PRIORITY
113155          SYMBOL SPRIMASK=3*S1OCT                   % MSG PRIORITY
113155          SYMBOL CPRIMASK=-SPRIMASK-1
113155          SYMBOL SPRISHIFT=-16
113155          SYMBOL CPRISHIFT=-SPRISHIFT
113155   DOUBLE  WDADR=WDEA                               % BOTH ADDRESSES
113155   INTEGER WSCA                                     % SOURCE ADDRESS
113155   PSID
113155   *)KILL SLHW S1QW S3QW S1OCT S3OCT S5OCT S7OCT SRHW
113155   *)KILL SRHWM SLHWM S1QWM S2QWM S3QWM S4QWM
113155   *)KILL C1QWM C2QWM C3QWM C4QWM
113155

113155
113155
113155   % TIME USED BY SINTRAN ROUTINES:
113155   %      GET0 - 52MICS (10-54)   25MICS (10-S-02)
113155   %      ALTON- 68MICS (10-54)   33MICS (10-S-02)
113155   %      ALTOF- 56MICS (10-54)   26MICS (10-S-02)
113155
113155
113155
113155
113155   %=======     G E T F         170
113155   %
113155   % GET A NUMBER OF BUFFERS FROM FREE POOL
113155   % SET RT-PROG ADDRESS IN WPOSS-WORD OF EACH BUFFER
113155   %
113155   % GETF:      GET PARAMETERS(POOLHEAD,NO-OF-BUFFERS-REQUIRED)
113155   %            IF FALSE POOLHEAD OR ILLEGAL NO-OF-BUFFERS-REQUIRED THEN
113155   %                            NON-SKIP-RETURN(-1)
113155   %            ENDIF
113155   %            IF POOLHEAD.WNFRE<NO-OF-BUFFERS-REQUIRED THEN
113155   %                NON-SKIP-RETURN(0)
113155   %            ENDIF
113155   %            POOLHEAD WFREE=:FIRST-BUFFER=:BUFFER
113155   %            FOR COUNT:=2 TO NO-OF-BUFFERS-REQUIRED DO
113155   %                RTREF=:BUFFER.WPOSS; 0=:BUFFER.WNPAK
113155   %                BUFFER.WNBUF=:BUFFER
113155   %            ENDDO
113155   %            BUFFER.WNBUF=:POOLHEAD.WFREE
113155   %            0=:BUFFER.WNBUF
113155   %            POOLHEAD.WNFRE - NO-OF-BUFFERS-REQUIRED=:POOLHEAD.WNFRE
113155   %            SKIP-RETURN(FIRST-BUFFER)
113155   % ENTRY:     X - ADDRESS OF POOL HEAD
113155   %            A - NUMBER OF BUFFERS WANTED
113155   % EXIT:
113155   %      NON-SKIP              A=-4                POOL DESTROYED
113155   %                            A=-1                ILLEGAL PARAMETER VALUE
113155   %                            A=0                 NOT ENOUGH FREE BUFFERS
113155   %      SKIP                  A = ADDRESS OF FIRST BUFFER IN CHAIN
113155   % TIME USED: 326 MICS + 41.5 MICS*N (10-54)      N=NO. OF BUFFERS
113155   %            159 MICS + 20 MICS * N (10-S-02)
113155   %
113155
113155   %============================================================================
113155   % 35.30      U S O X
113155   %
113155   SUBR US0X
113155   INTEGER NUM                  % NUMBER OF BUFFERS REQUIRED
113156   INTEGER LVAR                 % LOCAL VARIABLE
113157   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113160   INTEGER NPOLH                % ADDRESS OF POOL HEAD
113161   INTEGER LLIM                 % LOWER LIMIT OF BUFFER POOL
113162   INTEGER HLIM                 % HIGHER LIMIT OF BUFFER POOL
113163   US0X:  CALL GET0; ZAREG=:NUM; ZXREG=:NPOLH
113170          RTREF=:ICURT
113172          OLDPAG=:D
113174          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113175          NPOLH.WHLIM=:HLIM; X.WLLIM=:LLIM          % SAVE BUFFER POOL LIMITS
113202          IF NPOLH.WPVER><SPCOR OR NUM<=0 OR A>SBMAX THEN A:=-1; GO NSKIP FI
113217          IF X.WNFRE-NUM<0 THEN A:=0; GO NONSK FI   % TOO FEW BUFFERS LEFT
113224          A=:X.WNFRE                                % UPDATE NUMBER OF FREE BUFFERS LEFT
113225          1=:D
113227          A:=X.WFREE=:LVAR                             % FIRST FREE BUFFER
113231          FOR D TO NUM DO
113234            IF A=:X-LLIM<<0 OR HLIM-,+X>>=0 THEN A:=-4; GO NONSK FI
113247            IF X.WNPAK><X THEN A:=-4; GO NONSK ELSE 0=:X.WNPAK FI
113255            ICURT=:X.WPOSS; A:=X.WNBUF
113260          OD
113262          0=:X.WNBUF
113263          A=:NPOLH.WFREE
113265          CALL ALTOFF; LVAR=:ZAREG; MIN ZPREG; 0/\0; GO RET
113273   NONSK:
113273   NSKIP: A=:LVAR
113274          CALL ALTOFF; LVAR=:ZAREG; GO RET; *US0=US0X
113300   RBUS
113306
113306
113306
113306
113306
113306
113306
113306   %========    P U T F         171
113306   %
113306   % RETURN A CHAIN OF BUFFERS TO FREE POOL. ALL BUFFERS MUST CONTAIN
113306   % ADDRESS OF CURRENT RT-PROGRAM IN WPOSS-WORD, AND ZERO IN
113306   % WNPAK-WORD. LAST BUFFER MUST HAVE ZERO IN WNBUF-WORD.
113306   % IT IS CHECKED THAT NUMBER OF BUFFERS DOES NOT EXCEED MAX ALLOWED
113306   % NUMBER. THIS PREVENTS INFINITE LOOP.
113306   %
113306   % PUTF:      GET PARAMETERS(POOLHEAD,PACKET)
113306   %            IF FALSE POOLHEAD OR ILLEGAL PACKET THEN NON-SKIP-RETURN(-1) ENDIF
113306   %            IF ANY-BUF-OF-PACKET.WPOSS><CURR-RT-PROG OR PACKET.WNPAK><0 THEN
113306   %                NON-SKIP-RETURN(0)
113306   %            ENDIF
113306   %            POOLHEAD.WFREE=:LAST-BUFFER-OF-PACKET.WNBUF
113306   %            PACKET=:POLLHEAD.WFREE
113306   %            0=:ALL-PACKET-BUFFERS.WPOSS
113306   %            POOLHEAD.WNFRE+NO-OF-NUFFERS-IN-PACKET=:POOLHEAD.WNFRE
113306   %            SKIP-RETURN
113306   %
113306   %
113306   % ENTRY:     X - ADDRESS OF POOL HEAD
113306   %            A - ADDRESS OF FIRST BUFFER IN CHAIN
113306   % EXIT:
113306   %                            A=-3                TOO LONG CHAIN, DISORDER ?
113306   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM
113306   %                                                OR PACKET BELONGS TO QUEUE
113306   %                            A=-1                ILLEGAL PARAMETER VALUE
113306   %      SKIP                  BUFFER CHAIN PUT IN POOL OK
113306   % TIME USED: 320 MICS + 52 MICS * N (10-54)      N=NO OF BUFFERS IN PACKET
113306   %            154 MICS + 24 MICS * N (10-S-02)
113306
113306   %============================================================================
113306   % 35.31      U S 1 X
113306   %
113306   SUBR US1X
113306   INTEGER IPACK                % ADDRESS OF PACKET TO RELEASE
113307   INTEGER LVAR                 % LOCAL VARIABLE
113310   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113311   INTEGER NPOLH                % ADDRESS OF POOL HEAD
113312   INTEGER LLIM                 % LOWER LIMIT OF BUUFER POOL
113313   INTEGER HLIM                 % HIGHER LIMIT OF BUFFER POOL
113314   US1X:  CALL GET0; ZAREG=:IPACK; ZXREG=:NPOLH
113321          RTREF=:ICURT
113323          OLDPAG=:D
113325          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113326          NPOLH.WLLIM=:LLIM; X.WHLIM=:HLIM
113333          IF NPOLH.WPVER><SPCOR THEN A:=-1; GO NSKIP FI
113342          IF IPACK.WNPAK><0 THEN A:=-2; GO NSKIP FI
113347          1=:D; IPACK=:LVAR     % CHECK BUFFER CHAIN
113353          FOR D TO SBMAX DO
113356            LVAR=:LVAR.WNPAK
113361            IF A=:T-LLIM<<0 OR HLIM-,+T>>=0 THEN A:=-1; GO NSKIP FI
113374            IF LVAR.WPOSS-ICURT><0 THEN A:=-2; GO NSKIP
113402            ELSE 0=:X.WPOSS; FI
113404            IF LVAR.WNBUF=:LVAR=0 GO PEND
113410          OD
113412          A:=-3; GO NSKIP
113414   PEND:  X=:T
113415          NPOLH.WFREE=:T.WNBUF
113421          IPACK=:NPOLH.WFREE
113424          NPOLH.WNFRE+D=:X.WNFRE
113430          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113434   NSKIP: A=:LVAR
113435          CALL ALTOFF; LVAR=:ZAREG; GO RET; *US1=US1X
113441   RBUS
113447
113447
113447
113447
113447
113447   %========   G E T Q          172
113447   %
113447   % GET A PACKET FROM START OF QUEUE
113447   % SET RT-PROG ADDRESS IN WPOSS-WORD OF EACH BUFFER
113447   %
113447   % GETQ:      GET PARAMETER(QUEUEHEAD)
113447   %            IF ILLEGAL QUEUE HEAD THEN NON-SKIP-RETURN(-1) ENDIF
113447   %            IF QUEUE EMPTY THEN NON-SKIP-RETURN(0) ENDIF
113447   %            QUEUEHEAD.WFPAK=:PACKET
113447   %            PACKET.WNPAK=:QUEUEHEAD.WFPAK
113447   %            QUEUEHEAD.WPNUM - 1
113447   %            0=:PACKET.WNPAK
113447   %            QUEUEHEAD.WPROC=:ALL-BUFFERS-OF-PACKET.WPOSS
113447   %            SKIP-RETURN(PACKET)
113447   %
113447   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113447   % EXIT:
113447   %      NON-SKIP              A=-1                ILLEGAL PARAMETER VALUE
113447   %                            A=0                 QUEUE EMPTY
113447   %      SKIP                  A = ADDRESS OF PACKET
113447   % TIME USED: 281 MICS (10-54)                    134 MICS (10-S-02)
113447
113447   %============================================================================
113447   % 35.32      U S X 2
113447   %
113447   SUBR US2X
113447   INTEGER IPACK                % ADDRESS OF FETCHED PACKET
113450   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113451   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113452   US2X:  CALL GET0; ZXREG=:IQH; RTREF=:ICURT
113457          OLDPAG=:D
113461          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113462   GQCOM: IF IQH.WPROC><ICURT THEN A:=-1; GO NSKIP FI
113471          IF X.WPNUM=0 THEN GO NSKIP FI
113474          A:=X.WFPAK=:IPACK
113476          IF A.WNPAK=IQH THEN IQH=:IQH.WLPAK FI
113506          A=:IQH.WFPAK; X.WPNUM-1=:X.WPNUM
113513          A:=IQH.WPROC; X:=IPACK
113516          DO WHILE X><0
113517            A=:X.WPOSS; 0=:X.WNPAK; X:=X.WNBUF
113522          OD
113523          CALL ALTOFF; IPACK=:ZAREG; MIN ZPREG; 0/\0; GO RET
113531   NSKIP: A=:IPACK
113532          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US2=US2X
113536   RBUS
113543
113543
113543
113543
113543
113543
113543
113543
113543   %========    P U T Q         173
113543   %
113543   % PUT A PACKET AT END OF QUEUE. WPOSS-WORD MUST CONTAIN ADDRESS
113543   % OF CALLING RT-PROGRAM. WNPAK-WORD MUST BE ZERO.
113543   %
113543   % PUTQ:      GET PARAMETER(QUEUEHEAD,PACKET)
113543   %            IF PACKET.WPOSS><CURR-RT-PROG THEN NON-SKIP-RETURN(-2) ENDIF
113543   %            IF PACKET.WNPAK><0 THEN NON-SKIP-RETURN(0) ENDIF
113543   %            QUEUEHEAD.WLPAK=:PACKET.WNPAK
113543   %            PACKET=:QUEUEHEAD.WLPAK
113543   %            DO WHILE PACKET><0
113543   %                0=:PACKET.WPOSS; PACKET.WNPAK=:PACKET
113543   %            ENDDO
113543   %            QUEUEHEAD.WPNUM + 1
113543   %            SKIP-RETURN
113543   %
113543   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113543   %            A - ADDRESS OF PACKET
113543   % EXIT:
113543   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM OR
113543   %                                                PACKET BELONGS TO QUEUE
113543   %      SKIP                  PACKET PUT IN QUEUE
113543   % TIME USED:
113543   %      PUTQ: 320 MICS (NORD-10)                  165 MICS (10-S)
113543
113543   %============================================================================
113543   % 35.33      U S X 3
113543   %
113543   SUBR US3X
113543   INTEGER IPACK                % ADDRESS OF PACKET TO PUT IN QUEUE
113544   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113545   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113546   US3X:  CALL GET0; ZAREG=:IPACK; ZXREG=:IQH
113553          RTREF=:ICURT
113555          OLDPAG=:D
113557          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113560          IF IPACK.WPOSS><ICURT OR X.WNPAK><0  THEN A:=-2; GO NSKIP FI
113571          T:=IQH.WLPAK; IPACK=:X.WLPAK; MIN X.WPNUM; A=:T.WNPAK
113600          IQH=:IPACK.WNPAK
113603          X:=IPACK
113604          DO WHILE X><0
113605            0=:X.WPOSS; X:=X.WNBUF
113607          OD
113610          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113614   NSKIP: A=:IPACK
113615          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US3=US3X
113621   RBUS
113626
113626
113626
113626
113626
113626
113626   %========    P R I Q         174
113626   %
113626   % PUT A PACKET IN QUEUE ACCORDING TO PRIORITY, I.E. PACKET IS INSERTED
113626   % AFTER LAST PACKET IN QUEUE WITH EQUAL OR HIGHER PRIORITY.
113626   % PRIORITY VALUE IS FOUND IN PACKET HEAD, WORD AND BITS DEFINED AT SYSTEM
113626   % GENERATION.
113626   % WPOSS-WORD MUST CONTAIN ADDRESS OF CALLING RT-PROGRAM. WNPAK-WORD
113626   % MUST BE ZERO.
113626   %
113626   % PRIQ:      GET PARAMETER(QUEUEHEAD,PACKET)
113626   %            IF ANY-BUF-OF-PACKET.WPOSS><CURR-RT-PROG OR PACKET.WNPAK><0 THEN
113626   %                NON-SKIP-RETURN(-2)
113626   %            ENDIF
113626   %            IF PACKET.PRIOR=0 THEN
113626   %                QUEUEHEAD.WLPAK=:LASTPACKET; QUEUEHEAD=:QPACK
113626   %                GO INSERT
113626   %            ENDIF
113626   %            QUEUEHEAD.WFPAK=:QPACK
113626   %            DO WHILE QPACK><QUEUEHEAD AND QPACK.PRIOR>=PACKET.PRIOR
113626   %                QPACK=:LASTPACKET; QPACK.WNPAK=:QPACK
113626   %            ENDDO
113626   % INSERT:    QPACK=:PACKET.WNPAK; PACKET=:LASTPACKET.WNPAK
113626   %            QUEUEHEAD.WPNUM + 1
113626   %            DO WHILE PACKET><0
113626   %                0=:PACKET.WPOSS; PACKET.WNPAK=:PACKET
113626   %            ENDDO
113626   %            SKIP-RETURN
113626   %
113626   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113626   %            A - ADDRESS OF PACKET
113626   % EXIT:
113626   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM OR
113626   %                                                PACKET BELONGS TO QUEUE
113626   %      SKIP                  PACKET INSERTED IN QUEUE
113626   % TIME USED:
113626   %      PRIQ: PRIOR 0         330 MICS (NORD-10)  170 MICS (10-S)
113626   %                  ><0       320+33*N (NORD-10)  165+15*N (10-S)
113626   %                  ><0       130+33*N (NORD-10)   65+15*N (10-S)
113626   %                            N=NO OF PACKETS AHEAD IN QUEUE+1
113626
113626   %============================================================================
113626   % 35.34      U S X 4
113626   %
113626   SUBR US4X
113626   INTEGER IPACK                % ADDRESS OF PACKET TO SEND
113627   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113630   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113631   INTEGER IPRI                 % PRIORITY OF PACKET
113632   US4X:  CALL GET0; ZAREG=:IPACK; ZXREG=:IQH
113637          RTREF=:ICURT
113641          OLDPAG=:D
113643          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113644          IF IPACK.WPOSS><ICURT OR X.WNPAK><0 THEN A:=-2; GO NSKIP FI
113655          X.WPRI/\SPRIMASK=:IPRI
113660          X:=IQH=:D
113662          IF IPRI=0 THEN X.WLPAK=:D; GO DIPUT FI
113667          DO WHILE X.WNPAK><IQH AND A.WPRI/\SPRIMASK-IPRI>>=0
113701            X:=D.WNPAK=:D
113704          OD
113705   DIPUT: T:=D.WNPAK; IPACK=:X.WNPAK; T=:A.WNPAK
113713          IF A:=T=IQH THEN IPACK=:IQH.WLPAK FI
113722          MIN IQH.WPNUM
113724          X:=IPACK
113725          DO WHILE X><0
113726            0=:X.WPOSS; X:=X.WNBUF
113730          OD
113731          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113735   NSKIP: A=:IPACK
113736          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US4=US4X
113742   RBUS
113750
113750
113750   *"7NDDI
"113750
113750
113750   @DEV 1
113750   @DEV (S-S-L)RP-P2-PIOC:NPL
113750   *"8PIOC
"113750
113750   SUBR PIOCM,PIRET,EXEL,    PIDLO,PIDUN,PIDWS
113750
113750   %=======================================================================
113750   %===================================================================== =
113750   %                                                                    = =
113750   %      MONITOR CALL PIOC                                             = =
113750   %                                                                    = =
113750   %===================================================================== =
113750   %=======================================================================
113750   %
113750   %      THE MONITOR CALL  P I O C  ON RPIT
113750   %
113750   %      PURPOSE:              USED FOR COMMUNICATION WITH PIOC
113750   %
113750   %      ARGUMENTS:            X - DEMANDFIELD, B - PARAMPOINTER
113750   %                            PT 0, APT = USERS APT, ION, PON
113750   %
113750   %      CALLING SEQUENCE:     T - FUNCTION
113750   %                            X - PIOC LDN
113750   %                            A - PARAM POINTER
113750   %                            IF T = -1 THEN
113750   %                               A ======> INSTRUCTION TO BE EXECUTED
113750   %                                         KEY FOR SECURITY
113750   %                                         X-REG
113750   %                                         T-REG
113750   %                                         A-REG
113750   %                                         D-REG
113750   %                              ELSE
113750   %                               PARAMETERS IN REG (SEE INDIVIDUEL COMMANDS)
113750   %                            ENDIF
113750   %
113750   %      RETURN:               STATUS IN T
113750   %=======================================================================
113750   INTEGER ARRAY PIENT:=(PIRES,PIREL,PIKIC,PIWKI,PILOA,PIUNL,PISTA,PISTO,PIDIS)
113761   INTEGER PIDF
113762   PIOCM:
113762          X=:DEMSV; A:=B=:PIRSV
113765          IF X.ZTREG = -1 THEN GO EXEL FI                     % SPECIAL FUNCTION (EXECUTE L-REG) NO RETURN
113772          X.ZXREG; CALL LOGPH                                 % FIND DATAFIELD
113774          IF A = 0 THEN D=:A FI                               % ACCEPT BOTH INPUT AND OUTPUT
113776          IF A = 0 THEN PE1; GO PIRET; FI                     % ILLEGAL LDN
114001          A=:B=:PIDF
114003          IF PINIT >< 173 THEN PE1; GO PIRET; FI               % THIS IS NOT A PIOC DATAFIELD
114011          IF X.ZTREG >= 20 THEN GO SWPIOC FI                   % SPECIAL LOAD/UNLOAD FOR PIOC MONITOR
114016
114016          CALL GET0
114017          MLEV; *MST PIE                                      % IN CASE OF TIMEOUT
114021          A:=PIDF=:B
114023          IF DEMSV.ZTREG >> PMFUN THEN PILF; GO PIRET; FI      % ILLEGAL FUNCTION
114032          *1BANK
114033          PIENT(A);*2BANK; COPY SA DP                          % GO TO ACTION ROUTINE
114037
114037   SWPIOC:IF A-20 > 2 THEN PILF; GO PIRET; FI
114045          GOSW PIDLO,PIDUN,PIDWS
114051
114051
114051   %      RETURN FROM MONITOR CALL
114051   %      RETURN STATUS IN A-REG
114051
114051   PIRET: X := DEMSV =: B:=RTRES
114054          A=: ZTREG; *IOF
114056          CALL BRELEASE; CALL RET
114060   RBUS
114077
114077
114077   %      SPECIAL FUNCTION   EXECUTE INSTRUCTION AND GIVE TADX BACK TO USER
114077
114077
114077   SUBR EXEL
114077   %==========================================================================
114077   % SPECIAL MON PIOC FUNCTION
114077   %==========================================================================
114077   INTEGER POINTER PPAST:=PASSTYPE
114100   INTEGER HPASS
114101   TRIPLE TADR
114104   EXEL:
114104            CALL GET6;                      % ACCESS USER PARAMETERS
114105
114105            IF BACKG >< 0 THEN
114107              PPAST=:HPASS                   % ACCSESS SYSTEM SEGMENT
114111             ELSE
114112              1=:HPASS
114114            FI
114114
114114            IF X.OLDPAG/\3-1>0 OR HPASS = 2 THEN % RT AND RING 2 OR SYSTEM
114125                  X.ZXREG; CALL LOGPH                                 % FIND DATAFIELD
114127                  IF A = 0 THEN D=:A FI                               % ACCEPT BOTH INPUT AND OUTPUT
114131                  IF A = 0 THEN PE1; GO PIRET; FI                     % ILLEGAL LDN
114134                  A=:B
114135                  IF X.D1 >< PIKEY THEN PNOTP; GO PIRET FI            % CHECK KEY IN USER PARAM
114143                  IF X.D0 /\ 177700 = 143300 THEN                     % SEGMENT MUST BE FIXED BEFORE LOAD AND STORE
114150                     CALL FIXOK
114151                  FI
114151                  X:=DEMSV
114152                  X.D0=:L; * LDF D3,X
114155                  X:=X.D2; * EXR SL
114157                  TAD =:TADR
114160                  DEMSV=:B; OLDPAG=:D; PIRSV=:B
114166                  CALL DALTON; MLEV; *MST PIE
114171                  TAD:=TADR
114172                  A=:P4; T=:P3; A:=D=:P5; X=:P2
114177                  MLEV; *MCL PIE
114201                  CALL ALTOFF
114202                  A:=POK
114203            ELSE
114204               A:=PNOTP
114205            FI
114205            GO FAR PIRET
114206   RBUS
114223
114223   %      SEGNR IN A, PAGE IN D
114223   SUBR PM116,PM160,PM164,PDISA,PDISO
114223   INTEGER I
114224   PM116:
114224   %% UNFIX AND DISCONNECT ALL PROC
114224          A=:PISEG; "PIMPA"; * MON 116              % UNFIX
114227   PDISA:
114227   %% DISCONNECT ALL PROC.
114227          0=:I; K:="0";
114231          FOR I STEP 1 TO 17 DO
114235            A:=PXT(I)
114237   L1:      IF A=:D >< 0 THEN                          % ANY XT BLOCK ?
114241              0=:PXT(X)                             % YES, DISCONNECT AT LEVEL 12
114242              *IOF
114243              A:="DIS12"
114244              *IRW LV12B DP
114245              A:=D; *IRW LV12B DL
114247              LV12; *MST PID; ION
114252            FI
114252            IF K GO L2
114254          OD
114260   L2:    EXIT
114261   PDISO:
114261   % DISCONNECT ONE PROC.
114261          A:=PXT(A); K:="1"; GO L1
114265
114265   PM160: AD=:PIPPA; "PIMPA"; * MON 160;
114270          EXIT
114271
114271   PM164: A=:PISEG:="PIMPA"; * MON 2WSEG
114274          EXIT
114275   RBUS
114301
114301
114301   %==========================================================================
114301   %            F I X O K    S E G F N    C H P O    P R E A D
114301   %            P W R I T E    K R E A D    P I C A C
114301   %
114301   %            P I O C   U T I L I T Y    R O U T I N E S
114301   %
114301   %==========================================================================
114301
114301   SUBR PREAD,PWRIT,KREAD
114301   %==========================================================================
114301   %      LOAD AND STORE IN PHYSICAL MEMORY
114301   %      (64K WORDS ONLY)
114301   %==========================================================================
114301   INTEGER SAVL
114302   PREAD: A:=K1024; X+A; T:=PIOCA; *LDATX                     % DON'T LET CACH FOOL US
114306          A:=K1024; X-A; *LDATX; EXIT
114312   PWRIT: T:=PIOCA; *STATX; EXIT
114315   KREAD: A:=L=:SAVL; CALL PREAD; A SHZ -1; T:=SAVL=:P        % CONVERT TO WORD BASE
114323   RBUS
114325
114325   SUBR PICAC
114325   %      INHIBIT PIOC FROM CACH
114325   %      INPUT A REG POINTES TO FIRST PIOC PAGE
114325   INTEGER SAVA
114326   INTEGER POINTER LREG
114327   PICAC: A=:SAVA:=L=:"LREG"
114332          SAVA+PIMPG=:D; SAVA;
114336          CALL DISMCACHE; GO ERR;
114340          A:=SAVA; GO LREG
114342   ERR:   -77; GO PIRET
114344   RBUS
114346
114346
114346   %      MAKE SURE THAT SOME SEGMENTS ARE FIXED IN ALL PIOC MEMORY
114346
114346   %      INPUT B PIOC DATAFIELD
114346
114346   SUBR FIXOK,PIFIX
114346   INTEGER FPAG,DPAG
114350   SYMBOL PILO=0
114350   PIFIX: K:="0"; GO FELLS
114352   FIXOK: K:="1"
114353   FELLS: T:=HDEV; *IOXT; SHA ZIN SHR 10
114356          A =: PIOCA; *SHA ZIN 6
114360          A*4 =: FPAG; 0=: DPAG
114363          DO WHILE DPAG <= PIMPG                                 % < 77 OR 377
114367            T:=CORMBANK; DPAG SHZ 2 + FPAG =: X; *PROTE@3 LDATX  % GET PROTECT AND STATUS WORD
114375            IF A NBIT 5FIX THEN
114377              0=:PISTT
114400              IF K THEN
114402                A:=DEMSV=:B
114404                DPAG =: ZAREG
114406                PNOTFIX; GO PIRET
114410              ELSE
114411                DPAG; EXITA
114413              FI
114413            FI
114413            DPAG + 1 =: DPAG
114416          OD
114417          PISTT BONE PILO =:PISTT        % MARK LOADED
114422          EXIT
114423   RBUS
114427
114427   %      FIND OUT IF A SEGMENT ( FOUND IN SEG) IS FIXED WITHIN CURRENT PIOC
114427   %      IF SO UNFIX IT
114427
114427   %      INPUT B PIOC DATAFIELD
114427   %            A SEGMENT NUMBER
114427
114427   SUBR PISEF
114427   INTEGER FPAG
114430   INTEGER DPAG
114431   INTEGER SEG
114432   INTEGER SAVL
114433   PISEF: A=:SEG; T:=HDEV; *IOXT; SHA ZIN SHR 10
114437          A =: PIOCA; *SHA ZIN 6
114441          A*4 =: FPAG; 0=: DPAG
114444          DO WHILE DPAG <= PIMPG                            % < 77 OR 377
114450            T:=CORMBANK; DPAG SHZ 2 + FPAG =: X; *PROTE@3 LDATX  % GET PROTECT AND STATUS WORD
114456            IF A BIT 5FIX THEN
114460              DO; *PREVI@3 LDXTX
114461                WHILE X NBIT 0 AND X NBIT 1
114465              OD
114466              A:=X SHZ -2                                   % SEGMENT NUMBER IN A
114470              IF A = SEG THEN
114473                X:=L=:SAVL
114475                CALL PM116; A:=SAVL=:L                      % UNFIX
114500                EXIT
114501              FI
114501            FI
114501            DPAG + 1 =: DPAG
114504          OD
114505          EXIT
114506
114506   RBUS
114511
114511   %      CHECK IF YOU OPERATE ON LEGAL SLOT
114511
114511   SUBR CHPO
114511   CHPO:  IF DEMSV.ZAREG >> SLMAX THEN PILSL; GO PIRET; FI     % ILLEGAL SLOT
114520          A + "NDPRO" =:X ; L=:D; CALL PREAD; D=:L
114525          IF A><CURPRG THEN PNOTY; GO PIRET; FI                % YOU HAVE NOT RESERVED SLOT
114532          EXIT
114533   RBUS
114537
114537   %      CHECK IF PIOC LOADED
114537
114537   SUBR CHRUN
114537   CHRUN: IF PISTT >< 3 THEN                        % MUST BE STARTED AFTER LOAD
114543             PNOTR; GO PIRET
114545          FI
114545          EXIT
114546   RBUS
114547
114547   SUBR PISWP,PIRWP
114547   % ------------------------------------------------------------
114547   % SET/ RESET WRITTEN IN PAGE BIT AND EXSTRACT SEGMENT NO
114547   % ENTRY: A= 1 PHYS PAGE
114547   % RETURN: A= SEG. NO , T=1. PHYS PAGE NOT IN SEGMENT
114547   PISWP:K:="1"; GO FELLS
114551   PIRWP:K:="0"
114552   FELLS:
114552            T:=CORMBANK; A SHZ 2 =:X=:D
114556            *PROTE@3 LDATX  % GET PROTECT AND STATUS WORD
114557            IF A NBIT 5FIX THEN A:=X SHZ -2; EXIT; FI
114564            DO; *PREVI@3 LDATX
114565            WHILE A NBIT 0 AND A NBIT 1       % END OF PREVLINK ?
114571                A=:X                          % NO TRY PREVIOUS
114572            OD
114573            A SHZ -2=:X                       % SEG NO
114575            X:=:D                             % SAVE SEGNO IN D AND RESTORE 1. PHYS PAGE
114576            DO; *PROTE@3 LDATX;
114577                IF K THEN A BONE 5WIP
114602                ELSE A BZERO 5WIP FI
114604                *PROTE@3 STATX; PAGLI@3 LDATX
114606            WHILE A >< 0                      % END OF PAGLINK ?
114607                X:=A                          % NEXT IN PAGELINK
114610            OD
114611            T:=X SHZ -2+1                     % LAST PHYS PAGE IN T
114614            A:=D                              % SEGNO IN D
114615           EXITA
114616   RBUS
114617
114617   %

114617   %=======================================================================
114617   % 39.18     L O A D    S T O P    S T A R T    R E S S L
114617   %           R E L S L    K I C K    W K I C K    U N L O A D
114617   %
114617   %            P I O C    N O N R E S I D E N T (POF OR PIT3)  P A R T
114617   %
114617   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
114617
114617
114617   SUBR PILOA
114617   % LOAD PIOC
114617   % X: LDN
114617   % A: SEGMENT NUMBER
114617   % D: PAGE WITHIN PIOC
114617   INTEGER SEG,PAGE
114621   DOUBLE SEGPA = SEG
114621   PILOA:  T:=HDEV; *IOXT; SHA ZIN SHR 10                      % BANK NUMBER
114624           A*100+DEMSV.ZDREG =: PAGE; X.ZAREG =: SEG
114632          CALL PISEF                                % UNFIX FIRST IF ALREADY FIXED WITHIN THIS PIOC
114633          SEG BONE 17 =: SEG
114636          AD:=SEGPA; CALL PM160                     % FIX IT
114640          IF A >< 0 THEN
114641            A-;A+40; GO PIRET
114644          FI
114644          CALL PIFIX; *JMP *+1
114646          POK; GO PIRET
114650   RBUS
114656
114656   %      STOP (PANIC)
114656   SUBR  PISTO
114656   PISTO: T:=HDEV+3; A:= 60=:PWCR; *IOXT            % RESET AND HALT
114663         CALL FIXOK
114664         X:=1002; A:=0; CALL PWRIT                  % MARK AS STOPPED IN PIOC
114667         1=:PISTT
114671         POK; GO PIRET
114673   RBUS
114677
114677
114677
114677   %      START PIOC
114677   %      X: LDN
114677   %      AD: START-ADDR         =0 PIOCOS
114677   %      ON RETURN : IF ERROR A = FIRST NONFIXED PAGE
114677
114677   SUBR PISTA
114677   INTEGER LPOINTERS
114700   INTEGER LKICKP
114701   INTEGER ASAD,DELAY
114703   PISTA: T:=HDEV; *IOXT; SHA ZIN SHR 10
114706          A=:PIOCA; * SHA ZIN 6                               % SAVE PIOC BANK NUMBER
114710          CALL PICAC; CALL FIXOK
114712          X:=1002; A:=0; CALL PWRIT                           % RESET INITFLAG
114715
114715          T:=HDEV+3; A:=60; *IOXT                             % HALT AND RESET
114721          A:=0=:PWCR; *IOXT                                   % INITIATE
114724
114724   %      WAIT FOR PIOC TO GET READY
114724          -3 =: TMR
114726          DO
114726            A:=-500=:DELAY; *MIN DELAY; JMP *-1
114732            X:=1002; CALL PREAD
114734            WHILE A = 0
114735          OD
114736          0 =: TMR
114737          IF A >< PRKEY THEN PPROM; GO PIRET FI
114744   %      GIVE POINTERS TO PIOC DATAFIELD
114744   %      ALL ADDRESSES ARE CONVERTED TO WORD BASE (ND100)
114744
114744          X:=1001; CALL KREAD; A=:LPOINT
114747          A:=PIMPG; X:=LPOINT; *AAX PSIZ
114752          CALL PWRIT; A:=PIOCN; X:=LPOINT; *AAX PINO          % PIOC SIZE (PAGES) TO PIOC
114756          CALL PWRIT                                          % PIOC NUMBER (0,1..) TO PIOC
114757          X:=LPOINT; *AAX PIMBL
114761          CALL PREAD; A=:D; X:=LPOINT; *AAX PIMBH
114765          CALL PREAD; AD=: MBOXH
114767          X:=LPOINT; *AAX RTBL
114771          CALL PREAD; A=:D; X:=LPOINT; *AAX RTBH
114775          CALL PREAD; AD=:RTBOX
114777          X:=LPOINT; *AAX CPUNR
115001          A:=SYSNO; CALL PWRIT                                % ND100 CPU NUMBER
115003          X:=LPOINT; *AAX PNOPC
115005          CALL KREAD; A=:PNBOX                      % PIOC TO NORD MAILBOX
115007          X:=LPOINT; *AAX NPOPC
115011          CALL KREAD; A=:MASTA                      % NORD TO PIOC MAILBOX
115013
115013   %      KICK TABLE POINTERS TO DATAFIELD
115013          X:=LPOINT; *AAX KICKP
115015          CALL KREAD; A =:LKICKP=:PKICK             % ADDR KICKTABLE
115020          X:=LKICKP; *AAX XPTN
115022          CALL KREAD; A=:"PTN"
115024          X:=LKICKP; *AAX XNTP
115026          CALL KREAD; A=:"NTP"
115030          X:=LKICKP; *AAX XPIPR
115032          CALL KREAD; A=:"PIPRO"
115034          X:=LKICKP; *AAX XNDPR
115036          CALL KREAD; A=:"NDPRO"
115040          X:=LKICKP; *AAX XNMAI
115042          CALL KREAD; A=:"PNMAIL"
115044          X:=LKICKP; *AAX XPMAI
115046          CALL KREAD; A=:"NPMAIL"
115050
115050   %      SET START-ADDR
115050
115050          X:=LPOINT; *AAX PIOCO
115052          CALL KREAD; A=:ASAD                       % ADDRESS OF LOCATION HOLDING START ADDRESS
115054          IF DEMSV.ZAREG >< 0 THEN
115057            X:=ASAD; CALL PWRIT
115061          FI
115061          IF DEMSV.ZDREG >< 0 THEN
115064            X:=ASAD+1;  CALL PWRIT
115067          FI
115067
115067
115067   %      SO WE CAN GIVE THE START COMMAND
115067
115067          X:=MASTA; *AAX NPFUN
115071          A:=MPIOC; CALL PWRIT
115073          X:=MASTA; *AAX NPTIG
115075          A:=TRIG; CALL PWRIT
115077          A:=11; T:=HDEV+3; *IOXT
115103          3 =: PISTT                                % MARK AS STARTED AFTER LOAD
115105          POK; GO PIRET
115107   RBUS
115123
115123   %      RESERVE SLOT
115123   %      RESERVE SLOT NUMBER GIVEN IN A-REG
115123
115123   SUBR PIRES
115123   PIRES: CALL CHRUN
115124          IF DEMSV.ZAREG >> SLMAX THEN PILSL; GO PIRET; FI     % ILLEGAL SLOT
115133          A + "NDPRO" =: X; CALL PREAD
115136          IF A >< 0 THEN PSLBS GO PIRET; FI                    % IF FREE THEN
115141          CURPRG; CALL PWRIT                                  % SET IT BUSY BY ME
115143          POK; GO PIRET
115145   RBUS
115153
115153   %      RELEASE SLOT
115153   %      THE SLOT TO BE RELEASED IN A-REG
115153
115153   SUBR PIREL
115153   PIREL: CALL CHRUN
115154          IF DEMSV.ZAREG >> SLMAX THEN PILSL; GO PIRET; FI     % ILLEGAL SLOT
115163          A + "NDPRO" =: X ; A:=0; CALL PWRIT
115167          POK; GO PIRET
115171   RBUS
115175
115175   %      KICK THROUGH SLOT
115175   %      THE SLOT NUMBER IN A-REG, INFO IN D-REG
115175
115175   SUBR PIKIC
115175   PIKIC: CALL CHRUN; CALL CHPO
115177          IF DEMSV.ZDREG >< 0 THEN
115202            A := "NPMAIL" + DEMSV.ZAREG =: X; CALL PREAD
115207            IF A >< 0 THEN PFULL; GO PIRET; FI
115212            T:=DEMSV.ZDREG; A := "NPMAIL" + X.ZAREG =: X; T=:A; CALL PWRIT
115221          FI
115221          A := "NTP" + DEMSV.ZAREG =: X; TRIG; CALL PWRIT
115227          A:=PWCR BONE BNDC; T:=HDEV+3; *IOXT
115234          POK; GO PIRET
115236   RBUS
115244
115244   %      WAIT FOR PIOCINF
115244   %      THE SLOT NUMBER IN A-REG, INFO IN D-REG
115244
115244   SUBR PIWKI
115244   PIWKI: CALL CHRUN; CALL CHPO
115246          A := "PNMAIL" + DEMSV.ZAREG=:X=:D; CALL PREAD
115254          IF A >< 0 THEN                                     % ANY INFO ?
115255            A =: DEMSV.ZDREG                                 % GIVE INFO WORD TO USER
115257            D=:X; A:=0; CALL PWRIT                           % MAILBOX EMTY
115262            POK; GO PIRET
115264          ELSE
115265            PNOMES; GO PIRET                                  % NO MESSAGE FOR YOU
115267          FI
115267   RBUS
115275
115275   %      UNLOAD PIOC    (UNFIX SEGMENTS FIXED IN PIOC MEMORY)
115275
115275   SUBR PIUNL
115275   INTEGER SEG,FPAG,LPAG
115300   PIUNL: T:=HDEV; *IOXT
115302          A/\ 177400 SHZ -2 =: FPAG+PIMPG=:LPAG     % (BANK*100B*4)/4 = 1. PHYS PAGE
115307          T+3; A:= 60; *IOXT                        % STOP IT FIRST
115312          DO WHILE FPAG <=LPAG
115316            FPAG; CALL PIRWP; GO PIRET; T=:FPAG     % GET SEGNO AND RESET WRITTEN IN PAGE
115322            CALL PM116                              % UNFIX
115323          OD
115324          0=:PISTT                                  % NOT LOADED
115325          POK; GO PIRET
115327   RBUS
115333   SUBR PIDIS
115333   %-----------------------------------------------------------------------
115333   % DISCONNECT FROM MESSAGE SYSTEM
115333   %
115333   %-----------------------------------------------------------------------
115333   PIDIS:
115333         IF DEMSV.ZAREG = -1 THEN
115340           CALL PDISA;
115341         ELSE
115342           IF A <<= 17 THEN
115345              CALL PDISO;
115346              A:=D=:DEMSV.ZDREG
115351            ELSE
115352              PILF; GO PIRET
115354           FI
115354         FI
115354         POK; GO PIRET
115356   RBUS
115362   SUBR PIDLO,PIDUN
115362   %-----------------------------------------------------------------------
115362   % LOAD/UNLOAD PIOC  FROM USER MEMORY
115362   %  ENTRY: X=MONITOR CALL DF
115362   %         B=PIOC DF
115362   %
115362   %-----------------------------------------------------------------------
115362   %PARAMETER LIST:
115362   DISP 0
115362          DOUBLE  POINTER DP0
115362   PSID
115362
115362        INTEGER PBANK        % PIOC BANK
115363        INTEGER PPADR        % PIOC BANK ADDR
115364        DOUBLE  PIADR=PBANK  % PIOC ADDRESS
115364        INTEGER PIDIP
115365        INTEGER PIDF=PIDIP
115365        INTEGER PMONB        % ADDRESS USER MEMORY
115366        INTEGER PMONL        % NO OF WORD TO TRANSF
115367        INTEGER OOLD         % OLDPAGE
115370        INTEGER PFLAG        % =0 FROM USER,=1 TO USER
115371
115371   PIDUN:1=:PFLAG
115373         GO FELL
115374   PIDLO:0=:PFLAG
115375
115375   FELL: X.OLDPAGE=:OOLD=:D
115400         A:=B=:PIDF                   % MON DF
115402         A:=PIRSV=:B                  % B= PARAM PIONTER
115404
115404         CALL DALTON
115405         DP0 =:PIADR; "P1"=:PMONB; P2=:PMONL
115413         CALL ALTOFF
115414         CALL GET0; MLEV; *MST PIE
115417         A:=PIDF=:B; *2BANK
115422         CALL FIXOK
115423
115423         AD:=PIADR SHZ -1; A=:T;D=:L   % PIOC OFSET BYTES TO WORDS
115427         A:=PIOCA; 0=:D                % PIOC START BANK TO WORDS IN AD
115431         D+L; A:=A+C+T; AD=:PIADR      % AD PHYS START ADDR
115435         OOLD=:D; CALL DALTON
115440         A:=PMONB=:B
115442         PFLAG; *BLDA 00 DA
115444         A:=PMONL; A-;A=:PMONL
115447         AD:=PIADR; A=:T;D=:X
115452   LOOP:   IF K THEN
115454             * LDATX; STA ,B
115456            ELSE
115457             * LDA ,B; STATX
115461           FI
115461           B+1; X+1; IF X=0 THEN T+1; FI
115466         MIN PMONL;GO LOOP
115470         CALL ALTOFF
115471         A:=POK; GO PIRET
115473   RBUS
115501   SUBR PIDWS
115501   %-----------------------------------------------------------------------
115501   % PERFORM WSEG ON ALL SEGMENTS IN PIOC MEMORY
115501   %
115501   %-----------------------------------------------------------------------
115501         INTEGER FPAG,LPAG,PIDF
115504
115504   PIDWS:A:=B=:PIDF
115506         CALL GET0; MLEV; *MST PIE
115511         PIDF=:B; *2BANK
115514         CALL FIXOK
115515         T:=HDEV; *IOXT
115517         A/\ 177400 SHZ -2 =:FPAG+PIMPG=:LPAG     % (BANK*100B*4)/4 = 1. PHYS PAGE
115524         DO WHILE FPAG <=LPAG
115530            FPAG; CALL PISWP; GO ERR; T=:FPAG     % SET WRITTEN IN PAGE, AND GET SEGNO
115534            CALL PM164                            % WSEG
115535         OD
115536         A:=POK; GO PIRET
115540   ERR:  A:=DEMSV=:B
115542         GO PIRET
115543   RBUS
115552
115552   SUBR PITIM
115552   %===================================================================
115552   % TIMOUT AFTER REMOVING RESET AND START
115552   % (TMSUB=PITIM)
115552   %===================================================================
115552   PITIM: L=:D;
115553          X := 1002; A:=1; CALL PWRIT;       % SET FLAG TO STOP LOOP
115556          D=:P
115557   RBUS
115561
115561   *"
"115561   @DEV 1
115561   @DEV (S-S-L)RP-P2-TAD:NPL
115561   *"BADAD
"115561

115561   %%%%%%%%%%%%%%%%%%%%%%%%%%%%% RP-P2-TAD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
115561
115561   %==============================================================================
115561   %       B U F F E R   P O O L   R O U T I N E S
115561   %==============================================================================
115561   %
115561   % (R)   P U T P O O L              (ROUTINE IS DUPLICATED ON MPIT)
115561   %
115561   % ROUTINE TO PUT A BUFFER IN FREE POOL OF OUTPUT DATAFIELD
115561   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
115561   % ENTRY:    AD-REG - BUFFER-ADDRESS
115561   %            X-REG - BUFFER ID
115561   %            B-REG - TAD OUTPUT DATAFIELD
115561   SUBR PUTPOOL
115561   INTEGER XREG
115562   PUTPOOL: *IOF
115563          IF X=0 GO RETU; X=:XREG                   % DUMMY CALL
115565          A=:T; D=:X; AD:=POOLLI; *STDTX            % PUT OLD POOLLI IN NEW BUFFER
115571          X+2; A:=XREG; *STATX                      % PUT BUFFID IN NEW BUFFER
115574          T=:A; X-2=:D; AD=:POOLLI                  % PUT NEW BUFFER IN POOLLI
115600   RETU:  *ION; EXIT
115602   RBUS
115602
115602   %==============================================================================
115602   % (R)   G E T P O O L              (ROUTINE IS DUPLICATED ON MPIT)
115602   %
115602   % ROUTINE TO GET A BUFFER FROM FREE-POOL
115602   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
115602   % ENTRY:       B-REG - TAD OUTPUT DATAFIELD
115602   % SKIP RETURN: OK
115602   %              FOLLOWING VARIABLES IN OUTPUT DATAFIELD IS MODIFIED:
115602   %              BUFFID
115602   %              TDTADD
115602   %              TDBTPT
115602   %              REMSIZ
115602   %
115602   % RETURN:      ERROR   A-REG < 0 XMSG ERROR , ELSE POOL EMPTY
115602
115602   SUBR GETPOOL
115602   GETPOOL: *IOF
115603          IF BUFFID=0 THEN
115605             POOLLI; IF A=0 AND D=0 GO NOPOL           % POOL EMPTY
115611             A=:T; D=:X; *LDDTX                        % GET NEXT IN CHAIN
115614             AD=:POOLLI                                % UPDATE POOL POINTER
115615             T=:A; X=:D; *STZTX                        % ENSURE REF&FUNC IS ZERO
115620             AD=:TDTADD; X+2; *LDATX                   % SAVE ADDRESS AND GET BUFFID
115623             A=:BUFFID; BUDIS=:TDBTPT                  % SET BUFFID AND BYTE POINTER
115626             41ITAD.FBSIZ-BUDIS=:REMSIZ                % SET REMAINING SIZE
115632          FI; *ION
115633          EXITA
115634   NOPOL: AD=:TDTADD; 0=:BUFFID=:REMSIZ=:TDBTPT; *ION; EXIT
115642   RBUS
115643
115643   %==============================================================================
115643   % (R)   M O V I T O                (ROUTINE IS DUPLICATED ON MPIT)
115643   %
115643   % ROUTINE TO RELOCATE INPUT BUFFER AS OUTPUT BUFFER
115643   % ENTRY:       B-REG - OUTPUT-DATAFIELD
115643   SUBR MOVITO
115643   MOVITO: 41ITAD.BUFFID=:BUFFID; X.TDTADD=:TDTADD
115650           X.FBSIZ-BUDIS=:REMSIZ; BUDIS=:TDBTPT; 0=:CURMES
115656           A:=0=:D; AD=:X.TDTADD
115661           0=:X.BUFFID=:X.REMBYT=:X.TDBTPT=:X.REMSIZ=:X.CURMES
115666           EXIT
115667   RBUS
115670

115670   %==============================================================================
115670   %       R O U T I N E S   T O   A C T I V A T E   D R I V E R
115670   %==============================================================================
115670   %
115670   % (R)   S N D B U F   S N D W T
115670   %
115670   % ROUTINES TO SEND OUTPUT BUFFER,
115670   % ALWAYS CALLED WITH MONITOR LEVEL DISABLED
115670   % IF SNDWT, PROCESS IS SET IN IO-WAIT
115670   % ENTRY:     B-REG - TAD OUTPUT DATAFIELD
115670   %            A-REG - RESPONSE NO. IF SNDWT
115670   SUBR SNDBUF,SNDWT
115670   SNDWT: *IOF
115671          A=:RSPNUM; 1=:MTOR
115674          RTREF.STATUS BONE 5WAIT=:X.STATUS
115700   SNDBUF:*IOF
115701          IF BUFFID><0 THEN
115703             IF REMSIZ><41ITAD.FBSIZ-4 THEN     % SOMETHING IN OUTPUT BUFFER?
115711                TDRADDR; *IRW LV10B DB          % B = TAD RESIDENT OUTPUT DATAFIELD
115713                "BDROUT"; *IRW LV10B DP         % P = DRIVER OUTPUT ROUTINE
115715                LV10; *MST PID
115717             FI
115717          FI; *ION
115720          EXITA
115721   RBUS
115726
115726   %==============================================================================
115726   % (R)   C B R E R S P
115726   %
115726   % IF TAD, ROUTINE ACTIVATES DRIVER TO SEND ESCAPE-RESPONSE
115726   % ENTRY: B-REG - INPUT-DATAFIELD (OUTSIDE RESIDENT)
115726   % CALLED WITH INTERRUPT OFF
115726   % RETURN EXIT AD1
115726   SUBR CBRERSP
115726   CBRERSP: IF TYPRING NBIT 5BAD THEN EXITA FI
115732           TDRADDR; *IRW LV10B DB     % B = TAD RESIDENT INPUT DATAFIELD
115734           "BERESP"; *IRW LV10B DP    % P = DRIVER ESCAPE-RESPONSE
115736           LV10; *MST PID
115740           EXITA
115741   RBUS
115743
115743   %==============================================================================
115743   % (R)   B D T O U
115743   %
115743   % NORMAL OUTPUT TIMEOUT ROUTINE FOR TAD, CALLED WITH INTERUPT OFF
115743   % ROUTINE SENDS OUTPUT BUFFER AT TIMEOUT
115743   % B = TAD OUTPUT DATAFIELD
115743   SUBR BDTOU
115743   INTEGER POINTER LREG
115744   BDTOU: A:=L=:"LREG"; MLEV; *MCL PIE; ION
115751          CALL BOSTAD; CALL SNDBUF; 0/\0; TTMR=:TMR
115756          MLEV; *IOF; MST PIE
115761          GO LREG
115762   RBUS
115764
115764   %==============================================================================
115764   % (R)  M T D T O U
115764   %
115764   % SPECIAL OUTPUT TIMEOUT ROUTINE FOR TADS WHEN MAIL SYSTEM
115764   % SENDS MESSAGES.
115764   % B = TAD OUTPUT DATAFIELD
115764   SUBR MTDTOU
115764   INTEGER POINTER LREG
115765   MTDTOU: A:=L=:"LREG"; MLEV; *MCL PIE; ION
115772          CALL BOSTAD
115773          IF 41ITAD.PORTNO=0 GO RETU               % NOT CONNECTED ANYMORE
115776          AD:=POOLLI
115777          IF A=0 AND D=0 THEN                       % BUFFER POOL EMPTY
116002             IF BUFFID=0 AND X.BUFFID=0 THEN        % NO BUFFERS IN TAD AT ALL
116006                IF BRCOUNT=0 GO NBACT               % C-T DOES NOT RETURN BUFFERS
116010             FI
116010          FI
116010          "MSNDBUF"; GO CONT                        % SEND MAIL BUFFER DRIVER ROUTINE
116012   NBACT: "MRELBUF"                                 % RELEASE MAIL BUFFER DRIVER ROUTINE
116013   CONT:  *IOF; IRW LV10B DP                        % DRIVER FUNCTION
116015          TDRADDR; *IRW LV10B DB                    % B-REG TAD OUTPUT RES DATAFIELD
116017          LV10; *MST PID; ION                       % SET LEVEL 10
116022   RETU:  "BDTOU"=:"TMSUB"                          % RESET NORMAL TIMEOUT ROUTINE
116024          MLEV; *IOF; MST PIE
116027          GO LREG
116030   RBUS
116036
116036

116036   %==============================================================================
116036   %       M E S S A G E   H E A D E R S   R O U T I N E S
116036   %==============================================================================
116036   %
116036   % (R)  W R M H E A D
116036   %
116036   % ROUTINE TO WRITE MESSAGE HEADER ON EVEN BYTE
116036   %      ENTRY:   A-REG - MESSAGE HEADER
116036   %               B-REG - TAD OUTPUT DATAFIELD
116036   %      RETURN:  EXIT
116036   %
116036   SUBR WRMHEAD
116036   WRMHEAD: A=:D; T:=TDTAFI; X:=TDTALA
116041          IF TDBTPT BIT "0" THEN                    % ODD START, CREATE PAD BYTE
116044             A SHZ -1; X+A; *LDATX
116047             A/\177400; *STATX
116051             MIN TDBTPT; REMSIZ-1=:REMSIZ
116055          FI
116055          X:=TDTALA
116056          TDBTPT SHZ -1; X+A; D=:A; *STATX                    % WRITE IN BUFFER
116063          TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ
116071          EXIT
116072   RBUS
116073
116073   %==============================================================================
116073   % (R)   C R E M E S
116073   %
116073   % ROUTINES TO CREATE MESSAGE-HEADERS IN XMSG BUFFER  (TAD OUTPUT)
116073   %
116073   % ENTRY:     A-REG - MESSAGE TYPE
116073   %            T-REG - REQUIRED I-FIELD SIZE
116073   %            B-REG - TAD OUTPUT DATAFIELD
116073   %
116073   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116073   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116073   %
116073   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116073   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116073   %                                 A-REG: <0  XMSG ERROR CODE
116073   %
116073   SUBR CREMES
116073   INTEGER AREG,TREG; INTEGER POINTER LREG
116076   CREMES: A=:AREG:=L=:"LREG"; T=:TREG
116102          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116106          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116107          IF TDBTPT BIT "0" THEN T+3 ELSE T+2 FI              % ODD OR EVEN START IN BUFFER
116115          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116122          AREG SHZ 10; CALL WRMHEAD                           % WRITE MESSAGE HEADER
116125          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116132          MIN "LREG"; GO LREG
116134   NOPOL: A:=1; GO LREG
116136   RBUS
116140
116140   %==============================================================================
116140   % (R)   G E T M E S                (ROUTINE IS DUPLICATED ON MPIT)
116140   %
116140   % ROUTINE TO FIND NEXT MESSAGE HEADER IN XMSG BUFFER  (TAD INPUT)
116140   % ENTRY:     B-REG - TAD INPUT DATAFIELD
116140   %
116140   % RETURN:    SKIP-RETURN:  OK     A-REG:  MESSAGE-TYPE
116140   %                                 T-REG:  NUMBER OF BYTES IN I-FIELD
116140   %                                 TAD DATAFIELD BUFFER VARIABLES
116140   %                                 REMSIZ,TDBTPT,CURMES,REMBYT ARE UPDATED
116140   %
116140   %            NOSKIP:       ERROR  A-REG:  1  NO INPUT BUFFER
116140   %                                 A-REG:  2  BUFFER IS EMPTY
116140   %                                 A-REG:  3  INCONSISTENCY, MESSAGE BIGGER THAN BUFFER
116140   SUBR GETMES
116140   GETMES: IF BUFFID=0 THEN A:=1; EXIT FI                     % NO BUFFER
116144   TSTSP:  IF REMSIZ<2 THEN T=:A; EXIT FI
116152           T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1
116157           X+A; *LDATX
116161           MIN TDBTPT
116162           IF D BIT "0" THEN                                  % ODD BYTE
116164              IF A/\377=0 THEN REMSIZ-1=:REMSIZ; GO TSTSP FI  % FIRST BYTE FOUND
116172              A=:CURMES; X+1; *LDATX
116175              A SHZ -10; MIN TDBTPT; GO RCHK                  % RETURN AND CHECK
116200           FI
116200           A=:T SHZ -10
116202           IF A=0 THEN
116203              REMSIZ-1=:REMSIZ; GO TSTSP                      % PAD BYTE
116207           FI
116207           A=:CURMES:=T/\377; MIN TDBTPT
116213   RCHK:   IF A>REMSIZ-2 THEN A:=3; EXIT FI                   % INCONSISTENT MESSAGE
116221           A=:T+1-=:REMBYT; X:=REMSIZ-2=:REMSIZ
116230           A:=CURMES; EXITA                                   % MESSAGE FOUND
116232   RBUS
116233
116233   %==============================================================================
116233   % (R)   C R H E E V
116233   %
116233   % ROUTINE LIKE CREMES BUT BYTE COUNTER IS ALSO WRITTEN
116233   % USED WHEN MESSAGE IS COMPLETED BY CALLING ROUTINE
116233   % MESSAGE HEADER IS CREATED ON EVEN BYTE
116233   %
116233   % ENTRY:     A-REG - MESSAGE TYPE
116233   %            T-REG - REQUIRED I-FIELD SIZE
116233   %            B-REG - TAD OUTPUT DATAFIELD
116233   %
116233   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116233   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116233   %
116233   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116233   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116233   %
116233   SUBR CRHEEV
116233   INTEGER AREG,TREG; INTEGER POINTER LREG
116236   CRHEEV: A=:AREG:=L=:"LREG"; T=:TREG
116242          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116246          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116247          IF TDBTPT BIT "0" THEN T+3 ELSE T+2 FI              % ODD OR EVEN START IN BUFFER
116255          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116262          AREG SHZ 10+TREG; CALL WRMHEAD                      % WRITE MESSAGE HEADER
116266          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116273          MIN "LREG" GO LREG
116275   NOPOL: A:=1; GO LREG
116277   RBUS
116301
116301   %==============================================================================
116301   % (R)   C R H E O D
116301   %
116301   % ROUTINE LIKE CREMES BUT BYTE COUNTER IS ALSO WRITTEN
116301   % USED WHEN MESSAGE IS COMPLETED BY CALLING ROUTINE
116301   % MESSAGE HEADER IS CREATED ON ODD BYTE
116301   %
116301   % ENTRY:     A-REG - MESSAGE TYPE
116301   %            T-REG - REQUIRED I-FIELD SIZE
116301   %            B-REG - TAD OUTPUT DATAFIELD
116301   %
116301   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116301   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116301   %
116301   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116301   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116301   %
116301   SUBR CRHEOD
116301   INTEGER AREG,TREG; INTEGER POINTER LREG
116304   CRHEOD: A=:AREG:=L=:"LREG"; T=:TREG
116310          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116314          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116315          IF TDBTPT NBIT "0" THEN T+3 ELSE T+2 FI             % ODD OR EVEN START IN BUFFER
116323          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116330          IF TDBTPT NBIT "0" THEN A:=0; CALL STORBYT FI       % EVEN START, CREATE PAD BYTE
116335          AREG; CALL STORBYT; TREG; CALL STORBYT              % WRITE TYPE AND BYTE COUNTER
116341          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116346          MIN "LREG"; GO LREG
116350   NOPOL: A:=1; GO LREG
116352   RBUS
116354
116354
116354   %==============================================================================
116354   % (R)   U P D M B C
116354   %
116354   % ROUTINE TO UPDATE MESSAGE BYTE COUNT
116354   % ENTRY:       A-REG - NUMBER OF BYTES
116354   %              B-REG - TAD OUTPUT DATAFIELD
116354   % SKIP RETURN: OK
116354   % RETURN:      NOT ENOUGH SPACE
116354   SUBR UPDMBC
116354   UPDMBC: A=:D; T:=TDTAFI; X:=TDTALA
116357          IF NOBDIS BIT "0" THEN                    % BYTE COUNT ON ODD BYTE
116362             A SHZ -1; X+A; *LDATX                  % READ BYTE COUNT
116365             A=:T; A/\177400; A:=:T; A/\377
116371             A+D; T=:D; IF A>=400 THEN EXIT FI      % MESSAGE FULL?
116377             A\/D
116400          ELSE                                      % BYTE COUNT ON EVEN BYTE
116401             A SHZ -1; X+A; *LDATX                  % READ BYTE COUNT
116404             A=:T; A/\377; A:=:T; A SHZ -10
116410             A+D; T=:D; IF A>=400 THEN EXIT FI      % MESSAGE FULL?
116416             A SHZ 10; A\/D
116420          FI
116420          T:=TDTAFI; *STATX                         % WRITE BACK BYTE COUNT
116422          EXITA
116423   RBUS
116426

116426   %==============================================================================
116426   %       R O U T I N E S   T O   A C C E S S   D A T A   P A R T
116426   %==============================================================================
116426   %
116426   % (R)   G E T M B C
116426   %
116426   % ROUTINE TO FIND NUMBER OF BYTES IN CURRENT OUTPUT MESSAGE
116426   %
116426   % ENTRY:     B-REG - TAD OUTPUT DATAFIELD
116426   % RETURN:    A-REG - BYTE COUNT
116426   SUBR GETMBC
116426   GETMBC: IF NOBDIS=0 THEN A:=400; EXIT FI
116432           A=:D SHZ -1; T:=TDTAFI; X:=TDTALA; X+A; *LDATX
116440           IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI
116445           EXIT
116446   RBUS
116450
116450   %==============================================================================
116450   % (R)   B Y T P U T
116450   %
116450   % ROUTINE TO PUT A BYTE IN XMSG BUFFER  (TAD OUTPUT)
116450   %
116450   % ENTRY:     A-REG - BYTE
116450   %            B-REG - TAD OUTPUT DATAFIELD
116450   %
116450   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116450   %                                 REMSIZ AND TDBTPT IS UPDATED
116450   %
116450   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116450   %                                 A-REG:  2  OUTPUT BUFFER FULL
116450   %                                 A-REG:  3  MESSAGE FULL
116450   SUBR BYTPUT
116450   INTEGER AREG; INTEGER POINTER LREG
116452   BYTPUT: A/\377=:AREG:=L=:"LREG"
116456          IF BUFFID=0 THEN A:=1; EXIT FI               % OUTPUT BUFFER PRESENT?
116462          IF REMSIZ<=0 THEN A:=2; EXIT FI              % BUFFER FULL?
116467          A:=1; CALL UPDMBC; GO MSFUL                  % UPDATE MESSAGE BYTE COUNT
116472          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116500          IF D BIT "0" THEN                            % DESTINATION ODD BYTE
116502             *LDATX
116503             A/\177400\/AREG
116505          ELSE                                         % DESTINATION EVEN BYTE
116506             AREG SHZ 10
116510          FI
116510          T:=TDTAFI; *STATX                         % PUT BYTE IN BUFFER
116512          REMSIZ-1=:REMSIZ; MIN TDBTPT
116516          MIN "LREG"; GO LREG                       % UPDATE BUFFER COUNTERS AND RETURN
116520   MSFUL: A:=3; GO LREG                             % MESSAGE IS FULL
116522   RBUS
116525
116525   %==============================================================================
116525   % (R)   W O R D P U T
116525   %
116525   % ROUTINE TO PUT A WORD IN XMSG BUFFER  (TAD OUTPUT)
116525   %
116525   % ENTRY:     A-REG - WORD
116525   %            B-REG - TAD OUTPUT DATAFIELD
116525   %
116525   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116525   %                                 REMSIZ AND TDBTPT IS UPDATED
116525   %
116525   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116525   %                                 A-REG:  2  OUTPUT BUFFER FULL
116525   %                                 A-REG:  3  MESSAGE FULL
116525   SUBR WORDPUT
116525   INTEGER AREG; INTEGER POINTER LREG
116527   WORDPUT: A=:AREG:=L=:"LREG"
116532          IF BUFFID=0 THEN A:=1; EXIT FI               % OUTPUT BUFFER PRESENT?
116536          IF REMSIZ<=1 THEN A:=2; EXIT FI              % BUFFER FULL?
116544          A:=2; CALL UPDMBC; GO MSFUL                  % UPDATE MESSAGE BYTE COUNT
116547          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116555          IF D BIT "0" THEN                            % ODD START IN BUFFER
116557             *LDATX
116560             A/\177400=:T; AREG
116563             A SHZ -10; A\/T; T:=TDTAFI; *STATX        % WRITE FIRST BYTE
116567             AREG SHZ 10; X+1; *STATX                  % WRITE SECOND BYTE
116573          ELSE                                         % EVEN START IN BUFFER
116574             AREG; *STATX                              % WRITE WORD IN BUFFER
116576          FI
116576          REMSIZ-2=:REMSIZ; MIN TDBTPT; MIN TDBTPT  % UPDATE BUFFER COUNTERS
116603          MIN "LREG"; GO LREG                       % RETURN
116605   MSFUL: A:=3; GO LREG                             % MESSAGE IS FULL
116607   RBUS
116611
116611   %==============================================================================
116611   % (R)   B Y T G E T
116611   %
116611   % ROUTINE TO GET A BYTE IN XMSG BUFFER  (TAD INPUT)
116611   % MUST BE CALLED WITH INTERUPT OFF!
116611   % ENTRY:     B-REG - TAD INPUT DATAFIELD
116611   %
116611   % RETURN:    SKIP-RETURN:  OK     A-REG:  BYTE
116611   %                                 TAD DATAFIELD BUFFER VARIABLES
116611   %                                 REMSIZ,REMBYT ARE UPDATED
116611   %
116611   %            NOSKIP:       ERROR  A-REG:  0  MESSAGE EMPTY
116611   %                                 A-REG:  1  NO INPUT BUFFER PRESENT
116611   %                                 A-REG:  2  BUFFER IS EMPTY
116611   SUBR BYTGET
116611   BYTGET:IF BUFFID=0  THEN A:=1; EXIT FI                % NO INPUT BUFFER
116615          IF REMSIZ<=0 THEN A:=2; EXIT FI                % INPUT BUFFER EMPTY
116622          IF REMBYT=0  THEN EXIT FI                      % MESSAGE EMPTY
116625          MIN REMBYT; GO CONT
116627          A:=0=:CURMES; EXIT                             % MESSAGE EMPTY
116632   CONT:  T:=TDTAFI; X:=TDTALA
116634          TDBTPT=:D SHZ -1; X+A; *LDATX                  % GET WORD WITH BYTE
116641          IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI     % GET WANTED BYTE
116646          T:=REMSIZ-1=:REMSIZ; MIN TDBTPT
116652          EXITA
116653   RBUS
116654
116654   %==============================================================================
116654   % (R)   L O A D B Y T
116654   %
116654   % ROUTINE TO LOAD A BYTE FROM THE XMSG BUFFER ACCORDING TO TDBTPT
116654   % TDBTPT IS INCREMEMENTED
116654   % ENTRY:     B-REG  - TAD-DATAFIELD  INPUT OR OUTPUT
116654   % RETURN:    A-REG  - BYTE   (OTHER REGISTERS IS NOT MODIFIED)
116654   SUBR LOADBYT
116654   INTEGER XREG,TREG,DREG
116657   LOADBYT:
116657          T=:TREG:=D=:DREG; X=:XREG
116663          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A; *LDATX
116672          MIN TDBTPT; IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI
116700          T:=DREG=:D:=TREG; X:=XREG; EXIT
116705   RBUS
116706
116706   %==============================================================================
116706   % (R)   S T O R B Y T              (ROUTINE IS DUPLICATED IN MPIT)
116706   %
116706   % ROUTINE TO STORE A BYTE IN THE XMSG BUFFER ACCORDING TO TDBTPT
116706   % TDBTPT AND REMSIZ IS UPDATED
116706   % ENTRY:     B-REG  - TAD-DATAFIELD  INPUT OR OUTPUT
116706   %            A-REG  - BYTE
116706   % RETURN:    NO REGISTERS MODIFIED
116706   SUBR STORBYT
116706   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
116712   STORBYT:
116712          TAD=:TADREG; X=:XREG
116714          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116722          IF D BIT "0" THEN
116724             *LDATX
116725             A/\177400=:T; AREG/\377\/T; T:=TDTAFI; *STATX
116734          ELSE
116735             AREG SHZ 10; *STATX
116740          FI
116740          MIN TDBTPT; REMSIZ-1=:REMSIZ
116744          TAD:=TADREG; X:=XREG; EXIT
116747   RBUS
116751

116751   %==============================================================================
116751   %       A U X I L A R Y   R O U T I N E S   F O R   M O N I T O R   C A L L S
116751   %==============================================================================
116751   %
116751   % (R)   R E D O M
116751   %
116751   % ROUTINE TO CAUSE MONITOR CALL TO BE REDONE
116751   % ENTRY:     B = DATAFIELD
116751   %            X = RT-PROGRAM
116751   %            D = WORKING AREA
116751   %            MONITOR LEVEL DISABLED
116751   SUBR REDOM
116751   REDOM:                                             % RESET TAD STACK
116751          D:=:B; ZPREG-1=:ZPREG; D:=:B                % REEXECUTE MONITOR CALL
116756          IF TDRADDR.RTRES-RTREF=0 THEN               % RESERVING PROGRAM?
116762             IF RTREF.STATUS NBIT 5REP AND TDRADDR.ISTATE=0 THEN  % IF NOT 5REP OR NOWAIT
116771                RTREF.STATUS BONE 5WAIT=:X.STATUS
116775                2=:TDRADDR.ISTATE
117000             FI
117000          FI
117000          D=:B; GO RETSTUPR
117002   RBUS
117004
117004   %==============================================================================
117004   % (R)   I E D C H K
117004   %
117004   % ROUTINE TO CHECK IF INPUT IS DONE WHILE DELAYED ESCAPE ACTION IS ON
117004   % ENTRY: B = INPUT-DATAFIELD
117004   % ERROR: EXIT.  A = ERROR-CODE: INPUT DONE IN DELAYED ESCAPE ACTION
117004   % OK:    SKIP RETURN
117004
117004   SUBR IEDCHK
117004   INTEGER DELMASK:=174377  % ZERO 5ESCLOFF, 5WESC, 5WLOC
117005   IEDCHK: IF FLAGB BIT 5ESCLOFF THEN
117010              IF T:=TYPRING BIT 5BAD THEN           %% T A D  ONLY
117013                IF A BIT 5WESC THEN                 %  ESCAPE WAITING
117015                   *IOF                             %
117016                   L=:D; CALL CBRERSP; 0/\0; D=:L   %  SEND-RESPONSE
117022                FI                                  %
117022              FI                                    %%
117022              *IOF
117023              FLAGB/\DELMASK=:FLAGB; *ION
117027              A:=TER00; EXIT
117031           FI
117031           A:=0; EXITA
117033   RBUS
117035
117035   %==============================================================================
117035   % (R)   C N V E R R
117035   %
117035   %      SUBROUTINE TO CONVERT FROM XMSG ERROR
117035   %      TO STANDARD ERROR CODE.
117035   SUBR CNVERR
117035   CNVERR: A-\/XKXXX; EXIT
117040   RBUS
117041

117041   %==============================================================================
117041   %       I O S E T   R O U T I N E S
117041   %==============================================================================
117041   %
117041   % (R)   C T I B A D
117041   %
117041   % INPUT IOSET ROUTINE FOR TAD, CALLED IN IOF
117041   % ENTRY: B = WORKING AREA
117041   %        X = RESIDENT INPUT-DATAFIELD
117041   %        A = CONTROL
117041   SUBR CTIBAD
117041   INTEGER XREG,BREG,TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER POINTER LREG
117047   CTIBAD: TAD=:TADREG; X=:XREG:=:B; X=:BREG:=L=:"LREG"; MLEV; *MCL PIE; ION
117060          CALL BISWTAD
117061          IF PORTNO=0 GO RETU
117063          IF AREG=-1 THEN                    % CLEAR BUFFER
117067             CALL CLIDAT; 0/\0
117071             41OTAD=:B
117073   NXBFF:    7RESE; T:=0; CALL CREMES; GO ECHEC
117077             7RECO; CALL SNDWT; 0/\0; GO RETU                  % SEND RESET AND WAIT FOR RESPONSE
117103   ECHEC:    IF A=2 THEN
117106                IF 41ITAD.BUFFID><0 THEN
117111                   CALL MOVITO; GO NXBFF
117113                FI
117113             FI; GO ORET
117114   ORET:     41ITAD=:B; GO RETU
117117          FI
117117   RETU:  MLEV; *IOF; MST PIE
117122          TAD:=TADREG; X:=BREG=:B:=XREG; GO LREG
117127   RBUS
117136
117136   %==============================================================================
117136   % (R)   C T O B A D
117136   %
117136   % OUTPUT IOSET ROUTINE FOR TAD
117136   % ENTRY: B = WORKING AREA
117136   %        X = RESIDENT OUTPUT-DATAFIELD
117136   %        A = CONTROLL
117136   %        D = PARAMETER
117136   % CALLED WITH INTERUPT OFF
117136   SUBR CTOBAD
117136   INTEGER BREG,XREG,TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER POINTER LREG
117144   CTOBAD: TAD=:TADREG; X=:XREG:=:B; X=:BREG:=L=:"LREG"; MLEV; *MCL PIE; ION
117155          CALL BOSWTAD
117156          IF 41ITAD.PORTNO=0 GO RETU
117161          IF AREG=-1 THEN                              % CLEAR BUFFER
117165             CALL CLODAT; 0/\0
117167             IF A=1 THEN
117172                CALL SNDBUF; 0/\0; GO RETU
117175             ELSE
117176                X:=BUFFID; AD:=TDTADD; 0=:BUFFID=:REMSIZ; CALL PUTPOOL
117203                GO RETU
117204             FI
117204          FI
117204          IF A=-2 THEN
117207             CALL SNDBUF; 0/\0; GO RETU             % SEND BUFFER
117212          FI
117212          IF A=23 OR A=24 THEN                      % SYSTEM/USER CONTROLL
117220   NWBUF:    IF BUFFID=0 THEN
117222                CALL GETPOOL; GO NYTRY              % GET NEW BUFFER
117224             FI
117224             IF AREG=23 THEN 7SYCN ELSE 7USCN FI
117233             T:=2; CALL CREMES; GO ECHK
117236             DREG; CALL WORDPUT; GO RETU
117241             IF AREG=23 THEN
117245                IF DREG=1 OR A=13 OR A=17 THEN CALL SNDBUF; 0/\0 FI
117261             ELSE
117262                7ERRS; CALL SNDWT; 0/\0                        % SEND MESSAGE AND WAIT FOR RESPONSE
117265             FI
117265             GO RETU
117266          FI
117266   RETU:  MLEV; *IOF; MST PIE; MST PID
117272          TAD:=TADREG; X:=BREG=:B:=XREG; GO LREG
117277
117277   ECHK:  IF A=1 GO NYTRY
117302          IF A=2 THEN
117305             CALL SNDBUF; GO RETU; GO NWBUF
117310          FI
117310          GO RETU
117311
117311   NYTRY: BREG=:D; RTREF=:X; GO REDOM
117316   RBUS
117332
117332   %=========================================================================
117332   % (R)   C L I D A T
117332   %
117332   % ROUTINE TO REPLACE DATA MESSAGES IN INPUT BUFFER WITH DUMMY
117332   % ENTRY        B-REG - INPUT DATAFIELD
117332   % SKIP RETURN: OK      A-REG = 0  BUFFER IS EMPTY
117332   %                      A-REG = 1  CONTROLL MESSAGES LEFT IN BUFFER
117332   % RETURN:      ERROR   A-REG - XMSG ERROR CODE
117332   SUBR CLIDAT
117332   INTEGER CTRBUF,BUFBP,BREMAI; INTEGER POINTER LREG
117336   CLIDAT: A:=L=:"LREG"; 0=:CTRBUF
117341          IF BUFFID=0 OR REMSIZ=0 GO OKOUT
117346          REMSIZ=:BREMAI; TDBTPT=:BUFBP
117352          IF CURMES=7BDAT THEN
117356             T:=REMBYT-; T-1; TDBTPT+T=:TDBTPT=:BUFBP
117365             REMSIZ-T=:REMSIZ=:BREMAI
117371          FI
117371          DO WHILE REMSIZ>0
117374             CALL GETMES; GO ECHECK; T=:D
117377             IF CURMES=7BDAT THEN
117403                T:=TDTAFI; X:=TDTALA; TDBTPT-2=:L SHZ -1; X+A; *LDATX
117413                IF L BIT "0" THEN
117415                   T:=7DUMM; A/\177400\/T
117420                ELSE
117421                   T:=7DUMM SHZ 10; A/\377\/T
117425                FI
117425                T:=TDTAFI; *STATX
117427             ELSE
117430                1=:CTRBUF
117432             FI
117432             TDBTPT+D=:TDBTPT
117435          OD
117436   EOUT:  BUFBP=:TDBTPT
117440          0=:CURMES=:REMBYT; BREMAI=:REMSIZ
117444   OKOUT: CTRBUF; MIN "LREG"; GO LREG
117447
117447   ECHECK: IF A<0 GO LREG                           % XMSG ERROR CODE
117451          IF A=3 THEN A:=TER01; GO LREG FI          % MESSAGE ERROR
117456          GO EOUT
117457   RBUS
117463
117463   %=========================================================================
117463   % (R)   C L O D A T
117463   %
117463   % ROUTINE TO REPLACE DATA MESSAGES IN OUTPUT BUFFER WITH DUMMY
117463   % ENTRY        B-REG - OUTPUT DATAFIELD
117463   % SKIP RETURN: OK      A-REG = 0  BUFFER IS EMPTY
117463   %                      A-REG = 1  CONTROLL MESSAGES IN BUFFER
117463   % RETURN:      ERROR   A-REG - XMSG ERROR CODE
117463   SUBR CLODAT
117463   INTEGER CTRBUF,BUFBP,AUXBP; INTEGER POINTER LREG
117467   CLODAT: A:=L=:"LREG"; 0=:CTRBUF
117472          IF BUFFID=0 OR REMSIZ=41ITAD.FBSIZ-BUDIS GO OKOUT
117502          TDBTPT=:D=:BUFBP; BUDIS=:TDBTPT
117507   NXTBY: DO WHILE TDBTPT<D
117512             CALL LOADBYT; IF A=0 GO NXTBY; A=:CURMES; CALL LOADBYT; A=:X
117517             IF CURMES=7BDAT THEN
117523                TDBTPT-1=:TDBTPT; A:=7DUMM; CALL STORBYT
117530             ELSE
117531                1=:CTRBUF
117533             FI
117533             TDBTPT+X=:TDBTPT
117536          OD
117537          BUFBP=:TDBTPT
117541   OKOUT: 0=:CURMES=:NOBDIS; CTRBUF; MIN "LREG"; GO LREG
117546   RETU:  GO LREG
117547   RBUS
117552

117552   %==============================================================================
117552   %       R O U T I N E S   T O   G E N E R A T E   M E S S A G E S
117552   %==============================================================================
117552   %
117552   % (R)   B B R E C
117552   %
117552   % ROUTINE TO SEND BREAK AND ECHO MESSAGE FOR TAD
117552   % ENTRY: X = INPUT DATAFIELD
117552   %        D = CONTROLL (1=BREAK, 2=ECHO)
117552   %        MONITOR LEVEL DISABLED
117552   SUBR BBREC
117552   BBREC: A:=L+1=:X."LRSA"; IF X.PORTNO=0 GO RETU
117556          IF X.BRECST<0 THEN A:=-1 FI                   % VALUE WILL BE CONV. TO BYTE FORMAT
117561          IF D=1 THEN CALL BDBREA ELSE CALL BDECHO FI
117567   RETU:  T:=X."LRSA"=:L; EXIT
117572   RBUS
117574
117574   %==============================================================================
117574   % (R)   C B R E C T A
117574   %
117574   % ROUTINE TO COPY BREAK AND ECHO TABLES
117574   % ENTRY:    D-REG  - SOURCE ADDRESS
117574   %           B-REG   - TAD OUTPUT DATAFIELD
117574   % RETURN:   EXIT    TDBTPT, REMSIZ IS UPDATED
117574   %
117574   SUBR CBRECTA
117574   CBRECTA:
117574          TDBTPT SHZ -1+TDTALA
117577          A=:NOCHAR
117600          FOR X:=0 TO 7 DO; X=:XRSA
117605             D.S0; D+1; T:=TDTAFI; X:=NOCHAR; *STATX
117613             MIN NOCHAR
117614          X:=XRSA; OD
117617          TDBTPT+20=:TDBTPT; REMSIZ-20=:REMSIZ
117625          EXIT
117626   RBUS
117626
117626   %==============================================================================
117626   % (R)   B D E C H O
117626   %
117626   % ROUTINE TO SEND ECHO-MESSAGE
117626   % ENTRY:       A-REG = ECHO STRATEGY
117626   %              X-REG = TAD INPUT DATAFIELD
117626   SUBR BDECHO
117626   INTEGER AREG,BREG,MSSIZ; INTEGER POINTER LREG
117632   BDECHO: A=:AREG:=L=:"LREG":=B=:BREG; 41OTAD=:B
117641          IF AREG>0 AND A<7 THEN
117647             IF A=CURECST GO RETU                   % SAME ECHO STRATEGY AS LAST TIME
117652          FI; A=:CURECST                            % SET NEW CURRENT STRATEGY
117653          IF A=7 THEN T:=21 ELSE T:=1 FI; T=:MSSIZ
117662          IF BUFFID=0 THEN
117664             CALL GETPOOL; GO NYTRY
117666          ELSE
117667             IF REMSIZ<T+3 THEN
117673                CALL SNDBUF; GO NYTRY
117675                IF BUFFID=0 GO NYTRY
117677             FI
117677          FI
117677          A:=7ECKM; T:=MSSIZ; CALL CRHEOD; GO RETU            % CREATE MESSAGE HEADER
117703          AREG=:D; CALL STORBYT                               % WRITE ECHO TYPE
117706          IF D=7 THEN                                         % COPY ECHO TABLE
117711             41ITAD+"PECH7"=:D; CALL CBRECTA
117715          FI
117715   RETU:  41ITAD=:X; BREG=:B; GO LREG
117722
117722   NYTRY: 41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM
117731   RBUS
117743
117743   %==============================================================================
117743   % (R)   B D B R E A
117743   %
117743   % ROUTINE TO SEND BREAK-MESSAGE.
117743   % ENTRY:       A-REG = BREAK STRATEGY
117743   %              X-REG = TAD INPUT DATAFIELD
117743   SUBR BDBREA
117743   INTEGER AREG,BREG,MSSIZ,BRSTR; INTEGER POINTER LREG
117750   BDBREA: A=:AREG:=L=:"LREG":=B=:BREG; X=:B
117756          IF AREG>0 AND A<7 THEN
117764             IF A=41OTAD.CURBRST GO RETU                  % SAME BREAK STRATEGY AS LAST TIME
117770          FI; A=:41OTAD.CURBRST                           % SET NEW CURRENT STRATEGY
117772          IF A>7 AND X:=OSVTPN<3 THEN T:=7 ELSE A=:T FI   % FAKE 8 AND 9 IF NOT PROT 3
120004          T=:BRSTR
120005          IF T=X:=7 THEN T:=23 ELSE T:=3 FI; T=:MSSIZ; 41OTAD=:B
120016          IF BUFFID=0 THEN
120020             CALL GETPOOL; GO NYTRY
120022          ELSE
120023             IF REMSIZ<T+3 THEN
120027                CALL SNDBUF; GO NYTRY
120031                IF BUFFID=0 GO NYTRY
120033             FI
120033          FI
120033          A:=7BMMX; T:=MSSIZ; CALL CRHEOD; GO RETU            % CREATE MESSAGE HEADER
120037          BRSTR=:D; CALL STORBYT                              % WRITE BREAK TYPE
120042          TDBTPT SHZ-1; T:=TDTALA+A; 41ITAD.BRKMAX
120050          T=:X:=TDTAFI; *STATX                                % WRITE MAXBREAK
120053          TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ
120061          IF D=7 THEN
120064             IF AREG=11 THEN 41ITAD.BRKTAB ELSE 41ITAD+"PBRK7" FI
120075             A=:D; CALL CBRECTA
120077          FI
120077   RETU:  41ITAD=:X; BREG=:B; GO LREG
120104
120104   NYTRY: 41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM
120113   RBUS
120125
120125   %==============================================================================
120125   % (R)   B T M O D
120125   %
120125   % ROUTINE TO SEND TERMINAL-MODE, CALLED FROM MTERMODE
120125   %
120125   % X = INPUT-DATAFIELD, A = MODE,  MONITOR LEVEL DISABLED
120125   % T = WORKING FIELD IF BMTMOD
120125
120125   SUBR BTMOD
120125   INTEGER WFI
120126   BMTMOD:K:=1; T=:WFI; GO FELL
120131   BTMOD: K:="0"
120132   FELL:  IF T:=X.PORTNO=0 THEN EXITA FI
120136          T:=41OTAD=:B:=L+1=:"LRSA"; A=:XRSA
120143   NXBUF: 7TMOD; T:=1; CALL CREMES; GO ECHEC
120147          A:=XRSA/\377; CALL BYTPUT; GO RETU
120153          CALL SNDBUF; 0/\0
120155   RETU:  GO LRSA
120156   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120164          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120177          GO RETU
120200   RBUS
120210
120210   %==============================================================================
120210   % (R)   C T M O D   C M T M O D
120210   %
120210   % ROUTINE TO SEND TERMINAL-MODE, CALLED FROM TERMODE COMMAND
120210   %
120210   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120210   % T = WORKING FIELD IF CMTERM
120210
120210   SUBR CTMOD,CMTERM
120210   INTEGER WFI
120211   CMTERM:K:=1; T=:WFI; GO FELL
120214   CTMOD: K:="0"
120215   FELL:  T:=L+1=:X."LRSA"
120217          A:=B=:X.XRSA; 41OTAD=:B
120223   NXBUF: 7TMOD; T:=1; CALL CREMES; GO ECHEC; 41ITAD=:B; A:=0
120232
120232   % CAPITAL LETTERS
120232          IF T:=DFLAG BIT 5CAPITAL THEN A BONE "0" FI
120236   % CR DELAY
120236          IF T:=TINFO BIT 5CRDLY THEN A BONE 1 FI
120242   % STOP ON FULL PAGE
120242          IF T:=41OTAD.SCREEN><X:=0 THEN A BONE 2 FI
120250   % LOGGOUT ON MISSING CARRIER
120250          IF T:=FLAGB BIT 5LBLOG   THEN A BONE 3 FI
120254          X:=41OTAD=:B; CALL BYTPUT; GO RETU
120260          CALL SNDBUF; 0/\0
120262   RETU:  X:=41ITAD; X.XRSA=:B; X."LRSA"=:L; EXIT
120270   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120276          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120311          GO RETU
120312   RBUS
120321
120321   %==============================================================================
120321   % (R)   C S T Y P   C M S T Y P
120321   %
120321   % ROUTINE TO SEND TERMINAL TYPE CALLED FROM SET-TERMINAL-TYPE COMMAND
120321   % AND MSTTY MONITOR CALL
120321   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120321   % T = WORKING FIELD IF CMSTYP
120321
120321   SUBR CSTYP,CMSTYP
120321   INTEGER BREG,WFI; INTEGER POINTER LREG
120324   CMSTYP:K:=1; T=:WFI; GO FELL
120327   CSTYP: K:="0"
120330   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120335          X:=B=:BREG; 41OTAD=:B
120341   NXBUF: 7TTYP; T:=2; CALL CREMES; GO ECHEC
120345          41ITAD.CTTYP; CALL WORDPUT; GO RETU
120351   RETU:  X:=41ITAD; BREG=:B; GO LREG
120355   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120363          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120376          GO RETU
120377   RBUS
120406
120406   %==============================================================================
120406   % (R)   C S U M O D
120406   %
120406   % ROUTINE TO SEND UMOD MESSAGE CALLED FROM IOMTY FUNCTION SUNMO
120406   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120406   % T = WORKING FIELD IF CMSTYP
120406   SUBR CSUMOD
120406   INTEGER BREG
120407   INTEGER POINTER LREG
120410   CSUMOD: IF X.PORTNO=0 OR X.OSVTPN/\377<4 THEN EXIT FI
120420           MLEV; *MCL PIE                           % DISABLE MON LEV.
120422           A:=B=:BREG:=41OTAD=:B:=L=:"LREG"
120430   NXBUF:  7UMOD; T:=2; CALL CREMES; GO ECHEC
120434           X:=BREG; A:=X.D4; CALL WORDPUT; GO OUT   % D4 CONTAINS UMOD STRATEGY
120440           CALL SNDBUF; GO OUT
120442           MIN "LREG"
120443   OUT:    BREG=:B; GO LREG
120446   ECHEC:  IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF FI
120454           IF A=1 THEN
120457              41ITAD=:B; RTREF=:X; BREG=:D;GO REDOM % WAIT FOR BUFFER
120466           FI
120466           GO OUT
120467   RBUS
120477
120477   %==============================================================================
120477   % (R)   C C E S C   C M E S C
120477   %
120477   % ROUTINE CALLED FROM ENABLE/DISABLE-ESCAPE COMMANDS AND MONITOR CALLS
120477   % TO SEND ENABLE/DISABLE ESCAPE
120477   % X = INPUT DATAFIELD, MONITOR LEVEL DISABLED
120477   % T = WORKING FIELD IF CMESC
120477   SUBR CCESC,CMESC
120477   INTEGER BREG,WFI; INTEGER POINTER LREG
120502   CMESC: K:=1; T=:WFI; GO FELL
120505   CCESC: K:="0"
120506   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120513          X:=B=:BREG; 41OTAD=:B
120517   NXBUF: 7CESC; T:=1; CALL CREMES; GO ECHECK
120523          IF 41ITAD.DFLAG BIT 5IESC THEN A:=0 ELSE A:=1 FI
120532          CALL BYTPUT; GO RETU
120534          IF TDRADDR.RTRES=RTREF THEN
120541             7CERS; CALL SNDWT; 0/\0                           % SEND MESSAGE AND WAIT FOR RESPONSE
120544          ELSE
120545             CALL SNDBUF; 0/\0                                 % JUST SEND MESSAGE
120547          FI
120547   RETU:  X:=41ITAD; BREG=:B; GO LREG
120553   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120561          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120574          GO RETU
120575   RBUS
120605
120605   %==============================================================================
120605   % (R)   C S D A E   C M S D A E
120605   %
120605   % ROUTINE CALLED FROM DEFINE-ESCAPE-CHARACTER COMMAND TO SEND CHANGE.
120605   % X = INPUT DATAFIELD, MONITOR LEVEL DISABLED
120605   SUBR CSDAE,CMSDAE
120605   INTEGER BREG,WFI; INTEGER POINTER LREG
120610   CMSDAE:K:=1; T=:WFI; GO FELL
120613   CSDAE: K:="0"
120614   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120621          X:=B=:BREG; 41OTAD=:B
120625   NXBUF: 7DESC; T:=1; CALL CREMES; GO ECHECK
120631          41ITAD.CESCP/\377
120634          CALL BYTPUT; GO RETU; CALL SNDBUF; GO RETU
120640   RETU:  41ITAD=:X; BREG=:B; GO LREG
120645   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120653          IF A=1 THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120664          GO RETU
120665   RBUS
120675
120675   %==============================================================================
120675   % (R)   B I S I Z    P I S I Z
120675   %
120675   % ROUTINE CALLED FROM IBRSIZ/ISIZE WITH:
120675   % X = INPUT-DATAFIELD, B = WORKING-AREA, MONITOR LEVEL DISABLED
120675   % TO FIND NUMBER OF CHARACTERS LEFT TO READ IN A TAD
120675   % IF TAD INPUT-BUFFER IS EMPTY, A REQUEST FOR ISIZE IS SENT
120675   % TO PARTNER.
120675   %
120675   % SKIP-RETURN: A = NUMBER OF CHARACTERS IN BUFFER
120675   %              X = NUMBER OF CHARACTERS INCLUDING FIRST BREAK  (BISIZ ONLY)
120675   % RETURN:      A = ERROR CODE
120675
120675   SUBR BISIZ,PISIZ
120675   BISIZ: A:=0; GO FELLS             % IBRSIZ (MON 313)
120677   PISIZ: A:=1                       % ISIZE  (MON 66)
120700   FELLS: X:=:B; A=:XRSA; X=:"LRSA"
120703          IF BUFFID><0 THEN                          % INPUT BUFFER PRESENT
120705             IF CURMES=7BDAT THEN                    % DATA-MESSAGE PRESENT
120711   CDATA:       A:=REMBYT-
120713                IF A-1=0 THEN GO CMORE ELSE GO RETU FI
120717             ELSE
120720   CMORE:       CALL GETMES; GO ENDCH               % GET NEXT MESSAGE
120722                IF A=X:=7BDAT THEN                  % DATA MESSAGE
120725                   IF T=0 THEN                      % EMPTY
120727                      GO CMORE
120730                   ELSE
120731                      T=:A; GO RETU                 % NUMBER OF BYTES FOUND
120733                   FI
120733                ELSE
120734                   A:=3; GO ENDCH
120736             FI;FI; GO CMORE
120737
120737   ENDCH:    IF A<0 GO EROUT
120740             IF A=3 THEN
120743                CALL SNDREJ; 0/\0; A:=TER01; GO EROUT
120747             FI
120747          FI
120747
120747   % INPUT-BUFFER IS EMPTY OR NOT PRESENT
120747          41OTAD=:B                       % B = OUTPUT DATAFIELD
120751          IF 41ITAD.BUFFID><0 THEN        % RETURN INPUT BUFFER TO POOL
120754             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.NOBDIS
120760             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL
120764          FI
120764
120764   TAGAI: A:=7ISRQ; T:=0; CALL CREMES; GO BCHEC
120770          IF 41ITAD.XRSA=0 THEN 7ISRS ELSE 7ISRS BONE 17 FI
120777          CALL SNDWT; 0/\0; X."LRSA"=:B; MIN ZPREG; 0/\0; GO RET % SEND MESSAGE AND WAIT FOR RESPONSE
121006
121006   BCHEC: IF A<0 GO EROUT
121007          IF A=2 THEN                     % OUTPUT-BUFFER FULL
121012             CALL SNDBUF; GO EROUT; GO TAGAI
121015          FI
121015          41ITAD=:B; RTREF=:X; "LRSA"=:D
121023          GO REDOM                        % TRY WHEN BUFFERS RETURNED
121024
121024   % CHARACTERS PRESENT IN LOCAL BUFFER, RETURN NUMBER
121024   RETU:  B=:X; T:="LRSA"=:B; X:=X.XRSA;
121030          A=:ZAREG; IF X=0 THEN A=:ZXREG FI
121034          MIN ZPREG; ;0/\0; GO RET
121037
121037   % ERROR RETURN
121037   EROUT: T:="LRSA"=:B; A=:ZAREG; GO RET
121043   RBUS
121057
121057   %==============================================================================
121057   % (R)   B O S I Z
121057   %
121057   % ROUTINE CALLED FROM OSIZE IF TAD
121057   % X = OUTPUT-DATAFIELD
121057   SUBR BOSIZ
121057   BOSIZ: IF X.BUFFID><0 THEN
121061             A:=X.REMSIZ
121062          FI
121062          A=:ZAREG; MIN ZPREG; 0/\0; GO RET
121066   RBUS
121067
121067   %==============================================================================
121067   % (R)   B S C P C
121067   %
121067   % ROUTINE TO PREPARE SENDING OF COMPLETION CODE, CALLED FROM UEADM.
121067   % THE ROUTINE MUST CHECK DATA TO DETERMINE IF THE CURRENT OPERATION
121067   % OF UEADM IS WRITE COMPLETION CODE. IF UEDAT ON SYSTEM-SEGMENT IS
121067   % EQUAL THE ARRAY IN THE USER PARAMETER EXEPT FOR COMPLETION CODE
121067   % FUNCTION 2 IS USED TO SET COMPLETION CODE.
121067
121067   SUBR BSCPC
121067   DISP -177; INTEGER T2SEG,WPNT; PSID
121067   SYMBOL FPART=3,CBC01,CBC02,LPART,AREND=UEMAX
121067   INTEGER POINTER TTIF:=TTIFIELD
121070   BSCPC: A:=L=:TTIF."LRSA"; IF X.PORTNO=0 THEN EXIT FI
121076          WPNT=:D
121100          FOR X:=0 TO FPART DO; X:=:D            % CHANGE IN UEDAT BEFORE COMP.CODE?
121105              T:=T2SEG; CALL GET1L; GO ERR; X+1:=:D
121112              IF A><UEDAT(X) GO NOCOD
121115          OD; A:=D+2=:D
121122          FOR X:=LPART TO AREND DO; X:=:D        % CHANGE IN UEDAT AFTER COMP.CODE?
121127              T:=T2SEG; CALL GET1L; GO ERR; X+1:=:D
121134              IF A><UEDAT(X) GO NOCOD
121137          OD
121141          T:=T2SEG; X:=WPNT+CBC02; CALL GET1L; GO ERR    % COLLECT COMPLETION CODE
121146          A=:D; X-1; CALL GET1L; GO ERR; X:=TTIF:=:B     % --------- " ----------
121154          CALL SNDCP                                     % SEND COMPLETION CODE
121155   RETU:  X."LRSA"=:L; EXIT
121160   ERR:
121160   NOCOD: X:=TTIF; GO RETU
121162   RBUS
121165
121165   %==============================================================================
121165   % (R)   S N D C P
121165   %
121165   % ROUTINE TO SEND COMPLETION CODE CALLED FROM BSCPC
121165   % ENTRY:     AD= COMPLETION CODE
121165   %            B = TAD INPUT DATAFIELD
121165   % RETURN:    EXIT, NO ERRORS RAPPORTED
121165
121165   SUBR SNDCP
121165   INTEGER BREG,CPC1,CPC2,LREG
121171   SNDCP: MLEV; *MCL PIE                            % DISABLE MONTTOR LEVEL
121173          T:=L=:LREG; A=:CPC1:=D=:CPC2; X=:BREG
121201          X:=TDRADDR; CALL XISWTAD                  % SET UP WINDOW IN PIT
121203          41OTAD=:B                                 % B-REG - OUTPUT-DATAFIELD
121205   NXBUF: 7CPCO; T:=4; CALL CRHEEV; GO ECHEC        % CREATE MESSAGE
121211          TDBTPT SHZ -1; T:=TDTAFI; X:=TDTALA+A
121216          CPC1; *STATX
121220          X+1; CPC2; *STATX
121223          TDBTPT+4=:TDBTPT; REMSIZ-4=:REMSIZ
121231          CALL SNDBUF; 0/\0
121233   RETU:  41ITAD=:X:=BREG=:B:=LREG=:L; MLEV; *MST PIE; EXIT
121244   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF FI; GO RETU
121253   RBUS
121261
121261   %==============================================================================
121261   % (R)   N W S T A
121261   %
121261   % ROUTINE TO SEND NOWAIT STATUS, CALLED WITH MONITOR LEVEL DISABLED
121261   % ENTRY:      A = NOWAIT STATUS
121261   %             X = TAD INPUT-DATAFIELD
121261   SUBR NOWTSTA
121261   INTEGER BREG,NWS; INTEGER POINTER LREG
121264   NOWTSTA:A=:D; IF X.PORTNO=0 THEN EXITA FI                  % NOT CONNECTED
121270          A:=L+1=:"LREG":=D; X:=:B=:BREG; A=:NWS
121276   NXBFF: IF A=0 THEN A:=7NOWT ELSE A:=7TNOW FI               % DETERMINE NOWT TYPE
121302          T:=41OTAD=:B; T:=1; CALL CRHEEV; GO ECHK            % CREATE MESSAGE
121307          NWS; CALL STORBYT                                   % WRITE STATUS
121311          CALL SNDBUF; 0/\0; GO RETUO                         % SEND MESSAGE
121314
121314   ECHK:  IF A=1 THEN                                         % NO BUFFER
121317             41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM           % TRY LATER
121326          FI
121326          IF A=2 THEN                                         % NOT ENOUGH SPACE
121331             CALL SNDBUF; GO RETUO
121333             NWS; GO NXBFF                                    % NEXT BUFFER
121335          FI
121335   RETUO: 41ITAD=:B
121337   RETUI: B=:X; BREG=:B; GO LREG
121343   RBUS
121352
121352   %==============================================================================
121352   % (R)   S N D R F I
121352   %
121352   % ROUTINE TO GENERATE AND SEND RFI-MESSAGE.
121352   % CALLED FROM ALL INPUT CALLS WHEN INPUT BUFFER IS EMPTY.
121352
121352   % ENTRY:          B-REG - TAD INPUT DATAFIELD
121352   % SKIP RETURN:    OK
121352   % RETURN:         A-REG - XMSG ERROR CODE
121352   SUBR SNDRFI
121352   INTEGER POINTER LREG
121353   SNDRFI: A:=L=:"LREG"; B=:X=:D; 41OTAD=:B
121361          IF X.TDRADDR.ISTATE<0 THEN                % NOWAIT MODE
121364             IF D.DFLAG BIT 5RQI GO SOUT            % RFI ALREADY SENT, TRY TO SEND OUTPUT
121370          FI
121370          IF BUFFID=0 AND 41ITAD.BUFFID><0 GO USINP % OUTPUT BUFFER PRESENT?
121375          A:=7RFI; T:=0; CALL CREMES; GO NOSPA      % GENERATE MESSAGE
121401          GO SBU
121402
121402   NOSPA: IF A<0 GO RETU                            % XMSG ERROR
121403          IF A=1 GO NOPOL                           % NO BUFFERS IN POOL
121406          CALL SNDBUF; GO RETU                      % OUTPUT BUFFER FULL, SEND
121410          IF BUFFID=0 GO USINP                      % NO BUFFER, USE INPUT
121412          A:=7RFI; T:=0; CALL CREMES; GO RETU       % GENERATE MESSAGE
121416
121416   SBU:   41ITAD.DFLAG BONE 5RQI=:X.DFLAG           % MARK RFI SENT IN INPUT-DATAFIELD
121422   SOUT:  IF 41ITAD.BUFFID><0 THEN
121425             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.REMBYT
121431             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL % RETURN INPUT BUFFER TO POOL
121435          FI
121435          CALL SNDBUF; 0/\0
121437   OKRET: 41ITAD=:B; MIN "LREG"; GO LREG            % OK RETURN
121443
121443   USINP: IF 41ITAD.BUFFID=0 GO NOPOL               % POOL IS EMPTY
121446          CALL MOVITO                               % MOVE INP. BUFF. TO OUTPUT
121447          A:=7RFI; T:=0; CALL CREMES; GO RETU       % GENERATE MESSAGE
121453          CALL SNDBUF; GO RETU                      % SEND MESSAGE
121455          41ITAD.DFLAG BONE 5RQI=:X.DFLAG           % MARK RFI SENT IN INPUT-DATAFIELD
121461          GO OKRET                                  % OK RETURN
121462   RETU:  X:=41ITAD=:B; GO LREG
121465
121465   NOPOL: 41ITAD.DFLAG BZERO 5RQI BONE 5WRQI=:X.DFLAG
121472          GO OKRET                                  % DRIVER SENDS RFI WHEN BUFFER AVAILABLE
121473   RBUS
121501
121501   %==============================================================================
121501   % (R)   S N D R E J
121501   %
121501   % ROUTINE TO GENERATE AND SEND REJECT-MESSAGE.
121501   % IF REJECTED MESSAGE IS DATA, RFI-MESSAGE
121501   % IS ALSO SENDT.
121501
121501   % ENTRY:          B-REG - TAD INPUT DATAFIELD
121501   % SKIP RETURN:    OK
121501   % RETURN:         A-REG - XMSG ERROR CODE
121501   SUBR SNDREJ
121501   INTEGER POINTER LREG
121502   SNDREJ: A:=L=:"LREG":=41OTAD=:B
121506          IF BUFFID=0 AND 41ITAD.BUFFID><0 GO USINP    % OUTPUT BUFFER PRESENT?
121513          IF 41ITAD.CURMES=7BDAT THEN T:=3 ELSE T:=1 FI % INCLUDING RFI?
121523          A:=7REJE; CALL CREMES; GO NOSPA              % GENERATE REJECT
121526          41ITAD.CURMES; CALL BYTPUT; GO RETU          %
121532          A:=7RFI; T:=0; CALL CREMES; GO RETU          % GENERATE RFI
121536          GO SBU
121537
121537   NOSPA: IF A<0 GO RETU                            % XMSG ERROR
121540          CALL SNDBUF; GO RETU                      % OUTPUT BUFFER FULL, SEND
121542          IF BUFFID=0 GO USINP                      % NO BUFFER, USE INPUT
121544          A:=7REJE; T:=1; CALL CREMES; GO RETU      % GENERATE REJECT
121550          41ITAD.CURMES; CALL BYTPUT; GO RETU
121554          IF 41ITAD.CURMES=7BDAT THEN
121561             A:=7RFI; T:=0; CALL CREMES; GO RETU    % GENERATE RFI
121565          FI
121565
121565   SBU:   CALL SNDBUF; GO RETU                      % SEND BUFFER
121567          IF 41ITAD.BUFFID><0 THEN
121572             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.REMBYT
121576             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL % RETURN INPUT BUFFER TO POOL
121602          FI
121602   OKRET: 41ITAD=:B; MIN "LREG"; GO LREG             % OK RETURN
121606
121606   USINP: IF 41ITAD.BUFFID=0 THEN                   % NO BUFFERS AVAILABLE
121611             IF X.CURMES=7BDAT THEN
121615                X.DFLAG BONE 5WRQI=:X.DFLAG         % RFI MUST BE SENT BY DRIVER
121620             FI
121620             GO OKRET                               % REJECT IS NOT POSSIBLE
121621          FI
121621          CALL MOVITO                               % MOVE INP. BUFF. TO OUTPUT
121622          A:=7REJE; T:=1; CALL CREMES; GO RETU      % GENERATE REJECT
121626          41ITAD.CURMES; CALL BYTPUT; GO RETU
121632          IF 41ITAD.CURMES=7BDAT THEN
121637             A:=7RFI; T:=0; CALL CREMES; GO RETU    % GENERATE RFI
121643          FI
121643          CALL SNDBUF; GO RETU                      % SEND BUFFER
121645          GO OKRET                                  % OK RETURN
121646
121646   RETU: X:=41ITAD=:B; GO LREG
121651   RBUS
121661
121661   %==============================================================================
121661   %       I O T R A N S   A N D  I / O   M O N I T O R   C A L L S
121661   %==============================================================================
121661   %
121661   % (R)   B D P U T
121661   %
121661   % OUTPUT IOTRANS ROUTINE FOR TAD.
121661   % CALLED WITH INTERUPT OFF
121661   % ENTRY:        A-REG - BYTE
121661   %               B-REG - TAD OUTPUT DATAFIELD
121661   % SKIP RETURN:  OK
121661   % RETURN:       ERROR-CODE IN DERROR
121661   SUBR BDPUT
121661   BDPUT: A=:LAST:=L=:"LRSA"; X=:XRSA; 0=:TMR
121666          CALL BOSTAD; MLEV; *MCL PIE; ION
121672          IF 41ITAD.PORTNO=0 THEN MIN "LRSA"; GO RETU; FI     % NOT CONNECTED
121677          IF 7BDAT><CURMES THEN
121703   CRMES:    T:=3; CALL CREMES; GO ERR
121706          FI
121706          IF 41ITAD.TINFO NBIT 5UMOD OR X.BSTATE=5BCOM THEN
121716             LAST BZERO 7
121720          ELSE
121721             LAST
121722          FI
121722          CALL BYTPUT; GO ERR
121724          MIN "LRSA" GO RETU                                  % SKIP RETURN OK
121726
121726   ERR:   IF A<0 GO CNXE                                      % ERROR FROM XMSG
121727          IF A=1 GO RETU                                      % WAIT FOR BUFFER
121732          IF A=2 THEN                                         % BUFFER FULL
121735             CALL SNDBUF; GO CNXE
121737             IF BUFFID><0 THEN 7BDAT; GO CRMES FI
121743             GO RETU
121744          FI
121744          IF A=3 THEN 7BDAT; GO CRMES; FI                     % MESSAGE FULL
121751          GO RETU
121752   CNXE:  CALL CNVERR                                         % CONVERT ERROR-CODE
121753   EROUT: A=:DERROR; X:=XRSA; MLEV; *IOF; MST PIE
121760          GO LRSA
121761   RETU:  TTMR=:TMR; X:=XRSA; MLEV; *IOF; MST PIE
121767          LAST; GO LRSA
121771   RBUS
121777
121777   %==============================================================================
121777   % (R)   B D G E T
121777   %
121777   % INPUT IOTRANS ROUTINE FOR TAD.
121777   % CALLED WITH INTERUPT OFF
121777   % ENTRY:        B-REG - TAD INPUT DATAFIELD
121777   % SKIP RETURN:  OK
121777   %               A-REG - BYTE
121777   % RETURN:       ERROR-CODE IN DERROR
121777   SUBR BDGET
121777   BDGET: A:=L=:"LRSA"; X=:XRSA
122002          CALL BISTAD; MLEV; *MCL PIE; ION
122006          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122010          IF PORTNO=0 THEN A:=TER02; GO EROUT; FI   % NOT CONNECTED
122014   BYGET: IF CURMES=7BDAT THEN
122020             CALL BYTGET; GO ERR; A=:LAST; MIN "LRSA"; GO RETU
122025          FI
122025   NXMES: CALL GETMES; GO ERR
122027          IF A=X:=7BDAT THEN
122032             IF T=0 THEN GO NXMES ELSE GO BYGET FI
122036          ELSE
122037             A:=3; GO ERR
122041          FI
122041          GO RETU
122042
122042   ERR:   IF A<0 GO CNXE                                      % XMSG ERROR CODE
122043          IF A=0 GO NXMES                                     % DATA MESSAGE EMPTY
122044          IF A=1 OR A=2 THEN CALL SNDRFI; GO CNXE; GO RETU;FI % BUFFER EMPTY, SEND RFI
122055          IF A=3 THEN                                         % INCONSISTENT MESSAGE
122060             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122064          FI
122064          GO RETU
122065   CNXE:  CALL CNVERR
122066   EROUT: A=:DERROR
122067   RETU:  A=:X:=MLEV; *IOF; MST PIE
122073          X=:A:=XRSA
122075          GO LRSA
122076   RBUS
122107
122107   %==============================================================================
122107   % (R)   B M 8 O U T   B B 8 O U T   B D T C H
122107   %
122107   % BM8OUT (MON 22):
122107   %    MONITOR CALL TO WRITE UP TO 8 BYTES ON A TAD (0 BYTE TERMINATES)
122107   % BB8OUT (MON 24):
122107   %    MONITOR CALL TO WRITE 8 BYTES ON A TAD
122107   %
122107   % CALLED WITH INTERUPT OFF WITH B = OUTPUT-DATAFIELD
122107
122107   SUBR BM8OUT,BB8OUT,BDTCH
122107
122107   % ROUTINE TO CHECK FOR TERMINATION IN DATA
122107   BDTCH:  A=:D
122110           IF X:=XRSA=0 THEN
122113             A SHZ -10; IF A=0 THEN EXIT FI      % FIRST BYTE EMPTY
122116             D=:A; A/\377
122120             IF A=0 THEN A:=D SHZ -10; EXITA FI  % LAST BYTE EMPTY
122124           FI
122124           D=:A; L+1; EXITA
122127
122127   BM8OUT: T:=0; GO FELLS
122131   BB8OUT: T:=1
122132   FELLS: MLEV; *MCL PIE; ION
122135          CALL BOSWTAD; T=:XRSA                     % SET WINDOW
122137          IF 41ITAD.PORTNO=0 GO MOURET; 0=:TMR      % NOT CONNECTED
122144          IF 7BDAT><CURMES THEN                     % CURRENT NOT DATA-MESS
122150   CRMES:    T:=10; CALL CREMES; GO ERR             % RESERVE 10 BYTES
122153          ELSE
122154             IF REMSIZ<12 THEN A:=2; GO ERR FI      % NOT ENOUGH SPACE IN BUFFER
122162             CALL GETMBC                            % GET BYTE COUNT IN CURMES
122163             IF A+10>377 THEN 7BDAT; GO CRMES FI    % NOT ENOUGH SPACE IN MESSAGE
122171          FI
122171
122171   % ENOUGH SPACE IN BUFFER
122171
122171          *IRR ALEVB DA
122172          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DD
122200          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DL
122206          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DX
122214          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR
122221
122221   % NORMAL RETURN, BYTES STORED IN BUFFER
122221   OKRET: TTMR=:TMR; GO TAD8RET
122224
122224   % ONE BYTE LEFT TO WRITE IN BUFFER
122224   LASBY: CALL BYTPUT; GO ERR; GO OKRET
122227
122227   % ERRORS FROM CREMES
122227   ERR:   IF A=1 GO RETU                            % WAIT FOR BUFFER
122232          IF A=2 THEN                               % BUFFER FULL
122235             CALL SNDBUF; GO CNXE
122237             IF BUFFID><0 THEN 7BDAT; GO CRMES FI   % NEW BUFFER
122243             GO RETU                                % WAIT FOR BUFFER
122244          FI
122244          GO RETU
122245
122245   CNXE: CALL CNVERR; A=:DERROR
122247   RETU: TTMR=:TMR; MLEV; *IOF; MST PIE
122254         GO TERWDX
122255   RBUS
122272
122272   %==============================================================================
122272   % (R)   B B 4 I N W
122272   %
122272   % MON 63: MONITOR CALL ALWAYS RETURNS 8 BYTES FROM A TAD
122272   % CALLED WITH INTERUPT OFF WITH B = INPUT DATAFIELD
122272
122272   SUBR BB4INW
122272   BB4INW: MLEV; *MCL PIE; ION
122275          CALL BISWTAD                              % SET WINDOW
122276          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122300          IF PORTNO=0 THEN A:=TER02; GO EROUT FI    % NOT CONNECTED
122304   POSDA: IF CURMES><7BDAT THEN                     % NOT DATA MESSAGE
122310   NXMES:    CALL GETMES; GO ERR                    % GET NEW MESSAGE
122312             IF A><X:=7BDAT THEN A:=3; GO ERR FI    % CONTROLL MESSAGE
122317          FI
122317          IF REMBYT=0 OR A=-1 GO NXMES              % CURRENT MESSAGE EMPTY
122324
122324   % DATA-MESSAGE WITH AT LEAST ONE BYTE
122324
122324          DBCOU GOSW BYT1,BYT2,BYT3,BYT4,BYT5,BYT6,BYT7,BYT8
122336
122336   BYT1:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DA
122343          MIN DBCOU
122344   BYT2:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DA
122350          A\/LAST; *IRW ALEVB DA
122352          MIN DBCOU
122353   BYT3:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DD
122360          MIN DBCOU
122361   BYT4:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DD
122365          A\/LAST; *IRW ALEVB DD
122367          MIN DBCOU
122370   BYT5:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DL
122375          MIN DBCOU
122376   BYT6:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DL
122402          A\/LAST; *IRW ALEVB DL
122404          MIN DBCOU
122405   BYT7:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DX
122412          MIN DBCOU
122413   BYT8:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DX
122417          A\/LAST; *IRW ALEVB DX
122421
122421   % ALL CHARACTERS COLLECTED, RETURN TO USER
122421          0=:DBCOU; A:=10; *IRW ALEVB DT
122424          GO TAD8RET
122425
122425   % DETERMINE ACTION ON ERRORS
122425   ERR:   IF A<0 GO CNXE                            % XMSG ERROR
122426          IF A=0 GO NXMES                           % MESSAGE EMPTY
122427          IF A=1 OR A=2 THEN
122435             CALL SNDRFI; GO CNXE; GO RETU          % BUFFER EMPTY, SEND RFI
122440          FI
122440          IF A=3 THEN
122443             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122447          FI
122447          GO RETU
122450
122450   CNXE:  CALL CNVERR
122451   EROUT: A=:DERROR; 0=:DBCOU
122453   RETU:  MLEV; *IOF; MST PIE
122456          GO TERWDX
122457   RBUS
122472
122472   %==============================================================================
122472   % (R)   B B 8 I N P
122472   %
122472   % MON 310: MONITOR CALL RETURNS UP TO 8 BYTES FROM A TAD.
122472   % NUMBER OF BYTES READ IS RETURNED IN T-REG. WHEN LAST
122472   % CHARACTER IS READ FROM BUFFER T BIT 17 IS SET TO INDICATE
122472   % BREAK CHARACTER.
122472   % CALLED WITH INTERUPT OFF WITH B = INPUT DATAFIELD
122472
122472   SUBR BB8INP
122472   BB8INP: MLEV; *MCL PIE; ION
122475          CALL BISWTAD                              % SET WINDOW
122476          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122500          IF PORTNO=0 THEN A:=TER02; GO EROUT FI    % NOT CONNECTED
122504          0=:DBCOU                                  % ZERO CHARACTER COUNT
122505   POSDA: IF CURMES><7BDAT THEN                     % NOT DATA MESSAGE
122511   NXMES:    CALL GETMES; GO ERR                    % GET NEW MESSAGE
122513             IF A><X:=7BDAT THEN A:=3; GO ERR FI    % CONTROLL MESSAGE
122520          FI
122520          IF REMBYT=0 OR A=-1 GO NXMES              % CURRENT MESSAGE EMPTY
122525
122525   % DATA-MESSAGE WITH AT LEAST ONE BYTE
122525
122525   BYT1:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DA
122532          MIN DBCOU
122533   BYT2:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DA
122537          A\/LAST; *IRW ALEVB DA
122541          MIN DBCOU
122542   BYT3:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DD
122547          MIN DBCOU
122550   BYT4:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DD
122554          A\/LAST; *IRW ALEVB DD
122556          MIN DBCOU
122557   BYT5:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DL
122564          MIN DBCOU
122565   BYT6:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DL
122571          A\/LAST; *IRW ALEVB DL
122573          MIN DBCOU
122574   BYT7:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DX
122601          MIN DBCOU
122602   BYT8:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DX
122606          A\/LAST; *IRW ALEVB DX
122610          MIN DBCOU
122611          IF REMBYT=-1 THEN DBCOU BONE 17=:DBCOU FI % LAST CHARACTER, BREAK
122620
122620   % ALL CHARACTERS COLLECTED, RETURN TO USER
122620   OKRET: A:=DBCOU; 0=:DBCOU; *IRW ALEVB DT
122623          GO TAD8RET
122624
122624   % DETERMINE ACTION ON ERRORS
122624   ERR:   IF A<0 GO CNXE                            % XMSG ERROR
122625          IF A=0 GO NXMES                           % MESSAGE EMPTY
122626          IF A=1 OR A=2 THEN
122634             IF DBCOU><0 THEN                       % CHARACTERS TO RETURN
122636                A BONE 17=:DBCOU; GO OKRET          % MARK FOR BREAK
122641             ELSE
122642                CALL SNDRFI; GO CNXE; GO RETU       % BUFFER EMPTY, SEND RFI
122645             FI
122645          FI
122645          IF A=3 THEN
122650             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122654          FI
122654          GO RETU
122655
122655   CNXE:  CALL CNVERR
122656   EROUT: A=:DERROR; 0=:DBCOU
122660   RETU:  MLEV; *IOF; MST PIE
122663          GO TERWDX
122664   RBUS
122677
122677   *"-BADAD
"122677   @DEV 1
122677   @DEV (S-S-L)RP-P2-ACCRT:NPL
122677   %

122677   *"8ACC
"122677   %            *********************
122677   %            **                 **
122677   %            **    A C C R T    **
122677   %            **                 **
122677   %            *********************
122677   %
122677   %            ACCRT IS AN RT-PROGRAM WHICH DUMPS THE ACCUMULATED CPU TIME USED
122677   %            BY USER RT-PROGRAMS AND THE NUMBER OF 1K PAGE DISK ACCESSES
122677   %            MADE THROUGH THE FILE SYSTEM, FROM TABLES CONTAINED IN THE POF
122677   %            AREA OF MEMORY TO THE FILE (SYSTEM)ACCOUNTS:DATA.
122677   %
122677   %      VERSION F : 11 / JULY / 1985.
122677   %
122677   %      FOR USE WITH VSX K VERSION AND LATER.
122677   %==============================================================================
122677   %       UTILITIES FOR ACCRT.
122677   SUBR AR2READ,AR2WRITE,AR3READ,AR3WRITE
122677   INTEGER SAVTT
122700   AR2READ:    T=:SAVTT:=GLTMBANK; *LDDTX; LDT SAVTT; EXIT
122705   AR2WRITE:   T=:SAVTT:=GLTMBANK; *STDTX; LDT SAVTT; EXIT
122712   AR3READ:    T:=GLTMBANK; *LDDTX
122714               A=:SAVTT;    *LDATX 20
122716               A:=:D; T:=SAVTT; EXIT
122721   AR3WRITE:   T=:SAVTT:=GLTMBANK; *STDTX 10
122724               A:=SAVTT; *STATX; EXIT
122727   RBUS
122730
122730   %-------------------------------------------------------------------------------
122730   %
122730   %      R T A C R T
122730
122730   SUBR RTACRT
122730
122730   %      LOCAL VARIABLES
122730
122730   @ICR
122730
122730   SYMBOL   5ACCO = 36,                   % ACCOUNT:DATA BLOCK SIZE
122730            5RTPR = 14;                   % RTPROJ:DATA BLOCK SIZE
122730
122730
122730   %      BASE VARIABLES
122730
122730   DISP -200;
122730   INTEGER ARRAY BACCO(5ACCO),  % BUFFER FOR ACCOUNTING RECORD. (I.E. BLOCKS FROM ACCOUNTS:DATA).
122730                 BRTPR(5RTPR);  % BUFFER TO READ RTPROJ RECORD
122730
122730   DOUBLE  ARRAY DBACC=BACCO;   % USED TO ACCESS BACCO AS A DOUBLE INTEGER ARRAY.
122730
122730   INTEGER FILN1, %:=0,            % FILE-NUMBER FOR RTPROJ:DATA
122730           BLOC1, %:=0,            % BLOCK-NUMBER FOR RTPROJ:DATA
122730           FILN2, %:=0,            % FILE-NUMBER FOR ACCOUNTS:DATA
122730           BLOC2, %:=0,            % BLOCK-NUMBER FOR ACCOUNTS:DATA
122730
122730           PARA1(5), %:=(FILN1,"0",BRTPR,BLOC1,"5RTPR"),           % R/W 1 RTPROJ BLOCK
122730           PARA2(5), %:=(FILN2,"0",BACCO,BLOC2,"5ACCO"),           % R/W 1 ACCOUNT BLOCK
122730
122730           ACPOI, % :=0,           % CURRENT ENTRY IN ACTAB
122730           ENDAC, % :=0,           % ADDRESS OF LAST RECORD IN ACTAB.
122730           IOPOI, % :=0,           % CURRENT ENTRY IN IOACT
122730           SAERR, % :=0,           % SAVED ERROR-CODE
122730           NMBR , % :=0,           % NUMBER OF ACCOUNTING RECORDS IN FILE
122730           DMAX , % :=0,           % MAX NUMBER OF ACCOUNTS BEFORE A WARNING IS GIVEN
122730           RMAX , % :=0,           % MAX NUMBER OF ACCOUNTS PERMITTED IN THE FILE.
122730           ERFL,  % :=0,           % ERROR-FLAG :THE ACCOUNTING FILE IS FULL IF = 244
122730           BUNI , % :=0,
122730           SEC  , % :=0,
122730           MINUT, % :=0,
122730           HOUR , % :=0,
122730           DAY  , % :=0,
122730           MNTH , % :=0,
122730           YEAR , % :=0,
122730
122730           TPARA; % :=(BUNI);
122730
122730   PSID;
122730   @CR;
122730   *)FILL
122730
122730   %-------------------------------------------------------------------------------
122730   %            INITIALISATION.
122730
122730   RTACRT: *2BANK                         % SET 2 BANK MODE
122731          "ACBASE"=:B                     % INITIALISE B-REGISTER.
122733          IF ACTAB=-1 THEN
122737             *MON 2RTEX                   % NO RT-ACCOUNTING IN THIS SYSTEM.
122740          FI
122740          0=:SAERR=:ERFL                  % ZERO SAVED ERROR CODE AND ERROR FLAG.
122742   %
122742   %      RESERVE ACCOUNTING SEMAPHORE, OPEN FILES AND SET THE BLOCK SIZE.
122742   %
122742          "ACCSEMRE"; *MON 2RESR             % RESERVE ACCOUNTING SEMAPHORE
122744
122744          X:="XRTPROJ"; T:=3; A:="TYPD"
122747          *MON 2NOPE; JMP I (SEMER                  % OPEN (SYSTEM)RTPROJ:DATA
122751          A=:FILN1=:T:=5RTPR; *MON 2SBLZ            % SET BLOCK SIZE ( 5RTPR )
122755          GO FAR CL1FI
122756          X:="AFILNAM"; T:=2; A:="TYPD"             % OPEN ACCOUNTS:DATA
122761          *MON 2NOPE; JMP I (CL1FI                  % OPEN (SYSTEM)ACCOUNTS:DATA
122763          A=:FILN2=:T:=5ACCO; *MON 2SBLZ            % SET BLOCK SIZE ( 5ACCO )
122767          GO FAR CL2FI
122770   %
122770   %      READ FIRST BLOCK OF ACCOUNTS:DATA TO DETERMINE THE NEXT BLOCK TO WRITE.
122770   %
122770          0=:BLOC2; "PARA2+ACBASE"; *MON 2RFIL
122773          IF A><0 THEN
122774             GO FAR CL2FI
122775          FI
122775          BACCO(0)=:NMBR=:BLOC2           % CURRENT NUMBER OF BLOCKS IN FILE
123001          BACCO(1)=:DMAX                  % NUMBER OF BLOCKS BEFORE A WARNING MESSAGE IS GIVEN.
123004          BACCO(2)=:RMAX                  % MAXIMUM NUMBER OF BLOCKS ALLOWED IN THE FILE.
123007          IF NMBR > RMAX THEN             % ACCOUNTING FILE FULL
123013             244=:ERFL
123015             GO FAR FICL
123016          FI
123016   %
123016   %      EXAMINE THE RT-ACCOUNTING TABLE IN POF AND DETERMINE WHICH RT-PROGRAMS ARE BEING ACCOUNTED.
123016   %
123016          NBSRT SHZ 1 + IOACTAB=:IOPOI    % COMPUTE START OF I/O ACCOUNTING TABLE FOR USER RT-PROGRAMS;
123022          ACTAB=:ACPOI                    % (FOLLOWS TABLE FOR SYSTEM RT-PROGRAMS.)
123024          NBRTP-1*3+ACPOI=:ENDAC          % LAST RECORD (3 WORDS IN ACTAB).
123031   %
123031   %      GIVE VALUES TO THOSE PARTS OF ACCOUNTS RECORD WHICH ARE CONSTANT.
123031   %
123031          1=:BACCO(10)                    % ACCOUNT TYPE = RT ENTRY
123034          0=:BACCO(13)=:BACCO(14)         % TERMINAL TIME USED.
123040          0=:BACCO(15)                    % TERMINAL NUMBER.
123042          GO FILSK
123043   *)FILL
123063   %-------------------------------------------------------------------------------
123063   %            READ ALL RECORDS IN ACTAB AND DETERMINE WHICH RT-PROGRAMS SHOULD BE ACCOUNTED
123063
123063   FILSK: A:=ACPOI                        % INITIALISE LOOP VARIABLE.
123064   MLOOP:
123064   %      FOR ACPOI STEP 3 TO ENDAC DO
123064             IF A >> ENDAC GO FAR SUIT6
123067             A=:X
123070             CALL AR3READ                 % READS TAD FROM TABLE-AREA
123071   %
123071   %         DETERMINE IF THIS PROGRAM SHOULD BE LOGGED. IF T-REG >< 0 IT SHOULD.
123071   %         A RECORD NEED ONLY BE WRITTEN IF AD-REG >< 0 OR ENTRY FROM
123071   %         IOACT >< 0.
123071   %
123071             IF T=0 GO FAR NEXT           % PROGRAM MUST NOT BE ACCOUNTED
123073             T=:BLOC1                     % BLOCK NUMBER IN RTPROJ:DATA FILE
123074             IF A><0 OR D><0 THEN
123077                T:=1
123100             ELSE
123101                T:=0
123102             FI
123102             AD=:DBACC(16)                % CPU TIME USED.
123104             IF IOACTAB><X:=-1 THEN
123110                X:=IOPOI
123111                CALL AR2READ
123112             ELSE
123113                0=:A=:D
123115             FI
123115             IF T=0 AND D=0 AND A=0 GO FAR NEXT
123123             AD=:DBACC(30)                          % NUMBER OF BLOCK I/O TRANSFERS.
123125   %
123125   %         CHECK THAT THERE IS ROOM IN THE ACCOUNTS:DATA FILE BEFORE TRYING TO WRITE THIS RECORD.
123125   %
123125             IF NMBR > RMAX THEN                    % ACCOUNTS:DATA FILE FULL.
123131                244=:ERFL; GO FAR SUIT6
123134   *)FILL
123142             ELSE
123143                IF A > DMAX THEN
123146                   243=:ERFL
123150                FI
123150             FI
123150             "PARA1+ACBASE"; *MON 2RFIL; JAF LERR6    % READ PROJECT NAME.
123153   %
123153   %         BUILD RECORD FOR ACCOUNTS:DATA.
123153   %
123153             FOR X:=0 TO 3 DO; BRTPR(X)=:BACCO(X); OD         % COPY RT-PROGRAM NAME TO ACCOUNTS:DATA RECORD.
123163             A:=#  ;
123164             FOR X:=4 TO 7 DO; A=:BACCO(X); OD                % PAD WITH SPACES
123173
123173   %         PACK AND INSERT TIME OF DUMPING THIS RECORD.
123173
123173             "TPARA+ACBASE"; *MON 2CLOC                       % GET TIME OF DUMP
123175             D:=0; A:=YEAR-3554/\77; AD SHR 4; A+MNTH
123203             AD SHR 5; A+DAY; AD SHR 5
123206             A+HOUR; AD SHR 6; A+MINUT; AD SHR 6; A+SEC:=:D
123214             A=:BACCO(11); A:=D=:BACCO(12)                    % STORE TIME IN ACCOUNTING RECORD.
123221             X:=ACPOI+1
123223             0=:A=:D
123225             CALL AR2WRITE                                    % RESET ENTRY
123226             IF IOACTAB >< -1 THEN
123232                X:=IOPOI
123233                0=:A=:D
123235                CALL AR2WRITE                                 % RESET ENTRY
123236             FI
123236             FOR T:=4 TO A:=13 DO
123242                BRTPR(T); X:=X+14; A=:BACCO(X)                % COPY PROJECT NAME TO ACCOUNTING RECORD.
123246             OD
123250             MIN BLOC2
123251             "PARA2+ACBASE"; *MON 2WFIL; JAF LERR6             % WRITE BLOCK TO ACCOUNTS:DATA
123254             MIN NMBR
123255   NEXT:
123255             IOPOI+2=:IOPOI
123260             ACPOI+3=:ACPOI
123263             0=:BACCO(32)=:BACCO(33)=:BACCO(34)=:BACCO(35)
123273             GO FAR MLOOP
123274   %      OD
123274
123274   *)FILL
123306   %-------------------------------------------------------------------------------
123306   %      WHOLE TABLE EXAMINED AND RECORDS WRITTEN. UPDATE FIRST BLOCK OF ACCOUNTS:DATA
123306   %      AND WRITE IT BACK.
123306   %
123306   LERR6: A=:SAERR                                            % FILESYSTEM ERROR IN LOOP.
123307   SUIT6: NMBR=:BACCO(0); DMAX=:BACCO(1); RMAX=:BACCO(2)
123320          0=:BLOC2; "PARA2+ACBASE"; *MON 2WFIL; JAF CL2FI     % ALL RECORDS JUST WRITTEN LOST IF THIS ERROR OCCURS.
123324          IF A:=SAERR >< 0 GO CL2FI
123326
123326   %      CLOSE FILES AND RELEASE ACCOUNTING SEMAPHORE.
123326
123326   FICL:  T:=FILN2; *MON 2CLOS; JAF CL2FI              % CLOSE FILES
123331          T:=FILN1; *MON 2CLOS; JAF CL1FI
123334          "ACCSEMRE";  *MON 2RELE                      % RELEASE ACCOUNTING SEMAPHORE
123336
123336          IF ERFL >< 0 THEN
123340             *MON 2ERMS                   % ACCOUNTS:DATA FULL OR NEARLY FULL.
123341          FI
123341
123341          *MON 2RTEX                      % EXIT
123342
123342   %-------------------------------------------------------------------------------
123342   %            ERROR EXITS.
123342
123342   INTEGER XERSA:=0
123343   CL2FI: A=:SAERR                        % ERROR WITH 2 FILES OPEN AND SEMAPHORE RESERVED.
123344          T:=FILN2; *MON 2CLOS; JMP *+1   % CLOSE ACCOUNTS:DATA
123347          GO CLOFI
123350   CL1FI: A=:SAERR                        % ERROR WITH 1 FILE OPEN AND SEMAPHORE RESERVED.
123351   CLOFI: T:=FILN1; *MON 2CLOS; JMP *+1   % CLOSE RTPROJ:DATA
123354          GO RESEM
123355   SEMER: A=:SAERR                        % ERROR WITH SEMAPHORE RESERVED.
123356   RESEM: "ACCSEMRE"; *MON 2RELE          % RELEASE SEMAPHORE.
123360          IF SAERR=147 AND XERSA><T THEN  % ONLY ONE ERROR MESSAGE
123367             SAERR=:XERSA;   *MON 2ERMS;  % IF DEVICE UNIT RESERVED FOR SPECIAL USE
123372          FI
123372          *MON 2RTEX
123373
123373   RBUS
123376   *"
"123376   @DEV 1
123376   @DEV (S-S-L)RP-P2-MON-ADP:NPL
123376   % TAB P
123376   *"8ADP 8LAMU
"123376   %

123376   %=========================================================================
123376   %
123376   %       MON ADP
123376   %
123376   %       GLOBAL DATA
123376   %
123376   % SYMBOL MAXPLAMU=11                 % NUMBER OF PROGRAM LAMUS.
123376   % INTEGER ARRAY PROGLAMU(MAXPLAMU+1) % PROGRAM LAMU ARRAY
123376   %     "FREDS"                        % FIRST EXTRA DATA SEGMENT.
123376   %
123376   @LIB CXCPU
123376   % )MCDEF ADPSG                       % MACRO FOR MAKING EXTRA DATA SEGMENTS.
123376   % 0;0;200;CSGLE;SGMAD;111;140000;0
123376   % ]
123376   % (FREDS=*@-3)
123376   @ELIB
123376   @LIB CXCPU-,
123376   % MSGLE 77                           % HOW TO USE THE ADPSG MACRO.
123376   % ADPSG
123376   %
123376   % INTEGER MAILAMU                    % MAIL BOX LAMU FOR THIS BACKGROUND PROGRAM.
123376   % INTEGER MAILCON                    % MAIL BOX LAMU CONNECTION FLAG.
123376   % INTEGER RUNLAMU                    % CURRENT EXECUTING PROGRAM LAMU.
123376   % INTEGER OLDEREENT                  % SAVED RENTRANT SEGMENT, WHILE IN LAMU.
123376   %
123376   SUBR MNADP
123376
123376   % MON LAMU FUNCTION CODES.
123376
123376   SYMBOL 6LADEL=2     % DELETE LAMU.
123376   SYMBOL 6LACON=3     % CONNECT LAMU.
123376   SYMBOL 6LADISC=4    % DISCONNECT LAMU.
123376   SYMBOL 6LAPRO=7     % PROTECT LAMU.
123376   SYMBOL 6LACRE=11    % CREATE SYSTEM LAMU.
123376
123376   % PARAMETERS AND LOCAL VARIABLES.
123376
123376   DISP 0
123376       INTEGER FUNKSJON=ZTREG                  % FUNCTION CODE (PARAMETER).
123376       INTEGER NOPAGES=ZXREG                   % NUMBER OF PAGES IN PROGRAM LAMU (PARAMETER).
123376       INTEGER ROUTINE=ZAREG, LASTATUS=ZAREG   % ROUTINE NUMBER (PARAM) AND STATUS.
123376       INTEGER LAFUNC=D0                       % MON LAMU PARAMETERS.
123376       INTEGER LAID=D1
123376       INTEGER LASIZE=D2,  LAPRGR=D2, LAPRT=D2
123376       INTEGER LAPHYSA=D3, LALOGAD=D3
123376       INTEGER ALFUNC=D4                       % ADDRESSES OF MON LAMU PARAMETERS.
123376       INTEGER ALID=D5
123376       INTEGER ALSIZE=D6
123376       INTEGER ALPHYSA=D7
123376       INTEGER POINTER LREG=D8                 % RETURN ADDRESS FOR SUBROUTINES.
123376       INTEGER ERSTAT=D9                       % SAVED ERROR CODE IF FATAL ERROR.
123376   PSID
123376
123376   MNADP:  CALL GET0                           % GET PARAMETERS.
123377           MLEV; *MST PIE                      % ENABLE PAGE FAULTS.
123401           IF "FREDS" = 0 OR SGADPSIZE = 0 GO ERRIMPL % NOT IMPLEMENTED.
123406           "LAFUNC"+B=:ALFUNC                  % INITIALIZE MON LAMU PARAMETER LIST.
123411           A+"LAID-LAFUNC"=:ALID
123413           A+"LASIZE-LAID"=:ALSIZE
123415           A+"LAPHYSA-LASIZE"=:ALPHYSA
123417           IF FUNKSJON = 0 OR >> 15 GO ERRFUNC % CHECK FOR LEGAL FUNCTION.
123424           IF A > 5 AND < 14 AND X:="BFIELD".PASSTYPE >< 2 GO ERRAUTH % MUST BE USER SYSTEM FOR THESE FUNCTIONS.
123437           T:="OKADP"=:L
123441   @ICR
123441           A GOSW ERRFUNC, FAR GOADP, FAR GOSUB, FAR CONMAIL, FAR DISMAIL, FAR DELMAIL,
123450                           FAR CREPL, FAR DELPL, FAR CONPD,   FAR DISPD,   FAR PLPRT,
123455                           FAR PLPER, FAR DISALL,FAR GTSEG  ;
123460   @CR;
123460   OKADP:  A:=0
123461   ENADP:  IF A >< 0 AND X:=FUNKSJON<<=2 AND X><0 GO ERROJ
123470           A=:LASTATUS
123471   FINADP: CALL XBMRET
123472           GO RETSTUPR
123473
123473   ERRIMPL:    A:=2ADP; CALL 9ERRA(#00); GO RETXIT % ILLEGAL MONITOR CALL.
123477   ERRFUNC:    ER114; GO ENADP         %   ILLEGAL FUNCTION.
123501   ERRID:      ER236; GO ENADP         %   ILLEGAL PROGRAM LAMU ID.
123503   ERREXIST:   ER237; GO ENADP         %   PROGRAM LAMU ALREADY EXISTS.
123505   ERRNPR:     ER238; GO ENADP         %   NO SUCH PROGRAM LAMU.
123507   ERRSIZE:    ER239; GO ENADP         %   ILLEGAL PROGRAM LAMU SIZE.
123511   ERRCON:     ER240; GO ENADP         %   PROGRAM LAMU NOT CONNECTED.
123513   ERRNAA:     RX000; GO ENADP         %   NOT ALLOWED NOW.
123515   ERRLAMU:           GO ENADP         %   ERROR CODE FROM MON LAMU.
123516   ERRAUTH:    A:=25; GO ENADP         %   YOU ARE NOT AUTHORIZED TO DO THIS.
123520
123520   ERROJ:                              % ERROR IN FUNCTION 1 OR 2 IS FATAL.
123520               A=:ERSTAT               % SAVE ERROR CODE.
123521               6LADISC=:LAFUNC         % DISCONNECT LAMU.
123523               -1=:LAID                % ALL LAMUS.
123525               0=:LAPRGR               % THIS PROGRAM.
123526               A:="ALFUNC"+B
123530               *MON 2LAMU; RAND
123532               0=:MAILCON=:RUNLAMU     % NO MAILBOX AND NO PROGRAM LAMU CONNECTED.
123534               ERSTAT=:D; A:=ZPREG     % ERROR PARAMETERS.
123537               T:=FUNKSJON; X:=#79;    % FATAL ERROR IN MON ADP.
123541   @LIB CXCPU
123541               *IOF
123542               CALL NW9ERR             % WRITE ERROR AND
123543               *ION
123544   @ELIB
123544   @LIB CXCPU-,
123544               GO RETXIT               % ABORT PROGRAM.
123545   *)FILL
123612
123612   CREMAIL:                        % CREATE MAIL BOX LAMU.
123612           6LACRE=:LAFUNC          % CREATE SYSTEM LAMU.
123614           0=:LAID                 % RETURN ID.
123615           1=:LASIZE               % ONE PAGE.
123617           0=:LAPHYSA              % ANYWHERE.
123620           A:="ALFUNC"+B
123622           *MON 2LAMU
123623           GO FAR ERRLAMU
123624           LAID=:MAILAMU           % MAIL BOX LAMU ID.
123626           EXIT
123627
123627                                   % ------ FUNCTION   3
123627   CONMAIL:A:=L=:"LREG"            % CONNECT MAIL BOX LAMU.
123631           IF MAILCON >< 0 THEN EXIT FI
123634           IF MAILAMU = 0 THEN     % IF NO MAIL BOX,
123636               CALL CREMAIL        %   THEN CREATE IT.
123637           FI
123637           6LACON=:LAFUNC          % CONNECT LAMU.
123641           MAILAMU=:LAID           % MAIL BOX.
123643           0=:LAPRGR               % THIS PROGRAM.
123644           277=:LALOGAD            % LAST PAGE IN DATA BANK.
123646           A:="ALFUNC"+B
123650           *MON 2LAMU
123651           GO FAR ERRLAMU
123652           1=:MAILCON              % MAIL BOX IS CONNECTED.
123654           GO LREG
123655
123655                                   % ------ FUNCTION   4
123655   DISMAIL:                        % DISCONNECT MAIL BOX LAMU.
123655           IF MAILCON = 0 THEN EXIT FI % NO LAMU CONNECTED: NO DISCONNECT.
123660           MAILAMU=:LAID           % MAIL BOX.
123662           6LADISC=:LAFUNC         % DISCONNECT LAMU.
123664           0=:LAPRGR               % THIS PROGRAM.
123665           A:="ALFUNC"+B
123667           *MON 2LAMU
123670           GO FAR ERRLAMU
123671           0=:MAILCON              % MAIL BOX IS NOT CONNECTED.
123672           EXIT
123673
123673                                   % ------ FUNCTION   5
123673   DELMAIL:                        % DELETE MAILBOX LAMU.
123673           IF OLDPAG NBIT RING2 GO FAR ERRAUTH % MUST BE RING2 PROGRAM.
123676           IF MAILCON >< 0 THEN    % IF MAILBOX LAMU CONNECTED.
123700               CALL DISMAIL        % THEN DISCONNECT IT.
123701           FI
123701           MAILAMU=:LAID           % MAILBOX LAMU.
123703           0=:MAILAMU              % NO MORE MAILBOX LAMU.
123704           6LADEL=:LAFUNC          % DELETE LAMU.
123706           A:="ALFUNC"+B
123710           *MON 2LAMU
123711           GO FAR ERRLAMU
123712           GO FAR OKADP
123713   *)FILL
123722                                   % ------ FUNCTION   1
123722   GOADP:                          % GO TO ADP LAMU.
123722           IF RUNLAMU >< 0 GO FAR ERRNAA   % NOT POSSIBLE NOW.
123725           IF ROUTINE SHZ -12 >> MAXPLAMU OR = 0 GO FAR ERRID % INDEX IS 1 TO MAXPLAMU.
123734           IF PROGLAMU(A) = 0 GO FAR ERRNPR
123740           A=:LAID                 % PROGRAM LAMU ID.
123741           6LACON=:LAFUNC          % CONNECT LAMU.
123743           0=:LAPRGR               % THIS PROGRAM.
123744           100=:LALOGAD            % PROGRAM LAMU AS PROGRAM BANK.
123746           A:="ALFUNC"+B
123750           *MON 2LAMU
123751           GO FAR ERRLAMU
123752           CALL CONMAIL            % CONNECT (AND CREATE) MAIL BOX.
123753           ROUTINE SHZ -12=:RUNLAMU % NOW RUNNING IN LAMU.
123756   @LIB CXCPU
123756           "FREDS"+"BFIELD".BPIUSIDX=:CURPROG.ACT1SEG  % USE EXTRA DATA SEGMENT.
123763   @ELIB
123763   @LIB CXCPU-,
123763           X.RSEGM=:OLDEREENT      % SAVE USERS OLD REENTRANT SEGMENT.
123765           0=:X.RSEGM              % USE NO REENTRANT SEGMENT.
123766           ZPREG =: ZLREG          % SAVE RETURN ADDRESS.
123770   @LIB OLD
123770           0=:ZPREG                % START IN ADDRESS 0.
123771           GO FAR FINADP
123772
123772   DISRL:                          % DISCONNECT PROGRAM LAMU SUBROUTINE.
123772           PROGLAMU(A)=:LAID       % CURRENT PROGRAM LAMU.
123775           6LADISC=:LAFUNC         % DISCONNECT LAMU.
123777           0=:LAPRGR               % THIS PROGRAM.
124000           A:="ALFUNC"+B
124002           *MON 2LAMU
124003           GO FAR ERRLAMU
124004           0=:RUNLAMU              % NOT RUNNING IN LAMU.
124005           IF OLDPAG NBIT RING2 THEN
124010   @LIB CXCPU
124010               "BFIELD".BC1SEGM=:CURPROG.ACT1SEG % USING BACKGROUND SEGMENT.
124014   @ELIB
124014   @LIB CXCPU-,
124014           FI
124014           EXIT
124015
124015                                   % ------ FUNCTION   2
124015   GOSUB:                          % GO TO SUBSYSTEM.
124015           IF RUNLAMU <= 0 GO FAR ERRNAA % PROGRAM LAMU MUST BE ACTIVE.
124020           CALL DISRL
124021           OLDEREENT=:X.RSEGM      % USING REENTRANT SEGMENT.
124023           ZAREG=:ZPREG            % RETURN ADDRESS.
124025           GO FAR FINADP
124026   *)FILL
124042                                   % ------ FUNCTION   6
124042   CREPL:                          % CREATE PROGRAM LAMU.
124042           IF ROUTINE >> MAXPLAMU OR = 0 GO FAR ERRID % INDEX IS 1 TO MAXPLAMU
124050           IF PROGLAMU(A) >< 0 GO FAR ERREXIST % ALREADY CREATED.
124054           6LACRE=:LAFUNC          % CREATE SYSTEM LAMU.
124056           0=:LAID                 % RETURN ID.
124057           NOPAGES=:LASIZE         % SPECIFIED NUMBER OF PAGES.
124061           IF A = 0 OR A >> 100 GO FAR ERRSIZE % ILLEGAL SIZE.
124065           0=:LAPHYSA              % ANYWHERE.
124066           A:="ALFUNC"+B
124070           *MON 2LAMU
124071           GO FAR ERRLAMU
124072           X:=ROUTINE              % PROGRAM LAMU INDEX.
124073           LAID=:PROGLAMU(X)       % SET UP SYSTEM LAMU ID.
124075           GO FAR OKADP
124076
124076                                   % ------ FUNCTION    7
124076   DELPL:                          % DELETE PROGRAM LAMU.
124076           IF ROUTINE >> MAXPLAMU OR = 0 GO FAR ERRID % INDEX IS 1 TO MAXPLAMU
124104           IF PROGLAMU(A) = 0 GO FAR ERRNPR % NO SUCH LAMU.
124110           0=:PROGLAMU(X)          % DELETE IN TABLE.
124111           A=:LAID                 % LAMU ID.
124112           6LADEL=:LAFUNC          % DELETE LAMU.
124114           A:="ALFUNC"+B
124116           *MON 2LAMU
124117           GO FAR ERRLAMU
124120           GO FAR OKADP
124121
124121                                   % ------ FUNCTION   10
124121   CONPD:                          % CONNECT PROGRAM LAMU AS DATA BANK.
124121           IF RUNLAMU > 0 GO FAR ERRNAA % PROGRAM LAMU MUST NOT BE ACTIVE.
124124           IF ROUTINE >> MAXPLAMU OR = 0 GO FAR ERRID % INDEX IS 1 TO MAXPLAMU.
124132           PROGLAMU(A)=:LAID       % SPECIFIED PROGRAM LAMU.
124135           IF A = 0 GO FAR ERRNPR  % NO SUCH PROGRAM LAMU.
124137           A=:RUNLAMU              % USING PROGRAM LAMU AS DATA.
124140           CALL FAR DISMAIL        % DISCONNECT MAILBOX FIRST.
124141           6LACON=:LAFUNC          % CONNECT LAMU.
124143           0=:LAPRGR               % THIS PROGRAM.
124144           200=:LALOGAD            % AS DATA BANK.
124146           A:="ALFUNC"+B
124150           *MON 2LAMU
124151           GO FAR ERRLAMU
124152           GO FAR OKADP
124153
124153                                   % ------ FUNCTION   11
124153   DISPD:                          % DISCONNECT PROGRAM LAMU.
124153           IF RUNLAMU >= 0 GO FAR ERRCONN % LAMU NOT CONNECTED.
124156           A=:LAID                 % LAST CONNECTED PROGRAM LAMU.
124157           6LADISC=:LAFUNC         % DISCONNECT LAMU.
124161           0=:LAPRGR               % THIS PROGRAM.
124162           0=:RUNLAMU              % NO PROGRAM LAMU CONNECTED.
124163           A:="ALFUNC"+B
124165           *MON 2LAMU
124166           GO FAR ERRLAMU
124167           GO FAR OKADP
124170                                       % ------ FUNCTION   12
124170   PLPRT:  060000=:D; GO FELPR         % PROGRAM LAMU WRITE PROTECT.
124173
124173                                       % ------ FUNCTION   13
124173   PLPER:  160000=:D                   % PROGRAM LAMU WRITE PERMIT.
124175
124175
124175   FELPR:  IF ROUTINE >> MAXPLAMU OR = 0 GO FAR ERRID % CHECK INDEX.
124203           IF PROGLAMU(A) = 0 GO FAR ERRNPR % CHECK THAT LAMU IS DEFINED.
124207           A=:LAID                     % PROGRAM LAMU ID.
124210           6LAPRO=:LAFUNC              % PROTECT LAMU.
124212           A:=D=:LAPRT                 % PROTECTION FROM D-REG.
124214           A:="ALFUNC"+B
124216           *MON 2LAMU
124217           GO FAR ERRLAMU
124220           GO FAR OKADP
124221   *)FILL
124240                                       % ------ FUNCTION   14
124240   DISALL:                             % DISCONNECT MAILBOX AND PROGRAM LAMU.
124240           IF OLDPAG NBIT RING2 GO FAR ERRAUTH % MUST BE RING2 PROGRAM.
124243           IF MAILCON >< 0 THEN        % DISCONNECT MAILBOX IF CONNECTED.
124245               CALL FAR DISMAIL
124246           FI
124246           IF RUNLAMU < 0 THEN         % DISCONNECT PROGRAM LAMU AS DATA.
124250               A=:LAID
124251               6LADISC=:LAFUNC
124253               0=:LAPRGR
124254               0=:RUNLAMU
124255               A:="ALFUNC"+B
124257               *MON 2LAMU
124260               GO FAR ERRLAMU
124261           ELSE IF A > 0 THEN          % DISCONNECT PROGRAM LAMU.
124264               CALL FAR DISRL
124265           FI FI
124265           GO FAR OKADP
124266
124266                                       % ------ FUNCTION   15
124266   GTSEG:                              % GET ADP-SEGMENT NUMBER
124266           A:="FREDS"+"BFIELD".BPIUSIX
124271           A=:ZTREG
124272           GO FAR OKADP
124273   RBUS
124305   *"
"124305   @DEV 1
124305   @DEV (S-S-L)RP-P2-CONFG:NPL
124305   % TAB P
124305   %

124305   %==============================================================================
124305   %
124305   %   MON   C O N F I G U R A T I O N         (VSX)
124305   %
124305   %           ENTRY:  A - PARAMETER LIST:
124305   %                           FUNCTION.
124305   %                           PARAMETER INDEX.
124305   %                           PARAMETER SUBINDEX.
124305   %                           VALUE (IN/OUT).
124305   %
124305   %           EXIT:   SKIP RETURN:    OK.
124305   %                   ERROR RETURN:   A - ERROR CODE:
124305   %                                        25 - YOU ARE NOT AUTHORIZED TO DO THIS.
124305   %                                        33 - NO SUCH LOGICAL UNIT.
124305   %                                       174 - ILLEGAL PARAMETER.
124305   %                                       201 - ILLEGAL FUNCTION CODE.
124305   %                                      3201 - ILLEGAL INDEX.
124305   %                                      3222 - TO BIG TABLES. REDUCE SOME OF THE VARIABLES
124305   %                                             X4TSK,X5PRT,X5LNK,X4ACK,X4NBF OR  X5TRB
124305   %
124305   SUBR MNCFG
124305
124305   %       FUNCTION ARRAY TABLE ENTRY.
124305
124305   DISP 0
124305       INTEGER CFFUN                           % LEGAL FUNCTIONS FOR THIS ENTRY.
124305       INTEGER CFHOW                           % HOW TO COMPUTE THIS VALUE.
124305       INTEGER CFVAL                           % VALUE TO USE OR DIVIDE.
124305       INTEGER POINTER CFSPECI=CFVAL           % SPECIAL ROUTINE.
124305       INTEGER CFDIV, CFMIN=CFDIV              % VALUE TO DIVIDE BY.
124305       INTEGER POINTER CFADR, CFROUT=CFADR     % ROUTINE OR VALUE POINTER.
124305       INTEGER CFDESC=CFADR                    % DESCRIPTOR POINTER.
124305   PSID
124305
124305   %       DESCRIPTOR ENTRY.
124305   DISP 0
124305       INTEGER DEADR           % ADDRESS OF ARRAY IN SAVE AREA.
124305       INTEGER DENUMB          % NUMBER OF ELEMENTS IN ARRAY.
124305       INTEGER ELSIZE          % SIZE OF EACH ELEMENT IN THE ARRAY.
124305       INTEGER POINTER DECHECK % ROUTINE TO CHECK FOR LEGAL VALUES.
124305   PSID
124305
124305   %       LEGAL FUNCTIONS.
124305   @ICR;
124305   SYMBOL  0FUSAVE  =17, 1FUSAVE  =100000,     % READ SAVE AREA (NEXT VALUE).
124305           0FUREAD  =16, 1FUREAD  = 40000,     % READ ACTIVE VALUE.
124305           0FUWRITE =15, 1FUWRITE = 20000,     % WRITE SAVE AREA (NEXT VALUE).
124305           0FUGENER =14, 1FUGENER = 10000,     % READ GENERATED VALUE.
124305           0FUFREE  =13, 1FUFREE  =  4000,     % AVAILABLE UNITS (IN MEMORY).
124305           0FUSPECI =12, 1FUSPECI =  2000,     % SPECIAL FUNCTION (PARAMETER DEPENDENT).
124305
124305   %       FUNCTIONS ALLOWED FROM ALL USERS (SUBSET OF ABOVE)
124305
124305           0BFSAVE  = 7, 1BFSAVE  =100200,     % READ SAVE AREA (NEXT VALUE).
124305           0BFREAD  = 6, 1BFREAD  = 40100,     % READ ACTIVE VALUE.
124305           0BFWRITE = 5, 1BFWRITE = 20040,     % WRITE SAVE AREA (NEXT VALUE).
124305           0BFGENER = 4, 1BFGENER = 10020,     % READ GENERATED VALUE.
124305           0BFFREE  = 3, 1BFFREE  =  4010,     % AVAILABLE UNITS (IN MEMORY).
124305           0BFSPECI = 2, 1BFSPECI =  2004,     % SPECIAL FUNCTION (PARAMETER DEPENDENT).
124305
124305   %       PROCEDURE TO COMPUTE VALUE.
124305
124305           0PRDIVIDE   =0, 1PRDIVIDE  =  1,    % DIVIDE VALDIV BY DIVBY.
124305           0PRVALUE    =1, 1PRVALUE   =  2,    % USE VALUE.
124305           0PRADDRESS  =2, 1PRADDRESS =  4,    % USE ADDRESS.
124305           0PRROUTINE  =3, 1PRROUTINE = 10,    % CALL ROUTINE.
124305           0PRPHADDR   =4, 1PRPHADDR  = 20,    % USE PHYSICAL ADDRESS.
124305           0PRUADDR    =5, 1PRUADDR   = 40,    % USE VALUE AS ADDRESS.
124305           0PRARRAY    =6, 1PRARRAY   =100,    % ADDRESS OF ARRAY.
124305           0PRDESCR    =7, 1PRDESCR   =200,    % USE DESCRIPTOR.
124305           0PRUROUT   =10, 1PRUROUT   =400,    % USE VALUE AS ROUTINE.
124305
124305   %       RANGE.
124305
124305           0RAONOFF =17, 1RAONOFF =100000,     % VALUE IS ON OR OFF.
124305           0RAMIN   =16, 1RAMIN   = 40000;     % MINIMUM VALUE.
124305   ;@CR;
124305   INTEGER ARRAY FUNARR(0)                     % FUNCTION ARRAY.
124305   *"8VSX0
"124305   DATA(1FUGENER+1FUREAD, 1PRVALUE+1PRADDRESS, 1, 0, WMVERS)   % STANDARD SYSTEM.
124312   *"-8VSX0
"124312   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 5BUFA, 0, MXDVBUFS)     % DEVICE BUFFERS.
124317   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE, 77777, 0, DVBFPAGE)     % FIRST DVBUF PAGE.
124324   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9BDSL-9BDST, 5BDSZ, MXTADS)      % TADS.
124331   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LBPR-9LTBP, 5RTSIZE, MXBATCHES) % BATCHES.
124336   *"-8COSP
"124336   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, ENDSP-SPTAB-11, 12, MXSPOOLERS)  % SPOOLERS.
124343   *"-8BACS
"124343   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LTBP-9FBPR, 5RTSIZE, MXBPROGS)  % BAKS.
124350   *"
"124350   DATA(1FUREAD,                           1PRADDRESS,          0,     0, MXTBPROGS)       % BAKS IN USE.
124355   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 0DBNU, 0, MXSDB) % DEBUGGERS.
124362   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, NU5PR, 0, MX5PROCS)    % ND500 PROCS.
124367   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRUADDR+1PRADDRESS, NRFSG, 0, MXRFACS)     % RFA SEGMENTS.
124374   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE+1RAMIN, 16,    2, SPQSSIZE)    % SPOOL-Q SIZE.
124401   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE+1RAMIN, 10,    5, SISYSEG)     % SYS.SEG SIZE.
124406   *"-8ADP
"124406   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS+1RAONOFF, 1, 0, SGADPSIZE) % MON ADP.
124413   *"-8BACS
"124413   DATA(1FUGENER,                          1PRVALUE,   1, 0, 0) % 8BACS.
124420   *"-8COSP
"124420   DATA(1FUGENER,                          1PRVALUE, 1, 0, 0)   % COSMOS SPOOLING.
124425   *"
"124425
124425   DATA(1FUGENER+1FUFREE,      1PRDIVIDE+1PRROUTINE, 9FBPR-RTBES, 5RTSIZE, RTFREE) % USER RTP.
124432   DATA(1FUGENER+1FUFREE,      1PRVALUE+1PRROUTINE,  0USSG,       0,       SGFREE) % USER SEGS.
124437   DATA(1FUREAD+1FUGENER,      1PRDIVIDE+1PRROUTINE, 5TFST-5TTST, 5TTSZ,   TERCNT) % TERMINALS.
124444   DATA(1FUGENER,              1PRDIVIDE,            5TEND-5TFST, 5TTSZ+5TTSZ, 0)  % TELEFIXES.
124451
124451   DATA(1FUGENER,              1PRDIVIDE,            0SELA-0SEFI, 4 , 0)           % SEMAPHORES.
124456   DATA(1FUGENER,              1PRVALUE,             0INDV,    0, 0)               % INT. DEV. (TOTAL).
124463   DATA(1FUGENER,              1PRVALUE,             0INBL,    0, 0)               % INT. DEV. (BLOCK).
124470   DATA(1FUGENER,              1PRVALUE,             SIBAP-SIBBD, 0, 0)            % SIBAS.
124475   DATA(1FUREAD,               1PRROUTINE,           0, 0, VOPFI)                  % OPEN FILES.
124502   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 14000, 10, MXALLMEM) % ALLOCATED MEMORY.
124507
124507   *"8LAMU
"124507   DATA(1FUGENER,                 1PRVALUE,                      1, 0, 0)       % MON LAMU (PRESENT).
124514   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 4000, 1, GNLAMU)  % MAX NUMBER OF LAMUS.
124521   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN,  100, 1, GNLPRT)  % MAX LAMUS PER PROG.
124526   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 4000, 0, GNSYL)   % MAX SYSTEM LAMUS.
124533   *"-8LAMU
"124533   DATA(1FUREAD,       1PRARRAY,  1\2, 0, SOFT500)     % ND500 SOFTWARE VERSIONS.
124540   DATA(1FUREAD,       1PRARRAY, 1\10, 0, MICP500)     % ND500 MICROPROGRAM (PER CPU).
124545   DATA(1FUREAD,       1PRADDRESS,  0, 0, HWINFO+1)    % ND110 MICROPROGRAM.
124552
124552   DATA(1FUREAD,       1PRARRAY, 0\12, 0, MEMCON)  % MEMORY CONFIGURATION.
124557
124557   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUSPECI, 1PRDESCR,   DELOGNO, 0, HDDESC)       % HDLC TYPE.
124564   DATA(1FUGENER,                          1PRUROUT,    CNHDLC, 0, 0)            % # HDLC-HDLC.
124571   DATA(1FUGENER,                          1PRUROUT,    CNSYNC, 0, 0)            % # HDLC-SYNCH.MOD.
124576   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 0NX21, 0, MXX21) % X21.
124603
124603   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRDESCR, 0,       0, SPDESC) % SPOOLING DEVICES.
124610   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUSPECI, 1PRDESCR, DELOGNO, 0, LPDESC) % LINE-PRINTER TYPE.
124615
124615   *"8F5UD
"124615   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LPUD-9FPUD, 5RTSIZE, 5FUDMA) % FAST UDMA.
124622   *"-8F5UD
"124622   DATA(1BFREAD, 1PRADDRESS, 0, 0, FPIMP)            % READ FIRST PAGE IN MULTIPORT
124627
124627   DATA(1FUREAD                 , 1PRDESCR, 0, 0, DXCAL)  % READ XMSG PARAMETERS USED FOR CALCULATION OF SPACE
124634   DATA(1FUREAD+1FUSAVE+1FUWRITE, 1PRDESCR, 0, 0, DXRUN)  % MANIPULATE XMSG PARAMETERS
124641   DATA(1FUSAVE,                  1PRDESCR, 0, 0, DXFRE)  % READ FIRST FREE ADDRESS ON XMSG SEGMENT
124646   DATA(1FUREAD+1FUSAVE+1FUWRITE, 1PRDESCR, 0, 0, NUCON)  % NUCLEUS CONFIGURATION PARAMETERS
124653
124653   INTEGER ENARR(0)    % END OF FUNARR.
124653
124653   **<*50;)ZERO        % ADDITIONAL AREA FOR PATCHING IN UPTO 8 NEW PARAMETERS.
124653   **50/
124723
124723
124723   % DESCRIPTORS.
124723   INTEGER ARRAY HDDESC:=(0HDTA,0NHDL,TBLHDLCSIZE,CHKHD) % HDLC DEVICES.
124727   INTEGER ARRAY LPDESC:=(0LPTA,0NLPS,LPTBSIZE,CHKLP)    % LINE PRINTERS.
124733   INTEGER ARRAY SPDESC:=(0SPTA,0SPLE,1,CHKSP)           % SPOOLING DEVICES.
124737   INTEGER ARRAY  DXCAL:=(XCALC,7,1,CXDUM)               % XMSG VALUES USED FOR CALCULATIONS OF SPACE
124743   INTEGER ARRAY  DXRUN:=(XRUNA,30,3,CXKXM)              % XMSG GENERATION PARAMETERS
124747   INTEGER ARRAY  DXFRE:=(FSXMF,1,1,CXDUM)               % FIRST FREE ADDRESS ON XMSG SEGMENT
124753   INTEGER ARRAY  NUCON:=(NUPAR,12,1,CXDUM)              % NUCLEUS GENERATION PARAMETERS
124757
124757   DISP 0
124757       INTEGER FUNC=D0             % FUNCTION (PARAMETER).(NB! D0 also used by XFLAG)
124757       INTEGER IDEX=D1             % INDEX IN FUNARR (PARAMETER).(NB! D1 also used by LTEM)
124757       INTEGER SUBIDEX=D2          % SUBINDEX (PARAMETER).
124757       INTEGER VAL=D3              % INPUT OR OUTPUT VALUE (PARAMETER).
124757
124757       INTEGER LTEM=D1             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER POINTER LREG=D7     % RETURN ADDRESS IN LOCAL SUBROUTINES.
124757       INTEGER LANT=D7             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER XGPSEGM=D4          % SEGMENT FOR WSEG.
124757       INTEGER AGPSEGM=D5          % ADDRESS OF XPGSEGM.
124757       INTEGER LPDISP=D5           % RECORD DISPLACEMENT IN CNHDLC AND CNSYNC.
124757       INTEGER LPEND=D6            % LOOP END VALUE FOR LOCAL SUBROUTINES.
124757       INTEGER TAVL=D6             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER LPCNT=S5            % LOOP COUNTER FOR LOCAL SUBROUTINES.
124757       INTEGER BUSD=S5             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER DEPNT=S4            % ADDRESS OF ARRAY ENTRY.
124757       INTEGER CHVAL=D3            % SPOOLING DEVICE NUMBER.
124757   PSID
124757
124757   DISP 0                          % VARIBALES FOR GGVAL/PPVAL.
124757       INTEGER XVAL=D4             % SAVED VALUE TO PUT.
124757       INTEGER XRSEGM=D8           % SAVED REENTRANT SEGMENT.
124757       INTEGER XAREG=D9            % SAVED X OR A REGISTER.
124757       INTEGER XOLD1SEG=D10        % SAVED ACT1SEG.
124757       INTEGER POINTER XLREG=D11   % RETURN ADDRESS.
124757       INTEGER XFLAG=D0            % GET/PUT FLAG
124757   PSID
124757
124757   GGVAL:  1=:XFLAG; GO XXVAL                          % GET VALUE FROM SEGMENT.
124762   PPVAL:  A=:XVAL; 0=:XFLAG                           % PUT VALUE TO SEGMENT.
124764   XXVAL:  X=:XAREG; X:=L=:"XLREG"                     % SAVE REGISTERS.
124767           RTREF.ACT1SEG=:XOLD1SEG; X.RSEGM=:XRSEGM    % SAVE OLD SEGMENTS.
124774           T=:X.ACT1SEG; 0=:X.RSEGM                    % SET NEW SEGMENT, NO REENTRANT.
124776           RTREF; CALL LAMINHIBIT                      % NO LAMUS, RETURN THROUGH STUPR.
125000           XAREG=:D:=XFLAG=:L; T:=XVAL                 % GET VALUE AND ADDRESS.
125005           RTREF.ACTPRI/\ACLEAR\/AUPIN=:X.ACTPRI; *TRR PCR % SET UP PCR TO ACCESS SEGMENT.
125013           X:=D                                        % ADDRESS IN X.
125014           IF L=0 THEN
125016               T=:X.S0                                 % PUT VALUE.
125017           ELSE
125020               T:=X.S0                                 % GET VALUE.
125021           FI
125021           *IOF
125022           "NRPIT+ADPIT+ALEVB+ERNG2"; *TRR PCR         % RESTORE ORIGINAL PCR.
125024           A=:RTREF.ACTPRI; *ION
125027           XOLD1SEG=:X.ACT1SEG; XRSEGM=:X.RSEGM        % RESTORE SEGMENTS.
125033           T=:XAREG                                    % SAVE VALUE WHILE
125034           RTREF; CALL LAMENABLE                       % ENABLING LAMUS, RETURN THROUGH STUPR.
125036           A:=XAREG                                    % GET VALUE.
125037           GO XLREG                                    % RETURN.
125040   *)FILL
125046   INTEGER PENARR:=ENARR                               % POINTER TO END OF PARAMETER ARRAY.
125047
125047   MNCFG:  CALL GET4                                   % GET PARAMETERS.
125050           MLEV; *MST PIE                              % ENABLE PAGE FAULTS.
125052           IF IDEX*5+"FUNARR" >>= PENARR GO ILLIDX     % CHECK INDEX.
125060           X:=A; *1BANK; LDF 0,X; 2BANK; STF CFFUN,B   % MOVE TABLE ENTRY
125065                 *1BANK; LDD 3,X; 2BANK; STD CFDIV,B   %   TO WORK AREA.
125071           IF X:=FUNC = 0 OR X >> 6 GO ILLFUNC         % CHECK FUNCTION.
125076           T:=1; X-                                    % BUILD FUNCTION MASK.
125100           FOR X DO T SHR -1; OD
125102           IF CFFUN/\T = 0 GO ILLFUNC                  % CHECK FUNCTION.
125105           IF BACKGROUND><0 AND "BFIELD".PASSTYPE-2><0 THEN
125113              T SHZ -10; IF CFFUN/\T=0 GO ERRAUTH      % MUST BE USER SYSTEM IF BG-PROG.
125117           FI
125117           FUNC GOSW ILLFUNC, FUSAVE, FUREAD, FUWRITE, FUGENER, FAR FUFREE, FAR FUSPECI
125130
125130   PUTVAL: X:=ZAREG+3                  % RETURN DATA IN FOURTH PARAMETER.
125132           T:=OLDPAG=:D
125134           CALL DALTON                 % IN USER DATA PIT.
125135           A=:X.S0.S0                  % GIVE USER DATA.
125137           CALL SINALTPIT              % BACK TO DPIT.
125140   OKEND:  MIN ZPREG; 0/\0             % SKIP RETURN.
125142   ENDMO:  IF BACKGROUND >< 0 THEN CALL XBMRET; FI % FIX SYS.SEG. IN MEMORY.
125145           GO RET                      % END OF MONITOR CALL.
125146
125146   ILLPAR: 174; GO ERRRR   % ILLEGAL PARAMETER.
125150   ILLIDX: RX001; GO ERRRR % ILLEGAL INDEX.
125152   ILLSPA: RX022; GO ERRRR % NO MORE SPACE LEFT ON SEGMENT S3XMK
125154   ILLUNI:  33; GO ERRRR   % NO SUCH LOGICAL UNIT.
125156   ILLFUNC:201; GO ERRRR   % ILLEGAL FUNCTION CODE (FOR THIS INDEX).
125160   ERRAUTH: 25; GO ERRRR   % YOU ARE NOT AUTHORIZED TO DO THIS.
125162   ERRINT:  -1             % INTERNAL ERROR.
125163   ERRRR:  A=:ZAREG
125164           GO ENDMO
125165   *)FILL
125203
125203   FUSAVE: IF CFHOW  BIT 0PRADDRESS THEN X:="CFADR"; T:=5SDPIT; CALL FAR GGVAL
125211           ELSE IF A BIT 0PRDESCR   THEN GO FAR DESAVE
125215           ELSE GO ERRINT FI FI
125217           GO PUTVAL
125220
125220   FUREAD: IF CFHOW  BIT 0PRADDRESS THEN A:=CFADR
125224           ELSE IF A BIT 0PRROUTINE THEN CALL CFROUT
125230           ELSE IF A BIT 0PRDESCR   THEN GO FAR DEREAD
125234           ELSE IF A BIT 0PRARRAY   THEN
125237               A:=CFVAL; AD SHZ -10; D SHZ -10      % SPLIT LOWER AND UPPER LIMITS.
125242               IF T:=SUBIDEX<A OR T>D GO FAR ILLIDX % CHECK SUBINDEX.
125247               CALL CFROUT
125250           ELSE GO ERRINT FI FI FI FI
125252           GO PUTVAL
125253
125253   FUWRITE:IF CFHOW  BIT 0PRADDRESS THEN
125256               IF A BIT 0RAONOFF THEN
125260                   IF VAL >< 0 THEN A:=1 FI    % BINARY VALUE.
125263               ELSE
125264                   CALL WRGENER                                  % GET GENERATED VALUE (MAX).
125265                   IF  A << VAL GO ILLPAR                        % CHECK AGAINST MAX.
125270                   IF CFHOW BIT 0RAMIN AND T<<A:=CFMIN GO ILLPAR % CHECK AGAINST MIN.
125276                   A:=T
125277               FI
125277               X:="CFADR"; T:=5SDPIT; CALL FAR PPVAL       % PUT NEW VALUE.
125302               5SDPIT=:XGPSEGM; A:=B+"XGPSEGM"=:AGPSEGM
125307               A:=B+"AGPSEGM"; *MON 2WSEG                  % WRITE BACK SAVE AREA.
125312           ELSE IF A BIT 0PRDESCR THEN GO FAR DEWRITE
125316           ELSE GO ERRINT FI FI
125320           GO OKEND
125321
125321   FUGENER:A:="PUTVAL"; GO XXGENER
125323   WRGENER:A:=L
125324   XXGENER:A=:"LREG"
125325           IF CFHOW  BIT 0PRUADDR  THEN X:=CFVAL; T:=5SDPIT; CALL FAR GGVAL
125333           ELSE IF A BIT 0PRDIVIDE THEN A:=CFVAL=:D:=0; T:=CFDIV; *RDIV ST
125343           ELSE IF A BIT 0PRVALUE  THEN A:=CFVAL
125347           ELSE IF A BIT 0PRUROUT  THEN CALL CFSPECI
125353           ELSE GO FAR ERRINT FI FI FI FI
125355           GO LREG
125356
125356   FUFREE: IF CFHOW  BIT 0PRROUTINE THEN CALL CFROUT
125362           ELSE GO FAR ERRINT FI
125364           GO FAR PUTVAL
125365
125365   FUSPECI:CALL CFSPECI
125366
125366   *)FILL
125401   RTFREE: D:=0                    % COUNT NUMBER OF FREE USER RT PROGRAMS.
125402           X:="RTBES"
125403           DO WHILE X<<"9FBPR"
125406               IF X.STATUS NBIT 5USED THEN D+1 FI
125412               X+5RTSIZE
125413           OD
125414           A:=D
125415           EXIT
125416
125416   SGCNT:  DO WHILE X<<=LPEND      % COUNT NUMBER OF FREE SEGMENTS FROM X TO LPEND.
125421               T:=SEGTBANK; *SGSTA@3 LDATX
125423               IF A = 0 THEN D+1 FI
125425               X+5SEGSIZE
125426           OD
125427           EXIT
125430
125430   SGFREE: A:=L=:"LREG"            % COUNT NUMBER OF FREE USER SEGMENTS.
125432           D:=0
125433           SEGSTART+"1STFS"=:X     % FIRST GROUP.
125436           SEGSTART+3760=:LPEND
125441           CALL SGCNT
125442           SEGSTART+"SEGTX"=:X     % SECOND GROUP.
125445           SGMAX*5SEGSIZE+SEGSTART=:LPEND
125451           CALL SGCNT
125452           A:=D
125453           GO LREG
125454
125454   TERCNT: D:=0                    % COUNT NUMBER OF TERMINALS IN TIMER TABLE.
125455           X:="9SXTD"
125456           *1BANK                  % TABLE IS IN RPIT.
125457           DO WHILE X<<"9EXTD"
125462               IF X.S0>>"5TTST" AND <<"5TFST" THEN D+1 FI  % TERMINAL PRESENT.
125472               X+2                 % TWO ENTRIES PER TERMINAL.
125473           OD
125474           *2BANK
125475           A:=D
125476           EXIT
125477
125477   VOPFI:  IF DV100>=NPOOL THEN A:=T FI    % THE MAX NUMBER OF OPEN FILES IS
125504           EXIT                            % THE MINIMUM OF THE SIZE OF THE OPEN
125505                                           % OPEN FILE TABLE AND THE NUMBER OF BUFFERS.
125505   *)FILL
125524   DEMOVE: X:=CFDESC                   % MOVE DESCRIPTOR TO WORK AREA.
125525           *1BANK; LDD DEADR,X; 2BANK; STD DEADR,B
125531           *1BANK; LDD ELSIZ,X; 2BANK; STD ELSIZ,B
125535           IF SUBIDEX=0 OR >> DENUMB GO FAR ILLIDX     % CHECK SUBINDEX.
125542           A-1*ELSIZE+DEADR=:X                         % COMPUTE ENTRY POINTER.
125546           EXIT
125547
125547   DESAVE: CALL DEMOVE                 % READ DESCRIPTOR SAVE AREA.
125550           T:=5SAVE; CALL FAR GGVAL
125552           GO FAR PUTVAL
125553
125553   DEREAD: CALL DEMOVE                 % READ DESCRIPTOR CURRENT VALUE.
125554           T:=0; *LDATX
125556           GO FAR PUTVAL
125557
125557   DEWRITE:CALL DEMOVE                 % WRITE DESCRIPTOR NEXT VALUE.
125560           X=:DEPNT
125561           A:=VAL                      % GET VALUE.
125562           CALL DECHECK                % CHECK IT.
125563           X:=DEPNT
125564           T:=5SAVE; CALL FAR PPVAL    % WRITE IT.
125566           5SAVE=:XGPSEGM; A:=B+"XGPSEGM"=:AGPSEGM
125573           A:=B+"AGPSEGM"; *MON 2WSEG                  % WRITE BACK SAVE AREA.
125576           GO FAR OKEND
125577
125577   DELOGNO:CALL DEMOVE     % FIND LOGICAL DEVICE NUMBER.
125600           T:=0; *LDATX 10 % GET DEVICE NUMBER.
125602           GO FAR PUTVAL
125603   *)FILL
125612   CHKHD:  K:="0"; GO CHFEL    % CHECK HDLC PARAMETERS.
125614   CHKLP:  K:="1"              % CHECK LINE PRINTER PARAMETERS.
125615   CHFEL:  IF A=:D = 0 THEN EXIT FI    % 0 IS ALWAYS OK.
125620           IF D=1 THEN                 % FIRST CHOICE.
125623               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125625               IF K THEN; *LDATX 30    % L-P.
125630               ELSE;      *LDATX 20    % HDLC.
125632               FI
125632           ELSE IF D=2 THEN            % SECOND CHOICE.
125636               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125640               *LDATX 40
125641           ELSE IF D=3 AND K THEN      % THIRD CHOICE, ONLY L-P.
125647               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125651               *LDATX 50
125652           ELSE
125653               GO FAR ILLPAR           % OTHER CHOICES ARE ILLEGAL.
125654           FI FI FI
125654           IF A=0 GO FAR ILLPAR        % NOT PRESENT.
125656           A:=D                        % RESTORE VALUE.
125657           EXIT
125660
125660
125660   CHKSP:                              % CHECK SPOOLING PARAMETERS.
125660           EXIT
125661   *)FILL
125662   CNHDLC: 2=:LPDISP       % COUNT NUMBER OF HDLC-HDLC.
125664           GO CNFEL
125665   CNSYNC: 4=:LPDISP       % COUNT NUMBER OF HDLC-SYNCH.
125667   CNFEL:  0=:VAL
125670           *1BANK
125671           A:=HDDESC(1); *2BANK
125674           A-=:LPEND; *1BANK   % NUMBER OF ENTRIES.
125677           A:=HDDESC(0); *2BANK
125702           A=:LPCNT            % FIRST ADDRESS.
125703           FOR LPEND DO
125703               T:=5SAVE; LPCNT+LPDISP=:X
125707               CALL FAR GGVAL
125710               IF A >< 0 THEN MIN VAL FI   % COUNT ENTRIES >< 0.
125712               A:=LPCNT;    *1BANK
125714               A+HDDESC(2); *2BANK
125717               A=:LPCNT
125720           OD
125722           A:=VAL
125723           GO FAR PUTVAL
125724   *)FILL
125727   CXDUM:  EXIT                            % NO CHECK
125730   CXKXM:  A=:D; A:=L=:TAVL; T:=0; X-1
125735           *LDATX
125736           IF A>>D THEN GO FAR ILLPAR FI   % Value less than legal minimum value
125741           X+2
125742           *LDATX
125743           IF A<<D THEN GO FAR ILLPAR FI   % Value greater than legal max. value
125746           IF SUBIDEX = 20 THEN
125752              X:=DEPNT; X-3; T:=5SAVE      % Read input frame size
125755              CALL FAR GGVAL; X:=VAL
125757              IF X >> A THEN GO FAR ILLPAR FI  % Output frame size must be <=  input frame
125762           FI
125762           IF SUBIDEX = 17 THEN
125766              X:=DEPNT; X+3; T:=5SAVE      % Read output frame size
125771              CALL FAR GGVAL; X:=VAL
125773              IF X << A THEN GO FAR ILLPAR FI  % Output frame size must be <=  input frame
125776           FI
125776           IF SUBIDEX = 23 THEN
126002              X:=DEPNT; X-52; T:=5SAVE     % Read number of message elements
126005              CALL FAR GGVAL; X:=VAL
126007              IF X >> A THEN GO FAR ILLPAR FI  % Number of network server transmitt buffer
126012           FI                                  % must be less than total message elements
126012           IF SUBIDEX = 5 THEN
126016              X:=DEPNT; X+52; T:=5SAVE         % Read number of network server transmitt buffer
126021              CALL FAR GGVAL; X:=VAL
126023              IF X << A THEN GO FAR ILLPAR; *)FILL        % Number of network server transmitt buffer
126030              FI
126030           FI                                             % must be less than total message elements
126030           X:="XRUNA"
126031           T:=1 CALL CHIND                                % Calculate space for task tables
126033           A*"4TLEN"; A=:BUSD; X:="XRUNA"; X+3
126037           T:=2; CALL CHIND                               % Calculate space for port tables
126041           A*"4PLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+14
126046           T:=5; CALL CHIND                               % Calculate space for message tables
126050           A*"4MLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+36
126055           T:=13; CALL CHIND                              % Calculate space for link tables
126057           IF A = 0 GO NOLINK                             % If number of link is 0, no space vil be used for
126060           A=:LANT*"4LLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+60% acknowledgement and receive frames
126066           T:=21; CALL CHIND                              % Calculate space for acknowledgement frames
126070           A+12*"5FLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+63
126076           T:=22; CALL CHIND                              % Calculate space for receive frames
126100           A*LANT*"5FLEN"; A+BUSD=:BUSD;
126104           GO NOLINK
126105   *)FILL
126114   NOLINK: X:="XRUNA"; X+105
126116           T:=30; CALL CHIND                              % Calculate space for trace buffers
126120           A*2; A+"X5FUN"; A+BUSD=:BUSD; X:="FSXMF"
126125           T:=5SAVE; CALL FAR GGVAL                       % Find first free location on segment 76
126127           X:="X6TOP"; X-1 ; X-A                          % Top of segment 76
126132           A:=BUSD
126133           IF A >>= X THEN GO FAR ILLSPA FI               % Check if there is enough space on segment
126136           53=:IDEX                                       % Restore index number (same location as LTEM)
126140           A:=TAVL=:L; A:=VAL; X:=DEPNT;                  % Restore value and address within XRUNA
126144           EXIT
126145   CHIND:  A:=SUBIDEX
126146           IF A=T THEN
126150                A:=VAL                                            % If current subindex use actual value
126151           ELSE
126152                T:=L=:LTEM; T:=5SAVE; CALL FAR GGVAL; T:=LTEM=:L  % if not; read value from save area
126160           FI
126160           EXIT
126161   *)FILL
126170   DISP 0
126170       INTEGER PCOUNT=D4       % PAGE COUNTER
126170       INTEGER MASK=D5         % MASK FOR MEMORY COUNTER.
126170       INTEGER NBANKS=D6       % NUMBER OF BANKS.
126170   PSID
126170
126170   MEMCON:             % MEMORY CONFIGURATION
126170   SUBIDEX GOSW MMTOT,MMLOCAL,MPIO,MM3,MM4,MM5,MMSWAP,MMSIN,MMRTC,MM500,FAR MMDAT
126205
126205   MMTOT:  A:=0;      GO MMLOOP    % NOT MEMORY.
126207   MMLOCAL:A:=KMECCR; GO MMLOOP    % LOCAL ND-100 MEMORY.
126211   MPIO:   A:=KMPIOC; GO MMLOOP    % PIOC MEMORY.
126213   MM3:    A:=KMPM3;  GO MMLOOP    % MPM 3 MEMORY.
126215   MM4:    A:=KMPM4;  GO MMLOOP    % MPM 4 MEMORY.
126217   MM5:    A:=KMPM5                % MPM 5 MEMORY.
126220   MMLOOP:             % COUNT NUMBER OF BANKS OF THIS KIND OF MEMORY.
126220           A=:MASK                             % SET WANTED MEMORY TYPE.
126221           T:=MBMEMARRAY; X:=MEMARRAY          % MEMORY DESCRIPTION ARRAY.
126223           A:=X+200=:L                         % END OF ARRAY.
126226           0=:NBANKS                           % RESET BANK COUNTER.
126227           DO WHILE X << L
126231               *LDATX                  % GET TWO BYTES.
126232               AD SHZ -10              % SPLIT THE BYTES, TEST UPPER BYTE.
126233               IF A-MASK = 0 THEN      % IF MEMORY IS OF WANTED KIND THEN
126235                   MIN NBANKS          % COUNT ONE BANK.
126236               FI
126236               AD SHZ 10; A/\377       % TEST LOWER BYTE.
126240               IF A-MASK = 0 THEN      % IF MEMORY IS OF WANTED KIND THEN
126242                   MIN NBANKS          % COUNT ONE BANK.
126243               FI
126243               X+1
126244           OD
126245           IF SUBIDEX = 0 THEN 400-NBANKS=:NBANKS FI % COMPLEMENT TO ALL MEMORY.
126252           A:=NBANKS SHZ 6             % MULTIPLY BANKS BY 64 TO GET PAGES.
126254           GO FAR PUTVAL
126255
126255   MMSWAP:             % PAGES FOR SWAPPING.
126255           A:=-1; CALL CHNSWPAGES
126257           GO FAR PUTVAL
126260   MMSIN:              % PAGES USED BY RESIDENT SINTRAN.
126260           "0DMMLIMS"/\1777\/PITST=:X  % START OF MEMORY ARRAY IN START BASE FIELD.
126264           "0EMMLIMS"/\1777\/PITST=:L  % END OF MEMORY ARRAY.
126270           T:=0                        % BANK #0.
126271           0=:PCOUNT                   % RESET PAGE COUNTER.
126272           DO WHILE X<<L               % DO FOR WHOLE ARRAY.
126274               *LDDTX                  % GET MEMORY ENTRY.
126275               IF A>=0 THEN            % IF USED THEN
126276                   D-A+1               % COMPUTE SIZE AND
126300                   PCOUNT+D=:PCOUNT    % ADD TO TOTAL.
126303               FI
126303               X+2                     % NEXT ENTRY.
126304           OD
126305           A:=PCOUNT
126306           GO FAR PUTVAL
126307   *)FILL
126323   MMRTC:              % PAGES USED BY RT-COMMON.
126323           A:=CCNOX
126324           GO FAR PUTVAL
126325   MM500:              % PAGES RESERVED BY ND-500.
126325           IF PN500D >< 0 THEN
126327               A:=A.AN5PAGES
126331           FI
126331           GO FAR PUTVAL
126332
126332   MICP500:            % ND500 MICROPROGRAM VERSIONS.
126332           IF PN500D = 0 GO FAR ILLIDX         % NO ND500 IN THIS SYSTEM.
126335           IF SUBIDEX-1*"5CPUDFSZ"+"S5CPUDF" >> "E5CPUDF" GO FAR ILLIDX % VALID CPU NUMBER.
126344           IF A.CPUAVAILABLE = 0 GO FAR ILLPAR % THE CPU DOES NOT EXIST.
126350           IF X.5INITFLAG BIT BCSLOADED THEN   % IF MICRO PROGRAM IS LOADED.
126353               A:=X.5MICPVERS                  % GET MICRO PROGRAM VERSION.
126354           ELSE
126355               A:=0                            % MICRO PROGRAM NOT LOADED.
126356           FI
126356           GO FAR PUTVAL
126357   *)FILL
126367   % VERSION DISPLACEMENT AND SIZE IN WORDS.
126367   DOUBLE SWDATA(0);DATA(5SWVERS,4)    % SWAPPER VERSION.
126371   DOUBLE SMDATA(0);DATA(5SYMVERS,6)   % SYSTEM MONITOR VERSION.
126373
126373   SOFT500:            % ND500 SOFTWARE VERSIONS:
126373           IF PN500D = 0 GO FAR ILLIDX         % NO ND500 IN THIS SYSTEM.
126376                                               % SUBINDEX HAS TO BE 1 OR 2 HERE.
126376                               % MOVE VERSION TO USER.
126376           X:=ZAREG+3          % POINTER TO FOURTH PARAMETER ADDRESS.
126400           OLDPAG=:D           % USERS PITS.
126402           CALL DALTON         % IN USERS DATA PIT.
126403           T:=X.S0             % GET DESTINATION ADDRESS.
126404           CALL SINALTPIT      % BACK TO DPIT.
126405           IF SUBIDEX-1 = 0 THEN                                  % SWAPPER VERSION
126410               IF PN500D.SYSINITFLAG NBIT BSWLOAD GO FAR ILLPAR   % SWAPPER NOT LOADED.
126414               AD:=SWDATA
126415           ELSE                                                   % SYSTEM MONITOR VERSION.
126416               IF 5MSINIT = 0 GO FAR ILLPAR                       % SYSTEM MONITOR NOT STARTED.
126421               AD:=SMDATA
126422           FI
126422           D=:X                % NUMBER OF WORDS IN X.
126423           A+PN500D=:D         % SOURCE ADDRESS IN D.
126425           A:=OLDPAG; K:="1"   % USER PIT; TO USER.
126427           CALL MOVUS          % MOVE DATA.
126430           GO FAR OKEND        % THAT'S IT.
126431
126431   MMDAT:                            % READ MEMORY TYPE ARRAY
126431         X:=ZAREG+3
126433         OLDPAGE=:D  ; CALL DALTON
126436         T:=X.S0
126437         CALL SINALTPIT                % RESET TO DPIT AS ALT PIT
126440         X:=MEMARRAY ; A:=MBMEMARRAY
126442         CALL DALTON
126443         X =: D ; X:=200=:L ; *MOVPA   % MOVE PHYSICAL TO USER(ALT PIT)
126447         CALL SINALTPIT
126450         GO FAR OKEND
126451   RBUS
126464   @DEV 1
126464   @DEV (S-S-L)RP-P2-N500:NPL
126464

126464   *"8N500
"126464   %==============================================================================
126464   %
126464   %       C X - R P I T - N 5 0 0
126464   %
126464   %==============================================================================
126464
126464   %==============================================================================
126464   %      ( R )    N 5 0 0 - A B S T R A N S   P R O G R A M
126464   %
126464   %      RT-program to read/write page from/to disk to/from memory
126464   %
126464   SUBR 5SWRT
126464   5SWRT: *2BANK; IOF
126466          "S500S"=:B; X:=RTREF
126471          CALL BRESERVE; IF A<0 THEN CALL ERRFATAL FI          % RESERVE PROCESS #0
126474          0=:PSTAT
126475          X:=SWMSG; T:=5MBBANK; A:="S500S"; *AAX XADPR; STATX  % ADDR OF PROC.DESCR
126502          A:=SWMSG+"SWPINFO"=:D:=5MBBANK; AD=:DSWMSG           % PHYS.ADDR OF SWPINFO IN SWMSG
126507          GO INRT; *)FILL
126520
126520          % - B-reg will be set by actswapper
126520          DO
126520             *ION
126521   INRT:     X:="S500S"; CALL FAR SETIOWAIT
126523             *IOF
126524             "S500S".PSTAT BZERO F5BUFF=:X.PSTAT
126530             X:=SWMSG; CALL RN5STATUS
126532             IF A><PSW1WAIT THEN
126535                GO INRT
126536             FI
126536             *ION
126537             IF T:=XSDUNIT=0 THEN A:=-1; GO 5SWERR FI
126544             "ABSLI"; *MON 131
126546             IF X:="N500DF".SYSINITFLAG BIT B5STOP GO INRT
126552             IF A>=0 THEN
126553                T:=0=:A=:D                                     % TRANSFER OK.
126556             ELSE
126557   5SWERR:      A=:SWEHSTAT
126560                A:=12=:L; "XSDUNIT"=:D; T:="5SWESTATUS"; *MOVAA  % SAVE ERROR INFORMATION
126566                T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
126573   *NNC30,      CNVBYADR
126576                55MESSIZE=:L; T:="5SWEMESSAGE"                 % SAVE MESSAGE OF PROCESS BEING
126601                A:=D-55MSNEGSIZE=:D:=5MBBANK; *MOVPA           % SERVED BY THE SWAPPER
126606                A:=SWDERR=:D:=0; T:=1                          % ERROR IN TRANSFER
126612             FI
126612             *IOF
126613             X:=SWMSG; CALL MONICO                             % RESTART SWAPPER
126615             CALL GCPUDF; CALL ERRFATAL; A=:B
126620   *NNT30=*
126620             CALL TER500; 0/\0
126622             CALL ACTRDY
126623             LTTMR=:TMR; CALL LOWACT500
126626          OD
126627   RBUS
126653
126653   %===========================================================================
126653   %       ( R )    N 5 0 0 S C H E D U L E R
126653   %
126653   % Timeslicer for nd-500 processes & restart of suspended processes
126653   % This routine is part of the nd-100 timeslicer (rt-prog. RTSLI)
126653   %
126653   SUBR N500SCHEDULER
126653
126653   INTEGER POINTER TSLREG=?
126653   INTEGER CTSLCLASS=?
126653   INTEGER CTSLPROC=?
126653   INTEGER CTSLSTATUS=?
126653   INTEGER CINDEX=?
126653   INTEGER CL5CPU=?
126653   INTEGER 5TCOUNT=?
126653   INTEGER 5TNEXT=?
126653   DOUBLE  DTSCOUNT=?
126653
126653   N500SCHEDULER:
126653          IF "N500DF".SYSINITFLAG BIT B5STOP THEN EXIT FI
126660          A:=L=:"TSLREG"
126662          "S5CPUDF"=:B
126664          % Test if there is anything to do - any nd-500 cpus in use ?
126664          DO WHILE B<<="E5CPUDF"
126667             IF CPUAVAILABLE BIT 5ALIVE THEN
126672                IF A/\5CPUTYPE=SAMSON THEN
126676                   % Nd-500 samson on octobus line - test if memory layout ok : -
126676                   IF MAILINK><-1  THEN
126702                      A:=0; X:="S5CPUDF"
126704                      DO WHILE X<<="E5CPUDF"; A\/X.C5STAT; X+5CPUDFSIZE; OD
126712                      IF A/\C5PFMASK=0 GO NN5S1
126714                   FI
126714                ELSE
126715                   % Nd-500 on dma interface - test if power present & running : -
126715                   T:=HDEV+RSTA5; *IOXT                % Check if activated and not in power-fail
126720                   IF A BIT 5ILOC AND C5STAT NBIT BHPFAIL GO NN5S1
126725                FI
126725             FI; B+5CPUDFSZ
126726          OD
126727          GO TSLREG
126730   *)FILL
126734
126734   NN5S1:                                           % Something to timeslice -
126734          IF "N500DF".SYSINITFLAG BIT BRESPLACE GO FAR EDOX
126740          1=:CINDEX; X:="S500S"+5PRDSIZE            % Start with first process after swapper
126744
126744          % - Loop over all nd-500 process descriptions : -
126744   DOX:   IF CINDEX>>MX5PROCS GO FAR EDOX           % All possible used processes searched?
126750          *IOF
126751          IF X.RTRES=0 OR X.PSTAT NBIT SLICE OR A/\5RUNSTATUS=5INCOMM GO FAR EFIX
126762          X=:B=:CTSLPROC                            % Timesliced process not having communication priority
126764          T:=5MBBANK; X:=X.MESSBUFF; *AAX 5TSLC; LDDTX
126770          AD=:DTSCOUNT; *AAX 5TSLS-5TSLC; LDATX
126773          A=:CTSLSTATUS                             % Current timeslice status
126774          A SHZ -7CUTY/\TSLCMSK=:CTSLCLASS          % Current timeslice class
126777          *AAX L500C-5TSLS; LDATX
127001          A=:CL5CPU                                 % 16 least significant part of nd-500 cpu-time used
127002          IF PSTAT BIT 55BRKPRIOR THEN              % Waiting for break priority?
127005             A BZERO 55BRKPRIOR=:PSTAT              % Clear break flag
127007             *AAX 5PRIO-L500C; LDATX                % Get current priority
127011             IF A<=TSLLOWLG THEN                    % Can priority be increased
127014                TSLBRKELEM(CTSLCLASS)               % Get break element
127016                A=:D:=CTSLSTATUS/\177400\/D=:CTSLSTATUS
127023                CL5CPU=:5TNEXT
127025                GO SETALL
127026             FI
127026          FI
127026          A:=CL5CPU-5TNEXT=:D:=0
127032          T:=TSLTUNIT; *RDIV ST                     % Compute cpu time used
127034          IF A+5TCOUNT<0 GO CONWAIT                 % Timeslice finished?
127036          CL5CPU=:5TNEXT                            % Yes, set new cpu time
127040          CTSLSTATUS/\TSLELMSK=:X                   % Timeslice element
127043          A:=CTSLSTATUS/\177400\/TSLNEXTAB(X)       % Find next element in chain
127046          A=:CTSLSTATUS/\TSLELMSK=:D
127051          GO SETALL
127052
127052   INTEGER POINTER TSLREG
127053   INTEGER CTSLCLASS
127054   INTEGER CTSLPROC
127055   INTEGER CTSLSTATUS
127056   INTEGER CINDEX
127057   INTEGER CL5CPU
127060   INTEGER 5TCOUNT,5TNEXT
127062   DOUBLE  DTSCOUNT=5TCOUNT
127062   *)FILL
127100
127100   SETALL:IF TSLTIMTAB(D)=:T-TSLHTIME>=0 THEN       % Hash element?
127105             CL5CPU/\TSLHASHM+T                     % Yes; hash with time used
127110          ELSE
127111             A:=T
127112          FI; A-=:5TCOUNT                           % Set timslice counter
127114          TSLPRITAB(D); T:=5MBBANK; X:=MESSBUFF
127120          *AAX 5PRIO; STATX                         % Set new priority
127122          IF A<=TSLLPRITAB(CTSLCLASS) THEN
127126             X:=MESSBUFF; T:=5MBBANK; *AAX HTSLL; STATX
127132             PSTAT BONE 5LTSLPRI                    % Mark that process is on special low prirority
127134          ELSE
127135             PSTAT BZERO 5LTSLPRI
127137          FI; A=:PSTAT
127140          X:=MESSBUFF; CALL FAR TSL5CHXQ
127142          T:=5MBBANK; X:=CTSLPROC.MESSBUFF
127145          AD:=DTSCOUNTA; *AAX 5TSLC; STDTX          % Set new timeslice variables
127150          CTSLSTATUS; *AAX 5TSLS-5TSLC; STATX
127153   CONWAIT: X:=CTSLPROC
127154   EFIX:  *ION
127155          MIN CINDEX; X+5PRDSIZE                    % Next process description to handle
127157          GO FAR DOX; *)FILL
127170
127170          % - End of loop over all nd-500 process descriptions -
127170          %   Restart any nd-500 cpu stopped by n500scheduler :
127170   EDOX:  ATIM2=:SUSPATIME
127172          *ION
127173          CALL FAR CHSUSP
127174          "S5CPUDF"=:B
127176          DO WHILE B<<="E5CPUDF"
127201             IF CPUAVAILABLE BIT LV1ACT THEN
127204                A BZERO LV1ACT=:CPUAVAILABLE
127206                *IOF
127207                CALL XLOWACT500
127210                *ION
127211             FI
127211             B+5CPUDFSZ
127212          OD
127213          GO TSLREG
127214   *)FILL
127222
127222
127222   % Error from terminate nd-500 (timeout, impossible to terminate nd-500)
127222   %
127222   ESCED: CALL RSTARTALL
127223          *ION
127224          GO TSLREG; *)FILL
127226
127226
127226   % Local subroutine to check all suspended processes if they can be restarted
127226   %
127226   INTEGER CCSUSP
127227   INTEGER POINTER 5TRET
127230
127230   CHSUSP: A:=L=:"5TRET"
127232          IF 5SUSPFLAG >< 0 THEN
127234             0=:5SUSPFLAG; "S5CPUDF"=:B
127237             DO WHILE B<<="E5CPUDF"
127242                IF CPUAVAILABLE BIT 5ALIVE THEN
127245                   *IOF
127246                   0=:CCSUSP; X:=MAILINK; *AAX X5BEX
127251                   DO
127251                      T:=5MBBANK; *LINK@3 LDDTX                   % Always skip first message
127253                   WHILE D><-1
127256   *NNC31,            CNVBYADR                                    % Convert multi-port address
127261                      IF X:=D><DUMMESS THEN
127265                         CALL RN5STATUS
127266                         IF A=SUSPSTAT THEN                       % Process suspended
127271                            T:=5MBBANK; *AAX SUSPC; LDATX         % Suspend-time-counter
127274                            IF A-1=0 THEN
127276                               *AAX -SUSPC
127277                               ANSWER; CALL WN5STATUS             % Reset status to "answer-from-nd-500"
127301                               X=:CCSUSP
127302                               CALL SLOCK; GO FAR ESCED           % Lock queue semaphore
127304                               CALL ITOFIFOQ                      % Insert in FIFO queue
127305                               CALL SUNLOCK                       % Unlock queue semaphore
127306                            ELSE
127307                               *STATX; AAX -SUSPC                 % Save new value of suspend-time-counter
127311                               1=:5SUSPFLAG
127313                            FI
127313                         FI
127313                      FI
127313                   OD
127314                   *ION
127315                   IF CCSUSP><0 THEN
127317                      *IOF
127320                      X:=-1
127321   *NNT31=*
127321                      CALL TER500; GO FAR ESCED
127323                      CPUAVAILABLE BONE LV1ACT=:CPUAVAILABLE
127326                      *ION
127327                   FI
127327                FI
127327                IF MIFLAG BIT MUDOM GO 5TRET
127332                B+5CPUDFSZ
127333             OD
127334          FI
127334          GO 5TRET; *)FILL
127352
127352
127352   % Local routine move process in execution queue according to new priority
127352   %
127352   % Entry:         X=message address
127352   %
127352   INTEGER CC5CPU,CMESS
127354   INTEGER POINTER 55TRET
127355
127355   TSL5CHEXQ:
127355          T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
127361          IF A NBIT 5IEXQUEUE THEN EXIT FI            % Is process in ex-queue ?
127364          A:=:L=:"55TRET"; X=:CMESS
127367          CALL GCPUDF; CALL ERRFATAL; A=:B
127372          IF MIFLAG BIT MUDOM THEN
127375             CALL SLOCK; GO FAR ESCED
127377             CALL IFM500XQ; CALL ITO500XQ
127401             CALL SUNLOCK
127402             CALL ACTRDY
127403          ELSE
127404             B=:D; T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
127411             IF A NBIT 5CPUBOUND THEN
127413                X:="S5CPUDF"; LEXQUEUE=:L
127416                DO WHILE X<<="E5CPUDF"
127421                   IF X.CPUAVAILABLE BIT 5ALIVE AND C5STAT NBIT BHPFAIL AND SPREF=0 THEN
127431                      A:=X.MAILINK:=:X; T:=5MBBANK; *AAX X5CPU; LDXTX
127436                      IF A:=:X=MPACTIVE THEN
127442                         IF X.LEXQUEUE<L THEN A=:L; X=:D FI
127447                      FI
127447                   FI
127447                   X+5CPUDFSZ
127450                OD
127451             FI
127451             A:=D=:CC5CPU; X:=CMESS
127454             CALL TER500; GO FAR ESCED
127456             CALL IFM500XQ
127457             CPUAVAILABLE BONE LV1ACT=:CPUAVAILABLE
127462             IF CC5CPU><B THEN
127465                A=:B; CALL TER500; GO FAR ESCED
127470                X:=WATCHDOG; T:=5MBBANK; 3RMICV; *MICFU@3 STATX
127474                MSGN500; CALL WN5STATUS
127476                CALL ITO500XQ; X=:TMRXQ; LTTMR=:TMR
127502                X:=CMESS; T:=5MBBANK; CPUNO; *AAX 5CPUN; STATX; AAX -5CPUN
127510                CPUAVAILABLE BONE LV1ACT=:CPUAVAILABLE
127513             FI
127513             CALL ITO500XQ
127514          FI
127514          GO 55TRET
127515
127515   RBUS
127532
127532
127532   %=============================================================================
127532   %        ( R )     N 5 0 0 T M R
127532   %
127532   %      Time-out routine for the n500
127532   %      Called in IOF
127532
127532   SUBR N500TMR
127532   INTEGER POINTER TMRET=?
127532   INTEGER CCERR=?
127532
127532   N500TMR:
127532          IF "N500DF".SYSINITFLAG BIT B5STOP THEN EXIT FI
127537          A:=L=:"TMRET"
127541   5TMR1: IF CPUAVAILABLE NBIT 5ALIVE GO TMRET          % Nd-500 cpu present?
127544          IF MAILINK=-1 GO TMRET                        % Buffers allocated?
127550          IF C5STAT/\3=3 GO 5TMRA                       % Power fail detected & reloading cs
127555          IF CPUAVAILABLE/\5CPUTYPE><SAMSON THEN
127562             177377; CALL CLE5STATUS                    % Check for power-fail
127564             IF A BIT 5POWOF THEN                       % If power-fail then set new timer
127566   5TMRA:       TTMR=:TMR; GO TMRET
127571             FI
127571          ELSE A:=0
127573          FI
127573          IF T:=C5STAT BIT BHPFAIL THEN
127576             IF T NBIT BCSLPFAIL THEN
127600                A BONE POWDOWN; CALL RSTARTALL
127602             FI
127602             IF CPUAVAILABLE/\5CPUTYPE=SAMSON GO TMRET
127607             177177; CALL CLE5STATUS; GO TMRET
127612          FI
127612          IF A/\ 720 ><0 GO N5ABORT                     % Power fault, communication error
127614          IF FERROR><0 GO TMRET
127617          IF C5STAT BIT BCSWPFAIL THEN
127622             A BZERO BCSWPFAIL=:C5STAT
127624             A:=0 BONE POWDOWN; CALL RSTARTALL
127627             GO 5TMRA
127630          FI
127630          A:=0; X:="S5CPUDF"
127632          DO WHILE X<<="E5CPUDF"; A\/X.C5STAT; X+5CPUDFSIZE; OD
127640          IF A/\ C5PFMASK><0 GO 5TMRA
127642          IF X:=WATCHDOG=TMRXQ THEN
127646             CALL RN5STATUS
127647             IF A><ANSWER THEN
127652                T:=5MBBANK; X:=MAILINK; *AAX X5BRK; LDATX  % Microprogram break?
127656                IF A><0 GO 5TMRA
127657                0=:TMR
127660   N5ABORT:     N5TIMOUT
127661   5TMR2:       A=:CCERR; 0=:TMRXQ
127663                CALL RSTARTALL; GO TMRET
127665             ELSE
127666                LTTMR=:TMR; CALL XLOWACT500
127671                GO TMRET
127672             FI
127672          FI
127672          GO 5TMR3; *)FILL
127711
127711   INTEGER POINTER TMRET
127712   INTEGER CCERR
127713   5TMR3: IF FERROR><0 GO TMRET
127716          X:=-1
127717   *NNT32=*
127717          CALL TER500; GO 5TMR2
127721          X:=SWMSG; CALL RN5STATUS
127723          IF A=PSW1WAIT THEN                            % Swapper wating for nd-100 program
127726             T:=5MBBANK; *AAX SWPFU; LDATX
127731             IF A=ALLOPAGE THEN
127734                T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
127741   *NNC32,      CNVBYADR
127744                X:=D; *AAX XADPR; LDXTX
127747                IF X=0 OR X.RTRES=0 GO EESWPUSER
127753                X:=D; CALL RN5STATUS
127755                IF A/\3777><5IALLOPAGE THEN             % Swapper not busy allocating a page?
127761                   IF A><MSGN500 GO EESWPUSER
127764                   T:=5MBBANK; *MICFU@3 LDATX
127766                   IF A-3SWMESS><0 GO EESWPUSER
127770                   *AAX PRET1; LDATX
127772                   IF A><3START GO EESWPUSER
127775                FI
127775             ELSE
127776                IF "5SWAP".WLINK=0 GO EESWPUSER
130001                T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
130006   *NNC33,      CNVBYADR
130011                X:=D; *AAX XADPR; LDXTX
130014                IF X=0 OR X.RTRES=0 THEN
130017   EESWPUSER:      X:=SWMSG; A:=0; CALL EMONICO         % Restart swapper with error return
130022                   CALL ACTRDY
130023                FI
130023             FI
130023          FI
130023          3RMICV; T:=5MBBANK; X:=WATCHDOG; *MICFU@3 STATX
130027          MSGN500; CALL WN5STATUS
130031          CALL SLOCK; GO TMRET
130033          CALL ITO500XQ; X=:TMRXQ
130035          CALL SUNLOCK
130036          CALL ACTRDY
130037          LTTMR=:TMR; CALL LOWACT500
130042          GO TMRET
130043   RBUS
130062
130062
130062   %==============================================================================
130062   %      ( R )       C H 5 M X T I M E
130062   %
130062   % SUBROUTINE TO THE TIMER RT-PROGRAM
130062   % ABORT BATCH-JOBS USING NORD 500 WHEN THE N500 CPU TIME
130062   % IS GREATER OR EQUAL TO THE MAX CPU TIME IN THE @ENTER COMMAND
130062   %
130062   % ENTRY:     B=BATCH DATAFIELD
130062   %            X=BATCH RT-PROGRAM
130062   %
130062   % EXIT:      MAX CPU TIME IS USED; ABORT JOB
130062   %
130062   % EXIT+1:    MAX CPU TIME NOT USED; THE BATCH JOB WILL CONTINUE
130062   %
130062
130062   SUBR CH5MXTIME
130062
130062   INTEGER H5TUS,L5TUS; DOUBLE DC5TUS=H5TUS
130064   CH5MXTIME: X=:D; *AAX BRESL
130066              DO WHILE X:=X.RESLINK><D
130071                 IF X>>="S500S" AND X<<="S500E"-5PRDSIZE THEN % HAS BATCH RESERVED ANY ND-500 PROC?
130100                    T:=5MBBANK; X:=X.MESSBUFF; *AAX 500TU; LDDTX
130104                    AD=:DC5TUS
130105                    A:=MXTIME; T:=5670; *RMPY ST DA           % YES, CHECK IF MAX ND-500 CPU TIME IS USED
130110                    A:=:D-L5TUS; *RDCR ADC DD
130113                    A:=:D-H5TUS
130115                    IF A<0 THEN EXIT FI
130117                    EXITA
130120                 FI
130120              OD
130121              EXITA                                           % NO ND-500 PROC. RESERVED
130122   RBUS
130126
130126
130126   %=========================================================================
130126   %       ( R )    X I B M O V E                         (WM-400)
130126   %
130126   %      MONITOR FUNCTION CALLED FROM IBMOVE AND RETURNS TO CIBMOVE IN COMMON
130126   %      MOVES BYTES FROM TERMINAL INPUT BUFFER TO ND-500 BUFFER
130126   %      IF MAX NO OF BYTES IS REACHED THE THE ND-500 PROCESS IS RESTARTED.
130126   %      GOES TO MONEN IF THE INPUT BUFFER IS EMPTY.
130126   %
130126   % ENTRY:     X=ND500 PROCESS DESCRIPTION
130126   %        IN5MSG=ND-500 MSG WAITING IN DVINST OR DVIO MONITOR CALL
130126
130126   SUBR XIBMOVE
130126
130126   %%DOUBLE  IBM41PITENTRY                             % SAVED TERMINAL PITENTRY
130126   %%DOUBLE  IBM5PITENTRY                              % SAVED ND500-MESSAGE PITENTRY
130126   %%DOUBLE  IBMM6PITENTRY                             % SAVED MON60-BUFFER PITENTRY
130126   %%INTEGER IBMIN5MSG                                 % SAVED IN5MSG
130126   %%INTEGER IBMPRD                                    % SAVED PROCESS DESCRIPTION ADDRESS
130126   %%INTEGER IBMWNDMESS                                % LOGICAL ADDR OF MESSAGE
130126   %%INTEGER IBMLGBUADDR                               % LOGICAL ADDR OF DATA BUFFER
130126   %%INTEGER IMBLREG
130126
130126   XIBMOVE: A:=L=:IBMLREG; X=:IBMPRD
130131   % - SET UP TERMINAL WINDOW AND B
130131          AD:=DTDFPHPAGE=:IMBDTDFPHPAGE             % PHYSICAL PAGE AND LOGICAL ADDRESS OF BIG TERMINAL DF
130133          D=:X; T:=A SHZ -6                         % T,X=PHYSICAL ADDRESS OF BIG TERMINAL DF
130136          A:=:D/\1777+"WND41*2000"=:B               % LOGICAL ADDRESS INSIDE WINDOW
130142          A:=142000; AD=:IBM41PITENTRY              % RPM + WPM + RING2
130144          *AAX IN5MS; LDATX
130146          A=:IBMIN5MSG
130147   % - CHECK FOR ERROR CONDITIONS
130147          IF A=0 THEN "MONEN" GO FAR CCLEANUP FI    % INCASE NOWIAT AND "DUMMY" START FROM TERM.DRIVER
130152          X:=IBMIN5MSG; CALL RN5STATUS
130154          IF A=N5IOWAIT THEN                        % PROCESS STILL IN IOWAIT
130157             T:=5MBBANK; *AAX SMCNO; LDATX
130162             IF A=511 OR A=503 GO CIIMB             % PROCESS IN DVIO OR DVINST
130170          FI
130170          AD:=IMBDTDFPHPAGE                         % PHYSICAL PAGE AND LOGICAL ADDRESS OF BIG TERMINAL DF
130171          D=:X; T:=A SHZ -6; *AAX IN5MS; STZTX      % PROCESS NOT IN IOWAIT (NOT IN DVIO OR DVINST)
130176          "MONEN"; GO FAR CCLEANUP
130200
130200   CIIMB: AD:=IMBDTDFPHPAGE                         % PHYSICAL PAGE AND LOGICAL ADDRESS OF BIG TERMINAL DF
130201          D=:X; T:=A SHZ -6; *AAX FLAGB; LDATX      % PROCESS NOT IN IOWAIT (NOT IN DVIO OR DVINST)
130206          IF A BIT 5LSTA THEN                       % TERMINAL LINE LOST?
130210                *AAX IN5MS-FLAGB; STZTX
130212                X:=IBMIN5MSG
130213                A:=316                              % GODBYE TERMINAL
130214                CALL EMONICO
130215                "MONEN"; GO FAR CCLEANUP            % CLEAR PIT.ENTRIES AN GO TO MONEN
130217          FI
130217   % - SET UP WINDOW FOR ND-500 MESSAGE
130217          A:=IBMIN5MSG=:D:=5MBBANK; A=:T; D=:X
130224          AD SHZ -12                                % D=PHYS.PAGE OF MESSAGE
130225          A:=142000; AD=:IBM5PITENTRY               % SAVE PITENTRY
130227          A:=IBMIN5MSG/\1777+"WNDN5*2000"=:IBMWNDMESS   % LOG.ADDR OF MESSAGE
130233   % - SET UP WINDOW FOR ND-500 BUFFER (WHICH WILL RECEIVE THE CHARACTERS FROM THE TERMINAL DF)
130233          X:=IBMIN5MSG; *AAX ABUFA; LDDTX
130236          D=:T
130237          AD SHZ -12; A:=142000; AD=:IBMM6PITENTRY    % D=PHYS.PAGE OF MON60 BUFFER
130242          A:=T/\1777+"WNDBF*2000"=:IBMLGBUADDR        % LOGICAL ADDR OF DATA BUFFER
130246
130246   IIBM:  *ION; IOF
130250   % - MOVE CHARACTER INTO ND-500 BUFFER
130250          AD:=IBM41PITENTRY                         % GET TERMINAL SAVED PITENTRY
130251          T:=0; X:="WND41+WND41+174000"; *STDTX     % SET PIT.ENTRY
130254          AD:=IBM5PITENTRY                          % GET ND-500 MESSAGE SAVED PITENTRY
130255          X:="WNDN5+WNDN5+174000"; *STDTX           % SET PITENTRY
130257          AD:=IBMM6PITENTRY                         % GET MON60-BUFFER SAVED PITENTRY
130260          X:="WNDBF+WNDBF+174000"; *STDTX           % SET PIT.ENTRY
130262          CALL IOTRANS; GO FAR TMWT                 % READ CHARACTER; IF NONE, GO TMWT
130264          X:=IBMWNDMESS.5FYLLE; T:=IBMLGBUADDR; *SBYT % STORE BYTE IN BUFFER
130270          A:=X+1=:IBMWNDMESS.5FYLLE                 % INCREMNT BYTE POINTER
130273          GO IBTBREAK; *)FILL
130325
130325   IBTBREAK:
130325   % - TEST FOR BREAK
130325          A=:D                                      % SAVE NEW 5FYLLE FOR LATER TEST
130326          IF X.SMCNO=511 THEN                       % DVIO OR DVINST?
130332             X.11MXBRK                              % DVIO
130333          ELSE
130334             X.MAXBYT                               % DVINST
130335          FI
130335          IF D>=A GO N5RST                          % BREAK REACHED? (5FYLLE>=MAX NO. BYTES)
130337          IF T:=RSISTE>=0 THEN
130342             IF HENTE=T GO N5RST
130345          ELSE
130346             IF BRECHOFL BIT 5BREAK GO N5RST
130351          FI
130351   % - NEXT CHARACTER
130351          GO IIBM
130352   *)FILL
130353
130353   N5RST:                                           % RESTART USER
130353          IF IBMWNDMESS.5FYLLE=0 THEN               % NO CHARS READ VIA IOTRANS
130356             IF BRECHOFL BIT 5WECH THEN             % WAITING FOR SPACE IN OUTBUFFER TO DO ECHO
130361                0=:X.MLFLAG                         % IBMOVE INACTIVE
130362                "MONEN"; GO CCLEANUP                % TERMINAL OUTPUT DRIVER WILL RESTART IBMOVE
130364             FI
130364             % - ECHO STRATEGY MUST HAVE CHANGED AFTER INPUT DRIVER READ CHARACTER
130364             IF TDRADR.ISTATE=-1 OR A=-2 THEN       % NOWAIT
130374                X := IBMIN5MSG
130375                3; CALL EMONICO                     % GIVE END OF FILE
130377                0=: IN5MSG                          % DVINST FINISHED
130400                CALL GCPUDF; CALL ERRFATAL          % SET B TO POINT TO CPU DF
130402                A=:B; GO RST                        % RESTART USER PROGRAM
130404             ELSE                                   % NOT NOWAIT
130405                CALL ERRFATAL                       % ECHO STRATEGY CAN NOT CHANGE
130406             FI
130406          FI
130406   % - RETURN NUMBER OF CHARACTERS TO USER
130406          A=:D                                      % D=NUMBER OF CHARS
130407          IF X.SMCNO = 511 THEN                     % DVIO OR DVINST?
130413             A:=0; AD=:X.11NOCRET                   % DVIO
130415          ELSE
130416             A:=0; AD=:X.NOCHRET                    % DVINST
130420          FI
130420   % - INFORM TIME SLICER ABOUT BREAK CONDITION
130420          X.XADPROC.PSTAT BONE 55BRKPRIOR =: X.PSTAT
130424          IF X:=X.RTRES><0 THEN X.STATUS BONE 5BRKF=:X.STATUS FI
130431          0=:IN5MSG                                 % CLEAR ND-500 INDICATION IN TERMINAL DATAFIELD
130432          X:=IBMIN5MSG; CALL GCPUDF; CALL ERRFATAL
130435          A=:B; X:=IBMWNDMESS
130437          IF MIFLAG BIT WSMC THEN
130442             AD:=X.ISTRA=:X.26ADDESS=:X.SM26ADDRESS % BUFFER ADDR
130445             X.5FYLLE=:X.26NRBYT=:X.SM26NRBYT       % NUMBER OF CHARS
130450             0=:X.KFLIP                             % CLEAR ERROR INICATOR
130451             0=:X.FUNCA=:X.FUNCD                    % 0=:FUNCVALUE
130453             3WMONCO=:X.MICFUNC                     % RESTART AFTER MON.CALL
130455             IF X.SMCNO=511 THEN A:=100000 ELSE A:=4 FI
130464             A=:X.NUMPAR                            % STORE WRITE BACK MASK
130465             X:=IBMIN5MSG; CALL MCCO
130467          ELSE
130470             AD:=X.ABUFADR
130471   *NNC34,   CNVWADR
130474             AD=:X.N100ADR                          % 5MPM BYTE ADDR OF DATA BUFFER
130475             AD:=X.ISTRA=:X.N500ADR
130477             X.5FYLLE=:X.NRBYT                      % NUMBER OF BYTES
130501             0=:X.5DITNO                            % DEFAULT DIT #0
130502             "INSMONCO"=:X.SPFLA                    % CONTINUE IN INSMONCO AFTER DATA MEM.WRITE
130504             3WMED=:X.MICFUNC                       % WRITE DATA BUFFER TO ND-500
130506             X:=IBMIN5MSG; MSGN500; CALL WN5STATUS
130511          FI
130511          GO RST; *)FILL
130526
130526   RST:
130526   % - RESTART ND-500
130526          IF FERROR><0 THEN "MONEN"; GO CCLEANUP FI
130532          X:=IBMIN5MSG
130533   *NNT33=*
130533          CALL TER500; GO N500ERR
130535          CALL ACTRDY
130536          CALL LOWACT500
130537          "MONEN"; GO CCLEANUP
130541
130541   N500ERR: *IOF
130542          CALL RSTARTALL
130543          "MONEN"; GO CCLEANUP
130545
130545
130545   % - CLEAR TERMINAL WINDOW AND BUFFER WINDOW
130545   INTEGER POINTER CRETADDR
130546   CCLEANUP: A=:D
130547          T:=0; X:="WND41+WND41+174000"; *STZTX       % CLEAR TERM WINDOW
130552          X:="WNDN5+WNDN5+174000"; *STZTX             % CLEAR ND-500 MESS. WINDOW
130554          X:="WNDBF+WNDBF+174000"; *STZTX             % CLEAR DATA-BUFFER WINDOW
130556          IBMLREG=:P
130560
130560   TMWT:
130560   % - NOWAIT?
130560          IF TDRADDR.ISTAT=-1 OR A=-2 GO FAR N5RST    % NOWIAT
130570   % - CLEAR MLFLAG
130570          0=:IBMWNDMESS.MLFLAG
130572          "MONEN"; GO CCLEANUP
130574   RBUS
130610
130610
130610   %=========================================================================
130610   %      ( R )     X 5 P R A C T I V A T E
130610   %
130610   % REACTIVATE A ND-500 PROCESS.
130610   %
130610   % ENTRY:       X=PROCESS DESCRIPTION
130610   %              INTERRUPT MUST BE OFF!
130610   % X5ERACTIVATE: A= ERRORCODE
130610   % EXIT:        PROCESS NOT IN EXECUTION QUEUE OR IN TIME QUEUE
130610   % EXIT+1:      THE PROCESS IS ACTIVATED
130610   %
130610   SUBR X5PRACTIVATE,X5ERACTIVATE
130610   INTEGER POINTER LREG
130611   INTEGER DREG,BREG,CCERR,CSWITCH
130615
130615   X5ERACTIVATE:A=:CCERR; 1=:CSWITCH; GO FELL
130621   X5PRACTIVATE:0=:CSWITCH
130622   FELL:  A:=L=:"LREG":=B=:BREG; A:=D=:DREG
130630          T:=5MBBANK; X:=X.MESSBUFF
130632          CALL GCPUDF; GO FFPEX; A=:B
130635          T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
130641          IF A BIT 5ITMQUEUE THEN                             % IN TIME-QUEUE
130643   *NNT34=*
130643             CALL TER500; 0/\0
130645             CALL SLOCK; 0/\0
130647             CALL FR5TMQ                                      % REMOVE FROM TIME-QUEUE
130650             A:=1; CALL SPITMQ
130652             CALL ITO500XQ
130653             CALL SUNLOCK
130654             GO FFPXX                                         % ACTIVATE PROCESS
130655          ELSE IF A BIT 5IEXQUEUE THEN                        % PROCESS IN EQ-QUEUE?
130660             CALL RN5STATUS                                   % YES
130661             IF A><STOPPED THEN                               % IS PROCESS STOPPED?
130664                CALL SLOCK; 0/\0
130666                T:=5MBBANK; *AAX 5MSFL; LDATX                 % NO, SET REPEAT
130671                A BONE 55REP; *STATX
130673                CALL SUNLOCK
130674                GO FFPOK
130675             FI
130675   *NNT35=*
130675             CALL TER500; 0/\0
130677             IF CSWITCH=0 THEN CALL OKMONICO                  % OK RESTART PROC AFTER A "STOP" MON.CALL
130702             ELSE CCERR; CALL EMONICO FI                      % ERROR RESTART PROC AFTER A "STOP" MON.CALL
130705   FFPXX:    CALL ACTRDY
130706             CALL LOWACT500
130707   FFPOK:    MIN "LREG"                                       % GIVE SKIP RETURN
130710          FI FI
130710   FFPEX: BREG=:B; DREG=:D; GO LREG
130715   RBUS
130732
130732
130732   %============================================================================
130732   %       ( R )    X C L E A N
130732   %
130732   % Subroutine to clean up if shadow process is aborted
130732   % or nd-500 process terminates
130732   %
130732   SUBR XCLEAN
130732   INTEGER SVXREG,SVXXREG,SVLREG,SVDREG
130736   DOUBLE  CCMESS
130740   XCLEAN:
130740   *"8N500 8MTRA
"130740           A:=D=:SVDREG; RTREF=:D;  *IOF
130745           AD:=5MWQU; X:="5MWQU"
130747           DO WHILE D><0                        % REMOVE FROM WAITING QUEUEU
130751   *NNC35,    CNVBYADR
130754              X=:SVXXREG; D=:X; T:=5MBBANK; *LINK@3 LDDTX
130760              AD=:CCMESS
130761              D=:B; X=:SVXREG; *AAX XADPR; LDXTX
130765              IF X.RTRES=D THEN                 % PROCESS IN WAITING QUEUE
130770                 IF SVXXREG-"5MWQU"=0 THEN
130773                    CCMESS=:5MWQU               % ONLY THIS ONE IS QUEUE
130775                 ELSE
130776                    % MORE THAN ONE PROCESS IN WAITING QUEUE
130776                    X:=SVXXREG; CCMESS; *LINK@3 STDTX
131001                 FI; GO NXTS
131002              FI; X:=SVXREG; CCMESS
131004           OD
131005   NXTS:   *ION
131006           X:="READYQ-NLINK"; *IOF
131010           A:=L=:SVLREG
131012           % REMOVE ALL DATAFIELDS FROM READY QUEUE:
131012           DO X=:L=:SVXXREG
131014           WHILE X:=X.NLINK><0
131016              IF X.RTRES=RTREF THEN
131022                 0=:X.RTRES; X=:T; A:=L+"NLINK"=:X; CALL GETOUT; CALL PTFREE
131031                 % GIVE DATAFIELD TO ANY WAITING:
131031                 AD:=5MWQU
131032   *NNC36,       CNVBYADR
131035                 IF X:=D><0 THEN
131037                    T:=5MBBANK; *LINK@3 LDDTX
131041                    AD=:5MWQU; CALL GCPUDF; CALL ERRFATAL
131044                    A=:B; X=:SVXREG; X:=-1
131047   *NNT36=*
131047                    CALL TER500; 0/\0
131051                    X:=SVXREG
131052                    CALL SLOCK; 0/\0; CALL ITO500XQ; CALL SUNLOCK
131056                 FI
131056                 X:=SVXXREG
131057              FI
131057           OD; SVLREG=:L; *ION
131063           % MARK ALL REQUESTS IN DISK QUEUE FOR THIS PROCESS
131063           % AS INACTIVE (TRANSFER WILL NOT BE DONE IF RTRES=0):
131063           X:="BFQUE"
131064           DO WHILE X<<"EFQUE"
131067              IF X.RTRES=RTREF THEN 0=:X.RTRES; FI
131074              A:=X+"5POOLELSIZE"=:X
131077           OD
131100           SVDREG=:D
131102   *"8N500
"131102           EXIT
131103
131103   *"8N500
"131103
131103   RBUS
131123
131123
131123   %========================================================================
131123   %       ( R )    X M S I N I T
131123   %
131123   % Clear the memory area used for nd-500 messages (maiboxes), and
131123   % setup the message addr in all used nd-500 process descriptions.
131123   % The histogram message and the watchdog (time-out), messages are
131123   % initialized and setup as well.
131123   %
131123   % Entry:     none
131123   %
131123   SUBR XMSINIT
131123   INTEGER SVDREG=?
131123   INTEGER MSMLINK,MSCPUNO,MSDFCPU,MSQLINK
131127
131127   XMSINIT: *1BANK; COPY SD DA; STA I (SVDRE; 2BANK
131133          5FPMAILBOX=:D:=0; AD SH 12; A=:5MBBANK             % MEMORY BANK FOR MESSAGES
131140          A=:T; 5NPMAILBOX SH 12 -1+D; D=:X
131146          DO WHILE X><A
131150             *STZTX
131151             X+1
131152          OD
131153          A:=D=:X500DF
131155          A+5EXTDFSIZE=:MSMLINK
131157          X500DF+"X5BACTIVEQ-X5NACTIVEQ"=:MSQLINK
131162          0=:MSCPUNO; X:="S5CPUDF"                           % INITIALIZE SHARED MEMORY EXTENSIONS
131164          DO WHILE X<<="E5CPUDF"                             % OF ALL ND-500 CPU DATAFIELDS
131167             X=:MSDFCPU
131170             0=:X.LEXQUEUE
131171             MSMLINK=:D; 5MBBANK; AD=:X.MAILLINK
131175             *CNVWADR
131200             T:=5MBBANK; X:=MSQLINK; *AAX X5NAC; STDTX
131204             T:=MSDFCPU.MAIL1LINK; X:=X.MAILINK=:MSQLINK
131210             A:=-1=:D; *AAX X5BEX; STDTX
131214             *AAX X5ACT-X5BEX; STATX
131216             *AAX X5PRO-X5ACT; STATX                         % -1=:TX.X5PROC       (ND-500 IDLE)
131220             IF MSDFCPU.MIFLAG BIT MUDOM THEN
131224                X.5STATION
131225                T:=5MBBANK; X:=MSMLINK; *AAX X5STA; STATX
131231                MAXOCTBUF+1 SH -1 + MAXACCPBUFF+2000 SH -12
131237                T:=MSCPUNO; *RMPY ST DA
131241                5FPACCPBUF; D+A; A:=0; AD SH 12
131245                T:=5MBBANK; X:=MSMLINK; *AAX X5ACC; STDTX    % ACCP BUFFERS
131251                A:=:D; A+MAXACCPBUFF; D:=D+C:=:A
131255                *AAX X5OCT-X5ACC; STDTX                      % OCTOBUS BUFFERS
131257                MSCPUNO SH 1 + 5FPHWBUF=:D; A:=0; AD SH 12
131265                *AAX X5HWB-X5OCT; STDTX                      % HW BUFFERS
131267             FI
131267             MSMLINK+5EXTDFSIZE=:MSMLINK
131272             MIN MSCPUNO; X:=MSDFCPU+5CPUDFSZ
131275          OD
131276          MSMLINK=:D; GO MSIN0; *)FILL
131317
131317   INTEGER MSINPROCNO,MSPRDESCR
131321   MSIN0:
131321          A:=55MSNEGSIZE+D=:SWMSG
131324          T:=5MBBANK; A=:X:=0 BONE 5SYSRES
131330          *AAX 5MSFL; STATX; AAX -5MSFL
131333          5SWPROC=:MSINPROCNO; X:="S500S"
131336          FOR MSINPROCNO DO WHILE MSINPROCNO<<=MX5PROCS
131342             X=:MSPRDESCR
131343             A:=D/\1777+55MESSIZE
131346             IF A>>2000 THEN D SHZ -12 +1 SH 12 FI
131354             A:=D+55MSNEGSIZE=:X.MESSBUFF                     % ADDR OF MESSAGE INTO PROC.DESCR.
131357             T:=5MBBANK; X:=:A; *AAX XADPR; STATX; AAX -XADPR
131364             MSINPROCNO; *SENDE@3 STATX
131366             X:=MSPRDESCR+5PRDSIZE; 55MESSIZE; D+A
131372          OD
131374          GO MSIN1; *)FILL
131405
131405   MSIN1:
131405          IF NCPU>1 THEN
131411             X:=D+55MSNEGSIZE=:DUMMESS; T:=5MBBANK            % EX.QUEUE HEAD IN MULTI-CPU SYSTEMS
131415             A:=-1; *LINK1@3 STATX; LINK2@3 STATX
131420             *SENDE@3 STATX                                   % SET SENDER=-1 IN HISTOGRAM MESSAGE
131421             A:=77777; *AAX 5PRIO; STATX                      % MAX PRIORITY
131424             A:=0 BONE 5SYSRES
131426             *AAX 5MSFL-5PRIO; STATX; AAX -5MSFL
131431             A:=55MESSIZE; D+A
131433          FI
131433          X:=D+55MSNEGSIZE=:HIMESS; T:=5MBBANK                % ADDR OF HISTOGRAM MESSAGE
131437          A:=-1; *SENDE@3 STATX                               % SET SENDER=-1 IN HISTOGRAM MESSAGE
131441          3RPREG; *MICFU@3 STATX                              % MICRO-PROG. FUNCTION IS READ P-REGISTER
131443          A:=77776; *AAX 5PRIO; STATX                         % MAX PRIORITY
131446          A:=0 BONE 5SYSRES BONE 5CPUBOUND
131451          *AAX 5MSFL-5PRIO; STATX; AAX -5MSFL
131454          A:=55MESSIZE; D+A
131456   *"8N500 8MPRF
"131456          X:=D; X+55MSNEGSIZE=:MPHMESS                        % INITIALIZE HIST-MSG FOR PERFORMANCE LOGGING
131461          A:=-1; *SENDE@3 STATX                               % SET SENDER =-1
131463          3RPREG; *MICFU@3 STATX                              % MICRO-FUNC. = READ-P-REG.
131465          A:=77776; *AAX 5PRIO; STATX                         % MAX PRIORITY
131470          A:=0 BONE 5SYSRES BONE 5CPUBOUND
131473          *AAX 5MSFL-5PRIO; STATX                             % INITIALIZE MESSAGE-FLAG
131475          A:=1; *AAX 5CPUN-5MSFL; STATX                       % ???????
131500          A:=55MESSIZE; D+A
131502   *"8N500
"131502          "S5CPUDF"=:B
131504          DO WHILE B<<="E5CPUDF"
131507             A:=D+55MSNEGSIZE=:WATCHDOG=:X                    % ADDR OF WATCHD4_4
131513             A:=-1; T:=5MBBANK; *SENDE@3 STATX                % SET SENDER=-1 IN WATCHDOG MESS.
131516             3RMICV; *MICFU@3 STATX                           % MICRO-PROG. FUNCTION IS READ-MICP.-VERSION
131520             CPUNO; *AAX 5CPUN; STATX                         % CLEAR MESS.FLAG (SET NOT IN EX-QUEUE)
131523             A:=77776; *AAX 5PRIO-5CPUN; STATX                % MAX PRIORITY
131526             A:=0 BONE 5SYSRES BONE 5CPUBOUND
131531             *AAX 5MSFL-5PRIO; STATX
131533             IF "N500DF".NCPU>1 AND MIFLAG BIT MUDOM THEN
131543                X:=MAILINK; T:=5MBBANK
131545                DUMMESS=:D; A:=T
131550   *NNC37,      CNVWADR
131553                *AAX X5BEX; STDTX
131555             FI
131555             WATCHDOG+"55MESSIZE-55MSNEGSIZE"=:D; B+5CPUDFSZ
131561          OD
131562          "N500DF"=:B
131564          GO MSIN2
131565   *)FILL
131600   INTEGER CCADR
131601
131601          % Allocate Swap-wait-fifo buffer
131601   MSIN2: A:=D=:CCADR
131603          5MBBANK;
131604   *NNC38,CNVWADR
131607          T:=5MBBANK; X:=X500DF; *AAX X5SWB; STDTX
131613          *AAX X5SWH-X5SWB; STZTX; AAX X5SWF-X5SWH; STZTX
131617          IF MX5PROCS SH 1>55MESSIZE THEN T+T FI
131625          CCADR+T=:D
131630
131630          % Allocate Message-Communication-fifo buffer
131630          5MBBANK=:T; *CNVWADR
131635          *AAX X5FIF-X5SWF; STDTX
131637          MX5PROCS; *AAX X5MXF-X5FIF; STATX
131642          A:=-1=:D; *AAX X5BTI-X5MXF; STDTX
131646          SWMSG=:D; A:=T
131651   *NNC39,CNVWADR
131654          *AAX X5SWM-X5BTI; STDTX; AAX -X5SWM
131657          NCPU; *AAX X5NCP; STATX
131662          N1OCTDEST; *AAX X1STA-X5NCP; STATX
131665          5NKSTART; *AAX X5NKS-X1STA; STDTX    % Start of Nucleus Kernel
131670          0=:5DBFLAG
131671
131671          SVDREG=:D; EXIT
131674
131674   INTEGER SVDREG
131675   RBUS
131703
131703   %========================================================================
131703   %       ( R )    X 5 G B U F F
131703   %       ( R )    X 5 X G B U F F
131703   %
131703   % Routine to reserve contiguous memory area for various ND-500(0) buffers.
131703   % The whole memory is searched.
131703   %
131703   % X5GBUFF:   The reserved area must be within 1 memory bank.
131703   % X5XGBUFF:  The reserved may cross a 64k memory bank
131703   %
131703   % Entry:     A=number of pages to reserve
131703   % Exit:      no memory available
131703   % Exit ad1:  A=first physical page reserved
131703   %
131703   SUBR X5XGBUFF,X5GBUFF
131703
131703   INTEGER 5GBNPAGES,5GBFPAGE,5GBLPAGE,5GBFLAG,5GBEPART
131710   INTEGER ARRAY PM61:=("1",5GBNPAGES,5GBFPAGE,5GBLPAGE,"0","0")
131716   INTEGER POINTER 5GBLREG
131717   DOUBLE ARRAY POINTER DPAMEMTABLE
131720   INTEGER TYPADR
131721   INTEGER CCINX,XDRGX
131723
131723   X5XGBUFF:  T:=1=:5GBFLAG; GO 5GBFELLS
131726   X5GBUFF:   0=:5GBFLAG
131727   5GBFELLS: A=:5GBNPAGES; A:=L=:"5GBLREG":=D=:XDRGX
131734             "AMEMTABLE"+B=:"DPAMEMTABLE"+"TYPMTAB-AMEMTABLE"=:TYPADR
131741             0=:CCINX
131742             FOR CCINX DO WHILE X:=CCINX<"MXMPARTS-1"
131746                T:=TYPADR; *LBYT
131750                T:=0 BONE MSHARED BONE PSACC BONE DSACC
131754                IF A=T THEN
131756                   AD:=DPAMEMTABLE(X); IF A=0 THEN A+1 FI
131761                   IF D=0 GO OUT
131763                   A+ADRZERO=:5GBFPAGE; A:=D-1+ADRZERO=:5GBEPART=:5GBLPAGE=:D
131773   LOOP:           IF 5GBFPAGE+5GBNPAGES-1<<=D THEN
132000                      IF T:=5GBFLAG=0 THEN
132003                         IF A SHZ -6><5GBFPAGE SHZ -6 THEN
132010                            5GBFPAGE SHZ -6 +1 SH 6=:T+5GBNPAGES
132016                            IF A>>D GO NXTAREA
132020                            IF A SHZ -6><T SHZ -6 GO OUT
132024                            A:=T SH 6=:5GBFPAGE
132027                         FI
132027                         5GBFPAGE/\177700+77=:5GBLPAGE
132033                      FI
132033                      IF 5GBFPAGE+5GBNPAGES-1>>ENDPAGE GO OUT      % AREA NOT AVAILABLE
132041                      "ARPIT"=:D; CALL DALTON                      % SET 5PIT AS ALT.PIT
132044                      "PM61"; *MON 61
132046                      GO 5GB2                                      % MEMORY NOT RESERVED
132047                      CALL ALTOFF                                  % SET DPIT AS ALT.PIT
132050                      A=:5GBFPAGE=:D; 5GBNPAGES+D-1:=:D
132056                      CALL DISPCACHE; 0/\0
132060                      5NPAGES+5GBNPAGES=:5NPAGES
132063                      A:=5GBFPAGE
132064                      MIN "5GBLREG"; GO OUT                        % MEMORY RESERVED, A=FIRST PHYS.PAGE IN AREA
132066   5GB2:              CALL ALTOFF                                  % SET DPIT AS ALT.PIT
132067                      IF 5GBFLAG=0 THEN
132071                         5GBFPAGE+100/\177700 =:5GBFPAGE           % TRY IN NEXT BANK
132075                         5GBEPART=:5GBLPAGE=:D
132100                         GO LOOP
132101                      FI
132101                   FI
132101                FI
132101   NXTAREA:  OD
132103   OUT:     T:=XDRGX=:D
132105            GO 5GBLREG
132106   RBUS
132122
132122
132122   %============================================================
132122   %            X X 5 C O N O M D
132122   %
132122   % Calls "CON5OMD" on driver level to connect octobus OMD no.
132122   % 'ALIVE'-bit in CPUAVAILABLE is set if everything is ok.
132122   %
132122   % Exit:     A><0 indicates "Samson" CPUs
132122   %
132122   SUBR XX5CONOMD
132122   INTEGER 5TMUNIT,5TM
132124   INTEGER ARRAY PM104:=(5TM,5TMUNIT)
132126   INTEGER POINTER 5CONLREG=?
132126   INTEGER XDRGX=?
132126   INTEGER CBSET=?
132126
132126   XX5CONOMD: A:=L=:"5CONLREG":=D=:XDRGX
132132          IF "LMDF".5OMDNO=0 THEN
132135             *IOF
132136             A:=X;      *IRW LV12B DB
132140             "CON5OMD"; *IRW LV12B DP
132142             LV12;      *MST PID
132144             *ION
132145          FI
132145          IF "LMDF".5OMDNO><0 THEN
132150             FOR X:=FMFDEST TO LMFDEST DO
132154                *IOF
132155                A:=X;        *IRW LV12B DA
132157                "LMDF";      *IRW LV12B DB
132161                "MFPREPARE"; *IRW LV12B DP
132163                LV12;        *MST PID
132165                *ION
132166                "ARPIT"=:D; CALL DALTON
132171                0=:5TM=:5TMUNIT; "PM104"; *MON 2HOLD
132175                1=:5TM; 2=:5TMUNIT; "PM104"; *MON 2HOLD
132203                CALL ALTOFF
132204             OD
132206          FI
132206          X:="S5CPUDF"; 0=:NSAMSON=:N5CPU
132211          DO WHILE X<<="E5CPUDF"
132214             IF X.CPUAVAILABLE/\5CPUTYPE=SAMSON THEN
132221                X.CPUNO+FN5DEST-1=:X.5STATION
132225                *IOF
132226                A:=X;        *IRW LV12B DB
132230                "LMDF";      *IRW LV12B DX
132232                "CON5IDENT"; *IRW LV12B DP
132234                LV12;        *MST PID
132236                *ION
132237                "ARPIT"=:D; CALL DALTON
132242                0=:5TM=:5TMUNIT; "PM104"; *MON 2HOLD
132246                1=:5TM; 2=:5TMUNIT; "PM104"; *MON 2HOLD
132254                CALL ALTOFF
132255                MIN NSAMSON
132256             ELSE IF X.CPUAVAILABLE BIT 5ALIVE THEN
132262                IF X.HDEV=660 THEN         % Check for overlapping device numbers
132266                   1042; CALL LOGPH             % Check logical device number 546d - teminal group #4
132270                   IF A><0 OR D><0 THEN         % Overlapping device number?
132273                      0=:X.CPUAVAILABLE         % Yes, set CPU unavailable
132274                   FI
132274                FI
132274             FI FI
132274             IF X.CPUAVAILABLE BIT 5ALIVE THEN MIN N5CPU FI
132300             X+5CPUDFSZ
132301          OD
132302          GO BYPASS
132303
132303   INTEGER POINTER 5CONLREG
132304   INTEGER XDRGX
132305   *)FILL
132326
132326   % Patch n500 code according to CPU type
132326   INTEGER CBSET(0); *BSET ONE 00 DA
132327   INTEGER CPIT,CINSTR,CTAB
132332
132332   BYPASS: "NNTAB"=:B
132334           DO WHILE B<<"ENNTA"
132337              S0*200+174000=:CPIT
132343              IF NSAMSON><0 THEN S1; T:=S2 ELSE S3; T:=S4 FI
132352              A=:CINSTR; T=:CTAB
132354              IF T><0 THEN
132356                DO WHILE CTAB.S0><-1
132363                   IF A><0 THEN
132364                      D:=0; AD SHZ -12; A SH 1+CPIT=:X
132371                      AD SH 12; A/\1777=:D
132374                      T:=0; *LDATX 10
132376                      A=:T SHZ -6:=:T/\77 SH 12+D=:X
132405                      CINSTR; *STATX
132407                   FI
132407                   MIN CTAB; 0/\0
132411                OD
132412             FI
132412             B+5
132413          OD
132414          "N500DF"=:B; XDRGX=:D; GO 5CONLREG
132421   RBUS
132431
132431
132431   *"-8N500
"132431
132431   @DEV 1
132431   @DEV (S-S-L)RP-P2-MSYSU:NPL
132431   %======================================================================%
132431   %                                                                      %
132431   %  ( R )   M S Y S U   M O N I T O R   C A L L                         %
132431   %                                                                      %
132431   %======================================================================%
132431
132431
132431   %====================================================================
132431   %          M S Y S U
132431   %
132431   % MSYSU : MON SYSU MAIN ENTRY
132431   %
132431   SUBR MSYSU
132431
132431   MSYSU: CALL GETIM                           % GET PARAMETERS
132432          MLEV; *MST PIE                       % ENABLE MONITOR LEVEL
132434          X:=D2; CALL R1USR; A=:D3             % GET AMOUNT
132437          X:=D2; "0"; CALL W1USR               % ZERO RETURNED AMOUNT
132442          -1=:ESCFL                            % SET NO ESCAPE DISABLE
132444          IF BACKGROUND><0 THEN
132446             IF "BFIELD".PASSTYPE=0 THEN
132451                NAUT=:ZAREG; GO MXRET          % NOT AUTHORIZED TO CALL MSYSU
132454             FI
132454             CALL GETDATAFIELD                 % GET TERMINAL DATAFIELD
132455             T:="FLAGB"; CALL XGTDFADDR        % GET FLAG
132457             IF A BIT 5ESCON THEN 0=:ESCFL FI  % ESCAPE ENABLED
132462          FI
132462
132462          IF D0<<=17 THEN                      % CHECK FUNCTION CODE
132466   @ICR;
132466   *"8DIMI
"132466             GOSW ILFNC,RDMT,WDMT,RDMH,WDMH,LOABS,LODLT,LODEI,
132477                  LCLDB,LOSAB,DDRES,DDREL,LOABM,DOLCK,DULCK,D9FLE;
132507   *"-8DIMI
"132507          FI
132507
132507   ILFNC: UKFNC; GO OUT1                       % ILLEGAL FUNCTION CODE
132511
132511   *"8DIMI
"132511   RDMT:  CALL RDDMT; GO OUT1; GO FIN          % READ DMT
132514
132514   WDMT:  CALL WRDMT; GO OUT1; GO FIN          % WRITE DMT
132517
132517   RDMH:  CALL RDDMH; GO OUT1; GO FIN          % READ DMT HEADER
132522
132522   WDMH:  CALL WRDMH; GO OUT1; GO FIN          % WRITE DMT HEADER
132525
132525   LOABS: CALL DOABS; GO OUT1; GO OUT2         % DO ABSTRANS CALL
132530
132530   LODLT: CALL DODLT; GO OUT1; GO OUT2         % READ DISK LAYOUT TABLE
132533
132533   LODEI: CALL DODEI; GO OUT1; GO FIN          % READ DISK ERROR INFO
132536
132536   LCLDB: CALL CLDVB; GO FIN                   % CLEAR ALL DEVICE BUFFERS
132540
132540   LOSAB: CALL DOSAB; GO OUT1; GO OUT2         % DO ABSTRANS CALL ON SECONDARY
132543   *"
"132543   DDRES: CALL DRESD; GO OUT1; GO FIN          % DIMIR RESERVE DIRECTORY
132546
132546   DDREL: CALL DRELD; GO OUT1; GO FIN          % DIMIR RELEASE DIRECTORY
132551   *"8DIMI
"132551   LOABM: CALL DOABM; GO OUT1; GO OUT2         % ABSTR WITH MEMORY BUFFER
132554
132554   DOLCK: CALL DCRES; GO OUT1; GO FIN          % RESERVE LOCK
132557
132557   DULCK: CALL DCREL; GO OUT1; GO FIN          % RELEASE LOCK
132562   *"
"132562   D9FLE: CALL DFLEA; GO OUT1; GO FIN          % 9FLEA INTERFACE
132565
132565   FIN:   "0"                                  % STATUS OK
132566   OUT2:  MIN ZPREG; 0/\0                      % PREPARE SKIP RETURN
132570   OUT1:  A=:ZAREG                             % STORE RETURN STATUS
132571          IF ESCFL>0 THEN CALL ESCON FI        % REENABLE ESCAPE
132575          GO MXRET
132576   RBUS
132631
132631
132631   %====================================================================
132631   %          D F L E A
132631   %
132631   % DFLEA : INTERFACE TO 9FLEA
132631   %
132631   %     ENTRY : B = MON SYSU WORK AREA
132631   %
132631   %     EXIT  : A = ERROR CODE
132631   %     EXIT+1: OK
132631   %
132631   SUBR DFLEA
132631
132631   INTEGER PARAD=?, NWORD=?
132631
132631   DISP SYWA=SYUWA
132631      INTEGER POINTER HOME
132631      INTEGER U, COUNT
132631      INTEGER ARRAY PARAM(100)
132631   PSID
132631
132631   DFLEA: A:=L=:"HOME"
132633          D1=:X=:U                             % USER PARAMETER ARRAY
132636          IF D3=:NWORD>>"SYUWL" THEN UKPAR; GO ERR FI
132645          "PARAM"+B=:PARAD; D:=0
132651          D3-=:COUNT
132654          FOR COUNT DO
132654             X:=U; CALL R1USR; X+1=:U          % READ FROM USER
132660             A=:PARAM(D); D+1
132663          OD
132665          CALL 9FLEA
132666   INTEGER PARAD, NWORD                        % ADDRESS AND WORDCOUNT
132670          MIN "HOME"                           % PREPARE SKIP RETURN
132671   ERR:   GO HOME
132672   RBUS
132677
132677
132677   *"8DIMI
"132677   %====================================================================
132677   %          R D D M T
132677   %
132677   % RDDMT : PERFORM READ CLUSTER TAGS
132677   %
132677   %     ENTRY : B = MON SYSU WORK AREA
132677   %
132677   %     EXIT  : A = ERROR CODE
132677   %     EXIT+1: OK
132677   %
132677   SUBR RDDMT
132677
132677   DISP SUWA=SYUWA
132677      INTEGER ARRAY DMTCOPY(0)
132677   PSID
132677
132677   INTEGER U, COUNT
132701   INTEGER POINTER HOME
132702
132702   RDDMT: A:=L=:"HOME"
132704          X:=D1; CALL R1USR; X+1=:U            % CLUSTER NUMBER
132710          IF A-1>>="NDMTE" THEN CLTHI; GO ERR FI
132716          A*DMTL+"DMTBL+DMHL"=:CLUP            % CLUSTER POINTER
132721          *IOF
132722          FOR X:=0 TO "DMTLR-1" DO
132726             CLUAP(X)=:DMTCOPY(X)              % GET COPY TO ENSURE INTEGRETY
132730          OD
132732          *ION
132733          1-D3=:COUNT
132736          FOR COUNT DO
132736             X:=U; CALL R1USR                  % NEXT TAG NUMBER
132740             X:="DMTCOPY"+B; CALL RCTAG; GO ERR
132744             X:=U; CALL W1USR; X+1=:U          % WRITE VALUE
132750          OD
132752          MIN "HOME"; 0/\0                     % PREPARE SKIP RETURN
132754   ERR:   A=:D:=D3+COUNT; X:=D2; CALL W1USR    % NEW AMOUNT
132761          A:=D; GO HOME
132763   RBUS
132773
132773
132773   %====================================================================
132773   %          W R D M T
132773   %
132773   % WRDMT : PERFORM WRITE CLUSTER TAGS
132773   %
132773   %     ENTRY : B = MON SYSU WORK AREA
132773   %
132773   %     EXIT  : A = ERROR CODE
132773   %     EXIT+1: OK
132773   %
132773   SUBR WRDMT
132773
132773   DISP SUWA=SYUWA
132773      INTEGER ARRAY DMTCOPY(0)
132773   PSID
132773
132773   INTEGER U, UMAX, WIMFL
132776   INTEGER POINTER HOME
132777
132777   WRDMT: A:=L=:"HOME"
133001          X:=D1; D3+X=:UMAX
133005          CALL R1USR; X+1=:U                   % CLUSTER NUMBER
133010          IF A-1>>="NDMTE" THEN CLTHI; GO ERR FI
133016          A*DMTL+"DMCLT"=:CLUP                 % CLUSTER POINTER
133021          *IOF
133022          FOR X:=0 TO "DMTLW-1" DO
133026             CLUAP(X)=:DMTCOPY(X)              % GET COPY OF CLUSTER ENTRY
133030          OD
133032          *ION
133033          0=:WIMFL                             % RESET WRITE IMAGE FLAG
133034          DO
133034             WHILE X:=U<<UMAX
133040             CALL R2USR; X+2=:U                % NEXT TAG AND VALUE
133043             X:="DMTCOPY"+B; CALL WCTAG; GO ERR
133047             IF K THEN MIN WIMFL; 0/\0 FI      % SET WRITE IMAGE FLAG
133053          OD
133054          X:="DMTCOPY"+B; CALL PRCLU           % SET FLAGS ETC.
133057          MIN ESCFL; CALL ESCOFF               % ESCAPE OFF
133061          *IOF
133062          "DMWCA"; *IRW MLEVB DP               % ACTUAL UPDATE PERFORMED ON MLEV
133064          MLEV; *MST PID                       % ENABLE MLEV
133066          *ION
133067          IF ZAREG=0 THEN
133071             IF WIMFL><0 THEN
133073                A:="DMTCOPY"+B; X:="DMTLI"     % SOURCE ADDRESS AND LENGTH
133076                T:=CLUP; CALL WIMAG            % UDATE CLUSTER ON IMAGE
133100             FI
133100             MIN "HOME"; 0/\0                  % PREPARE SKIP RETURN
133102          FI
133102   ERR:   GO HOME
133103   *)FILL
133117
133117   INTEGER POINTER SAVL
133120   PRCLU: A:=L=:"SAVL"
133122          0=:X.DMDFU; DMFLG BONE 8DERR=:DMFLG
133126          IF X.DMFLG BIT 8DEUS THEN
133131   %
133131   % PREPARE PRIMARY ENTRY
133131             X.PRDEV SHZ -4; CALL LOGPH; A=:X.PRCDF
133135             IF X.PRFLG BIT 9DIFL THEN A BONE 9DDIS=:X.PRFLG FI
133142             IF A NBIT 9DDIS AND X.PRVAL=0 THEN
133146                X.DMFLG BZERO 8DERR=:X.DMFLG
133151             FI
133151   %
133151   % PREPARE SECONDARY-1 ENTRY
133151             X.S1DEV SHZ -4; CALL LOGPH; A=:X.S1CDF
133155             IF A><0 THEN
133156                IF X.S1FLG BIT 9DIFL THEN A BONE 9DDIS=:X.S1FLG FI
133163                IF A NBIT 9DDIS AND X.S1VAL=0 THEN
133167                   X.DMFLG BZERO 8DERR=:X.DMFLG
133172                FI
133172             FI
133172   %
133172   % PREPARE SECONDARY-2 ENTRY
133172             X.S2DEV SHZ -4; CALL LOGPH; A=:X.S2CDF
133176             IF A><0 THEN
133177                IF X.S2FLG BIT 9DIFL THEN A BONE 9DDIS=:X.S2FLG FI
133204                IF A NBIT 9DDIS AND X.S2VAL=0 THEN
133210                   X.DMFLG BZERO 8DERR=:X.DMFLG
133213                FI
133213             FI
133213   %
133213   %
133213             IF X.DMFLG NBIT 8DERR THEN
133216                A/\177770                      % CLEAR PASSTHROUGH
133217             FI
133217             IF T:=X.DRDB1=0 AND T:=X.DRDB2=0 THEN
133225                A BZERO 8DRDB                  % NO READ DISTRIBUTION BORDER
133226             ELSE
133227                A BONE 8DRDB                   % USE READ DISTRIBUTION BORDER
133230             FI
133230             A=:X.DMFLG
133231             IF A BIT 8DMIR THEN
133233                17/\X.PRDEV+X.PRCDF=:X.DMDFU   % SET SEARCH WORD
133237             FI
133237          FI
133237          GO SAVL
133240   RBUS
133242
133242   %====================================================================
133242   %          R D D M H
133242   %
133242   % RDDMH : PERFORM READ DMT HEADER
133242   %
133242   %     ENTRY : B = MON SYSU WORK AREA
133242   %
133242   %     EXIT  : A = ERROR CODE
133242   %     EXIT+1: OK
133242   %
133242   SUBR RDDMH
133242
133242   INTEGER U, COUNT
133244   INTEGER POINTER HOME
133245
133245   RDDMH: A:=L=:"HOME"
133247          D1=:U; D3-=:COUNT                    % PARAMETERS
133254          FOR COUNT DO
133254             X:=U; CALL R1USR                  % NEXT TAG NUMBER
133256             CALL RHTAG; GO ERR                % READ TAG
133260             X:=U; CALL W1USR                  % RETURN VALUE
133262             MIN U; 0/\0
133264          OD
133266          MIN "HOME"; 0/\0                     % PREPARE SKIP RETURN
133270   ERR:   A=:D:=D3+COUNT; X:=D2; CALL W1USR    % NEW AMOUNT
133275          A:=D; GO HOME
133277   RBUS
133302
133302   %====================================================================
133302   %          W R D M H
133302   %
133302   % WRDMH : PERFORM WRITE DMT HEADER
133302   %
133302   %     ENTRY : B = MON SYSU WORK AREA
133302   %
133302   %     EXIT  : A = ERROR CODE
133302   %     EXIT+1: OK
133302   %
133302   SUBR WRDMH
133302
133302   INTEGER U, UMAX
133304   INTEGER POINTER HOME
133305
133305   WRDMH: A:=L=:"HOME"
133307          D1=:U+D3=:UMAX                       % PARAMETER ARRAY ADDRESS
133313          MIN ESCFL; CALL ESCOFF               % ESCAPE OFF
133315          DO
133315             WHILE X:=U<<UMAX
133321             CALL R2USR                        % NEXT TAG AND VALUE
133322             CALL WHTAG; GO ERR                % PERFORM UPDATE
133324             IF K THEN                         % SET WRITE IMAGE FLAG
133326                X=:A=:T:=1; CALL WIMAG         % UPDATE IMAGE
133332             FI
133332             U+2=:U
133335          OD
133336          MIN "HOME"; 0/\0                     % PREPARE SKIP RETURN
133340   ERR:   GO HOME
133341   RBUS
133345
133345   %====================================================================
133345   %          C L D V B
133345   %
133345   % CLDVB : CLEAR ALL DEVICE BUFFERS
133345   %
133345   SUBR CLDVB
133345   INTEGER POINTER HOME
133346   INTEGER IX
133347
133347   CLDVB: A:=L=:"HOME"
133351          IF BACKGROUND=0 THEN
133353             "OFLCK"; CALL XLOCK
133355          FI
133355          0=:IX; FOR IX TO 376 DO A=:T; CALL FILSYS(CLADV) OD
133371          IF BACKGROUND=0 THEN
133373             "OFLCK"; CALL XUNLOCK
133375          FI
133375          GO HOME
133376   RBUS
133404
133404   %====================================================================
133404   %          D O A B S   D O S A B    D O A B M
133404   %
133404   % DOABS : DO ABSTR CALL AFTER TRANSFER OF PARAMETERS
133404   %         (TO ALLOW PAGEFAULT IN ABSTR CALL)
133404   %
133404   %     ENTRY : B = MON SYSU WORK AREA
133404   %
133404   %     EXIT  : A = HARDWARE STATUS
133404   %     EXIT+1: A = HARDWARE STATUS
133404   %
133404   %
133404   %  DOSAB : DO ABSTRANS CALL ON SECONDARY IN CLUSTER (=DOABS)
133404   %
133404   %  DOABM : DO ABSTRANS WITH LOCAL MEMORY BUFFER (64 WORDS)
133404   %
133404   SUBR DOABS, DOSAB, DOABM
133404
133404   DISP SYWA=SYUWA   % LAYOUT OF WORK AREA
133404      INTEGER A2DEV
133404      INTEGER A2FNC
133404      INTEGER A2ME1, A2ME2
133404      DOUBLE  A2MEA=A2ME1
133404      DOUBLE  A2DIA
133404      INTEGER A2NBL
133404      INTEGER A2PFN, A2PME, A2PDI, A2PNB
133404      INTEGER ARRAY MAREA(100)
133404   PSID
133404
133404   INTEGER MFLAG,U,UMIN,COUNT,SAVA
133411   INTEGER POINTER HOME
133412
133412   DOABM: 1=:MFLAG; GO ABCOM
133415   DOABS:
133415   DOSAB: 0=:MFLAG
133416   ABCOM: A:=L=:"HOME"
133420          X:=D1                                % GET PARAMETER ARRAY ADDRESS
133421          CALL R1USR; A=:A2DEV; X+1            % DEVICE
133424          CALL R1USR; A=:A2FNC; X+1            % FUNCTION
133427          CALL R2USR; AD=:A2MEA; X+2           % MEMORY ADDRESS
133432          CALL R2USR; AD=:A2DIA; X+2           % DISK ADDRESS
133435          CALL R1USR; A=:A2NBL; X+1            % NUMBER OF SECTORS
133440          "A2FNC"+B=:A2PFN                     % SET PARAM ADDRESS LIST
133443          "A2MEA"+B=:A2PME
133446          "A2DIA"+B=:A2PDI
133451          "A2NBL"+B=:A2PNB
133454          IF MFLAG><0 THEN
133456             A2MEA; A:=:D=:U=:UMIN; D3-=:COUNT % MEMORY AREA
133465             CALL GMEMB; GO ERR; AD=:A2MEA     % MEMORY ADDRESS
133470             FOR COUNT DO
133470                X:=U; CALL R1USR               % READ FROM USER
133472                T:=A2ME1; D=:X+1; *STATX       % WRITE TO IO-SEGMENT
133476                MIN U; 0/\0
133500             OD
133502          FI
133502          "A2PFN"+B; T:=A2DEV; *MON 2ABST      % CALL ABSTRANS
133506          A=:SAVA                              % HARDWARE STATUS
133507          IF MFLAG><0 THEN
133511             UMIN=:U; D3-=:COUNT; A2MEA
133517             FOR COUNT DO
133517                T:=A2ME1; D=:X+1; *LDATX       % READ FROM BUFFER AREA
133523                X:=U; CALL W1USR               % WRITE TO USER
133525                X+1=:U
133527             OD
133531             D3; X:=D2; CALL W1USR             % RETURNED AMOUNT
133534          FI
133534          MIN "HOME"; 0/\0; SAVA               % PREPARE SKIP RETURN
133537   ERR:   GO HOME
133540   *)FILL
133551
133551   % LOCAL ROUTINE TO GET MEMORY BUFFER
133551
133551   GMEMB: IF A<=2000 THEN
133554             "FC510"; *MON 61                  % GET PAGE NUMBER OF IO-BUFFER
133556             GO ERSEG; IF T=0 GO ERSEG         % ERROR IN SEGMENT
133561             D:=0; AD SHZ -6                   % MEMORY BUFFER ADDRESS
133563          ELSE
133564             UKPAR; EXIT                       % TRANSFER LARGER THAN BUFFER
133566          FI
133566          EXITA
133567   ERSEG: ILDWD; EXIT                          % "DIMWD NOT INSTALLED"
133571   RBUS
133575
133575   %====================================================================
133575   %          D O D L T
133575   %
133575   % DODLT : READ DISK LAYOUT TABLE
133575   %
133575   %     ENTRY : B = MON SYSU WORK AREA
133575   %
133575   %     EXIT  : A = ERROR CODE
133575   %     EXIT+1: OK
133575   %
133575   SUBR DODLT
133575   INTEGER U, COUNT, LAYAR, RUNIT
133601   INTEGER POINTER HOME
133602
133602   DODLT: A:=L=:"HOME"
133604          D1=:X=:U                             % USER PARAMETER ARRAY
133607          CALL R2USR; T:=D=:RUNIT              % GET DEVICE AND UNIT
133612          IF D>>3 THEN UDUNI; GO ERR FI        % NO SUCH UNIT
133617          CALL LOGPH
133620          IF A=0 THEN UDDEV; GO ERR FI         % NO SUCH DEVICE
133623          A:=:B; X:=HTABL(RUNIT)=:LAYAR; A:=:B % GET UNIT LAYOUT ADDRESS
133630          IF A:=:X=0 THEN UDUNI; GO ERR FI     % UNIT NOT DEFINED
133634          RUNIT SHZ 3; *ADD (BSKP ZRO 040 DX   % MAKE BSKP INSTRUCTION FOR UNIT
133637          X:=X.TYPEC; T:=0; *EXR SA; BSET ONE DT % GET SPARE TRACK BIT TO T
133643          IF LAYAR.REFOR BIT 4 THEN T BONE 1 FI  % INDICATE IF SPARE SECTOR
133650          T=:ZAREG                             % FORMAT INDICATOR
133651          "-DILEZ"=:COUNT                      % SIZE OF ARRAY
133653          FOR COUNT DO
133653             X:=LAYAR; X.S0; MIN LAYAR         % READ A WORD
133656             X:=U; CALL W1USR                  % WRITE TO USER
133660             MIN U; 0/\0
133662          OD
133664          "DILEZ"; X:=D2; CALL W1USR           % RETURNED AMOUNT
133667          ZAREG; MIN "HOME"                    % PREPARE SKIP RETURN
133671   ERR:   GO HOME
133672   RBUS
133701
133701
133701   %====================================================================
133701   %          D O D E I
133701   %
133701   % DODEI : READ DISK ERROR INFORMATION
133701   %
133701   %     ENTRY : B = MON SYSU WORK AREA
133701   %
133701   %     EXIT  : A = ERROR CODE
133701   %     EXIT+1: OK
133701   %
133701   SUBR DODEI
133701
133701   DISP SYWA=SYUWA
133701      INTEGER POINTER HOME
133701      INTEGER U, COUNT, ERRP, RDEV, RUNIT
133701   PSID
133701
133701   DODEI: A:=L=:"HOME"
133703          D1=:X=:U                             % USER PARAMETER ARRAY
133706          CALL R2USR; A=:RDEV:=D=:RUNIT        % GET DEVICE AND UNIT
133712          IF RUNIT>>3 THEN UDUNI; GO ERR FI    % NO SUCH UNIT
133720          RDEV; CALL LOGPH                     % GET DATAFIELD ADDRESS
133722          IF A=0 THEN UDDEV; GO ERR FI         % NO SUCH DEVICE
133725          A.DEDFADDR+RUNIT=:ERRP               % POINTER TO ERROR INFORMATION
133731          -14=:COUNT
133733          FOR COUNT DO
133733             ERRP=:X+4=:ERRP:=X.S0             % SINGLE TABLE ENTRY
133740             X:=U; CALL W1USR                  % WRITE TO USER
133742             MIN U; 0/\0
133744          OD
133746          "14"; X:=D2; CALL W1USR              % RETURNED AMOUNT
133751          MIN "HOME"                           % PREPARE SKIP RETURN
133752   ERR:   GO HOME
133753   RBUS
133757
133757   %====================================================================
133757   %          D C R E S    D C R E L
133757   %
133757   % DCRES : RESERVE CLUSTER LOCK
133757   %
133757   % DCREL : RELEASE CLUSTER LOCK
133757   %
133757   %     ENTRY : B = MON SYSU WORK AREA
133757   %
133757   %     EXIT  : A = ERROR CODE
133757   %     EXIT+1: OK
133757   %
133757   SUBR DCRES, DCREL
133757
133757   INTEGER RESFL, BOLD, CLPNT
133762   INTEGER POINTER HOME
133763
133763   DCRES: 1=:RESFL; GO FELLS
133766   DCREL: 0=:RESFL
133767   FELLS: A:=L=:"HOME":=B=:BOLD
133773          X:=D1; CALL R1USR                    % CLUSTER NUMBER
133775          IF A-1>>="NDMTE" THEN CLTHI; GO NSKIP FI
134003          A*DMTL+"DMTBL+DMHL"=:CLPNT           % CLUSTER POINTER
134006          X:=RTRES; "CLSEM"=:B                 % GET SEMAPHORE DATAFIELD
134011          MLEV; *MCL PIE                       % DISABLE MONITOR LEVEL
134013          IF RESFL><0 THEN
134015             CALL BRESERVE                     % TRY TO RESERVE
134016             IF A<0 THEN
134017                CALL FREXQU; CALL TOWQU        % INSERT IN WAIT QUEUE,
134021                BOLD=:B; ZPREG-1=:ZPREG        % MARK RESTART
134026                -1=:MTOR                       % AND GO TO "STUPR"
134030                GO MXRET                       % RELEASE MON SYSU DATAFIELD
134031             FI
134031             CLPNT.DMRFL BZERO 8DMSS=:X.DMRFL  % ZERO CLUSTER CHANGED FLAG
134035          ELSE
134036             IF X=RTRES THEN CALL BRELEASE FI  % RELEASE SEMAPHORE
134042          FI
134042          MLEV; *MST PIE                       % ENABLE MONITOR LEVEL
134044          MIN "HOME"                           % PREPARE SKIP RETURN
134045   NSKIP: T:=BOLD=:B                           % RESTORE MON SYSU DATAFIELD
134047          GO HOME
134050   RBUS
134064   *"
"134064
134064   %====================================================================
134064   %          D R E S D    D R E L D
134064   %
134064   % DRESD : RESERVE DIRECTORY FOR DISK MIRRORING
134064   % DRELD : RELEASE DIRECTORY RESERVED FOR DISK MIRRORING
134064   %
134064   %     ENTRY : B = MON SYSU WORK AREA
134064   %
134064   %     EXIT  : A = ERROR CODE
134064   %     EXIT+1: OK
134064   %
134064   SUBR DRESD, DRELD
134064
134064   DISP SYWA=SYUWA
134064      INTEGER LOGDV, LOGUN, SUBUN, DVHIT, UNHIT, SUHIT, RELFL, RSTAT, SAVSG, SAVRS
134064      INTEGER POINTER HOME
134064   PSID
134064
134064   DRELD: 1=:RELFL; GO FELLS
134067   DRESD: 0=:RELFL
134070   FELLS: A:=L=:"HOME"
134072          0=:RSTAT=:DVHIT=:UNHIT=:SUHIT        % ZERO COUNTERS
134076          X:=D1; CALL R2USR
134100          A=:LOGDV:=D=:LOGUN                   % DEVICE AND UNIT
134103          X+2; CALL R1USR; A=:SUBUN            % SUBUNIT
134106          GLDN; CALL XLOCK                     % RESERVE GENERAL DIRECTORY LOCK
134110          X:="DIRTA"
134111          DO
134111             IF X.DUNIT/\7777=LOGDV THEN
134116                MIN DVHIT; 0/\0                % DEVICE OK
134120                IF X.DUNIT SHZ -14=LOGUN THEN
134125                   MIN UNHIT; 0/\0             % UNIT OK
134127                   IF SUBUN=X.LUNIT SHZ -11 OR A=-1 THEN
134137                      MIN SUHIT; 0/\0          % SUBUNIT OK
134141                      X.DLOCK; CALL XLOCK      % RESERVE DIRECTORY LOCK
134143                      IF X.DIRFL BIT DENTE THEN
134146                         DFCENT=:RSTAT         % DIRECTORY ENTERED
134150                      FI
134150                   FI
134150                FI
134150             FI
134150             WHILE X+DTLEN<<"ENDDD"
134154          OD
134155          IF RSTAT=0 THEN
134157             IF DVHIT=0 THEN UDDEV=:RSTAT      % NO SUCH DEVICE
134163             ELSE
134164             IF UNHIT=0 THEN UDUNI=:RSTAT      % NO SUCH UNIT
134170             ELSE
134171             IF SUHIT=0 THEN USUNI=:RSTAT      % NO SUCH SUBUNIT
134175             FI FI FI
134175          FI
134175          IF RSTAT=0 THEN
134177             MIN "HOME"                        % OK RETUR
134200          ELSE
134201             -1=:RELFL                         % NO OPERATION
134203          FI
134203          X:="DIRTA"
134204          DO
134204             IF X.DUNIT/\7777=LOGDV THEN
134211                IF X.DUNIT SHZ -14=LOGUN THEN
134216                   IF SUBUN=X.LUNIT SHZ -11 OR A=-1 THEN
134226                      IF RELFL=0 THEN
134230                         X.DIRFL BONE DTUSE=:X.DIRFL
134233                      ELSE
134234                      IF RELFL=1 THEN
134240                         X.DIRFL BZERO DTUSE=:X.DIRFL
134243                      FI FI
134243                      X.DLOCK; CALL XUNLOCK    % RELEASE DIRECTORY LOCK
134245                   FI
134245                FI
134245             FI
134245             WHILE X+DTLEN<<"ENDDD"
134251          OD
134252          GLDN; CALL XUNLOCK                   % RELEASE GENERAL DIRECTORY LOCK
134254   ERR:   RSTAT; GO HOME
134256   RBUS
134271
134271   *"8DIMI
"134271   %====================================================================
134271   %          R 1 U S R   R 2 U S R   W 1 U S R
134271   %
134271   % R1USR : READ ONE WORD FROM USER ADDRESS SPACE
134271   %
134271   %     ENTRY : B = MSYSU DATAFIELD
134271   %             X = ADDRESS OF WORD
134271   %
134271   %     EXIT  : A = WORD
134271   %
134271   % R2USR : READ TWO WORD FROM USER ADDRESS SPACE
134271   %
134271   %     ENTRY : B = MSYSU DATAFIELD
134271   %             X = ADDRESS OF WORD
134271   %
134271   %     EXIT  : AD = DOUBLEWORD
134271   %
134271   %
134271   % W1USR : WRITE ONE WORD TO USER ADDRESS SPACE
134271   %
134271   %     ENTRY : B = MSYSU DATAFIELD
134271   %             A = WORD
134271   %             X = ADDRESS OF WORD
134271   %
134271   % USES A
134271   %
134271   SUBR R1USR, R2USR, W1USR
134271   INTEGER POINTER HOME
134272
134272   R1USR: A:=L=:"HOME"
134274          CALL ALTON                           % USER ADDRESS SPACE IN PIT 2
134275          *LDA ,X                              % GET WORD
134276          CALL ALTOF                           % BACK TO NORMAL
134277          GO HOME
134300
134300
134300   R2USR: A:=L=:"HOME"
134302          CALL ALTON                           % USER ADDRESS SPACE IN PIT 2
134303          *LDD ,X                              % GET WORDS
134304          CALL ALTOF                           % BACK TO NORMAL
134305          GO HOME
134306
134306
134306   W1USR: A:=:L=:"HOME":=L
134311          CALL ALTON                           % USER ADDRESS SPACE IN PIT 2
134312          *STA ,X                              % PUT WORD
134313          CALL ALTOF                           % BACK TO NORMAL
134314          GO HOME
134315
134315   RBUS
134317
134317
134317   %====================================================================
134317   %      R C T A G    R H T A G    W C T A G    W H T A G
134317   %
134317   % RCTAG :  READ A CLUSTER TAG VALUE
134317   %
134317   %     ENTRY : X = POINTER TO START OF DMT ENTRY (CLUSTER)
134317   %             A = TAG NUMBER
134317   %
134317   %     EXIT  : A = ERROR CODE
134317   %     EXIT+1: A = CORRESPONDING VALUE
134317   %
134317   %
134317   % RHTAG :  READ A HEADER TAG VALUE
134317   %
134317   %     ENTRY : A = TAG NUMBER
134317   %
134317   %     EXIT  : A = ERROR CODE
134317   %     EXIT+1: A = CORRESPONDING VALUE
134317   %
134317   %
134317   % WCTAG : WRITE A CLUSTER TAG VALUE
134317   %
134317   %     ENTRY : X = POINTER TO START OF DMT ENTRY (CLUSTER)
134317   %             A = TAG NUMBER
134317   %             D = VALUE
134317   %
134317   %     EXIT  : A = ERROR CODE
134317   %     EXIT+1: OK, K CONTAINS WRITE IMAGE FLAG
134317   %
134317   %
134317   % WHTAG : WRITE A HEADER TAG VALUE
134317   %
134317   %     ENTRY : A = TAG NUMBER
134317   %             D = VALUE
134317   %
134317   %     EXIT  : A = ERROR CODE
134317   %     EXIT+1: K CONTAINS WRITE IMAGE FLAG
134317   %             X = ADDRESS OF UPDATED WORD
134317   %
134317   SUBR RCTAG, RHTAG, WCTAG, WHTAG
134317
134317
134317   % -------- HEADER TAGS ----------------------------------------------------
134317   % DEFINE MACRO TO GENERATE A HEADER TAG DEFINITION ENTRY
134317   % )MCDEF DHTAG $ROF, $WIM, $TAG, $WA, $BO, $BL    %
134317   % $ROF @1+$WIM @16+$TAG  % READ ONLY (1), WRITE IMAGE (1), TAG NUMBER (12)
134317   % $WA                    % WORD ADDRESS
134317   % $BO @4+$BL             % BIT NUMBER (4), BIT LENGTH (4)
134317   @MAC
134317
134317   % LOCAL ROUTINE TO LOOK UP A HEADER TAG IN THE DESCRIPTOR TABLE
134317   INTEGER ARRAY HDTBL=?
134317
134317   LHTAG: FOR X:=0 STEP 3 TO "HDLEN" DO
134323             IF HDTBL(X)=:T/\7777=D THEN
134330                IF T<0 AND K THEN NWTAG; EXIT FI
134336                *BLDA 160 DT                   % COPY WRITE IMAGE FLAG
134337                X+1; HDTBL(X)=:D
134342                X+1; X:=HDTBL(X)               % ADDRESS IN X
134344                EXITA                          % SKIP RETURN
134345             FI
134345          OD
134347          UKTAG; EXIT
134351   *)FILL
134356
134356   % HEADER TAGS:
134356   INTEGER ARRAY HDTBL(0)
134356   *DHTAG 1,0,00001,DHNCL,10,10           % DM HEADER: NUMBER OF DMT ENTRIES
134360
134361   *DHTAG 1,0,00002,DHNCL,00,10           % DM HEADER: NUMBER OF NO UPDATE AREAS
134363
134364   *DHTAG 1,0,00003,DHVER,10,10           % DM HEADER: VERSION LETTER
134366
134367   *DHTAG 1,0,00004,DHVER,00,10           % DM HEADER: REVISION NUMBER
134371
134372   *DHTAG 0,1,00010,RVSEM,00,00           % DM HEADER: REVIVE SEMAPHORE
134374
134375   *DHTAG 0,1,00020,DVBFP,00,00           % DM HEADER: DEVICE BUFFER FIRST PAGE
134377
134400   *DHTAG 0,1,00077,DWDOK,00,00           % DM HEADER: RT-ADDRESS OF DIMWD
134402
134403   *HDLEN=*-HDTBL-1
134403
134403
134403   % --------------- CLUSTER TAGS -----------------------
134403
134403   % DEFINE MACRO TO GENERATE A CLUSTER TAG DEFINITION ENTRY
134403   % )MCDEF DCTAG $ROF, $WIM, $TAG, $WA, $BO, $BL    %
134403   % $ROF @1+$WIM @16+$TAG  % READ ONLY (1), WRITE IMAGE (1), TAG NUMBER (12)
134403   % $WA @4+$BO @4+$BL      % WORD ADDRESS (10), BIT NUMBER (4), BIT LENGTH (4)
134403   @MAC
134403
134403   % LOCAL ROUTINE TO LOOK UP A CLUSTER TAG IN THE DESCRIPTOR TABLE
134403   INTEGER ARRAY CTTBL=?
134403
134403   LCTAG: FOR X:=0 STEP 2 TO "CDLEN" DO
134407             IF CTTBL(X)=:T/\7777=D THEN
134414                IF T<0 AND K THEN NWTAG; EXIT FI
134422                *BLDA 160 DT                   % COPY WRITE IMAGE FLAG
134423                X+1; CTTBL(X)=:D SHZ -10=:X    % OFFSET IN X
134430                X+B; EXITA                     % SKIP RETURN
134432             FI
134432          OD
134434          UKTAG; EXIT
134436   *)FILL
134443
134443   INTEGER ARRAY CTTBL(0)
134443   *DCTAG 0,1,00100,PRDEV,04,14           % PRIMARY DEVICE NUMBER
134444
134445   *DCTAG 0,1,00101,PRDEV,00,04           %         UNIT NUMBER
134446
134447   *DCTAG 0,1,00102,PRFLG,00,04           %         BASE 2 LOGARITM OF SECTOR SIZE
134450
134451   *DCTAG 0,1,00103,PRFLG,15,01           %         DISCONNECTED FLAG
134452
134453   *DCTAG 0,1,00104,PRFLG,14,01           %         INHIBIT FLAG
134454
134455   *DCTAG 0,1,00105,PRFLG,13,01           %         REVIVE WRITE FLAG
134456
134457   *DCTAG 0,1,00106,PRVAL,00,00           %         VALID FLAG
134460
134461   *DCTAG 0,1,00107,PRFLG,11,01           %         PART OF DISK FLAG
134462
134463   *DCTAG 0,1,00110,PRFLG,10,01           %         CHANGED FLAG
134464
134465   *DCTAG 0,1,00120,PREX1,00,00           %         EXTENT START MSW
134466
134467   *DCTAG 0,1,00121,PREX2,00,00           %                      LSW
134470
134471   *DCTAG 0,1,00122,PREX3,00,00           %                STOP  MSW
134472
134473   *DCTAG 0,1,00123,PREX4,00,00           %                      LSW
134474
134475   *DCTAG 0,1,00200,S1DEV,04,14           % SECONDARY 1 DEVICE NUMBER
134476
134477   *DCTAG 0,1,00201,S1DEV,00,04           %         UNIT NUMBER
134500
134501   *DCTAG 0,1,00202,S1FLG,00,04           %         BASE 2 LOGARITM OF SECTOR SIZE
134502
134503   *DCTAG 0,1,00203,S1FLG,15,01           %         DISCONNECTED FLAG
134504
134505   *DCTAG 0,1,00204,S1FLG,14,01           %         INHIBIT FLAG
134506
134507   *DCTAG 0,1,00205,S1FLG,13,01           %         REVIVE WRITE FLAG
134510
134511   *DCTAG 0,1,00206,S1VAL,00,00           %         VALID FLAG
134512
134513   *DCTAG 0,1,00207,S1FLG,11,01           %         PART OF DISK FLAG
134514
134515   *DCTAG 0,1,00210,S1FLG,10,01           %         CHANGED FLAG
134516
134517   *DCTAG 0,1,00220,S1EX1,00,00           %         EXTENT START MSW
134520
134521   *DCTAG 0,1,00221,S1EX2,00,00           %                      LSW
134522
134523   *DCTAG 0,1,00222,S1EX3,00,00           %                STOP  MSW
134524
134525   *DCTAG 0,1,00223,S1EX4,00,00           %                      LSW
134526
134527   *DCTAG 0,1,00251,S1NUA,01,01           % NO UPDATE AREA 1 ENABLE FLAG
134530
134531   *DCTAG 0,1,00252,S1NUA,02,01           % NO UPDATE AREA 2 ENABLE FLAG
134532
134533   *DCTAG 0,1,00300,S2DEV,04,14           % SECONDARY 2 DEVICE NUMBER
134534
134535   *DCTAG 0,1,00301,S2DEV,00,04           %         UNIT NUMBER
134536
134537   *DCTAG 0,1,00302,S2FLG,00,04           %         BASE 2 LOGARITM OF SECTOR SIZE
134540
134541   *DCTAG 0,1,00303,S2FLG,15,01           %         DISCONNECTED FLAG
134542
134543   *DCTAG 0,1,00304,S2FLG,14,01           %         INHIBIT FLAG
134544
134545   *DCTAG 0,1,00305,S2FLG,13,01           %         REVIVE WRITE FLAG
134546
134547   *DCTAG 0,1,00306,S2VAL,00,00           %         VALID FLAG
134550
134551   *DCTAG 0,1,00307,S2FLG,11,01           %         PART OF DISK FLAG
134552
134553   *DCTAG 0,1,00310,S2FLG,10,01           %         CHANGED FLAG
134554
134555   *DCTAG 0,1,00320,S2EX1,00,00           %         EXTENT START MSW
134556
134557   *DCTAG 0,1,00321,S2EX2,00,00           %                      LSW
134560
134561   *DCTAG 0,1,00322,S2EX3,00,00           %                STOP  MSW
134562
134563   *DCTAG 0,1,00323,S2EX4,00,00           %                      LSW
134564
134565   *DCTAG 0,1,00351,S2NUA,01,01           % NO UPDATE AREA 1 ENABLE FLAG
134566
134567   *DCTAG 0,1,00352,S2NUA,02,01           % NO UPDATE AREA 2 ENABLE FLAG
134570
134571   *DCTAG 0,1,01000,DMFLG,17,01           % CLUSTER ENTRY IN USE
134572
134573   *DCTAG 0,1,01001,DMFLG,16,01           % MIRRORING ENABLED FOR THIS CLUSTER
134574
134575   *DCTAG 0,1,01002,DMFLG,15,01           % READ DISTRIBUTION ALLOWED FLAG
134576
134577   *DCTAG 0,0,01003,DMWFL,00,02           % REVIVE READ MEMBER INDEX
134600
134601   *DCTAG 0,0,01004,DMWFL,11,07           % REVIVE PROGRESS
134602
134603   *DCTAG 0,1,01005,DMRBS,00,00           % REVIVE BUFFER SIZE
134604
134605   *DCTAG 0,1,01006,DMFLG,11,01           % MEMBER INFORMATION ON DISK POSSIBLE
134606
134607   *DCTAG 1,0,01010,DMFLG,14,01           % NO VALID MEMBER IN CLUSTER
134610
134611   *DCTAG 0,1,01011,DMFLG,00,02           % LAST VALID MEMBER
134612
134613   *DCTAG 0,1,01012,DMFLG,13,01           % NO VALID MEMBER CONTINUE FLAG
134614
134615   *DCTAG 0,1,01020,DRDB1,00,00           % READ DISTRIBUTION BOUNDARY MOST SIG WORD
134616
134617   *DCTAG 0,1,01021,DRDB2,00,00           % READ DISTRIBUTION BOUNDARY LEAST SIG WORD
134620
134621   *DCTAG 0,1,01110,DMNUA+0,00,00         % NO UPDATEA AREA 1 START ADDR MOST SIG WORD
134622
134623   *DCTAG 0,1,01111,DMNUA+1,00,00         % NO UPDATEA AREA 1 START ADDR LEAST SIG WORD
134624
134625   *DCTAG 0,1,01112,DMNUA+2,00,00         % NO UPDATEA AREA 1 STOP ADDR MOST SIG WORD
134626
134627   *DCTAG 0,1,01113,DMNUA+3,00,00         % NO UPDATEA AREA 1 STOP ADDR LEAST SIG WORD
134630
134631   *DCTAG 0,1,01120,DMNUA+4,00,00         % NO UPDATEA AREA 2 START ADDR MOST SIG WORD
134632
134633   *DCTAG 0,1,01121,DMNUA+5,00,00         % NO UPDATEA AREA 2 START ADDR LEAST SIG WORD
134634
134635   *DCTAG 0,1,01122,DMNUA+6,00,00         % NO UPDATEA AREA 2 STOP ADDR MOST SIG WORD
134636
134637   *DCTAG 0,1,01123,DMNUA+7,00,00         % NO UPDATEA AREA 2 STOP ADDR LEAST SIG WORD
134640
134641   *CDLEN=*-CTTBL-1
134641
134641
134641   INTEGER POINTER HOME, LUTAG
134643   INTEGER SHTZ(0); *SHT ZIN
134644   INTEGER SAVB
134645
134645   RHTAG: X:=B=:SAVB:="LHTAG"; 0=:B; GO R1TAG
134652   RCTAG: X:=:B=:SAVB:="LCTAG"
134655
134655   R1TAG: X=:"LUTAG"; A=:D:=L=:"HOME"; *1BANK
134662          K:="0"; CALL LUTAG; GO ERR; *2BANK
134666          IF 17/\D><0 THEN
134671             A\/SHTZ; T:=1; *EXR SA; AAT -1    % MASK IN T
134675             D SHZ -4; 17 /\D - /\77 \/SHTZ=:D % SHIFT INSTRUCTION IN D
134704             X.S0:=:T; *EXR SD                 % SHIFT RIGHT
134707             A/\T
134710          ELSE
134711             X.S0                              % WHOLE WORD
134712          FI
134712          GO FIN
134713
134713   INTEGER VALUE
134714
134714   WHTAG: X:=B=:SAVB:="LHTAG"; 0=:B; *IOF
134721          GO W1TAG
134722   WCTAG: X:=:B=:SAVB:="LCTAG"
134725
134725   W1TAG: A:=:D=:VALUE:=L=:"HOME"
134731          X=:"LUTAG"; *1BANK
134733          K:="1"; CALL LUTAG; GO ERR; *2BANK
134737          IF 17/\D><0 THEN
134742             A\/SHTZ; T:=1; *EXR SA; AAT -1    % MASK IN T
134746             VALUE/\T=:VALUE                   % MASK NEW VALUE
134751             A:=D SHZ -4 /\17 \/SHTZ=:D        % SHIFT INSTRUCTION IN D
134756             *EXR SD                           % SHIFT MASK
134757             A:=T-,/\X.S0                      % ZERO OLD VALUE
134762             T:=VALUE; *EXR SD                 % SHIFT VALUE
134764             A\/T                              % NEW WORD
134765          ELSE
134766             VALUE                             % WHOLE WORD
134767          FI
134767          A=:X.S0                              % STORE WORD
134770
134770   FIN:   MIN "HOME"                           % PREPARE SKIP RETURN
134771   ERR:   *2BANK; ION
134773          T:=SAVB=:B; GO HOME
134776   RBUS
135002
135002
135002   %====================================================================
135002   %          W I M A G
135002   %
135002   % WIMAG : COPIES AN AREA TO SINTRAN IMAGE DATA SEGMENT
135002   %
135002   %     ENTRY : A = SOURCE ADDRESS
135002   %             T = DESTINATION ADDRESS
135002   %             X = NUMBER OF WORDS TO COPY
135002   %
135002   %     EXIT  :
135002   %
135002   %     USES T,A,D,X
135002   %
135002   SUBR WIMAG
135002   INTEGER POINTER HOME
135003   TRIPLE TADREG
135006   INTEGER SAVS1,SAVS2,SAVRS
135011
135011   WIMAG: X=:D:=L=:"HOME"; TAD=:TADREG
135015          RTREF.RSEGM=:SAVRS; 0=:X.RSEGM       % SAVE AND CLEAR REENTRANT SEGMENT
135021          RTREF; CALL LAMINHIBIT               % DISABLE LAMU
135023          T:=5IMDAT; CALL M1MEX; T=:SAVS1      % CHANGE SEGMENT 1 AND SAVE OLD
135026          T:=0; CALL M2MEX; T=:SAVS2           % CHANGE SEGMENT 2 AND SAVE OLD
135031          TADREG; D=:X:=A                      % MOVUS PARAMETERS
135034          K:=1; AUPIN; CALL MOVUS              % COPY TO IMAGE
135037          T:=SAVS1; CALL M1MEX                 % RESTORE SEGMENT 1
135041          T:=SAVS2; CALL M2MEX                 % RESTORE SEGMENT 2
135043          SAVRS=:RTREF.RSEGM                   % RESTORE REENTRANT SEGMENT
135046          RTREF; CALL LAMENABLE                % ENABLE LAMU
135050          "DM164"; *MON 164                    % WRITE SEGMENT: MON WSEG
135052          GO HOME
135053   RBUS
135063   *"
"135063   @DEV 1
135063   @EOF
135063
% RP-P2-DIGIO:MAC
135063  "
135063  )LINE
%

135063  %============================================================================
135063  %            C X - T I M E R - T A B L E
135063  %==============================================================================
135063  % TIMER TABLE
135063  % 42.12      T M R T A
135063  %
135063  TMRTA=*
135063  "8BD1; BIGDI
135064  "8BD2; BIGD2
135065  "8SCS1; SCSI1
135066  "8SCS2; SCSI2
135067  "8SCS3; SCSI3
135070  "8WD1+8MD1; WIGDI
135071  "8BDIO; DOM01; DOM02; DOM03; DOM04; DOM05; DOM06; DOM07; DOM10
135101          DOM11; DOM12; DOM13; DOM14; DOM15; DOM16; DOM17; DOM20
135111  "
135111         EBUTD      % ERROR-MESSAGE TO EPSON CONNECTED TO A TANDBERG VDU
135112  M1TMR, -1
135113  "8PUN1
135113         DPNCH
135114  "8LP1
135114         DLPR
135115  "8LP2
135115         DLPR2
135116  "8DLP1+8DVE1;DMLP1
135117  "8DLP2+8DVE2;DMLP2
135120  "8BFD1;FDID1
135121  "8BFD2;FDID2
135122  "8NLP1;DMPR1
135123  "8NLP2;DMPR2
135124  "8SMO1
135124         IDMO1;UDMO1
135126  "8SMO2
135126         IDMO2;UDMO2
135130  "8HMO1
135130         IDHM1;UDHM1
135132  "8HMO2
135132         IDHM2;UDHM2
135134  "8HMO3
135134         IDHM3;UDHM3
135136  "8HMO4
135136         IDHM4;UDHM4
135140  "8HMO5
135140         IDHM5;UDHM5
135142  "8HMO6
135142         IDHM6;UDHM6
135144  "8HDM1;HDMI1;HDMO1
135146  "8C1HD;HDOF1
135147  "8C2HD;HDOF2
135150  "8C3HD;HDOF3
135151  "8C4HD;HDOF4
135152  "8C5HD;HDOF5
135153  "8C6HD;HDOF6
135154  "8C1X2;X21F1
135155  "8C2X2;X21F2
135156  "8PC01;PIO01
135157  "8PC02;PIO02
135160  "8PC03;PIO03
135161  "8PC04;PIO04
135162  "8ETR1;ETRN1
135163  "8ETR2;ETRN2
135164  "8ETR3;ETRN3
135165  "99TM1; TMMT1
135166  "99SM1; STMT1
135167  "99TM2; TMMT2
135170  "99SM2; STMT2
135171  "
135171  "8DMVC; VEFIE
135172  "8DMV2; VE2FI
135173  "8CP51; 5CPU1
135174  "8CP52; 5CPU2
135175  "8CP53; 5CPU3
135176  "8CP54; 5CPU4
135177  "8M1U0 99SM1; MTDI1
135200  "8M1U1 99SM1; MTDI2
135201  "8M1U2 99SM1; MTDI3
135202  "8M1U3 99SM1; MTDI4
135203  "8M2U0 99SM2; M2DI1
135204  "8M2U1 99SM2; M2DI2
135205  "8M2U2 99SM2; M2DI3
135206  "8M2U3 99SM2; M2DI4
135207  "8MOLI; MLIDF
135210  "8UD01+8VI01; UDI01;
135211  "8UD02+8VI02; UDI02;
135212  "8GPI0;DTGP0
135213  "8SIBA+8SIBX+8SIBM+8SIBN; DSI0; DSI1; DSI2
135216  "8SIBX+8SIBM+8SIBN;       DSI3; DSI4; DSI5
135221  "8SIBM+8SIBN; DSI5; DSI6; DSI7; DSI8; DSI9; DSI10; DSI11
135230  "
135230  "8NIU0; MNDF0
135231  "8NIU1; MNDF1
135232  "8NIU2; MNDF2
135233  "
135233  8USTM=*                      % START OF USER-AREA OF TIMER TABLE
135233
135233  *+XTIME/                     % EXTRA ENTRIES, DEFAULT=6
135241         -1
135242  9SXTD=*                      % START OF TERMINALS
135242         DT01R;DT01W
135244  TMRTE, -1
135245  "8TR5 -9SMO1
135245         DT05R;DT05W
135247  "8TR6
135247         DT06R;DT06W
135251  "8TR7
135251         DT07R;DT07W
135253  "8TR8
135253         DT08R;DT08W
135255  "8TR9 -9SMO2
135255         DT09R;DT09W
135257  "8TR10
135257         DT10R;DT10W
135261  "8TR11
135261         DT11R;DT11W
135263  "8TR12
135263         DT12R;DT12W
135265  "8TR13 -9SMO3
135265         DT13R;DT13W
135267  "8TR14
135267         DT14R;DT14W
135271  "8TR15
135271         DT15R;DT15W
135273  "8TR16
135273         DT16R;DT16W
135275  "8TR17 -9SMO4;DT17R;DT17W
135277  "8TR18;DT18R;DT18W
135301  "8TR19;DT19R;DT19W
135303  "8TR20;DT20R;DT20W
135305  "8TR21 -9SMO5;DT21R;DT21W
135307  "8TR22;DT22R;DT22W
135311  "8TR23;DT23R;DT23W
135313  "8TR24;DT24R;DT24W
135315  "8TR25 -8SMO9;DT25R;DT25W
135317  "8TR26;DT26R;DT26W
135321  "8TR27;DT27R;DT27W
135323  "8TR28;DT28R;DT28W
135325  "8TR29 -9SMO6;DT29R;DT29W
135327  "8TR30 -9SMO7;DT30R;DT30W
135331  "8TR31;DT31R;DT31W
135333  "8TR32;DT32R;DT32W
135335  "8TR33;DT33R;DT33W
135337  "8TR34;DT34R;DT34W
135341  "8TR35 -8SMO7;DT35R;DT35W
135343  "8TR36 -8SMO8;DT36R;DT36W
135345  "8TR37 -8SMO9;DT37R;DT37W
135347  "8TR38 -9SMO1;DT38R;DT38W
135351  "8TR39 -9SMO2;DT39R;DT39W
135353  "8TR40 -9SMO3;DT40R;DT40W
135355  "8TR41 -9SMO4;DT41R;DT41W
135357  "8TR42 -9SMO5;DT42R;DT42W
135361  "8TR43 -9SMO6;DT43R;DT43W
135363  "8TR44 -9SMO7;DT44R;DT44W
135365  "8TR45;DT45R;DT45W
135367  "8TR46;DT46R;DT46W
135371  "8TR47;DT47R;DT47W
135373  "8TR48;DT48R;DT48W
135375  "8TR49;DT49R;DT49W
135377  "8TR50;DT50R;DT50W
135401  "8TR51;DT51R;DT51W
135403  "8TR52;DT52R;DT52W
135405  "8TR65;DT65R;DT65W
135407  "8TR66;DT66R;DT66W
135411  "8TR67;DT67R;DT67W
135413  "8TR68;DT68R;DT68W
135415  "8TR69;DT69R;DT69W
135417  "8TR70;DT70R;DT70W
135421  "8TR71;DT71R;DT71W
135423  "8TR72;DT72R;DT72W
135425  "8TR73;DT73R;DT73W
135427  "8TR74;DT74R;DT74W
135431  "8TR75;DT75R;DT75W
135433  "8TR76;DT76R;DT76W
135435  "8TR77;DT77R;DT77W
135437  "8TR78;DT78R;DT78W
135441  "8TR79;DT79R;DT79W
135443  "8TR80;DT80R;DT80W
135445  "8TR81;DT81R;DT81W
135447  "8TR82;DT82R;DT82W
135451  "8TR83;DT83R;DT83W
135453  "8TR84;DT84R;DT84W
135455  "8TR85;DT85R;DT85W
135457  "8TR86;DT86R;DT86W
135461  "8TR87;DT87R;DT87W
135463  "8TR88;DT88R;DT88W
135465  "8TR89;DT89R;DT89W
135467  "8TR90;DT90R;DT90W
135471  "8TR91;DT91R;DT91W
135473  "8TR92;DT92R;DT92W
135475  "8TR93;DT93R;DT93W
135477  "8TR94;DT94R;DT94W
135501  "8TR95;DT95R;DT95W
135503  "8TR96;DT96R;DT96W
135505  "8TR97;DT97R;DT97W
135507  "8TR98;DT98R;DT98W
135511  "8TR99;DT99R;DT99W
135513  "9TR00;T100R;T100W
135515  "9TR01;T101R;T101W
135517  "9TR02;T102R;T102W
135521  "9TR03;T103R;T103W
135523  "9TR04;T104R;T104W
135525  "9TR05;T105R;T105W
135527  "9TR06;T106R;T106W
135531  "9TR07;T107R;T107W
135533  "9TR08;T108R;T108W
135535  "9TR09;T109R;T109W
135537  "9TR10;T110R;T110W
135541  "9TR11;T111R;T111W
135543  "9TR12;T112R;T112W
135545  "9TR13;T113R;T113W
135547  "9TR14;T114R;T114W
135551  "9TR15;T115R;T115W
135553  "9TR16;T116R;T116W
135555  "9TR17;T117R;T117W
135557  "9TR18;T118R;T118W
135561  "9TR19;T119R;T119W
135563  "9TR20;T120R;T120W
135565  "9TR21;T121R;T121W
135567  "9TR22;T122R;T122W
135571  "9TR23;T123R;T123W
135573  "9TR24;T124R;T124W
135575  "9TR25;T125R;T125W
135577  "9TR26;T126R;T126W
135601  "9TR27;T127R;T127W
135603  "9TR28;T128R;T128W
135605  "9TR29;T129R;T129W
135607  "9TR30;T130R;T130W
135611  "9TR31;T131R;T131W
135613  "9TR32;T132R;T132W
135615  "9TR33;T133R;T133W
135617  "9TR34;T134R;T134W
135621  "9TR35;T135R;T135W
135623  "9TR36;T136R;T136W
135625  "9TR37;T137R;T137W
135627  "9TR38;T138R;T138W
135631  "9TR39;T139R;T139W
135633  "9TR40;T140R;T140W
135635  "
135635  9EXTD=*                      % END OF TERMINALS
135635
135635  "TEFX1;TB01R;TB01W
135637         TR01R;TR01W
135641  "BAD01;BD01R;BD01W
135643  "BAD02;BD02R;BD02W
135645  "BAD03;BD03R;BD03W
135647  "BAD04;BD04R;BD04W
135651  "BAD05;BD05R;BD05W
135653  "BAD06;BD06R;BD06W
135655  "BAD07;BD07R;BD07W
135657  "BAD08;BD08R;BD08W
135661  "BAD09;BD09R;BD09W
135663  "BAD10;BD10R;BD10W
135665  "BAD11;BD11R;BD11W
135667  "BAD12;BD12R;BD12W
135671  "BAD13;BD13R;BD13W
135673  "BAD14;BD14R;BD14W
135675  "BAD15;BD15R;BD15W
135677  "BAD16;BD16R;BD16W
135701  "BAD17;BD17R;BD17W
135703  "BAD18;BD18R;BD18W
135705  "BAD19;BD19R;BD19W
135707  "BAD20;BD20R;BD20W
135711  "BAD21;BD21R;BD21W
135713  "BAD22;BD22R;BD22W
135715  "BAD23;BD23R;BD23W
135717  "BAD24;BD24R;BD24W
135721  "BAD25;BD25R;BD25W
135723  "BAD26;BD26R;BD26W
135725  "BAD27;BD27R;BD27W
135727  "BAD28;BD28R;BD28W
135731  "BAD29;BD29R;BD29W
135733  "BAD30;BD30R;BD30W
135735  "BAD31;BD31R;BD31W
135737  "BAD32;BD32R;BD32W
135741  "BAD33;BD33R;BD33W
135743  "BAD34;BD34R;BD34W
135745  "BAD35;BD35R;BD35W
135747  "BAD36;BD36R;BD36W
135751  "BAD37;BD37R;BD37W
135753  "BAD38;BD38R;BD38W
135755  "BAD39;BD39R;BD39W
135757  "BAD40;BD40R;BD40W
135761  "BAD41;BD41R;BD41W
135763  "BAD42;BD42R;BD42W
135765  "BAD43;BD43R;BD43W
135767  "BAD44;BD44R;BD44W
135771  "BAD45;BD45R;BD45W
135773  "BAD46;BD46R;BD46W
135775  "BAD47;BD47R;BD47W
135777  "BAD48;BD48R;BD48W
136001  "BAD49;BD49R;BD49W
136003  "BAD50;BD50R;BD50W
136005  "BAD51;BD51R;BD51W
136007  "BAD52;BD52R;BD52W
136011  "BAD53;BD53R;BD53W
136013  "BAD54;BD54R;BD54W
136015  "BAD55;BD55R;BD55W
136017  "BAD56;BD56R;BD56W
136021  "BAD57;BD57R;BD57W
136023  "BAD58;BD58R;BD58W
136025  "BAD59;BD59R;BD59W
136027  "BAD60;BD60R;BD60W
136031  "BAD61;BD61R;BD61W
136033  "BAD62;BD62R;BD62W
136035  "BAD63;BD63R;BD63W
136037  "BAD64;BD64R;BD64W
136041  "BAD65;BD65R;BD65W
136043  "BAD66;BD66R;BD66W
136045  "BAD67;BD67R;BD67W
136047  "BAD68;BD68R;BD68W
136051  "BAD69;BD69R;BD69W
136053  "BAD70;BD70R;BD70W
136055  ";IOCT0
136056  "8NUCL;NUODF
136057  "
136057  TLAMD                     % DELETE TEMP. LAMUS FROM ABORTED PROG
136060  ETMRT, -1                           % END OF TIMER TABLE
136061
136061  )LINE
%=============================================================================
136061  %            S B P R T A B
136061  %
136061  % ONE ENTRY FOR EACH BACKGROUND PROGRAM WHICH HAS NO FIXED TERMINAL/TAD
136061  % CONNECTION.
136061  %
136061  )MCDEF 9BPEX $BPNN
       $BPNN ;0;61
]
136061
136061
136061  SBPRT=*
136061  "8BACS
136061         BAK01;DT01R;62
136064  "8BP2 8BACS; 9BPEX BAK02

136064         BAK02;0;61
136067
136067  "8BP3 8BACS; 9BPEX BAK03

136067         BAK03 ;0;61
136072
136072  "8BP4 8BACS; 9BPEX BAK04

136072         BAK04 ;0;61
136075
136075  "8BP5 8BACS; 9BPEX BAK05

136075         BAK05 ;0;61
136100
136100  "8BP6 8BACS; 9BPEX BAK06

136100         BAK06;0;61
136103
136103  "8BP7 8BACS; 9BPEX BAK07

136103         BAK07;0;61
136106
136106  "8BP8 8BACS; 9BPEX BAK08

136106         BAK08;0;61
136111
136111  "8BP9 8BACS; 9BPEX BAK09

136111         BAK09;0;61
136114
136114  "8BP10 8BACS; 9BPEX BAK10

136114         BAK10;0;61
136117
136117  "8BP11 8BACS; 9BPEX BAK11

136117         BAK11;0;61
136122
136122  "8BP12 8BACS; 9BPEX BAK12

136122         BAK12;0;61
136125
136125  "8BP13 8BACS; 9BPEX BAK13

136125         BAK13;0;61
136130
136130  "8BP14 8BACS; 9BPEX BAK14

136130         BAK14;0;61
136133
136133  "8BP15 8BACS; 9BPEX BAK15

136133         BAK15;0;61
136136
136136  "8BP16 8BACS; 9BPEX BAK16

136136         BAK16;0;61
136141
136141  "8BP17 8BACS; 9BPEX BAK17

136141         BAK17;0;61
136144
136144  "8BP18 8BACS; 9BPEX BAK18

136144         BAK18;0;61
136147
136147  "8BP19 8BACS; 9BPEX BAK19

136147         BAK19;0;61
136152
136152  "8BP20 8BACS; 9BPEX BAK20

136152         BAK20;0;61
136155
136155  "8BP21 8BACS; 9BPEX BAK21

136155         BAK21;0;61
136160
136160  "8BP22 8BACS; 9BPEX BAK22

136160         BAK22;0;61
136163
136163  "8BP23 8BACS; 9BPEX BAK23

136163         BAK23;0;61
136166
136166  "8BP24 8BACS; 9BPEX BAK24

136166         BAK24;0;61
136171
136171  "8BP25 8BACS; 9BPEX BAK25

136171         BAK25;0;61
136174
136174  "8BP26 8BACS; 9BPEX BAK26

136174         BAK26;0;61
136177
136177  "8BP27 8BACS; 9BPEX BAK27

136177         BAK27;0;61
136202
136202  "8BP28 8BACS; 9BPEX BAK28

136202         BAK28;0;61
136205
136205  "8BP29 8BACS; 9BPEX BAK29

136205         BAK29;0;61
136210
136210  "8BP30 8BACS; 9BPEX BAK30

136210         BAK30;0;61
136213
136213  "8BP31 8BACS; 9BPEX BAK31

136213         BAK31;0;61
136216
136216  "8BP32 8BACS; 9BPEX BAK32

136216         BAK32;0;61
136221
136221  "8BP33 8BACS; 9BPEX BAK33

136221         BAK33;0;61
136224
136224  "8BP34 8BACS; 9BPEX BAK34

136224         BAK34;0;61
136227
136227  "8BP35 8BACS; 9BPEX BAK35

136227         BAK35;0;61
136232
136232  "8BP36 8BACS; 9BPEX BAK36

136232         BAK36;0;61
136235
136235  "8BP37 8BACS; 9BPEX BAK37

136235         BAK37;0;61
136240
136240  "8BP38 8BACS; 9BPEX BAK38

136240         BAK38;0;61
136243
136243  "8BP39 8BACS; 9BPEX BAK39

136243         BAK39;0;61
136246
136246  "8BP40 8BACS; 9BPEX BAK40

136246         BAK40;0;61
136251
136251  "8BP41 8BACS; 9BPEX BAK41

136251         BAK41;0;61
136254
136254  "8BP42 8BACS; 9BPEX BAK42

136254         BAK42;0;61
136257
136257  "8BP43 8BACS; 9BPEX BAK43

136257         BAK43;0;61
136262
136262  "8BP44 8BACS; 9BPEX BAK44

136262         BAK44;0;61
136265
136265  "8BP45 8BACS; 9BPEX BAK45

136265         BAK45;0;61
136270
136270  "8BP46 8BACS; 9BPEX BAK46

136270         BAK46;0;61
136273
136273  "8BP47 8BACS; 9BPEX BAK47

136273         BAK47;0;61
136276
136276  "8BP48 8BACS; 9BPEX BAK48

136276         BAK48;0;61
136301
136301  "8BP49 8BACS; 9BPEX BAK49

136301         BAK49;0;61
136304
136304  "8BP50 8BACS; 9BPEX BAK50

136304         BAK50;0;61
136307
136307  "8BP51 8BACS; 9BPEX BAK51

136307         BAK51;0;61
136312
136312  "8BP52 8BACS; 9BPEX BAK52

136312         BAK52;0;61
136315
136315  "8BP53 8BACS; 9BPEX BAK53

136315         BAK53;0;61
136320
136320  "8BP54 8BACS; 9BPEX BAK54

136320         BAK54;0;61
136323
136323  "8BP55 8BACS; 9BPEX BAK55

136323         BAK55;0;61
136326
136326  "8BP56 8BACS; 9BPEX BAK56

136326         BAK56;0;61
136331
136331  "8BP57 8BACS; 9BPEX BAK57

136331         BAK57;0;61
136334
136334  "8BP58 8BACS; 9BPEX BAK58

136334         BAK58;0;61
136337
136337  "8BP59 8BACS; 9BPEX BAK59

136337         BAK59;0;61
136342
136342  "8BP60 8BACS; 9BPEX BAK60

136342         BAK60;0;61
136345
136345  "8BP61 8BACS; 9BPEX BAK61

136345         BAK61;0;61
136350
136350  "8BP62 8BACS; 9BPEX BAK62

136350         BAK62;0;61
136353
136353  "8BP63 8BACS; 9BPEX BAK63

136353         BAK63;0;61
136356
136356  "8BP64 8BACS; 9BPEX BAK64

136356         BAK64;0;61
136361
136361  "8BP65 8BACS; 9BPEX BAK65

136361         BAK65;0;61
136364
136364  "8BP66 8BACS; 9BPEX BAK66

136364         BAK66;0;61
136367
136367  "8BP67 8BACS; 9BPEX BAK67

136367         BAK67;0;61
136372
136372  "8BP68 8BACS; 9BPEX BAK68

136372         BAK68;0;61
136375
136375  "8BP69 8BACS; 9BPEX BAK69

136375         BAK69;0;61
136400
136400  "8BP70 8BACS; 9BPEX BAK70

136400         BAK70;0;61
136403
136403  "8BP71 8BACS; 9BPEX BAK71

136403         BAK71;0;61
136406
136406  "8BP72 8BACS; 9BPEX BAK72

136406         BAK72;0;61
136411
136411  "8BP73 8BACS; 9BPEX BAK73

136411         BAK73;0;61
136414
136414  "8BP74 8BACS; 9BPEX BAK74

136414         BAK74;0;61
136417
136417  "8BP75 8BACS; 9BPEX BAK75

136417         BAK75;0;61
136422
136422  "8BP76 8BACS; 9BPEX BAK76

136422         BAK76;0;61
136425
136425  "8BP77 8BACS; 9BPEX BAK77

136425         BAK77;0;61
136430
136430  "8BP78 8BACS; 9BPEX BAK78

136430         BAK78;0;61
136433
136433  "8BP79 8BACS; 9BPEX BAK79

136433         BAK79;0;61
136436
136436  "8BP80 8BACS; 9BPEX BAK80

136436         BAK80;0;61
136441
136441  "8BP81 8BACS; 9BPEX BAK81

136441         BAK81;0;61
136444
136444  "8BP82 8BACS; 9BPEX BAK82

136444         BAK82;0;61
136447
136447  "8BP83 8BACS; 9BPEX BAK83

136447         BAK83;0;61
136452
136452  "8BP84 8BACS; 9BPEX BAK84

136452         BAK84;0;61
136455
136455  "8BP85 8BACS; 9BPEX BAK85

136455         BAK85;0;61
136460
136460  "8BP86 8BACS; 9BPEX BAK86

136460         BAK86;0;61
136463
136463  "8BP87 8BACS; 9BPEX BAK87

136463         BAK87;0;61
136466
136466  "8BP88 8BACS; 9BPEX BAK88

136466         BAK88;0;61
136471
136471  "8BP89 8BACS; 9BPEX BAK89

136471         BAK89;0;61
136474
136474  "8BP90 8BACS; 9BPEX BAK90

136474         BAK90;0;61
136477
136477  "8BP91 8BACS; 9BPEX BAK91

136477         BAK91;0;61
136502
136502  "8BP92 8BACS; 9BPEX BAK92

136502         BAK92;0;61
136505
136505  "8BP93 8BACS; 9BPEX BAK93

136505         BAK93;0;61
136510
136510  "8BP94 8BACS; 9BPEX BAK94

136510         BAK94;0;61
136513
136513  "8BP95 8BACS; 9BPEX BAK95

136513         BAK95;0;61
136516
136516  "8BP96 8BACS; 9BPEX BAK96

136516         BAK96;0;61
136521
136521  "8BP97 8BACS; 9BPEX BAK97

136521         BAK97;0;61
136524
136524  "8BP98 8BACS; 9BPEX BAK98

136524         BAK98;0;61
136527
136527  "8BP99 8BACS; 9BPEX BAK99

136527         BAK99;0;61
136532
136532  "9BP00 8BACS; 9BPEX BK100

136532         BK100;0;61
136535
136535  "9BP01 8BACS; 9BPEX BK101

136535         BK101;0;61
136540
136540  "9BP02 8BACS; 9BPEX BK102

136540         BK102;0;61
136543
136543  "9BP03 8BACS; 9BPEX BK103

136543         BK103;0;61
136546
136546  "9BP04 8BACS; 9BPEX BK104

136546         BK104;0;61
136551
136551  "9BP05 8BACS; 9BPEX BK105

136551         BK105;0;61
136554
136554  "9BP06 8BACS; 9BPEX BK106

136554         BK106;0;61
136557
136557  "9BP07 8BACS; 9BPEX BK107

136557         BK107;0;61
136562
136562  "9BP08 8BACS; 9BPEX BK108

136562         BK108;0;61
136565
136565  "9BP09 8BACS; 9BPEX BK109

136565         BK109;0;61
136570
136570  "9BP10 8BACS; 9BPEX BK110

136570         BK110;0;61
136573
136573  "9BP11 8BACS; 9BPEX BK111

136573         BK111;0;61
136576
136576  "9BP12 8BACS; 9BPEX BK112

136576         BK112;0;61
136601
136601  "9BP13 8BACS; 9BPEX BK113

136601         BK113;0;61
136604
136604  "9BP14 8BACS; 9BPEX BK114

136604         BK114;0;61
136607
136607  "9BP15 8BACS; 9BPEX BK115

136607         BK115;0;61
136612
136612  "9BP16 8BACS; 9BPEX BK116

136612         BK116;0;61
136615
136615  "9BP17 8BACS; 9BPEX BK117

136615         BK117;0;61
136620
136620  "9BP18 8BACS; 9BPEX BK118

136620         BK118;0;61
136623
136623  "9BP19 8BACS; 9BPEX BK119

136623         BK119;0;61
136626
136626  "9BP20 8BACS; 9BPEX BK120

136626         BK120;0;61
136631
136631  "9BP21 8BACS; 9BPEX BK121

136631         BK121;0;61
136634
136634  "9BP22 8BACS; 9BPEX BK122

136634         BK122;0;61
136637
136637  "9BP23 8BACS; 9BPEX BK123

136637         BK123;0;61
136642
136642  "9BP24 8BACS; 9BPEX BK124

136642         BK124;0;61
136645
136645  "9BP25 8BACS; 9BPEX BK125

136645         BK125;0;61
136650
136650  "9BP26 8BACS; 9BPEX BK126

136650         BK126;0;61
136653
136653  "9BP27 8BACS; 9BPEX BK127

136653         BK127;0;61
136656
136656  "9BP28 8BACS; 9BPEX BK128

136656         BK128;0;61
136661
136661  "9BP29 8BACS; 9BPEX BK129

136661         BK129;0;61
136664
136664  "9BP30 8BACS; 9BPEX BK130

136664         BK130;0;61
136667
136667  "9BP31 8BACS; 9BPEX BK131

136667         BK131;0;61
136672
136672  "9BP32 8BACS; 9BPEX BK132

136672         BK132;0;61
136675
136675  "9BP33 8BACS; 9BPEX BK133

136675         BK133;0;61
136700
136700  "9BP34 8BACS; 9BPEX BK134

136700         BK134;0;61
136703
136703  "9BP35 8BACS; 9BPEX BK135

136703         BK135;0;61
136706
136706  "9BP36 8BACS; 9BPEX BK136

136706         BK136;0;61
136711
136711  "9BP37 8BACS; 9BPEX BK137

136711         BK137;0;61
136714
136714  "9BP38 8BACS; 9BPEX BK138

136714         BK138;0;61
136717
136717  "9BP39 8BACS; 9BPEX BK139

136717         BK139;0;61
136722
136722  "9BP40 8BACS; 9BPEX BK140

136722         BK140;0;61
136725
136725  "9BP41 8BACS; 9BPEX BK141

136725         BK141;0;61
136730
136730  "9BP42 8BACS; 9BPEX BK142

136730         BK142;0;61
136733
136733  "9BP43 8BACS; 9BPEX BK143

136733         BK143;0;61
136736
136736  "9BP44 8BACS; 9BPEX BK144

136736         BK144;0;61
136741
136741  "9BP45 8BACS; 9BPEX BK145

136741         BK145;0;61
136744
136744  "9BP46 8BACS; 9BPEX BK146

136744         BK146;0;61
136747
136747  "9BP47 8BACS; 9BPEX BK147

136747         BK147;0;61
136752
136752  "9BP48 8BACS; 9BPEX BK148

136752         BK148;0;61
136755
136755  "9BP49 8BACS; 9BPEX BK149

136755         BK149;0;61
136760
136760  "9BP50 8BACS; 9BPEX BK150

136760         BK150;0;61
136763
136763  "9BP51 8BACS; 9BPEX BK151

136763         BK151;0;61
136766
136766  "
136766  EBPRT=*
136766
136766  %===========================================================================
136766  %      P R V T T A B L E
136766  %
136766  % TABLE FOR SAVING VARIABLES FROM THE SYSTEM SEGMENT
136766  % USED BY BACKGROUND PROCESS ALLOCATION SYSTEM
136766  %
136766  PRVTT=*
136766  "8BACS
136766
136766  )MCDEF MPRVT $FLG
$FLG ;0;0;12;0;0;0
]
136766
136766         62;0;0;12;0;0;0
136775  "8TR5 -9SMO1 8BACS; MPRVT 61

136775  61;0;0;12;0;0;0
137004
137004  "8TR6 8BACS; MPRVT 61

137004  61 ;0;0;12;0;0;0
137013
137013  "8TR7 8BACS; MPRVT 61

137013  61 ;0;0;12;0;0;0
137022
137022  "8TR8 8BACS; MPRVT 61

137022  61 ;0;0;12;0;0;0
137031
137031  "8TR9 -9SMO2 8BACS; MPRVT 61

137031  61;0;0;12;0;0;0
137040
137040  "8TR10 8BACS; MPRVT 61

137040  61 ;0;0;12;0;0;0
137047
137047  "8TR11 8BACS; MPRVT 61

137047  61 ;0;0;12;0;0;0
137056
137056  "8TR12 8BACS; MPRVT 61

137056  61 ;0;0;12;0;0;0
137065
137065  "8TR13 -9SMO3 8BACS; MPRVT 61

137065  61;0;0;12;0;0;0
137074
137074  "8TR14 8BACS; MPRVT 61

137074  61 ;0;0;12;0;0;0
137103
137103  "8TR15 8BACS; MPRVT 61

137103  61 ;0;0;12;0;0;0
137112
137112  "8TR16 8BACS; MPRVT 61

137112  61 ;0;0;12;0;0;0
137121
137121  "8TR17 -9SMO4 8BACS; MPRVT 61

137121  61;0;0;12;0;0;0
137130
137130  "8TR18 8BACS; MPRVT 61

137130  61 ;0;0;12;0;0;0
137137
137137  "8TR19 8BACS; MPRVT 61

137137  61 ;0;0;12;0;0;0
137146
137146  "8TR20 8BACS; MPRVT 61

137146  61 ;0;0;12;0;0;0
137155
137155  "8TR21 -9SMO5 8BACS; MPRVT 61

137155  61;0;0;12;0;0;0
137164
137164  "8TR22 8BACS; MPRVT 61

137164  61 ;0;0;12;0;0;0
137173
137173  "8TR23 8BACS; MPRVT 61

137173  61 ;0;0;12;0;0;0
137202
137202  "8TR24 8BACS; MPRVT 61

137202  61 ;0;0;12;0;0;0
137211
137211  "8TR25 -8SMO9 8BACS; MPRVT 61

137211  61;0;0;12;0;0;0
137220
137220  "8TR26 8BACS; MPRVT 61

137220  61 ;0;0;12;0;0;0
137227
137227  "8TR27 8BACS; MPRVT 61

137227  61 ;0;0;12;0;0;0
137236
137236  "8TR28 8BACS; MPRVT 61

137236  61 ;0;0;12;0;0;0
137245
137245  "8TR29 -9SMO6 8BACS; MPRVT 61

137245  61;0;0;12;0;0;0
137254
137254  "8TR30 -9SMO7 8BACS; MPRVT 61

137254  61;0;0;12;0;0;0
137263
137263  "8TR31 8BACS; MPRVT 61

137263  61 ;0;0;12;0;0;0
137272
137272  "8TR32 8BACS; MPRVT 61

137272  61 ;0;0;12;0;0;0
137301
137301  "8TR33 8BACS; MPRVT 61

137301  61 ;0;0;12;0;0;0
137310
137310  "8TR34 8BACS; MPRVT 61

137310  61 ;0;0;12;0;0;0
137317
137317  "8TR35 -8SMO7 8BACS; MPRVT 61

137317  61;0;0;12;0;0;0
137326
137326  "8TR36 -8SMO8 8BACS; MPRVT 61

137326  61;0;0;12;0;0;0
137335
137335  "8TR37 -8SMO9 8BACS; MPRVT 61

137335  61;0;0;12;0;0;0
137344
137344  "8TR38 -9SMO1 8BACS; MPRVT 61

137344  61;0;0;12;0;0;0
137353
137353  "8TR39 -9SMO2 8BACS; MPRVT 61

137353  61;0;0;12;0;0;0
137362
137362  "8TR40 -9SMO3 8BACS; MPRVT 61

137362  61;0;0;12;0;0;0
137371
137371  "8TR41 -9SMO4 8BACS; MPRVT 61

137371  61;0;0;12;0;0;0
137400
137400  "8TR42 -9SMO5 8BACS; MPRVT 61

137400  61;0;0;12;0;0;0
137407
137407  "8TR43 -9SMO6 8BACS; MPRVT 61

137407  61;0;0;12;0;0;0
137416
137416  "8TR44 -9SMO7 8BACS; MPRVT 61

137416  61;0;0;12;0;0;0
137425
137425  "8TR45 8BACS; MPRVT 61

137425  61 ;0;0;12;0;0;0
137434
137434  "8TR46 8BACS; MPRVT 61

137434  61 ;0;0;12;0;0;0
137443
137443  "8TR47 8BACS; MPRVT 61

137443  61 ;0;0;12;0;0;0
137452
137452  "8TR48 8BACS; MPRVT 61

137452  61 ;0;0;12;0;0;0
137461
137461  "8TR49 8BACS; MPRVT 61

137461  61 ;0;0;12;0;0;0
137470
137470  "8TR50 8BACS; MPRVT 61

137470  61 ;0;0;12;0;0;0
137477
137477  "8TR51 8BACS; MPRVT 61

137477  61 ;0;0;12;0;0;0
137506
137506  "8TR52 8BACS; MPRVT 61

137506  61 ;0;0;12;0;0;0
137515
137515  "8TR65 8BACS; MPRVT 61

137515  61 ;0;0;12;0;0;0
137524
137524  "8TR66 8BACS; MPRVT 61

137524  61 ;0;0;12;0;0;0
137533
137533  "8TR67 8BACS; MPRVT 61

137533  61 ;0;0;12;0;0;0
137542
137542  "8TR68 8BACS; MPRVT 61

137542  61 ;0;0;12;0;0;0
137551
137551  "8TR69 8BACS; MPRVT 61

137551  61 ;0;0;12;0;0;0
137560
137560  "8TR70 8BACS; MPRVT 61

137560  61 ;0;0;12;0;0;0
137567
137567  "8TR71 8BACS; MPRVT 61

137567  61 ;0;0;12;0;0;0
137576
137576  "8TR72 8BACS; MPRVT 61

137576  61 ;0;0;12;0;0;0
137605
137605  "8TR73 8BACS; MPRVT 61

137605  61 ;0;0;12;0;0;0
137614
137614  "8TR74 8BACS; MPRVT 61

137614  61 ;0;0;12;0;0;0
137623
137623  "8TR75 8BACS; MPRVT 61

137623  61 ;0;0;12;0;0;0
137632
137632  "8TR76 8BACS; MPRVT 61

137632  61 ;0;0;12;0;0;0
137641
137641  "8TR77 8BACS; MPRVT 61

137641  61 ;0;0;12;0;0;0
137650
137650  "8TR78 8BACS; MPRVT 61

137650  61 ;0;0;12;0;0;0
137657
137657  "8TR79 8BACS; MPRVT 61

137657  61 ;0;0;12;0;0;0
137666
137666  "8TR80 8BACS; MPRVT 61

137666  61 ;0;0;12;0;0;0
137675
137675  "8TR81 8BACS; MPRVT 61

137675  61 ;0;0;12;0;0;0
137704
137704  "8TR82 8BACS; MPRVT 61

137704  61 ;0;0;12;0;0;0
137713
137713  "8TR83 8BACS; MPRVT 61

137713  61 ;0;0;12;0;0;0
137722
137722  "8TR84 8BACS; MPRVT 61

137722  61 ;0;0;12;0;0;0
137731
137731  "8TR85 8BACS; MPRVT 61

137731  61 ;0;0;12;0;0;0
137740
137740  "8TR86 8BACS; MPRVT 61

137740  61 ;0;0;12;0;0;0
137747
137747  "8TR87 8BACS; MPRVT 61

137747  61 ;0;0;12;0;0;0
137756
137756  "8TR88 8BACS; MPRVT 61

137756  61 ;0;0;12;0;0;0
137765
137765  "8TR89 8BACS; MPRVT 61

137765  61 ;0;0;12;0;0;0
137774
137774  "8TR90 8BACS; MPRVT 61

137774  61 ;0;0;12;0;0;0
140003
140003  "8TR91 8BACS; MPRVT 61

140003  61 ;0;0;12;0;0;0
140012
140012  "8TR92 8BACS; MPRVT 61

140012  61 ;0;0;12;0;0;0
140021
140021  "8TR93 8BACS; MPRVT 61

140021  61 ;0;0;12;0;0;0
140030
140030  "8TR94 8BACS; MPRVT 61

140030  61 ;0;0;12;0;0;0
140037
140037  "8TR95 8BACS; MPRVT 61

140037  61 ;0;0;12;0;0;0
140046
140046  "8TR96 8BACS; MPRVT 61

140046  61 ;0;0;12;0;0;0
140055
140055  "8TR97 8BACS; MPRVT 61

140055  61 ;0;0;12;0;0;0
140064
140064  "8TR98 8BACS; MPRVT 61

140064  61 ;0;0;12;0;0;0
140073
140073  "8TR99 8BACS; MPRVT 61

140073  61 ;0;0;12;0;0;0
140102
140102  "9TR00 8BACS; MPRVT 61

140102  61 ;0;0;12;0;0;0
140111
140111  "9TR01 8BACS; MPRVT 61

140111  61 ;0;0;12;0;0;0
140120
140120  "9TR02 8BACS; MPRVT 61

140120  61 ;0;0;12;0;0;0
140127
140127  "9TR03 8BACS; MPRVT 61

140127  61 ;0;0;12;0;0;0
140136
140136  "9TR04 8BACS; MPRVT 61

140136  61 ;0;0;12;0;0;0
140145
140145  "9TR05 8BACS; MPRVT 61

140145  61 ;0;0;12;0;0;0
140154
140154  "9TR06 8BACS; MPRVT 61

140154  61 ;0;0;12;0;0;0
140163
140163  "9TR07 8BACS; MPRVT 61

140163  61 ;0;0;12;0;0;0
140172
140172  "9TR08 8BACS; MPRVT 61

140172  61 ;0;0;12;0;0;0
140201
140201  "9TR09 8BACS; MPRVT 61

140201  61 ;0;0;12;0;0;0
140210
140210  "9TR10 8BACS; MPRVT 61

140210  61 ;0;0;12;0;0;0
140217
140217  "9TR11 8BACS; MPRVT 61

140217  61 ;0;0;12;0;0;0
140226
140226  "9TR12 8BACS; MPRVT 61

140226  61 ;0;0;12;0;0;0
140235
140235  "9TR13 8BACS; MPRVT 61

140235  61 ;0;0;12;0;0;0
140244
140244  "9TR14 8BACS; MPRVT 61

140244  61 ;0;0;12;0;0;0
140253
140253  "9TR15 8BACS; MPRVT 61

140253  61 ;0;0;12;0;0;0
140262
140262  "9TR16 8BACS; MPRVT 61

140262  61 ;0;0;12;0;0;0
140271
140271  "9TR17 8BACS; MPRVT 61

140271  61 ;0;0;12;0;0;0
140300
140300  "9TR18 8BACS; MPRVT 61

140300  61 ;0;0;12;0;0;0
140307
140307  "9TR19 8BACS; MPRVT 61

140307  61 ;0;0;12;0;0;0
140316
140316  "9TR20 8BACS; MPRVT 61

140316  61 ;0;0;12;0;0;0
140325
140325  "9TR21 8BACS; MPRVT 61

140325  61 ;0;0;12;0;0;0
140334
140334  "9TR22 8BACS; MPRVT 61

140334  61 ;0;0;12;0;0;0
140343
140343  "9TR23 8BACS; MPRVT 61

140343  61 ;0;0;12;0;0;0
140352
140352  "9TR24 8BACS; MPRVT 61

140352  61 ;0;0;12;0;0;0
140361
140361  "9TR25 8BACS; MPRVT 61

140361  61 ;0;0;12;0;0;0
140370
140370  "9TR26 8BACS; MPRVT 61

140370  61 ;0;0;12;0;0;0
140377
140377  "9TR27 8BACS; MPRVT 61

140377  61 ;0;0;12;0;0;0
140406
140406  "9TR28 8BACS; MPRVT 61

140406  61 ;0;0;12;0;0;0
140415
140415  "9TR29 8BACS; MPRVT 61

140415  61 ;0;0;12;0;0;0
140424
140424  "9TR30 8BACS; MPRVT 61

140424  61 ;0;0;12;0;0;0
140433
140433  "9TR31 8BACS; MPRVT 61

140433  61 ;0;0;12;0;0;0
140442
140442  "9TR32 8BACS; MPRVT 61

140442  61 ;0;0;12;0;0;0
140451
140451  "9TR33 8BACS; MPRVT 61

140451  61 ;0;0;12;0;0;0
140460
140460  "9TR34 8BACS; MPRVT 61

140460  61 ;0;0;12;0;0;0
140467
140467  "9TR35 8BACS; MPRVT 61

140467  61 ;0;0;12;0;0;0
140476
140476  "9TR36 8BACS; MPRVT 61

140476  61 ;0;0;12;0;0;0
140505
140505  "9TR37 8BACS; MPRVT 61

140505  61 ;0;0;12;0;0;0
140514
140514  "9TR38 8BACS; MPRVT 61

140514  61 ;0;0;12;0;0;0
140523
140523  "9TR39 8BACS; MPRVT 61

140523  61 ;0;0;12;0;0;0
140532
140532  "9TR40 8BACS; MPRVT 61

140532  61 ;0;0;12;0;0;0
140541
140541  "TEFX1 8BACS; MPRVT 61

140541  61 ;0;0;12;0;0;0
140550
140550                MPRVT 61

140550  61 ;0;0;12;0;0;0
140557
140557  "BAD01 8BACS; MPRVT 60

140557  60 ;0;0;12;0;0;0
140566
140566  "BAD02 8BACS; MPRVT 60

140566  60 ;0;0;12;0;0;0
140575
140575  "BAD03 8BACS; MPRVT 60

140575  60 ;0;0;12;0;0;0
140604
140604  "BAD04 8BACS; MPRVT 60

140604  60 ;0;0;12;0;0;0
140613
140613  "BAD05 8BACS; MPRVT 60

140613  60 ;0;0;12;0;0;0
140622
140622  "BAD06 8BACS; MPRVT 60

140622  60 ;0;0;12;0;0;0
140631
140631  "BAD07 8BACS; MPRVT 60

140631  60 ;0;0;12;0;0;0
140640
140640  "BAD08 8BACS; MPRVT 60

140640  60 ;0;0;12;0;0;0
140647
140647  "BAD09 8BACS; MPRVT 60

140647  60 ;0;0;12;0;0;0
140656
140656  "BAD10 8BACS; MPRVT 60

140656  60 ;0;0;12;0;0;0
140665
140665  "BAD11 8BACS; MPRVT 60

140665  60 ;0;0;12;0;0;0
140674
140674  "BAD12 8BACS; MPRVT 60

140674  60 ;0;0;12;0;0;0
140703
140703  "BAD13 8BACS; MPRVT 60

140703  60 ;0;0;12;0;0;0
140712
140712  "BAD14 8BACS; MPRVT 60

140712  60 ;0;0;12;0;0;0
140721
140721  "BAD15 8BACS; MPRVT 60

140721  60 ;0;0;12;0;0;0
140730
140730  "BAD16 8BACS; MPRVT 60

140730  60 ;0;0;12;0;0;0
140737
140737  "BAD17 8BACS; MPRVT 60

140737  60 ;0;0;12;0;0;0
140746
140746  "BAD18 8BACS; MPRVT 60

140746  60 ;0;0;12;0;0;0
140755
140755  "BAD19 8BACS; MPRVT 60

140755  60 ;0;0;12;0;0;0
140764
140764  "BAD20 8BACS; MPRVT 60

140764  60 ;0;0;12;0;0;0
140773
140773  "BAD21 8BACS; MPRVT 60

140773  60 ;0;0;12;0;0;0
141002
141002  "BAD22 8BACS; MPRVT 60

141002  60 ;0;0;12;0;0;0
141011
141011  "BAD23 8BACS; MPRVT 60

141011  60 ;0;0;12;0;0;0
141020
141020  "BAD24 8BACS; MPRVT 60

141020  60 ;0;0;12;0;0;0
141027
141027  "BAD25 8BACS; MPRVT 60

141027  60 ;0;0;12;0;0;0
141036
141036  "BAD26 8BACS; MPRVT 60

141036  60 ;0;0;12;0;0;0
141045
141045  "BAD27 8BACS; MPRVT 60

141045  60 ;0;0;12;0;0;0
141054
141054  "BAD28 8BACS; MPRVT 60

141054  60 ;0;0;12;0;0;0
141063
141063  "BAD29 8BACS; MPRVT 60

141063  60 ;0;0;12;0;0;0
141072
141072  "BAD30 8BACS; MPRVT 60

141072  60 ;0;0;12;0;0;0
141101
141101  "BAD31 8BACS; MPRVT 60

141101  60 ;0;0;12;0;0;0
141110
141110  "BAD32 8BACS; MPRVT 60

141110  60 ;0;0;12;0;0;0
141117
141117  "BAD33 8BACS; MPRVT 60

141117  60 ;0;0;12;0;0;0
141126
141126  "BAD34 8BACS; MPRVT 60

141126  60 ;0;0;12;0;0;0
141135
141135  "BAD35 8BACS; MPRVT 60

141135  60 ;0;0;12;0;0;0
141144
141144  "BAD36 8BACS; MPRVT 60

141144  60 ;0;0;12;0;0;0
141153
141153  "BAD37 8BACS; MPRVT 60

141153  60 ;0;0;12;0;0;0
141162
141162  "BAD38 8BACS; MPRVT 60

141162  60 ;0;0;12;0;0;0
141171
141171  "BAD39 8BACS; MPRVT 60

141171  60 ;0;0;12;0;0;0
141200
141200  "BAD40 8BACS; MPRVT 60

141200  60 ;0;0;12;0;0;0
141207
141207  "BAD41 8BACS; MPRVT 60

141207  60 ;0;0;12;0;0;0
141216
141216  "BAD42 8BACS; MPRVT 60

141216  60 ;0;0;12;0;0;0
141225
141225  "BAD43 8BACS; MPRVT 60

141225  60 ;0;0;12;0;0;0
141234
141234  "BAD44 8BACS; MPRVT 60

141234  60 ;0;0;12;0;0;0
141243
141243  "BAD45 8BACS; MPRVT 60

141243  60 ;0;0;12;0;0;0
141252
141252  "BAD46 8BACS; MPRVT 60

141252  60 ;0;0;12;0;0;0
141261
141261  "BAD47 8BACS; MPRVT 60

141261  60 ;0;0;12;0;0;0
141270
141270  "BAD48 8BACS; MPRVT 60

141270  60 ;0;0;12;0;0;0
141277
141277  "BAD49 8BACS; MPRVT 60

141277  60 ;0;0;12;0;0;0
141306
141306  "BAD50 8BACS; MPRVT 60

141306  60 ;0;0;12;0;0;0
141315
141315  "BAD51 8BACS; MPRVT 60

141315  60 ;0;0;12;0;0;0
141324
141324  "BAD52 8BACS; MPRVT 60

141324  60 ;0;0;12;0;0;0
141333
141333  "BAD53 8BACS; MPRVT 60

141333  60 ;0;0;12;0;0;0
141342
141342  "BAD54 8BACS; MPRVT 60

141342  60 ;0;0;12;0;0;0
141351
141351  "BAD55 8BACS; MPRVT 60

141351  60 ;0;0;12;0;0;0
141360
141360  "BAD56 8BACS; MPRVT 60

141360  60 ;0;0;12;0;0;0
141367
141367  "BAD57 8BACS; MPRVT 60

141367  60 ;0;0;12;0;0;0
141376
141376  "BAD58 8BACS; MPRVT 60

141376  60 ;0;0;12;0;0;0
141405
141405  "BAD59 8BACS; MPRVT 60

141405  60 ;0;0;12;0;0;0
141414
141414  "BAD60 8BACS; MPRVT 60

141414  60 ;0;0;12;0;0;0
141423
141423  "BAD61 8BACS; MPRVT 60

141423  60 ;0;0;12;0;0;0
141432
141432  "BAD62 8BACS; MPRVT 60

141432  60 ;0;0;12;0;0;0
141441
141441  "BAD63 8BACS; MPRVT 60

141441  60 ;0;0;12;0;0;0
141450
141450  "BAD64 8BACS; MPRVT 60

141450  60 ;0;0;12;0;0;0
141457
141457  "BAD65 8BACS; MPRVT 60

141457  60 ;0;0;12;0;0;0
141466
141466  "BAD66 8BACS; MPRVT 60

141466  60 ;0;0;12;0;0;0
141475
141475  "BAD67 8BACS; MPRVT 60

141475  60 ;0;0;12;0;0;0
141504
141504  "BAD68 8BACS; MPRVT 60

141504  60 ;0;0;12;0;0;0
141513
141513  "BAD69 8BACS; MPRVT 60

141513  60 ;0;0;12;0;0;0
141522
141522  "BAD70 8BACS; MPRVT 60

141522  60 ;0;0;12;0;0;0
141531
141531  "
141531  EPRVT=*
141531
141531  )LINE
%
141531  % File : (SAMSON)KILL-MACROS:DUMY
141531
141531  )KILL CNVBYADR CNVWADR
141531  )LINE
)MCDEF TYPSW $A,$B,$C,$D,$E
LD$A  ,$B  MTDFT; RADD S$A  DP
$C 00;$D ;$E %
$C 03;$D ;$E %
$C 06;$D ;$E %
$C 11;$D ;$E %
$C 14;$D ;$E %
MTBYP=*; )KILL MTBYP
]
033744  )MCDEF SOWN
COPY SB DD; LDX (BBASE; BSET ZRO; LDA ,X -2; AAA 2; STD ,X OWN; BSET ONE
]
033744  )LINE
033744   %$--:MPIT                      % FOR SPLITTING AV LISTING.
033744   *P2MPI/          % PART 2 OF MPIT STARTS HERE
050716   @DEV (S-S-L)MP-P2-1:NPL
050716   %==========================================================================
050716   %
050716   %
050716   %
050716   %==========================================================================
050716
050716   %==========================================================================
050716   %      P M T R A N S       INTERFACE BETWEEN SEGADM AND DISK DRIVER
050716   %
050716   SUBR PMTRANS
050716   INTEGER LREG
050717   INTEGER CHK:=0            % TO ENSURE PROPER CALLING SEQUENCE.
050720   PMTRANS:       IF CHK><0 GO PMTRANS
050723                  A-1=:CHK
050725                  *IRR SLEVB DB                % GET DATAFIELD FROM SLEV.
050726                  A=:B; *IRR SLEVB DL          % GET RETURN ADDRESS ON SLEV.
050730                  A+1=:LREG; *IRR SLEVB DA     % GET PARAMETER LIST FROM SLEV.
050733                  T:=7; CALL MTRANS            % DO DISK TRANSFER.
050735                  MIN CHK; *JMP *
050737                  *IRW SLEVB DA                % RETURNS WITH STATUS IN A-REG.
050740                  LREG; *IRW SLEVB DP          % RETURN TO SLEV.
050742                  SLEV; *MST PID; JMP *
050745   RBUS
050746
050746   %==============================================================================
050746   %     ( M )    I O R E M
050746   %
050746   % MONITOR FUNCTION ROUTINE TO START PROGRAM USING SYNC.MODEM
050746   %
050746   SUBR IOREM
050746   IOREM: IF X:=X.RTRES >< 0 THEN CALL RTENTRY; CALL FTIMQU FI
050752          GO STUPR
050753   RBUS
050756
050756
050756   *"8BACS
"050756   %==============================================================================
050756   %      BACKGROUND PROCESS ALLOCATION SYSTEM ROUTINES
050756   %==============================================================================
050756
050756   %============================================================================
050756   %            C M B A B P R O C
050756   %
050756   % CALLED FROM MON LOGIN
050756   %
050756   SUBR CMBABPROC
050756   CMBABPROC: CALL MBABPROC; GO MONEN
050760          A:=X; *IRW ALEVB DX; IRR ALEVB DP; AAA 1; IRW ALEVB DP
050765          GO MONEN
050766   RBUS
050770   *"
"050770
050770   SUBR MBABPROC,T2P08
050770
050770   *"8BACS
"050770   %=============================================================================
050770   %            C F B P P R O C       ( M )
050770   %
050770   % LOCAL SUBROUTINE TO SEARCH FOR A BACKGROUND PROCESS TO ALLOCATE
050770   %
050770   % ENTRY:     B=INPUT DATAFIELD
050770   %
050770   % EXIT:      NO BACKGROUND PROCESS FOUND
050770   %
050770   % EXIT+1:    BACKGROUND PROCESS FOUND.
050770   %            X=ADDRESS IN BACKGROUND PROCESS TABLE (SBPRTAB)
050770   %
050770   INTEGER BFOUND
050771   CFBP:     0=:BFOUND
050772             X:=ASBPRTAB
050773             DO WHILE X<<=AEBPRTAB-BPRTSIZE
050777                T:=MBSPRTAB; *CBPTE@3 LDATX
051001                IF A=B THEN EXITA FI                % BACKGROUND PROC FOUND
051004                IF A=0 AND BFOUND=0 THEN            % BACKG.PROC. IS FREE AND NO OTHER CANDIDATE IS FOUND
051007                   X=:D; *BBPRO@3 LDXTX
051011                   IF X.STATUS BIT 5RTOFF THEN X:=D; GO NXT FI
051016                   X:=D; *BPRFL@3 LDATX
051020                   IF A NBIT BPNAVAILABLE AND A/\BTYPRMASK><0 THEN % AVAILABLE AND LEGAL FOR THIS DEVICE TYPE?
051024                      X=:BFOUND                     % FREE ENTRY FOUND
051025                   FI
051025                FI
051025   NXT:         X+BPRTSIZE
051026             OD
051027             IF X:=BFOUND><0 THEN EXITA FI          % A FREE BACKGROUND PROCESS IS FOUND
051032             EXIT                                   % NO BACKGROUND PROCESS FOUND
051033   *)FILL
051037   *"
"051037
051037   %============================================================================
051037   %            M B A B P R O C       ( M )
051037   %
051037   % ALLOCATE BACKGROUND PROCESS
051037   %
051037   % MONITOR LEVEL - CALLED FROM MESCAPE
051037   %
051037   % ENTRY:     X= DATAFIELD
051037   %
051037   % EXIT:      STARTED A TAD USED AS A SERVER OR
051037   %            NOT TERMINAL/TAD OR NOT BOTH INPUT AND OUTPUT DATAFIELDS
051037   %            ARE FREE.
051037   %
051037   % EXIT+1:    X=BACKGROUND PROGRAM CONNECTED TO THE ACTUAL TERMINAL/TAD
051037   %
051037   % THIS ROUTINE WILL RETURN TO MONEN IF NO BACKROUND PROGRAM IS FOUND
051037   %
051037
051037   INTEGER POINTER LREG=?
051037   INTEGER CCBBPROG=?,PRVTADDR=?,CADDR=?,SVCLASS=?,SRVTAD=?
051037
051037   MBABPROC:
051037   *"-8BACS
"051037          IF X.RTRES><0 THEN EXIT FI                          % INPUT DATAFIELD FREE?
051042          IF X.TYPRING /\ BTYPRMASK = 0 THEN  EXIT FI         % NOT TERMINAL OR TAD
051046          A:=L=:"LREG"
051050          T:="DFOPP"; CALL XGTDFADDR
051052          IF A=0 GO LREG                                      % TWO WAYS DEVICE?
051054          B:=X                                                % YES
051055          IF T:=TYPRING BIT 5SPLITDF THEN A:=B+"9CXTI" FI
051062          IF A.RTRES><0 THEN X:=B; GO LREG FI                 % OUTPUT DATAFIELD FREE?
051067          CALL FAR CFBP; GO FAR NFND; GO OK                   % YES, TRY TO FIND FREE BACKGROUND PROC.
051072   *)FILL
051077
051077   OK:    X=:CADDR; T:=MBSPRTAB; *BBPRO@3 LDXTX
051102          IF X.WLINK><0 GO FAR TMONEN                         % PROGRAM ALREADY ACTIVE
051105          IF X.STATUS BIT 5RTOFF GO FAR TMONEN                % PROGRAM CANNOT BE STARTED
051110          A BZERO 5WAIT BZERO 5REP=:X.STATUS
051113          "9ENTOPCOM"=:X.STADR                                % START ADDR. OF BACKGROUND PROGRAM
051115          X=:CCBBPROG:=X.RTDLGADDR                            % X=ADDR OF REGISTER BLOCK
051117          T:=0; A:=B; *AAX DBREG; STATX                       % SET REGISTERS FOR BACKGROUND PROGRAM
051123          A:=CCBBPROG; X:=B; T:="DBPROG"; CALL XSTDFADDR      % UPDATE DBPROG IN DATAFIELD
051127          T:=MBSPRTAB; X:=CADDR; A:=B; *CBPTE@3 STATX
051133          A:=B; CALL 9GTLOGDV; D:=0                           % FIND LOGICAL DEVICE NUMBER OF TERMINAL (TAD)
051136          A:=D; T:=MBSPRTAB; X:=CADDR; *BPLOG@3 STATX
051142          X:=B; CALL FIBCKTABLE; GO FAR TMONEN
051145          CALL GBTINDX; GO FAR TMONEN
051147          X:=CCBBPROG; CALL CHNLG; GO FAR ERR                 % CHECK NUMBER OF INLOGGED USERS.
051152          T:=MBSPRTAB; X:=CADDR; *BTBIN@3 STATX
051155          A*5PRVTSIZE+APRVTTABLE=:X=:PRVTADDR                 % ADDRESS OF PRIVATE-SYSTEM-SEGMENT-INFO TABLE ELEMENT
051161          T:=MBPRVTTABLE; *SVBPR@3 LDATX
051163          A BONE BPSOK; X:=CADDR; T:=MBSPRTAB; *BPRFL@3 STATX % INSERT FLAG BITS
051167          D:=0; *AAX TTMCO; STDTX; STDTX 20; STDTX 40         % CLEAR "TIMEOUT" VARIABLES
051174          A:=CCBBPROG-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
051202          A=:X:=B=:XBCKTABLE(X); 0=:SRVTAD                    % UPDATE XBCKTAB
051206          IF TYPRING BIT 5BAD THEN
051211             X:=B; T:="TADTYP"; CALL XGTDFADDR
051214             IF A=377 THEN 1=:SRVTAD FI                       % SERVER TYPE TAD
051221          FI
051221          X:=CCBBPROG; CALL GTSLPINDEX; GO NSLIS; GO OVFILL   % FIND TIMESLICE INDEX
051225   *"-8BACS BADAD
"051225   INTEGER POINTER LREG
051226   INTEGER CCBBPROG,PRVTADDR,CADDR,SRVTAD,SVCLASS=PRVTADDR
051232   *)FILL
051255
051255   *"8BACS
"051255   INTOTSLPRTAB:
051255           T:=GLTMBANK; *LDDTX; STDTX 20                      % MOVE END OF TABLE
051260           A:=CCBBPROC-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
051266           A=:D:=CCBBPROC; T:=GLTMBANK; *STDTX
051272           EXIT
051273
051273   OVFILL:
051273          IF SRVTAD><0 THEN                                   % TAD TYPE 377 (SERVER)
051275             A:=X*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK
051302             *TSLST@3 LDATX
051303             A=:SVCLASS; A:=5 SH 7CUTY; *TSLST@3 STATX        % SET SERVER CLASS
051307             X:=B; T:="XDFOPP"; CALL XGTDFADDR
051312             X:=A; T:="SVOTS"; A:=SVCLASS; CALL XSTDFADDR     % SAVE OLD TIMESLICE CLASS
051316             CCBBPROC.STATUS BONE 5TSLICED BONE 5ESCF=:X.STATUS
051323             CALL FPITSLPRTAB; CALL INTOTSLPRTAB
051325          ELSE
051326             T:=MBPRVTTABLE; X=:D:=PRVTADDR; *SVTSL@3 LDATX
051332             A=:L:=D*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK
051340             A:=L; *TSLST@3 STATX                             % SET TIMESLICE CLASS
051342             IF L NBIT 5NOSLICE THEN
051344                CCBBPROC.STATUS BONE 5TSLICED BONE 5ESCF=:X.STATUS
051351                CALL FPITSLPRTAB; CALL INTOTSLPRTAB
051353             ELSE
051354                CCBBPROC.STATUS BZERO 5TSLICED=:X.STATUS
051360                CALL FPITSLPRTAB; GO NSLIS
051362                A:=X-D=:L; T:=D; X:=GLTMBANK
051367                A:=T+2=:D:=X; *MOVPP                          % COMPRESS DTSLPRTAB
051374             FI
051374          FI
051374   NSLIS: X:=CCBBPROG; MIN "LREG"
051376          GO LREG
051377   *)FILL
051411
051411   % NO BACKGROUND PROCESS FOUND, CHECK IF ANY
051411   % OF THE BACKGROUND PROCESSES IS FREE
051411   NFND:   X:=ASBPRTAB
051412           DO WHILE X<<=AEBPRTAB-BPRTSIZE
051416              X=:D; T:=MBSPRTAB; *BPRFL@3 LDATX
051421              IF A NBIT BPCFIXED THEN                         % NOT PERMANENT OCCUPIED
051423                 *BBPRO@3 LDXTX
051424                 IF X.TLINK=0 AND X.WLINK=0 AND X.STATUS NBIT 5RWAIT THEN
051433                    X:=D; *CBPTE@3 STZTX                      % BACKGROUND PROCESS IS PASSIVE
051435                 FI
051435              FI; X:=D+BPRTSIZE
051437           OD; CALL FAR CFBP; GO ERR                          % CHECK IF ANY FREE NOW
051442           GO FAR OK                                          % FREE PROGRAM FOUND
051443
051443   *"
"051443   ERR:   CALL 9GTLOGDV; GO TMONEN
051445          A:=D; CALL 9ERR(#98)
051450   T2P08:
051450   TMONEN: *IOF
051451          CALL CBERSP; 0/\0                                 % SEND ESCAPE RESPONSE IF TAD
051453          GO MONEN
051454
051454   *"-8BACS BADAD
"051454   RBUS
051465

051465   %=============================================================================
051465   %       (M)   C H N L G
051465   %
051465   %       ROUTINE TO CHECK NUMBER OF ACTIVE USERS.
051465   %
051465   %       ENTRY: B=INPUT DATAFIELD
051465   %              X=RT DESCRIPTION ADDRESS
051465   %       EXITA: LOGIN ALLOWED
051465   %       EXIT:  LOGIN NOT ALLOWED
051465   SUBR CHNLG
051465   INTEGER CADR,LREG,AREG
051470   CHNLG:  X=:CADR; A=:AREG
051472           IF "DT01R"=B THEN AREG; EXITA FI             % ALWAYS ACCEPT CONSOLE
051477           IF TYPRING BIT 5BAD THEN                     % IF TAD, CHECK IF REMOTE.
051502              A:=L=:LREG
051504              X:=B+"9CXTI"; T:="PARTNER"; CALL XGTDFADDR% GET FIRST PART OF MAGNO (CPU NO.)
051510              T:=LREG=:L
051512              IF A=SYSNO THEN AREG; EXITA FI            % LOCAL CONNECTIONS ALWAYS OK
051517           FI
051517           GO BYP
051520           IF "STDRIV"="MTINS" THEN                     % IF MTAD, CHECK IF REMOTE.
051524              IF MTFLAG NBIT 5MTRC THEN AREG; EXITA FI  % LOCAL ALWAYS OK.
051531           FI
051531   BYP:    IF NACTI+1>NLEGU THEN EXIT FI                % NO MORE USERS ALLOWED
051537           A=:NACTI                                     % UPDATE NO. OF ACTIVE USERS
051540           CADR.INPRITY BONE 5COUNT=:X.INPRITY          % MARK PROGRAM HAS BEEN COUNTED
051544           AREG; EXITA
051546   RBUS
051555   %=============================================================================
051555   *"99SM1
"051555   %==============================================================================
051555   %      S M T B R E L       (M)
051555   %
051555   % MONITOR LEVEL ROUTINE TO RELEASE THE STC-DMA DATAFIELD AND DECREMENT
051555   % THE CALLING PROGRAM'S P-REGISTER
051555   %
051555   SUBR SMTBREL
051555   SMTBREL: X=:B:=X.RTRES; CALL BRELEASE
051560          IF X=CURPROG THEN
051563             *IRR ALEVB DP; AAA -1; IRW ALEVB DP
051566          ELSE
051567             X=:D:=X.RTDLGADDR; T:=0; *LDATX XTDPR
051573             A-1; *STATX XTDPR
051575             X:=D
051576          FI; "RETRA"=:MFUNC; GO MONEN
051601   RBUS
051605
051605

051605   *"8MT1+8DMVC+8CDLI+8FDI1+8FDI2+8BFD1+8BFD2+8MT2+8MT3+8MT4
"051605   %==============================================================================
051605   %       C G M L E V       (M)
051605   % IOTRANS ROUTINE FOR MAG.TAPE, VERSATEC ON DMA, AND FLOPPY DISK
051605   %
051605   % MONITOR LEVEL FOR INPUT
051605   SUBR CGMLEV,CBMLEV
051605   CGMLEV:CALL CBF2; T:=7; CALL MTRANS; CALL BRELEASE
051611          CALL MBFDISC; X:=BREGC;0=:X.CERRO
051614          IF TYPRING BIT 5FLOP THEN
051617             IF HSTAT NBIT 4 THEN
051622                IF A BIT 5 THEN A BONE 4=:HSTAT; 3=:CERRCODE; A:=0
051631                ELSE
051632                   X:=BREGC.CASUN; X:=FDIFORM(X); WDSCT(X)     % WORDS PER SECTOR ACCORDING TO FORMAT
051636                FI
051636             ELSE
051637                A:=0
051640             FI; A=:BREGC.NOWRE
051642          FI
051642          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B
051650             IF T:=X.NOWRE=0 THEN A=:X.DERROR ELSE A=:X.CERROR FI
051656          FI
051656   CBGE1: X=:B;NOWRE SHZ 1=:BHOLD;0=:HENTE=:CFREE
051664          GO STUPR
051665   %
051665   % MONITOR LEVEL FOR OUTPUT
051665   %
051665   CBMLEV:CALL CBF2
051666          T:=7;CALL MTRANS; CALL BRELEASE
051671          CALL MBFDISC; X:=BREGC
051673          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B; A=:X.DERROR FI
051702          X=:B;MAX=:CFREE;0=:FYLLE=:BHOLD
051707          GO STUPR
051710   *)FILL
051715
051715   INTEGER POINTER REGL
051716   INTEGER BREG
051717   CBF2:  A:=L=:"REGL"
051721          *IRR ALEVB DP
051722          A-1;*IRW ALEVB DP
051724          MAX SHZ -1=:NOWRE; CLOGDV; CALL LOGPH
051731          IF A=0 THEN 2=:DERROR; GO STUPR; FI     % NO  "DMA" DATAFIELD
051735          A:=:B;A=:BREG; X:=RTREF; CALL BRESERVE  % RESERVE "DMA" DATAFIELD
051741          IF A<0 THEN
051742             CALL FREXQU;CALL TOWQU; GO STUPR     % WAIT FOR "DMA" DEVICE TO BE FREE
051745          FI
051745          IF TYPRING BIT 5FLOP THEN
051750             1=:BREG.NOWRE
051753             X:=X.CASUN; NFDIADR(X)=:BREG.FDIADR
051757          FI; BREG=:BREGC; A+"CPARM"; GO REGL
051763   %
051763   % INCREMENT DISC ADDRESS IF FLOPPY DISC
051763   %
051763   MBFDISC: IF TYPRING BIT 5FLOP THEN
051766                X:=BREGC.CASUN; MIN NFDIADR(X); 0/\0
051772            FI; EXIT
051773   RBUS
052002
052002   %==============================================================================
052002   %      S M T R A                               (M)
052002   %
052002   SUBR SMTRA
052002   % SUBROUTINE TO SET UP A CALL TO THE MASS STORAGE DRIVER
052002   % MONITOR LEVEL
052002
052002   SMTRA: X=:B                            % LEVEL 2  (MONITOR LEVEL)
052003          CLOGDV; CALL LOGPH; A=:X
052006          "SRETRA"=:X.MFUNC
052010          IF X.TYPRING BIT 5FLOP THEN
052013             X=:D; 1=:NOWRE; CASUN+X+"NFDIADR"=:X; X.S0; MIN X.S0; 0/\0
052025            A=:FDIADR; D=:X
052027          FI
052027          A:=B+"CPARM"; X=:B;CALL CMTRANS
052033          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B ELSE A:=0 FI; A=:D
052044          IF CURPROG=MRTREF THEN
052050              A:=D; *IRW ALEVB DA
052052          ELSE
052053             A:=D; X:=MRTREF.RTDLGADDR; T:=0; *STATX XTDAR
052060          FI; X:=MRTREF
052061          "RETRANS"=:MFUNC; CALL BRELEASE; BREGC=:B
052066          "IORES"=:MFUNC
052070   OUT:   GO STUPR
052071
052071   RBUS
052104
052104
052104   *"8MT1+8MT2+8FDI1+8FDI2+8BFD1+8BFD2+8DLP1+8DLP2+8DMVC+8DVE1+8DVE2+8MT3+8MT4
"052104   %==============================================================================
052104   % 34.11      C M T R A N S   S R E T R A
052104   %
052104   %
052104   % SUBROUTINE TO START DRIVER ON LEVEL 11
052104   % MONITOR LEVEL
052104   % ENTRY: B=DATAFIELD ADDRESS
052104   %        A=ADDRESS OF PARAMETER LIST
052104   %
052104   SUBR CMTRANS,SRETRA
052104
052104   CMTRANS: T:=L=:"TRLREG"
052106          CALL GAPFD
052107          *IOF; TRR 10
052111          "STDRIV";*IRW LV11B DT
052113          A:=B; *IRW LV11B DB; IRW LV11B DX;
052116          "SLV11"; *IRW LV11B DP
052120          LV11;*MST PID
052122          X:=MRTREF;CALL WDATA
052124          *ION
052125          IF X=RTREF GO RWAIT; GO MONEN
052131
052131   % X=DATAFIELD ADDRESS
052131   SRETRA: X=:B:=MRTREF;IF X=0 GO MONEN
052135          CALL RDATA;GO TRLREG
052137
052137   RBUS
052147
052147   *"8HDMA
"052147   %

052147   %==============================================================================
052147   %     ( M )     H I T R N S
052147   %
052147   %  SUBROUTINE TO START DRIVER ON LEVEL 13,
052147   %  RETURN WHEN FINISHED
052147   %  MONITOR LEVEL
052147   %  ENTRY:  A=PARAMETER LIST ADDRESS
052147   %          B=DATAFIELD ADDRESS
052147   %
052147
052147   SUBR HITRNS
052147   INTEGER TREG,AREG,LREG
052152   HITRNS:
052152          T=:TREG:=L=:LREG;A=:AREG
052156          IF T=0 THEN   % FROM ABSTR
052160            X:=RTREF; CALL BRESERVE; IF A<0 GO WT    % RESERV DF.
052164          FI
052164          LREG=:"TRLREG"; AREG
052167          IF T:=TREG=0 THEN CALL GAPFU ELSE CALL GAPFD; FI  % GET PARAMETERS FROM USER OR DPIT
052175          *IOF;TRR 10                         % CLEAR CACHE
052177          B=:A; *IRW LV13B DB; IRW LV13B DX
052202          "STDRIV"; *IRW LV13B DP
052204          LV13; *MST PID
052206          X:=RTRES; CALL WDATA
052210          *PION
052211          IF X=RTREF GO RWAIT; GO MONEN
052215
052215   RBUS
052226
052226
052226   %==============================================================================
052226   %      ( M )      H O T R N S
052226   %
052226   %  SUBROUTINE TO START DRIVER ON LEVEL 12,
052226   %  RETURN WHEN FINISHED.
052226   %  MONITOR LEVEL
052226   %  ENTRY:  A=PARAMETERLIST ADDRESS
052226   %          B=DATAFIELD ADDRESS
052226   %
052226
052226   SUBR HOTRNS
052226   INTEGER TREG,AREG,LREG
052231   HOTRNS:
052231          T=:TREG:=L=:LREG;A=:AREG
052235          IF T=0 THEN   % FROM ABSTR
052237            X:=RTREF; CALL BRESERVE; IF A<0 GO WT    % RESERV DF.
052243          FI
052243          LREG=:"TRLREG"; AREG
052246          IF T:=TREG=0 THEN CALL GAPFU ELSE CALL GAPFD; FI  % GET PARAMETERS FROM USER OR DPIT
052254          *IOF;TRR 10
052256          B=:A; *IRW LV12B DB; IRW LV12B DX
052261          "STDRIV"; *IRW LV12B DP
052263          LV12; *MST PID
052265          X:=RTRES; CALL WDATA
052267          *PION
052270          IF X=RTREF GO RWAIT; GO MONEN
052274
052274   RBUS
052305
052305   % PREDECLARATION
052305   SUBR HDMIDRIV
052305   RBUS
052305
052305   %==============================================================================
052305   %    ( M )   C T R O D   C T R I D   H D O B U S   H D I B U S   H D O F I N
052305   %            H D I F I N   H D O F E I L   H D I F E I L   H D I T I M
052305   %            H D O T I M
052305   %
052305   % ROUTINE TO SET UP CALL TO HDLC-BSC/DMA OUTPUT/INPUT DRIVER.
052305   %
052305   % LEVEL 12/LEVEL 13
052305   %
052305   % ACTIVATED BY MTRANS
052305   %
052305   % ENTRY : B=ADDRESS OF THE DATAFIELD
052305   %         X=ADDRESS OF THE PARAMETER LIST (OF ABTRANS)
052305   %
052305   % PARAMETERS : PAR0          = FUNCTION CODE
052305   %              PAR1          = POINTER TO THE MEMORY ADDRESS
052305   %              PAR2          = NOT USED
052305   %              PAR3          = NO. OF WORDS IN READ/WRITE
052305   %                            = PROTOCOL IN SET-PROTOCOL
052305   %                            = MODE IN SET-MODE
052305   %                            = SECONDS IN SET-RECEIVE-TIMER
052305   %
052305
052305   SUBR CTROD,CTRID,HDOBUS,HDIBUS,HDOFIN,HDIFIN,HDOFEIL,HDIFEIL,HDITIM,HDOTIM
052305
052305   DISP 0; DOUBLE POINTER DP1=P1; PSID
052305   DISP -44
052305   INTEGER HCTRL
052305   INTEGER HMOD
052305   %INTEGER CERRCODE
052305   PSID
052305   DISP -40; INTEGER HSPFL; PSID
052305   SYMBOL HDHDX=5,BROCK=10
052305
052305   CTROD:
052305          0=:CERRCODE=:HSTAT
052307          IF ABFUN/\77=1 OR =55 OR =52 GO RWOPER    % SEND, CONTROL OR INIT
052322          IF A=51 THEN                              % SELECT HALF/FULL DUPLEX
052325             IF ABP31<0 OR >1 THEN
052332                174=:CERRCODE; GO OFINEY
052335             FI
052335             T:=HCTRL=:D
052337             IF A=1 THEN D BONE HDHDX ELSE D BZERO HDHDX FI
052345             A:=D=:HCTRL; GO OFINOK
052350          FI
052350          201=:CERRCODE; GO OFINEY                  % ILL. FUNCTION CODE
052353
052353   OFINOK:
052353          GO OFIN
052354   OFINEY:
052354          HSTAT BONE 4=:HSTAT; GO OFIN
052360   IFINOK:
052360          GO IFIN
052361   IFINEY:
052361          HSTAT BONE 4=:HSTAT; GO IFIN
052365
052365   RWOPER:
052365          AD:=MEMAD; A:=:D; A=:CARG; A:=D/\37 SH 12=:T
052374          ABFUN/\377+T=:CTRG
052400          ABP31=:CXRG
052402          TAD:=CTADRG=:TADRG; X:=CXRG=:XRG
052406          IF A=0 THEN A=:MRETURN FI
052410          DO
052410              TTMR=:TMR; X:=XRG; TAD:=TADRG
052414              CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
052420   RWBUSY:
052420          OD
052421
052421   HDIBUS:CALL ID13
052422          T:=HDEV+10; *EXR ST
052425          IF A NBIT BROCK THEN
052427             GO HDIBUS                   % BLOCK NOT READY
052430          ELSE
052431             A=:HSPFL; GO HDMIDRIV
052433          FI
052433   HDOBUS:
052433          CALL ID12; GO RWBUSY
052435
052435   HDIFIN:
052435          X=:HSTAT
052436   IFIN:  IF RTRES><0 THEN
052440             0=:HSPFL=:TMR; CALL RTACT
052443          FI
052443          GO HDIBUS
052444   HDIFEIL:
052444          A=:CERRCODE; X BONE 4=:HSTAT; GO IFIN
052450   HDOFIN:
052450          X=:HSTAT
052451   OFIN:  IF RTRES><0 THEN CALL RTACT FI
052454          0=:TMR; CALL ID12; A+1; GO ERR22
052460   HDOFEIL:
052460          A=:CERRCODE; X BONE 4=:HSTAT; GO OFIN
052464
052464   *)FILL
052476
052476   % INPUT
052476
052476   CTRID: 0=:CERRCODE=:HSTAT
052500          IF ABFUN/\77=0 GO RWOPER        % RECEIVE
052503          IF A=53 THEN                    % SET REC. TIMER
052506             ABP31-=:TTMR; GO IFINOK
052512          FI
052512          IF A=50 THEN                    % SELECT PROTOCOL
052515             ABP31=:HMOD; GO IFINOK
052520          FI
052520          201=:CERRCODE; GO IFINEY
052523
052523   % TIME-OUT ON LEVEL 12/13
052523   %
052523   % ACTIVATED FROM TIME PROGRAM
052523
052523   HDITIM:
052523          HSTAT BONE 4=:HSTAT; 12=:CERRCODE
052530          100; T:=HDEV+11; *EXR ST
052534          GO IFIN
052535   HDOTIM:
052535          HSTAT BONE 4=:HSTAT; 12=:CERRCODE
052542          "0"; T:=HDEV+13; *EXR ST
052546          GO OFIN
052547
052547   RBUS
052551
052551
052551
052551   *"8FDI1
"052551   %==============================================================================
052551   %            C L M L E V
052551   %
052551   % IOTRANS ROUTINE FOR LINE-PRINTER AND VERSATEC
052551   % MONITOR LEVEL
052551   SUBR CLMLEV
052551   CLMLEV: *IRR ALEVB DP
052552           A-1; *IRW ALEVB DP
052554           MDATAF=:B; X:=RTREF; CALL BRESERVE
052560           IF A<0 THEN
052561              CALL FREXQU; CALL TOWQU; GO STUPR
052564           FI; BREGC=:B
052566           MAX SHZ -1=:NOWRE; 0=:BHOLD=:FYLLE; MAX=:CFREE
052575           A:=B+"CPARM";X:=MDATAF=:B; T:=7; CALL MTRANS; CALL BRELEASE
052604           BREGC=:B
052606           GO STUPR
052607   RBUS
052616
052616   %==============================================================================
052616   %         C L T R A                 (M)
052616   %
052616   % ROUTINE TO CLOSE LINE-PRINTER/VERSATEC
052616   % MONITOR LEVEL
052616   SUBR CLTRA
052616   CLTRA: X=:B; "IORES"=:MFUNC
052621          CALL MCHDVBUF; GO L4
052623          IF BHOLD><0 THEN
052625                IF CFREE><0 AND PVEFUNC><10 THEN
052633                   12; CALL DBPUT
052635                   IF CFREE >< 0 THEN
052637                      215; CALL DBPUT
052641                   FI
052641                FI
052641                IF BHOLD BIT "0" THEN
052644                  A:=0; CALL DBPUT
052646                  BHOLD
052647                FI
052647                A SHZ -1=:NOWRE; MDATAF=:B
052653                "SRETRANS"=:MFUNC; BREGC+"CPARM"; CALL CMTRANS
052660                "RETRANS"=:MFUNC; BREGC=:B
052664          ELSE
052665                X:=MDATAF=:B; X:=MRTREF; CALL RDATA; BREGC=:B
052673          FI
052673   L3:    IF CURPROG=MDATAF.MRTREF THEN
052700                A:=0; *IRW ALEVB DA
052702          ELSE
052703                X:=T.RTDLGADDR; T:=0; *STZTX XTDAR
052707          FI
052707          IF MDATAF.RTRES><0 THEN X=:B:=A; CALL BRELEASE FI
052715          GO STUPR
052716   L4:    MDATAF=:B; X:=MRTREF; CALL RDATA; BREGC=:B; GO L3
052725
052725   RBUS
052741   *"8DLP1+8DLP2+8DVE1+8DVE2
"052741   %==============================================================================
052741   % 39.7       C L P 1 0    (MPIT)
052741   %
052741   %
052741   % ROUTINE ON LEVEL 10 TO HANDLE INTERRUPT FROM LP.
052741   %
052741   SUBR CLP10
052741   CLP10: B=:X; "LP5MF"-"MFUNC"+B=:B; CALL RTACT; X=:B; CALL ID10; GO CLP10
052752   RBUS
052757
052757
052757   %==============================================================================
052757   % 39.8       X T R D L P     T R D L P      (M)
052757   %
052757   %
052757   % SUBROUTINE ON MONITOR LEVEL TO TRANSFER DATA TO THE DEVICE
052757   %
052757
052757   SUBR XTRDLP,TRDLP
052757
052757   INTEGER WDIO1=?,RSIO1=?,WDIO2=?,RSIO2=?
052757
052757
052757   TRDLP:
052757   XTRDLP: X.S0=:B; 0=:TMR
052762          IF VEFLG><0 THEN
052764                IF PVEFUNC=10 THEN 104 ELSE 4 FI; A=:CIOXC
052774          FI
052774          IF CXBHOLD><0 THEN              % NUMBER OF BYTES IN EXTRA BUFFER
052776             X:=CXHENTE; GO L1
053000          FI
053000   L0:    IF XCBHOLD=0 GO FIN              % NUMBER OF BYTES IN DEVICE BUFFER
053002          IF A<<=CXMAX THEN
053005             % IF THE NUMBER OF BYTES LEFT IN DEVICE BUFFER IS LESS THAN
053005             % CAPACITY OF THE EXTRA BUFFER
053005             % COPY FROM DEVICE BUFFER/ABSTR BUFFER TO EXTRA BUFFER IN DATAFIELD
053005             A:=XCHENTE SHZ -1+XCBUFST=:D; A:=XCBHOLD=:CXBHOLD+1 SHZ -1=:L
053016             A:=MEMA1; T:=CXBUFST;  *MOVPA
053021             IF VEMOD=0 THEN
053023                IF RTRES><0 THEN CALL RTACT FI
053026             FI
053026             IF XCHENTE BIT "0" THEN X:=1 ELSE X:=0 FI
053034             0=:XCBHOLD                          % ODD BYTE LEFT OVER ?
053035   L1:       IOXRS=:RSIO1; IOXWD=:WDIO1
053041             DO
053041                INTEGER RSIO1       % READ STATUS
053042             WHILE A BIT 3
053044                T:=CXBUFST
053045                IF CHCONV><0 THEN
053047                   *LBYT
053050                   CALL CONVCH
053051                ELSE
053052                   *LBYT
053053                FI
053053                INTEGER WDIO1
053054                T:=IOXWC; CIOXC; *EXR ST
053057                X=:A; FOR X:=LPDELAY DO OD; X:=A             % DELAY
053063                X+1; CXBHOLD-1=:CXBHOLD
053067                IF A=0 THEN
053070                   IF XCBHOLD=0 GO PIN1
053072                   GO L0
053073                FI
053073             OD
053074   PIN1:     X=:CXHENTE; T:=IOXWC; CIOXC BZERO 2 BONE "0"; *EXR ST
053102             TTMR=:TMR; GO PSTUPR
053105   *)FILL
053111
053111   FIN:      IF VEMOD><0 THEN
053113                0=:VEMOD
053114                IF A=30 THEN
053117                   11
053120                ELSE
053121                   IF A=31 THEN
053124                      10
053125                   ELSE
053126                         GO L2
053127                FI;FI
053127                A=:PVEFUNC; GO FINX
053131
053131   L2:          1505; T:=IOXWC; *EXR ST
053134                GO PSTUPR
053135                FI
053135   FINX:     IF RTRES><0 THEN CALL RTACT FI
053140             GO PSTUPR
053141          FI
053141          IOXRS=:RSIO2; IOXWD=:WDIO2
053145          DO
053145             INTEGER RSIO2                                    % READ STATUS
053146          WHILE A BIT 3                                       % UNTIL NOT READY
053150             T:=MEMA1; A:=XCHENTE=:D SHZ -1+XCBUFST=:X
053156             *LDATX                                           % FETCH WORD FROM BUFFER
053157             IF D NBIT "0" THEN A SHZ -10 ELSE A/\377 FI      % GET BYTE
053164             MIN XCHENTE
053165             IF T := CHCONV >< 0 THEN
053170                CALL CONVCH                                   % CONVERT BYTE?
053171             FI
053171             INTEGER WDIO2                                    % WRITE DATA
053172             T:=IOXWC; CIOXC; *EXR ST
053175             X=:A; FOR X:=LPDELAY DO OD; X:=A                      % DELAY
053201             XCBHOLD-1=:XCBHOLD
053204             IF A=0 GO PIN2
053205          OD
053206   PIN2:  T:=IOXWC; CIOXC BZERO 2 BONE "0"; *EXR ST
053213          TTMR=:TMR; GO PSTUPR
053216
053216   CONVCH:
053216          A=:D
053217          IF VEFLG><0 AND PVEFUNC=10 THEN A:=D ; EXIT FI
053227          A:=D/\177
053231          X=:D:="CHCONV"
053233          DO
053233                IF T:=X.S0=0 THEN X:=D; EXIT FI
053240                IF A=T THEN X.S1; X:=D; EXIT FI
053245                X+2
053246          OD
053247   RBUS
053256   *"
"053256   %===========================================================================
053256   % 34.21    M C H D V B U F     (M)
053256   %
053256   % SUBROUTINE TO CHECK IF A DEVICE BUFFER IS RESERVED FOR THIS LOGICAL
053256   % DEVICE UNIT BY THE PROGRAM WHICH HAS RESERVED THE LOGICAL
053256   % DEVICE UNIT
053256   %
053256   % ENTRY:     B=ADDRESS OF I/O DATAFILELD
053256   % EXIT:      NO DEVICE BUFFER RESERVED
053256   % EXITA:     DEVICE BUFFER RESERVED
053256   %
053256   SUBR MCHDVBUF
053256   DISP 5; INTEGER LGIOLOG; PSID          % LOGICAL DEVICE NUMBER IN BUFFER
053256
053256   MCHDVBUF:
053256          X=:D
053257          IF ADRBHEAD=0 OR A.RTRES><RTRES OR X.LGIOLOG><CIOLOG THEN
053272             X:=D
053273             EXIT
053274          FI
053274          X:=D; EXITA
053276   RBUS
053276   *"8UDMA+8VICO
"053276   %============================================================================
053276   %        MONITOR LEVEL ENTRY FOR MON UDMA  ON MPIT
053276   %============================================================================
053276   SUBR MUDMA
053276
053276   MUDMA: *IRR ALEVB DT;
053277          IF A < LUDV OR  A >HUDV THEN "240"; GO MERR; FI
053307          CALL LOGPH; A:=D
053311          IF A=0 THEN "33"; GO MERR; FI
053314          IF A.RTRES >< RTREF THEN "5"; GO MERR; FI
053323          A:=X.DFPNT; CALL SWAPPR;
053325          GO MONEN
053326   MERR:  *IRW ALEVB DA
053327          GO MONEN
053330
053330   RBUS
053337   *"
"053337   *"IBL01+IBL02+IBL03+IBL04+IBL05
"053337

053337   %==============================================================================
053337   %     ( M )    I M T R I    I M T R O
053337   %
053337   %
053337   %      MTRANS ROUTINES FOR BLOCK ORIENTED INTERNAL DEVICES. ONLY FUNCTION CODES
053337   %      0, 1 AND 21 ARE VALID.
053337   %
053337   SUBR IMTRI,IMTRO
053337
053337   DISP -3
053337   INTEGER DBLDN                % DBH LOGICAL DEVICE NUMBER: USED AS A FLAG AND FOR LOCKING / UNLOCKING.
053337   INTEGER INWORDS              % NO. OF WORDS IN BUFFER
053337   INTEGER IDFOPP               % ADDRESS OF OUTPUT DATAFIELD
053337   INTEGER POINTER CIFUNC       % POINTER TO FUNCTION CODE
053337   DOUBLE POINTER PDCADDR(2)    % POINTER TO MEMORY (BUFFER) ADDRESS
053337   INTEGER POINTER PNWORDS      % POINTER TO THE PAR. NO. OF WORDS
053337   PSID
053337
053337   INTEGER POINTER LREG; INTEGER XREG
053341
053341   IMTRI: A=:X; X:=:B; A:=L=:"LREG"; 0=:X.HSTAT
053346          IF CIFUNC /\ 77 = 0 THEN
053351   %
053351   %         READ FROM INTERNAL DEVICE.
053351   %
053351             IF X.BREGC >< 0 THEN
053353                0=:X.BREGC                          % BREGC IS USED AS A FLAG: IF >< 0 THERE IS DATA WAITING
053354                IF X.INWORDS < PNWORDS THEN         % TO BE READ IN THE IBD. IF = 0 THERE IS NONE.
053360                   A=:PNWORDS                       % NUMBER OF WORDS IN IBD < NUMBER SPECIFIED.
053361                FI
053361                X=:XREG
053362                IF X.IDFOPP.RTRES >< 0 THEN
053365                   X=:B:=A; CALL RDATA              % OUTPUT DATAFIELD IS RESERVED.
053370                   A:=XREG=:B; A:=DBLDN; CALL LOGPH
053374                   IF A = 0 THEN CALL ERRFATAL FI
053376                   A=:B; 1=:DKFUN                   % CHANGE FUNCTION CODE IN DBH TO WRITE
053401                   CALL BRESERVE                    % RESERVE DBH FOR RT-PROG OWNING OUTPUT DATFIELD.
053402                   IF A < 0 THEN
053403                      CALL FREXQ; CALL TOWQU        % PUT THE RT-PROG INTO WAITING QUEUE FOR DBH.
053405                   FI
053405                FI
053405                XREG=:B; X:=RTRES; GO LREG
053411             FI
053411             X=:B; A:=DBLDN
053413   CALLWDATA:CALL LOGPH
053414             IF A = 0 THEN CALL ERRFATAL FI
053416             B=:D; A=:B; X:=RTRES; CALL BRELEASE
053422             B:=D; X:=RTRES; CALL WDATA             % SET THE CALLING PROGRAM INTO I/O WAIT.
053425             IF X=RTREF THEN
053430                *IRR ALEVB DP
053431                A-1; *IRW ALEVB DP                  % DECREMENT THE P-REG ON APPLICATION LEVEL.
053433                GO RWAIT
053434             FI
053434             X:=X.RTDLGADDR; T:=0; *LDATX XTDPR
053437             A-1; *STATX XTDPR
053441             GO MONEN
053442          FI
053442   %
053442   %      NOT READ: IS FUNCTION CLEAR DEVICE?
053442   %
053442          IF A=21 THEN
053445             0=:X.DBLDN=:BREGC                      % CLEAR DEVICE: CLEAR DBH LDN AND DATA IN BUFFER FLAG.
053447          ELSE
053450             20=:X.HSTAT                            % INDICATE ILLEGAL FUNCTION.
053452          FI
053452          X=:B:=RTRES; EXIT
053455   %
053455   %      WRITE TO IBD.
053455   %
053455   IMTRO: A=:X; X:=:B; A:=L=:"LREG"; 0=:X.HSTAT
053462          IF CIFUNC/\77 >< 1 THEN
053467             20=:X.HSTAT; X=:B:=RTRES; EXIT         % FUNCTION NOT WRITE: INDICATE ILLEGAL FUNCTION CODE.
053474          FI
053474          X=:XREG
053475          IF X.IDFOPP.BREGC >< 0 THEN
053500             A:=X.DBLDN; X:=XREG=:B
053503             GO CALLWDATA                           % WAIT UNTIL DATA HAS BEEN READ BEFORE WRITING NEW DATA.
053504          FI                                        % X-REG NOW POINTS TO INPUT PART.
053504          1=:X.BREGC                                % FLAG IBD AS CONTAINING DATA.
053506          PNWORDS=:X.INWORDS
053510          IF X.RTRES >< 0 THEN
053512             X=:B; A=:X; CALL RDATA; A:=DBLDN; CALL LOGPH
053517             IF A = 0 THEN CALL ERRFATAL FI
053521             A=:B; 0=:DKFUN; CALL BRESE             % FUNCTION TO BE CONTINUED IS READ.
053524             IF A < 0 THEN
053525                CALL FREXQ; CALL TOWQU
053527             FI
053527          FI
053527          X:=XREG=:B:=RTRES; GO LREG
053533   RBUS
053547

053547   *"8ACC                                 % CPU-TIME USED FOR USER RT-PROGRAMS
"053547   %============================================================================
053547   %      ( M )        N A C C O U N T
053547
053547   SUBR NACCOUNT
053547   %% RT-ACCOUNTING                                 % USER RT-PROGRAM
053547   NACCOUNT: IF A:=CURPROG>>="9FBPR" THEN EXIT FI   % BG PROG.
053554          IF A >>="RTBES" GO NN2                    % USER PROG.
053557          IF      A="RWRT1" THEN A:="DF1".SSREF
053564          ELSE IF A="RWRT2" THEN A:="DF2".SSREF
053572          FI FI
053572   NN1:   IF A << "RTBES" THEN EXIT;FI              % NOT USER RT-PROGRAM
053576
053576   NN2:   A-"RTBES"=:D:=0;T:=5RTSIZE;*RDIV ST       % COMPUTE USER RT-DESC INDEX
053603          A=:D SHZ  1 +D+ ACTAB=:X                  % ACCOUNT ENTRY
053610          T:=GLTMBANK; *LDATX
053612          IF A><0 THEN
053613              *LDDTX 10
053614              D+1; A:=A+C
053616              *STDTX 10
053617          FI
053617          EXIT
053620   *)FILL
053631   *"-8ACC
"053631   RBUS
053631
053631   *"8LOG+8HIST
"053631   %==============================================================================
053631   %     ( M )    L O G 1
053631   %
053631   % ROUTINES TO GATHER SYSTEM AND PROGRAM STATISTICS
053631   % CALLED FROM TERMINAL OUTPUT DRIVER (LEVEL 10)
053631   % THE INFORMATION IS USED BY THE COMMAND "RT-PROGRAM-LOG"
053631   %
053631   SUBR LOG1,SHISTI
053631
053631   %========================================================================%
053631   % NOTE: THESE DISPLACEMENTS CORRESPONDS TO THE DATA STRUCTURE DEFINED    %
053631   %       IN THE HISTOGRAM AND LOGGING COMMANDS ON THE COMMAND SEGMENT.    %
053631   %       DO NOT CHANGE THIS DEFINITIONS WITHOUT DOING THE SAME CHANGE     %
053631   %       IN THE COMMAND ROUTINES!                                         %
053631   %========================================================================%
053631   DISP -13
053631   INTEGER HTOT1,HTOT2          % TOTAL NUMBER OF SAMPLES
053631   INTEGER STLT1,STLT2          % COUNTS BACKGROUND PROGRAM EXECUTING ON RING 2/3
053631   INTEGER HISTPROG             % PROGRAM TO DO HISTOGRAMING ON
053631   INTEGER HISTART              % FLAG >< 0 WHEN HISTOGRAM IS STARTED
053631   INTEGER FPREG                % ADDR OF FIRST HISTOGRAM INTERVAL
053631   INTEGER DELTA                % SIZE OF EACH HISTOGRAM INTERVAL
053631   INTEGER HISTFLAG             % FLAG >< 0 WHEN SYSTEM-HISTOGRAM
053631   INTEGER CHILEV               % "IRR XX DP" INSTRUCTION
053631   INTEGER FLGHIST              % FLAG FOR COMMANDS ROUTINES
053631   PSID
053631
053631   DISP 0
053631   INTEGER ACTC1,ACTC2                % CPU ACTIVE
053631   INTEGER ACTP1,ACTP2                % TARGET PROGRAM ACTIVE (USING CPU)
053631   INTEGER SWC1,SWC2                  % SWAPPER IN USE
053631   INTEGER SWP1,SWP2                  % SWAPPER IN USE BY TARGET PROGRAM
053631   INTEGER FILC1,FILC2                % FILESYSTEM IN USE
053631   INTEGER FILP1,FILP2                % FILESYSTEM IN USE BY TARGET PROGRAM
053631   INTEGER DIC1,DIC2                  % MAIN SWAP-DISC IN USE
053631   INTEGER PASP1,PASP2                % TARGET PROGRAM PASSIVE
053631   INTEGER IOWP1,IOWP2                % TARGET PROGRAM IN I/O WAIT
053631   INTEGER TOTL1,TOTL2                % TOTAL NUMBER OF SAMPLES
053631   INTEGER U1T1,U1T2                  % ADDITIONAL LOG.UNIT #1 USED
053631   INTEGER U1P1,U1P2                  % ADDITIONAL LOG.UNIT #1 USED BY TARGET PROGRAM
053631   INTEGER U2T1,U2T2                  % ADDITIONAL LOG.UNIT #2 USED
053631   INTEGER U2P1,U2P2                  % ADDITIONAL LOG.UNIT #2 USED BY TARGET PROGRAM
053631   INTEGER ADRSWP,ADRU1,ADRU2         % ADDRS OF DATAFIELDS
053631   INTEGER LOGPROG                    % RT-DESCR OF TARGET PROGRAM
053631   INTEGER PTOT1,PTOT2
053631   INTEGER XINCR,CINCR
053631   PSID
053631   *"8LOG
"053631   INTEGER CSVB=?
053631   LOG1:  MIN "LGARR".CINCR; EXIT; X.XINCR=:X.CINCR % CINCR=INTERRUPTS BETWEEN SAMPLES
053636          X:=:B=:CSVB
053640          IF COMRTP=0 GO FAR TALLRTP                % IS IT PROGRAM LOG?
053643          IF LOGFIELD.RTRES><"F1202".RTRES THEN     % IS THE LOGGING SEMAPHORE STILL RESERVED BY THE ACTUAL PROGR?
053651             IF ALLRTP=0 THEN 0=:LOGFIELD=:MNLOGFI FI % NO
053655             0=:COMRTP                              % MARK RT-PROGRAM-LOG TERMINATED (BY ESCAPE)
053656             GO OUT
053657          FI; *TRA PVL
053660          IF A SH 11 SHZ -14><0 THEN                % CPU ACTIVE (PREVIOUS LEVEL NOT ZERO)
053663             *MIN ACTC2,B; SKP; MIN ACTC1,B; RAND
053667             IF LOGPROG=CURPROG THEN                % ANY TARGET PROGRAM DEFINED AND TARGET PROGRAM ACTIVE?
053673                 *MIN ACTP2,B; SKP; MIN ACTP1,B; RAND % YES
053677             FI
053677          FI
053677          IF "CLFIE".RTRES><0 AND A><"1SWAP" THEN   % ND-100 SWAPPER RESERVED?
053705             *MIN SWC2,B; SKP; MIN SWC1,B; RAND     % YES
053711             IF A=LOGPROG AND A><CURPROG THEN       % ANY TARGET PROGRAM DEFINED AND TARGET PROGRAM USING SWAPPER?
053717                *MIN SWP2,B; SKP; MIN SWP1,B; RAND  % YES
053723             FI
053723          FI; GO LOG2; *)FILL
053736
053736   INTEGER CSVB
053737   OUT:   CSVB=:B; EXIT
053742
053742   LOG2:
053742          IF ADRSWP.STPRW=:D><0 THEN                % MAIN-SWAP DEVICE RESERVED?
053746             *MIN DIC2,B; SKP; MIN DIC1,B; RAND     % YES
053752             IF "CLFIE".RTRES=0 OR A="1SWAP" THEN   % USED FOR SWAPPING?
053760                *MIN FILC2,B; SKP; MIN FILC1,B; RAND % NO, ASSUME USED FOR FILE-SYSTEM
053764                IF D=LOGPROG THEN                   % FILE-SYSTEM USED BY TARGET-PROGR?
053767                   *MIN FILP2,B; SKP; MIN FILP1,B; RAND % YES
053773                FI
053773             FI
053773          FI
053773          IF X:=LOGPROG><0 THEN                     % ANY SPECIFIC TARGET PROGRAM?
053775             IF X.WLINK=0 THEN                      % YES, IS IT PASSIVE (IDLE)?
053777                *MIN PASP2,B; SKP; MIN PASP1,B; RAND % YES
054003             FI
054003             IF X.STATUS BIT 5WAIT THEN             % IS IT IN I/O WAIT?
054006                *MIN IOWP2,B; SKP; MIN IOWP1,B; RAND % YES
054012             FI
054012          FI; *MIN TOTL2,B; SKP; MIN TOTL1,B; RAND  % INCREMENT TOTOAL NUMBER OF SAMPLES
054016          IF X:=ADRU1><0 THEN                       % ANY ADDITIONAL LOG.UNIT #1 DEFINED?
054020             IF X>>="9FDFD" AND X<<"9EDFD" THEN     % DISK
054026                X.STPRW                             % DISK SORTING/PARALLEL SEEK
054027             ELSE
054030                X.RTRES
054031             FI
054031             IF A><0 THEN                           % IS IT RESERVED?
054032                *MIN U1T2,B; SKP; MIN U1T1,B; RAND  % YES
054036                IF A=LOGPROG THEN                   % RESERVED BY THE TARGET PROGRAM?
054041                   *MIN U1P2,B; SKP; MIN U1P1,B; RAND % YES
054045                FI
054045             FI
054045          FI
054045          IF X:=ADRU2><0 THEN                       % ANY ADDITIONAL LOG.UNIT #2 DEFINED?
054047             IF X>>="9FDFD" AND X<<"9EDFD" THEN     % DISK
054055                X.STPRW                             % DISK SORTING/PARALLEL SEEK
054056             ELSE
054057                X.RTRES
054060             FI
054060             IF A><0 THEN                           % IS IT RESERVED ?
054061                *MIN U2T2,B; SKP; MIN U2T1,B; RAND  % YES
054065                IF A=LOGPROG THEN                   % RESERVED BY THE TARGET PROGRAM?
054070                   *MIN U2P2,B; SKP; MIN U2P1,B; RAND  % YES
054074                FI
054074             FI
054074          FI; GO TALLRTP; *)FILL
054101
054101   INTEGER POINTER PCSVB:=CSVB
054102
054102   TALLRTP: IF ALLRTP=0 GO FAR OUT
054105          IF LOGPROG><"F1352".RTRES GO OUT
054112          CURPROG-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
054120          A SH 1; T:=MBLGARR; X:=ALGARR+A; *LDDTX
054125          D+1; A:=A+C; *STDTX
054130          *MIN PTOT2,B; SKP; MIN PTOT1,B; RAND
054134   *"8LOG 8HIST
"054134          IF "HISTO".HISTPROG><LOGPROG OR X.FLGHISTO=0 OR X.HISTART><0 GO FAR OUT
054146          *1BANK
054147          PCSVB=:B; *2BANK
054152          *TRA PVL
054153          A SHZ -3/\17=:D
054156          A SH 1+"SLVTB"=:X
054161          *MIN 1,X; SKP; MIN ,X; RAND
054165          IF "HISTO".CHILEV SHZ -3/\17><D GO FAR OUT
054173          GO IHIST
054174   *"8HIST
"054174   %=============================================================================
054174   %      ( M )    S H I S T I
054174   %
054174   % ROUTINE CALLED FROM LEVEL 13 FOR HISTOGRAM SAMPLING.
054174   % ACTIVATED EITHER BY THE @DEFINE-SYSTEM-HISTOGRAM COMMAND
054174   % OR BY THE @DEFINE-HISTOGRAM/@START-HISTOGRAM COMMAND
054174   %
054174   SHISTI:IF "HISTO".HISTFLAG><0 THEN               % @DEFINE-SYSTEM-HISTOGRAM
054177   IHIST:    T:=X.CHILEV; *EXR ST
054201             A-X.FPREG=:D:=0; T:=X.DELTA; *RDIV ST
054206             IF A>>=100 THEN A:=100 FI
054212             X:="HISTO"+A+A
054215             *MIN 1,X; SKP; MIN ,X; RAND
054221             X:="HISTO"
054222             *MIN HTOT2,X; SKP; MIN HTOT1,X; RAND
054226             EXIT
054227          FI
054227          IF X.HISTART><0 AND X.HISTPROG=CURPROG THEN    % ORDINARY HISTOGRAM
054235             IF BACKGROUND=0 OR CURPROG.ACTPRI/\3=0 THEN
054243                *IRR ALEVB DP
054244                A-"HISTO".FPREG=:D:=0; T:=X.DELTA; *RDIV ST
054252                IF A>>=100 THEN A:=100 FI
054256                X:="HISTO"+A+A
054261                *MIN 1 ,X; SKP; MIN ,X; RAND
054265                X:="HISTO"
054266             ELSE
054267                X:="HISTO"
054270                *MIN STLT2,X; SKP; MIN STLT1,X; RAND
054274             FI; *MIN HTOT2,X; SKP; MIN HTOT1,X; RAND
054300          FI; EXIT
054301   RBUS
054315
054315   *"8DILG
"054315
054315   %===========================================================================
054315   %            M L D I L
054315   %
054315   % MONITOR LEVEL ROUTINE TO START OR STOP THE DISC ACCESS LOG RT-PROGRAM
054315   %
054315   SUBR MLDIL
054315   MLDIL:  IF "RTDIL".WLINK><0 THEN                     % ALREADY RUNNING
054320              IF "DFDIL".DILGFLAG NBIT DILIABSTR THEN   % NOT EXECUTING MON ABSTR
054324                 "RTDIL".STATUS BZERO 5WAIT=:X.STATUS   % RESTART PROGRAM
054330              FI
054330           ELSE
054331              CALL RTENTRY                              % NOT RUNNING, START IT
054332          FI; GO MONEN
054333   RBUS
054337
054337   *"8DIR
"054337

054337   %==============================================================================
054337   % 37.8.1     B U S E X
054337   %
054337   %      BUS EXTENDER DRIVER FOR LEVEL 13
054337   %
054337   %      ON ENTRY:             A = IDENTCODE - 1
054337   %
054337
054337   SUBR BUSEX
054337
054337
054337   INTEGER BEXNO, BEXHDEV, LPES
054342
054342   BUSEX: *IOF
054343          A - 7 =: BEXNO                  % BEXNO CONTAINS EXTENDER NO.
054345          A SH 2 + HDEV =: T =: BEXHDEV   % T=BEXHDEV=DEVNO OF CALLING BEX
054351          X := "B14"                      % X POINTS TO BASE-FIELD FOR ENT14
054352          *TRA PVL
054353          A =: D; *EXR SA                 % GET PERR
054355          A =: X.PERR                     % TO E14.PERR
054356          A := D SH 11 SHZ -14 =: X.ACTLV % TO E14.ACTLV
054362          A := 2; T + "DCONT"; *IOXT      % ENABLE NEW INTERRUPT
054365          T + "DST-DCONT"; *IOXT          % READ BEX STATUS
054367          IF A BIT 14 GO PFINT            % POWER FAIL?
054371          IF A BIT 12 GO ILPARITY         % MEMORY PARITY ERROR?
054373          BEXNO; CALL 9ERR (#48)          % ERROR MESSAGE
054376   UTBEX: *ION
054377          CALL ID13                       % WAIT FOR INTERRUPT
054400          GO BUSEX
054401
054401   %%%    POWER FAIL
054401
054401   PFINT: 12 =: X.IBITNO                  % TO E14.IBITNO
054403          CALL 9ERR (#49)                 % ERROR MESSAGE
054405          GO UTBEX
054406
054406   %%%    MEMORY ERROR
054406
054406   ILPARITY: 10 =: X.IBITNO                  % TO E14.IBITNO
054410          T := BEXHDEV + "DCONT"          % T = DEV.NO OF INTERRUPTING BEX
054412          A:=2; *IOXT                     % ENABLE FOR NEXT INTERRUPT
054414          T + "DDR-DCONT"; *IOXT          % READ LOCAL PES-REGISTER
054416          A =: LPES := 102                % SAVE CODE
054420          T + "DCONT-DDR"; *IOXT          % ENABLE FOR READING LOW LIM.
054422          T + "DDR-DCONT"; *IOXT          % READ LOW LIM.
054424          A /\ 377 + LPES =: X.PESERR     % STORE IN E14.PESERR
054427          A:=42; T + "DCONT-DDR"; *IOXT   % ENABLE FOR READING LOCAL PEA.
054432          T + "DDR-DCONT"; *IOXT          % READ LOCAL PEA
054434          A =: X.PEAERR                   % TO E14.PEAERR
054435          BEXNO; CALL 9ERR (#70)          % ERROR MESSAGE
054440          "EFJOB"; *IRW 160 DP            % SET LEV.14 P-REG
054442          "40000"; *MST PIE; MST PID      % ENABLE/WAKE LEVEL 14
054445          GO UTBEX
054446
054446   RBUS
054455
054455   *"8MPM4
"054455   %==============================================================================
054455   %                   BUSCD
054455   %
054455   %      MPM4 INTERRUPT HANDLER FOR LEVEL 13D
054455   %
054455   %      ON ENTRY:               A = IDENTCODE - 1
054455   %
054455
054455   SUBR BUSCD
054455
054455
054455   INTEGER POINTER IROUT:=ROUTI
054456   INTEGER BUSCNO,BUSST,LLIM,LPES,LPEA
054463
054463   BUSCD: *IOF
054464          A-017=:BUSCNO SHZ 2 + HDEV + 2 =:T; * IOXT          % READ BUSC STATUS
054473          A=:BUSST
054474          IF A BIT 7 GO PFINT                       % MPM4 POWER FAIL
054476          IF A BIT 6 GO MOOR                        % MEMORY OUT OF RANGE
054500          IF A BIT 5 GO ILPARITY                    % PARITY ERROR
054502          CALL IROUT                                % RE-INIT INTERRUPT
054503          A:=BUSCNO; T:=BUSST; CALL 9ERR(#71)       % ILLEGAL BUSC INTERRUPT
054507   RETUR: *ION
054510          CALL ID13                                 % WAIT FOR INTERRUPT
054511          GO BUSCD
054512
054512   PFINT: A:=BUSCNO; CALL 9ERR(#72); GO RETUR       % MPM4 POWER FAIL INTERRUPT
054516
054516   MOOR:  CALL IROUT
054517          A:=BUSCNO; T:=LLIM; CALL 9ERR(#73)        % MPM4 MEMORY OUT OF RANGE
054523   MOOR1: A:=LPES; T:=LPEA; CALL 9ERR(#74); GO RETUR  % WRITE PES AND PEA
054530
054530   ILPARITY: CALL IROUT
054531          IF BUSST BIT 4 GO WRPAR
054534          A:=BUSCNO; T:=LLIM; CALL 9ERR(#75)        % MPM4 MEMORY ERROR
054540          GO MOOR1
054541
054541   WRPAR: A:=LPES SHZ -010 /\ 017 =:T               % WRITE-PARITY ERROR
054545          A:=BUSCNO; CALL 9ERR(#76); GO RETUR
054551
054551   ROUTI: A:=0; T:=T+1; * IOXT                      % PREPARE READ LPES
054554          T:=T-3; * IOXT                            % READ LPES
054556          A=:LPES
054557          A:=040; T:=T+3; * IOXT                    % PREPARE READ LPA
054562          T:=T-3; * IOXT                            % READ LPEA
054564          A=:LPEA
054565          A:=0106; T:=T+3; * IOXT                   % PREPARE READ LIMITS
054570          T:=T-3; * IOXT                            % READ LIMITS
054572          A /\ 0377 =:LLIM
054574          EXIT
054575
054575   RBUS
054602
054602   *"8COSP
"054602   %===========================================================================
054602   %  (M)     C O S P S
054602   %
054602   %  START ADDRESS OF COSMOS SPOOLING RT-PROGRAM.
054602   %  STARTED ON MPIT, GET ADRESS OF SPOOLING DATAFIELD, CHANGE TO
054602   %  NUPIN AND GO TO START-ADDRESS ON SEGMENT.
054602   SUBR COSPS
054602   COSPS:  *IOF
054603           "MCOSPS"; *IRW MLEVB DP
054605           MLEV; *MST PID; ION
054610           CALL ERRFATAL
054611   MCOSPS: "COSDA"; *IRW ALEVB DA                % ADDRESS OF SPOOLING DATAFIELD
054613           "0"; *IRW ALEVB DP                    % START ADDRESS ON SEGMENT
054615           "NUPIN+AUPIN+ALEVB+ERNG2"
054616           A=:CURPROG.ACTPRI; *TRR PCR           % NEW ACTPRI
054621           GO MONEN
054622   RBUS
054630   *"
"054630
054630   @DEV 1
054630   @DEV (S-S-L)MP-P2-TERM-DRIV:NPL
054630

054630   %==============================================================================
054630   %      M P - P 2 - T E R M - D R I V
054630   %==============================================================================
054630   %
054630   %      PREDECLARATIONS
054630   %
054630   SUBR WDX, M8RET, TERWD
054630   RBUS
054630   %==============================================================================
054630   % 37.2       S T T I N   T Y E N T
054630   %
054630   % TERMINAL INPUT DRIVER, LEVEL 12
054630   %
054630   % THE X-REGISTER MUST POINT TO THE OUTPUT DATAFIELD IN ALL THE
054630   % ROUTINES CALLED BY THIS DRIVER
054630   %
054630   SUBR STTIN,TYENT,BFYICOMDRIVER
054630   SYMBOL 5PIP=17
054630   STTIN:  TTMR=:TMR
054632   RETURN: CALL ID12                                % WAIT FOR INTERRUPT
054633   TYENT: ISTATE=:IISTATE; CALL SET12WINDOW
054636          IF BRKMODE=12 GO BFYICOMDRIVER
054642          IF DFOPP><0 THEN X:=1777; X/\A; A:=B/\176000+X FI
054651          A=:12DFOPP; A.BITFLAG BZERO 5CLOU=:X.BITFLAG
054656   NXCHR: X:=12DFOPP
054657          CALL TIAPD; GO RETURN                     % READ CHARACTER
054661          IF T:="ROUSPEC"><0 THEN
054664             D:=0; CALL ROUSPEC; GO NXCHR; GO OKCHAR
054670          FI; A=:LAST                               % SAVE IN DATAFIELD
054671          CALL XONREAD; GO NXCHR
054673   OKCHAR: BRECHOFL/\177770=:BRECHOFL               % CLEAR BREAK/ECHO FLAG
054676          A := LAST/\377; CALL XONCHECK             % TEST FOR XON/XOFF OUT.
054701          IF DFLAG BIT 5CAPITAL THEN                % CONVERT LOWER CASE TO UPPER CASE
054704             LAST/\177=:T
054707             IF 140<T AND 176>T AND CESCP SHZ -10/\177><T AND CESCP/\177><T THEN
054726                LAST BZERO 5=:LAST                  % CONVERT ALL EXEPT
054731             FI                                     % RUBOUT  AND DISCONNECT
054731          FI
054731          IF X><0 AND X.SCREEN><0 THEN              % TWO WAY DEVICE WITH CR-DELAY
054734                IF <0 THEN -1=:X.TMR FI
054737                1=:X.SCREEN
054741                IF LAST=0 THEN                      % IGNORE TAPE-FEED?
054743                  IF FLAGB NBIT 5LCHAR GO NXCHR
054746                  IF CESCP SHZ-10><0 GO NXCHR
054751                FI
054751          FI
054751          IF T:=DFLAG NBIT 5SPEC AND T NBIT 5CTRLO THEN
054756             CALL ESCAPE; GO NXCHR; X:=12DFOPP
054761          FI
054761          IF DFLAG NBIT 5CTRLO THEN
054764             IF LAST/\177=17 THEN
054771                DFLAG BONE 5CTRLO=:DFLAG
054774             FI
054774          ELSE
054775             DFLAG BZERO 5CTRLO=:DFLAG
055000          FI
055000          IF CFREE=0 THEN
055002             TINFO BONE 5BFUL=:TINFO; GO BFULL      % BUFFER IS FULL, RESTART USER
055006          FI
055006          GO L1; *)FILL
055025   L1:   *IOF
055026          IF DFLAG BIT 5ECHO THEN
055031               LAST/\377
055033               CALL TECHO                 %TEST FOR ECHO
055034               CALL TBREAK                %TEST FOR BREAK
055035               X:=12DFOPP
055036          ELSE
055037               IF IISTATE=-1 THEN; *ION   % NOWAIT MODE
055044                  LAST/\377; CALL CXRBPUT; GO BFULL
055050               FI
055050          FI
055050         *ION
055051          IF BRECHOFL BIT 5ECHO THEN CALL ECHSUBR FI             % ECHO CHAR?
055055          IF BRECHOFL<0 THEN 7=:LAST; CALL ECHSUBR; GO RETU FI   % IGNORE CHAR?
055063
055063   ADDCH: LAST/\377; CALL CXRBPUT                   % PUT CHARACTER IN BUFFER
055066
055066          IF CFREE<20 AND BRECHOFL NBIT 5BREAK GO BFULL % FULL BUFFER
055075          IF BRECHOFL BIT 5BREAK THEN               % BREAK ACCORDING TO STRATEGY
055100             DFLAG BZERO 5ECHO                      % ECHO OFF IN DRIVER
055102             IF X:=FYLLE=HENTE THEN
055106                A BONE 5ALEC                        % WHOLE BUFFER IS ECHOED BY DRIVER
055107             ELSE
055110                A BZERO 5ALEC                       % PART OF BUFFER MUST BE ECHOED BY IOTRANS
055111             FI; A=:DFLAG; X=:RSISTE                % RSISTE IS FIRST CHARACTER NOT ECHOED
055113          ELSE
055114             IF DFLAG BIT 5XOFF GO BFULL            % MAKE SHURE THAT BUFFER IS EMPTIED WHEN XOFF
055117             GO RETU
055120          FI
055120
055120   BFULL: CALL TSTBACK                              % RESTART PROGRAM
055121   *"8N500
"055121          IF X:=IN5MSG >< 0 THEN
055123                T:=5MBBANK; *AAX MLFLA; LDATX
055126                IF A=0 THEN
055127                   A:=1; *STATX
055131                   "IBMOVE"; CALL CXRTACT
055133                FI
055133          ELSE
055134   BYP1:        IF IISTATE=-1 OR A=-2 THEN; *IOF
055144                   CALL PNW5ST; GO XRETU; *ION
055147                FI
055147                "IORESTART"; CALL CXRTACT
055151          FI
055151   *"
"055151   *"-8N500
"055151
055151   RETU:  IF "ROUSPEC"><0 THEN
055153             D:=1; X:=12DFOPP; CALL ROUSPEC; GO FAR OKCHAR
055157          FI
055157          GO FAR NXCHR
055160   XRETU: *ION
055161          GO RETU
055162   *)FILL
055201   %
055201   %%  ECHO:
055201   INTEGER  LREG
055202   ECHSUBR: *IOF
055203          A:=L=: LREG
055205          IF X.CFREE=0 THEN
055207             *ION
055210             GO FAR NXCHR
055211          FI
055211          IF X.MINBHOLD BIT 5BLOC THEN    % OUTPUT BUFFER LOCKED
055214             DFLAG BZERO 5ECHO=:DFLAG; BRECHOFL BZERO 5BREAK=:BRECHOFL
055222             -1=:RSISTE; *ION
055225             GO FAR ADDCH
055226          FI
055226          LAST/\377; X:=:B
055231          IF T:=BITFLAG BIT 5EMPT AND T:=X.DFLAG NBIT 5OXON THEN
055237             IF T:=X.TINFO BIT 5ENABLE THEN CALL PRCHA; GO ECRET FI
055244             CALL ECAPD
055245          ELSE
055246   PIBUF:    CALL CXRBPUT
055247          FI
055247   ECRET: X:=:B; LREG =: L
055252          *ION
055253          EXIT; *)FILL
055262
055262
055262   ECAPD: A=:D; T:=HDEV+DST; *IOXT                      % READ STATUS
055266          IF A BIT 3 THEN                               % READY FOR TRANSFER
055270             D=:A; T-DST+DDW; *IOXT                     % WRITE CHARACTER
055274             "DACT"; T-DDW+DCONT; *IOXT                 % ACTIVATE
055300             EXIT
055301          ELSE                                          % NOT READY
055302             BITFLAG BZERO 5EMPT=:BITFLAG
055305             "DACT+DPIN"
055306             T-DST+DCONT; *IOXT                         % ACTIVATE AND PIN
055311             D=:A; GO PIBUF                             % ECHO VIA OUTPUT-BUFFER
055313          FI
055313          EXIT
055314   RBUS
055314
055314   %=====================================================================
055314   %            X O F T R
055314   %      37.20
055314   %
055314   % THIS ROUTINE IS AN ALTERNATIVE TO NORMAL XOFF/XON CHECKING AND
055314   % REQUIRES XOFF/XON TO BE IN SEQUENCE. ANY OTHER COMBINATION WILL
055314   % BE TREATED AS NORMAL DATA CHARACTERS.
055314   % THE ROUTINE IS ACTIVATED BY ENTERING IT'S ADDRESS IN THE ROUSPEC
055314   % LOCATION IN THE TERMINAL INPUT DATAFIELD. THE ROUTINE IS CALLED
055314   % AT THE START (D=0) AND AT THE END (D=1) OF THE DRIVER.
055314   % FIRST PART (D=0) PERFORMS THE XOFF/XON CHECKING WILE THE LAST PART
055314   % (D=1) PERFORMS BRANCHING ACCORDING TO RESULTS FROM FIRST PART.
055314
055314   SUBR XOFTR
055314   SYMBOL IXOFF=3,IDATA=4,OPIN=5
055314   XOFTR: IF T:=DFLAG BIT 5XDEVICE THEN   % XOFF/XON CHECKING FOR THIS TERMINAL?
055317             IF D=0 THEN                                      % TEST CHARACTERS
055321                A=:LAST BZERO 7=:D
055324                IF T:=BRECHOFL NBIT IXOFF THEN      % X O F F   T E S T
055327                   IF X.XOFCR=D THEN
055332                      T BONE IXOFF BZERO IDATA=:BRECHOFL
055335                      CNTREG BZERO 2=:CNTREG; T:=HDEV+DCONT; *IOXT
055343                      T:=DFLAG BONE 5OXON=:DFLAG              % STOP OUTPUT
055346                      0=:X.TMR; L-1
055350                   FI; A:=LAST; EXITA
055352                ELSE                                % X O N   T E S T
055353                   IF D=X.XONCR THEN                          % IGNORE CHARACTERS
055356                      T:=BRECHOFL BZERO IXOFF BZERO IDATA=:BRECHOFL
055362                      CNTREG BONE 2=:CNTREG; T:=HDEV+DCONT; *IOXT
055370                      T:=DFLAG BZERO 5OXON=:DFLAG
055373                      T:=X.HDEV+DCONT
055375                      A:=1; *IOXT                             % PIN OUTPUT
055377                      EXIT
055400                   ELSE
055401                      A SHZ 10+X.XOFCR=:LAST                  % DATA CHARACTERS
055404                      T:=BRECHOFL BONE IDATA BZERO IXOFF=:BRECHOFL
055410                      EXITA
055411                   FI
055411                 FI
055411             ELSE                                   % R E T U R N   C H E C K
055412                IF T:=BRECHOFL BIT IDATA THEN
055415                   T BONE OPIN BZERO IDATA=:BRECHOFL
055420                   LAST SHZ -10=:LAST
055423                   EXIT                                       % NEW CHARACTER
055424                FI
055424                IF T:=BRECHOFL BIT OPIN THEN
055427                   T BZERO OPIN=:BRECHOFL
055431                   CNTREG BONE 2=:CNTREG; T:=HDEV+DCONT; *IOXT
055437                   DFLAG BZERO 5OXON=:DFLAG
055442                   T:=X.HDEV+DCONT
055444                   A:=1; *IOXT                                % PIN OUTPUT
055446                FI
055446                EXITA
055447             FI
055447          ELSE
055450             IF D=0 THEN
055452                A=:LAST; BRECHOFL/\177707=:BRECHOFL
055456             FI
055456          FI
055456          EXITA
055457   RBUS
055460

055460
055460   %============================================================================
055460   %      TUNING VARIABLES FOR TERMINAL OUTPUT DRIVER
055460
055460   INTEGER ARRAY NWR100=?                 % MAX NO OF CHARS. IN CORR. MODE ND-100
055460   *"8N500
"055460   INTEGER C5LFIFO=?                      % IF ><0 STATES MAX NO OF CHAR. TO COPY
055460   INTEGER C5LPLAIN=?                     % IF ><0 STATES MAX NO OF CHAR. TO COPY
055460   INTEGER ARRAY NWR500=?                 % MAX NO OF CHARS. IN CORR. MODE ND-500
055460   *"
"055460   %-----------------------------------------------------------------------------
055460   %      VARIABLES USED BY TERMINAL OUTPUT DRIVER
055460
055460   INTEGER WRCH=?                         % NUMER OF CHARACTERS TO WRITE
055460   INTEGER EBHO=?                         % NO OF CHARACTERS TRANSFERED
055460   INTEGER CBHOL=?                        % NUMBER OF BYTES/WORDS TO WRITE
055460   INTEGER TRMOD=?                        % TERMINAL MODE (0-3)
055460
055460   %==============================================================================
055460   % 37.4       D W R I T E     T W R I T E
055460   %
055460   % DRIVER ROUTINE FOR TERMINAL-INTERFACES ON LEVEL 10!
055460   % THE SAME DRIVER IS USED BOTH FOR OLD AND NEW (FIFO) TERMINALS.
055460
055460   % THE X-REGISTER MUST POINT TO THE INPUT DATAFIELD (X=DFOPP)
055460   % IN ALL THE ROUTINES CALLED BY THE OUTPUT DRIVER
055460
055460   SUBR DWRITE,TWRITE,DHIST
055460
055460   SYMBOL SUFFS=5               % SUFFICIENT SPACE FOR ECHO
055460
055460   *"8LOG
"055460   %------------------------------------------------------------------------------
055460   % LOCAL SUBROUTINE TO CHECK IF RT PROG LOG IS ACTIVATED FOR THIS TERMINAL.
055460   % IF OUTPUT BUFFER IS EMPTY, A DUMMY CHARACTER IS WRITTEN, ELSE TRMOD IS
055460   % SET TO 4, CAUSING ONLY ONE CHARACTER TO BE WRITTEN PR INTERRUPT.
055460   %
055460   INTEGER POINTER RETAD
055461   *"
"055461   CHLOG:
055461   *"8LOG
"055461          IF LOGFIELD=TDRADDR OR MNLOGFI=T THEN     % RT-PROGRAM LOG ACTIVATED
055470             A:=L=:"RETAD"
055472             CALL LOG1                              % DO SAMPLING
055473             IF BHOLD=0 AND ON5MSG=0 THEN           % NO CHARACTERS ON OUTPUT
055477                T:=HDEV+DDW; A:="0"; *IOXT          % WRITE ZERO TO CONTINUE INTERRUPTS.
055503                GO FAR RETU                         % WAIT FOR INTERRUPT
055504             FI
055504             4=:TRMOD; K:="0" ; GO RETAD;           % OVERRULE TERM-MODE COMMAND
055510         FI
055510   *"
"055510         EXIT
055511   *)FILL
055516
055516   %-----------------------------------------------------------------------------
055516   % LOCAL SUBROUTINE TO SET UP WINDOW FOR DATAFIELD AFTER INTERRUPT
055516   %
055516   INTEGER POINTER LLRG
055517   SDFWI: A:=L=:"LLRG"; ISTATE=:OISTATE; CALL SET10WINDOW
055524          IF DFOPP><0 THEN X:=1777; X/\A; A:=B/\176000+X FI
055533          A=:X=:10DFOPP; A:=B/\176000+BUFST=:10BUFST; GO LLRG
055542
055542   %-----------------------------------------------------------------------------
055542   % LOCAL SUBROUTINE TO CALL ID10 AND UPDATE DISP DRIVER IN RESIDENT DATAFIELD
055542   %
055542   TID10: *ION
055543         A:=L=:TDRADDR."DRIVER";
055546         GO ID10
055547
055547   %------------------------------------------------------------------------------
055547   % PROGRAMMED RESTART BY PROGRAM.
055547   % IF FIFO INTERFACE, THE  DRIVER MUST WAIT FOR INTERRUPT TO ENSURE THAT THE FIFO
055547   % IS EMPTY. IF NOT FIFO THE DRIVER CAN CONTINUE IF READY FOR TRANSFER IS SET.
055547   % CARRIER MISSING IS CHECKED IN ANY CASE IF THE INTERFACE IS NOT READY AT THIS
055547   % POINT.
055547   %------------------------------------------------------------------------------
055547
055547   DWRITE:CALL SDFWI; TTMR=:TMR; BITFLAG BZERO 5EMPT=:BITFLAG; *IOF
055556          X.BRECHOFL BONE 5PINFL=:X.BRECHOFL; *ION % NO NEED TO BE PINNED
055562          T:=HDEV+DST; *IOXT                       % READ STATUS
055565          IF NBIT 3 THEN                           % NOT READY FOR TRANSFER
055567             IF BIT 13 THEN; *IOF                  % CARRIER MISSING
055572                X.DFLAG BONE 5LBRK=:X.DFLAG; *ION
055576             FI
055576             GO FAR RETU                           % WAIT FOR INTERRUPT
055577          FI
055577          IF X.TINFO BIT 5FIFO GO FAR RETU         % ALWAYS WAIT FOR INTERRUPT IF FIFO
055602          GO CADEL; *)FILL                         % READY, START WRITING
055613
055613
055613   %------------------------------------------------------------------------------
055613   %      RESTART AFTER INTERRUPT, FIFO IS EMPTY, AT LEAST 64 CHARACTERS
055613   %      MAY BE WRITTEN TO THE INTERFACE BEFORE READY FOR TRANSFER GOES OFF
055613   %      THE CHARACTERS ARE FOUND EITHER IN RINGBUFFER OR IN ND-500 BUFFER.
055613   %------------------------------------------------------------------------------
055613
055613   TWRITE:CALL SDFWI
055614   CADEL: X:=10DFOPP; BITFLAG BZERO 5EMPT=:BITFLAG; *IOF
055621          X.BRECHOFL BONE 5PINFL=:X.BRECHOFL; *ION  % NO NEED TO BE PINNED
055625   DHIST: 0/\0; 0/\0                      % ====== D E B U G  O N L Y =====
055627          CALL OXONCHECK; GO FAR SRONOF             % CHECK IF READER ON/OFF SHOULD BE SENT
055631          CALL XONWRITE; GO FAR BDINT               % CHECK IF XOFF HAS STOPPED OUTPUT
055633          *IOF
055634          T:=X.DFLAG BZERO 5LBRK=:X.DFLAG; *ION     % LINE IS OK UNTIL OTHERWISE FOUND
055640          A:=X.TINFO
055641          IF T BIT 17 THEN                          % READER ON/OFF ENAB. FIFO CANT BE USED
055643             K:="0"
055644          ELSE
055645            *BLDA 5FIFO DA                          % K - FIFO TERMINAL
055646          FI
055646          IF A BIT 5UMOD THEN T:=-1 ELSE T:=77577 FI% PARITY MASK
055653          T=:10MASK
055654   SICH:  X:=BITFLAG BZERO 5EMPT=:BITFLAG:="0"=:EBHO      % DRIVER IS BUSY
055661          IF A BIT 5CRDLY THEN X BONE 1 FI          % CARRIAGE RETURN DELAY (TINFO)
055664          IF T:=SCREEN><0 THEN X BONE "0" FI        % STOP ON FULL PAGE ENABLED
055670          X=:TRMOD                                  % SAVE MODE
055671          IF A BIT 5ERRMSG GO FAR EWRITE            % ERROR MESSAGE TO ERROR DEVICE
055673          IF A BIT 5ENABLE GO FAR DTERM             % MASTER DISPLAY SET IN TINFO
055675          CALL FAR CHLOG                            % CHECK IF RT-PROG LOG
055676   *"8N500
"055676        IF BHOLD=0 AND ON5MSG=0 GO FAR BISEM       % OUTPUT BUFFER IS EMPTY
055703         IF K AND TRMOD=0 THEN                      % FIFO INTERFACE AND NO CHECK
055707            IF X:=ON5MSG><0 AND BHOLD=0 THEN GO WR500 ELSE GO WR100 FI
055715         ELSE                                       % OLD INTERFACE
055716            IF X:=ON5MSG><0 THEN
055720               CALL M5TORB; IF BHOLD=0 GO FAR BISEM
055724            FI; GO WO100
055725         FI
055725   *"-8N500
"055725

055725   %------------------------------------------------------------------------------
055725   %      OUTPUT FROM RINGBUFFER.
055725   %      PREPARE NUMBER OF CHARACTERS TO WRITE AND SELECT OPTIMAL
055725   %      OUTPUT ROUTINE ACCORDING TO TERMINAL MODE.
055725   %------------------------------------------------------------------------------
055725
055725   WR100: 100=:WRCH; *IOF                           % FIFO TERMINAL
055730          IF BHOLD>WRCH THEN A:=T FI; *ION          % FIND NUMBER OF CHARS. TO WRITE
055736          A=:EBHO -=:CBHOL
055741          GO W0100
055742
055742   WO100: 1=:WRCH=:EBHO -=:CBHOL                    % OLD INTERFACE OR TRMOD >< 0
055747          TRMOD GOSW SB100,FAR W1100,FAR W2100,FAR W3100,SB100
055756
055756   *"8N500
"055756   %------------------------------------------------------------------------------
055756   %      OUTPUT FROM ND-500 BUFFER.
055756   %      PREPARE NUMBER OF CHARACTERS TO WRITE AND SELECT OPTIMAL
055756   %      OUTPUT ROUTINE ACCORDING TO TERMINAL MODE.
055756   %------------------------------------------------------------------------------
055756
055756   WR500: 100=:WRCH
055760          T:=5MBBANK; *AAX NOBYT; LDATX                   % NUMBER OF BYTES IN BUFFER
055763          IF A=0 GO FAR B5ISEM                            % BUFFER IS EMPTY
055765          IF A>WRCH THEN A-T=:EBHO; T=:A FI; *BLDA 0 DA   % K IF NOT ENDING ON WORD
055774          A SHZ -1 -=:CBHOL                               % NUMBER OF WORDS (NEG)
055777          T:=5MBBANK; *AAX HBUFA-NOBYT; LDATX
056002          *AAX 5HENT-HBUFA; LDXTX; COPY SA DT             % T & X  BUFFER ADDRESS
056005          GO FAR W0500
056006
056006   *"
"056006
056006   *)FILL
056034

056034   %-------------------------------------------------------------------------------
056034   % FAST OUTPUT FROM RINGBUFFER, NO CHECKS ON DATA
056034   % ROUTINE IS OPTIMISED ON IOX, TWO MORE INSTRUCTIONS REQUIRED IF IOXT. (64*2)
056034   %-------------------------------------------------------------------------------
056034
056034   W0100: X:=MAX=:L:=HENTE; T:=10BUFST              % X = HENTE,  L = MAX, T = BUFST
056040          IF HDEV+DDW NBIT 17 THEN
056044             A+164000=:D                            % T = BUFFST, D = IOX DDW
056046   N01F:     *LBYT; AND I (10MAS; EXR SD            % GET FROM BUFFER AND WRITE
056051             X+1; IF X=L THEN X:="0" FI             % INCREMENT HENTE
056055             MIN CBHOL; GO N01F                     % COUNT CHARACTERS
056057             GO FAR BMOUT                           % FIFO IS FULL, CHECK BUFFER
056060          FI
056060          A=:D                                      % T = BUFFST, D = HDEV+DDW
056061   N01S:  *LBYT; AND I (10MAS; SWAP ST DD; IOXT; SWAP ST DD % GET FROM BUFFER AND WRITE
056066          X+1; IF X=L THEN X:="0" FI                % INCREMENT HENTE
056072          MIN CBHOL; GO N01S                        % COUNT CHARACTERS
056074          GO FAR BMOUT                              % FIFO IS FULL, CHECK BUFFER
056075
056075   SB100: *IOF
056076          TAD:=FFMAX; A-1; D=:X+1                   % SINGLE BYTE OUTPUT
056102          IF D=T THEN D:="0" FI; AD=:DBHOLD         % UPDATE BUFFER POINTERS
056106          MIN CFREE; T:=10BUFST; *LBYT; ION         % GET CHARACTER
056112          T:=HDEV+DDW; A/\10MASK;*IOXT              % WRITE CHARACTER
056116          GO FAR BOKOU                              % LEAVE LEVEL
056117
056117   *"8N500
"056117   %------------------------------------------------------------------------------
056117   % FAST OUTPUT FROM ND-500 BUFFER, NO CHECKS ON DATA.
056117   % ROUTINE IS OPTIMISED ON IOX, TWO MORE INSTRUCTIONS REQUIRED IF IOXT (64*2)
056117   %------------------------------------------------------------------------------
056117
056117   W0500: IF HDEV+DDW NBIT 17 THEN                  % IOX OR IOXT REQUIRED
056123             A+164000=:L; IF CBHOL=0 GO N05FB       % L = IOX WRITE CHARACTER
056127   N05F:     *LDATX                                 % FETCH TWO BYTES
056130             A/\10MASK                              % PARITY CHECK
056131             A SHR 10; *EXR SL                      % WRITE LEFT  BYTE
056133             A SH -10; *EXR SL                      % WRITE RIGTH BYTE
056135             X+1; MIN CBHOL; GO N05F                % COUNT WORDS
056140             IF K THEN
056142   N05FB:       *LDATX; SHA SHR 10; EXR SL          % WRITE LAST BYTE
056145                GO 5FINI                            % BUFFER IS EMPTY
056146             FI
056146             EBHO; CALL 5CMOR; GO FAR RETU; GO 5FINI % CHECK IF MORE TO WRITE
056152          FI
056152          A=:L; IF CBHOL=0 GO N05SB
056155   N05S:  *LDATX
056156          A/\10MASK
056157          A SHR 10; T:=:L; *IOXT
056162          A SH -10; *IOXT
056164          T:=:L; X+1; MIN CBHOL; GO N05S
056170          IF K THEN
056172   N05SB:    *LDATX; SHA SHR 10; COPY SL DT; IOXT
056176             GO 5FINI
056177          FI
056177          EBHO; CALL 5CMOR; GO FAR RETU             % CHECK IF MORE TO WRITE
056202   5FINI: X:=ON5MSG; 0=:ON5MSG; *IOF
056205          CALL PT5RST; *ION
056207          GO FAR RETU
056210   *"
"056210   *)FILL
056222

056222   %------------------------------------------------------------------------------
056222   % LOCAL SUBROUTINE TO GET CHARACTER FROM BUFFER
056222   %
056222   COLCH: *IOF
056223          TAD:=FFMAX; IF A=0 THEN EXIT FI                % BUFFER EMPTY
056226          A-1; D=:X+1; IF D=T THEN D:="0" FI; AD=:DBHOLD % UPDATE BUFFER POINTERS
056235          MIN CFREE; T:=10BUFST; *LBYT; ION; EXIT AD1    % GET CHARACTER FROM BUFFER
056242   *)FILL
056243
056243   %-----------------------------------------------------------------------------
056243   % OUTPUT FROM RINGBUFFER WITH STOP ON FULL PAGE
056243   %-----------------------------------------------------------------------------
056243
056243   W1100: IF SCREEN<0 GO FAR BCOUT
056246   N11:   IF SCREEN>24 THEN
056252             -1=:SCREEN; 7; T:=HDEV+DDW; *IOXT      % FULL PAGE PRINT BELL
056260              GO FAR BCOUT
056261          FI
056261          CALL COLCH; GO FAR BREMP                  % GET CHARACTER FROM BUFFER
056263          IF =12 THEN MIN SCREEN FI                 % COUNT LINES
056267          IF =14 THEN T+24=:SCREEN FI               % NEW PAGE
056274          T:=HDEV+DDW; A/\10MASK; *IOXT             % WRITE CHARACTER
056300          MIN CBHOL; GO N11; GO FAR BOKOU           % CONTINUE UNTIL EMPTY OR STOP
056303   *)FILL
056310
056310
056310   %-----------------------------------------------------------------------------
056310   % OUTPUT FROM RINGBUFFER WITH CARRIAGE RETURN DELAY
056310   %-----------------------------------------------------------------------------
056310
056310   W2100:
056310   N21:   CALL FAR COLCH; GO FAR BREMP              % GET CHARACTER FROM BUFFER
056312          T:=HDEV+DDW; A/\10MASK; *IOXT             % WRITE CHARACTER
056316          IF A BZERO 7=15 GO FAR CDELAY             % CR CAUSES DELAY
056322          MIN CBHOL; GO N21; GO FAR BOKOU           % OUTPUT BUFFER IS EMPTY
056325
056325   %-----------------------------------------------------------------------------
056325   % OUTPUT FROM RINGBUFFER WITH BOTH STOP ON FULL PAGE AND CR. DELAY
056325   %-----------------------------------------------------------------------------
056325
056325   W3100: IF SCREEN<0 GO FAR BCOUT
056330   N31:   IF SCREEN>24 THEN
056334             -1=:SCREEN; 7; T:=HDEV+DDW; *IOXT      % FULL PAGE PRINT BELL
056342              GO FAR BCOUT
056343          FI
056343          CALL FAR COLCH; GO FAR BREMP              % GET CHARACTER FROM BUFFER
056345          IF =12 THEN MIN SCREEN FI                 % COUNT LINES
056351          IF =14 THEN T+24=:SCREEN FI               % NEW PAGE
056356          T:=HDEV+DDW; A/\10MASK; *IOXT             % WRITE CHARACTER
056362          IF A BZERO 7=15 GO FAR CDELAY             % CR CAUSES DELAY
056366          MIN CBHOL; GO N31; GO FAR BOKOU           % CONTINUE UNTIL EMPTY OR STOP
056371
056371   *)FILL
056400
056400   %------------------------------------------------------------------------------
056400   % LOCAL SUBROUTINE TO RESTART USER IF INPUT IS WAITING FOR ECHO
056400   % CAN SWITCH INTERUPT ON
056400
056400   INTEGER SAVB; INTEGER POINTER LREG
056402
056402   RSINP: A:=L=:"LREG"
056404          IF X:=10DFOPP><0 THEN
056406             IF X.BRECHOFL BIT 5WECH THEN
056411                A BZERO 5WECH=:X.BRECHOFL; X:=:B=:SAVB
056415   *"8N500
"056415               IF X:=IN5MSG><0 THEN
056417                   *IOF
056420                   T:=5MBBANK; *AAX MLFLA; LDATX
056423                   IF A = 0 THEN               % IBMOVE NOT ALLREADY ACTIVE
056424                       A:=1; *STATX            % MARK IBMOVE ACTIVE
056426                       "IBMOVE"
056427                   ELSE                        % IBMOVE ALLREADY ACTIVE
056430                       GO OUT
056431                   FI
056431                   *ION
056432                ELSE
056433                   CALL TSTBACK; "IORESTART"
056435                FI
056435   *"-8N500
"056435               CALL CXRTACT
056436   OUT:
056436               SAVB=:B
056440             FI
056440          FI
056440          GO LREG; *)FILL
056447
056447   %------------------------------------------------------------------------------
056447   % LOCAL SUBROUTINE TO RESTART USER IF MINBHOLD IS REACHED IN OUTPUT BUFFER
056447
056447   RSOUT:  IF OISTAT=0 THEN EXITA FI                    % CALLED WHEN NOT EMPTY
056452           X:=BHOLD; T:=MINBHOLD BZERO 5BLOC BZERO 5NOWT
056456           IF X<=T GO FELLS; EXIT
056461   RSEOU:  IF OISTAT=0 THEN EXITA FI                    % CALLED WHEN EMPTY BUFFER
056464   FELLS:  IF A<0 THEN
056465              IF MINBHOLD NBIT 5NOWT THEN EXITA FI
056471              A BZERO 5NOWT=:MINBHOLD
056473           FI
056473           A:=L=:"LREG"; "IORESTART"; CALL CXRTACT
056477           GO LREG; *)FILL
056503
056503   %------------------------------------------------------------------------------
056503   %      RETURN FROM LEVEL 10
056503
056503   BCOUT: CALL RSOUT; GO BDINT
056505          IF CFREE>=SUFFS THEN CALL RSINP FI
056512          GO BDINT
056513   BMOUT: X=:HENTE; *IOF                            % UPDATE HENTE
056515          BHOLD-EBHO=:BHOLD; X:=MAX-A=:CFREE; *ION  % UPDATE BHOLD AND CFREE
056524   BOKOU: CALL RSOUT; GO RETU                       % IS OUTPUT WAITING FOR BUFFER
056526          IF CFREE>=SUFFS THEN CALL RSINP FI        % IS INPUT WAITING FOR ECHO
056533          GO RETU                                   % ENABLE INTERRUPT
056534
056534   BREMP: BITFLAG BONE 5EMPT=:BITFLAG; 0=:TMR
056540          CALL RSEOU; GO RETU; CALL RSINP
056543   RETU:  T:=HDEV+DCONT; "DPIN"; *IOXT              % ENABLE INTERRUPT
056547          CALL FAR TID10; GO FAR TWRITE             % WAIT FOR INTERRUPT
056551
056551   CDELAY: MIN CBHOL; 0/\0
056553   DELAY: CALL RSOUT; GO DRETU                      % IS OUTPUT WAITING FOR BUFFER
056555          IF CFREE>=SUFFS THEN CALL RSINP FI        % IS INPUT WAITING FOR ECHO
056562
056562   DRETU: T:=HDEV+DCONT; "DPIN"; *IOXT              % ENABLE INTERRUPT
056566          CALL FAR TID10; CALL FAR SDFWI            % WAIT FOR INTERRUPT
056570          IF 10DFOPP.TINFO BIT 5FIFO THEN           % FIFO INTERFACE
056574             A:=0; T:=HDEV+DDW
056577             FOR X:=-5 DO
056600                *IOXT                               % WRITE 5 DUMMY CHARACTERS
056601             OD
056602          ELSE                                      % PLAIN INTERFACE
056603             TYPRING BONE 10 BONE 6=:TYPRING        % 5 DUMMY CHARS. COUNTED IN BIT 6-8
056607   CLOOP:    IF TYPRING SHZ-6/\7>0 THEN
056614                A-1 SH 6=:T:=TYPRING/\177077\/T=:TYPRING
056623                A:=0; T:=HDEV+DDW; *IOXT
056627                T-DDW+DCONT; "DPIN"; *IOXT
056633                CALL FAR TID10; CALL FAR SDFWI; GO CLOOP
056636             FI
056636          FI
056636          GO FAR CADEL
056637
056637   *"8N500
"056637   B5ISEM: X:=ON5MSG; 0=:ON5MSG; *IOF
056642          CALL PT5RST; *ION
056644   *"
"056644   BISEM: BITFLAG BONE 5EMPT=:BITFLAG
056647          CALL FAR RSEOU; 0/\0
056651          IF 10DFOPP.BSTATE=5BPASSIVE THEN
056656             IF X.TINFO BIT 5VSPEED THEN
056661                A BONE 5SPNFOUND=:X.TINFO
056663                X.TYPRING BONE 10=:X.TYPRING
056666                -2=:X.TMR
056670          FI; FI
056670
056670   BDINT: X:=10DFOPP; *IOF
056672          IF X.DFLAG BIT 5XON OR BIT 5XOFF GO RETU
056677          X.BRECHOFL BZERO 5PINFL=:X.BRECHOFL      % NEED TO BE PINNED
056702          0=:TMR; T:=HDEV+DCONT; "0"; *IOXT        % DISABLE INTERUPT
056707          CALL FAR TID10; GO FAR TWRITE
056711
056711   SRONOF:T:=HDEV+DDW; *IOXT                       % WRITE READER ON/OFF
056714          GO RETU
056715   *)FILL
056730

056730   %-----------------------------------------------------------------------------
056730   % DISPLAY MODI, THE CHARACTERS ARE WRITTEN TO ALL TERMINALS PRESENT
056730   % IN THE DISPLAY LINK FROM THE MASTER TERMINAL.
056730   %-----------------------------------------------------------------------------
056730
056730   DTERM: CALL FAR CHLOG
056731   *"8N500
"056731          IF BHOLD=0 AND ON5MSG=0 GO FAR BISEM
056736          IF X:=ON5MSG><0 THEN
056740             CALL M5TORB; IF BHOLD=0 GO FAR BISEM
056744          FI
056744   *"-8N500
"056744          IF TRMOD BIT "0" THEN                     % STOP ON FULL PAGE USED
056747             IF SCREEN<0 GO FAR BCOUT
056752             IF SCREEN>24 THEN; *IOF
056757                -1=:SCREEN; 7; CALL PRCHA; *ION     % FULL PAGE PRINT BELL
056764                 GO FAR BCOUT
056765             FI
056765          FI
056765          CALL FAR COLCH; GO FAR BREMP              % GET CHARACTER FROM BUFFER
056767          IF T:=TRMOD BIT "0" THEN
056772             IF =12 THEN MIN SCREEN FI              % COUNT LINES
056776             IF =14 THEN T+24=:SCREEN FI            % NEW PAGE
057003          FI; *IOF
057004          CALL PRCHA; *ION                          % WRITE CHARACTER
057006          IF T:=TRMOD BIT 1 THEN                    % CR DELAY USED
057011             IF A BZERO 7=15 GO FAR CDELAY          % CR CAUSES DELAY
057015          FI
057015          GO FAR BOKOU                              % WAIT FOR INTERRUPT
057016   *)FILL
057030
057030   %----------------------------------------------------------------------
057030   %   ERROR MESSAGE TO ERROR DEVICE, THE MESSAGE IS FOUND IN EBUWRITE
057030   %----------------------------------------------------------------------
057030   DISP 0; DOUBLE EBUHF=EBUHENTE; PSID   % HENTE AND FYLLE IN ERROR BUFFER
057030
057030   EWRITE: IF X:=EBUWRITE><0 THEN
057032              AD:=X.EBUHF
057033              IF A><D THEN                        % SOMETHING IN BUFFER
057035                 X=:T:=A; *LBYT                   % COLLECT BYTE
057040                 X+1:=:T; T=:X.EBUHENTE           % UPDATE HENTE
057043                 T:=HDEV+DDW; *IOXT               % WRITE CHARACTER
057046                 GO FAR RETU                      % LEAVE LEVEL 10
057047              FI
057047              X.EBULINK=:EBUWRITE                 % WHOLE BUFFER PRINTED
057051              T:=EBUFREE=:X.EBULINK; X=:EBUFREE   % PUT IN FREE LIST
057054              IF A><0 GO CHRET                    % MORE IN PRINT LINK?
057055           FI; *IOF
057056           10DFOPP.TINFO BZERO 5ERRMSG=:X.TINFO; *ION
057063   CHRET:  IF OISTATE><0 THEN
057065              "IORESTART"; CALL CXRTACT           % RESTART PROGRAM
057067           FI
057067           GO FAR RETU
057070   RBUS
057077
057077   %------------------------------------------------------------------------------
057077   % SUBROUTINE TO WRITE CHARACTERS TO ALL TERMINALS LINKED TO A MASTER
057077   % TERMINAL.
057077   % THE ROUTINE MUST BE CALLED IN IOF, AS IT IS CALLED BOTH FROM
057077   % LEVEL 10 AND 12.
057077
057077   SUBR PRCHA
057077   INTEGER CHAR,XREG; INTEGER POINTER LREG
057102   PRCHA: T:=HDEV+DDW; *IOXT                       % WRITE CHARACTER ON MASTER
057105          A=:CHAR:=L=:"LREG"; X=:XREG:=TDRADDR
057112          DO; T:="PDISPLAY"; CALL XGTDFADDR
057114          WHILE A><-1
057117              A=:X; T:="HDEV"; CALL XGTDFADDR; A=:T
057123              T+DDW; A:=CHAR; *IOXT
057126          OD
057127          X:=XREG; CHAR; GO LREG
057132   RBUS
057135
057135   *"8N500
"057135   %------------------------------------------------------------------------------
057135   % SUBROUTINE TO UPDATE CHARACTERS LEFT IN ND-500 BUFFER
057135   % IF MORE CHARACTERS TO PRINT EXIT ELSE EXITA
057135   % IF RINGBUFFER CAN HOLD REST OF CHARACTERS THEY ARE COPIED AND
057135   % ND-500 IS RESTARTED.
057135   %
057135   SUBR 5CMOR
057135   INTEGER POINTER LREG; INTEGER EBHO5
057137   5CMOR: IF A><0 THEN
057140             A=:EBHO5
057141             IF C5LFIFO=0 THEN
057143                CFREE=:NOCHAR
057145             ELSE
057146                IF T:=CFREE<A THEN T=:NOCHAR ELSE A=:NOCHAR FI
057154             FI
057154             X=:A:=ON5MSG; T:=5MBBANK; *AAX 5HENT; STATX
057161             EBHO5; *AAX NOBYT-5HENT; STATX
057164             IF T:=NOCHAR<0 THEN EXIT FI; *IOF
057171             IF A<T AND T:=BHOLD=0 THEN
057176                T:=L+1=:"LREG"
057200                T:=CFREE-A=:CFREE; T:=BHOLD+A=:BHOLD; *BLDA 0 DA
057207                A=:FYLLE SHZ -1=:L; 0=:HENTE
057213                T:=5MBBANK; *AAX HBUFA-NOBYT; LDATX
057216                *AAX 5HENT-HBUFA; LDXTX; COPY SX DD
057221                T:=10BUFST; X:=0
057223                IF L=0 GO M5ONEB; *MOVPA
057226                IF K THEN
057230   M5ONEB:         A:=:T; D:=:X; A=:D; *LDATX
057234                   A SHZ -10; D=:T; X:=0; *SBYT
057240                FI; *ION
057241                GO LREG
057242             FI; *ION
057243             EXIT
057244          FI
057244          EXITA
057245   RBUS
057250
057250   %-------------------------------------------------------------------------
057250   %      M 5 T O R B
057250   %
057250   % ROUTINE TO MOVE CHARACTERS FROM 500 BUFFER TO RINGBUFFER
057250   % ENTRY:   B - OUTPUT DATAFIELD
057250   %          X - ON5MSG
057250   SUBR M5TORB
057250   INTEGER NOC1,NOC2,FYLST
057253   INTEGER POINTER LREG=?
057253   M5TORB: A:=L=:"LREG"; *IOF
057256          IF C5LPLAIN=0 THEN
057260             CFREE=:NOCHAR
057262          ELSE                                                % RESTRICTED COPY
057263             IF T:=CFREE>A THEN A=:NOCHAR ELSE T=:NOCHAR FI
057271          FI
057271          T:=5MBBANK; *AAX NOBYT; LDATX
057274          IF A><0 THEN
057275             IF T:=BHOLD=0 OR T:=FYLLE=:FYLST NBIT 0 AND A<NOCHAR THEN
057307                IF T:=BHOLD=0 THEN 0=:FYLST=:FYLLE=:HENTE FI
057315                T:=NOCHAR BZERO "0"
057317                IF A>T THEN A-T=:CNOCHAR; T=:A; ELSE 0=:CNOCHAR FI
057326                T:=CFREE-A=:CFREE; T:=BHOLD+A=:BHOLD; *BLDA 0 DA
057335                A=:D
057336                IF FYLLE+D>MAX THEN
057343                   A-T=:FYLLE=:NOC2; D-A=:A; A=:NOC1
057351                ELSE
057352                   T:=:D=:NOC1; 0=:NOC2
057355                   IF A=D THEN 0=:FYLLE ELSE A=:FYLLE FI
057362                FI; GO L1
057363   INTEGER POINTER LREG; *)FILL
057366   L1:          *ION
057367                NOC1 SHZ -1=:L
057372                T:=5MBBANK; *AAX HBUFA-NOBYT; LDATX
057375                *AAX 5HENT-HBUFA; LDXTX; COPY SX DD
057400                T:=FYLST SHZ -1; X:=10BUFST+T=:T:=0
057406                IF L=0 GO M5ONEB; *MOVPA
057411                IF T=:L:=NOC2><0 THEN
057415                   T SHZ -1=:L; T:=10BUFST; X:=0
057421                   IF L=0 GO M5ONEB; *MOVPA
057424                ELSE
057425                   L=:T
057426                FI
057426                IF K THEN
057430   M5ONEB:         A:=:T; D:=:X; A=:D; *LDATX
057434                   A SHZ -10; D=:T; X:=0; *SBYT
057440                   GO M5FINI
057441                FI
057441                IF CNOCHAR=0 GO M5FINI
057443                X:=ON5MSG; T:=5MBBANK; D=:A; *AAX 5HENT; STATX
057450                CNOCHAR; *AAX NOBYT-5HENT; STATX
057453             FI
057453             *ION
057454             GO LREG
057455          FI
057455   M5FINI: *IOF
057456           X:=ON5MSG; 0=:ON5MSG; CALL PT5RST; *ION
057462          GO LREG
057463   RBUS
057466   *"
"057466
057466   %==============================================================================
057466   %       (M)      T F I N P U T
057466   %
057466   % TELEFIX TERMINAL INPUT DRIVER, LEVEL 10
057466   %
057466   %
057466   SUBR TFINPUT,TFECHO
057466
057466   SYMBOL 5PIP=17
057466
057466   %------------------------------------------------------------------------------
057466   % LOCAL SUBROUTINE TO READ ONE CHARACTER FROM PAIR DATAFIELD RINGBUFFER
057466   %
057466   INTEGER POINTER LREG; INTEGER CCHAR,MYDFA
057471   RDPAIR: A:=L=:"LREG"; X:=PAIRDF:=:B=:MYDFA; *IOF
057477           CALL SET12WINDOW; IF BHOLD=0 THEN MYDFA=:B; GO RESI FI
057505           CALL CXRBGET; A=:CCHAR
057507           T:=BHOLD=:D:=MINBHOLD BZERO 5BLOC; MYDFA=:B
057515           IF PAIRDF.ISTATE><0 AND D>T THEN X:=:B; CALL XRTACT; X:=:B FI
057525           MIN "LREG"
057526   RESI:   CALL RES12WINDOW; *ION
057530           CCHAR; GO LREG
057532   *)FILL
057536
057536   %------------------------------------------------------------------------------
057536   %       T F I N P U T
057536   %
057536   % THIS DRIVER IS NOT INTERRUPT DRIVEN, RESTART IS DONE BY STDEV FROM
057536   % OUTPUT PAIR TERMINAL.
057536
057536   RETURN: *ION
057537          TTMR=:TMR; GO WT10; CALL ERRFATAL         % WAIT FOR RESTART
057543   TFINPUT:
057543          ISTATE=:OISTATE; CALL SET10WINDOW
057546          IF DFOPP><0 THEN X:=1777; X/\A; A:=B/\176000+X FI
057555          A=:10DFOPP; A.BITFLAG BZERO 5CLOU=:X.BITFLAG
057562          CALL RDPAIR; GO RETURN; A=:LAST           % READ CHARACTER
057565          BRECHOFL/\177770=:BRECHOFL                % CLEAR BREAK/ECHO FLAG
057570          IF DFLAG BIT 5CAPITAL THEN                % CONVERT LOWER CASE TO UPPER CASE
057573             LAST/\177=:T
057576             IF 140<T AND 176>T AND CESCP SHZ -10/\177><T AND CESCP/\177><T THEN
057615                LAST BZERO 5=:LAST                  % CONVERT ALL EXEPT
057620             FI                                     % RUBOUT  AND DISCONNECT
057620          FI
057620          IF X:=10DFOPP><0 AND X.SCREEN><0 THEN     % TWO WAY DEVICE WITH CR-DELAY
057624                IF <0 THEN -1=:X.TMR FI
057627                1=:X.SCREEN
057631                IF LAST=0 THEN                      % IGNORE TAPE-FEED?
057633                  IF FLAGB NBIT 5LCHAR GO RETURN
057636                  IF CESCP SHZ-10><0 GO RETURN
057641                FI
057641          FI
057641          IF T:=DFLAG NBIT 5SPEC AND T NBIT 5CTRLO THEN
057646             CALL ESCAPE; GO RETURN; X:=10DFOPP
057651          FI
057651          IF DFLAG NBIT 5CTRLO THEN
057654             IF LAST/\177=17 THEN; *IOF
057662                DFLAG BONE 5CTRLO=:DFLAG; *ION
057666             FI
057666          ELSE; *IOF
057670             DFLAG BZERO 5CTRLO=:DFLAG; *ION
057674          FI
057674          IF CFREE=0 THEN; *IOF
057677             TINFO BONE 5BFUL=:TINFO; GO BFULL      % BUFFER IS FULL, RESTART USER
057703          FI
057703          GO L1; *)FILL
057716   L1:    *IOF
057717          IF DFLAG BIT 5ECHO THEN
057722               LAST/\377
057724               CALL TECHO                 %TEST FOR ECHO
057725               CALL TBREAK                %TEST FOR BREAK
057726               X:=10DFOPP
057727          ELSE
057730               IF OISTATE=-1 THEN         % NOWAIT MODE
057734                  LAST/\377; CALL CXRBPUT; GO BFULL
057740               FI
057740          FI
057740          IF BRECHOFL<0 THEN 7=:LAST; GO IGNCH FI   % IGNORE CHAR?
057745
057745   ADDCH: LAST/\377; CALL CXRBPUT                   % PUT CHARACTER IN BUFFER
057750   IGNCH:
057750          IF BHOLD>=MAX-10 AND BRECHOFL NBIT 5BREAK GO BFULL % FULL BUFFER
057760          IF BRECHOFL BIT 5BREAK THEN               % BREAK ACCORDING TO STRATEGY
057763             DFLAG BZERO 5ECHO                      % ECHO OFF IN DRIVER
057765             IF X:=FYLLE=HENTE THEN
057771                A BONE 5ALEC                        % WHOLE BUFFER IS ECHOED BY DRIVER
057772             ELSE
057773                A BZERO 5ALEC                       % PART OF BUFFER MUST BE ECHOED BY IOTRANS
057774             FI; A=:DFLAG; X=:RSISTE                % RSISTE IS FIRST CHARACTER NOT ECHOED
057776          ELSE
057777             GO RETU
060000          FI
060000
060000   BFULL: CALL TSTBACK                              % RESTART PROGRAM
060001   *"8N500
"060001          IF X:=IN5MSG >< 0 THEN
060003                T:=5MBBANK; *AAX MLFLA; LDATX
060006                IF A=0 THEN
060007                   A:=1; *STATX
060011                   "IBMOVE"; CALL CXXRTACT
060013                FI
060013          ELSE
060014   BYP1:        IF OISTATE=-1 OR A=-2 THEN
060023                   CALL PNW5ST; GO RETU
060025                FI
060025                "IORESTART"; CALL CXXRTACT
060027          FI
060027   *"
"060027   *"-8N500
"060027
060027   RETU:  IF BRECHOFL<0 OR A BIT 5ECHO THEN             % SOMETHING TO ECHO
060033             X:=10DFOPP:=:B=:10DFOPP                    % CHANGE TO OUTPUT DF
060036             X.LAST; CALL CXRBPUT; GO TFECHO            % GO TO OUTPUT DRIVER
060041          FI
060041          GO FAR RETURN
060042   RBUS
060060

060060   %==============================================================================
060060   %       (M)      T F W R I T E    T F E C H O
060060   %
060060   % OUTPUT-DRIVER ROUTINE FOR TELEFIX TERMINALS ON LEVEL 10!
060060
060060   SUBR TFWRITE,TFECHO
060060
060060   SYMBOL SUFFS=5               % SUFFICIENT SPACE FOR ECHO
060060
060060   %-----------------------------------------------------------------------------
060060   % LOCAL SUBROUTINE TO SET UP WINDOW FOR DATAFIELD AFTER RESTART
060060   %
060060   INTEGER POINTER LLRG
060061   SDFWI: A:=L=:"LLRG"; ISTATE=:OISTATE; CALL SET10WINDOW
060066          IF DFOPP><0 THEN X:=1777; X/\A; A:=B/\176000+X FI
060075          A=:X=:10DFOPP; GO LLRG
060100
060100   %----------------------------------------------------------------------------
060100   % LOCAL SUBROUTINE TO CHECK IF CFREE IN PAIR DATAFIELD RINGBUFFER IS
060100   % GREATER OR EQUAL THE NUMBER GIVEN IN A-REG.
060100   %
060100   INTEGER WANTCF; INTEGER POINTER LREG=?
060101   CHPAIRFREE:
060101           A=:WANTCF:=L=:"LREG"
060104           IF PAIRDF.RTRES=0 THEN EXIT FI                     % NOT RESERVED
060110           T:="CFREE"; CALL XGTDFADDR
060112           IF A>=WANTCF THEN MIN "LREG" FI; X=:D              % ENOUCH SPACE IN BUFFER?
060117           IF X.ISTATE>0 OR T:=X.RTRES.STATUS BIT 5RWAIT THEN % RESTART NEEDED?
060126              D=:X; X:=:B; CALL RTACT; X:=:B                  % RESTART PROGRAM
060132           ELSE
060133              IF A<0 THEN T BONE 5REP=:X.STATUS FI % SET 5REP TO AVOID "TIMING HOLE"
060136           FI
060136           GO LREG
060137
060137   %------------------------------------------------------------------------------
060137   % LOCAL SUBROUTINE TO PRINT ONE CHARACTER IN PAIR DATAFIELD RINGBUFFER
060137   %
060137   INTEGER POINTER LREG; INTEGER CCHAR,MYDFA
060142   PRPAIR: A=:CCHAR:=L=:"LREG"; X:=PAIRDF:=:B=:MYDFA; *IOF
060151           CALL SET12WINDOW; CCHAR; CALL CXRBPUT; CALL RES12WINDOW; *ION
060156           X:=MYDFA=:B; GO LREG
060161
060161   %------------------------------------------------------------------------------
060161   % LOCAL SUBROUTINE TO PRINT 5 DUMMY CHARS. IN PAIR DATAFIELD RINGBUFFER
060161   %
060161   PR5PAIR:
060161           A:=L=:"LREG"; X:=PAIRDF:=:B=:MYDFA; *IOF
060167           CALL SET12WINDOW; A:=0
060171           FOR X:=-5 DO CALL CXRBPUT; OD; CALL RES12WINDOW; *ION
060176           X:=MYDFA=:B; GO LREG
060201
060201   %------------------------------------------------------------------------------
060201   % LOCAL SUBROUTINE TO GET CHARACTER FROM OWN BUFFER
060201   %
060201   COLCH: *IOF
060202          TAD:=FFMAX; IF A=0 THEN EXIT FI                % BUFFER EMPTY
060205          A-1; D=:X+1; IF D=T THEN D:="0" FI; AD=:DBHOLD % UPDATE BUFFER POINTERS
060214          MIN CFREE; T:=10BUFST; *LBYT; ION; EXIT AD1    % GET CHARACTER FROM BUFFER
060221
060221   *)FILL
060235
060235   %------------------------------------------------------------------------------
060235   %      T F W R I T E    T F E C H O
060235   %
060235   % THIS DRIVER IS NOT INTERRUPT DRIVEN. THE DRIVER MOVES CHARACTERS FROM
060235   % THE OUTPUT BUFFER TO INPUT BUFFER OF THE TERMINAL POINTED TO IN
060235   % PAIRDF.
060235   % RESTART WILL TAKE PLACE BY:
060235   %        OWN  TERMINAL: STDEV AND TIMEOUT ON OUTPUT
060235   %        PAIR TERMINAL: STDEV ON INPUT IF WANTST><0
060235   %------------------------------------------------------------------------------
060235
060235   TFWRITE:                                         % START-ADDRESS
060235          CALL SDFWI                                % SET WINDOW
060236   TFECHO:                                          % ENTRY FROM INP.DR. WHEN ECHO
060236          A:=B/\176000+BUFST=:10BUFST               % FIND BUFFER START
060242          0=:TMR
060243          A:=10DFOPP.TINFO; X:=0                    % GET TINFO AND ZERO MODE
060246          IF A BIT 5CRDLY THEN X BONE 1 FI          % CARRIAGE RETURN DELAY (TINFO)
060251          IF T:=SCREEN><0 THEN X BONE "0" FI        % STOP ON FULL PAGE ENABLED
060255          X=:TRMOD                                  % SAVE MODE
060256   *"8N500
"060256          IF BHOLD=0 AND ON5MSG=0 GO FAR RETU
060263          IF X:=ON5MSG><0 THEN
060265             CALL M5TORB; IF BHOLD=0 GO FAR RETU
060271          FI
060271   *"-8N500
"060271          IF TRMOD BIT 1 THEN 6 ELSE 1 FI           % CR DELAY 6 CHAR ELSE 1 FREE
060277          CALL CHPAIRFREE; GO FAR RETU              % CHECK IF FREE CHARS
060301          IF TRMOD BIT "0" THEN                     % STOP ON FULL PAGE USED
060304             IF SCREEN<0 GO FAR RETU                % NOT RESTARTED FROM FULL PAGE
060307             IF SCREEN>24 THEN
060313                -1=:SCREEN; 207; CALL PRPAIR        % FULL PAGE PRINT BELL
060317                 GO FAR RETU
060320             FI
060320          FI
060320          CALL FAR COLCH; GO FAR RETU               % GET CHARACTER FROM BUFFER
060322          IF T:=TRMOD BIT "0" THEN
060325             IF =12 THEN MIN SCREEN FI              % COUNT LINES
060331             IF =14 THEN T+24=:SCREEN FI            % NEW PAGE
060336          FI
060336          CALL PRPAIR                               % WRITE CHARACTER
060337          IF T:=TRMOD BIT 1 THEN                    % CR DELAY USED
060342             IF A BZERO 7=15 GO FAR CDELAY          % CR CAUSES DELAY
060346          FI
060346          GO BMODIFY                                % FINISHED
060347
060347   %------------------------------------------------------------------------------
060347   % LOCAL SUBROUTINE TO RESTART USER IF INPUT IS WAITING FOR ECHO
060347
060347   INTEGER SAVB; INTEGER POINTER LRE1
060351
060351   RSINP: A:=L=:"LRE1"
060353          IF X:=10DFOPP><0 THEN
060355             IF X.BRECHOFL BIT 5WECH THEN
060360                A BZERO 5WECH=:X.BRECHOFL; X:=:B=:SAVB
060364   *"8N500
"060364               IF X:=IN5MSG><0 THEN
060366                   *IOF
060367                   T:=5MBBANK; *AAX MLFLA; LDATX
060372                   IF A = 0 THEN               % IBMOVE NOT ALREADY ACTIVE
060373                       A:=1; *STATX            % MARK IBMOVE ACTIVE
060375                       "IBMOVE"
060376                   ELSE                        % IBMOVE ALLREADY ACTIVE
060377                       GO OUT
060400                   FI
060400                   *ION
060401                ELSE
060402                   CALL TSTBACK; "IORESTART"
060404                FI
060404   *"-8N500
"060404   OUT:
060404               CALL CXRTACT
060405               SAVB=:B
060407             FI
060407          FI
060407          GO LRE1; *)FILL
060426
060426   %------------------------------------------------------------------------------
060426   % LOCAL SUBROUTINE TO RESTART USER IF MINBHOLD IS REACHED IN OUTPUT BUFFER
060426
060426   RSOUT:  IF OISTAT=0 THEN EXITA FI
060431           X:=BHOLD; T:=MINBHOLD BZERO 5BLOC BZERO 5NOWT
060435           IF X>T THEN EXIT FI
060440           IF A<0 THEN
060441              IF MINBHOLD NBIT 5NOWT THEN EXITA FI
060445              A BZERO 5NOWT=:MINBHOLD
060447           FI
060447           A:=L=:"LRE1"; "IORESTART"; CALL CXRTACT
060453           GO LRE1; *)FILL
060457
060457   %------------------------------------------------------------------------------
060457   %      RETURN FROM LEVEL 10
060457
060457   BMODIFY:
060457          CALL RSOUT; GO BMODO
060461          IF CFREE>=SUFFS THEN CALL RSINP FI
060466   BMODO: TTMR=:TMR
060470   RETU:  *ION                                      % IN CASE OF ECHO
060471          GO WT10; CALL ERRFATAL                    % LEAVE LEVEL 10
060473
060473   CDELAY:
060473          CALL RSOUT; GO DRETU                      % IS OUTPUT WAITING FOR BUFFER
060475          IF CFREE>=SUFFS THEN CALL RSINP FI        % IS INPUT WAITING FOR ECHO
060502   DRETU: CALL FAR PR5PAIR; GO RETU                 % PRINT 5 DUMMY CHARACTERS
060504   RBUS
060507
060507
060507   %==============================================================================
060507   % 37.5       I O A P D   O O A P D
060507   %
060507   % SUBROUTINES TO READ AND WRITE A CHARACTER USING IOXT!!!!!!!
060507
060507   SUBR IOAPD,OOAPD,XOOAPD
060507   INTEGER ERRCODE,IOXNO
060511   IOAPD: T:=HDEV+DST; *IOXT
060514          A =: D                                    % STATUS
060515          T+"DDR-DST"; *IOXT                        % BYTE IN A
060517          IF D BIT 13 THEN                          % CARRIER MISSING??
060521                IF TYPRING BIT 5TERM THEN; *IOF     % TERMINAL
060525                   DFLAG BONE 5LBRK=:DFLAG;
060530                   -2=:TMR                          % START TIME-OUT IN 2 SEC.
060532                FI
060532                L =: D                              % SAVE RETUR-ADRESS
060533                CALL CLBUF ; L := D                 % CLEAR BUFFER
060535                EXIT
060536          ELSE
060537             T:=DFLAG BZERO 5LBRK=:DFLAG            % LINE IS OK
060542          FI
060542          IF D BIT 4 THEN
060544             T:=TINFO
060545             IF D BIT 5 THEN T BONE 5FRER ELSE T BONE 5PAER FI; T=:TINFO
060553             IF A=0 THEN
060554                IF CESCP/\377><LAST GO SIMESC
060561             FI
060561             CNTREG; T:=HDEV+DCONT; *IOXT
060565             TTMR=:TMR; EXIT
060570          FI
060570   SIMESC: A=:D; CNTREG; T:=HDEV+DCONT; *IOXT
060575          D=:A; EXITA
060577
060577   OOAPD: A=:D                                      % SAVE CHAR IN D
060600          T:=HDEV+DST; *IOXT
060603          IF BIT 3 THEN                             % READY!!!
060605             D=:A
060606   XOOAPD:   T:=HDEV+DDW; *IOXT                     % WRITE CHAR TO INTERFACE
060611          FI
060611   OUTRA: "DACT+DPIN"; T:=HDEV+"DCONT"; *IOXT       % RE-ACTIVATE.
060615          EXIT
060616
060616   RBUS
060620
060620
060620   %====================================================================
060620   %            F S P E E D
060620   %
060620   % DESCRIPTION: ROUTINE TO FIND SPEED WHEN LOGGIN IN ON A TERMINAL.
060620   %              (DESTROYS A, D AND X).
060620   % ENTRY: A = ESCAPE CHARACTER
060620   % EXIT:  SKIP RETURN - SPEED FOUND.
060620   %        RETURN  - SPEED NOT FOUND.
060620   %
060620   SUBR FSPEED
060620   DISP 0
060620   INTEGER CCSPEE                                         % CURRENT TSPEED
060620   INTEGER CTABLE                                         % CURRENT TABLE TO SEARCH IN.
060620   INTEGER NSPEED                                         % NEXT SPEED IF NOT FOUND.
060620   INTEGER VESCAPE=CTABLE                                 % ESCAPE CHARACTER.
060620   PSID                                                   %
060620   @ICR                                                   %
060620   INTEGER ARRAY ETABLE := ( 210, TAB1, 273,              % ENTRY TABLE.
060623                             273, TAB2, 356,              %
060626                             356, TAB3, 210,              %
060631                             -1);                         %
060632                                                          %
060632   INTEGER ARRAY TAB1   := ( 210, 33,                     % 9600 BAUD
060634                             231, 36,                     % 4800
060636                             167, 170,                    % 2400
060640                             252, 160,                    % 1800
060642                             252, 140,                    % 1800
060644                            -1);
060645
060645   INTEGER ARRAY TAB2   := ( 273, 33,                     % 1200 BAUD
060647                             146, 36,                     %  600
060651                             335, 170,                    %  300
060653                             125, 140,                    %  200
060655                            -1);
060656
060656   INTEGER ARRAY TAB3   := ( 356, 33,                     % 150    BAUD
060660                             104, 73,                     % 134.5
060662                             104, 63,                     % 134.5
060664                             377, 167,                    % 110
060666                             377, 147,                    % 110
060670                              63, 36,                     %  75
060672                              42, 174,                    %  50
060674                             -1);
060675   @CR;
060675   INTEGER XREG, CCHAR, TABPART
060700   FSPEED:                                                %
060700          A BZERO 7 =: CCHAR; X=:XREG                     % SAVE RECEIVED CHARACTER.
060703          IF TINFO NBIT 5VSPEED OR TSPEED=-1 THEN EXIT FI % VARIABLE SPEED NOT ALLOWED.
060713          A=:D                                            % D= TSPEED IN DATAFIELD.
060714          K:="0"                                          % SET FLAG "CORRECT SPEED NOT FOUND".
060715          *1BANK                                          %
060716          X:="ETABLE"                                     %
060717          DO WHILE X.CCSPEE><D AND A><-1                  % WHILE NOT CORRECT TABLE PART.
060725              X+3                                         %
060726          OD                                              %
060727          IF A><-1 THEN                                   % SPEED FOUND.
060732              X=:TABPART                                  % SAVE ENTRY.
060733              X.CTABLE=:X                                 % X= START OF TAB1/TAB2/TAB3.
060735              DO WHILE X.VESCAPE><CCHAR AND X.CCSPEE><-1  % SEARCH FOR ESCAPE CHARACTER.
060745                  X+2                                     %
060746              OD                                          %
060747              IF A><-1 THEN                               % IF ESCAPE CHARACTER FOUND THEN
060752                  A:=X.CCSPEE                             % GET SPEED AND
060753                  K:="1"                                  % SET FLAG "CORRECT SPEED FOUND".
060754              ELSE                                        %
060755                  A:=TABPART.NSPEED                       % TRY NEXT SPEED.
060757              FI                                          %
060757          ELSE                                            %
060760              A:="ETABLE".CCSPEE                          % GET INITIAL TSPEED.
060762          FI                                              %
060762          *2BANK                                          %
060763          A=:TSPEED; T:=HDEV+DSPEED; *IOXT                % WRITE TO SPEED SELECTION REGISTER.
060767          X:=XREG
060770          IF K THEN                                       % IF SPEED FOUND THEN
060772              TYPRING/\176077=:TYPRING
060775              -36=:TTMR                                   % LOGGIN WITHIN 30 SEC
060777              TINFO BZERO 5SPNFOUND =: TINFO              % RESET BIT "SPEED NOT FOUND".
061002              A:=33; EXITA                                % RETURN WITH ESCAPE CHARACTER.
061004          ELSE                                            %
061005              IF TYPRING NBIT 7 AND NBIT 10 THEN
061012                 A BONE 6=:TYPRING                        % FIRST TRY
061014              FI
061014              -2=:TMR                                     % TIMOUT IN 2 SECONDS.
061016              EXIT                                        %
061017          FI                                              %
061017   RBUS                                                   %
061021
061021
061021   %====================================================================
061021   %            T I A P D
061021   %
061021   % ROUTINE TO READ A CHARACTER FROM TERMINAL USING IOXT!
061021   SUBR TIAPD
061021   TIAPD: T:=HDEV+DST; *IOXT                        % READ STATUS
061024          A=:D; IF A NBIT 3 THEN TTMR; GO PINRE FI  % NOT READY
061031          T+"DDR-DST"; *IOXT                        % READ CHARACTER
061033          IF D BIT 13 THEN                          % CARRIER MISSING?
061035             DFLAG BONE 5LBRK=:DFLAG                % MARK LINE ERROR
061040             -2; GO PINRE                           % START TIMEOUT IN 2 SECONDS
061042          FI
061042          IF T:=TINFO BIT 5SPNFOUND AND T:=X.BITFLAG BIT 5EMPT GO FSPEED  % WRONG SPEED.
061050          IF D BIT 4 THEN
061052             IF D BIT 5 THEN T BONE 5FRER ELSE T BONE 5PAER FI
061057             T=:TINFO
061060             TTMR; GO PINRE                               % PARITY ERROR
061062          FI
061062          T:=DFLAG BZERO 5LBRK=:DFLAG               % LINE IS OK
061065          EXITA
061066   PINRE: A=:TMR:=CNTREG; T:=HDEV+DCONT; *IOXT      % ENABLE INTERRUPT
061073          EXIT
061074   RBUS
061075
061075

061075   %==============================================================================
061075   % 40.5       X O N C H E C K   X O F F C H E C K   O X O N C H E C K
061075   %
061075   % SUBROUTINE TO TELETYPE DRIVERS TO CONTROL
061075   % XON/XOFF SENDING TO TELETYPE INTERFACES
061075   % XOFF IS GIVEN WHEN ONLY 17 FREE CHAR-ENTRIES IN BUFFER
061075   % XON IS GIVEN WHEN HALF THE BUFFER IS FREE AND "XOFF" HAS
061075   % PREVIOUSLY BEEN GIVEN
061075   % LEVEL 12
061075   %
061075   SUBR XONCHECK,OXONCHECK
061075   INTEGER POINTER LREGL
061076   XONCHECK: IF X=0 THEN EXIT FI
061101          IF CFREE>=20 THEN EXIT FI
061106          IF DFLAG NBIT 5RDEVICE THEN
061111             CNTREG BZERO 7=:CNTREG; EXIT          % RESET PIN 19 (V.24)
061115          FI
061115          A BONE 5XOFF BONE 6XOFF=:DFLAG
061120          IF BRECHOFL NBIT 5PINFL THEN
061123             T:=X.HDEV+DCONT; A:=1; *IOXT          % PIN TO START OUTPUT DRIVER
061127          FI
061127          EXIT
061130
061130   % OUTPUT LEVEL, (LEVEL 10)
061130   OXONCHECK:
061130          IF X=0 OR T:=X.DFLAG NBIT 5RDEVICE THEN EXITA FI
061135          IF T:=X.DFLAG BIT 5XON THEN X.XONCR; T BZERO 5XON=:X.DFLAG; EXIT FI
061144          IF T BIT 5XOFF THEN X.XOFCR; T BZERO 5XOFF=:X.DFLAG; EXIT FI
061152          EXITA
061153
061153   RBUS
061153
061153

061153   %==============================================================================
061153   % 40.6       X O N R E A D
061153   %
061153   %
061153   %      SUBROUTINE TO INPUT DRIVERS
061153   %      TO CHECK FOR RECIEVED XON/XOFF FROM LEGAL DEVICE
061153   %      LEVEL 12.
061153   %
061153   %      EXIT  => IGNORE THIS CHAR.
061153   %      EXITA => CHAR. OK AS INPUT.
061153   %
061153   %
061153   %
061153   SUBR XONREAD
061153   XONREAD: A/\177=:D                              % SAVE CHAR FOR TESTS & RETUR.
061155          IF DFLAG NBIT 5XDEVICE THEN EXITA FI     % NOT ALLOWED
061161          IF D=X.XONCR THEN                        % XON RECIEVED.
061164             A BZERO 5OXON =: DFLAG                % FLAG XOFF-STATE
061166             IF A NBIT 5RDEVICE THEN
061170                CNTREG BONE 2=:CNTREG
061173                T:=HDEV+DCONT; *IOXT               % UNLOCK FIFO
061176             FI
061176             IF BRECHOFL NBIT 5PINFL THEN
061201                T:=X.HDEV+DCONT; A:=1; *IOXT       % PIN TO START OUTPUT DRIVER
061205             FI
061205             EXIT
061206          FI
061206          IF D=X.XOFCR THEN
061211             A BONE 5OXON=:DFLAG                   % XOFF; FLAG.
061213             IF A NBIT 5RDEVICE THEN
061215                CNTREG BZERO 2=:CNTREG
061220                T:=HDEV+DCONT; *IOXT               % LOCK FIFO
061223             FI
061223             EXIT
061224          FI
061224          EXITA
061225   RBUS
061226
061226   %==============================================================================
061226   % 40.7       X O N W R I T E
061226   %
061226   %      ROUTINE TO CHECK FOR XOFF-STATE
061226   %      OUTPUT LEVEL (LEVEL 10)
061226   %
061226   %      EXIT  => XOFF STATE / DON'T SEND ANYTHING.
061226   %      EXITA => XON STATE / SEND
061226   %
061226   %            CALLED IN IOF
061226   %            =============
061226   %
061226
061226   SUBR XONWRITE
061226
061226   XONWRITE:
061226          IF X=0 OR X.DFLAG NBIT 5XDEVICE THEN EXITA FI
061233          IF A NBIT 5OXON THEN EXITA FI
061236          EXIT
061237
061237   RBUS
061237

061237   %==============================================================================
061237   %       N O T S   D R I V E R S
061237   %
061237   INTEGER TRMOD=?
061237   SUBR MNLCP,MNCBE,MNRES,MNIND,MNOUD,MNWSC,MNCCP,MNHCP
061237   RBUS
061237   %==============================================================================
061237   %       (M)      M N M A I N   M N N X T
061237   %
061237   % MBNIU MAIN DRIVER, LEVEL 10
061237   %
061237   % THIS DRIVER IS NOT USED BY STDEV
061237   % MNMAIN: ENTRY AFTER INTERRUPT
061237   % MNNXT:  ENTRY FOR PROCESSING NEXT EVENT
061237   %
061237   % ENTRY:  B POINTS TO CONTROLLER DATAFIELD FOR THIS STATION
061237   %
061237   SUBR MNMAIN,MNNXT
061237
061237   %==============================================================================
061237   % GEVENT
061237   % LOCAL SUBROUTINE TO GET AN EVENT FROM MBNIU
061237   %
061237   % B POINTS TO CONTROLLER DATAFIELD
061237   %
061237   INTEGER HEAD,CCC3
061241   DOUBLE  EVENT
061243   GEVENT: T:=MNCBNK; X:="MNCONT+MNEQR"; *LDDTX         % GET EQ READ AND WRITE PTRS.
061246           IF A=D THEN EXIT FI                          % NO MORE EVENTS
061251           IF D BONE 10-A BZERO 10 > X:=340 THEN MIN CCC3; FI
061260           A=:HEAD SHZ 1+"MNCONT+MNEQB"=:X; *LDDTX      % GET EVENT
061265           AD=:EVENT; X:="MNCONT+MNEQR"
061267           A:=HEAD+1 /\ 377; *STATX                     % INCR. HEAD POINTER
061273           AD:=EVENT; EXITA                             % RETURN WITH EVENT IN A/D
061275
061275   %==============================================================================
061275   %       M N M A I N
061275   %
061275   INTEGER ICODE,CCC1,CCC2,CCC4,CCC5
061302   RETURN: T:=HDEV+10; *IOXT                            % READ INTERRUPT POINTER
061305           MNCNTREG; T:=HDEV+5; *IOXT                   % ENABLE FOR INTERRUPT
061311           MIN CCC2                                     % COUNT ENABLES
061312           0=:MNACT; GO WT10                            % WAIT FOR RESTART
061314   MNMAIN: T:=HDEV+4; *IOXT                             % READ STATUS
061317           IF A BIT 4 THEN                              % MULTIBUS TIMEOUT
061321              MIN CCC5; *JMP *3; MIN CCC4; RAND
061325           FI
061325           MIN CCC1                                     % COUNT DRIVER STARTS
061326           MIN MNACT;T:=MNCBNK;X:="MNCONT+MNHST";*LDDTX % INDICATE DRIVER ACTIVE AND GET HOST AND NIU STATE
061332           IF A=MNRST OR D=T GO MNRES                   % FORCED RESET ?
061337   FORTS:  CALL GEVENT; GO RETURN                       % GET EVENT, RETURN IF NONE
061341           A /\ 7 GOSW MNOUD,MNIND,MNLCP,MNCBE,MNCCP,MNHCP,ERRFATAL,MNWSC
061353   MNNXT:  GO FORTS                                     % THIS LOCATION CAN BE PATCHED TO 124001
061354           T:=HDEV+5; 2; *IOXT                          % ENABLE OTHER LEVEL 10 RESOURCES BEFORE NEXT EVENT
061360           0=:MNACT; GO WT10                            % WAIT FOR INTERRUPT
061362   RBUS
061403

061403   %==============================================================================
061403   %       (M)      M N I N D   M N I N T
061403   %
061403   % MBNIU INPUT DRIVER, LEVEL 10
061403   %
061403   % MNIND: CALLED FROM MBMAIN
061403   %        RETURNS TO MBMAIN
061403   % MNINS: CALLED FROM STDEV (BY TIMER WHEN EVENT WAS NOT FINISHED)
061403   %        RETURN BY LEAVING LEVEL
061403
061403   SUBR MNIND,MNINS
061403
061403   %------------------------------------------------------------------------------
061403   % RCHAR
061403   % LOCAL SUBROUTINE TO READ ONE CHARACTER FROM MBNIU INPUT BUFFER.
061403   %
061403   INTEGER MAXGET
061404   RCHAR:  T:=10DFOPP.MNWBNK; IF X:=MNGET >= A:=MAXGET GO NXBUF % CHECK IF THIS BUFFER IS EMPTY
061412   FORTS:  *LDATX                                       % READ CHAR.
061413           X+1=:MNGET; EXITA                            % INCR. GET POINTER AND EXIT
061416   NXBUF:  X:=MNCURB+MNBST; "0"; *STATX                 % RELEASE BUFFER
061422           X:=MNCURB+MNBLI;*LDDTX;SHD ZIN 10;RADD SD DA % NEXT BUFFER IN LINK
061427           A+MNWAD=:MNCURB+MNBST=:X; *LDATX             % GET BUF. STATE
061434           X:=MNCURB+MNDAT=:MNGET                       % RESET GET POINTER
061437           IF A=0 THEN EXIT FI                          % EXIT IF EMPTY
061441           X=:D:=MNCURB+MNNOB; *LDATX                   % GET NUMBER OF BYTES PRESENT
061445           IF A=0 GO NXBUF                              % EMPTY BUFFER
061446           A+D=:MAXGET; X:=D; GO FORTS                  % CONTINUE
061452   *)FILL
061453
061453   %------------------------------------------------------------------------------
061453   %       M N I N D   M N I N S
061453
061453   INTEGER POINTER RETU
061454
061454   MNIND:  MNIDF(D):=:B=:10SVB;"DRETU"=:"RETU";GO FELLS % ENTRY FROM MNMAIN
061463   MNINS:  MIN MNACT; "SRETU"=:"RETU"                   % ENTRY FROM STDEV, INDICATE DRIVER ACTIVE
061466   FELLS:  ISTATE=:OISTATE; CALL SET10WINDOW
061471           1777/\DFOPP=:X:=B/\176000; X+A=:10DFOPP      % SET UP OPPOSITE
061500           X.BITFLAG BZERO 5CLOU=:X.BITFLAG             % RESET CLEAR OUTPUT FLAG
061503           0=:TMR; MNTMFL BZERO 5MNDL=:MNTMFL           % DO NOT DISCONNECT BECAUSE OF LOGOUT
061507           T:=X.MNWBNK; X:=MNCURB+MNBST; *LDATX         % GET STATE OF CURRENT BUF.
061513           IF A=0 GO RETU                               % NOTHING IN MBNIU BUFFER
061515           X:=MNCURB+MNNOB; *LDATX                      % GET NO OF BYTES IN BUFFER
061520           A+MNCURB+MNDAT=:MAXGET                       % COMPUTE MAX. GET ADDR. IN BUFFER
061523   NXTCH:  IF CFREE=0 THEN
061525              MNTMFL BONE 5MNRS=:MNTMFL                 % IF BUFFER FULL THE DRIVER SHOULD
061530              -1=:TMR; GO RETU                          % BE RESTARTED BY TIMER.
061533           FI
061533           CALL RCHAR; GO RETU; A=:LAST                 % READ CHARACTER
061536           BRECHOFL/\177770=:BRECHOFL                   % CLEAR BREAK/ECHO FLAG
061541           IF DFLAG BIT 5CAPITAL THEN                   % CONVERT LOWER CASE TO UPPER CASE
061544              LAST/\177=:T
061547              IF 140<T AND 176>T AND CESCP SHZ -10/\177><T AND CESCP/\177><T THEN
061566                 LAST BZERO 5=:LAST                     % CONVERT ALL EXEPT
061571              FI                                        % RUBOUT  AND DISCONNECT
061571           FI
061571           IF 10DFOPP.SCREEN><0 THEN                    % TWO WAY DEVICE WITH CR-DELAY
061574              IF <0 THEN -1=:X.TMR FI
061577              1=:X.SCREEN
061601              IF LAST=0 THEN                            % IGNORE TAPE-FEED?
061603                 IF FLAGB NBIT 5LCHAR GO NXTCH
061606                 IF CESCP SHZ-10><0 GO NXTCH
061611              FI
061611           FI
061611           IF T:=DFLAG NBIT 5SPEC AND T NBIT 5CTRLO THEN
061616              CALL ESCAPE; GO NXTCH; X:=10DFOPP
061621           FI
061621           IF DFLAG NBIT 5CTRLO THEN
061624              IF LAST/\177=17 THEN
061631                 DFLAG BONE 5CTRLO=:DFLAG
061634              FI
061634           ELSE
061635              DFLAG BZERO 5CTRLO=:DFLAG
061640           FI
061640           IF CFREE=0 THEN
061642              TINFO BONE 5BFUL=:TINFO; GO BFULL         % BUFFER IS FULL, RESTART USER
061646           FI
061646           GO BYP1
061647   *)FILL
061663   BYP1:   IF DFLAG BIT 5ECHO THEN
061666              LAST/\377
061670              *IOF
061671              CALL TECHO                                %TEST FOR ECHO
061672              CALL TBREAK                               %TEST FOR BREAK
061673              *ION
061674           ELSE
061675              IF OISTATE=-1 THEN         % NOWAIT MODE
061701                 LAST/\377; CALL CXRBPUT; GO BFULL
061705              FI
061705           FI
061705           IF BRECHOFL<0 THEN 7=:LAST; GO IGNCH FI      % IGNORE CHAR?
061712
061712   ADDCH:  LAST/\377; CALL CXRBPUT                      % PUT CHARACTER IN BUFFER
061715   IGNCH:
061715           IF BHOLD>=MAX-10 AND BRECHOFL NBIT 5BREAK GO BFULL % FULL BUFFER
061725           IF BRECHOFL BIT 5BREAK THEN                  % BREAK ACCORDING TO STRATEGY
061730              DFLAG BZERO 5ECHO                         % ECHO OFF IN DRIVER
061732              IF X:=FYLLE=HENTE THEN
061736                 A BONE 5ALEC                           % WHOLE BUFFER IS ECHOED BY DRIVER
061737              ELSE
061740                 A BZERO 5ALEC                          % PART OF BUFFER MUST BE ECHOED BY IOTRANS
061741              FI; A=:DFLAG; X=:RSISTE                   % RSISTE IS FIRST CHARACTER NOT ECHOED
061743           ELSE
061744              GO ECHTST; *)FILL
061752           FI
061752
061752   BFULL:  CALL TSTBACK                                 % RESTART PROGRAM
061753   *"8N500
"061753           IF X:=IN5MSG >< 0 THEN
061755              T:=5MBBANK; *AAX MLFLA; LDATX
061760              IF A=0 THEN
061761                 A:=1; *STATX
061763                 "IBMOVE"; CALL CXRTACT
061765              FI
061765           ELSE
061766              IF OISTATE=-1 OR A=-2 THEN
061775                 *IOF
061776                 CALL PNW5ST; GO FAR NION; *ION
062001              FI
062001              "IORESTART"; CALL CXRTACT
062003           FI
062003   *"
"062003   *"-8N500
"062003
062003   ECHTST: IF BRECHOFL<0 OR A BIT 5ECHO THEN            % SOMETHING TO ECHO
062007              IF 10DFOPP.MINBHOLD BIT 5BLOC THEN        % OUTP. BUFFER LOCKED
062013                 DFLAG BZERO 5ECHO=:DFLAG
062016                 BRECHOFL BZERO 5BREAK=:BRECHOFL
062021                 -1=:RSISTE; GO FAR NXTCH
062024              FI
062024              X:=:B=:10DFOPP
062026              IF BHOLD=0 THEN
062030                 CALL MNOUE; GO MNFULL                  % WRITE DIRECT IN MBNIU BUFFER
062032              ELSE
062033   MNFULL:       IF CFREE >< 0 THEN
062035                    10DFOPP.LAST; CALL CXRBPUT          % INSERT IN RING BUFFER
062040                 FI
062040              FI
062040              X:=10DFOPP:=:B=:10DFOPP
062043           FI
062043   NION:   *ION
062044           GO FAR NXTCH
062045
062045   DRETU:  A:=10SVB=:B; GO MNNXT
062050   SRETU:  0=:MNACT; GO WT10
062052   RBUS
062072

062072   %==============================================================================
062072   %       (M)      M N O U E   M N O U S   M N O U D
062072   %
062072   % OUTPUT-DRIVER ROUTINE FOR MBNIU ON LEVEL 10!
062072   %
062072   % MNOUE: CALLED BY INPUT DRIVER TO GIVE ECHO DIRECT IN MBNIU OUTPUT BUFFER
062072   %        RETURNS TO L-REG
062072   % MNOUS: CALLED BY STDEV
062072   %        RETURNS BY GIVING UP PRIORITY
062072   % MNOUD: CALLED BY MNMAIN
062072   %        RETURNS TO MNMAIN
062072   %
062072   SUBR MNOUE,MNOUS,MNOUD
062072
062072   SYMBOL  SUFFS=5               % SUFFICIENT SPACE FOR ECHO
062072
062072   %-----------------------------------------------------------------------------
062072   % SDFWI
062072   % LOCAL SUBROUTINE TO SET UP WINDOW FOR DATAFIELD AND FIND BUFFER START
062072   %
062072   INTEGER POINTER LLRG
062073   SDFWI:  A:=L=:"LLRG"; ISTATE=:OISTATE; CALL SET10WINDOW   % SET UP WINDOW
062100           1777/\DFOPP=:X:=B/\176000; X+A=:10DFOPP           % SET UP OPPOSITE
062107           A+BUFST=:10BUFST; GO LLRG                         % FIND BUFFER START
062112
062112   %----------------------------------------------------------------------------
062112   % CHFREE
062112   % LOCAL SUBROUTINE TO FIND SPACE AVAILABLE IN MBNIU OUTP. BUFFER
062112   %
062112   INTEGER LOOPS,MNMSIZ:=160                            % MNMSIZ CAN BE USED TO TUNE SYSTEM
062114   CHFREE: T:=MNWBNK; X:=10DFOPP.MNWAD+"MNMSC"; *LDATX  % GET MAX SEND COUNT
062121           IF A>X:=MNMSIZ THEN A:=X FI                  % IN CASE OF SYNC. MODEMS
062125           A=:MNBSIZ; 0=:MNNBT; 0=:MNFREE; -10=:LOOPS
062132           10DFOPP.MNWAD+MNBST=:X; 200=:D
062140           DO
062140              X+D; *LDATX                               % GET BUFFER STATE
062142              IF A=0 THEN MIN MNFREE FI                 % INCR. NO. OF FREE BUFFERS
062144              MIN LOOPS                                 % SKIP OD WHEN ZERO
062145           OD
062146           MNFREE*MNBSIZ=:MNFREE   % COMPUTE NO. OF FREE CHARS
062151           EXIT
062152
062152   %----------------------------------------------------------------------------
062152   % MNDIS
062152   % LOCAL SUBROUTINE TO DISCONNECT AN NIU IF BUFFER IS EMPTY
062152   %
062152   MNDIS:  IF BHOLD><0 THEN EXIT FI                         % RINGBUFFER NOT EMPTY
062155           IF 10*MNBSIZ>MNFREE THEN EXIT FI                 % MBNIU BUFFER NOT EMPTY
062163           10DFOPP.MNTMFL BONE 5MNRQ=:X.MNTMFL              % INDICATE REQUEST OUTSTANDING
062167           T:=MNWBNK; X:=10DFOPP.MNWAD+MNREQ; MNHAN; *STATX % REQUEST HANGUP
062175           EXIT
062176
062176   %------------------------------------------------------------------------------
062176   % SBU
062176   % LOCAL SUBROUTINE TO SEND MBNIU OUTPUT BUFFER
062176   % DESTROYES T,X,D REGISTERS.
062176   %
062176   INTEGER SVA
062177   SBU:    IF X:=MNNBT=0 THEN EXIT FI                       % NO NEED TO SEND EMPTY BUFFER
062203           A=:SVA:=X; T:=MNWBNK; X:=MNCURB+MNNOB; *STATX    % UPDATE NUMBER OF BYTES
062211           X+"MNTCB-MNNOB"; A:=0; *STATX                    % SET TRANSP. CONTR. BITS TO ZERO
062214           X+"MNDTY-MNTCB"; *STATX                          % SET DATA TYPE TO ZERO
062216           X+"MNBST-MNDTY"; A:=1; *STATX                    % SEND BUFFER
062221           X+"MNBLI-MNBST"; *LDDTX                          % FIND NEXT BUFFER
062223           D SHZ 10; A+D+10DFOPP.MNWAD=:MNCURB+MNDAT=:MNFILL
062232           0=:MNNBT; A:=SVA; EXIT
062235   *)FILL
062247
062247   %------------------------------------------------------------------------------
062247   % PRTCHAR
062247   % LOCAL SUBROUTINE TO WRITE ONE CHARACTER IN MBNIU OUTPUT BUFFER.
062247   % DESTROYES T,X REGISTERS.
062247   % EXIT IF NO SPACE IN BUFFER, OTHERVISE EXITA
062247   %
062247   INTEGER CCHAR
062250   PRTCHAR:T:=MNWBNK; X:=MNFILL; A/\10MASK; *STATX      % WRITE CHARACTER IN BUFFER
062254           MIN MNFILL
062255           IF X:=MNNBT+1=:MNNBT = MNBSIZ GO SBU         % BUFFER FULL
062263           EXIT
062264   *)FILL
062267
062267   %------------------------------------------------------------------------------
062267   % COLCH
062267   % LOCAL SUBROUTINE TO GET CHARACTER FROM OWN BUFFER
062267   %
062267   COLCH:  TAD:=FFMAX; IF A=0 THEN EXIT FI              % BUFFER EMPTY
062272           A-1;D=:X+1; IF D=T THEN D:="0" FI;AD=:DBHOLD % UPDATE BUFFER POINTERS
062301           MIN CFREE; T:=10BUFST; *LBYT; EXIT AD1       % GET CHARACTER FROM BUFFER
062305   *)FILL
062306
062306   %-----------------------------------------------------------------------------
062306   % MSLOW
062306   % LOCAL SUBROUTINE TO COPY FROM OWN BUFFER TO MBNIU BUFFER WHEN TERMOD IS SET.
062306   %
062306   INTEGER POINTER LREG
062307   INTEGER SVXX
062310   MSLOW:  A:=L=:"LREG"
062312           DO
062312              IF TRMOD BIT 1 THEN 6 ELSE 1 FI              % CR DELAY 6 CHAR ELSE 1 FREE
062320              IF A > MNFREE GO LREG                        % ENOUGH SPACE IN MBNIU ?
062323              IF TRMOD BIT "0" THEN                        % STOP ON FULL PAGE USED
062326                 IF SCREEN<0 THEN                          % NOT RESTARTED FROM FULL PAGE
062330                    BITFLAG BONE 5EMPT=:BITFLAG; GO LREG
062334                 FI
062334                 IF A>24 THEN
062337                    -1=:SCREEN; 7; CALL PRTCHAR; GO LREG   % FULL PAGE PRINT BELL
062344                 FI
062344              FI
062344              CALL FAR COLCH; GO LREG                      % GET CHARACTER FROM BUFFER
062346              IF T:=TRMOD BIT "0" THEN
062351                 IF =12 THEN MIN SCREEN FI                 % COUNT LINES
062355                 IF =14 THEN T+24=:SCREEN FI               % NEW PAGE
062362              FI
062362              CALL PRTCHAR; X:=MNFREE-1=:MNFREE            % WRITE CHARACTER
062366              IF T:=TRMOD BIT 1 THEN                       % CR DELAY USED
062371                 IF A BZERO 7=15 THEN                      % CR CAUSES DELAY
062375                    X:=-5; A:=0
062377                    FOR X DO
062377                       X=:SVXX; CALL PRTCHAR; X:=SVXX
062402                    OD
062403                 FI
062403              FI
062403           OD
062404   *)FILL
062407
062407   %----------------------------------------------------------------------
062407   % MEWRIT
062407   % LOCAL SUBROUTINE TO WRITE ERROR MESSAGE TO MBNIU BUFFER
062407   %
062407   DISP 0; DOUBLE EBUHF=EBUHENTE; PSID               % HENTE AND FYLLE IN ERROR BUFFER
062407
062407   MEWRIT: A:=L=:"LREG"
062411           IF 10DFOPP.FLAGB BIT 5LSTA AND X:=EBUWRITE><0 GO FRLI
062420           DO WHILE X:=EBUWRITE><0
062422              DO WHILE X.EBUHENTE><X.EBUFYLLE
062426                 X=:T:=A; *LBYT                      % COLLECT BYTE
062431                 X:=T; MIN X.EBUHENTE                % UPDATE HENTE
062433                 CALL FAR PRTCHAR; MNFREE-1=:MNFREE  % WRITE CHARACTER
062437                 IF A=0 GO EOUT                      % MBNIU BUFFER FULL
062440                 X:=EBUWRITE
062441              OD
062442   FRLI:      X.EBULINK=:EBUWRITE                    % WHOLE BUFFER PRINTED
062444              T:=EBUFREE=:X.EBULINK; X=:EBUFREE      % PUT IN FREE LIST
062447           OD
062450           10DFOPP.TINFO BZERO 5ERRMSG=:X.TINFO
062454   EOUT:   GO LREG
062455   *)FILL
062462   %-----------------------------------------------------------------------------
062462   % MFAST
062462   % LOCAL SUBROUTINE TO COPY FROM OWN BUFFER TO MBNIU BUFFER WHEN TERMOD IS 0.
062462   %
062462   INTEGER COUNT,CC1,CC2
062465   INTEGER POINTER LRE2
062466   MFAST:  A:=L=:"LRE2"
062470           DO
062470              TAD:=FFMAX; T=:CC2                        % MAX=:CC2
062472              IF A>X:=MNBSIZ THEN A:=X FI               % NO. OF BYTES TO MOVE IN THIS SESSION
062476              A=:MNNBT; A-=:COUNT:=10BUFST=:L           % L=BUFFER START, D=HENTE
062503              T:=MNWBNK; X:=MNFILL
062505              DO
062505                 T:=:L; X:=:D; *LBYT                    % GET CHARACTER
062510                 T:=:L; X:=:D; A/\10MASK; *STATX        % WRITE CHARACTER
062514                 *RINC DX; RINC DD
062516                 IF CC2=D THEN D:=0 FI                  % END OF RING BUFFER ?
062522                 MIN COUNT                              % SKIP OD WHEN ZERO
062523              OD
062524              A=:T:=BHOLD-MNNBT; AD=:DBHOLD; T-A=:CFREE % UPDATE RING BUFFER POINTERS
062532              CALL FAR SBU                              % SEND BUFFER
062533              T:=MNWBNK; X:=MNCURB+MNBST; *LDATX        % GET STATE OF NEXT BUFFER
062537              IF A><0 OR BHOLD=0 GO LRE2                % FINISHED ?
062543           OD
062544   *)FILL
062551   %-----------------------------------------------------------------------------
062551   % MF500
062551   % LOCAL SUBROUTINE TO COPY FROM 500 BUFFER TO MBNIU BUFFER WHEN TERMOD IS 0.
062551   %
062551   INTEGER N5BYT,CC3,CC4,SVD,SVL
062556   INTEGER POINTER LRE3
062557   MF500:  A:=L=:"LRE3"
062561           T:=5MBBANK; ON5MSG+"NOBYT"=:X; *LDATX; STA N5BYT      % NO. OF BYTES IN BUFFER
062567           IF A=0 GO B5EMPT                                      % EMPTY BUFFER
062570           "HBUFA-NOBYT"; X+A; *LDATX; AAX 5HENT-HBUFA; LDXTX    % BUFFER START AND READ POINTERS
062575           A=:L; X=:D
062577           IF MNFREE>=N5BYT THEN A:=T FI                         % MAX NO. TO MOVE
062604           A=:CC3; T-A=:N5BYT:=A                                 % N5BYT = CHARS. LEFT AFTER MOVE
062610           DO WHILE CC3>< 0
062612              IF MNBSIZ>=CC3 THEN A:=T FI; T-A=:CC3; A=:MNNBT    % NO OF CHARS TO MOVE IN THIS SESSION
062622              T:=MNWBNK; A+1 SHZ -1-=:CC4; X:=MNFILL
062630              DO
062630                 T:=:L; X:=:D; *LDATX                            % GET 2 BYTES
062633                 T:=:L; X:=:D; A/\10MASK SHR 10; *STATX          % STORE LEFT BYTE
062640                 *RINC DX; SHA SHR 10; STATX; RINC DX; RINC DD   % STORE RIGHT BYTE
062645                 MIN CC4                                         % SKIP OD WHEN ZERO !!!!!
062646              OD
062647              A:=L=:SVL:=D=:SVD; CALL FAR SBU; SVD=:D; SVL=:L    % SEND BUFFER
062660           OD
062661           X:=D; N5BYT; CALL 5CMOR; GO LRE3                      % CHECK IF ND500 BUFFER EMPTY.
062665   B5EMPT: X:=ON5MSG; 0=:ON5MSG; *IOF; JPL I (PT5RS; ION         % RESTART 500
062672           GO LRE3
062673   *)FILL
062705   %-----------------------------------------------------------------------------
062705   % MIGNO
062705   % LOCAL SUBROUTINE TO EMPTY OWN BUFFER WHEN FORCED RESET OR CONNECTION BROKEN
062705   %
062705   MIGNO:  TAD:=FFMAX; T=:CFREE; A:=D=:FYLLE; 0=:BHOLD  % EMPTY BUFFER
062712           MINBHOLD BZERO 5BLOC=:MINBHOLD
062715           EXIT
062716   *)FILL
062716   %------------------------------------------------------------------------------
062716   %      M N O U E   M N O U S   M N O U D
062716
062716   INTEGER POINTER RETU
062717   INTEGER SVX
062720
062720   MNOUE:  A:=L=:"RETU"; CALL FAR CHFREE                % ENTRY FROM INP. DRIVER
062723           IF A>0 THEN
062725              BITFLAG BZERO 5EMPT=:BITFLAG              % INDICATE DRIVER BUSY
062730              10DFOPP.LAST; CALL FAR PRTCHAR            % PRINT CHAR. AND
062733              CALL FAR SBU; MIN "RETU"                  % SEND BUFFER
062735           FI
062735           GO RETU
062736   MNOUS:  MIN MNACT; "SRETU"=:"RETU"; CALL FAR SDFWI   % ENTRY FROM STDEV, INDICATE DRIVER ACTIVE
062742           IF X.FLAGB BIT 5LSTA THEN 1600=:MNFREE; GO FELLS; FI
062750           CALL FAR CHFREE; IF A=0 GO RETU              % EXIT IF NO FREE SPACE
062753           GO FELLS
062754   MNOUD:  MNODF(D):=:B=:10SVB; "DRETU"=:"RETU"         % ENTRY FROM MBMAIN
062762           CALL FAR SDFWI; CALL FAR CHFREE; IF A=0 GO RETU
062766   FELLS:  BITFLAG BONE 5EMPT=:BITFLAG
062771           IF 10DFOPP.MNTMFL BIT 5MNDI THEN             % DISCONNECT WANTED ?
062775              CALL FAR MNDIS
062776           FI
062776           A:=10DFOPP.TINFO; X:=0                       % GET TINFO AND ZERO MODE
063001           IF A BIT 5UMOD THEN T:=-1 ELSE T:=77577 FI   % BUILD MASK
063006           T=:10MASK
063007           IF A BIT 5CRDLY THEN X BONE 1 FI             % CARRIAGE RETURN DELAY (TINFO)
063012           IF T:=SCREEN><0 THEN X BONE "0" FI           % STOP ON FULL PAGE ENABLED
063016           X=:TRMOD                                     % SAVE MODE
063017           IF A BIT 5ERRMSG THEN                        % ERROR MESSAGE TO ERROR DEVICE
063021              CALL FAR MEWRIT; CALL FAR SBU
063023              IF MNFREE=0 GO RETU
063026           FI
063026   *"8N500
"063026           IF BHOLD=0 AND ON5MSG=0 GO RETU
063033   *"-8N500
"063033           IF 10DFOPP.FLAGB BIT 5LSTA THEN              % LINE DEAD ?
063037              CALL MIGNO                                % CLEAR OUTPUT BUFFER
063040           ELSE
063041              BITFLAG BZERO 5EMPT=:BITFLAG              % DRIVER WILL BE RESTARTED BY INTERRUPT OR TIMER
063044              TTMR=:TMR
063046   *"8N500
"063046              IF TRMOD=0 THEN                           % NOT CR DELAY OR STOP ON FULL PAGE ?
063050                 IF ON5MSG><0 AND BHOLD=0 THEN
063054                    CALL FAR MF500
063055                 ELSE
063056                    CALL FAR MFAST
063057                 FI
063057              ELSE
063060                 IF X:=ON5MSG><0 THEN CALL M5TORB FI
063063                 CALL FAR MSLOW; CALL FAR SBU           % MOVE WITH CHECK FOR CR DELAY OR STOP ON FULL PAGE
063065              FI
063065   *"-8N500
"063065           FI
063065           GO RETU                                      % SEND LAST BUFFER BEFORE RETURN
063066   *)FILL
063112   %------------------------------------------------------------------------------
063112   % RSINP
063112   % LOCAL SUBROUTINE TO RESTART USER IF INPUT IS WAITING FOR ECHO
063112   %
063112   INTEGER SAVB; INTEGER POINTER LRE1
063114
063114   RSINP:  A:=L=:"LRE1"
063116           IF 10DFOPP.BRECHOFL BIT 5WECH THEN
063122              A BZERO 5WECH=:X.BRECHOFL; X:=:B=:SAVB
063126   *"8N500
"063126              IF X:=IN5MSG><0 THEN
063130                 *IOF
063131                 T:=5MBBANK; *AAX MLFLA; LDATX
063134                 IF A = 0 THEN                          % IBMOVE NOT ALREADY ACTIVE
063135                    A:=1; *STATX                        % MARK IBMOVE ACTIVE
063137                    "IBMOVE"
063140                 ELSE                                   % IBMOVE ALLREADY ACTIVE
063141                    GO OUT
063142                 FI
063142                 *ION
063143              ELSE
063144                 CALL TSTBACK; "IORESTART"
063146              FI
063146   *"-8N500
"063146   OUT:       CALL CXRTACT
063147              SAVB=:B
063151           FI
063151           GO LRE1
063152   *)FILL
063160
063160   %------------------------------------------------------------------------------
063160   % RSOUT
063160   % LOCAL SUBROUTINE TO RESTART USER IF MINBHOLD IS REACHED IN OUTPUT BUFFER
063160   %
063160   RSOUT:  IF OISTAT=0 THEN EXITA FI
063163           X:=BHOLD; T:=MINBHOLD BZERO 5BLOC BZERO 5NOWT
063167           IF X>T THEN EXIT FI
063172           IF A<0 THEN
063173              IF MINBHOLD NBIT 5NOWT THEN EXITA FI
063177              A BZERO 5NOWT=:MINBHOLD
063201           FI
063201           A:=L=:"LRE1"; "IORESTART"; CALL CXRTACT
063205           GO LRE1; *)FILL
063211
063211   %------------------------------------------------------------------------------
063211   %      RETURN
063211
063211   SRETU: CALL RSOUT; *JMP *1                           % CALLED BY STDEV
063213          0=:MNACT; GO WT10                             % LEAVE LEVEL 10
063215   DRETU: CALL RSOUT; GO BYP1                           % CALLED BY MNMAIN
063217          IF CFREE>=SUFFS THEN CALL RSINP FI
063224   BYP1:  A:=10SVB=:B; GO MNNXT                         % LEAVE OUTPUT DRIVER
063227
063227   RBUS
063233   %

063233   %==============================================================================
063233   %       (M)      M N L C P
063233   %
063233   % MBNIU LISTEN COMPLETED, LEVEL 10
063233   %
063233   %
063233   SUBR MNLCP
063233   MNLCP:  MNIDF(D):=:B=:10SVB; CALL SET10WINDOW
063240           1777/\DFOPP=:X:=B/\176000;X+A=:10DFOPP       % SET UP OPPOSITE
063247           X:=TDRADDR; T:=9CXTI+X
063252           IF X.RTRES=0 AND T.RTRES=0 THEN              % DF NOT RESERVED
063257              MNTMFL BZERO 5MNRQ BZERO 5MNDL=:MNTMFL    % RESET REQUEST OUTSTANDING
063263              CALL CLBUF                                % CLEAR INPUT BUFFER
063264              IF MNCDF.MNCFL NBIT 5MNTT THEN            % SHOULD TERM TYPE BE RESET ?
063270                 0=:CTTYP
063271              FI
063271              T:=TINFO
063272              IF A BIT 5MN8I THEN T BONE 58BIT ELSE T BZERO 58BIT FI
063277              T=:TINFO                                  % 8 BITS MODUS OR NOT
063300              10DFOPP.MINBHOLD BZERO 5BLOC=:X.MINBHOLD  % RESET OUTP. BUFFER LOCK
063304              FLAGB BZERO 5LSTA=:FLAGB                  % RESET LINE DEAD
063307              MNWAD+MNIBU=:MNCURB+MNDAT=:MNGET          % DATA TRANSFER START IN FIRST BUFFER
063314              MNWAD+MNOBU=:10DFOPP.MNCURB+MNDAT=:X.MNFILL
063322           ELSE
063323              MNTMFL BONE 5MNLR=:MNTMFL; -2=:TMR        % TIMER SHOULD FIND OUT WHEN DF IS FREE
063330              T:=10DFOPP.MNWBNK; X:=MNWAD+MNREQ; 22; *STATX     % REQUEST 'HANGUP'
063336           FI
063336           10SVB=:B; GO MNNXT
063341   RBUS
063352
063352   %==============================================================================
063352   %       (M)      M N C C P
063352   %
063352   % MBNIU OUTGOING CALL COMPLETED, LEVEL 10
063352   %
063352   %
063352   SUBR MNCCP
063352   INTEGER CC1
063353   MNCCP:  MNIDF(D):=:B=:10SVB; CALL SET10WINDOW
063360           1777/\DFOPP=:X:=B/\176000;X+A=:10DFOPP       % SET UP OPPOSITE
063367           T:=X.MNWBNK; X:=MNWAD+"MNRSP"; *LDATX        % GET RESPONSE
063373           A=:CC1; X:=TDRADDR; T:=9CXTI+X
063377           IF X.RTRES><0 AND T.RTRES><0 THEN            % DF RESERVED
063404              MNTMFL BZERO 5MNRQ=:MNTMFL                % RESET REQUEST OUTSTANDING
063407              IF CC1=0 THEN                             % OK RESPONSE
063411                 T:=TINFO
063412                 IF MNCDF.MNCFL BIT 5MN8O THEN
063416                    T BONE 58BIT
063417                 ELSE
063420                    T BZERO 58BIT
063421                 FI
063421                 T=:TINFO                               % 8 BITS MODUS OR NOT
063422                 FLAGB BZERO 5LSTA=:FLAGB               % RESET LINE DEAD
063425                 MNWAD+MNIBU=:MNCURB+MNDAT=:MNGET       % DATA TRANSFER START IN FIRST BUFFER
063432                 MNWAD+MNOBU=:10DFOPP.MNCURB+MNDAT=:X.MNFILL
063440              ELSE
063441                 MNTMFL BONE 5MNER=:MNTMFL              % INDICATE ERROR RESPONSE
063444              FI
063444           ELSE
063445              MNTMFL BZERO 5MNRQ=:MNTMFL                % RESET REQUEST OUTSTANDING
063450           FI
063450           10SVB=:B; GO MNNXT
063453   RBUS
063463
063463   %==============================================================================
063463   %       (M)      M N H C P
063463   %
063463   % MBNIU HANGUP COMPLETED, LEVEL 10
063463   %
063463   %
063463   SUBR MNHCP
063463   MNHCP:  MNIDF(D):=:B=:10SVB; CALL SET10WINDOW
063470           1777/\DFOPP=:X:=B/\176000;X+A=:10DFOPP       % SET UP OPPOSITE
063477           MNTMFL BZERO 5MNRQ BZERO 5MNDI=:MNTMFL       % RESET REQUEST OUTSTANDING
063503           FLAGB BONE 5LSTA=:FLAGB                      % SET TERMINAL LINE DEAD
063506           -1=:10DFOPP.TMR
063511           10SVB=:B; GO MNNXT
063514   RBUS
063522
063522   %==============================================================================
063522   %       (M)      M N C B E
063522   %
063522   % MBNIU CONNECTION BROKEN EVENT, LEVEL 10
063522   %
063522   %
063522   SUBR MNCBE
063522   INTEGER COUNT
063523   MNCBE:  MNIDF(D):=:B=:10SVB; CALL SET10WINDOW
063530           1777/\DFOPP=:X:=B/\176000;X+A=:10DFOPP          % SET UP OPPOSITE
063537           FLAGB BONE 5LSTA=:FLAGB;                        % SET LINE DEAD
063542           IF MNTMFL BIT 5MNOU THEN                        % RESERVED FOR OUTGOING ?
063545              -1=:10DFOPP.TMR                              % TIMER SHOULD HANDLE THIS
063550           ELSE
063551              X:=TDRADDR; T:=9CXTI+X
063554              IF X.RTRES=0 AND T.RTRES=0 THEN              % DATAFIELD FREE ?
063561                 MNTMFL BONE 5MNRQ=:MNTMFL
063564                 MNCDF.MNLNG-=:COUNT; X."MNNAP"=:D
063572                 T:=10DFOPP.MNWBNK; X:=MNWAD+MNNAS; L:=0   % X POINTS TO NAME STRING
063577                 FOR COUNT DO                              % COPY NAME STRING
063577                    T:=:D; X:=:L; *LBYT                    % GET BYTE
063602                    T:=:D; X:=:L; *STATX                   % STORE BYTE
063605                    X+1;L+1
063607                 OD
063611                 X:=MNWAD+MNNAL; A:=L; *STATX              % NAME LENGTH
063615                 T:=10DFOPP.MNWBNK; X:=MNWAD+MNREQ; MNLIS; *STATX  % REQUEST FOR 'LISTEN'
063623              ELSE
063624                 MNTMFL BONE 5MNLG BONE 5MNLR=:MNTMFL      % TIMER SHOULD START LOGOUT AND REQUEST 'LISTEN' WHEN DF IS FREE
063630                 -1=:TMR=:10DFOPP.TMR                      % ACTIVATE TIMER
063634           FI;FI
063634           10SVB=:B; GO MNNXT
063637   RBUS
063645
063645   %==============================================================================
063645   %       (M)      M N R E S
063645   %
063645   % MBNIU RESTART ROUTINE, LEVEL 10
063645   %
063645   %
063645   SUBR MNRES
063645   INTEGER SVB,COUNT
063647   MNRES:  T:=MNCBNK; X:="MNCONT+MNHST"; MNRST; *STATX     % SET HOST STATE TO 'RESTART'
063653           0=:COUNT; A:=B=:SVB
063656           FOR COUNT TO 37 DO
063662              IF MNIDF(A)><0 THEN
063665                 A=:B; CALL SET10WINDOW
063667                 1777/\DFOPP=:X:=B/\176000;X+A                % SET UP OPPOSITE
063675                 FLAGB BONE 5LSTA=:FLAGB                      % INDICATE LINE DEAD
063700                 "0" BONE 5MNLG=:MNTMFL; -1=:TMR=:X.TMR       % TIMER SHOULD START LOGOUT
063706                 SVB=:B
063710              FI
063710           OD
063714           -2=:TMR; 0=:MNACT; GO WT10                      % ACTIVATE TIMER ROUTINE AND LEAVE LEVEL.
063720   RBUS
063726
063726   %==============================================================================
063726   %       (M)      M N W S C
063726   %
063726   % MBNIU ROUTINE ACTIVATED AT WINDOW STATE CHANGE, LEVEL 10
063726   %
063726   %
063726   SUBR MNWSC
063726   INTEGER COUNT,CC1
063730   MNWSC:  MNIDF(D):=:B=:10SVB; X=:CC1; CALL SET10WINDOW
063736           1777/\DFOPP=:X:=B/\176000;X+A=:10DFOPP         % SET UP OPPOSITE
063745           IF CC1<2 GO NEXT                               % CI WINDOW
063751           IF CC1-2<MNCDF.MNOUT THEN                      % RESERVED FOR OUTGOING ?
063757              MNTMFL BONE 5MNOU=:MNTMFL                   % INDICATE RESERVED FOR OUTGOING
063762              T:=10DFOPP.MNWBNK; X:=MNWAD+MNERE;73;*STATX % ENABLE EVENTS
063770           ELSE
063771              T:=10DFOPP.MNWBNK; X:=MNWAD+MNERE;57;*STATX % ENABLE EVENTS
063777              X:=TDRADDR; T:=9CXTI+X
064002              IF X.RTRES=0 AND T.RTRES=0 THEN             % DATAFIELD FREE ?
064007                 MNTMFL BONE 5MNRQ=:MNTMFL                % INDICATE REQUEST OUTSTANDING
064012                 MNCDF.MNLNG-=:COUNT; X."MNNAP"=:D; L:=0
064021                 T:=10DFOPP.MNWBNK; X:=MNWAD+MNNAS        % X POINTS TO NAME STRING
064025                 FOR COUNT DO                             % COPY NAME STRING
064025                    T:=:D; X:=:L; *LBYT                   % GET BYTE
064030                    T:=:D; X:=:L; *STATX                  % STORE BYTE
064033                    X+1;L+1
064035                 OD
064037                 X:=MNWAD+MNNAL; A:=L; *STATX             % NAME LENGTH
064043                 X:=MNWAD+MNREQ; MNLIS; *STATX            % SET REQUEST TO 'LISTEN'
064047              ELSE
064050                 MNTMFL BONE 5MNLR=:MNTMFL; -2=:TMR       % TIMER SHOULD REQUEST 'LISTEN' WHEN DF IS FREE
064055                 -1=:10DFOPP.TMR                          % IN CASE BG-PROG IS WAITING FOR OUTPUT
064060              FI
064060           FI
064060   NEXT:   10SVB=:B; GO MNNXT
064063   RBUS
064071
064071   %=============================================================================
064071   %       M T A D
064071   %=============================================================================
064071   %       (M)      M T R S D F
064071   % ROUTINE TO RELEASE MTAD DATAFIELD
064071   % ENTRY: X=INPUD DF
064071   % EXIT:  T,A,D DESTROYED
064071   %
064071   SUBR MTRSDF
064071   MTRSDF: X.MTFLAG BONE 5MTSF BONE 5MTLG BZERO 5MTRC=:X.MTFLAG
064076           -2=:X.TMR; 0=:X.MTRTP; X.FLAGB BONE 5LSTA=:X.FLAGB
064104           X=:D; A:=X+X.XOPPDF=:X; 0=:X.MTMBPH=:X.MTMBLG
064112           X.BITFLAG BONE 5EMPT=:X.BITFLAG; -1=:X.TMR; X:=D; EXIT
064121   RBUS
064121
064121   %=============================================================================
064121   %       (M)      M T D F I N I
064121   % ROUTINE TO INITIALIZE MTAD DF
064121   % ENTRY: X=POINTER TO DF
064121   %        A=MAILBOX PHYSICAL PAGE NO
064121   %        D=MAILBOX ADDRESS WITHIN BANK
064121   %        T=DF TYPE
064121   %        SHOULD BE CALLED WITH IOF !!
064121   %
064121   % EXIT:  T,A,D DESTROYED
064121   %
064121   SUBR MTDFINI
064121   MTDFINI:T=:X.MTDFTYP; A=:T:=X+X.XOPPDF:=:X:=:D
064127           T=:X.MTMBPH; A=:X.MTMBLG; *AAA MBFLG
064132           X:=A; T SH -6; *LDATX
064135           T:=D.MTFLAG BZERO 5MTFR
064140           IF A BIT 5REMC THEN T BONE 5MTRC FI; T=:X.MTFLAG
064144           IF A BIT 58BIO THEN "0" BONE 58BIT ELSE "0" FI
064152           A=:X.TINFO; 0=:X.CTTYP; X.FLAGB BZERO 5LSTA=:X.FLAGB
064157           0=:X.BHOLD=:X.HENTE=:X.FYLLE; X.MAX=:X.CFREE
064164           A:=X+X.XOPPDF; T:=X.MTDFTYP=:A.MTDFTYP
064171           0=:X.BHOLD=:X.HENTE=:X.FYLLE; X.MAX=:X.CFREE
064176           X:=D; EXIT
064200   RBUS
064200
064200   %=============================================================================
064200   %       (M)      M T M B I N I
064200   % ROUTINE TO INITIALIZE MTAD MAILBOX
064200   % ENTRY: X=INPUT DF
064200   % EXIT:  T,A,D DESTROYED
064200   %
064200   SUBR MTMBINI
064200   INTEGER SVT,SVX,SVB,SVL
064204   MTMBINI:A:=X=:D+X.XOPPDF=:X; A:=X.TDRADDR
064211           T:=X.MTMBPH SH -6; X:=X.MTMBLG
064214                       *AAX MBODF;       STATX
064216           A-"9CXTI";  *AAX MBIDF-MBODF; STATX
064221           A:=MTIBSTA; *AAX MBIBU-MBIDF; STATX
064224                       *AAX MBINR-MBIBU; STZTX
064226                       *AAX MBINW-MBINR; STZTX
064230           A:=MTIMAX;  *AAX MBINM-MBINW; STATX
064233           A:=MTOBSTA; *AAX MBOBU-MBINM; STATX
064236                       *AAX MBOUR-MBOBU; STZTX
064240                       *AAX MBOUW-MBOUR; STZTX
064242           A:=MTOMAX;  *AAX MBOUM-MBOUW; STATX
064245           *AAX MBSID-MBOUM; STZTX; STZTX 10; STZTX 20; STZTX 30; STZTX 40
064253           *IOF
064254           T=:SVT; X=:SVX; A:=L=:SVL:=B=:SVB
064262           D.TDRADDR=:B; CALL 9GTLOGDV; D:=0                  % GET LOG. DEV. NO.
064267           A:=SVL=:L:=SVB:=:B:=:D; T:=SVT; X:=SVX; *ION
064277           *AAX MBTNO-MBSID; STATX
064301           X:=D; EXIT
064303   RBUS
064310
064310   %=============================================================================
064310   %       (M)      M T R S M B
064310   % ROUTINE TO RESET MTAD MAILBOX
064310   % ENTRY: INPUT DF
064310   % EXIT:  T,A,D DESTROYED
064310   %
064310   SUBR MTRSMB
064310   MTRSMB: A:=X=:D+X.XOPPDF=:X; T:=X.MTMBPH SH -6; X:=X.MTMBLG
064317           *AAX MBIDF; STZTX; STZTX 10
064322           *AAX MBSID-MBIDF; STZTX; STZTX 10; STZTX 20; STZTX 30; STZTX 40
064330           X:=D; EXIT
064332   RBUS
064332
064332   %==============================================================================
064332   %       (M)      M T S T A R T
064332   %
064332   % MONITOR CALL TO ACTIVATE MTAD DRIVER/ALLOCATE DATAFIELD.
064332   %
064332   % ENTRY: A = LOGICAL ADDRESS MAILBOX
064332
064332   SUBR MTSTART
064332
064332   %-----------------------------------------------------------------------------
064332   % MTGIDF,MTGODF
064332   % LOCAL SUBROUTINES TO GET DF ADDRESSES FROM MAILBOX
064332   % EXIT:  NO LEGAL DF ADDRESS
064332   % EXITA: X = DF ADDRESS
064332   %        ALL REGISTERS DESTROYED
064332   %
064332   INTEGER POINTER LREG0
064333   INTEGER CCDFAD
064334   MTGIDF: A:=L=:"LREG0"; T:=MBBNK; X:=MBADR; *AAX MBIDF;LDATX% GET ADDRESS
064342           X:=BMTDFLI; A=:CCDFAD
064344           DO WHILE X><-1
064347              IF X=CCDFAD THEN X+9CXTI; GO TMB FI
064354              T:="MTDFLI"; CALL XGTDFADDR; X:=A               % NEXT DF IN LINK
064357           OD
064360           GO LREG0
064361   MTGODF: A:=L=:"LREG0"; T:=MBBNK; X:=MBADR; *AAX MBODF;LDATX% GET ADDRESS
064367           X:=BMTDFLI; A=:CCDFAD
064371           DO WHILE X><-1
064374              IF X+9CXTI=CCDFAD GO TMB
064400              T:="MTDFLI"; X-9CXTI; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
064404           OD
064405           GO LREG0
064406   TMB:    T:="MTMBPH"; CALL XGTDFADDR                        % GET MB ADDRESS FROM DF
064410           IF A=MBPNO THEN X:=CCDFAD; MIN "LREG0" FI
064415           GO LREG0
064416   *)FILL
064425
064425   %-----------------------------------------------------------------------------
064425   % MTGPHAD
064425   % LOCAL SUBROUTINE TO GET PHYSICAL PAGE NO FROM LOG. ADDRESS
064425   % A = LOGICAL ADDRESS OF MAILBOX
064425   %
064425   MTGPHAD:*IRR ALEVB 0; AND (1; COPY SA DD; IRR ALEVB DA     % GET 1/2 BANK MODUS AND LOG. ADDR
064431           D SHZ 6; A SHZ -12+D SHZ 1+174201=:X; T:=0; *LDATX % GET PH. PAGE NO FROM PIT
064441           A=:MBPNO; T:=A SHZ -6; A /\ 77 SHZ 12=:X           % BANK AND ADDR. WITIN BANK IN T,X
064447           *IRR ALEVB DA; AND (1400; RADD SA DX               % DISPLACEMENT WITHIN PAGE
064452           EXIT
064453   *)FILL
064460   MTSTART:*IRR ALEVB DA                                      % GET MAILBOX ADDRESS
064461           A SHZ -12 BONE 6=:T; *IRR ALEVB                    % T=LAMU PAGE (100-177)
064465           IF A BIT 0 THEN T+100 FI                           % 2-BANK MODUS ?
064470           T=:D=:MBLAD; A:=CURPROG; CALL CHLAM; GO FAR ERRLAM % ADDRESS IN LAMU AREA ?
064475           CALL FAR MTGPHAD; T=:MBBNK; X=:MBADR               % GET PHYSICAL ADDRESS
064500           *AAX MBREQ; LDATX                                  % GET REQUEST
064502           IF A><0 THEN                                       % REQUEST ?
064503              IF A=5MTCN THEN                                 % CONNECT REQUEST
064506                 CALL FAR MTGIDF; *SKP; JMP OKREQ             % REQUEST IS OK IF ALREADY CONNECTED
064511                 X:=BMTDFLI
064512                 DO WHILE X><-1                               % SEARCH FOR FREE DATAFIELD
064515                    *IOF
064516                    T:="MTFLAG"; CALL XGTDFADDR
064520                    IF A BIT 5MTFR THEN                       % DF FREE ?
064522                       CALL MTSW0; CURPROG=:X.MTRTP           % SET DF WINDOW
064525                       MBLAD=:X.MTMID; A:=MBADR=:D:=MBPNO; T:=0
064533                       CALL FAR MTDFINI; *ION
064535                       CALL FAR MTMBINI
064536                       CALL MTRW0                             % RESET WINDOW
064537                       GO OKREQ
064540                    ELSE
064541                       *ION
064542                       T:="MTDFLI"; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
064545                    FI
064545                 OD
064546                 9MTNF; GO EREQ                               % NO FREE DATAFIELD
064550              FI
064550              IF A=5MTDC THEN                                 % DISCONNECT REQUEST
064553                 CALL FAR MTGIDF; GO OKREQ                    % REQUEST IS OK IF NO DF CONNECTED
064555                 CALL MTSW0                                   % SET DF WINDOW
064556                 CALL MTRSDF; CALL MTRSMB
064560                 CALL MTRW0                                   % RESET WINDOW
064561                 GO OKREQ
064562              FI
064562   OKREQ:     "0"
064563   EREQ:      T:=MBBNK; A=:D:=0; X:=MBADR; *AAX MBREQ; STDTX  % UPDATE REQUEST,RESPONSE
064571              *IRR ALEVB DP; RINC DA; IRW ALEVB DP            % SKIP RETURN
064574              GO MONEN
064575           FI
064575           T:=MBBNK; X:=MBADR; *AAX MBINP; LDDTX              % INPUT POINTERS
064601           IF A><D THEN
064603              CALL FAR MTGIDF; GO ERRDF
064605              X=:B; CALL MTIND
064607           FI
064607           CALL FAR MTGODF; GO ERRDF
064611           *IRR ALEVB DP; RINC DA; IRW ALEVB DP               % SKIP RETURN
064614           X=:B; CALL MTOUD                                   % ALWAYS START OUTPUT DRIVER
064616           GO MONEN
064617   ERRLAM: "276"; *IRW ALEVB DA                               % LAMU NOT CONNECTED
064621           GO MONEN
064622   ERRDF:  "316"; *IRW ALEVB DA                               % TERMINAL LINE IS NOT CONNECTED
064624           GO MONEN
064625   RBUS
064656
064656   %==============================================================================
064656   %       (M)      M T I N D   M T I N S
064656   %
064656   % MTAD INPUT DRIVER, LEVEL 2
064656   %
064656   % MTIND: CALLED WHEN INTERRUPT
064656   % MTINS: CALLED FROM STDEV (BY TIMER WHEN EVENT WAS NOT FINISHED)
064656
064656   SUBR MTIND,MTINS
064656
064656   INTEGER POINTER RETAD
064657
064657   RETURN: GO RETAD
064660   MTIND:  A:=L=:"RETAD"; ISTATE=:2ISTATE; CALL MTSDFWI       % INTERRUPT ENTRY
064665           CALL MTSMBWI; GO FELLS
064667   MTINS:  X=:B; "MONEN"=:"RETAD"                             % ENTRY FROM STDEV
064672           ISTATE=:2ISTATE; CALL MTSDFWI; CALL MTSMBWI
064676   FELLS:  IF FLAGB BIT 5LSTA THEN GO FAR RETU FI
064702           2DFOPP.BITFLAG BZERO 5CLOU=:X.BITFLAG              % RESET CLEAR OUTPUT FLAG
064706   NXTCH:  IF CFREE=0 THEN
064710              MTFLAG BONE 5MTRS=:MTFLAG                       % IF BUFFER FULL THE DRIVER SHOULD
064713              -1=:TMR; GO FAR RETU                            % BE RESTARTED BY TIMER.
064716           FI
064716           *TYPSW A,B,JPL I (MTG,JMP I (RSTTE,JMP MTBYP
064722
064725
064730
064733
064736
064737           A=:LAST; BRECHOFL/\177770=:BRECHOFL                % CLEAR BREAK/ECHO FLAG
064743           IF DFLAG BIT 5CAPITAL THEN                         % CONVERT LOWER CASE TO UPPER CASE
064746              LAST/\177=:T
064751              IF 140<T AND 176>T AND CESCP SHZ -10/\177><T AND CESCP/\177><T THEN
064770                 LAST BZERO 5=:LAST                           % CONVERT ALL EXEPT
064773              FI                                              % RUBOUT  AND DISCONNECT
064773           FI
064773           IF 2DFOPP.SCREEN><0 THEN                           % TWO WAY DEVICE WITH CR-DELAY
064776              IF <0 THEN -1=:X.TMR FI
065001              1=:X.SCREEN
065003              IF LAST=0 THEN                                  % IGNORE TAPE-FEED?
065005                 IF FLAGB NBIT 5LCHAR GO NXTCH
065010                 IF CESCP SHZ-10><0 GO NXTCH
065013              FI
065013           FI
065013           IF T:=DFLAG NBIT 5SPEC AND T NBIT 5CTRLO THEN
065020              CALL ESCAPE; GO NXTCH; X:=2DFOPP
065023           FI
065023           IF DFLAG NBIT 5CTRLO THEN
065026              IF LAST/\177=17 THEN
065033                 DFLAG BONE 5CTRLO=:DFLAG
065036              FI
065036           ELSE
065037              DFLAG BZERO 5CTRLO=:DFLAG
065042           FI
065042           GO BYP1
065043   *)FILL
065062   BYP1:   IF DFLAG BIT 5ECHO THEN
065065              LAST/\377; *IOF
065070              CALL TECHO; CALL TBREAK; *ION                   % TEST FOR ECHO/BREAK
065073           ELSE
065074              IF 2ISTATE=-1 THEN                              % NOWAIT MODE
065100                 LAST/\377; CALL CXRBPUT; GO BFULL
065104              FI
065104           FI
065104           IF BRECHOFL<0 THEN 7=:LAST; GO IGNCH FI            % IGNORE CHAR?
065111
065111   ADDCH:  LAST/\377; CALL CXRBPUT                            % PUT CHARACTER IN BUFFER
065114   IGNCH:
065114           IF BHOLD>=MAX-10 AND BRECHOFL NBIT 5BREAK GO BFULL % FULL BUFFER
065124           IF BRECHOFL BIT 5BREAK THEN                        % BREAK ACCORDING TO STRATEGY
065127              DFLAG BZERO 5ECHO                               % ECHO OFF IN DRIVER
065131              IF X:=FYLLE=HENTE THEN
065135                 A BONE 5ALEC                                 % WHOLE BUFFER IS ECHOED BY DRIVER
065136              ELSE
065137                 A BZERO 5ALEC                                % PART OF BUFFER MUST BE ECHOED BY IOTRANS
065140              FI; A=:DFLAG; X=:RSISTE                         % RSISTE IS FIRST CHARACTER NOT ECHOED
065142           ELSE
065143              GO ECHTST; *)FILL
065151           FI
065151
065151   BFULL:  IF MTIRFL=0 THEN                                   % NOT ALREADY RESTARTED
065153              CALL TSTBACK; 1=:MTIRFL                         % RESTART PROGRAM
065156           FI
065156
065156   ECHTST: IF BRECHOFL<0 OR A BIT 5ECHO THEN                  % SOMETHING TO ECHO
065162              IF 2DFOPP.MINBHOLD BIT 5BLOC THEN               % OUTP. BUFFER LOCKED
065166                 DFLAG BZERO 5ECHO=:DFLAG
065171                 BRECHOFL BZERO 5BREAK=:BRECHOFL
065174                 -1=:RSISTE; GO FAR NXTCH
065177              FI
065177              X:=:B=:2DFOPP
065201              IF BHOLD=0 THEN
065203                 X.LAST
065204                 *TYPSW T,B,JPL I (MTP,JMP MTFUL,JMP MTBYP
065210
065213
065216
065221
065224
065225                 X:=2DFOPP
065226                 *TYPSW T,B,JPL I (MTA,JMP MTBYP,JMP MTBYP
065232
065235
065240
065243
065246
065247              ELSE
065250   MTFULL:       IF CFREE >< 0 THEN
065252                    2DFOPP.LAST; CALL CXRBPUT                 % INSERT IN RING BUFFER
065255                 FI
065255              FI
065255              X:=2DFOPP:=:B=:2DFOPP
065260           FI
065260           GO FAR NXTCH
065261   *)FILL
065300   RETU:   IF MTIRFL=0 GO CLWI                                % NO RESTART
065302           0=:MTIRFL
065303   *"8N500
"065303           IF X:=IN5MSG >< 0 THEN
065305              T:=5MBBANK; *AAX MLFLA; LDATX
065310              IF A=0 THEN
065311                 A:=1; *STATX
065313                 "IBMOVE"; CALL CXRTACT
065315              FI
065315           ELSE
065316              IF 2ISTATE=-1 OR A=-2 THEN
065325                 *IOF
065326                 CALL PNW5ST; GO CLWI; *ION
065331              FI
065331              "IORESTART"; CALL CXRTACT
065333           FI
065333   *"
"065333   *"-8N500
"065333   CLWI:   *ION
065334           CALL MTCLWI; GO FAR RETURN
065336   *)FILL
065347   INTEGER SVB
065350   RSTTEST:IF MTMBWI.MBFLG BIT 5CLRS THEN                     % CLIENT WANTS KICK ?
065354              X:=2DFOPP:=:B=:SVB
065357              *TYPSW A,B,JPL I (MTA,JMP MTBYP,JMP MTBYP
065363
065366
065371
065374
065377
065400              SVB=:B
065402           FI; GO RETU
065403   RBUS
065412

065412   %==============================================================================
065412   %       (M)      M T O U S   M T O U D
065412   %
065412   % OUTPUT-DRIVER ROUTINE FOR MTAD ON LEVEL 2!
065412   %
065412   % MTOUS: CALLED BY STDEV
065412   % MTOUD: CALLED WHEN INTERRUPT
065412   %
065412   SUBR MTOUS,MTOUD
065412
065412   SYMBOL  SUFFS=5               % SUFFICIENT SPACE FOR ECHO
065412
065412   %------------------------------------------------------------------------------
065412   % MTCHF
065412   % LOCAL SUBROUTINE TO FIND AVAILABLE SPACE IN MTAD OUTPUT BUFFER
065412   %
065412   MTCHF:  IF 2DFOPP.FLAGB BIT 5LSTA THEN MAX; EXIT FI        % LINE DEAD ?
065420           AD:=MTMBWI.MBOUP; IF A-D-1 < 0 THEN A+X.MBOUM FI   % A=READ,D=WRITE
065426           A=:MTFREE; EXIT
065430
065430   %------------------------------------------------------------------------------
065430   % COLCH
065430   % LOCAL SUBROUTINE TO GET CHARACTER FROM OWN BUFFER
065430   %
065430   COLCH:  TAD:=FFMAX; IF A=0 THEN EXIT FI                    % BUFFER EMPTY
065433           A-1;D=:X+1; IF D=T THEN D:="0" FI;AD=:DBHOLD       % UPDATE BUFFER POINTERS
065442           MIN CFREE; T:=2BUFST; *LBYT; EXIT AD1              % GET CHARACTER FROM BUFFER
065446   *)FILL
065452
065452   %-----------------------------------------------------------------------------
065452   % MSLOW
065452   % LOCAL SUBROUTINE TO COPY FROM OWN BUFFER TO MTAD BUFFER WHEN TERMOD IS SET.
065452   %
065452   INTEGER POINTER LREG
065453   INTEGER SVXX
065454   MSLOW:  A:=L=:"LREG"
065456           DO
065456              IF 2TRMOD BIT 1 THEN 6 ELSE 1 FI                % CR DELAY 6 CHAR ELSE 1 FREE
065464              IF A > MTFREE GO LREG                           % ENOUGH SPACE IN MBNIU ?
065467              IF 2TRMOD BIT "0" THEN                          % STOP ON FULL PAGE USED
065472                 IF SCREEN<0 GO LREG                          % NOT RESTARTED FROM FULL PAGE
065475                 IF SCREEN>24 THEN
065501                    -1=:SCREEN; 7                             % FULL PAGE, PRINT BELL
065504                    *TYPSW T,B,JPL I (MTP,JMP MTBYP,JMP MTBYP
065510
065513
065516
065521
065524
065525                    GO LREG
065526                 FI
065526              FI
065526              CALL FAR COLCH; GO LREG                         % GET CHARACTER FROM BUFFER
065530              IF T:=2TRMOD BIT "0" THEN
065533                 IF =12 THEN MIN SCREEN FI                    % COUNT LINES
065537                 IF =14 THEN T+24=:SCREEN FI                  % NEW PAGE
065544              FI
065544              *TYPSW T,B,JPL I (MTP,JMP MTBYP,JMP MTBYP
065550
065553
065556
065561
065564
065565              X:=MTFREE-1=:MTFREE                             % WRITE CHARACTER
065570              IF T:=2TRMOD BIT 1 THEN                         % CR DELAY USED
065573                 IF A BZERO 7=15 THEN                         % CR CAUSES DELAY
065577                    -5=:SVXX; A:=0
065602                    FOR SVXX DO
065602                       *TYPSW T,B,JPL I (MTP,JMP MTBYP,JMP MTBYP
065606
065611
065614
065617
065622
065623                    OD
065625                 FI
065625              FI
065625           OD
065626   *)FILL
065636   %----------------------------------------------------------------------
065636   % MEWRIT
065636   % LOCAL SUBROUTINE TO WRITE ERROR MESSAGE TO MAILBOX
065636   %
065636   DISP 0; DOUBLE EBUHF=EBUHENTE; PSID               % HENTE AND FYLLE IN ERROR BUFFER
065636   INTEGER POINTER  LRE3
065637
065637   MEWRIT: A:=L=:"LRE3"
065641           IF 2DFOPP.FLAGB BIT 5LSTA AND X:=EBUWRITE><0 GO FRLI
065650           DO WHILE X:=EBUWRITE><0
065652              DO WHILE X.EBUHENTE><X.EBUFYLLE
065656                 X=:T:=A; *LBYT                      % COLLECT BYTE
065661                 X:=T; MIN X.EBUHENTE                % UPDATE HENTE
065663                 *TYPSW T,B,JPL I (MTP,JMP EOUT,JMP MTBYP
065667
065672
065675
065700
065703
065704                 MTFREE-1=:MTFREE
065707                 IF A=0 GO EOUT                      % MAILBOX FULL
065710                 X:=EBUWRITE
065711              OD
065712   FRLI:      X.EBULINK=:EBUWRITE                    % WHOLE BUFFER PRINTED
065714              T:=EBUFREE=:X.EBULINK; X=:EBUFREE      % PUT IN FREE LIST
065717           OD
065720           10DFOPP.TINFO BZERO 5ERRMSG=:X.TINFO
065724   EOUT:   GO LRE3
065725   *)FILL
065737
065737   %-----------------------------------------------------------------------------
065737   % MFAST
065737   % LOCAL SUBROUTINE TO COPY FROM OWN BUFFER TO MTAD BUFFER WHEN TERMOD IS 0.
065737   %
065737   INTEGER COUNT,CC1,CC2,CC3
065743   INTEGER POINTER LRE2
065744   MFAST:  A:=L=:"LRE2"
065746           TAD:=FFMAX; T=:CC2                        % MAX=:CC2
065750           IF A>X:=MTFREE THEN A:=X FI               % NO. OF BYTES TO MOVE IN THIS SESSION
065754           A=:CC3-=:COUNT:=2BUFST=:L                 % L=BUFFER START, D=HENTE
065761           MTMBWI.MBOUM=:CC1; T:=X.MBOBU+X; X:=X.MBOUW
065767           DO
065767              T:=:L; X:=:D; *LBYT                    % GET CHARACTER
065772              T:=:L; X:=:D; A/\MTMASK; *SBYT         % WRITE CHARACTER
065776              *RINC DX; RINC DD
066000              IF CC2=D THEN D:=0 FI                  % END OF RING BUFFER ?
066004              IF CC1=X THEN X:=0 FI                  % END OF MAILBOX BUFFER
066010              MIN COUNT                              % SKIP OD WHEN ZERO
066011           OD
066012           BHOLD-CC3; AD=:DBHOLD; T:=CC2-A=:CFREE    % UPDATE RING BUFFER POINTERS
066020           MTMBWI.MBOUW+CC3; IF A>=X.MBOUM THEN A-T FI
066027           A=:X.MBOUW                                % UPDATE MAILBOX POINTER
066030           GO LRE2
066031   *)FILL
066035   %-----------------------------------------------------------------------------
066035   % MIGNO
066035   % LOCAL SUBROUTINE TO EMPTY OWN BUFFER WHEN LINE DEAD
066035   %
066035   MIGNO:  MAX=:CFREE; 0=:BHOLD=:HENTE=:FYLLE                 % EMPTY BUFFER
066042           EXIT
066043   *)FILL
066043   %------------------------------------------------------------------------------
066043   %      M T O U S   M T O U D
066043
066043   INTEGER POINTER RETU,LLRG
066045   INTEGER SVX
066046
066046   RRET:   GO LLRG
066047   MTOUS:  X=:B; "SRETU"=:"RETU"; ISTATE=:2ISTATE; CALL MTSDFWI
066055           X:=B; CALL MTSMBWI; GO FELLS
066060   MTOUD:  A:=L=:"LLRG":="DRETU"=:"RETU"; ISTATE=:2ISTATE; CALL MTSDFWI
066067           X:=B; CALL MTSMBWI
066071   FELLS:  CALL FAR MTCHF; IF A=0 GO RETU
066074           BITFLAG BONE 5EMPT=:BITFLAG; A:=2DFOPP.TINFO; X:=0 % GET TINFO AND ZERO MODE
066102           IF A BIT 58BIT AND A NBIT 5UMOD THEN
066106              T:=177=:MTMASK
066110           ELSE
066111              T:=377=:MTMASK
066113           FI
066113           IF A BIT 5CRDLY THEN X BONE 1 FI                   % CARRIAGE RETURN DELAY (TINFO)
066116           IF T:=SCREEN><0 THEN X BONE "0" FI                 % STOP ON FULL PAGE ENABLED
066122           X=:2TRMOD                                          % SAVE MODE
066123           IF A BIT 5ERRMSG THEN                              % ERROR MESSAGE TO ERROR DEVICE
066125              CALL FAR MEWRIT; GO MTCACT
066127           FI
066127   *"8N500
"066127           IF BHOLD=0 AND ON5MSG=0 GO RETU
066134   *"-8N500
"066134           IF 2DFOPP.FLAGB BIT 5LSTA THEN                     % LINE DEAD ?
066140              CALL MIGNO                                      % CLEAR OUTPUT BUFFER
066141           ELSE
066142              BITFLAG BZERO 5EMPT=:BITFLAG                    % DRIVER WILL BE RESTARTED BY INTERRUPT OR TIMER
066145   *"8N500
"066145              IF X:=ON5MSG><0 AND BHOLD=0 THEN
066151                 IF MTMBWI.MBFLG BIT 5PCHK THEN
066155                    CALL MTMMO; GO RETU; GO MTCACT            % CLIENT IS ABLE TO CHECK PARITY
066160                 ELSE
066161                    CALL MT5MO                                % MOVE TO RING BUFFER
066162                 FI
066162              FI
066162   *"
"066162              IF 2TRMOD=0 THEN                                % NOT CR DELAY OR STOP ON FULL PAGE ?
066164                 CALL FAR MFAST
066165              ELSE
066166                 CALL FAR MSLOW                               % MOVE WITH CHECK FOR CR DELAY OR STOP ON FULL PAGE
066167              FI
066167   MTCACT:    X:=2DFOPP
066170              *TYPSW A,B,JPL I (MTA,JMP MTBYP,JMP MTBYP
066174
066177
066202
066205
066210
066211           FI
066211           GO RETU                                            % SEND LAST BUFFER BEFORE RETURN
066212   *)FILL
066237   %------------------------------------------------------------------------------
066237   % RSINP
066237   % LOCAL SUBROUTINE TO RESTART USER IF INPUT IS WAITING FOR ECHO
066237   %
066237   INTEGER SAVB; INTEGER POINTER LRE1
066241
066241   RSINP:  A:=L=:"LRE1"
066243           IF 2DFOPP.BRECHOFL BIT 5WECH THEN
066247              A BZERO 5WECH=:X.BRECHOFL; X:=:B=:SAVB
066253   *"8N500
"066253              IF X:=IN5MSG><0 THEN
066255                 *IOF
066256                 T:=5MBBANK; *AAX MLFLA; LDATX
066261                 IF A = 0 THEN                                % IBMOVE NOT ALREADY ACTIVE
066262                    A:=1; *STATX                              % MARK IBMOVE ACTIVE
066264                    "IBMOVE"; CALL CXRTACT
066266                 ELSE                                         % IBMOVE ALLREADY ACTIVE
066267                    GO OUT
066270                 FI
066270                 *ION
066271              ELSE
066272                 CALL TSTBACK; "IORESTART"; CALL CXRTACT
066275              FI
066275   *"-8N500
"066275   OUT:       SAVB=:B
066277           FI
066277           GO LRE1
066300   *)FILL
066306
066306   %------------------------------------------------------------------------------
066306   % RSOUT
066306   % LOCAL SUBROUTINE TO RESTART USER IF MINBHOLD IS REACHED IN OUTPUT BUFFER
066306   %
066306   RSOUT:  IF 2ISTAT=0 THEN EXITA FI
066311           X:=BHOLD; T:=MINBHOLD BZERO 5BLOC BZERO 5NOWT
066315           IF X>T THEN EXIT FI
066320           IF A<0 THEN
066321              IF MINBHOLD NBIT 5NOWT THEN EXITA FI
066325              A BZERO 5NOWT=:MINBHOLD
066327           FI
066327           "IORESTART"; GO CXRTACT
066331   *)FILL
066334
066334   %------------------------------------------------------------------------------
066334   %      RETURN
066334
066334   SRETU: CALL RSOUT; 0/\0; CALL MTCLWI; GO MONEN             % CALLED BY STDEV
066340   DRETU: CALL RSOUT; GO BYP1                                 % CALLED BY INTERRUPT
066342          IF CFREE>=SUFFS THEN CALL RSINP FI
066347   BYP1:  CALL MTCLWI; GO FAR RRET
066351   RBUS
066354
066354   %=============================================================================
066354   %       (M)      M T S D F W I
066354   %
066354   % ROUTINE TO SET UP WINDOW FOR DATAFIELD FOR MTAD TERMINALS
066354   % (LEVEL 2)
066354   %
066354   % ENTRY: B=RES. DF
066354   % EXIT:  B=DATAFIELD
066354   %        X=OPPOSITE
066354   %        T,A,D DESTROYED.
066354   %
066354   SUBR MTSDFWI
066354   INTEGER POINTER LREG
066355   MTSDFWI:A:=L=:"LREG"; CALL SETBFWINDOW; DFOPP/\1777=:X     % SET DF WINDOW
066363           A:=B/\176000; X+A=:2DFOPP; A+BUFST=:2BUFST;        % OPPOSITE AND BUFSTART
066371           GO LREG
066372   RBUS
066377
066377   %=============================================================================
066377   %       (M)      M T S M B W I
066377   %
066377   % ROUTINE TO SET UP WINDOW FOR MAILBOX FOR MTAD TERMINALS
066377   % (LEVEL 2)
066377   %
066377   % ENTRY: X=OUTPUT DF
066377   % EXIT:  X=MAILBOX WINDOW
066377   %        ALL REGISTERS DESTROYED.
066377   %
066377   SUBR MTSMBWI
066377   INTEGER SVX
066400   MTSMBWI:X.MTMBPH=:D; T:=0; X=:SVX:="WND41*2+174000"; 142000; *STDTX
066407           SVX.MTMBLG/\1777+"WND41*2000"=:X=:MTMBWI; EXIT
066416   RBUS
066422
066422   %=============================================================================
066422   %       (M)      M T C L W I
066422   %
066422   % ROUTINE TO CLEAR WINDOW FOR DATAFIELD AND MAILBOX FOR MTAD TERMINALS
066422   % (LEVEL 2)
066422   %
066422   % EXIT:  X,A,T DESTROYED
066422   %
066422   SUBR MTCLWI
066422   MTCLWI: T:=0; X:="WNDBF*2+174000"; A:=0; *STATX            % DF WINDOW
066426           X:="WND41*2+174000"; *STATX                        % MAILBOX WINDOW
066430           EXIT
066431   RBUS
066433
066433   %=============================================================================
066433   %       (M)      M T S W X   M T R W X
066433   %
066433   % ROUTINES TO SET UP AND CLEAR SPECIAL DF WINDOW FOR MTAD
066433   %
066433   % MTSW0,MTRW0: LEVEL 2
066433   % MTSW3,MTRW3: LEVEL 12
066433   % MTSW6,MTRW6: LEVEL 2
066433   %
066433   % ENTRY: X=RESIDENT INPUT DF
066433   % EXIT:  X=WINDOW INPUT DF
066433   %        ALL REGISTERS DESTROYED.
066433   %
066433   SUBR MTSW0,MTRW0
066433   INTEGER SVX; DOUBLE PTENTRY
066436   MTSW0:  X=:SVX; T:=0; X:="MTW00*2+174000"; *LDDTX
066442           AD=:PTENTRY; SVX.TDFPHPAGE=:D:=142000
066447           X:="MTW00*2+174000"; *STDTX
066451           SVX.TDFLGADDR/\1777+"MTW00*2000"=:X; EXIT
066457   MTRW0:  X=:SVX; T:=0; X:="MTW00*2+174000"; PTENTRY; *STDTX
066464           X:=SVX; EXIT
066466   RBUS
066472   SUBR MTSW3,MTRW3
066472   INTEGER SVX; DOUBLE PTENTRY
066475   MTSW3:  X=:SVX; T:=0; X:="MTW03*2+174000"; *LDDTX
066501           AD=:PTENTRY; SVX.TDFPHPAGE=:D:=142000
066506           X:="MTW03*2+174000"; *STDTX
066510           SVX.TDFLGADDR/\1777+"MTW03*2000"=:X; EXIT
066516   MTRW3:  X=:SVX; T:=0; X:="MTW03*2+174000"; PTENTRY; *STDTX
066523           X:=SVX; EXIT
066525   RBUS
066531   SUBR MTSW6,MTRW6
066531   INTEGER SVX; DOUBLE PTENTRY
066534   MTSW6:  X=:SVX; T:=0; X:="MTW06*2+174000"; *LDDTX
066540           AD=:PTENTRY; SVX.TDFPHPAGE=:D:=142000
066545           X:="MTW06*2+174000"; *STDTX
066547           SVX.TDFLGADDR/\1777+"MTW06*2000"=:X; EXIT
066555   MTRW6:  X=:SVX; T:=0; X:="MTW06*2+174000"; PTENTRY; *STDTX
066562           X:=SVX; EXIT
066564   RBUS
066570
066570   %==============================================================================
066570   %       (M)      M T P x x
066570   %
066570   % MAILBOX WRITE ROUTINES FOR MTAD TERMINALS LEVEL 2.
066570   % MTP00:
066570   %
066570   % ENTRY: X = MAILBOX WINDOW
066570   %        B = TERMINAL OUTPUT DF
066570   %        A = CHARACTER TO BE WRITTEN
066570   % EXIT:  T,A,D DESTROYED
066570   %
066570   SUBR MTP00,MTP03,MTP06,MTP11,MTP14
066570   MTP00:  X:=MTMBWI; X=:D:=X.MBOUW; IF X>>=MTOMAX THEN X:=0 FI
066577           T:=MTOBSTA+D; A/\MTMASK; *SBYT                        % STORE BYTE
066603           IF D:=:X+1=MTOMAX THEN 0=:X.MBOUW ELSE MIN X.MBOUW FI
066613           EXITA
066614   MTP03:  *JMP I *1; MTP00
066616   MTP06:  *JMP I *1; MTP00
066620   MTP11:  *JMP I *1; MTP00
066622   MTP14:  *JMP I *1; MTP00
066624   RBUS
066630
066630   %==============================================================================
066630   %       (M)      M T G x x
066630   %
066630   % MAILBOX READ ROUTINES FOR MTAD TERMINALS LEVEL 2.
066630   % MTG00:
066630   %
066630   % ENTRY: X = MAILBOX WINDOW
066630   %        B = TERMINAL INPUT DF
066630   % EXIT:  BUFFER EMPTY
066630   %        A,D DESTROYED
066630   % EXITA: A = CHARACTER READ
066630   %        T,D DESTROYED
066630   %
066630   SUBR MTG00,MTG03,MTG06,MTG11,MTG14
066630   MTG00:  X:=MTMBWI; AD:=X.MBINP; IF A=D THEN EXIT FI
066635           IF A>>=MTIMAX THEN A:=0 FI                         % ERROR IN POINTER
066641           T:=MTIBSTA+X; X=:D:=A; *LBYT                       % READ BYTE
066646           IF D:=:X+1=MTIMAX THEN 0=:X.MBINR ELSE MIN X.MBINR FI
066656           EXITA
066657   MTG03:  *JMP I *1; MTG00
066661   MTG06:  *JMP I *1; MTG00
066663   MTG11:  *JMP I *1; MTG00
066665   MTG14:  *JMP I *1; MTG00
066667   RBUS
066672
066672   %==============================================================================
066672   %       (M)      M T 5 M O
066672   %
066672   % ROUTINE TO MOVE FROM 500 MESSAGE TO EMPTY RING BUFFER, LEVEL 2.
066672   % MT5MO:
066672   %
066672   % ENTRY: B = TERMINAL OUTPUT DF
066672   % EXIT:  A,D,X DESTROYED
066672   %
066672   SUBR MT5MO
066672   INTEGER POINTER LREG
066673   MT5MO:  A:=L=:"LREG";
066675           T:=5MBBANK; X:=ON5MSG; *AAX NOBYT; LDATX           % NUMBER OF BYTES IN BUFFER
066701           IF A>=MAX THEN
066704              T=:BHOLD; 0=:CFREE=:HENTE=:FYLLE; A-T
066711              IF A=0 THEN K:=1 ELSE K:="0" FI
066715           ELSE
066716              A=:BHOLD=:FYLLE; T:=MAX-A=:CFREE; 0=:HENTE; A:=0; K:=1
066726           FI;
066726           T:=5MBBANK; *STATX                                 % UPDATE NOBYT
066730           BHOLD+1 SHZ -1=:L; *AAX 5HENT-NOBYT; LDATX         % BANK NO. OF DATA BUFFER
066736           A=:D; *AAX HBUFA-5HENT; LDATX                      % BUFFER POINTER
066741           T:=2BUFST; *MOVPA                                  % MOVE DATA
066743           A:=D; T:=5MBBANK; X:=ON5MSG; *AAX 5HENT; STATX     % UPDATE 5HENT
066750           IF K THEN
066752              X:=ON5MSG; 0=:ON5MSG; *IOF; JPL I (PT5RS; ION   % RESTART 500
066757           FI
066757           GO LREG
066760   RBUS
066763
066763   %==============================================================================
066763   %       (M)      M T M M O
066763   %
066763   % ROUTINE TO MOVE FROM 500 MESSAGE TO MAILBOX WITH NO PARITY CHECK, LEVEL 2.
066763   % MTMMO:
066763   %
066763   % ENTRY: B = TERMINAL OUTPUT DF
066763   % EXIT:  NOTHING MOVED
066763   % EXITA: SOMETHING MOVED
066763   %
066763   SUBR MTMMO
066763   INTEGER POINTER LREG
066764   INTEGER ANT
066765   DOUBLE  SADR
066767   MTMMO:  A:=L=:"LREG"; MTMBWI.MBOUP
066773           IF A><D THEN EXIT FI                               % WAIT FOR CLIENT TO EMPTY MAILBOX
066776           IF MTMASK=177 THEN 1=:X.MBPFL ELSE 0=:X.MBPFL FI   % MARK IF CLIENT SHOULD CLEAR PARITY
067006           A:=0; D:=0; AD=:X.MBOUP                            % RESET POINTERS TO ZERO
067011           T:=5MBBANK; X:=ON5MSG; *AAX 5HENT; LDATX
067015           A=:D; *AAX HBUFA-5HENT; LDATX
067020           AD=:SADR; *AAX NOBYT-HBUFA; LDATX
067023           A=:D; MTMBWI.MBOUM-1; IF A<D THEN D=:A FI          % CAN NOT MOVE MORE THAN MBOUM-1
067032           A=:ANT+1 SHZ -1=:L; T:=X.MBOBU+X; AD:=SADR; *MOVPA % MOVE WORDS
067042           A:=D; T:=5MBBANK; X:=ON5MSG; *AAX 5HENT; STATX     % D CONTAINS NEW 5HENT AFTER MOVE
067047           *AAX NOBYT-5HENT; LDATX
067051           A-ANT; *STATX                                      % UPDATE NOBYT
067053           A=:L; ANT=:MTMBWI.MBOUW
067057           IF L=0 THEN
067061              X:=ON5MSG; 0=:ON5MSG; *IOF
067064              CALL PT5RST; *ION
067066           FI
067066           MIN LREG; GO LREG
067070   RBUS
067074
067074   %==============================================================================
067074   %       (M)      M T A x x
067074   %
067074   % ROUTINES TO ACTIVATE CLIENT FOR MTAD TERMINALS LEVEL 2.
067074   % MTA00:
067074   %
067074   % ENTRY: X = TERMINAL INPUT
067074   % EXIT:  A,D,X DESTROYED
067074   %
067074   SUBR MTA00
067074   MTA00:  X:=X.MTRTP; GO RTENTRY                             % ACTIVATE RT-PROGRAM
067076   RBUS
067077   SUBR MTA03
067077   INTEGER SVB
067100   INTEGER POINTER LREG
067101   MTA03:
067101   *"8N500
"067101           A:=L=:"LREG"; X:=X.MTRTP; *IOF; JPL I (NW5ST+1
067106           0/\0; *ION
067110           GO LREG
067111   *"-8N500
"067111   RBUS
067112   SUBR MTA06
067112   INTEGER SVB,SVX
067114   INTEGER POINTER SVL
067115   MTA06:  A:="MTNKDF":=:B=:SVB:=L=:"SVL"; X=:SVX
067123           *IOF; SOWN
067133           SVX.MTRTP=:D; A:=MTNKPORT; X:=0; CALL NKSEND; *ION % SEND NUCLEUS KICK
067142           SVB=:B; GO SVL
067145   RBUS
067151   SUBR MTA14
067151   MTA14:  *JMP I *1; MTA00
067153   RBUS
067153
067153   %==============================================================================
067153   %       (M)      M T C x x
067153   %
067153   % ROUTINES TO CHECK IF MAILBOX IS OK FOR  MTAD TERMINALS LEVEL 2.
067153   % MTC00:
067153   %
067153   % ENTRY: X = TERMINAL INPUT DF
067153   % EXIT:  A,D,X DESTROYED
067153   %
067153   SUBR MTC00,MTC03,MTC06,MTC11,MTC14
067153   INTEGER SVX
067154   INTEGER POINTER LREG
067155   MTC00:  A:=L=:"LREG":=X.MTRTP; T:=X.MTMID=:D; X=:SVX:=X.TDRADDR
067164           CALL CHLAM; GO ERR00; X:=SVX; MIN "LREG"; GO LREG
067171   ERR00:  X:=SVX; GO LREG
067173   MTC03:  *JMP I *1; MTC00
067175   MTC06:  *JMP I *1; MTC00
067177   MTC11:  EXITA
067200   MTC14:  *JMP I *1; MTC00
067202   RBUS
067203
067203   *"8N500
"067203   %=====================================================================
067203   %       (M)      M T 5 0 0
067203   %
067203   % MTAD MONITOR CALL ENTRY FROM ND 500, CALLED FROM 500 DRIVER, LEV. 12
067203   %
067203   % ENTRY:
067203
067203   INTEGER N500D=?
067203
067203   SUBR MT500,NXTMSG
067203   INTEGER CCBNK=?,CCADR=?
067203   %---------------------------------------------------------------------
067203   % MTG5MB
067203   % LOCAL SUBROUTINE TO GET PHYSICAL ADDRESS OF MAILBOX
067203   % EXITA: T=BANK NO. OF MAILBOX
067203   %        X=DISP. WITHIN BANK
067203   SYMBOL MTPAR=101
067203   MTG5MB: X:=N5MESSAGE; T:=5MBBANK; *AAX MTPAR; LDATX        % PAGE NO IN MULTIPORT
067207           D:=0; A+"N500D".ADRZERO; AD SHZ -6
067213           A=:T; D=:X; EXITA
067216
067216   %-----------------------------------------------------------------------------
067216   % MTGIDF,MTGODF
067216   % LOCAL SUBROUTINES TO GET DF ADDRESSES FROM MAILBOX
067216   % EXIT:  NO LEGAL DF ADDRESS
067216   % EXITA: X = DF ADDRESS
067216   %        ALL REGISTERS DESTROYED
067216   %
067216   INTEGER POINTER LREG0
067217   INTEGER CCDFAD
067220   MTGIDF: A:=L=:"LREG0"; T:=CCBNK; X:=CCADR; *AAX MBIDF;LDATX% GET ADDRESS
067226           X:=BMTDFLI; A=:CCDFAD
067230           DO WHILE X><-1
067233              IF X=CCDFAD THEN X+9CXTI; GO TMT FI
067240              T:="MTDFLI"; CALL XGTDFADDR; X:=A               % NEXT DF IN LINK
067243           OD
067244           GO LREG0
067245   MTGODF: A:=L=:"LREG0"; T:=CCBNK; X:=CCADR; *AAX MBODF;LDATX% GET ADDRESS
067253           X:=BMTDFLI; A=:CCDFAD
067255           DO WHILE X><-1
067260              IF X+9CXTI=CCDFAD GO TMT
067264              T:="MTDFLI"; X-9CXTI; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
067270           OD
067271           GO LREG0
067272   TMT:    T:="MTMBPH"; CALL XGTDFADDR; A=:T                  % GET MB ADDRESS FROM DF
067275           IF CCBNK+CCADR SHR 6=T THEN X:=CCDFAD; MIN "LREG0" FI
067304           GO LREG0
067305   *)FILL
067314
067314   INTEGER CCBNK,CCADR
067316   MT500:  CALL MTG5MB; GO ILLPA                              % GET MAILBOX ADDR
067320           T=:CCBNK; X=:CCADR; *AAX MBREQ; LDATX              % GET REQUEST
067324           IF A><0 THEN
067325              IF A=5MTCN THEN
067330                 CALL MTGIDF; *SKP; JMP OKREQ                 % REQUEST IS OK IF ALREADY CONNECTED
067333                 X:=BMTDFLI
067334                 DO WHILE X><-1                               % SEARCH FOR FREE DATAFIELD
067337                    *IOF
067340                    T:="MTFLAG"; CALL XGTDFADDR
067342                    IF A BIT 5MTFR THEN                       % DF FREE ?
067344                       CALL MTSW3; X=:D                       % SET DF WINDOW
067346                       X:=N5MESSAGE; T:=5MBBANK; *AAX XADPR; LDXTX
067352                       X.RTRES=:D.MTRTP
067355                       A:=CCADR=:D+CCBNK SHR 6; T:=3
067362                       CALL MTDFINI; *ION
067364                       CALL MTMBINI
067365                       CALL MTRW3                             % RESET WINDOW
067366                       GO OKREQ
067367                    ELSE
067370                       *ION
067371                       T:="MTDFLI"; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
067374                    FI
067374                 OD
067375                 9MTNF; GO EREQ                               % NO FREE DATAFIELD
067377              FI
067377              IF A=5MTDC THEN                                 % DISCONNECT REQUEST
067402                 CALL FAR MTGIDF; GO OKREQ                    % REQUEST IS OK IF NO DF CONNECTED
067404                 CALL MTSW3; *IOF                             % SET DF WINDOW
067406                 CALL MTRSDF; *ION
067410                 CALL MTRSMB
067411                 CALL MTRW3                                   % RESET WINDOW
067412                 GO OKREQ
067413              FI
067413   OKREQ:     "0"
067414   EREQ:      T:=CCBNK; A=:D:=0; X:=CCADR; *AAX MBREQ; STDTX  % UPDATE REQUEST,RESPONSE
067422              GO OKRET
067423           FI
067423           CALL FAR MTGODF; GO ERRDF
067425           IF X.MLINK=0 THEN
067427              "MT5START"=:X.MFUNC; X:=:B; CALL RTACT; X:=:B   % START DRIVERS
067434           FI
067434   OKRET:  X:=N5MESSAGE; CALL OKMONICO; CALL ACTRDY; GO NXTMSG
067440   ILLPA:  "174"; GO ERET
067442   ERRDF:  "316"
067443   ERET:   AD SH -20; X:=N5MESSAGE; CALL EMONICO; CALL ACTRDY
067447           GO NXTMSG
067450   RBUS
067475
067475   %=============================================================================
067475   %       (M)      M T 5 S T A R T
067475   %
067475   % MONITOR ROUTINE TO START MTAD DRIVERS, LEV. 2.
067475   %
067475   % ENTRY: X=RESIDENT OUTPUT DF
067475   SUBR MT5START
067475   INTEGER SVDF
067476   MT5START:T:=X.TDFPHPAGE SHZ -6; X=:SVDF:=X.TDFLGADDR
067502           *AAX MTMBP; LDATX; AAX MTMBL-MTMBP; LDXTX
067506           T:=A SHZ -6; *AAX MBINP; LDDTX                     % INPUT POINTERS
067512           IF A>< D THEN
067514              SVDF-"9CXTI"=:B; CALL MTIND
067520           FI
067520           SVDF=:B; CALL MTOUD
067523           GO MONEN
067524   RBUS
067527   *"
"067527   %=====================================================================
067527   %       (M)      M T N U C L
067527   %
067527   % MTAD MONITOR ROUTINE, ACTIVATED BY NUCLEUS, LEV. 2
067527   %
067527   % ENTRY:
067527
067527   SUBR MTNUCL
067527   INTEGER CCBNK=?,CCADR=?
067527   %---------------------------------------------------------------------
067527   % MTGNMB
067527   % LOCAL SUBROUTINE TO GET PHYSICAL ADDRESS OF MAILBOX
067527   % EXIT:  NO MESSAGE OR NUCLEUS ERROR
067527   % EXITA: T=BANK NO. OF MAILBOX
067527   %        X=DISP. WITHIN BANK
067527   %        A=SERVER NR.
067527   INTEGER CSNR
067530   MTGNMB: 0=:CSNR
067531           FOR CSNR TO 3 DO
067535              A SH 1+"MTSRE"=:X; X.S1                   % GET PHYS. PAGE FOR LAMU
067541              IF A=0 THEN EXIT FI                       % NO MORE SERVERS
067543              D:=0; AD SH -6; A=:T:=D+"MTEQR"=:X; *LDDTX% GET EVENT QUEUE POINTERS FOR THIS SERVER
067552              IF A><D THEN
067554                 A=:D+1/\777; *STATX                    % UPDATE READ POINTER
067560                 X+D; A:="MTEQR"; X-A; *LDATX           % GET "EVENT"
067564                 A:=:X/\176000; X+A; T:=T+C; A:=CSNR    % ADDRESS OF MAILBOX IN T,X
067571                 EXITA
067572              FI
067572           OD; EXIT
067577   *)FILL
067603   %-----------------------------------------------------------------------------
067603   % MTGIDF,MTGODF
067603   % LOCAL SUBROUTINES TO GET DF ADDRESSES FROM MAILBOX
067603   % EXIT:  NO LEGAL DF ADDRESS
067603   % EXITA: X = DF ADDRESS
067603   %        ALL REGISTERS DESTROYED
067603   %
067603   MTGIDF: T:=CCBNK; X:=CCADR; *AAX MBIDF;LDATX               % GET ADDRESS
067607           IF A><0 THEN X:=A; EXITA ELSE EXIT FI
067614   MTGODF: T:=CCBNK; X:=CCADR; *AAX MBODF;LDATX               % GET ADDRESS
067620           IF A><0 THEN X:=A; EXITA ELSE EXIT FI
067625   *)FILL
067625
067625   INTEGER CCBNK,CCADR,CCSNR
067630   MTNUCL: "MTNKDF"=:B; CALL FAR MTGNMB; GO MONEN             % GET MAILBOX ADDR
067634           A=:CCSNR; T=:CCBNK; X=:CCADR; *AAX MBREQ; LDATX    % GET REQUEST
067641           IF A><0 THEN
067642              IF A=5MTCN THEN
067645                 CALL MTGIDF; *SKP; JMP OKREQ                 % REQUEST IS OK IF ALREADY CONNECTED
067650                 X:=BMTDFLI
067651                 DO WHILE X><-1                               % SEARCH FOR FREE DATAFIELD
067654                    *IOF
067655                    T:="MTFLAG"; CALL XGTDFADDR
067657                    IF A BIT 5MTFR THEN                       % DF FREE ?
067661                       CALL MTSW6                             % SET DF WINDOW
067662                       X=:D; CCSNR SH 1+"MTSRE"=:X; X.S0=:D.MTRTP % SAVE SEND REF. FOR "KICK"
067672                       A:=CCADR=:D+CCBNK SHR 6; T:=6
067677                       CALL MTDFINI; *ION
067701                       CALL MTMBINI
067702                       CALL MTRW6                             % RESET WINDOW
067703                       GO OKREQ
067704                    ELSE
067705                       *ION
067706                       T:="MTDFLI"; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
067711                    FI
067711                 OD
067712                 9MTNF; GO EREQ                               % NO FREE DATAFIELD
067714              FI
067714              IF A=5MTDC THEN                                 % DISCONNECT REQUEST
067717                 CALL FAR MTGIDF; GO OKREQ                    % REQUEST IS OK IF NO DF CONNECTED
067721                 CALL MTSW6; *IOF                             % SET DF WINDOW
067723                 CALL MTRSMB; CALL MTRSDF; *ION
067726                 CALL MTRW6                                   % RESET WINDOW
067727                 GO OKREQ
067730              FI
067730   OKREQ:     "0"
067731   EREQ:      T:=CCBNK; A=:D:=0; X:=CCADR; *AAX MBREQ; STDTX  % UPDATE REQUEST,RESPONSE
067737              GO MTNUCL
067740           FI
067740           *AAX MBINP-MBREQ; LDDTX                            % INPUT POINTERS
067742           IF A><D THEN
067744              CALL FAR MTGIDF; GO MTNUCL
067746              X=:B; CALL MTIND
067750           FI
067750           CALL FAR MTGODF; GO MTNUCL
067752           X=:B; CALL MTOUD                                   % ALWAYS START OUTPUT DRIVER
067754           GO MTNUCL
067755   RBUS
070000
070000   %=============================================================================
070000   %       (M)      B F I C O M D R I V E R
070000   %
070000   % FAST INPUT DRIVER USED IN KOMBINATION WITH MON 373
070000   % (LEVEL 12)
070000   %
070000   % ENTRY: B=RESIDENT INPUT DF
070000   %
070000   SUBR BFYICOMDRIVER
070000
070000   RETU:   *JMP I (TYENT-1
070001   BFYICOMDRIVER:
070001           ISTATE=:IISTATE; CALL SET12WINDOW
070004   LOOP:   CALL TIAPD; GO RETU
070006           A=:LAST
070007           IF CFREE=0 GO LOOP
070011           IF TDRADDR.RTRES=0 GO LOOP
070014           LAST; CALL CXRBPUT
070016           IF LAST=BRKCHAR THEN
070022              MIN NBREAKS; GO BFULL
070024           ELSE
070025              IF BHOLD>>MAX-36 GO BFULL
070032           FI; GO LOOP
070033
070033   BFULL:  CALL TSTBACK
070034           "IORESTART"; CALL CXRTACT
070036           GO LOOP
070037   RBUS
070047
070047   %===========================================================================
070047   %       P I O M M T A D
070047   %
070047   % Routine to simulate Mon Mtad for Pioc-Mtad
070047   % (Monitor level)
070047   %
070047   % Entry:         AD=Phys.addr of Mtad mailbox
070047   %                B= Pioc Mtad queue.
070047   %
070047   SUBR PIOMMTAD
070047
070047   %--------------------------------------------------------------------
070047   % Local subroutine to get Datafield addr from mailbox.
070047   % Entry:         None
070047   % Exit:          No Df found.
070047   % Exit+1:        X=Df addr (resident part)
070047   %
070047   INTEGER CCDFAD=?
070047
070047   MTGIDF: T:=MBBNK; X:=MBADR; *AAX MBIDF; LDXTX        % Get DF addr from mailbox
070053           X=:CCDFAD
070054           IF X=0 THEN EXIT FI
070057           EXITA
070060
070060   MTGODF: T:=MBBNK; X:=MBADR; *AAX MBODF; LDXTX        % Get DF addr from mailbox
070064           X=:CCDFAD
070065           IF X=0 THEN EXIT FI                          % Input
070070           EXITA
070071   *)FILL
070073
070073   INTEGER POINTER LREG
070074   INTEGER BREG,XREG,CCDFAD
070077
070077   PIOMMTAD:
070077           T:=L=:"LREG"
070101           X=:XREG:=B=:BREG
070104           T:=A; X:=D; AD SHZ -12; A:=D=:MBPNO                % Phys.page of mailbox
070111           T=:MBBNK; X=:MBADR
070113           *AAX MBREQ; LDATX                                  % GET REQUEST
070115           IF A><0 THEN                                       % REQUEST ?
070116              IF A=5MTCN THEN                                 % CONNECT REQUEST
070121                 CALL MTGIDF; *SKP; JMP OKREQ                 % REQUEST IS OK IF ALREADY CONNECTED
070124                 -1=:CCDFAD
070126                 X:=BMTDFLI
070127                 DO WHILE X><-1                               % SEARCH FOR FREE DATAFIELD
070132                    *IOF
070133                    T:="MTFLAG"; CALL XGTDFADDR
070135                    IF A BIT 5MTFR THEN                       % DF FREE ?
070137                       X=:CCDFAD
070140                       CALL MTSW0                             % SET DF WINDOW
070141                       A:=B=:X.MTRTP
070143                       A:=MBADR=:D:=MBPNO; T:=11              % MTAD TYPE = 11
070147                       CALL MTDFINI
070150                       *ION
070151                       CALL MTMBINI
070152                       CALL MTRW0                             % RESET WINDOW
070153                       GO OKREQ
070154                    ELSE
070155                       *ION
070156                       T:="MTDFLI"; CALL XGTDFADDR; X:=A      % NEXT DF IN LINK
070161                    FI
070161                 OD
070162                 9MTNF; GO EREQ                               % NO FREE DATAFIELD
070164              FI
070164              IF A=5MTDC THEN                                 % DISCONNECT REQUEST
070167                 CALL MTGIDF; GO NODF                         % REQUEST IS OK IF NO DF CONNECTED
070171                 CALL MTSW0                                   % SET DF WINDOW
070172                 CALL MTRSMB; CALL MTRSDF
070174                 CALL MTRW0                                   % RESET WINDOW
070175                 GO OKREQ
070176   NODF:         -1=:CCDFAD
070200              FI
070200   OKREQ:     "0"
070201   EREQ:      T:=MBBNK; A=:D:=0; X:=MBADR; *AAX MBREQ; STDTX  % UPDATE REQUEST,RESPONSE
070207
070207   RETU:      BREG=:B; X:=CCDFAD; A:=MBADR=:D:=MBBNK
070215              CALL MTKPIOC                                    % KICK PIOC
070216   RETU1:     X:=BREG=:B:=XREG
070221              GO LREG
070222           FI
070222           T:=MBBNK; X:=MBADR; *AAX MBINP; LDDTX              % INPUT POINTERS
070226           IF A><D THEN
070230              CALL FAR MTGIDF; GO ERRDF
070232              X=:B; CALL MTIND
070234           FI
070234           CALL FAR MTGODF; GO ERRDF
070236           X=:B; CALL MTOUD                                   % ALWAYS START OUTPUT DRIVER
070240           GO RETU1
070241
070241   ERRDF: -1=:CCDFAD
070243          "316"; GO EREQ                                     % TERMINAL LINE IS NOT CONNECTED
070245   RBUS
070270
070270
070270   %============================================================================
070270   %       M T D M F U N C
070270   %
070270   % Monitor level routine to take requestes from the Pioc kick liste,
070270   % and call the Mon Mtad simulation routine.
070270   %
070270   SUBR MTDMFUNC
070270   MTDMFUNC: X=:B
070271           T:=MBPRWPN; X:=PIORPNT
070273           DO
070273              *LDDTX                                    % A=ReadPnt; D=WritePnt
070274           WHILE A><D                                   % Anything in buffer?
070276              A=:L; AD:=KICKLIST; D+L; A:=A+C           % Yes, compute addr of element
070302              T:=A; X:=D; *LDATX                        % X=Addr of mailbox relative to Kicklist
070305              A SHZ -1=:X
070307              AD:=KICKLIST; D+X; A:=A+C                 % AD=Phys Nd-100 addr of mailbox
070312              CALL PIOMMTAD                             % Perform moncall
070313              T:=MBPRWPN; X:=PIORPNT; *LDATX
070316              A+1/\777; *STATX                          % Update read pointer
070321           OD; GO MONEN
070323   RBUS
070326
070326   %============================================================================
070326   %       M T A 1 1
070326   %
070326   % Routine to activate client for Mtad type 11.
070326   % Executed on Mlevl
070326   %
070326   % Entry:         X=Terminal input Df.
070326   %                B=Terminal output Df.
070326   %
070326   SUBR MTA11
070326   INTEGER SAVB
070327   INTEGER POINTER SAVL
070330   MTA11:   A:=L=:"SAVL"
070332           AD:=DMTMBPH; A SHZ -6               % AD=Phys addr of mailbox
070334           T:=X.MTRTP:=:B=:SAVB                % B=addr of Pioc Queue
070337           X:=X.TDRADDR                        % X=Addr or resident datafield
070340           CALL MTKPIOC
070341           SAVB=:B
070343           GO SAVL
070344   RBUS
070345
070345   %============================================================================
070345   %       M T K P I O C
070345   %
070345   % Subroutine to send a Kick to a Pioc.
070345   %
070345   % Entry:         AD=Phys.addr of mailbox
070345   %                B= Addr of Pioc-Mtad queue
070345   %                X= Addr of Mtad input datafield (resident part)
070345   %                   (-1 means no Mtad datafield)
070345   %
070345   SUBR MTKPIOC
070345
070345   INTEGER CPIOQUEUE         % Addr of Pioc-Mtad queue
070346   INTEGER CCDFAD            % Addr of Mtad Df
070347   DOUBLE  CEVENT            % Current Pioc event
070351   INTEGER CPIOID            % Current Pioc procecc ID
070352   DOUBLE  TOPIBUFFR(0)      % Phys.addr of mailbox
070352   INTEGER 1TOPIBUFF,2TOPIBUFF
070354   % Pioc Superkick definitions (see Pisuper for more details)
070354   SYMBOL SUKOF=1012         % fixed addr in Piocos
070354   SYMBOL HSKPA=52525        % Pattern in Piocos
070354   SYMBOL LSKPA=125252       % Pattern in Piocos
070354   SYMBOL PATRN=0
070354   SYMBOL RTNOP=2
070354   SYMBOL RLOCK=0
070354   SYMBOL RHSIZ=4
070354
070354   MTKPIOC:X=:CCDFAD:=B=:CPIOQUE
070357           T:=A; X:=D; *AAX MBPID; LDATX                % Get Pioc Proc ID
070363           A=:CPIOID; *AAX MBEVE-MBPID; LDDTX           % Get Pioc Event
070366           AD=:CEVENT
070367           *IOF
070370           PIODF=:B
070372           IF PISTT><3 GO ERR                           % Is Pioc alive?
070376           T:=PIOCA; X:=SUKOF; *PATRN@3 LDDTX           % Yes, get "magic" pattern from Piocos
070401           IF A><HSKPA OR D><LSKPA GO ERR               % Is pattern ok?
070407           T:=PIOCA; *RNTOP@3 LDDTX                     % Yes, get addr of Kick-to-Pioc buffer
070411           AD SHZ -1; A+PIOCA; AD=:TOPIBUFF             % Nd-100 phys.addr of Kick-to-Pioc buffer
070414           T:=A; X:=D; *RLOCK@3 LDATX
070417           IF A><0 GO RETU                              % Buffer is locked
070420           *LDATX 20                                    % Get write pointer
070421           A SH 2+RHSIZ; X+A; T:=T+C; *LDATX            % Get element flag
070426           IF A=0 GO NFREE                              % Element free?
070427           CPIOID; *STATX 10                            % Yes, store PiocProcID
070431           CEVENT; *STDTX 20                            % Piocos event
070433           *STZTX                                       % Mark element is in use
070434           T:=1TOPIBUFF; X:=2TOPIBUFF; *LDATX 20
070437           A+1/\7; *STATX 20                            % Update write pointer
070442   NFREE:  T:=HDEV+3; A:=5; *IOXT                       % Kick Pioc
070446   RETU:   X:=CPIOQUEUE=:B:=CCDFAD
070451           *ION
070452           EXIT
070453
070453   % Pioc is not running
070453   % Mark this status in the Data field, and then the Timer program
070453   % will take the necessary action.
070453   %
070453   INTEGER  LREG
070454   ERR:    IF X:=CCDFAD><-1 THEN
070460              A:=L=:LREG
070462              T:="FLAGB"; CALL XGTDFADDR
070464              A BONE 5LSTA; T:="FLAGB"; CALL XSTDFADDR
070467              T:="MTFLAG"; CALL XGTDFADDR
070471              A BONE 5MTSF BONE 5MTLG
070473              T:="MTFLAG"; CALL XSTDFADDR
070475              T:="TMR"; A:=-1; CALL XSTDFADDR
070500              X+9CXTI; A:=-1; T:="TMR"; CALL XSTDFADDR
070504              LREG=:L
070506           FI; GO RETU
070507   RBUS
070520
070520   @DEV 1
070520   @DEV (S-S-L)MP-P2-2:NPL
070520   *"8LPPU
"070520

070520   %==============================================================================
070520   % 33.10      L P P U T
070520   %
070520   @MAC

)9SCLC
070520  % LINE PRINTER COVERTING ROUTINES
070520  PTABL=*
070520  PTABL<PTABL 27
070520  )ZERO
070520  % INSERT INPUT AND OUTPUT VALUES HERE
070520  %
070520  160;30
070522  44;135
070524  135;134
070526  43;133
070530  100;134
070532  0
070533  PTABL 20/
070540  % IOTRANS ROUTINE FOR LINE PRINTER
070540  % THE CHARACTERS IN PTABL ARE CONVERTED
070540  LPPUT, COPY  SX DD
070541         LDX   (PTABL
070542         BSET ZRO 70 DA
070543         1BANK
070544         LDT ,X
070545         2BANK
070546         SKP   DT UEQ 0
070547         JMP   PCON1
070550         SKP   DT UEQ SA
070551         JMP   * 3
070552         AAX   2
070553         JMP   LPPUT 3
070554         1BANK
070555         LDA   1 ,X
070556         2BANK
070557  PCON1, SAT   0
070560         SAX   -10
070561         BSET  ZRO 70 DA
070562         SHA   10
070563         JAP   *+2
070564         AAT   1
070565         SHA   ROT 1
070566         JNC   *-3
070567         BSKP  ZRO 00 DT
070570         BSET  ONE 70 DA
070571         COPY  SD DX
070572         JMP I (TRTPU
070573  )FILL
070575  )9RCLC
)9SLPL
070575   *"
"070575
070575   %==============================================================================
070575   % 37.15      M P R I N T           M O C T U T
070575
070575   % MONITOR LEVEL SUBROUTINE TO PUT TEXT DIRECTLY INTO TERM.1-BUFFER
070575   % ENTRY:     A=TEXT POINTER        A=NUMBER
070575   SUBR MPRINT, MOCTUT
070575   INTEGER TRTX,LREG,BREG,XREG
070601
070601   CSBUWINDOW:
070601          AD:=DTDFPHPAGE; A:=:D/\1777+"WNDBF*2000":=:B  % B IS NOW BIG DF.
070606          A:=142000; X:="WNDBF+WNDBF+174000"; T:=0; *STDTX
070612          EXIT
070613
070613   MPRINT: *IOF
070614          A=:TRTX:=L=:LREG:=B=:BREG:="DT01W"=:B; X=:XREG
070624   @LIB OLD
070624          CALL CSBUWINDOW
070625          X:=0
070626          DO
070626              T:=TRTX; *LBYT
070630          WHILE A><##'
070633              CALL CXRBPUT; X+1
070635          OD
070636   @LIB OLD
070636   OUT:   -1=:TMR; X:="WNDBF+WNDBF+174000"; T:=0; *STZTX
070643          X:=LREG=:L:=BREG=:B:=XREG
070650          *ION; EXIT
070652
070652   DOUBLE SVVAD
070654   MOCTUT: *IOF
070655          A=:TRTX:=L=:LREG:=B=:BREG:="DT01W"=:B; X=:XREG
070665   @LIB OLD
070665          CALL CSBUWINDOW
070666          X:=0
070667          IF TRTX >< 0 THEN
070671              A=:D:=0; AD SHZ 1; K:="0"
070675              FOR X:=-6 DO
070676                  IF A >< 0 OR K THEN
070701                      AD=:SVVAD
070702                      A+##0; CALL CXRBPUT
070704                      AD:=SVVAD
070705                      K:="1"
070706                  FI
070706                  A:=0; AD SHZ 3
070710              OD
070711          ELSE
070712              ##0; CALL CXRBPUT
070714          FI
070714   @LIB OLD
070714          GO OUT
070715   RBUS
070723
070723   *"8REA1+8REA2
"070723   %==============================================================================
070723   %     (M)    W P U N C H
070723   %
070723   % OUTPUT DRIVER FOR PAPER-TAPE-PUNCH ON LEVEL 10!
070723   %
070723   SUBR WPUNCH
070723   WPUNCH:
070723          0=:TMR                                               % RESET TIMER
070724          T:=HDEV+DST; *IOXT                                   % READ STATUS
070727          IF BIT 3 THEN                                        % READY FOR TRANSFER?
070731             TAD:=FFMAX                                        % T=MAX, A=BHOLD, D=HENTE
070732             IF A><0 THEN                                      % CHARACTERS IN BUFFER?
070733                A-1; D=:X+1; IF D=T THEN D:="0" FI; AD=:DBHOLD % UPDATE BUFFER POINTERS
070742                MIN CFREE; T:=BUFST; *1BANK; LBYT; 2BANK       % GET CHARACTER FROM BUFFER
070747                T:=HDEV+DDW; *IOXT                             % WRITE CHARACTER
070752                T+"DCONT-DDW"; "DACT+DPIN"; *IOXT              % ENABLE DEVICE FOR INTERRUPT
070755                TTMR=:TMR                                      % START TIMER
070757                IF ISTAT><0 THEN                               % IS USER WAITING?
070761                   IF BHOLD<MINBHOLD THEN CALL RTACT FI        % MINBHOLD REACHED?
070766                FI
070766             FI
070766          FI
070766          CALL ID10; GO WPUNCH                                 % WAIT FOR INTERRUPT
070770   RBUS
070773   *"
"070773

070773   %==============================================================================
070773   %                  C L O C K   I N T E R R U P T
070773   %
070773   % 37.8.2     E N T 1 3
070773   %
070773   % CLOCK INTERRUPT ENTRY, LEVEL 13
070773   %     INTEGER HISTFLAG=?
070773   SUBR ENT13
070773          DO
070773   *"8MPRF
"070773                CALL MSAMP                % Mon Performance sampling
070774   *"
"070774                CALL ID13
070775   ENT13:       "FREQU+60001"; *IOX DCONT RTCLD
070777                ATIME; D+1; A:=A+C; AD=:ATIME
071003                *TRA PVL
071004                IF A/\170=ALEVB OR =BLEVB THEN
071013                  A:=CURPROG-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
071021                  A*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; *CPUTI@3 LDDTX
071026                  D+1; A:=A+C; *CPUTI@3 STDTX
071031   *"8ACC
"071031                  IF RTACCFLAG >< 0 THEN CALL NACCOUNT FI
071034   *"
"071034                FI
071034   NEXT:        CALL RTACT
071035   *"8HIST
"071035                CALL SHISTI                    % MAY BE HISTOGRAM SAMPLING
071036   *"
"071036          OD
071037   RBUS
071055
071055   INTEGER ARRAY PCCS=?
071055
071055

071055   %==============================================================================
071055   %      ( M )     I N T E R N A L     I N T E R R U P T S
071055   %
071055   %            E N T 1 4    R E T 1 4   E R R 1 4   E F J O B
071055   %
071055   % ENTRY FOR INTERNAL INTERRUPTS, LEVEL 14
071055   %
071055   *MGOTA=*
071055   SUBR ENT14,RET14,ERR14,EFJOB,YWAIT
071055
071055   @ICR;
071055   INTEGER ARRAY GOTAB:=(MFELL,M1,M2,MFELL,MFELL,MFELL,MFELL,MFELL,
071065                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071075                   MFELL,M21,M22,M23,M24,MFELL,MFELL,MFELL,
071105                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071115                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071125                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071135                   MFELL,MFELL,MFELL,M63,MFELL,MFELL,MFELL,MFELL,
071145                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071155                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071165                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071175                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071205                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071215                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071225                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071235                   MFELL,MFELL,MFELL,MONERR,MFELL,MFELL,MFELL,MFELL,
071245                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071255                   XMSGY,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071265                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071275                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071305                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071315                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071325                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071335                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071345                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071355                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071365                   M310,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071375                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071405                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,
071415                   MFELL,MFELL,MFELL,MFELL,MFELL,MFELL,MONERR,MFELL,
071425                   MFELL,MONERR,MONERR,MONERR,MONERR,MONERR,MONERR,MONERR,
071435                   MONERR,MONERR,MONERR,MONERR,MONERR,MONERR,MONERR,MONERR,
071445                   MONERR,MONERR,MONERR,M373,MFELL,MFELL,M376,M377);
071455   @CR;
071455
071455   %DISP -200       % USING GLOBAL BASE INSTEAD.
071455   %       INTEGER PERR,ACTLV,IBITNO,PESERR,PEAERR,SADINSTR
071455   %       DOUBLE MMAP
071455   %PSID
071455
071455   % SYMBOL 5FATAL    = 15     % STATUS BITS IN N-100 PES-REGISTER
071455   % SYMBOL 5DMAFAULT = 16
071455
071455   DISP -1; INTEGER SN1; PSID
071455
071455   % ACTIVATE LEVEL 4 FOR MONITOR CALLS THAT WILL BE HANDLED
071455   % ON LEVEL 4.
071455   %
071455   M1:    "INBT";   GO IOB14
071457   M2:    "OUTBT";  GO IOB14
071461   M21:   "M8INB";  GO IOB14
071463   M22:   "M8OUTB"; GO IOB14
071465   M23:   "B8INB";  GO IOB14
071467   M24:   "B8OUT";  GO IOB14
071471   M63:   "B4INW";  GO IOB14
071473   M310:  "T8INP";  GO IOB14
071475   M373:  "BFY4INST"; GO IOB14
071477   M376:  "5INB";   GO IOB14
071501   M377:  "5OUTB"
071502   IOB14: *IRW BLEVB DP               % SET MONCALL ROUTINE ADDR ON BLEVL
071503          A:=1; *IRW BLEVB            % SET BIT #0 IN STATUS REG. ON BLEVL.
071505          BLEV; *MST PID
071507          GO RET14
071510   *)FILL
071524
071524   *"8SWLG
"071524   %===================================
071524   %      F P F C O U N T
071524   %
071524   FPFCOUNT:                                        % COUNT FAST PAGEFAULTS
071524          IF CSWLG><0 THEN                          % SWAPPING-LOG STARTED?
071526             *MIN I (TFPF2; SKP; MIN I (TFPF1; JMP *+1 % YES, COUNT PF.
071532             IF A-RTREF=0 THEN                      % LOG FOR THIS PROGRAM?
071534                *MIN I (CFPF2; SKP; MIN I (CFPF1; JMP *+1 % YES, COUNT PF
071540             FI
071540          FI; EXIT
071541   *"
"071541
071541   %=============================
071541   %       C L I M C H E C K
071541   %
071541   % LOCAL SUBROUTINE TO CHECK IF PNUMB (FAULTED PAGE), IS WITHIN A SEGMENT
071541   %
071541   % ENTRY:         X=SEGMENT ADDR
071541   % EXIT:          PNUMB IS WITHIN SEGMENT
071541   % EXITA:         PNUMB IS OUTSIDE SEGMENT (OR NO SEGMENT, I.E. X=0)
071541   %
071541   CLIMCHECK:
071541          IF X=0 THEN EXITA FI                      % NO SEGMENT
071544          T:=SEGTBANK; *LOGAD@3 LDDTX               % A:=LOGADR, D:=SEGLENGTH
071546          IF A>PNUMB OR A+D<=T THEN EXITA FI        % OUTSIDE SEGMENT
071555          EXIT                                      % PNUMB IS WITHIN SEGMENT
071556   *)FILL
071566
071566   INTEGER SVT14
071567
071567   %================================
071567   %      ( M )    I P A G E F A U L T
071567   %
071567   % PAGEFAULT
071567   IPAGFAULT: PNUMB/\1777=:PNUMB                    % PNUMB=LOGICAL PAGE CAUSING PAGEFAULT
071572          IF A=X:=WNDBF THEN                        % PF IN BUFFER WINDOW?
071575             IF RTREF.BUFWINDOW =0 THEN CALL ERRFATAL FI % BUFFER WINDOW DEFINED?
071601             A=:D:=142000                           % READ+WRITE+RING2
071603             X:="WNDBF+WNDBF+174000"; T:=0; *STDTX  % YES SET PIT ENTRY
071606   *"8SWLG
"071606             CALL FPFCOUNT                          % COUNT PAGEFAULT
071607   *"
"071607             GO RET14                               % LEAVE LEVEL 14
071610          FI
071610          IF A=X:=WND41 THEN                        % PF IN TERMINAL WINDOW
071613             IF RTREF.TRMWINDOW=0 THEN CALL ERRFATAL FI % TERMINAL WINDOW DEFINED?
071617             A=:D:=142000                           % READ+WRITE+RING2
071621             X:="WND41+WND41+174000"; T:=0; *STDTX  % YES, SET PIT ENTRY
071624   *"8SWLG
"071624             CALL FPFCOUNT                          % COUNT PAGEFAULT
071625   *"
"071625             GO RET14                               % LEAVE LEVEL 14
071626          FI
071626
071626   *"8N500
"071626          IF A=X:=WNDN5 THEN                       % PF IN ND500 WINDOW
071631             IF RTREF.N5WINDOW=0 THEN CALL ERRFATAL FI % ND500 WINDOW DEFINED?
071635             A=:D:=142000                          % READ+WRITE+RIN2
071637             X:="WNDN5+WNDN5+174000"; T:=0; *STDTX % YES, SET PIT ENTRY
071642   *"8SWLG 8N500
"071642             CALL FPFCOUNT                          % COUNT PAGEFAULT
071643   *"8N500
"071643             GO RET14                               % LEAVE LEVAL 14
071644          FI
071644   *"
"071644          IF ACTLV=X:=MLEVL THEN CALL ERRFATAL FI             % PF. ON MLEVL ONLY IN WINDOWS
071651          IF X:=BACKGROUND=0 THEN
071654             IF ACTLV=X:=BLEVL THEN CALL ERRFATAL FI          % ILLEGAL WITH PF ON LEVEL 4 CAUSED BY RT-PROGRAM
071661             IF PNUMB>>=X:=ARTFPAGE AND A<<=X:=ARTLPAGE THEN  % PAGE FAULT IN RT-COMMON?
071670                T=:SVT14
071671                X:=SEGMC; CALL CLIMCHECK; GO PFINSEGMENT
071674                X:=SEGMB; CALL CLIMCHECK; GO PFINSEGMENT
071677                X:=SEGMA; CALL CLIMCHECK; GO PFINSEGMENT
071702                X:=IRTCPIT; A:=PNUMB SH 1=:T
071706                X+A; AD:=X.DS0; X:=174000+T; T:=0; *STDTX     % SET UP RT-COMMON IN PIT
071714   *"8SWLG
"071714                IF CSWLG><0 THEN                              % SWAP LOG STARTED?
071716                   *MIN I (TPFR2; SKP; MIN I (TPFR1; JMP *+1  % YES, COUNT PF
071722                   IF A=RTREF THEN                            % LOG FOR CURRENT PROGRAM?
071725                      *MIN I (CPFR2; SKP; MIN I (CPFR1; JMP *+1 % YES, COUNT PF
071731                   FI
071731                FI
071731   *"
"071731                GO RET14                                      % LEAVE LEVEL 14
071732             FI
071732          FI; A:=BLEV; *MCL PID                               % DISABLE BLEVL
071734          A:=T; GO ACTMON                                     % PF WILL BE HANDLED ON MONITOR LEVEL
071736
071736   %====================================================
071736   %      ( M )   M F E L L   -   A C T M O N
071736   %
071736   % COMMON ENTRY FOR MONITOR CALLS THAT WILL BE HANDLED
071736   % ON MONITOR LEVEL (AND APP.LEVEL)
071736   MFELL: T=:A; *IRW MLEVB DX                                 % X-REG ON MONITOR LEVEL IS MON.CALL NUMBER
071740          "CALLPROC"                                          % ENTRY POINT ON MONITOR LEVEL
071741   ACTMON: *IRW MLEVB DP
071742          MLEV; *MST PID; MST PIE
071745          GO RET14
071746
071746   %=============================================
071746   %      ( M )   P F I N S E G M E N T
071746   %
071746   % PAGEFAULT IS IN SEGMENT AND NOT IN RTCOMMON
071746   PFINSEGMENT: A:=SVT14; GO ACTMON
071750
071750   %====================================
071750   %      ( M )    A B O R
071750   %
071750   % ABORT CURRENT RUNNING PROGRAM
071750   ABOR:  "PBRTEXT"; GO ACTMON
071752   *)FILL
072005
072005   MONERR: T=:A; CALL 9ERR(#00); GO FAR ABOR        % ILLEGAL MONITOR CALL
072011
072011   %=========================================================================
072011   %      ( M )    E N T 1 4   R E T 1 4
072011
072011   ENT14: "B14"=:B; GO BEG14              % INITIAL ENTRY POINT
072014   RET14:
072014   YWAIT: T:=1000=:D; *WAIT; COPY SA DA   % IF T-REG IS UNCHANGED AFTER INTERUPT THEN NOT MONCALL
072020   BEG14: *TRA IIC                        % READ INTERNAL INNTERUPT CODE
072021          IF T=D GO NOMONCALL             % MONITOR CALL?
072023          *TRA PGS; TRA STS               % YES, CLEAR PGS IN CASE OF PF ON PREFETCH
072025   MONCALL:
072025   *"8MPRF
"072025          CALL PML10                      % Mon Performance moncall sampling
072026   *"
"072026          X:=377; T/\X; T=:14MONNO        % T=MONITOR CALL NUMBER
072031   *"8DIR
"072031            IF X:=MCLGFLG><0 THEN                   % MONITOR CALL LOG STARTED?
072033               IF X:=CMCLG=-1 OR X=RTREF THEN       % COUNT THIS MONITOR CALL
072042                  A=:L:=14MONNO SH 1+TNMCALL=:X; T:=MCLGBANK
072050                  *LDDTX; RINC DD; COPY SA ADC DA; STDTX
072054                  A:=L
072055               FI; T:=14MONNO
072056            FI
072056   *"
"072056            *1BANK
072057            X:=GOTAB(T); *2BANK; JMP ,X; )FILL             % MONITOR CALL NUMBER IN T
072077
072077   %==============================================================================
072077   %      ( M )    N O M O N C A L L
072077   %
072077   % INTERNAL INTERRUPT MAY BE ANYTHING BUT MONITOR CALL
072077   NOMONCALL:
072077          A=:IBITNO; *TRA STS
072101          *TRA PVL
072102          A=:D; *EXR SA                             % D=P-REG ON PREVIOUS LEVEL
072104          A=:PERR:=D SH 11 SHZ -14=:ACTLV           % ACTLV=PREVIOUS LEVEL
072111          IF IBITNO>>12 THEN CALL ERRFATAL FI       % UNDEFINED INTERNAL INTERRUPT CODE
072116   @ICR;
072116          A GOSW IIC00,IIC01,IIC02,FAR IIC03,FAR IIC04,FAR IIC05,FAR IIC06,FAR IIC07,
072127                 FAR IIC10,FAR IIC11,FAR IIC12
072131   ;@CR;
072132
072132   IIC00: A:=16; T:=0; CALL 9ERR(#22)               % FALSE INTERRUPT
072136          GO RET14
072137
072137   IIC01: CALL ERRFATAL                             % MONITOR CALLS
072140                                                    % SHOULD BE HANDLED BEFORE THIS POINT
072140
072140   IIC02:                                           % PROTECT VIOLATION
072140          IF ACTLV=ALEVL OR A=LEVL5 THEN
072147             *TRA PGS
072150             A=:T/\1777=:PVPAGE SH -6 =:PVPIT
072155             IF ACTLV-1 = 0 THEN                    % SKIP IF LEVEL 5
072160                IF T NBIT 17 THEN                     % IS IT FETCH FAULT?
072162                  *IRR ALEVB DP; AAA -1; IRW ALEVB DP % NO, DECREMENT P-REG TO RESTART INSTRUCTION
072165                FI
072165             FI
072165             IF T BIT 16 THEN                       % PERMIT VIOLATION?
072167                IF PVPIT=UPITN OR =UPITA THEN       % YES, IN USER PAGE TABLES?
072176                   IF SEGMC><0 THEN                 % YES, CAN IT BE WRITE IN REENTRANT SEGEMNT'S PAGE?
072200                      PVPAGE SH 1+174000=:X; T:=0; *LDDTX % YES, GET PIT ENTRY FOR FAULTED PAGE.
072206                      IF A NBIT 5WPM THEN           % NOT WPM IN PIT ENTRY.
072210                         T:=SEGTBANK; X:=SEGMC; *SGSTA@3 LDATX
072213                         IF A BIT 5WPM THEN         % WRITE PERMIT IN SEGMENT?
072215                            A:=D SH 2=:PVPHYS       % MEM.MAP ADDR OF "FAULTED PAGE"
072220                            *LOGAD@3 LDDTX          % YES, A=FIRST PAGE, D=SEGLENGTH
072221                            T:=A
072222                            IF PVPAGE>=T AND A<D+T THEN % WITHIN SEGMENT LIMITS?
072230                               IF ACTLV-LEVL5 = 0 THEN  % LEVEL 5
072233                                   CALL P2XMS
072234                                   GO FAR TDTLEV
072235                                   GO RET14
072236                               FI
072236                               A:="WREENT"              % YES, HANDLE IT ON MONITOR LEVEL
072237                               GO FAR ACTMON
072240                            FI
072240                         FI
072240                      FI
072240                   FI
072240                FI
072240             FI;  CALL 9ERR(#31)                    % GIVE ERROR MESSAGE (PERMIT VIOLATION)
072242             GO FAR ABOR                            % ABORT CURRENT RUNNING PROGRAM
072243          FI; GO FAR TDTLEV
072244   *)FILL
072273
072273   *IICPF=*
072273   IIC03:                                           % PAGEFAULT
072273          IF ACTLV=ALEVL THEN                       % PAGEFAULT ON APPL.LEVEL
072277             *TRA PGS                               % GET LOGICAL PAGE AND "STATUS" BIT
072300             IF A=:PNUMB NBIT 17 THEN               % SHOULD FAULTED INSTRUCTION BE RESTARTED?
072303                *IRR ALEVB DP; AAA -1; IRW ALEVB DP % YES, DECREMENT P-REG
072306             FI; T:="PPAGEFAULT"; GO FAR IPAGFAULT
072310           FI
072310          IF A=BLEVL THEN                           % PAGEFAULT ON LEVEL 4
072313             *TRA PGS                               % GET LOGICAL PAGE AND "STATUS" BIT
072314             IF A=:PNUMB NBIT 17 THEN               % SHOULD FAULTED INSTRUCTION BE RESTARTED?
072317                *IRR BLEVB DP; AAA -1; IRW BLEVB DP % YES, DECREMENT P-REG
072322             FI; T:="P2PAGE2FAULT"; GO FAR IPAGFAULT
072324          FI
072324          IF A=MLEVL THEN
072327             *TRA PGS                                % PAGEFAULT ON MONITOR LEVEL
072330             IF A=:PNUMB NBIT 17 THEN
072333                *IRR MLEVB DP; AAA -1; IRW MLEVB DP
072336             FI; GO FAR IPAGFAULT
072337          FI
072337          IF A=5 THEN CALL P2XMS; GO FAR TDTLEV; GO RET14 FI % PF IN XMSG
072345          GO FAR TDTLEV                             % MAY BE PAGEFAULT ON ILLEGAL LEVEL
072346
072346   IIC04: IF ACTLV=ALEVL THEN                       % ILLEGAL INSTRUCTION
072352             IBITNO; T:=PERR; CALL 9ERR(#24)        % GIVE ERROR MESSAGE
072356             GO FAR ABOR                            % TERMINATE CURRENT RUNNING PROGRAM
072357          FI; GO FAR TDTLEV                         % ILLEGAL INSTRUCTION ON OTHER LEVELS
072360
072360   IIC05: IF ACTLV=ALEVL THEN                       %
072364             *IRR ALEVB 0; BSET ZRO SSZ; IRW ALEVB 0 % RESET Z INDICATOR ON ALEVL (Z IS IN STATUS REG)
072367             CALL 9ERR(#30)                         % GIVE ERROR MESSAGE
072371             GO FAR ABOR                            % TERMINATE CURRENT RUNNING PROGRAM
072372          FI; GO FAR TDTLEV                         % MAY BE Z INDICATOR IS SET ON ILLEGAL LEVEL
072373   *)FILL
072404
072404   IIC06: IF ACTLV=ALEVL THEN                       % PRIVILIGED INSTRUCTION
072410             RTREF.ACTPRI/\74000 SHZ -4+"NMPIT+LV14B+ERNG2"% SET USERS NORMAL PIT AS ALT. PIT
072415             X:=PERR; *TRR PCR
072417             X.SN1=:D                               % D= THE ILL.INSTR.
072421             "NMPIT+ADPIT+LV14B+ERNG2"; *TRR PCR    % RESET PCR
072423             IF 177600/\D=161000 THEN T:=177/\D; GO FAR MONCALL FI % IF 161XXX THEN MONCALL
072433             IBITNO; T:=PERR; CALL 9ERR(#24)        % GIVE ERROR MESSAGE
072437             GO FAR ABOR                            % TERMINATE CURRENT RUNNING PROGRAM
072440           FI; GO FAR TDTLEV                        % MAY BE ILL.INSTRUCTION ON ILLEGAL LEVEL
072441
072441   IIC07: T:=ACTLV; A:=PERR; CALL 9ERR(#37)         % IOX-EROR
072445          GO RET14
072446
072446   IIC10: *TRA PES                                  % MEMORY ERROR
072447          A=:PESERR
072450          IF A NBIT 5FATAL THEN                     % CAN ERROR BE CORRECTED?
072452             *TRA PEA                               % YES
072453   NOFATAL:  A=:PEAERR; T:=PESERR
072455             CALL 9ERR(#44); A:=0; *TRR ECCR
072461          ELSE
072462             *TRA PEA                               % NO
072463   NOCORR:   A=:PEAERR; T:=PESERR; CALL 9ERR(#38)   % NOT CORRECTABLE ERROR
072467             A:=PEAERR; T:=PESERR; CALL MFXMSG      % FATAL MEMORY ERROR IN XMSG?
072472             IF PESERR BIT 5DMAFAULT THEN CALL ERRFATAL FI  % DMA-ERROR N-100
072476             IF ACTLV=ALEVL GO FAR ABOR              % ABORT CURRENT ACTIVE PROGRAM WHEN MEM.ERROR ON APPL.LEVEL
072502             IF ><0 GO FAR TDTLEV                    % IF MWM.ERROR ON LEVEL 0, CONTINUE
072504          FI; GO RET14
072505   *)FILL
072521
072521   IIC11:                                           % MEMORY OUT OF RANGE
072521          *TRA PES
072522          A=:PESERR=:T; *TRA PEA
072525          A=:PEAERR; CALL 9ERR(#39)                 % GIVE ERROR MESSAGE
072530          IF PESERR BIT 5DMAFAULT GO RET14          % DMA-ERROR
072533          IF ACTLV=ALEVL GO FAR ABOR                % ABORT CURRENT PROGRAM
072537          GO FAR TDTLEV                             % MAY BE MEMORY OUT OF RANGE ON ILLEGAL LEVEL
072540
072540   IIC12: GO PPWFAIL                                % POWER FAIL
072541
072541   %=======================
072541   %      T D T L E V
072541   %
072541   % TEST FOR ERROR ON DIRECT TASK LEVEL (6 TO 9)
072541   INTEGER CBSET(0); *BSET ONE DA
072542   TDTLEV: IF ACTLV>=6 AND A<12 THEN                % ERROR ON DIRECT TASK LEVEL?
072551              A SH 3\/CBSET=:T; A:=0                % YES
072555              *EXR ST; MCL PID; MCL PIE             % DISABLE LEVEL
072560              T:=IBITNO; ACTLV; CALL 9ERR(#04)      % GIVE ERROR MESSAGE
072564              *TRA PGS
072565              GO RET14
072566           FI; CALL ERRFATAL                        % FATAL INTERNAL ERROR ON ILLEGAL LEVEL
072567   *)FILL
072575   %===================================================================
072575   %      ( M )      E R R 1 4
072575   ERR14: "B14"=:B; IBITNO; T:=PERR; CALL 9ERR(#40)
072603          GO RET14
072604
072604   *"8BEX1
"072604   %==============================
072604   %      ( M )   E F J O B
072604   %
072604   %    ENTRY FROM BEX-DRIVER LEVEL 13
072604   EFJOB: "B14" =: B                      % GET BASE-FIELD
072606          PEAERR; T := PESERR             % GET PARAMETERS
072610          IF T BIT 5FATAL GO FAR NOCORR   % TEST FOR FATAL ERROR
072612          GO FAR NOFATAL
072613
072613   *"
"072613   RBUS
072620
072620   *"8N500
"072620   %=============================================================================
072620   %      ( M )     C H F I X
072620   %
072620   % Subroutine to check if buffer in 500-proc is fixed contigously.
072620   %
072620   % Entry:   AD= N100 physical memory address
072620   %          T = number of n100 words to transfer
072620   %          X = calling process number
072620   %
072620   % Exit:    area not fixed
072620   %
072620   % Exit+1:  ok, area fixed
072620   %
072620   SUBR CHFIX
072620   SYMBOL FIXCONT=14,FIXABST
072620   INTEGER FPHPAG,LPHPAG,MXTA,N5SE
072624
072624   CHFIX: AD SHZ 6; A=:FPHPAG; X=:N5SE                           % First physical page
072627          AD SHZ -6; T-1; D+T; A:=A+C
072633          AD SHZ 6; A=:LPHPAG                                    % Last physical page
072635          IF 5FXBNK=0 AND 5FXTBL=0 THEN EXIT; FI                 % No areas fixed
072642          A:=N5SE-1*"MFSIZE*MFANT"+5FXTBL=:X+"MFSIZE*MFANT"=:MXTA
072651          DO
072651             T:=5FXBNK; *LDDTX                                   % AD = MFDESCR
072653             IF A BIT FIXABS OR A BIT FIXCONT THEN
072657                T:=5FXBNK; *LDDTX 20                             %  A=first fixed log page, d = last
072661                D-A                                              %  Length of fixed area in d
072662                T:=5FXBNK; *LDATX 40                             %  First nd-100 phys page in a
072664                D+A                                              %  Last nd-100 phys page in d
072665                IF T:=FPHPAG>=A AND T:=LPHPAG<=D THEN
072673                   X:=N5SE; EXITA                                %  Within fixed area
072675                FI
072675             FI
072675             X:=X+MFSIZE
072676          WHILE X<< MXTA
072701          OD
072702          EXIT
072703   RBUS
072706   *"
"072706
072706
072706   @DEV 1
072706   @DEV (S-S-L)MP-P2-DISK-START:NPL
072706   *"8STRD
"072706    SUBR GETFREE,GETSWFREE,PUTFREE
072706    INTEGER SAVB,SAVX
072710    INTEGER POINTER LREG
072711    % GETFREE:
072711    %-------------------------------------------------------------------
072711    % ROUTINE TO GET A QUE DF FROM FREE POOL                         ( M )
072711    % X= PROGRAM, B= QUE POOL DF
072711    % USE X-REG
072711    % EXIT  : ERROR, NO MORE QUE ELEMENTS
072711    % EXITA : T= QUE ELEM ADDRESS
072711    %-------------------------------------------------------------------
072711    GETSWFREE:
072711           A:=L=:"LREG"
072713           IF QPFNO=0 GO LREG
072716           X:=B; *AAX QPFSW
072720           GO LSW
072721    GETFREE:
072721           A:=L=:"LREG"
072723           IF QPFNO  = 0  THEN                      % NO MORE FREE QUE ELEMENTS
072725              X=:SAVX; X:="DUMMY"; CALL BRESERVE
072730              X:=SAVX; GO LREG
072732           FI
072732           QPFNO-1=:QPFNO                           % UPPDATE FREE QUE ELEMENTS
072735           X:=B; *AAX QPFRH
072737    LSW:   CALL GETOUT                              % GET QUE ELEMENT
072740           IF T.RTRES >< 0 THEN CALL ERRFATAL; FI
072744           0=:X.TYPRING               % DUE TO DOUBLE USE
072745           "LREG"=:L; EXITA
072750    % PUTFREE
072750    %-------------------------------------------------------------------
072750    % ROUTINE TO PUT A QUE DF IN FREE POOL, DF MUST BRE RELEASED     ( M )
072750    % ENTRY:  T= QUE ELEMENT ADDRESS
072750    %         B= QUE POOL DF
072750    %  USE TAD,X-REG
072750    %-------------------------------------------------------------------
072750    PUTFREE:
072750           A:=L=:"LREG"
072752           IF SAQEL= T THEN     % SWAPPER ELEMENT
072755             X:=B; *AAX QPFSW
072757           ELSE
072760             IF RTRES >< 0 THEN CALL ERRFATAL FI
072763             X:=B; *AAX QPFRH
072765             MIN QPFNO; A /\ A
072767           FI
072767           CALL PUTIN
072770           GO LREG
072771   RBUS
072776
072776   SUBR STRNS
072776   %-------------------------------------------------------------------
072776   %  MONITOR LEVEL ROUTINE TO GET A DISC-ACC-QUE ELEMENT AND     ( M )
072776   %    START DRIVER LEVEL
072776   %    A= PAR LIST, B=CONTR. DATAFIELD
072776   %    T= PIT NO FOR PARAMETER (T=0 => USE RTREF.ACTPRI)
072776   %    L= RET ADDRESS OR 0 (0 => STARTED FROM ABSTR, RETURN TO STUPR)
072776   %
072776   %-------------------------------------------------------------------
072776   INTEGER TREG,AREG,LREG,BREG,QDF,PROW
073004
073004   *"8STRD -8DIMI
"073004
073004   STRNS:  A=:AREG; A:=B=:BREG
073007           T=:TREG:=L=:LREG; *IOF
073013           IF T=0 THEN
073015              X:=RTREF=:PROW; "QP100"=:B
073021              CALL GETFREE; GO FULL
073023           ELSE
073024             X:=RTRES=:PROW; "QP100"=:B
073030             CALL GETSWFREE; CALL ERRFATAL
073032           FI; *ION
073033           T=:B=:QDF; X:=PROW; CALL BRESERVE         % RESERVE QUE ELEMENT
073037           IF A<0 THEN CALL ERRFATAL FI
073041           T:=LREG=:"TRLREG"                         % RETURN ADDRESS ON MLEV
073043           0=:TYPCO; AREG
073045           IF T=0 THEN CALL GAPFU ELSE CALL GAPFD FI
073052   % ---------------------------------- START LEV 11
073052           *IOF
073053           BREG;       *IRW LV11B DB                 % CONTROLLER
073055           A."STDRIV"; *IRW LV11B DP
073060           QDF;        *IRW LV11B DX                 % PARAMETERS
073062           LV11;       *MST PID
073064           X:=RTRES; CALL WDATA
073066           X.STATUS BONE 5NOABORT=:X.STATUS; *ION    % SET DELAYED ABORT
073072           IF X=RTREF GO RWAIT; GO MONEN
073076   FULL:   *ION
073077           GO WT
073100    RBUS
073115
073115    SUBR STRETRANS
073115    %-------------------------------------------------------------------
073115    % MONITOR LEVEL ROUTINE, ACTIVATED AFTER DRIVER IS FINISHED     ( M )
073115    %
073115    % X= CONTR. DF
073115    %-------------------------------------------------------------------
073115    % CACHE IS NOT CLEARED ON FUNC  1 & 61  (DMA OUTPUT)
073115    %                               66      (DMA INPUT TO CACHE INHIBITED AREA)
073115    %---------------------------------------------------------------------------
073115    INTEGER PROW,CDF,SSTA
073120    INTEGER POINTER TRLR
073121    STRETRANS:
073121           X=:B=:CDF                                % B= CONTR. DF
073123           DO
073123              X:=B; * AAX DIREE
073125           WHILE X.S0 >< -1                         % MORE IN QUE ?
073131              *IOF
073132              CALL GETOUT; T=:B; *ION               % B= QUE ELEMENT
073135              IF X:=RTRES=:PROW><0 THEN
073140                 0=:TYPRING                         % DUE TO DOUBLE USE (BREGQ)
073141                 CALL RDATA; CALL BRELEASE          % RELEASE QUE ELEM
073143              FI
073143              "TRLREG"=:"TRLR"; SSSTAT=:SSTA
073147              IF ABFUN/\77><1 AND ><61 AND ><66 THEN
073162                 *TRR CCLR  % CLEAR CACHE
073163              ELSE
073164   *CCM02,       TRR CCLR   % CLEAR CACHE ON NOT RASK
073165              FI
073165              T:=B; "QP100"=:B      % T= QUE ELEM
073170              IF SAQEL = T OR "TRLR" = 0 THEN       % SWAPPING OR ABSTRANS
073175                *IOF
073176                CALL PUTFREE;      *ION             % TOO FREE POOL
073200              FI
073200              X:=T; CDF=:B                          % X= QUE ELEM, B= CONTR DF
073203              IF "TRLR"=0 THEN                      % FROM ABSTR
073205                 IF PROW><0 THEN                    % PROG ABORTED ?
073207                    IF SSTA BIT 4 THEN A BONE 17 ELSE A BZERO 17 FI
073215                    IF X:=PROW=CURPROG THEN
073221                       *IRW ALEVB DA
073222                    ELSE
073223                       X:=X.RTDLGADDR
073224                       T:=0; *AAX DAREG; STATX
073227                    FI
073227                 FI
073227              ELSE                                  % FROM CALL MTRANS
073230                 CALL RTACT                         % MORE IN QUE ?
073231                 A:=SSTA; GO TRLR                   % B= CONTR DF, RETURN
073233              FI
073233           OD
073234           GO STUPR
073235   RBUS
073246   *"
"073246
073246   % =========================================================================
073246   %                         B D M T R                               (M)
073246   %       MTRANS ROUTINE FOR ABSTRANS CALLS TO DOMINO DEVICES
073246   %       MONITOR LEVEL
073246   %       ENTRY: A-REG: POINTER TO PARAMETER LIST
073246   %              B-REG: POOL DATAFIELD
073246   %              T-REG: PIT NO FOR PARAMETER (T=0 => USE RTREF.ACTPRI)
073246   %              L-REG: RET ADDRESS OR 0 (0 => STARTED FROM ABSTR, RETURN TO STUPR)
073246
073246   SUBR BDMTR
073246    INTEGER TREG,AREG,LREG,BREG,QDF,PROW
073254   BDMTR:  A=:AREG; A:=B=:BREG
073257           T=:TREG:=L=:LREG; *IOF
073263           IF T=0 THEN
073265              X:=RTREF=:PROW; "QP100"=:B
073271              CALL GETFREE; GO FULL
073273           ELSE
073274               CALL ERRFATAL                         % SWAPPING ILLEGAL
073275           FI; *ION
073276           T=:B=:QDF; X:=PROW; CALL BRESERVE         % RESERVE QUE ELEMENT
073302           IF A<0 THEN CALL ERRFATAL FI
073304           T:=LREG=:"TRLREG"                         % RETURN ADDRESS ON MLEV
073306           0=:TYPCO; AREG
073310           IF T=0 THEN CALL GAPFU ELSE CALL GAPFD FI
073315   % ---------------------------------- START LEV 12
073315           *IOF
073316           BREG=:B;    *IRW LV12B DB                 % CONTROLLER
073321           QDF;        *IRW LV12B DX                 % PARAMETERS
073323           "STDRIV";   *IRW LV12B DP
073325           LV12;       *MST PID
073327           QDF=:B; X:=RTRES; CALL WDATA
073333           X.STATUS BONE 5NOABORT=:X.STATUS; *ION    % SET DELAYED ABORT
073337           IF X=RTREF GO RWAIT; GO MONEN
073343   FULL:   *ION
073344           GO WT
073345   RBUS
073361
073361   SUBR BDMFU
073361   %-------------------------------------------------------------------
073361   % MONITOR LEVEL ROUTINE, ACTIVATED AFTER DRIVER IS FINISHED     ( M )
073361   %
073361   % X= CONTR. DF
073361   %-------------------------------------------------------------------
073361   % CACHE IS NOT CLEARED ON FUNC  1 & 61  (DMA OUTPUT)
073361   %                               66      (DMA INPUT TO CACHE INHIBITED AREA)
073361   %---------------------------------------------------------------------------
073361    INTEGER PROW,CDF,SSTA
073364    INTEGER POINTER TRLR
073365   BDMFU:
073365           X=:B=:CDF                                % B= CONTR. DF
073367           DO
073367              X:=B; * AAX DIBRE
073371           WHILE X.S0 >< -1                         % MORE IN QUE ?
073375              *IOF
073376              CALL GETOUT; T=:B;  *ION              % B= QUE ELEMENT
073401              IF X:=RTRES=:PROW><0 THEN
073404                 0=:TYPRING                         % DUE TO DOUBLE USE (BREGQ)
073405                 CALL RDATA; CALL BRELEASE          % RELEASE QUE ELEM
073407              FI
073407              "TRLREG"=:"TRLR"; SSSTAT=:SSTA
073413              IF ABFUN/\77><1 AND ><61 AND ><66 THEN
073426                 *TRR CCLR  % CLEAR CACHE
073427              ELSE
073430   *CCM14,       TRR CCLR   % CLEAR CACHE ON NOT RASK
073431              FI
073431              T:=B; "QP100"=:B; *IOF                % T= QUE ELEM
073435              CALL PUTFREE;     *ION                % TOO FREE POOL
073437              X:=T; CDF=:B                          % X= QUE ELEM, B= CONTR DF
073442              IF "TRLR"=0 THEN                      % FROM ABSTR
073444                 IF PROW><0 THEN                    % PROG ABORTED ?
073446                    A:=SSTA
073447                    IF X:=PROW=CURPROG THEN
073453                        *IRW ALEVB DA
073454                    ELSE
073455                       X:=X.RTDLGADDR
073456                       T:=0; *AAX DAREG; STATX
073461                    FI
073461                 FI
073461              ELSE                                  % FROM CALL MTRANS
073462                 CALL ERRFATAL
073463              FI
073463           OD
073464           GO STUPR
073465   RBUS
073476
073476   %============================================================================
073476   %                M B U I L D                                          (M)
073476   % BUILD A READ/WRITE AREA MESSAGE
073476   % MUST BE CALLED WITH INTERRUPT OFF
073476   % ENTRY:       B-REG: QUEUE DATAFIELD
073476   %              X-REG: POOL DATAFIELD
073476   % RETURN:      A-REG: ERROR CODE (ILLEGAL MEMORY ADDRESS)
073476   % SKIP RETURN: X-REG: DOMINO DATAFIELD
073476   SUBR MBUILD
073476   INTEGER SAVX
073477   INTEGER POINTER SAVL
073500   MBUILD: A:=L=:"SAVL"; X=:SAVX
073503           AD:=MEMAD; CALL DCNVA; GO ERET
073506           X:="DOMDF"; AD=:X.DMYAD          % CONVERT TO DOMINO MEMORY ADDRESS
073510           AD:=ABPA2=:X.DSTBL                     % MEDIA ADDRESS
073512           A:=ABP31; A=:D; A:=0; AD=:X.DNRPG      % NUMBER OF PAGES
073516           A:=-1=:D; AD=:X.DSSTS                  % -1 INTO STATUS
073521           0=:X.DSQC1=:X.DSQC2                    % 0 INTO SEQUENCE COUNTER
073523           T:=SAVX; T=:X.DSCA1; B:=:T             % SAVE ADDRESS OF POOL DF
073526           DIPOO=:X.DXPOO; OPAIX=:X.OPAIN         % POOL AND AREA INDEX
073532           T=:B; T=:X.DSOW2                       % OWNER OF MESSAGE
073534           1=:X.DSOW1; MIN "SAVL"                 % MARK ABSTRANS MESSAGE
073537           GO SAVL
073540   ERET:   A:=-3; GO SAVL
073542   RBUS
073544
073544   % =========================================================================
073544   %                     D C N V A                                      (M)
073544   %       CONVERT FROM ND100 TO DOMINO ADDRESS
073544   %       MUST BE CALLED WITH INTERRUPT OFF
073544   %       ENTRY:         AD-REG: ND-100 ADDRESS
073544   %       RETURN:        ILLEGAL MEMORY ADDRESS
073544   %       SKIP RETURN:   AD-REG: DOMINO MEMORY ADDRESS WITH BIT 31 SET
073544   %
073544   SUBR DCNVA
073544   INTEGER 5BIA1:=-1         % ND-100 ADDRESS OF ND-500'S FIRST PAGE
073545   INTEGER 5BIA2:=-1
073546   DOUBLE  5BIAS=5BIA1
073546   DOUBLE  1ADDR             % INPUT PARAMETER
073550   DCNVA:  AD=:1ADDR         % IS MODIFIED IN FIRST CALL TO THIS ROUTINE
073551           X:="N500D"; A:=X.ADRZERO=:D:=0
073555           AD SHZ 12; AD=:5BIAS; A:=124012; *STA DCNVA
073561           AD:=1ADDR
073562           A:=:D; A-5BIA2; A:=:D; A:=A+C-1-5BIA1 % SUBTRACT BIAS
073570           IF A BIT 17 THEN
073572              EXIT           % OUTSIDE MULTIPORT MEMORY
073573           FI
073573           AD SHZ 1          % MAKE BYTE ADDRESS
073574           A BONE 17         % SET BIT 31
073575           EXITA
073576   RBUS
073600
073600
073600   SUBR SSBDI
073600   %---------------------------------------------------------
073600   %  LEV 12 ROUTINE, ACTIVATED FROM MONITOR LEVEL
073600   %  ON MULTI THREAD DMA DEVICES
073600   %  B= CONTR DF. X= QUE DF.
073600   %---------------------------------------------------------
073600   SSBDI: CALL DODMA
073601          T:=X; X:=B; *AAX DIBRE
073604          CALL PUTIN; CALL RTACT
073606          GO WT12
073607   RBUS
073612
073612   SUBR BDTRANS,BD12T
073612    %-----------------------------------------------------------------------
073612    % LEVEL 12 ROUTINE TO START A BDIO TRANSFER
073612    %
073612    % ENTRY: B= DISK DF, X= QUE  DF
073612    %
073612    % EXIT :  BUSY (DO'NT TOUCH "DRIVER" IN DISK DF)
073612    % EXITA:  FINISH   SSSTAT IN QUE DF IS VALID
073612    %
073612    %-----------------------------------------------------------------------
073612   BDTRANS:
073612           A:=L=:X."TRLREG"
073614           "BD12T"=:X.NFUNC; *IOF
073617           CALL ST12L;       *ION
073621           A:=X."TRLREG"=:L; EXIT        % BUSY RETURN
073624   % ENTRY ON LEV 12, B= DISK DF, X= QUE DF
073624   BD12T:  T:=5; CALL DODMA
073626           A:=X."TRLREG"=:L; EXITA       % FINISH RETURN
073631   RBUS
073633
073633
073633   SUBR STRBDIO,REBDIO
073633   %---------------------------------------------------------
073633   %  LEV 12 DODMA ROUTINE FOR BDIO
073633   %
073633   %  ENTRY:  B= POOL DATAFIELD  X= QUE DF  T= TYPE
073633   %---------------------------------------------------------
073633    INTEGER PDF               % POOL  DF
073634    INTEGER QUDF              % QUE ELEM  DF
073635
073635   ERET:   A=:SSECN                               % SAVE NUCLEUS ERROR CODE
073636           X:=PDF; A=:X.DSTSD
073640           IF X.RSFLA=1 AND X.TMR=0 THEN          % POOL DF RESERVED AND NOT PUT INTO TIMER QUEUE
073646              X.TTMR=:X.TMR; "BDTMU"=:X."TMSUB"   % LET TIMRT TRY RECONNECT
073652           FI
073652           X.PLDNO=:PDVNO; A:=1661=:SINEC
073656           X:=RTRES; CALL 9FLEX(SINEC,4)
073662           A:=-2                                  % NUCLEUS ERROR
073663   RETU:   A=:QUDF.HSTAT; PDF=:B
073667           X.NFUNC=:L; EXIT                       % IMMEDIATE RETURN
073672
073672   STRBDIO:
073672           A:=B=:PDF; X=:QUDF; A:=L=:X.NFUNC
073677           T=:X.TYPCO
073700           X:=:B                               % B= QUE DF, X= POOL DF
073701           IF ABFUN=24 THEN A:=X.DSTSD; GO RETU; FI
073707           IF A=42 THEN                        % READ CAPACITY
073712              AD:=MEMAD; A=:T; D=:X; A:=42; *STATX
073717              X=:L; AD:=PDF.ARESZ; L=:X; *STDTX 10
073724   OKRET:     A:=0; GO RETU
073726           FI
073726           IF A=60 OR A=61 OR A=63 OR A=66 THEN    % READ/WRITE/COMPARE
073742              *IOF                             % IOF BEFORE GLOBAL DATAFIELD IS USED
073743              X:=PDF; CALL MBUILD; GO RETU     % BUILD MESSAGE
073746              IF ABFUN=61 THEN                 % WRITE
073752                 A:=167; T:=70                 % BDIO FUNCTION, MESSAGE SIZE
073754              ELSE
073755                 IF A=63 THEN
073760                    A:=213; T:=70              % COMPARE
073762                 ELSE
073763                    A:=166; T:=74              % READ
073765                 FI
073765              FI
073765              A=:X.DSCMD;
073766           ELSE
073767              A:=-1; GO RETU                   % ILLEGAL FUNCTION
073771           FI
073771           X=:D                                % B=QUEUE DF, X=DOMINO DF
073772           X:="CLUSTER"; *1BANK; LDA ,X; AAA 14
073776           X:="BBASE"; AD=:X.OWN; *2BANK       % SET OWNER
074001           T=:D; T:=DMSID; A:="DSVER+DOMDF"; X:=0; CALL NKWRI
074006           IF A><0 GO ERET
074007           A:=PDF.DRPRT=:D; X:="DOMDF";
074013           A:=X.DLPRT; X:=DMSID; CALL NKSEN; *ION
074017           IF A><0 GO ERET
074020           "DOMDF"=:B; "REBDIO"=:NFUNC
074024           CALL WT12; GO REBDIO; *)FILL
074046   % MESSAGE(S) ARRIVED
074046   REBDIO: X=:B
074047           DO
074047              *IOF
074050              X:="CLUSTER"; 0 BZERO "0"; *LDA ,X; AAA 14
074054              B=:D; X:="BBASE"; AD=:X.OWN      % SET OWNER
074057              0 BONE "0";
074060              T:=DLPRT; CALL NKREC
074062           WHILE X><0
074063              A=:SSECN                      % SAVE NUCLEUS STATUS
074064              X=:T; X:=0; 76=:D; A:="DSVER"+B
074072              CALL NKREA; *ION
074074              IF A=0 THEN
074075                X:=DSOW2                    % GET QUEUE DF OF WAITING PROCESS
074076                AD:=DSSTS
074077                IF A=0 AND D=0 THEN
074102                   AD:=DSQCN; T:=-1; X:=DSCA1
074105                   IF A=T AND D=T THEN      % TRANSFER OK BUT CHANGED TO MIRROR POOL
074111                      AD:=DXPOO             % X=ADDRESS OF POOL DATAFIELD
074112                      IF A=X.DIPO1 AND D=X.DIPO2 THEN
074120                         IF X.RSFLA=1 AND X.TMR=0 THEN  % NOT PUT INTO TIMER
074126                            X.TTMR=:X.TMR
074130                            "BDTMV"=:X."TMSUB"          % LET TIMRT TRY RECONNECT
074132                   FI;FI;FI
074132                   A:=0
074133                   0=:X.DSTSD; X:=DSOW2
074135                   A=:X.HSTAT               % EVERYTHING IS OK
074136                ELSE
074137                   T:=-1; X:=DSCA1
074141                   IF A=T AND D=T AND SSECN><0 THEN     % MESSAGE REJECTED
074147                      A=:X.DSTSD
074150                      X.PLDNO=:PDVNO; 1661=:SINEC
074154                      X:=DSOW2; X:=X.RTRES
074156                      CALL 9FLEX(SINEC,4);
074161                      A:=-2
074162                   ELSE
074163                      A:=D=:X.DSTSD=:SSECN     % SAVE STATUS
074166                      IF A><104031 AND A><104651 AND A><104622 THEN
074177                         X.PLDNO=:PDVNO; A:=1662=:SINEC
074203                         IF X.RSFLA=1 AND X.TMR=0 THEN  % NOT PUT INTO TIMER
074211                            X.TTMR=:X.TMR
074213                            "BDTMU"=:X."TMSUB"          % LET TIMRT TRY RECONNECT
074215                         FI
074215                         X:=DSOW2; X:=X.RTRES  % GET RT-ADDRESS OF CALLER
074217                         CALL 9FLEX(SINEC,4)   % WRITE ERROR MESSAGE TO INTERNAL DEVICE
074222                         A:=-4
074223                      ELSE
074224                         A:=-5                 % BLANK CHECK OR READ ONLY
074225                   FI;FI
074225                   X:=DSOW2
074226                   A=:X.HSTAT                  % BDIO ERROR
074227                FI
074227                "DOMDF"; A:=:X
074231                X:=X.DSCA1=:B;   *IOF
074234                X:=A; CALL TO12Q;*ION       % Q U E D F TIL LV12 QUE
074237                "DOMDF"=:B;
074241              FI
074241           OD
074242           GO WT12
074243   RBUS
074266
074266
074266   @DEV 1
074266   @DEV (S-S-L)MP-P2-TAD:NPL
074266   %%%%%%%%%%%%%%%%%%%%%%%  CX-TAD-MPIT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
074266   *"BADAD
"074266   %========================================================================
074266   %      T A D   D R I V E R
074266   %========================================================================
074266   %      G L O B A L   D A T A   F O R   T A D - D R I V E R  (D P I T)
074266   %=======================================================================
074266   %      I T A D     --- TAD INPUT  DATAFIELD ADDRESS FOR DRIVER
074266   %      O T A D     --- TAD OUTPUT DATAFIELD ADDRESS FOR DRIVER
074266   INTEGER ITAD=?,OTAD=?
074266
074266   %=======================================================================
074266   %      M E S S A G E   H E A D E R S
074266
074266   TRIPLE  DMMES=?              % DUMMY MESSAGE
074266   TRIPLE  RFIMS=?              % RFI MESSAGE
074266   TRIPLE  ERESP=?              % ESCAPE RESPONSE BUFFER
074266   TRIPLE  EDRSP=?              % ESCAPE RESPONSE ESCAPE DISABLED BUFFER
074266   INTEGER RSOFPM=?             % TMODE WITH RESET S.O.F.PAGE
074266   INTEGER HIGHT=?              % SAVE TYPE OF HIGH PRIORITY MESSAGE
074266   INTEGER RDATR=?              % DATA IN RESPONSE MESSAGE
074266
074266   %==============================================================================
074266   %       R O U T I N E S   D U P L I C A T E D   F R O M   R P I T
074266   %==============================================================================
074266   %
074266   % (M)   M P U T P O O L            (DUPLICATE OF PUTPOOL RPIT)
074266   %
074266   % ROUTINE TO PUT A BUFFER IN FREE POOL OF OUTPUT DATAFIELD
074266   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
074266   % ENTRY:    AD-REG - BUFFER-ADDRESS
074266   %            X-REG - BUFFER ID
074266   %            B-REG - TAD OUTPUT DATAFIELD
074266   SUBR MPUTPOOL
074266   INTEGER XREG
074267   MPUTPOOL: *IOF
074270          IF X=0 GO RETU; X=:XREG                   % DUMMY CALL
074272          A=:T; D=:X; AD:=POOLLI; *STDTX            % PUT OLD POOLLI IN NEW BUFFER
074276          X+2; A:=XREG; *STATX                      % PUT BUFFID IN NEW BUFFER
074301          T=:A; X-2=:D; AD=:POOLLI                  % PUT NEW BUFFER IN POOLLI
074305   RETU:  *ION; EXIT
074307   RBUS
074307
074307   %=========================================================================
074307   % (M)   M G E T P O O L            (DUPLICATE OF GETPOOL RPIT)
074307   %
074307   % ROUTINE TO GET A BUFFER FROM FREE-POOL
074307   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
074307   % ENTRY:       B-REG - TAD OUTPUT DATAFIELD
074307   % SKIP RETURN: OK
074307   %              FOLLOWING VARIABLES IN OUTPUT DATAFIELD IS MODIFIED:
074307   %              BUFFID
074307   %              TDTADD
074307   %              TDBTPT
074307   %              REMSIZ
074307   %
074307   % RETURN:      ERROR   A-REG < 0 XMSG ERROR , ELSE POOL EMPTY
074307
074307   SUBR MGETPOOL
074307   MGETPOOL: *IOF
074310          POOLLI; IF A=0 AND D=0 GO NOPOL           % POOL EMPTY
074314          A=:T; D=:X; *LDDTX                        % GET NEXT IN CHAIN
074317          AD=:POOLLI                                % UPDATE POOL POINTER
074320          T=:A; X=:D; *STZTX                        % ENSURE REF&FUNC IS ZERO
074323          AD=:TDTADD; X+2; *LDATX                   % SAVE ADDRESS AND GET BUFFID
074326          A=:BUFFID; BUDIS=:TDBTPT                  % SET BUFFID AND BYTE POINTER
074331          ITAD.FBSIZ-BUDIS=:REMSIZ                  % SET REMAINING SIZE
074335          *ION; EXIT AD1
074337   NOPOL: AD=:TDTADD; 0=:BUFFID=:REMSIZ=:TDBTPT; *ION; EXIT
074345   RBUS
074346
074346   %==============================================================================
074346   % (M)   M M O V I T O              (DUPLICATE OF MOVITO RPIT)
074346   %
074346   % ROUTINE TO RELOCATE INPUT BUFFER AS OUTPUT BUFFER
074346   % ENTRY:       B-REG - OUTPUT-DATAFIELD
074346   SUBR MMOVITO
074346   MMOVITO: ITAD.BUFFID=:BUFFID; X.TDTADD=:TDTADD
074353           X.FBSIZ-BUDIS=:REMSIZ; BUDIS=:TDBTPT; 0=:CURMES
074361           A:=0=:D; AD=:X.TDTADD
074364           0=:X.BUFFID=:X.REMBYT=:X.TDBTPT=:X.REMSIZ=:X.CURMES
074371           EXIT
074372   RBUS
074373
074373   %==============================================================================
074373   % (M)   M S T O R B Y T            (DUPLICATE OF STORBYT RPIT)
074373   %
074373   % ROUTINE TO STORE A BYTE IN THE XMSG BUFFER ACCORDING TO TDBTPT
074373   % TDBTPT AND REMSIZ IS UPDATED
074373   % ENTRY:     B-REG  - TAD-DATAFIELD  INPUT OR OUTPUT
074373   %            A-REG  - BYTE
074373   % RETURN:    NO REGISTERS MODIFIED
074373   SUBR MSTORBYT
074373   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
074377   MSTORBYT: *IOF
074400          TAD=:TADREG; X=:XREG
074402          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
074410          IF D BIT "0" THEN
074412             *LDATX
074413             A/\177400=:T; AREG/\377\/T; T:=TDTAFI; *STATX
074422          ELSE
074423             AREG SHZ 10; *STATX
074426          FI
074426          MIN TDBTPT; REMSIZ-1=:REMSIZ
074432          TAD:=TADREG; X:=XREG; *ION; EXIT
074436   RBUS
074440
074440   %==============================================================================
074440   % (M)   M G E T M E S              (DUPLICATE OF GETMES RPIT)
074440   %
074440   % ROUTINE TO FIND NEXT MESSAGE HEADER IN XMSG BUFFER  (TAD INPUT)
074440   % ENTRY:     B-REG - TAD INPUT DATAFIELD
074440   %
074440   % RETURN:    SKIP-RETURN:  OK     A-REG:  MESSAGE-TYPE
074440   %                                 T-REG:  NUMBER OF BYTES IN I-FIELD
074440   %                                 TAD DATAFIELD BUFFER VARIABLES
074440   %                                 REMSIZ,TDBTPT,CURMES,REMBYT ARE UPDATED
074440   %
074440   %            NOSKIP:       ERROR  A-REG:  1  NO INPUT BUFFER
074440   %                                 A-REG:  2  BUFFER IS EMPTY
074440   %                                 A-REG:  3  INCONSISTENCY, MESSAGE BIGGER THAN BUFFER
074440   SUBR MGETMES
074440   MGETMES: IF BUFFID=0 THEN A:=1; EXIT FI                     % NO BUFFER
074444   TSTSP:  IF REMSIZ<2 THEN T=:A; EXIT FI
074452           T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1
074457           X+A; *LDATX
074461           MIN TDBTPT
074462           IF D BIT "0" THEN                                  % ODD BYTE
074464              IF A/\377=0 THEN REMSIZ-1=:REMSIZ; GO TSTSP FI  % FIRST BYTE FOUND
074472              A=:CURMES; X+1; *LDATX
074475              A SHZ -10; MIN TDBTPT; GO RCHK                  % RETURN AND CHECK
074500           FI
074500           A=:T SHZ -10
074502           IF A=0 THEN
074503              REMSIZ-1=:REMSIZ; GO TSTSP                      % PAD BYTE
074507           FI
074507           A=:CURMES:=T/\377; MIN TDBTPT
074513   RCHK:   IF A>REMSIZ-2 THEN A:=3; EXIT FI                   % INCONSISTENT MESSAGE
074521           A=:T+1-=:REMBYT; X:=REMSIZ-2=:REMSIZ
074530           A:=CURMES; EXITA                                   % MESSAGE FOUND
074532   RBUS
074533

074533   %==============================================================================
074533   %       R O U T I N E S   T O   U P D A T E   D A T A F I E L D
074533   %==============================================================================
074533   %
074533   % (M)   B D T M O D
074533   %
074533   % ROUTINE TO SET TERMINAL MODE ON A TAD
074533   % ENTRY:       B = INPUT-DATAFIELD
074533   % SKIP-RETURN: OK
074533
074533   SUBR BDTMOD
074533   BDTMOD: TDBTPT=:D SHZ -1; T:=TDTAFI; X:=TDTALA+A; *LDATX
074542          IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI; A=:D
074550          REMSIZ-1=:REMSIZ; MIN TDBTPT; 0=:REMBYT
074555
074555   % CAPITAL LETTERS?
074555          T:=DFLAG BZERO 5CAPITAL
074557          IF D BIT "0" THEN T BONE 5CAPITAL FI; T=:DFLAG
074563
074563   % CR DELAY?
074563          T:=TINFO BZERO 5CRDLY=:TINFO
074566          IF D BIT 1 THEN
074570             T BONE 5CRDLY=:TINFO
074572          FI
074572
074572   % STOP ON FULL PAGE?
074572          0=:OTAD.SCREEN
074574          IF D BIT 2 THEN MIN X.SCREEN FI
074577
074577   % LOGGOUT ON MISSING CARRIER
074577          T:=FLAGB BZERO 5LBLOG
074601          IF D BIT 3 THEN T BONE 5LBLOG FI
074604          T=:FLAGB
074605
074605   RETU:  EXITA
074606   RBUS
074610
074610   %==============================================================================
074610   % (M)   B D T T Y P
074610   %
074610   % ROUTINE TO SET TERMINAL TYPE ON A TAD
074610   % ENTRY:         B = INPUT-DATAFIELD
074610   % SKIP-RETURN:   OK
074610   SUBR BDTTYP
074610   BDTTYP: TDBTPT=:D SHZ -1; T:=TDTAFI; X:=TDTALA+A; *LDATX
074617          IF D BIT "0" THEN
074621             A SHZ 10=:D; X+1; *LDATX
074625             A SHZ -10+D
074627          FI
074627          A=:CTTYP; TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ; 0=:REMBYT
074637   RETU:  EXITA
074640   RBUS
074640
074640   %==============================================================================
074640   % (M)   B D 8 M O D
074640   %
074640   % ROUTINE TO SET 8BITS UMOD ALLOWED ON A TAD
074640   % ENTRY:         B = INPUT-DATAFIELD
074640   % SKIP-RETURN:   OK
074640   SUBR BD8MOD
074640   BD8MOD: TDBTPT; AD SHZ -1; T:=TDTAFI; X:=TDTALA+A
074645           IF D BIT 17 THEN
074647              *LDDTX
074650              AD SH 10
074651           ELSE
074652              *LDATX
074653           FI
074653           IF A=1 THEN TINFO BONE 58BIT=:TINFO FI
074661           TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ; 0=:REMBYT
074670           EXITA
074671   RBUS
074671
074671   %==============================================================================
074671   % (M)   B D O P S V
074671   %
074671   % ROUTINE TO SET OPSYS VERSION AND TAD PROTOCOL NO OF PARTNER.
074671   % ENTRY:         B = INPUT-DATAFIELD
074671   % SKIP-RETURN:   OK
074671   SUBR BDOPSV
074671   BDOPSV: TDBTPT=:D SHZ -1; T:=TDTAFI; X:=TDTALA+A; *LDATX
074700          IF D BIT "0" THEN
074702             A SHZ 10=:D; X+1; *LDATX
074706             A/\377+D
074710          ELSE
074711             A/\177400=:D; X+1; *LDATX
074715             A SHZ -10+D
074717          FI
074717          A=:OSVTPN; TDBTPT+3=:TDBTPT; REMSIZ-3=:REMSIZ; 0=:REMBYT
074727   RETU:  EXITA
074730   RBUS
074732
074732   %==============================================================================
074732   % (M)   B D D E S C
074732   %
074732   % ROUTINE TO SET ESCAPE CHARACTER ON A TAD
074732   % ENTRY:        B = INPUT-DATAFIELD
074732   % SKIP-RETURN:  OK
074732   SUBR BDDESC
074732   BDDESC: TDBTPT=:D SHZ -1; T:=TDTAFI; X:=TDTALA+A; *LDATX
074741          IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI; A=:T
074747          CESCP/\177400+T=:CESCP
074753          MIN TDBTPT; REMSIZ-1=:REMSIZ; 0=:REMBYT
074760   RETU:  EXITA
074761   RBUS
074763
074763   %==============================================================================
074763   % (M)   B D D U M M
074763   %
074763   % ROUTINE TO BYPASS DUMMY MESSAGES
074763   % ENTRY:        B = INPUT-DATAFIELD
074763   % SKIP-RETURN:  OK
074763   SUBR BDDUMM
074763   BDDUMM: T:=REMBYT-; T-1; TDBTPT+T=:TDBTPT; REMSIZ-T=:REMSIZ
074774           0=:REMBYT
074775           EXITA
074776   RBUS
074776

074776   %==============================================================================
074776   %       X M S G   I N T E R F A C E   R O U T I N E S
074776   %==============================================================================
074776   %
074776   % (M)   M X M S G
074776   %
074776   % ROUTINE TO PERFORM XMSG MONITOR CALL, B = INPUT-DATAFIELD
074776   % SKIP RETURN: OK,    RETURN: XMSG ERROR
074776   % NOTE! WHEN MON 2XMSG IS DONE IN VSX B-REG MUST CONTAIN RESIDENT DATAFIELD
074776
074776   SUBR MXMSG
074776   INTEGER XREG
074777   TRIPLE  TADREG
075002   MXMSG: A:=:L=:"MXMRET"; A:=L; X=:L:=TDRADDR=:B
075010          X:=OTAD=:SOTAD:=BXTADD; X:=:L; *MON 2XMSG
075015          CALL WT10; X:=:L=:BXTADD:=SOTAD=:OTAD:=L
075023          X=:XREG; TAD=:TADREG; CALL SET10WINDOW
075026          A:=B=:ITAD; X:=XREG; TAD:=TADREG
075032          IF T>=0 THEN MIN "MXMRET" FI
075035          GO MXMRET
075036   RBUS
075042
075042   %==============================================================================
075042   % (M)   D R X A C C
075042   %
075042   % SUBROUTINE TO PERFORM DIRECT ACCESS TO XMSG BUFFERS
075042   % NOTE! THE ROUTINE TURNS THE INTERRUPT OFF AND RETURNS IN IOF
075042   SUBR DRXACC
075042   INTEGER POINTER LREG
075043   INTEGER FUNC=?
075043   DRXACC: IF X=0 THEN A:=XEIBP; EXITA; FI          % INCORRECT BUFFID
075047           X:=:L; A=:D; *1BANK; LDA ,X 0; 2BANK; IOF
075055           A=:FUNC; X=:"LREG"; L=:X; D=:A
075061           CALL DRXMSG; INTEGER FUNC
075063           GO RETU; MIN "LREG"
075065   RETU:   MIN "LREG"; GO LREG
075067   RBUS
075070
075070

075070   %==============================================================================
075070   %       T A D   D R I V E R
075070   %==============================================================================
075070   % THE DRIVER HAS TEN EXTERNAL ENTRY POINTS.
075070   %      INIBDR:     INITIAL START, CALLED FROM TADADM IN CONNECTION-
075070   %                  PHASE
075070   %      INISND:     INITIAL SEND, CALLED FROM TADADM TO SEND START-
075070   %                  BUFFER
075070   %      BDRINP:     INPUT-DRIVER, ACTIVATED FIRST TIME FROM INIBDR
075070   %                  ELSE ACTIVATED BY XMSG WHEN RECEIVING A BUFFER.
075070   %      BERESP:     ROUTINE TO SEND ESCAPE-RESPONSE, CALLED FROM
075070   %                  ESCAPE HANDLING.
075070   %      STOTAD:     ROUTINE TO STOP A TAD, THE PORT IS DISCONNECTED
075070   %                  IF OPEN.
075070   %      BDDSCN:     ROUTINE TO DISCONNECT A TAD WITHOUT LOGGING OUT.
075070   %      BDROUT:     OUTPUT-DRIVER, ACTIVATED FROM OUTPUT CALLS.
075070   %      BMAIRES:    RESERVE MAIL BUFFER. ACTIVATED FROM TWMESS
075070   %                  IN MAIL-SYSTEM.
075070   %      MSNDBUF:    SEND MAIL BUFFER. ACTIVATED FROM MAIL TIMEOUT
075070   %                  ROUTINE.
075070   %      MRELBUF:    RELEASE MAIL BUFFER. ACTIVATED FROM MAIL TIMEOUT
075070   %                  ROUTINE IF PARTNER DOES NOT RETURN BUFFERS.
075070   %======================================================================
075070   %      M E S S A G E   I D E N T I F I C A T O R S
075070
075070   SYMBOL EBUFF=7DUMM\0         % DUMMY-MESSAGE 0 (EMPTY BUFFER
075070   SYMBOL BDESC=7ESCA\0         % ESCAPE-MESSAGE
075070   SYMBOL RLOCA=7RLOC\0         % REMOTE LOCAL (RUBOUT NORD-NET
075070   SYMBOL BDDIS=7DCON\0         % DISCONNECT-MESSAGE
075070   SYMBOL CESCR=7CERS\0         % CESC-RESP MESSAGE
075070   SYMBOL RESCF=7RECO\0         % RESET-CONF MESSAGE
075070   SYMBOL NWREM=7NWRE\0         % NOWAIT RESTART MESSAGE
075070   SYMBOL ISZRS=7ISRS\2         % ISIZE RESPONSE MESSAGE
075070   SYMBOL ERRSP=7ERRS\2         % ERROR-RESPONSE MESSAGE
075070   SYMBOL TREPS=7TREP\2         % TREPP STATUS MESSAGE
075070
075070   %======================================================================
075070   % (M)   S T A D I W I N D O W    S T A D O W I N D O W
075070   %
075070   % ROUTINES TO SET UP WINDOW TO TAD-DATAFIELDS AND TO SET ADDRESSES OF
075070   % DATAFIELD OUTSIDE RESIDENT IN ITAD,OTAD RESPECTIVELY.
075070   %
075070   % STADIWINDOW: B-REG RESIDENT INPUT  DATAFIELD
075070   % STADOWINDOW: B-REG RESIDENT OUTPUT DATAFIELD
075070   %
075070   % RETURN:      B-REG CORRESPONDING DATAFIELD OUTSIDE RESIDENT
075070   %              X-REG CORRESPONDING DFOPP     OUTSIDE RESIDENT
075070   %              ITAD,OTAD ARE UPDATED
075070   SUBR STADIWINDOW,STADOWINDOW
075070   INTEGER POINTER LREG
075071   STADOWINDOW: M:="0"; GO FELLS
075073   STADIWINDOW: M:=1
075074   FELLS: A:=L=:"LREG"; CALL SET10WINDOW            % B IS NOW DF. OUTS. RES.
075077          IF DFOPP=0 THEN CALL ERRFATAL FI          % TAD MUST ALWAYS BE TWO WAY
075102          X:=1777; X/\A; A:=B/\176000+X=:X
075110          IF M THEN X=:OTAD; A:=B=:ITAD; GO LREG FI
075116          X=:ITAD; A:=B=:OTAD; GO LREG
075122   RBUS
075130
075130   @ICR
075130   SUBR   INIBDR,INISND,BDRINP,TDRINP,BDROUT,
075130          BERESP,STOTAD,DSTOTA,BDLOUT,BDDSCN,
075130          TDDSCN,BDRWT,BMAIRES,MSNDBUF,
075130          MRELBUF,FAERR,FAERO;
075130   @CR;
075130
075130   %=======================================================================
075130   % (M)   I N I B D R
075130   %
075130   % INITIAL ENTRY, LEVEL 10:
075130   %
075130   %      PROGRAMMED FROM TADADM WITH B = TAD INPUT-DATAFIELD
075130   %      TO EXECUTE FOLLOWING TASKS:
075130   %            - OPEN A XMSG PORT.
075130   %            - RESERVE BUFFERS ACCORDING TO NOBUFF AND FBSIZ IN
075130   %              DATAFIELD, ARRANGE FREE-POOL.
075130   %            - UPDATE PORTNO IN DATAFIELD
075130   %            - RETURN TO TADADM
075130
075130   INIBDR: CALL STADIWINDOW                                   % SET WINDOW
075131           IF PORTNO=0 THEN                                   % NO PORT OPENED
075133             0=:TDRADDR.BXTADD; T:=XFOPN; CALL MXMSG; GO IERR % OPEN PORT
075140             A=:PORTNO                                        % SET PORTNO IN DATAFIELD
075141             IF XFOPN=T THEN T:=XENOT; GO IERR; FI            % SPECIAL TEST FOR XTBLOC
075146             A:=0=:D; AD=:OTAD.POOLLI                         % POOL EMPTY
075152             T:=XFALM; FBSIZ; X:=NOBUFF; CALL MXMSG; GO IERR  % ALLOCATE MESSAGE SPACE
075157             FOR X:=1 TO NOBUFF DO; X=:XRSA
075164                T:=XFGET; A:=FBSIZ; CALL MXMSG; GO IERR       % RESERVE BUFFERS
075170                T:=OTAD=:B; A=:X=:BUFFID                      % B = OUTPUT-DATAFIELD
075174                CALL DRXACC(XDINF); GO OERR; *ION
075200                X:=BUFFID; CALL MPUTPOOL; 0=:BUFFID; ITAD=:B  % PUT BUFFER IN FREEPOOL
075205             X:=XRSA; OD
075210          FI
075210          GO BDRWT; *)FILL                                    % LEAVE LEVEL
075220
075220   INISND: CALL STADIWINDOW                                   % SET WINDOW
075221          OTAD=:B; CALL MGETPOOL; GO OERR; BUFFID
075226          T:=ITAD=:B; T:=PORTNO=:D
075232          T:=XFSCM; CALL MXMSG; GO IERR                       % SET CURRENT
075235          TAD:=DMMES; T=:X:=XFWHD; CALL MXMSG; GO IERR
075242          AD:=OTAD.PARTNER; X:=PORTNO
075245          T:=XFSND; CALL MXMSG; GO IERR                       % SEND BUFFER
075250          T:=XFDBK; A:=DPITBANK; CALL MXMSG; GO IERR          % SET BANK NO FOR READ WRITE
075254          T:=XFWDF; A:="BDRINP"; CALL MXMSG; GO IERR          % SET "WAKE UP" MODE
075260          FLAGB BZERO 5LSTA=:FLAGB                            % SET LINE OK BIT
075263          -1=:OTAD.CURBRST=:X.CURECST                         % ENSURE ECHO/BREAK FIRST TIME
075267          0=:X.BUFFID; GO TDRINP                              % ENTER RECEIVE MODE
075271
075271   % ----- INITIALIZING ERRORS -----
075271   OERR:  *ION
075272          A=:T; ITAD=:B
075275   IERR:  T=:OTAD.DERROR                                      % SAVE ERROR
075277          GO FAERR
075300   *)FILL
075311
075311   %==========================================================================
075311   % (M)   B D R I N P
075311   %
075311   % TAD INPUT DRIVER.  B = TAD INPUT DATAFIELD
075311   %
075311   % BDRINP IS INITIALLY STARTED BY INIBDR
075311   % THE FUNCTION OF THIS DRIVER IS TO RECEIVE BUFFERS FROM XMSG AND TAKE
075311   % PROPER ACTION DEPENDING ON THE CONTENTS IN THE BUFFER
075311   % ACTTIONS MAY BE THE FOLLOWING:
075311   %      - EMPTY BUFFER, RETURN TO POOL
075311   %      - DATA-MESSAGE, RESPONSE-MESSAGE, WAKE USER
075311   %      - CONTROLL-MESSAGE, PROCEED ACCORDINGLY
075311   %
075311   % THE DRIVER IS RESTARTED BY XMSG WHEN A BUFFER IS QUEUED ON THE PORT.
075311   % THE STRATEGY FOR HANDLING MESSAGES DEPENDS ON WETHER THE MESSAGE IS
075311   % A HIGH PRIORITY MESSAGE OR NORMAL PRIORITY MESSAGE
075311   %      - NORMAL:  MESSAGE IS REMOVED FROM PORT QUEUE ONLY IF
075311   %                 CURRENT INPUT-BUFFER IS EMPTIED (BUFFID=0)
075311   %      - HIGH:    MESSAGE IS IMIDEATELY SERVED.
075311   %==========================================================================
075311
075311   BDRINP: CALL STADIWINDOW                                   % SET WINDOW
075312   TDRINP: *ION
075313           IF PORTNO=0 GO BDRWT; T:=XFPST BONE XFWAK
075320           CALL MXMSG; GO FAERR                               % READ PORT STATUS
075322           IF T=0 GO BDRWT                                    % NO BUFFER
075324           CALL CHPART; GO TDRINP                             % CHECK IF LEGAL PARTNER
075326           IF XMTHI><T GO FAR NORMP                           % NORMAL PRIORITY
075331           T:=XFRCV; A:=PORTNO; CALL MXMSG; GO FAERR          % RECEIVE
075335           IF T=0 GO BDRWT                                    % NO BUFFER
075337           X:=D=:TMPBUF
075341           T:=XFRHD; A:=TMPBUF; CALL MXMSG; GO FAERR          % READ SIX BYTES
075345
075345   % CHECK IF RESPONSE-MESSAGE OR EMPTY BUFFER
075345           X=:HIGHT                                           % SAVE MESSAGE TYPE
075346           IF X=EBUFF OR X=CESCR OR X=RESCF OR X=ISZRS OR X=ERRSP THEN
075365             IF X=ISZRS OR X=ERRSP THEN                       % MESSAGE WITH DATA
075373                X:=TMPBUF; T:=6; CALL DRXACC(XDGER); GO FAERR; *ION
075401                A SHZ 10=:RDATR
075403                X:=TMPBUF; T:=7; CALL DRXACC(XDGER); GO FAERR; *ION
075411                T:=RDATR+A=:RDATR                             % DATA IN RDATR
075414             FI
075414             IF DFLAG BIT 5WRQI THEN                          % RFI WAITING TO BE SENDT
075417                A BZERO 5WRQI=:DFLAG; GO FAR RETRFI
075422             FI
075422             IF OTAD.BUFFID=0 THEN                            % PUT BUFFER TO OUTPUT
075425                X:=TMPBUF; CALL CHSIZE; GO FAR CHRESO
075430                X:=TMPBUF; A:=-1; CALL DRXACC(XDSBP); GO FAERR; *ION
075436                X:=TMPBUF; A:=BUDIS; CALL DRXACC(XDSBP); GO FAERR; *ION
075444                AD=:OTAD.TDTADD; TMPBUF=:X.BUFFID
075450                BUDIS=:X.TDBTPT; FBSIZ-BUDIS=:X.REMSIZ; 0=:TMPBUF
075456                IF X.ON5MSG><0 THEN X.TDRADDR=:B; GO FAR BDROUT FI
075463                GO FAR CHRESO; *)FILL
075510             ELSE                                             % PUT BUFFER IN POOL
075511                X:=TMPBUF; CALL CHSIZE; GO FAR CHRESO
075514                X:=TMPBUF; T:=OTAD=:B; CALL MPUTPOOL
075520                ITAD=:B; 0=:TMPBUF; GO FAR CHRESO
075524             FI
075524           FI
075524           IF X=NWREM THEN                                    % NOWAIT RESTART
075527             T:=XFSND; AD:=OTAD.PARTNER; X:=PORTNO
075533             CALL MXMSG; GO FAERR                             % RETURN MESSAGE
075535             GO FAR DATRES                                    % RESTART USER
075536           FI
075536           IF X=TREPS THEN                                    % TREP STATUS
075541             X:=TMPBUF; T:=6; CALL DRXACC(XDGER); GO FAERR; *ION
075547             A SHZ 10=:RDATR
075551             X:=TMPBUF; T:=7; CALL DRXACC(XDGER); GO FAERR; *ION
075557             T:=RDATR+A=:RDATR                                % DATA IN RDATR
075562             T:=XFSND; AD:=OTAD.PARTNER; X:=PORTNO
075566             CALL MXMSG; GO FAERR
075570             T:=RDATR; A:=TINFO
075572             IF T BIT 2 THEN A BONE 5BFUL FI                  % BUFFER OVERRUN
075575             IF T BIT 3 THEN A BONE 5PAER FI                  % PARITY ERROR
075600             IF T BIT 4 THEN A BONE 5FRER FI                  % FRAMING ERROR
075603             A=:TINFO
075604             GO TDRINP
075605           FI
075605           GO FAR ESCDIS; *)FILL                              % ESCAPE OR DISCONNECT
075624
075624   % ----- NORMAL PRIORITY -----
075624   NORMP: IF BUFFID><0 GO BDRWT                               % INPUT-BUFFER NOT EMPTY
075627          DFLAG BZERO 5RQI=:DFLAG                             % ALLOW RFI IN NOWAIT
075632          T:=XFRCV; A:=PORTNO; CALL MXMSG; GO FAERR           % RECEIVE FUNCTION
075636          IF T=0 GO BDRWT
075640          X-BUDIS=:REMSIZ:=D=:BUFFID=:TMPBUF
075645          X:=BUFFID; CALL CHSIZE; GO WRSIZE; AD=:TDTADD; BUDIS=:TDBTPT
075653
075653   % ----- BUFFER RECEIVED -----
075653   NXMES: CALL MGETMES; GO ECHECK
075655          IF CURMES=7BDAT GO DATRES                 % DATA MESSAGE
075661          IF A=7TMOD THEN                           % TMODE-MESSAGE
075664             CALL BDTMOD; GO FAERR; GO NXMES
075667          FI
075667          IF A=7TTYP THEN                           % TTYPE-MESSAGE
075672             CALL BDTTYP; GO FAERR; GO NXMES
075675          FI
075675          IF A=78MOD THEN                           % 8BITS UMOD MESSAGE
075700             CALL BD8MOD; GO FAERR; GO NXMES
075703          FI
075703          IF A=7DESC THEN                           % DEF-ESC MESSAGE
075706             CALL BDDESC; GO FAERR; GO NXMES
075711          FI
075711          IF A=7DUMM THEN                           % DUMMY MESSAGE
075714             CALL BDDUMM; GO FAERR; GO NXMES
075717          FI
075717          IF A=7OPSV THEN
075722             CALL BDOPSV; GO FAERR; GO NXMES
075725          FI
075725   SRJE:  CALL REJECT; 0/\0; GO TDRINP              % MESSAGE REJECTED
075730   ECHECK: IF A=1 OR A=2 GO BEMTY                   % EMPTY
075736           IF A=3 GO SRJE                           % SEND REJECT
075741           GO FAERR                                 % XMSG ERROR
075742   *)FILL
075757
075757   WRSIZE: 0=:BUFFID=:CURMES=:REMSIZ; GO TDRINP
075763
075763   BEMTY: X:=BUFFID; 0=:BUFFID=:CURMES=:REMSIZ
075767          CALL CHSIZE; GO TDRINP
075771          T:=OTAD=:B; CALL MPUTPOOL; ITAD=:B
075776          GO TDRINP
075777
075777   DATRES: A:=OTAD.RSPNUM BZERO 17
076002           IF A><7CERS AND A><7RECO AND A><7ISRS THEN         % NOT AWAITING RESPONSE
076013             CALL TSTBACK
076014             IF TDRADDR.ISTATE<0 THEN; *IOF                   % NOWAIT IN USE
076020                CALL PNW5ST; GO TOTDRI; *ION                  % CHECK IF 500 PROCESS
076023             FI
076023             "IORESTART"; CALL CXRTACT                        % RESTART USER
076025           FI
076025   TOTDRI: GO TDRINP; *)FILL                                  % TDRINP DOES ION
076037
076037   RSPRST: 0=:OTAD.RSPNUM                                     % RESET RESPONSE WAIT
076041           CALL TSTBACK; "RSRESTART"; CALL CXRTACT             % RESTART AFTER RESPONSE
076044           GO TDRINP
076045
076045   CHRESO: A:=HIGHT; 0=:HIGHT
076047           IF A=CESCR THEN                                    % CESC-RESP
076052             IF OTAD.RSPNUM=7CERS GO RSPRST
076057             GO TDRINP
076060           FI
076060           IF A=RESCF THEN                                    % RESET-CONF
076063             IF OTAD.RSPNUM=7RECO GO RSPRST
076070             GO TDRINP
076071           FI
076071           IF A=ISZRS THEN
076074              OTAD.RSPNUM=:D; A BZERO 17
076100              IF A=X:=7ISRS THEN                              % WAITING FOR ISIZE-RESPONSE
076103                 A:=RDATR; IF D BIT 17 THEN A BONE 17 FI
076107                 A=:DFRDATR:="MFISIZ"; CALL CXRTACT
076112                 GO TDRINP
076113              FI
076113           FI
076113           IF A=ERRSP THEN
076116              IF OTAD.RSPNUM=7ERRS THEN
076123                 IF TDRADDR.RTRES.STATUS BIT 5WAIT THEN
076130                    RDATR=:DFRDATR; "MFERSP"; CALL CXRTACT
076134                    GO TDRINP
076135                 FI
076135              FI
076135           FI
076135           OTAD.RSPNUM BZERO 17
076140           IF A><7CERS AND A><7RECO AND A><7ISRS THEN         % NOT AWAITING RESPONSE
076151             IF TDRADDR.ISTATE=2 THEN                         % INPUT WAITING TO REDO MON CALL
076156                "IORESTART"; CALL CXRTACT                     % RESTART PROGRAM
076160             ELSE
076161                OTAD=:B; "IORESTART"; CALL CXRTACT            % RESTART OUTPUT
076165                ITAD=:B
076167             FI
076167           FI
076167           GO TDRINP
076170   *)FILL
076210
076210
076210   % ----- RFI MESSAGE SENT FROM DRIVER WHEN BUFFER ARRIVES AND 5WRQI IS SET.
076210   %       BUFFER WAS NOT AVAILABLE FOR NORMAL SENDING.
076210
076210   RETRFI: TAD:=RFIMS; T=:X:=XFWHD; CALL MXMSG; GO FAERR
076215           AD:=OTAD.PARTNER; X:=PORTNO
076220           T:=XFSND; CALL MXMSG; GO FAERR; GO FAR CHRESO
076224
076224   % ----- ESCAPE OR DISCONNECT, X = MESSAGE HEADER -----
076224
076224
076224   ESCDIS: IF X=BDESC OR X=RLOCA THEN                  % ESCAPE OR REMOTE-LOCAL MESSAGE
076232             IF DFLAG NBIT 5IESC THEN                  % ESCAPE ENABLED
076235                IF X=BDESC THEN
076240                   CESCP/\377=:LAST                    % ESCAPE
076243                ELSE
076244                   IF FLAGB BIT 5LCHAR THEN
076247                      CESCP SHZ-10=:LAST               % LOCAL CHARACTER
076252                   ELSE
076253                      177=:LAST                        % RUBOUT IN NORD-NET
076255                   FI
076255                FI
076255                DFLAG BZERO 5RQI=:DFLAG                % ALLOW RFI IN NOWAIT
076260                CALL ESCAPE; 0/\0
076262                TAD:=ERESP; T=:X:=XFWHD
076265                CALL MXMSG; GO FAERR                   % WRITE ESCAPE-RESPONCE
076267                TMPBUF=:ESCBUF; 0=:TMPBUF; GO TDRINP
076273             ELSE                                   % ESCAPE DISABLED
076274                TAD:=EDRSP; T=:X:=XFWHD
076277                CALL MXMSG; GO FAERR                   % WRITE ESCAPE DISABLED RESPONSE
076301                AD:=OTAD.PARTNER; X:=PORTNO
076304                T:=XFSND; CALL MXMSG; GO FAERR         % SEND RESPONSE
076307                0=:TMPBUF; GO TDRINP
076311             FI
076311          FI
076311          IF X=BDDIS THEN                           % DISCONNECT-MESSAGE
076314             GO DSTOTA                              % STOP AND DISCONNECT TAD
076315          FI
076315          A:=X SHZ -10=:CURMES; GO FAR SRJE         % ILLEGAL HIGH-PRIORITY
076321          GO TDRINP
076322   *)FILL
076341
076341   %=========================================================================
076341   % (M)   B E R E S P
076341   %
076341   % ESCAPE RESPONSE, ACTIVATED FROM ESCAPE HANDLING WITH B = INPUT DATAFIELD
076341
076341   BERESP: CALL STADIWINDOW                         % SET WINDOW
076342           IF ESCBUF><0 THEN
076344              PORTNO=:D; A:=ESCBUF; 0=:ESCBUF
076350              T:=XFSCM; CALL MXMSG; GO FAERR        % SET CURRENT
076353              T:=XFSND; AD:=OTAD.PARTNER; X:=PORTNO
076357              CALL MXMSG; GO FAERR                  % SEND RESPONCE
076361              IF OTAD.RSPNUM><0 THEN                % AWAITING RESPONSE ?
076364                 0=:X.RSPNUM
076365                 X.TDRADDR.RTRES.STATUS BZERO 5WAIT=:X.STATUS
076372              FI
076372           FI
076372           GO TDRINP
076373
076373   %=========================================================================
076373   % (M)   S T O T A D
076373   %
076373   % ROUTINE ACTIVATED TO STOP A TAD, B = INPUT DATAFIELD
076373   % IF BACKROUND: TLREP ENABLED:  5LSTA AND 5LOGOUT IS SET
076373   %               TLREP DISABLED: TAD IS LOGGED OUT
076373   % TAD RESERVED: 5LSTA IS SET
076373   % THE TADS PORT IS CLOSED IF OPEN
076373
076373   STOTAD: CALL STADIWINDOW                            % SET DATAFIELD WINDOW
076374   DSTOTA:
076374   *"BADAD -8BACS
"076374           IF X:=DBPROG><0 THEN
076376              IF TADTYP=377 THEN                       % SERVER TAD
076402                0=:TADTYP; CALL GTSLPINDX; GO NSLIS    % GET INDEX OF RT-PROG
076405                X=:T; A:=OTAD.SVOTS; 0=:X.SVOTS        % GET SAVED STATUS
076411                A=:L:=T*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK
076417                A:=L; *TSLST@3 STATX                   % SET SAVED TIMESLICE STATUS
076421   NSLIS:     FI
076421              IF DBPROG=TDRADDR.RTRES AND FLAGB NBIT 5LOGOUT THEN
076431                 IF FLAGB BIT 5TLREP THEN
076434                    A BONE 5LOGOUT=:FLAGB                  % PROGRAM IS RESPONSIBLE, LOGOUT AT MON 0
076436                    "IORESTART"; CALL CXRTACT              % RESTART PROGRAM
076440                 ELSE
076441                    CALL BDLOUT                            % LOGGOUT USER
076442                 FI
076442              FI
076442           FI
076442   *"BADAD
"076442           IF A:=DBPROG><0 THEN
076444               CALL GBPIU;GO L1
076446               T:=MBSPRTAB
076447               A*BPRTSIZE; X:=ASBPRTAB;X+A;*AAX BPUER
076453               A:=2; *STATX
076455           FI
076455
076455   L1:     GO TDDSCN                                   % DISCONNECT
076456
076456   %=========================================================================
076456   % (M)   B D L O U T
076456   %
076456   % SUBROUTINE TO LOG OUT A TAD
076456   % B = INPUT-DATAFIELD
076456
076456   BDLOUT: A:=L=:"DRIVER"
076460          IF DBPROG><0 AND A=TDRADDR.RTRES THEN                    % BACKGROUND AND LOGGED ON
076466             IF X.ISTATE><0 OR XDFOPP.ISTATE><0 OR OTAD.RSPNUM><0 THEN
076476                DBPROG.STATUS BZERO 5WAIT=:X.STATUS                % RESET IO-WAIT    % MARK IO-WAIT
076502             FI
076502             DFLAG BZERO 5IESC=:DFLAG                              % ENABLE ESCAPE
076505             FLAGB/\ESCMASK=:FLAGB                                 % RESET USER ESCAPE/LOCAL
076510             -1=:LAST; CALL ESCAPE; 0/\0                           % LOGOUT USER
076514          FI
076514          GO DRIVER
076515   *)FILL
076541
076541   %=========================================================================
076541   % (M)   B D D S C N
076541   %
076541   % ROUTINE TO DISCONNECT A TAD IF PORT IS OPEN, B = INPUT-DATAFIELD
076541   % RETURN IS DONE BY LEAVING DRIVER-LEVEL.
076541
076541   BDDSCN: CALL STADIWINDOW                            % SET DATAFIELD WINDOW
076542   TDDSCN: FLAGB BONE 5LSTA=:FLAGB                     % SET LINE DEAD BIT
076545           IF PORTNO><0 AND TDRADDR.BXTADD><0 THEN     % PORT IS OPEN
076552             IF TMPBUF><0 THEN
076554                0=:TMPBUF; T:=XFREL; CALL MXMSG; 0/\0  % RELEASE CURRENT BUFFER
076560             FI
076560             0=:PORTNO=:BUFFID=:OTAD.BUFFID=:X.MBFID   % CLEAR DAFAFIELD
076565             TDRADDR=:B; BXTADD=:L; 0=:BXTADD          % COLLECT AND ZERO XTBLOC, B= RES.DF.
076572             T:=XFDCT; *MON 2XMSG; RAND 0 0            % DISCONNECT
076575             GO BDRWT
076576          ELSE                                         % PORT IS CLOSED
076577             0=:PORTNO=:BUFFID=:OTAD.BUFFID=:X.MBFID   % CLEAR DATAFIELD
076604             0=:TDRADDR.BXTADD                         % ZERO XTBLOC ADDRESS
076606          FI
076606          GO BDRWT
076607   *)FILL
076613
076613   %=========================================================================
076613   % (M)   B M A I R E S
076613   %
076613   % ROUTINE TO RESERVE A MAIL BUFFER.
076613   % IF STOP ON FULL PAGE THEN THIS IS RESET BY A HIGH PRIORITY MESSAGE
076613   % TAD PROTOCOL >= 3 IS THEN IN USE.
076613   %
076613   %  B = TAD OUTPUT DATAFIELD
076613   INTEGER CRPROG                                            % RT-DES OF CALLING PROGRAM
076614   INTEGER MAIBF,RBFID
076616
076616   BMAIRES: CURPROG=:CRPROG; CALL STADOWINDOW                % SET WINDOW
076621          0=:MAIBF=:RBFID=:ITAD.BRCOUNT; X=:B                % ZERO BUF.IDS AND BUF. ROTATE COUNT
076626          T:=XFGET; A:=2000; CALL MXMSG; GO BDRWT            % GET A BUFFER OF 1K BYTES
076632          X:=OTAD=:B; A=:MAIBF
076635          IF SCREEN><0 THEN                                  % STOP ON FULL PAGE AND PROT. 3
076637             ITAD=:B; T:=XFGET; A:=10; CALL MXMSG; GO RBFER  % RESERVE SPECIAL BUFFER
076645             A=:RBFID; A:=10=:D:="RSOFPM"; X:=DPITBANK
076652             T:=XFWRI; CALL MXMSG; GO RBFER; T:=XFSCM        % WRITE RESET S.O.F.P MESSAGE
076656             PORTNO=:D:=RBFID; CALL MXMSG; GO RBFER          % SET CURRENT
076663             T:=XFSND BONE XFHIP; AD:=OTAD.PARTNER
076667             X:=PORTNO; CALL MXMSG; GO RBFER                 % SEND WITH HIGH PRIORITY
076672          FI
076672          X:=MAIBF; CALL DRXACC(XDINF); GO RBFER; *ION       % GET DATA ADDRESS
076677          *IRW ALEVB DA; COPY SD DA; IRW ALEVB DD            % WRITE DATA ADDRESS
076702          MAIBF; *IRW ALEVB DT                               % WRITE BUFFER ID
076704          *IRR ALEVB DL; AAA 1; IRW ALEVB DL                 % INCREMENT L-REG
076707          GO BDRWT
076710   RBFER: *ION
076711          IF RBFID><0 THEN T:=XFREL; CALL MXMSG; 0/\0 FI     % RELEASE SPEC. BUFF
076716          IF MAIBF><0 THEN T:=XFREL; CALL MXMSG; 0/\0 FI     % RELEASE MAIL  BUFF
076723          GO BDRWT; *)FILL
076735
076735   %=========================================================================
076735   % (M)   M S N D B U F
076735   %
076735   % ROUTINE TO SEND MAIL BUFFER, CALLED FROM MAIL TIMER
076735   % B = TAD OUTPUT DATAFIELD
076735
076735   MSNDBUF: CALL STADOWINDOW                                  % SET WINDOW
076736          IF ITAD.PORTNO=0 GO BDRWT                           % PORT HAS BEEN DISCONNECTED
076742          X:=MBFID; CALL DRXACC(XDINF); GO EROP; *ION         % GET DATA ADDRESS
076747          A=:T; D=:X; *LDATX; STZTX                           % GET BYTE POINTER AND ZERO REF& FUNC
076753          X:=MBFID; CALL DRXACC(XDSBP); GO EROP; *ION         % SET BYTE POINTER IN MESSAGE
076760          A:=MBFID; X:=ITAD=:B:=PORTNO=:D
076765          T:=XFSCM; CALL MXMSG; GO EROP                       % SET CURRENT
076770          AD:=OTAD.PARTNER; X:=PORTNO
076773          T:=XFSND; CALL MXMSG; GO EROP                       % SEND MAIL BUFFER
076776   EROP:  *ION
076777          0=:OTAD.MBFID; GO BDRWT                             % ZERO MAIL BUF ID. AND LEAVE
077002   *)FILL
077010
077010   %=========================================================================
077010   % (M)   M R E L B U F
077010   %
077010   % ROUTINE TO RELEASE MAIL BUFFER, CALLED FROM MAIL TIMER WHEN
077010   % PARTNER DOES NOT RETURN ANY BUFFERS. MAIL IS THEN IGNORED
077010   % B = TAD OUTPUT DATAFIELD
077010
077010   MRELBUF: CALL STADOWINDOW                                  % SET WINDOW
077011          IF ITAD.PORTNO=0 GO BDRWT                           % NOT CONNECTED ANYMORE
077015          A:=MBFID; 0=:MBFID; X=:B; T:=XFREL; CALL MXMSG;0/\0 % RELEASE
077023          GO BDRWT; *)FILL
077030

077030   %=========================================================================
077030   % (M)   B D R O U T
077030   %
077030   % TAD OUTPUT DRIVER ACTIVATED FROM STDEV WITH B = TAD OUTPUT-DATAFIELD
077030
077030   BDROUT: CALL STADOWINDOW                                   % SET WINDOW
077031          IF ITAD.PORTNO=0 GO BDRWT                           % DUMMY CALL
077035          IF BUFFID=0 GO OUT                                  % NO BUFFER
077037          IF TDBTPT=BUDIS THEN CALL BDCH500; GO OUT FI        % CHECK FOR 500 OUTPUT
077045   NXT:   CALL SETSIZE                                        % SET CORRECT SIZE
077046          ITAD=:B                                             % B = INPUT-DATAFIELD
077050          PORTNO=:D; A:=OTAD.BUFFID
077054          T:=XFSCM; CALL MXMSG; GO FAERR                      % SET CURRENT
077057          AD:=OTAD.PARTNER; X:=PORTNO
077062          T:=XFSND; CALL MXMSG; GO FAERR                      % SEND BUFFER
077065          OTAD=:B; 0=:CURMES; CALL MGETPOOL; GO OUT
077072          CALL BDCH500; GO OUT; GO NXT
077075   OUT:   ITAD=:B; GO TDRINP              % RETURN VIA INPUT-DRIVER
077100
077100   INTEGER ANT
077101   INTEGER POINTER LREG
077102   BDCH500:
077102   *"BADAD 8N500
"077102          IF X:=ON5MSG><0 THEN
077104             T:=L+1=:"LREG"
077106             T:=5MBBANK; *AAX NOBYT; LDATX                        % NO. OF BYTES IN BUFFER
077111             IF A>>REMSIZ-6 THEN A:=T FI; A=:ANT                  % ENOUGH SPACE IN BUFFER ?
077117             T:=7BDAT SHZ 10; A+T; T:=TDTAFI; X:=TDTALA+2; *STATX % MESSAGE HEADER
077126             A/\377+1 SH -1=:L                                    % L=NUMBER OF WORDS TO MOVE
077132             T:=5MBBANK; X:=ON5MSG; *AAX HBUFA; LDATX             % BANK NO. OF BUFFER
077136             *AAX 5HENT-HBUFA; LDXTX                              % ADDR. WITHIN BUFFER
077140             X=:D; T:=TDTALA+3; X:=TDTAFI; *MOVPP                 % MOVE DATA
077145             TDBTPT+ANT+2=:TDBTPT; REMSIZ-ANT-2=:REMSIZ           % UPDATE BUFFER POINTERS
077155             T:=5MBBANK; X:=ON5MSG; *AAX NOBYT; LDATX
077161             IF A-ANT>0 THEN
077164                *STATX                                            % UPDATE NOBYT
077165                A:=D; *AAX 5HENT-NOBYT; STATX                    % UPDATE 5HENT
077170             ELSE
077171                X:=ON5MSG; 0=:ON5MSG; *IOF
077174                CALL PT5RST; *ION
077176             FI
077176             GO LREG
077177          FI
077177   *"BADAD
"077177          EXIT
077200
077200   % ----- F A E R R   FATAL ERROR IN DRIVER
077200   FAERO: ITAD=:B
077202   FAERR: *ION
077203          GO DSTOTA
077204
077204   % ----- B D R W T    LEAVE DRIVER LEVEL
077204   BDRWT: *ION
077205          CALL WT10; *JMP *-1
077207   RBUS
077230
077230   %======================================================================
077230   % (M)   R S R E S T A R T
077230   %
077230   % ROUTINE TO RESTART USER AFTER RECEIVED RESPONSE. PROGRAM IS ALWAYS
077230   % IN IO-WAIT. ISTATE WAS NOT UPDATED WHEN PROGRAM WAS PUT IN WAITING
077230   % STATE.
077230   SUBR RSRESTART
077230   RSRESTART: X:=X.RTRES
077231          X.STATUS BZERO 5WAIT=:X.STATUS
077234          GO STUPR
077235   RBUS
077236
077236   %=======================================================================
077236   % (M)   S E T S I Z E
077236   %
077236   % ROUTINE TO SET CORRECT SIZE AND BYTE-POINTER BEFORE SEND
077236   %      ENTRY: B-REG - TAD OUTPUT-DATAFIELD
077236   SUBR SETSIZE
077236   SETSIZE: A:=L=:ITAD."DRIVER"
077241          A:=ITAD.FBSIZ-REMSIZ-BUDIS                          % FIND SIZE
077245          T:=TDTAFI; X:=TDTALA; *STZTX; AAX 1; STATX          % REF & FUNC AND MSG SIZE
077252          X:=BUFFID; A:=-1; CALL DRXACC(XDSBP); 0/\0; *ION    % REWIND BUFFER
077260          X:=BUFFID; TDBTPT; CALL DRXACC(XDSBP); 0/\0; *ION   % SET BYTE POINTER
077266          ITAD."DRIVER"=:P                                    % RETURN
077271   RBUS
077273
077273   %=======================================================================
077273   % (M)   C H P A R T
077273   %
077273   % ROUTINE TO CHECK IF BUFFER IS SENT FROM PARTNER
077273   % B = INPUT-DATAFIELD, A = SENDERS NUMBER FROM RECEIVE
077273   SUBR CHPART
077273   CHPART: X:=L=:"DRIVER"
077275           IF A=X:=OTAD.RPORT THEN                  % SENDER OK
077301              MIN "DRIVER"
077302           ELSE                                     % UNAUTORIZED SENDER
077303              T:=XFRCV; A:=PORTNO; CALL MXMSG; GO DRIVER      % RECEIVE BUFFER
077307              T:=XFREL; A:=D; CALL MXMSG; GO DRIVER           % RELEASE BUFFER
077313           FI
077313          GO DRIVER
077314   RBUS
077316
077316   %=====================================================================
077316   % (M)   C H S I Z E
077316   %
077316   % ROUTINE TO CHECK IF A BUFFER IS OF CORRECT SIZE, IF NOT THE
077316   % BUFFER IS RELEASED.
077316   % THE BUFFER ROTATE COUNT IS INCREMENTED FOR BUFFERS OF CORRECT SIZE
077316   % ENTRY:        X-REG - BUFFER ID
077316   %               B-REG - TAD INPUT DATAFIELD
077316   % SKIP RETURN:  BUFFER OK, AD-REG - BUFFER ADDRESS
077316   % EXIT:         WRONG SIZE, BUFFER IS RELEASED
077316   %
077316   SUBR CHSIZE
077316   INTEGER XREG
077317   CHSIZE: *IOF
077320          A:=L=:"DRIVER"; X=:XREG
077323          CALL DRXACC(XDINF); GO FAERR; *ION
077327          X:=XREG; T=:L
077331          IF L=FBSIZ THEN
077334             MIN "DRIVER"; MIN BRCOUNT; 0/\0                  % CORRECT SIZE
077337          ELSE
077340             T:=XFREL; A:=XREG                                % WRONG SIZE
077342             CALL MXMSG; GO DRIVER
077344          FI
077344          GO DRIVER
077345   RBUS
077350
077350   %====================================================================
077350   % (M)   R E J E C T
077350   %
077350   %  ROUTINE TO SEND REJECT MESSAGE. THE ROUTINE HAS THE SAME FUNCTION
077350   %  AS SNDREJ. REJECT IS ONLY CALLED FROM DRIVER.
077350   %      ENTRY:   B-REG  - INPUT DATAFIELD
077350   %               CURMES - REJECTED MESSAGE
077350   SUBR REJECT
077350   REJECT: A:=L=:"DRIVER"
077352          IF OTAD.BUFFID=0 THEN
077355             BUFFID; X:=OTAD=:B
077360             IF A><0 THEN
077361                CALL MMOVITO; GO GESND
077363             ELSE
077364                CALL MGETPOOL; GO NOPOL; GO GESND
077367             FI
077367          ELSE
077370             OTAD=:B; IF REMSIZ>=3 GO GESND
077376             CALL SETSIZE
077377             A:=BUFFID; X:=ITAD=:B; T:=XFSCM; CALL MXMSG; GO FAERR
077405             AD:=OTAD.PARTNER; X:=PORTNO; T:=XFSND; CALL MXMSG; GO FAERR; OTAD=:B
077415             CALL MGETPOOL; GO NOPOL
077417          FI
077417   GESND: A:=7REJE; CALL MSTORBYT; A:=1; CALL MSTORBYT
077423          ITAD.CURMES/\377; CALL MSTORBYT
077427          CALL SETSIZE
077430          A:=BUFFID; X:=ITAD=:B; T:=XFSCM; CALL MXMSG; GO FAERR
077436          AD:=OTAD.PARTNER; X:=PORTNO; T:=XFSND; CALL MXMSG; GO FAERR; GO DRIVER
077445   NOPOL: ITAD=:B; GO DRIVER
077450   RBUS
077462
077462   %====================================================================
077462   % (M)   M F I S I Z   M F E R S P
077462   %
077462   %  MONITOR LEVEL ROUTINES TO RETURN PARAMETERS FROM MON CALLS
077462   %  ENTRY:   X-REG  - INPUT DATAFIELD
077462   %
077462   SUBR MFISIZ,MFERSP
077462   MFISIZ: X=:B; T:="DFRDATR"; CALL XGTDFADDR; A=:D BZERO 17  % GET RDATR FROM DF
077467           IF X:=RTRES=CURPROG THEN
077473              *IRW ALEVB DA
077474              IF D NBIT 17 THEN
077476                 *IRW ALEVB DX
077477              FI
077477           ELSE
077500              X:=X.RTDLGADDR; T:=0; *DAREG@3 STATX            % UPDATE REGISTER BLOCK
077503              IF D NBIT 17 THEN
077505                 *DXREG@3 STATX
077506              FI
077506           FI
077506           GO FELL
077507
077507   MFERSP: X=:B; T:="DFRDATR"; CALL XGTDFADDR                 % GET RDATR FROM DF
077512           IF X:=RTRES=CURPROG THEN
077516              *IRW ALEVB DA
077517              IF A=0 THEN
077520                 *IRR ALEVB DP; RINC DA; IRW ALEVB DP         % GIVE SKIP RETURN
077523              FI
077523           ELSE
077524              X:=X.RTDLGADDR; T:=0; *DAREG@3 STATX            % UPDATE REGISTER BLOCK
077527              IF A=0 THEN
077530                 *DPREG@3 LDATX; RINC DA; DPREG@3 STATX       % GIVE SKIP RETURN
077533              FI
077533           FI
077533   FELL:   X:=B; A:=0; T:="DFRDATR"; CALL XSTDFADDR
077537           X+"9CXTI"; T:="RSPNUM"; CALL XSTDFADDR
077542           X:=B; GO RSRESTART
077544   RBUS
077552   *"
"077552   @DEV 1
077552   @DEV (S-S-L)MP-P2-PIOC-DRIV:NPL
077552   *"8PIOC
"077552   SUBR PDRIV
077552   %==========================================================================
077552   %           P D R I V
077552   %
077552   %            P I O C    D R I V E R                (PIT3  (VSE)   )
077552   %
077552   %==========================================================================
077552   %      DESCRIPTION OF N100-XMSG BOX
077552   DISP 0
077552     DOUBLE NXMSG               % NORMAL XMSG ACTIVATION QUEUE
077552     INTEGER  NXFNC             % STATUS, BIT 1 SET BY ND100 (XMSG FUNC DONE)
077552                                %       , BIT 3 SET BY PIOC (XMSG FUNC REQUESTED)
077552     DOUBLE NXPAR               % PARAMETER POINTER
077552     INTEGER  NXXTB             % XT BLOCK (GIVEN BY N100 XMSG)
077552     INTEGER NXLB               % SAVE LAST LOCAL BANK FOR THIS TASK, UPDATED BY PIOC-DRIVER
077552     INTEGER NXPNU              % PROCESS NUMBER
077552   PSID
077552   DISP 0
077552     DOUBLE NXRTW               % RT ACTIVATION QUEUE
077552     INTEGER NXRTF              % STATUS, BIT 0 SET BY PIOC WHEN RTWAK REQUESTED
077552                                %         BIT 2 SET BY ND100 WHEN RTWAK COMPLETED
077552   PSID
077552
077552   % PISUPER
077552   %------------------------------------------------------------------------------
077552   % SUPERKICK ACTIVATION
077552   %------------------------------------------------------------------------------
077552   INTEGER EKICK
077553   INTEGER POINTER RET1
077554   PISUPER: A:=L=:"RET1"
077556           0=:EKICK                   % MARK NO PIOC-MTAD KICK
077557
077557   @MAC

)9SCLC
077557  %----- GLOBAL CONSTANTS ----------
077557  SUKOF=1012    % FIXED ADDRESS TO PORT SYSTEM
077557  HSKPA=52525   % FIXED PATTERN
077557  LSKPA=125252  % FIXED PATTERN
077557  MSK=7         % INDEX MASK (MODULO 8)
077557  %------ SUPERKICK OFFSETS ---------
077557  RHSIZ=4    % RING HEADER SIZE
077557  PATRN=0    % OFFSET TO DOUBLE PATTERN
077557  RNTOP=2    % OFFSET TO ND100TOPIOC RING POINTER
077557  RPTON=4    % OFFSET TO PIOCTOND100 RING POINTER
077557  PODIR=6    % OFFSET TO PORT DIRECTORY POINTER
077557  RLOCK=0    % OFFSET TO LOCK IN RING DESCRIPTOR
077557  RSIZE=1    % OFFSET TO SIZE IN RING DESCRIPTOR
077557  RHEAD=2    % OFFSET TO TAIL INDEX IN RING DESCRIPTOR
077557  RTAIL=3    % OFFSET TO HEAD INDEX IN RING DESCRIPTOR
077557  RENTR=4    % OFFSET TO ENTRY ARRAY IN RING DESCRIPTOR
077557  DEMPT=0    % OFFSET TO EMPTY FLAG IN ENTRY DESCRIPTOR
077557  DLEVL=1    % OFFSET TO "LEVEL" IN ENTRY DESCRIPTOR
077557  DPROC=2    % WILL BE CHANGED,
077557             % OFFSET TO PROCESS IN ENTRY DESCRIPTOR
077557  DINF0=2    % OFFSET TO INFO #0 IN ENTRY DESCRIPTOR
077557  DINF1=3    % OFFSET TO INFO #1 IN ENTRY DESCRIPTOR
077557  MTKIC=2    % OFFSET TO PIOC MTAD KICK LISTE POINTER
077557  %------ INSTRUCTIONS UNKNOWN TO DMAC ------
077557  MSTPI=150306
077557  %------ START OF SUPERKICK PATCH ----------
077557
077557       LDX (SUKOF      % OFFSET IN PIOC
077560       LDT ,B PIOCA    % PIOC BANK
077561       PATRN@3 LDDTX   % GET PATTERN
077562       SUB (HSKPA      % AND CHECK IT
077563       JAF NINT        % SUPERKICK IN THIS PIOC ?
077564       SAD ZIN 20      % D -> A
077565       SUB (LSKPA
077566       JAF NINT        % SUPERKICK IN THIS PIOC ?
077567       RPTON@3 LDDTX   % YES,GET PIOC
077570                       % TO ND100 RING POINTER
077570       SAD ZIN SHR 1   % TO GET WORD ADDRESS
077571       ADD ,B PIOCA    % ADD IN PIOC BANK
077572       COPY SA DT
077573       COPY SD DX
077574       RTAIL@3 LDATX   % GET TAIL INDEX
077575  LOOP,SHA ZIN 2       % AND GET OFFSET IN ENTRY ARRAY
077576       AAA RHSIZ       % ADD RING HEADER SIZE
077577       RADD SA DX      % ADD OFFSET IN RING
077600       DEMPT@3 LDATX   % GET EMPTY FLAG
077601       JAF NINT        % DOES THE ENTRY CONTAIN SUPERKICK ?
077602                       % TEST DLEV FOR RT,XMSG
077602       DLEVL@3 LDATX   % GET LEVEL
077603       AAA -5
077604       JAF RTPR        % XMSG (LEVEL 5?)
077605       AAA -20+5; JAF KXMS
077607
077607  % Pioc Mtad kick
077607       SAA 1; DEMPT@3 STATX                         % Mark entry is free
077611       LDX PIOQU,B; STX EKICK                       % Pioc Mtad Kick Df
077613       LDA KICKL,X; JAF KIOK
077615  % Find addrs of Kick buffer in Pioc.
077615       LDX (SUKOF; LDT PIOCA,B; PODIR@3 LDDTX       % Get addr of POCF
077620       SAD ZIN SHR 1; ADD PIOCA,B
077622       COPY SA DT; COPY SD DX; MTKIC@3 LDDTX        % Get addr of Kick buffer
077625       SAD ZIN SHR 1; ADD PIOCA,B
077627       LDX EKICK; STD KICKL,X                       % Nd-100 addr of Kick buffe
077631       LDT (1000; RADD ST DD; COPY SA ADC DA
077634       STD MBPRW,X                                  % Nd-100 addr of read pointer
077635  KIOK,JMP NOKI
077636
077636  % XMSG kick
077636  KXMS,DINF0@3 LDDTX   % GET DOUBLE INFO (LINK INDEX+PHYS.
077637                       % RING BUFFER ADDRESS)
077637       COPY SA DL
077640       SAA 1
077641       DEMPT@3 STATX   % MARK ENTRY AS FREE TO USE
077642       COPY SL DA
077643       JPL I (KXMSG    % KICK XMSG
077644       JMP NOKI        % (ENTER LINK INDEX IN RING BUFFER)
077645  %
077645  RTPR,DPROC@3 LDATX   % YES, GET RTDESCRIPTION ADDRESS TO KIC
077646       COPY SA DD      % SAVE A IN D
077647       DPROC@3 STZTX   % CLEAR RTDESCRIPTION IN ENTRY
077650       SAA 1           %
077651       DEMPT@3 STATX   % MARK ENTRY AS FREE TO USE
077652       COPY SD DX      % X IS RT-DESCRIPTION
077653       LDA ,X 1        % GET RT PROGRAM STATUS
077654       5REP@3 BSKP DA  % TEST FOR REP BIT IN RT DESCRIPTION
077655       JMP NOKI        % IF SET RT PROGRAM ALREADY SCHEDULED
077656       COPY SX DA      % SET RT DESCRIPTION IN A REGISTER
077657       JPL I (XRTEN    % AND KICK
077660       2BANK           % SET DPIT BACK AS ALT. PIT
077661  NOKI,LDX (SUKOF      %
077662       LDT ,B PIOCA    % SAME AS AT START
077663       RPTON@3 LDDTX   % GET PIOC TO ND100 RING POINTER
077664       SAD ZIN SHR 1   % TO GET WORD ADDRESS
077665       ADD ,B PIOCA    % ADD IN PIOC BANK
077666       COPY SA DT
077667       COPY SD DX
077670       RTAIL@3 LDATX   % GET TAILINDEX
077671       AAA 1           % INCREMENT TAILINDEX
077672       AND (MSK        % TAILINDEX MOD MASK+1
077673       RTAIL@3 STATX   % STORE NEW TAILINDEX
077674       JMP LOOP        % AND CHECK IF MORE ENTRIES IN USE
077675  NINT,LDX EKICK; JXZ NPKI
077677       SWAP SX DB; JPL I (RTACT; SWAP SX DB   % Pioc Mtad kick, start Mtad driver
077702  NPKI,JMP I RET1
077703  )FILL
077713  )KILL LOOP
077713
077713  XMBNK=*;0
077714  XIOTB=*;0
077715  XIOIX=*;0
077716  LIX=*;0
077717  XIODS=*;0
077720  XLIND=*;0
077721  %
077721  KXMSG=*
077721        COPY  DT  SA
077722        SHT   ZIN SHR 10
077723        STT  XLIND
077724  % 1
077724        AND  (377
077725        STA  XMBNK
077726        COPY  DT  SA
077727        COPY  SD  DX
077730        SAA   1
077731  % 2
077731        STATX 10
077732        LDXTX 0
077733  % 3
077733        STX  XIOTB
077734        AAX  177776
077735        LDDTX 0
077736  % 4
077736        STA  XIODS
077737        COPY  SD  DA
077740        STA  XIOIX
077741        STA  LIX
077742  % 5
077742        LDA  XIOTB
077743        ADD  XIOIX
077744        COPY  DX  SA
077745  % 6
077745  LOOP=*
077745  % 7
077745        LDATX 0
077746  % 8
077746        JAZ  OUT
077747  % 9
077747        AAX  1
077750        MIN  LIX
077751  % 10
077751        LDA  LIX
077752        SUB  XIODS
077753        JAF  NOTND
077754  % 11
077754        STZ  LIX
077755        LDX  XIOTB
077756  % 12
077756  NOTND=*
077756  % 13
077756        LDA  LIX
077757        SUB  XIOIX
077760        JAF  NTFUL
077761  % 14
077761        EXIT
077762  % 15
077762  NTFUL=*
077762  % 16
077762        JMP  LOOP
077763  OUT=*
077763  % 17
077763        LDA  XLIND
077764        STATX 0
077765  % 18
077765        SAA 40
077766        MSTPI
077767  % 19
077767        EXIT
077770  % 20
077770  )FILL
077771  )KILL XIOIX LIX XIOTB XIODS XMBNK XLIND
077771  )KILL LOOP OUT NOTND NTFUL
077771  )KILL PATCH
077771  )KILL SUKOF HSKPA LSKPA MSK
077771  )KILL RHSIZ PATRN RNTOP RPTON
077771  )KILL PODIR RLOCK RSIZE RHEAD RTAIL RENTR
077771  )KILL DEMPT DLEVL DPROC DINF0 DINF1 MSTPI
077771  )KILL  LOOP RTPR NOKI NINT KXMSG HOME GTHOM
077771  )KILL MTKIC EKICK KXMS KIOK NPKI
077771  )9RCLC
)9SLPL
077771   % PIWKF:
077771   %------------------------------------------------------------------------------
077771   % WAKE UP ROUTINE, ACTIVATED FROM XMSG
077771   %------------------------------------------------------------------------------
077771   INTEGER PMAX,XMST
077773   PIWKF: T=:XMST;0=:PMAX
077775          AD:=RTBOX; AD SHZ -1; D=:X; A+PIOCA=:T; *LDDTX  % POSSIBLE RT ACTIVATIONS IN PIOC
100003   RTFI:  IF A = 0 AND D = 0 THEN CALL WT12 FI
100007          AD SHZ -1; A+PIOCA=:T; D=:X; *NXXTB@3 LDATX
100014          X+10
100015          IF A = L THEN                             % CORRESPONDING XT BLOC
100017            *NXRTF@3 LDATX
100020            A BONE 2; *NXRTF@3 STATX                % YES, SET RTDONE FOR PIOC
100022            A:=PWCR BONE BNDC; T:=HDEV+3; *IOXT     % WAKE UP PIOC
100027            GO WT12
100030          FI
100030          T=:D; PMAX+1=:PMAX; IF PMAX > 20 GO WT12 % NOTHING
100040          D=:T; *NXRTW@3 LDDTX
100042          GO RTFI
100043   *)FILL
100044   % PIINC: PILOC:
100044   %-----------------------------------------------------------------------
100044   % LOAD XMSG CONTEX TO PIOC DF.
100044   % ENTRY:
100044   %   PIINC: MCURB AND LCURB MUST BE INITIATED
100044   %   PILOC: PICPN MUST BE UPDATED
100044   %
100044   % RETURN : XT-BLOCK IN L, AND ALL VAR. IN DF ARE LOADED FROM PIOC XMSG-BOX.
100044   %-----------------------------------------------------------------------
100044   INTEGER POINTER LRG1
100045   INTEGER PICN
100046   PIINC: K:="1"; GO FELLS;        % INITIAL LOADING
100050   PILOC: K:="0"                   % LOADING AFTER INTERUPT FROM OTHER
100051   FELLS: A:=L=:"LRG1"; A:=PXT(PICPN)=:L; IF K THEN X:=LCURB; GO FELL; FI
100062          AD:=MBOXH; AD SHZ-1; A+PIOCA=:T;D=:X;                   % GET HEADER
100067          -20=:PICN; DO; * NXMSG@3 LDDTX                          % GET QUE ELEMENT
100072          WHILE A >< 0 OR D >< 0                                  % QUE NOT EMPTY
100075            AD SHZ-1; A+PIOCA=:T; D=:X; *NXXTB@3 LDATX
100102            IF A=L THEN                                 % XMSG QUE ELEMENT FOUND
100104              T=:MCURB; X=:LCURB
100106   FELL:      * NXLB@3 LDATX
100107              A=:PIXLB;           *NXPAR@3 LDDTX
100111              AD SHZ-1; A+PIOCA=:T; D=:X
100115              T=:PIPAT; X=:PIPAX; * P0@3 LDDTX          % LOAD T-REG & A-REG FROM PIOC
100120              AD=:PIXTA;          * P2@3 LDDTX          % LOAD D-REG & X-REG FROM PIOC
100122              AD=:PIXDX;
100123              GO LRG1
100124            FI
100124            MIN PICN
100125          OD
100126          CALL  FAR PILER            % CANNOT FIND CORRECT XMSG QUE ELEMENT
100127   *)FILL
100130   % PISAC:
100130   %-----------------------------------------------------------------------
100130   %  SAVE CURRENT XMSG CONTEX TO PIOC PROCESS XMSG-BOX AND PARAMETER BLOCK
100130   %-----------------------------------------------------------------------
100130   PISAC:     IF PICPN+1=0 GO L1               % PREV. PROC IS READY
100133              T:=MCURB; X:=LCURB;              % SET UP XMSG-BOX ADDRSS
100135              A:=PIXLB; *NXLB@3 STATX          % SAVE LAST LOCAL BANK FOR THIS TASK
100137              T:=PIPAT; X:=PIPAX               % SET UP PARAMETER ADDRESS
100141              AD:=PIXTA; * P0@3 STDTX          % SAVE T-REG & A-REG TO PIOC
100143              AD:=PIXDX; * P2@3 STDTX          % SAVE D-REG & X-REG TO PIOC
100145   L1:        EXIT
100146   % PICXM:
100146   %-----------------------------------------------------------------------
100146   % CALL XMSG FROM PIOC
100146   % ENTRY:  ALL REGISTERS TO XMSG EXCEPT L (XT-BLOCK)
100146   % RETURN: ALL REGISTERS FROM XMSG INCLUDING L (XT-BLOCK)
100146   %-----------------------------------------------------------------------
100146   TRIPLE HSA1
100151   INTEGER HSA2,HSXT
100153   INTEGER POINTER LRG2
100154   PICXM:
100154           TAD=:HSA1; X=:HSA2
100156           A:=L=:PXL(PICPN); A:=PXT(X)        % SAVE L FOR CURRENT PROCESS AND GET XT-BLOCK
100162           IF A=-1 THEN A:=0; FI A=:L         % IF NEW XT-BLOCK
100167           TAD:=HSA1; X:=HSA2;* MON 2XMSG
100172           GO FAR XPLEV; TAD=:HSA1; X=:HSA2
100175           IF X:=PICPN = -1 OR PXT(X) >< L THEN % HAS THIS PROCESS BEEN INTERUPTED ?
100204             X:=0;DO WHILE X< 20              %  FIND PROCESS NR. LOOKING AFTER XT BLOCK
100210                 IF PXT(X)=L AND A >< 0 THEN
100214                    X=:PICPN                  % SET CURRENT PROCESS
100215                    CALL PISAC; CALL PILOC    % SAVE PREV. AND LOAD NEW  CONTEX
100217                    GO RETU
100220                 FI
100220                 X+1
100221             OD
100222             X:=0;DO WHILE X< 20              %  FIND PROCESS NR. LOOKING AFTER NEW XT-BLOCK.
100226                 IF PXT(X)+1=0 THEN           %
100231                    X=:D; T:=MCURB; X:=LCURB  % D= NEW PROC NO
100234                    * NXPNU@3 LDATX           % A= OLD PROC NO
100235                    IF A=D GO RETU            % OK PROCESS NOT SWITCHED
100237                    X:=D=:PICPN; X:=L=:HSXT   % SET PROC NO AND SAVE XT BLOCK
100243                    CALL PISAC                % SAVE OLD CONNTEX
100244                    CALL PILOC                % LOAD 1. PROCESS WHICH NOT HAVE A XT-BLOCK
100245                    T:=MCURB; X:=LCURB; * NXPNU@3 LDATX
100250                    A=:PICPN;                  % PROCESS NR MAY BE INCORRECT
100251                    X:=HSXT=:L; GO RETU
100254                 FI;X+1
100255             OD
100256             CALL FAR PILER
100257           FI
100257   RETU:   PXL(PICPN)=:"LRG2"
100262           TAD:=HSA1; X:=HSA2
100264           GO LRG2
100265   *)FILL
100267   %  XMMC:
100267   %-----------------------------------------------------------------------
100267   %  HANDLING OF MULTICALL
100267   %  THE ROUTINE CONVERT PARAMETER BLOCKS FROM PIOC 6 WORD FORMAT
100267   %  TO NORD 4 WORD FORMAT AND TRANSLATES ADDRESSES IN READ AND WRITE CALLS
100267   %  IF THE BANK CHANGES FROM LAST USED A DEFINE NEW BANK CALL IS INSERTED
100267   %-----------------------------------------------------------------------
100267   % VARIABES AND POINTERS USED IN DOIT
100267
100267   INTEGER MTSAV=?,MASAV=?
100267   DOUBLE MTASAV=?       % INTERMEDIATE STORE FOR T AND A REGISTERS IN A CALL
100267   DOUBLE MDXSAV=?       % INTERMEDIATE STORE FOR D AND X REGISTERS IN A CALL
100267   DOUBLE MUSSAV=?       % INTERMEDIATE STORE FOR EV. USERADDRESS
100267   DOUBLE NTASAV=?       % INTERMEDIATE STORE OF NEXT BLOCK, T & A
100267   DOUBLE NDXSAV=?       % INTERMEDIATE STORE OF NEXT BLOCK, D & X
100267   DOUBLE NUSSAV=?       % INTERMEDIATE STORE OF NEXT BLOCK, EV. USERADDR.
100267   INTEGER INX=?,INRPA=?,ONRPA=? % NUMBER OF XMSG CALL IN AND OUT OF ROUTINE
100267   INTEGER HNOFF=?,LNOFF=?
100267   DOUBLE NOFF =?        % START OF NEXT PARAMETER IN NORD BLOCK (4 WORD BLOCKS)
100267   INTEGER HPOFF=?,LPOFF=?
100267   DOUBLE POFF =?        % START OF NEXT PARAMETER IN PIOC BLOCK (6 WORD BLOCKS
100267
100267   XMMC:  IF PIXXR < 0 GO FAR REEX                 % REEXECUTE TASK'S LAST MULTICALL
100272                                                   % IF < -1 XMSG HANDLES IT
100272          A:=PIXAR=:D:=PIXLB
100275          X:= PIXXR;                                  % PAR.NR IN X
100276          A + PIOCA;                                  % PAR.ADDR IN AD
100277          AD =: NOFF; AD =: POFF                      % INITIALIZE NEXT BLOCK POINTERS
100301          X =: INRPA; X =: ONRPA; 0 =: INX            % INITIALIZE PARAMETER COUNTS
100304          T := HPOFF; X := LPOFF; *P0@3 LDDTX
100307          AD =: NTASAV; *P2@3 LDDTX                   % NEXT PAR. BLOCK IS FIRST
100311          AD =: NDXSAV; *P4@3 LDDTX
100313          AD =: NUSSAV
100314          GO LOOP
100315   %-----------------------------------------------------------------------
100315   INTEGER MTSAV,MASAV
100317   DOUBLE MTASAV = MTSAV
100317   DOUBLE MDXSAV, MUSSAV, NTASAV, NDXSAV, NUSSAV
100331   INTEGER INX,INRPA,ONRPA, HNOFF,LNOFF
100336   DOUBLE NOFF = HNOFF
100336   INTEGER HPOFF,LPOFF
100340   DOUBLE POFF = HPOFF
100340   *)FILL
100341   %-----------------------------------------------------------------------
100341   LOOP:  INX + 1 =: INX                              % INCREMENT LOOP VARIABLE
100344          AD := NTASAV; AD =: MTASAV                  % DO FOR ALL CALLS IN PAR. BLOCK
100346          AD := NDXSAV; AD =: MDXSAV
100350          AD := NUSSAV; AD =: MUSSAV
100352          IF INX < INRPA THEN                         % LAST CALL IN BLOCK ?
100356             AD := POFF; T := 6; *RADD ST DD          % INCREMENT PIOC BLOCK POINTER
100361             *RADD ADC DA
100362             AD =: POFF; T := A; X := D; *P0@3 LDDTX  % NEW PIOC BLOCK PTR. IN TX
100366             AD =: NTASAV; *P2@3 LDDTX                % SAVE NEXT T&A FROM OVERWRITE
100370             AD =: NDXSAV; *P4@3 LDDTX                % SAVE NEXT D&X FROM OVERWRITE
100372             AD =: NUSSAV;                            % SAVE NEXT USERADDR. --"--
100373          FI
100373          AD := MTASAV                             % GET CURR. T & A REGISTERS FROM BLOCK
100374          IF A = XFREA OR A = XFWRI THEN           % READ OR WRITE CALL ?
100402            AD := MUSSAV; AD SHZ -1; T:=D=:MASAV   % CONVERT TO WORD ADDRESSING T!!
100406            IF A >< PIXLB THEN                     % BANK DIFFERS FROM LAST USED?
100411              A=:PIXLB                              % REMEMBER NEW BANK
100412              A + PIOCA; D := A; A := XFDBK         % SET PARS. FOR DEFINE BANK NR.
100415              T := HNOFF; X := LNOFF; *P0@3 STDTX   % INSERT PARAMETERS IN BLOCK
100420              A := T; D := X; T := 4; *RADD ST DD   % INCREMENT NORD BLOCK POINTER
100424              *RADD ADC DA
100425              AD =: NOFF
100426              A := ONRPA; A + 1; A =: ONRPA     % INCREMENT RETURNED PARAMETERCOUNT
100431            FI
100431          FI
100431          T := HNOFF; X := LNOFF                % START OF NEXT NORD BLOCK
100433          AD := MTASAV; *P0@3 STDTX             % COPY T & A REGISTERS TO BLOCK
100435          AD := MDXSAV; *P2@3 STDTX             % COPY D & X REGISTERS TO BLOCK
100437          A := T; D := X; T :=4; *RADD ST DD
100443          *RADD ADC DA                          % INCREMENT NORD BLOCK POINTER (4)
100444          AD =: NOFF;
100445          IF INX < INRPA GO FAR LOOP            % CONTINUE LOOP ?
100451          X := ONRPA                            % RETURN NEW PARAMETERCOUNT IN X
100452          X =: PIXXR;                           % PARAMETER COUNT MIGHT BE INCR.
100453          GO FAR XMRT
100454   *)FILL
100456
100456
100456   %-------------------------------------------------------------------------------
100456   %      DOIT:
100456   %      THIS POINT IS ACTIVATED WHEN PIOC DOES A XMSG CALL FOR EXECUTION IN ND100
100456   %      THE PARAMETERS ARE FOUND BY A POINTER IN A CHAIN OF BOXES.
100456   %      PARAMETERS ARE SET IN REGISTERS, THE XMSG CALL ARE DONE.
100456   %      REACTIVACTION FROM XMSG MAY ACTIVATE THIS CODE IN TWO DIFFERENT POINTS.
100456   %      1. SKIP RETURN AFTER THE CALL
100456   %      2. IN "XPWAK" IF AN RTENTRY LIKE FUNCTION OCCURS
100456   %
100456   %-------------------------------------------------------------------------------
100456   DOIT:  *NXPNU@3 LDATX
100457          A=:PICPN                    % INITIATE PROCESS NR.
100460          CALL FAR PIINC              % GET ALL PARAMETERS AND PIONTERS TO DF.
100461                                      % XT BLOCK IS RETURNED IN L (HURRA)
100461          IF L = 0 THEN                             % VIRGIN ?
100463            -1=:PXT(PICPN);
100466            T:=MCURB; X:=LCURB; * NXXTB@3 STATX     % MARK GETTING NEW XT-BLOCK
100471            T:=XFDBK; A:=PIOCA=:PIXLB; CALL FAR PICXM% GET XT-BLOCK AND DEFINE BANK
100475            IF T < 0  GO FAR XPERET
100477            A:=L=:PXT(PICPN)                        % XT BLOCK TO PROC TABLE IN DATAFIELD
100502            T:=MCURB; X:=LCURB; *NXXTB@3 STATX      % XT BLOCK TO PIOCOS PROC DESC.
100505            A:="PIWKF"; T:=XFWDF; CALL FAR PICXM    % DEFINE RT WAKE UP ADDRESS
100510            IF T < 0  GO FAR XPERET
100512          FI
100512          IF PIXTR /\ 77=XFREA OR A=XFWRI OR A=XFRRE OR A=XFSMC OR A=XFWRT THEN  % READ OR WRITE OR REC./READ?
100533            IF A=51 THEN K:="1";ELSE K:="0";FI
100541            T:=PIPAT;X:=PIPAX; *P4@3 LDDTX          % GET ADDRESS NO WITHIN PIOC
100544            AD SHZ -1; T:=D
100546            IF K THEN T=:PIXXR; ELSE T=:PIXAR; FI   % BUFFER ADDRESS IN WORD ADDRESS
100553            IF A >< PIXLB THEN                      % NEW BANK WITHIN THIS PIOC ?
100556              A=:PIXLB                              % REMEMBER NEW BANK
100557              T:=XFDBK; A+PIOCA;  CALL FAR PICXM    % YES SET NEW BANK FOR XMSG
100562              IF T<0 GO  FAR XPERET
100564            FI
100564          FI
100564          IF PIXTR /\ 77 = XFSMC  GO FAR XMMC       % CURRENT CALL XMSG MULTICALL?
100571
100571   XMRT:
100571          IF PIXTR /\77 = XFDCT THEN                % DISCONNECT ?
100576             T:=MCURB; X:=LCURB; A BONE 1; *NXFNC@3  STATX  % YES, WE WILL NOT SEE THIS BLOCK AGAIN
100602             0=:PXT(PICPN); T:=XFDCT; *MON 2XMSG
100606          ELSE
100607   REEX:     T:=PIXTR; AD:=PIXAD; X:=PIXXR; CALL FAR PICXM
100613             T=:PIXTR; AD=:PIXAD; X=:PIXXR
100616          FI
100616
100616   %      XMSG FUNCTION DONE,
100616   SPARK:
100616          IF T<0 THEN                            % ERROR FROM XMSG
100620             -1=:PIXLB                           % FORCE A NEW DEFINE BANK NEXT XMSG CALL
100622             IF XEIXT=T OR XENRU=T THEN          % CHECK IF XMSG CRASHED
100630               T:=MCURB; X:=LCURB
100632               A:=0; *NXXTB@3 STATX              % LAST XT-BLOCK IN PIOCOS
100634               0=:PXT(PICPN)                     % ZERO XT-BLOCK IN DF.
100636             FI
100636          FI
100636          CALL FAR PISAC                         % UPPDATE XMSG PARAMETER BOX
100637
100637          T:=MCURB; X:=LCURB; *NXFNC@3 LDATX
100642          A BONE 1;           *NXFNC@3 STATX     % XMSG DONE
100644          A:=PWCR BONE BNDC; T:=HDEV+3; *IOXT    % WAKE UP PIOC
100651          -1=:PICPN                              % THIS PROCESS IS FINISH
100653          GO PIXMSG                              % GET NEW BOX IF ANY
100654   *)FILL
100663
100663   XPERET: T=:PIXTR; GO SPARK                    % RETURN ONLY STATUS
100665
100665   INTEGER CPILER
100666   PILER:  A:=L=:CPILER                          % ERROR IN XMSG BOX LINK IN PIOCOS
100670          -1=:PICPN                              % THIS PROCESS IS FINISH
100672           A:=PIOCN; T:=1; CALL 9ERR(#81)
100676           GO PIXMSG
100677
100677   %-----------------------------------------------------------------------
100677   %      PROCESS XMSG CALL FORM PIOC, MAIN ENTRY PIONT CALLED FROM
100677   %      DRIVER
100677   %      NB MUST NOT START BEFORE PREVIOUS CALL GAVE A SKIP RETURN
100677   %-----------------------------------------------------------------------
100677   INTEGER HSA3,HSA4,CINDEX
100702   PIXMSG:-20=:CINDEX
100704          AD:=MBOXH; AD SHZ -1; A+PIOCA=:T; D=:X; *LDDTX      % GET HEADER
100712   TRY:   IF A = 0 AND D = 0 GO XPRET                         % EMPTY QUEUE
100715          AD SHZ -1; A+PIOCA=:T; D=:X
100721          *NXFNC@3 LDATX
100722          IF A = 0 THEN                        % NEW XMSG REQUEST ?
100723            A BONE 3; *NXFNC@3 STATX           % YES, SET WORKING
100725            IF PICPN+1>< 0 THEN                % ANOTHER XMSG CALL INTERUPTED
100730               T=:HSA3; X=:HSA4;               % YES
100732               CALL FAR PISAC                  % SAVE PREVIOUS CONTEXT
100733               T:=HSA3; X:=HSA4;
100735            FI
100735            T=:MCURB; X=:LCURB
100737            GO FAR DOIT                        % DO XMSG CALL
100740          FI
100740          *NXMSG@3 LDDTX
100741          MIN CINDEX; GO TRY
100743
100743   XPRET: GO AFXMSG
100744   XPLEV: CALL WT12
100745   *)FILL
100751   %==========================================================================
100751   %      LOAD AND STORE IN PHYSICAL MEMORY
100751   %      (64K WORDS ONLY)
100751   %==========================================================================
100751   YPREAD: A:=K1024; X+A; T:=PIOCA; *LDATX                     % DON'T LET CACH FOOL US
100755          A:=K1024; X-A; *LDATX; EXIT
100761   YPWRIT: T:=PIOCA; *STATX; EXIT
100764   *)FILL
100765   %------------------------------------------------------------------------------
100765   %  PDRIV:
100765   %  PIOC DRIVER MAIN ENTRY POINT
100765   %
100765   %------------------------------------------------------------------------------
100765   INTEGER INN
100766   PDRIV:
100766           *2BANK
100767           IF PWCR BIT 5 THEN CALL WT12 FI                  % ACCEPT NO INTERRUPT WHEN NOT STARTED
100773          GO  PIXMSG                                        % PROCESS XMSG CALL
100774   AFXMSG:X := PNBOX; CALL YPREAD
100776          IF A >< 0 THEN                                    % TRIGG TO OPCOM ?
100777                A:=0; CALL YPWRIT
101001                RTRES=:KPROS                                % YES, WAKE HIM UP
101003                IF A >< 0 THEN
101004                  CALL RTACT; CALL WT12
101006                    ELSE
101007                  GO NOINT                                  % NO MONITOR ATTACHED
101010                FI
101010          FI
101010          X := PKICK; CALL YPREAD
101012          IF A >< 0 THEN                                    % TRIGG FOR SOMEONE ELSE?
101013                A:=0; CALL YPWRIT
101015                0=:INN
101016                FOR INN STEP 1 TO SLMAX DO                  % SEE WHO SHALL HAVE A KICK
101022                  A:="PTN"+INN=:X; CALL YPREAD
101026                  IF A = TRIG THEN
101031                    A:=0; CALL YPWRIT                       % DTRIGG
101033                    A:="NDPRO"+INN=:X; CALL YPREAD; A=:KPROS % GET PROCESS
101040                    IF A >< 0 THEN
101041                      CALL RTACT; CALL WT12
101043                    FI
101043                  FI
101043                OD
101047          FI
101047   NOINT: PWCR BONE BENA=: PWCR;
101052          CALL FAR  PISUPER                 % TEST IF SUPERKICK
101053          PWCR; T := HDEV+3; *IOXT          % MUST ENABLE PIOC AFTER DUMMY INTERRUPT
101057          CALL WT12
101060   RBUS
101063   SUBR DIS12
101063   %      ROUTINE FOR DISCONNECT AT LEVEL 12
101063   %      XT BLOCK IN L-REG
101063   DIS12: T:=XFDCT; *MON 2XMSG
101065          CALL WT12
101066          CALL WT12 % IN CASE OF ERROR RETURN FROM XMSG.
101067   RBUS
101070
101070   SUBR PIORE
101070   %===================================================================
101070   % SPECIAL IO-RESTART ROUTINE FOR PIOC  (MFUNC=PIORE)
101070   % X = DATAFIELD, RTRES = PROGRAM TO BE STARTED
101070   % KPROS = PROCESS TO BE ACTIVATED (RT)
101070   %===================================================================
101070   PIORE: X=:B:=KPROS
101072          PWCR BONE BENA=: PWCR; T := HDEV+3; *IOXT          % ENABLE PIOC
101100          CALL RTENTRY
101101          "STDRIV"; *IOF; IRW LV12B DP                        % START DRIVER AGAIN
101104          B=:A; *IRW LV12B DB
101106          LV12; *MST PID; ION
101111          CALL STUPR
101112   RBUS
101115   *"
"101115
101115   @DEV 1
101115   @DEV (S-S-L)MP-P2-HASP-ETC:NPL
101115   *"8MODI+8HMO1+8HMO2+8HMO3+8HMO4+8HMO5+8HMO6
"101115

101115   %===========================================================================
101115   %      ( I )     X P U T
101115   SUBR XPUT
101115   XPUT:   T:=MBSYMOD; GO TDBPUT
101117           EXIT
101120   RBUS
101122
101122   *"8MODI
"101122   %==============================================================================
101122   %      ( I )      M O D I N   M O D U T   M O D I 1
101122   %
101122
101122   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
101122   %   SYNCRONOUS MODEM DRIVER                 %
101122   %   AND HANDLING ROUTINES FOR SINTRAN III   %
101122   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
101122
101122   SUBR MODIN,MODUT,MODI1
101122
101122   DISP -17
101122   INTEGER DLINI             %
101122   INTEGER TRFL              % SET IF TRANSPARENT
101122   INTEGER XTERM(3)          % TERMINATOR FLAG
101122   INTEGER MOWSTAT
101122   INTEGER TERSW,MOSW
101122   PSID
101122
101122   SYMBOL EBSOH=1, EBSTX=2, EBETX=3, EBDLE=20, EBIUS=37, EBETB=46
101122   SYMBOL EBEOT=67, EBSYN=62, EBPAD=377
101122
101122   SYMBOL ASSOH=1, ASSTX=2, ASETX=3, ASEOT=4, ASACK=6, ASBEL=7
101122   SYMBOL ASDLE=20, ASDC1=21, ASNAK=25, ASSYN=26, ASETB=27, ASUS=37
101122
101122   % MODEM INPUT DRIVER
101122
101122   MODIN:
101122          CALL ID12
101123   MODI1: T:=HDEV+DDR;*EXR ST
101126          A=:LAST
101127          IF T:=CFREE=0 GO MOSWX
101132
101132   @ICR;
101132          T:=MOSW GOSW MOSW0, FAR IBM1, FAR IBM2, MOSW3, MOSW4, MOSW4,  % 0-5
101142                       FAR I3271, HASP1, HASP2, HASP3, FAR HASP4,       % 6-12
101147                       FAR HASP5, FAR HASP6, FAR HASP7, FAR HASP8,      % 13-16
101153                       FAR HASP9;                                       % 17
101154   @CR;
101154
101154   MOSW4: GO MODIN
101155
101155   MOTERMF:
101155          LAST                                      % TERMINATOR FOUND
101156   MOSW3: CALL XPUT
101157   MOSWX: CALL RTACT
101160          IF TERSW=7 OR =12 OR =14 GO MOSWY         % NTR/VIP-BTH/UTS-400
101172          T:=HDEV+DCONT; 2204; *EXR ST
101176          0=:TMR; 4=:MOSW                           % IGNORE NEXT CHARACTER
101201          GO MODIN
101202   MOSWY: T:=HDEV+DCONT; 2204; *EXR ST
101206          205; *EXR ST                              % READ NEXT CHARACTER (IF SYNC)
101210          0=:TMR=:MOSW
101212          GO MODIN
101213
101213   *)FILL
101232
101232   % TEST FOR TERMINATION CONDITION
101232
101232   @ICR;
101232   MOSW0: T:=TERSW GOSW FAR GEN0, FAR DCT0, FAR CDC0, FAR GER0, IBM0, VIP0, HASP0,
101243                        FAR NTR0, FAR MSV20, FAR I3270, FAR BTH0, FAR SSAAB,
101250                        FAR UTS0;
101251   @CR;
101251
101251   %      HASP WS :
101251   %
101251   %      MOSW=0, TERSW=6 : DECODE 1. CHARACTER (SHOULD BE SYN)
101251   %
101251   HASP0: IF A><EBSYN GO MOSWY                      % ERROR: RESYNC
101254          7=:MOSW; GO FAR MODRET                     % READ SECOND
101257
101257   %
101257   %      MOSW=7 : DECODE 2. CHARACTER (SHOULD ALSO BE SYNC)
101257   %
101257   HASP1: IF A><EBSYN GO FAR MOSWY                  % ERROR : RESYNC
101262          10=:MOSW; GO FAR MODRET
101265   %
101265   %      MOSW=10 : DECODE BLOCK FOLLOWING SYNC
101265   %
101265   HASP2: IF A=EBSYN GO FAR MODRET
101270          IF A=EBPAD GO FAR MOSWX                   % END OF BLOCK
101273          CALL XPUT
101274          IF A=EBDLE THEN                           % ACK OR TRANSP. TEXT
101277             11=:MOSW
101301          ELSE
101302             IF A=EBSOH THEN                        % ENQ OR NON-TRANSP. TEXT
101305                12=:MOSW
101307             FI
101307          FI
101307          GO FAR MODPIN
101310
101310   %
101310   %      MOSW=11 : TRANSPARENT TEXT OR ACK (STARTS WITH DLE)
101310   %
101310   HASP3: CALL XPUT
101311          IF A=EBSTX THEN                           % TRANSP. TEXT-BLOCK
101314             13=:MOSW
101316          ELSE
101317             GO MOSWX                               % ACK
101320          FI
101320          GO FAR MODPIN
101321
101321   %
101321   %      MOSW=12 : NON-TRANSPARENT TEXT BLOCK OR ENQ (STARTS WITH SOH)
101321   %
101321   HASP4: CALL XPUT
101322          IF A=EBSTX THEN                           % TEXT-BLOCK WITH CRC FOLLOWS
101325             15=:MOSW
101327          ELSE
101330             GO MOSWX                               % ENQ
101331          FI
101331          GO FAR MODPIN
101332
101332   %
101332   %      MOSW=13 : TRANSPARENT TEXT BLOCK ENDED WITH DLE+ETB+CRC+CRC+PAD
101332   %
101332   HASP5: CALL XPUT
101333          IF A=EBDLE THEN MIN MOSW FI               % ETB MAY FOLLOW
101337          GO FAR MODPIN
101340
101340   %
101340   %      MOSW=14 : DLE WAS READ IN TRANSP. TEXT MODE, CHECK IF NEXT IS ETB
101340   %
101340   HASP6: CALL XPUT
101341          IF A=EBETB THEN                           % ETB : 2 CRC FOLLOWS
101344             16=:MOSW
101346          ELSE
101347             13=:MOSW                               % RESET DLE-MODE
101351          FI
101351          GO FAR MODPIN
101352
101352   %
101352   %      MOSW=15 : NON-TRANSPARENT TEXT BLOCK ENDED WITH ETB+CRC+CRC+PAD
101352   %
101352   HASP7: CALL XPUT
101353          IF A=EBETB THEN MIN MOSW FI
101357          GO FAR MODPIN
101360
101360   %
101360   %      MOSW=16 : 1. CRC CHARACTER
101360   %
101360   HASP8: CALL XPUT
101361          MIN MOSW; GO FAR MODPIN                   % READ NEXT CRC
101363
101363   %
101363   %      MOSW=17 : 2. CRC CHARACTER
101363   %
101363   HASP9: CALL XPUT
101364          GO FAR MOSWX                              % END OF BLOCK
101365   *)FILL
101405
101405   %      VIP CONTROL (HONEYWELL-BULL INTERACTIV TERMINALS)
101405
101405   VIP0:  IF A=0 OR =ASSYN GO FAR MODRET
101411          CALL XPUT
101412          IF A/\177=ASETX THEN
101416             T:=2=:MOSW; GO FAR MODPIN              % BCB WILL FOLLOW AFTER ETX
101421          FI
101421          IF A=ASEOT GO FAR MOSWX                   % EOT : END OF BLOCK
101424          GO FAR MODPIN
101425
101425   % IBM 3780/2780 II WITH TRANSPARENT MODE
101425   IBM0:IF T:=XTERM=0 THEN
101430   % NOT IN TEXT MODE
101430           IF A=EBSYN GO FAR MODPIN   % SYNC CHARS NOT TO BUFFER
101433           CALL XPUT                  % PUT CHAR TO RING BUFFER
101434           IF A=EBSTX THEN
101437             0=:TRFL;IF DLINI>0 THEN MIN TRFL;FI      % SET IF TRANSPARENT
101444             0=:DLINI; MIN XTERM                      % SET TEXT MODE
101446           ELSE
101447             0=:DLINI;IF A=EBDLE THEN MIN DLINI;FI    % THIS WAS DLE
101454             IF A=EBPAD GO FAR MOSWX                  % TERMINATE ON PAD
101457           FI
101457        ELSE
101460   % TEXT MODE, SPECIAL TEST FOR TERMINATOR
101460           CALL XPUT                                 % CHAR TO BUFFER
101461           IF A=EBDLE THEN DLINI;*BSET BCM 0 DA      % COMPLEMENT ON DLE
101466             A=:DLINI
101467           ELSE
101470             IF T:=TRFL=0 OR T:=DLINI>0 THEN
101476   % TEST FOR TERMINATOR
101476                 IF A=EBETB OR =EBETX OR =EBIUS THEN
101507                    A=:XTERM;0=:DLINI
101511                    T:=1=:MOSW   % TERMINATOR FOUND, NEXT IS 1. BLOCK CHECK CHAR
101513                 FI
101513              FI
101513           FI
101513        FI
101513        GO FAR MODPIN
101514   *)FILL
101522   % MOSW=1:
101522   IBM1:   CALL XPUT                   % 1. BLOCK CHECK CHAR
101523           MIN MOSW;GO FAR MODPIN
101525   % MOSW=2:
101525   IBM2:   CALL XPUT                   % 2. BLOCK CHECK CHAR
101526           0=:MOSW
101527           IF XTERM=EBIUS THEN
101533             0=:XTERM
101534             GO FAR MODPIN             % 2780 RECORD TERMINATOR,CONTINUE
101535           FI
101535           0=:XTERM
101536           GO FAR MOSWX                % TERMINATE BLOCK AND ACTIVATE PROGRAM
101537   *)FILL
101542
101542   %      GERTS-115
101542
101542   GER0:  IF A=0 OR =ASSYN OR =377 GO FAR MODRET
101551          CALL XPUT
101552          A/\177
101553          IF A=ASETX THEN T:=3=:MOSW FI             % ETX : BCB WILL FOLLOW NEXT
101560   % *"8KGS
101560   %        IF A=ASEOT OR A=ASNAK OR A=ASDLE GO FAR MOTERMF
101560   % *"8SMO1+8SMO2+8SMO3+8SMO4+8SMO5+8SMO6+NSBD0+NSBD1
101560          GO FAR MODPIN
101561   %
101561   %      UNIVAC NTR
101561   %
101561   NTR0:  CALL XPUT
101562          IF A=ASETX THEN 3=:MOSW FI                % ETX : BCB WILL FOLLOW NEXT
101567          GO FAR MODPIN
101570
101570   *)FILL
101575
101575   %
101575   %      CD-200-USER
101575   %
101575   CDC0:  GO GER0
101576   %
101576   %      NOT DEFINED
101576   %
101576   GEN0:  GO GER0
101577   %
101577   %      DCT-2000
101577   %
101577   DCT0:  IF =0 OR =ASSYN OR =377 GO FAR MODRET
101606          CALL XPUT
101607          A/\177
101610          IF A=ASETX OR =ASEOT OR =ASACK OR=ASNAK OR=ASBEL OR =ASDC1 THEN
101632             3=:MOSW                                % AFTER ETX,EOT,ACK,NAK,BELL,DC1 : 1 BCC
101634          FI
101634          GO FAR MODPIN
101635   %
101635   %      SIEMENS MSV2
101635   %
101635   MSV20: IF A=ASSYN GO MODRET
101640          CALL XPUT
101641          IF A/\177=ASETX OR =ASETB OR =ASUS THEN MIN MOSW FI % READ 2 CRC NEXT
101654          IF A=177 GO FAR MOSWX                               % END OF BLOCK
101657          GO MODPIN
101660
101660   %
101660   %      IBM-3270 EMULATOR
101660   %
101660
101660   I3270: IF A=EBSYN GO MODRET
101663          CALL XPUT
101664          IF A=EBSTX THEN T:=6=:MOSW FI             % STX : SET TEXT MODE
101671          IF A=EBEOT GO FAR MOSWY                   % EOT : NEW SYNC MAY FOLLOW
101674          IF A=EBPAD GO FAR MOSWX                   % ENDING PAD
101677          GO MODPIN
101700   %
101700   %      MOSW=6 : 3270 IN TEXT MODE
101700   %
101700
101700
101700   I3271: CALL XPUT
101701          IF A=EBETX OR =EBETB THEN T:=1=:MOSW FI   % ETX/ETB : 2 CRC WILL FOLLOW
101711          GO MODPIN
101712
101712   %
101712   %      BTH/VIP 7750 INTERACTIVE TERMINALS
101712   %
101712   BTH0:  IF A=0 GO MODRET
101713          IF A=377 GO FAR MOSWX                     % PAD : END OF BLOCK
101716          CALL XPUT
101717          A/\177
101720          IF A=ASETX OR =ASETB THEN                 % ETX/ETB : BCC NEXT
101726             2=:MOSW; GO MODPIN
101731          FI
101731          IF A=ASEOT GO FAR MOSWX                   % EOT
101734          GO MODPIN
101735
101735   *)FILL
101744
101744   %
101744   %      STANSAAB, ISO-1745 LINE PROCEDURE.
101744   %
101744
101744   SSAAB: T:=177/\A=:D
101747          IF D=0 OR D=ASSYN GO MODRET
101754          IF D=ASEOT OR D=ASNAK GO FAR MOSW3        % EOT/NAK : END OF BLOCK
101762          CALL XPUT
101763          IF A/\177=ASDLE OR A=ASETX THEN 3=:MOSW FI % DLE/ETX : 1 BCC WILL FOLLOW
101774          GO MODPIN
101775
101775   %
101775   %      UNIVAC UTS-400 EMULATOR
101775   %
101775   UTS0:  IF A=0 OR =ASSYN OR =377 GO FAR MODRET     % UTS-400
102004          CALL XPUT
102005          IF A/\177=ASETX THEN 3=:MOSW; FI          % AFTER ETX : 1 BCC
102013          GO MODPIN
102014
102014   MODPIN:
102014   MODRET: 205; T:=HDEV+DCONT; *EXR ST
102020          -2=:TMR
102022          GO MODIN
102023   %
102023   % DRIVER FOR MODEM OUTPUT
102023   MODUT: DO;*IOF
102024             IF BHOLD=0 THEN 0=:TMR=:MOWSTAT; T:=0; CALL RTACT; GO HIT FI
102033             T:=MBSYMOD; CALL TDBGET; T:=HDEV+DDW;*EXR ST
102040             TTMR=:TMR
102042             T:=5
102043   HIT:      T=:A; T:=HDEV+DCONT;*EXR ST;ION
102050             CALL ID10
102051          OD
102052
102052   RBUS
102065
102065   *"8HMO1+8HMO2+8HMO3+8HMO4+8HMO5+8HMO6
"102065

102065   %=================================================
102065   %       ( I )     H O D I N    H O D U T    H O D I 1
102065   %
102065
102065   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
102065   % SYNCRONOUS MODEM DRIVER FOR HDLC INTERFACE
102065   % AND HANDLING ROUTINES FOR SINTRAN III
102065   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
102065
102065   %      SEE SPECIAL MODIFICATION IN CASE OF COMMUNICATION BETWEEN
102065   %      X21 AND X21-BIS ON NORD COMPUTERS AT LABEL "HODUT"
102065
102065   SUBR HODIN,HODUT,HODI1,MODXX
102065   DISP -17
102065          INTEGER DLINI             %
102065          INTEGER TRFL              % SET IF TRANSPARENT
102065          INTEGER XTERM(2)          % TERMINATOR FLAG
102065          INTEGER HOWSTAT
102065          INTEGER HERSW
102065          INTEGER HDXOK
102065          INTEGER MOSW
102065   PSID
102065          INTEGER TELL:=0
102066          INTEGER TELL1:=0
102067          SYMBOL BUFSIZ=20
102067          SYMBOL TELMA=BUFSIZ-1
102067          INTEGER ARRAY BUFF(BUFSIZ)                % RECEIVER STATUS
102107
102107          SYMBOL EBSOH=1, EBSTX=2, EBETX=3, EBDLE=20, EBIUS=37, EBETB=46
102107          SYMBOL EBEOT=67, EBSYN=62, EBPAD=377
102107
102107          SYMBOL ASSOH=1, ASSTX=2, ASETX=3, ASEOT=4, ASACK=6, ASBEL=7
102107          SYMBOL ASDLE=20, ASDC1=21, ASNAK=25, ASSYN=26, ASETB=27, ASUS=37
102107
102107   % MODEM INPUT DRIVER
102107
102107   HODIN:
102107          CALL ID13
102110   HODI1: T:=HDEV+BRRTS; *EXR ST
102113          A=:T                                      % ENTRY HERE IF X21
102114          IF A NBIT 0 OR A/\60000><0 THEN           % NO DATA OR X21 ERROR?
102120             MIN TELL; P+0
102122             TELL/\ TELMA=:TELL1
102125             *1BANK
102126             T=:BUFF(TELL1)
102130             *2BANK
102131             IF HOWSTAT = 0 THEN                    % YES, PINNED FOR DATA?
102133               304/\HDXOK; T:=HDEV+BWRTC; *EXR ST   % NO, ENABLE FOR STATUS CHANGE
102140                GO HODIN                            % HDXOK MAY CLEAR BIT 100
102141             ELSE
102142                GO FAR MODPIN                       % FORGET DATA, ENABLE AGAIN
102143             FI
102143          FI
102143          T:=HDEV+BRRDR;*EXR ST
102146          A=:LAST
102147          IF T:=CFREE=0 GO MOSWX
102152
102152   @ICR;
102152          T:=MOSW GOSW MOSW0, FAR IBM1, FAR IBM2, MOSW3, MOSW4, MOSW4,  % 0-5
102162                       FAR I3271, HASP1, HASP2, FAR HASP3, FAR HASP4,   % 6-12
102167                       FAR HASP5, FAR HASP6, FAR HASP7, FAR HASP8,      % 13-16
102173                       FAR HASP9;                                       % 17
102174
102174   @CR;
102174
102174   MOSW4: 300/\HDXOK; T:=X2DHD+BWRTC; *EXR ST       % ENABLE FOR MODEM STATUS CHANGE
102201
102201   MOTERMF:
102201          LAST                                      % TERMINATOR FOUND
102202   MOSW3: CALL XPUT
102203   MOSWX: CALL RTACT
102204          IF HERSW=7 OR =12 OR =14 GO MOSWY         % NTR/VIP-BTH/UTS-400
102216          T:=HDEV+BWRTC
102220          300; *EXR ST
102222          0=:TMR=:HOWSTAT; 4=:MOSW                  % IGNORE NEXT CHARACTER
102226          GO HODIN
102227   MOSWY: T:=HDEV+BWRTC
102231          100; *EXR ST
102233          307; *EXR ST                              % ENABLE INPUT AGAIN
102235          0=:TMR=:MOSW                              % READ NEXT CHARACTER (IF SYNC)
102237          GO HODIN
102240
102240   *)FILL
102265
102265   % TEST FOR TERMINATION CONDITION
102265
102265   @ICR;
102265   MOSW0: T:=HERSW GOSW FAR GEN0, FAR DCT0, FAR CDC0, FAR GER0, IBM0, VIP0, HASP0,
102276                        FAR NTR0, FAR MSV20, FAR I3270, FAR BTH0, FAR SSAAB,
102303                        FAR UTS0;
102304   @CR;
102304
102304   %      HASP WS :
102304   %
102304   %      MOSW=0, HERSW=6 : SKIP TEST FOR 1. CHAR WHEN HDLC IS USED, HDLC WILL
102304   %                        NOT GIVE AN INTERRUPT BEFORE 2 SYNCS ARE RECEIVED.
102304   %
102304   HASP0: T:=10=:MOSW; GO HASP2
102307   %
102307   %      MOSW=7 : NOT USED IN HDLC
102307   %
102307   HASP1: T:=10=:MOSW; GO HASP2
102312
102312   %
102312   %      MOSW=10 : DECODE BLOCK FOLLOWING SYNC
102312   %
102312   HASP2: IF A=EBSYN GO FAR MODRET
102315          IF A=EBPAD GO FAR MOSWX                   % END OF BLOCK
102320          CALL XPUT
102321          IF A=EBDLE THEN                           % ACK OR TRANSP. TEXT
102324             11=:MOSW
102326          ELSE
102327             IF A=EBSOH THEN                        % ENQ OR NON-TRANSP. TEXT
102332                12=:MOSW
102334             FI
102334          FI
102334          GO FAR MODPIN
102335
102335   %
102335   %      MOSW=11 : TRANSPARENT TEXT OR ACK (STARTS WITH DLE)
102335   %
102335   HASP3: CALL XPUT
102336          IF A=EBSTX THEN                           % TRANSP. TEXT-BLOCK
102341             13=:MOSW
102343          ELSE
102344             GO MOSWX                               % ACK
102345          FI
102345          GO FAR MODPIN
102346
102346   %
102346   %      MOSW=12 : NON-TRANSPARENT TEXT BLOCK OR ENQ (STARTS WITH SOH)
102346   %
102346   HASP4: CALL XPUT
102347          IF A=EBSTX THEN                           % TEXT-BLOCK WITH CRC FOLLOWS
102352             15=:MOSW
102354          ELSE
102355             GO MOSWX                               % ENQ
102356          FI
102356          GO FAR MODPIN
102357
102357   %
102357   %      MOSW=13 : TRANSPARENT TEXT BLOCK ENDED WITH DLE+ETB+CRC+CRC+PAD
102357   %
102357   HASP5: CALL XPUT
102360          IF A=EBDLE THEN MIN MOSW FI               % ETB MAY FOLLOW
102364          GO FAR MODPIN
102365
102365   %
102365   %      MOSW=14 : DLE WAS READ IN TRANSP. TEXT MODE, CHECK IF NEXT IS ETB
102365   %
102365   HASP6: CALL XPUT
102366          IF A=EBETB THEN                           % ETB : 2 CRC FOLLOWS
102371             16=:MOSW
102373          ELSE
102374             13=:MOSW                               % RESET DLE-MODE
102376          FI
102376          GO FAR MODPIN
102377
102377   %
102377   %      MOSW=15 : NON-TRANSPARENT TEXT BLOCK ENDED WITH ETB+CRC+CRC+PAD
102377   %
102377   HASP7: CALL XPUT
102400          IF A=EBETB THEN MIN MOSW FI
102404          GO FAR MODPIN
102405
102405   %
102405   %      MOSW=16 : 1. CRC CHARACTER
102405   %
102405   HASP8: CALL XPUT
102406          MIN MOSW; GO FAR MODPIN                   % READ NEXT CRC
102410
102410   %
102410   %      MOSW=17 : 2. CRC CHARACTER
102410   %
102410   HASP9: CALL XPUT
102411          GO FAR MOSWX                              % END OF BLOCK
102412
102412   *)FILL
102431
102431   %      VIP CONTROL (HONEYWELL-BULL INTERACTIV TERMINALS)
102431
102431   VIP0:  IF A=0 OR =ASSYN GO FAR MODRET
102435          CALL XPUT
102436          IF A/\177=ASETX THEN
102442             T:=2=:MOSW; GO FAR MODPIN              % BCB WILL FOLLOW AFTER ETX
102445          FI
102445          IF A=ASEOT GO FAR MOSWX                   % EOT : END OF BLOCK
102450          GO FAR MODPIN
102451
102451   % IBM 3780/2780 II WITH TRANSPARENT MODE
102451   IBM0:IF T:=XTERM=0 THEN
102454   % NOT IN TEXT MODE
102454           IF A=EBSYN GO FAR MODPIN   % SYNC CHARS NOT TO BUFFER
102457           CALL XPUT                  % PUT CHAR TO RING BUFFER
102460           IF A=EBSTX THEN
102463             0=:TRFL;IF DLINI>0 THEN MIN TRFL;FI      % SET IF TRANSPARENT
102470             0=:DLINI; MIN XTERM                      % SET TEXT MODE
102472           ELSE
102473             0=:DLINI;IF A=EBDLE THEN MIN DLINI;FI    % THIS WAS DLE
102500             IF A=EBPAD GO FAR MOSWX                  % TERMINATE ON PAD
102503           FI
102503        ELSE
102504   % TEXT MODE, SPECIAL TEST FOR TERMINATOR
102504           CALL XPUT                                 % CHAR TO BUFFER
102505           IF A=EBDLE THEN DLINI;*BSET BCM 0 DA      % COMPLEMENT ON DLE
102512             A=:DLINI
102513           ELSE
102514              IF T:=TRFL=0 OR T:=DLINI>0 THEN
102522   % TEST FOR TERMINATOR
102522                 IF A=EBETB OR =EBETX OR =EBIUS THEN
102533                    A=:XTERM;0=:DLINI
102535                    T:=1=:MOSW   % TERMINATOR FOUND, NEXT IS 1. BLOCK CHECK CHAR
102537                 FI
102537              FI
102537           FI
102537        FI
102537        GO FAR MODPIN
102540   *)FILL
102546   % MOSW=1:
102546   IBM1:   CALL XPUT                   % 1. BLOCK CHECK CHAR
102547           MIN MOSW;GO FAR MODPIN
102551   % MOSW=2:
102551   IBM2:   CALL XPUT                   % 2. BLOCK CHECK CHAR
102552           0=:MOSW
102553           IF XTERM=EBIUS THEN
102557             GO FAR MODPIN             % 2780 RECORD TERMINATOR,CONTINUE
102560           FI
102560           0=:XTERM
102561           IF HERSW=5 GO FAR MODPIN        % VIP
102565
102565           GO FAR MOSWX                % TERMINATE BLOCK AND ACTIVATE PROGRAM
102566   *)FILL
102571   %      GERTS-115
102571
102571   GER0:  IF A=0 OR =ASSYN OR =377 GO FAR MODRET
102600          CALL XPUT
102601          A/\177
102602          IF A=ASETX THEN T:=3=:MOSW FI             % ETX : BCB WILL FOLLOW NEXT
102607   % *"8KGS
102607   %        IF A=ASEOT OR A=ASNAK OR A=ASDLE GO FAR MOTERMF
102607   % *"8HMO1+8HMO2+8HMO3+8HMO4+8HMO5+8HMO6
102607          GO FAR MODPIN
102610   %
102610   %      UNIVAC NTR
102610   %
102610   NTR0:  CALL XPUT
102611          IF A=ASETX THEN 3=:MOSW FI                % ETX : BCB WILL FOLLOW NEXT
102616          GO FAR MODPIN
102617
102617   *)FILL
102624
102624   %
102624   %      CD-200-USER
102624   %
102624   CDC0:  GO GER0
102625   %
102625   %      NOT DEFINED
102625   %
102625   GEN0:  GO GER0
102626   %
102626   %      DCT-2000
102626   %
102626   DCT0:  IF =0 OR =ASSYN OR =377 GO FAR MODRET
102635          CALL XPUT
102636          A/\177
102637          IF A=ASETX OR =ASEOT OR =ASACK OR=ASNAK OR=ASBEL OR =ASDC1 THEN
102661             3=:MOSW                                % AFTER ETX,EOT,ACK,NAK,BELL,DC1 : 1 BCC
102663          FI
102663          GO FAR MODPIN
102664   %
102664   %      SIEMENS MSV2
102664   %
102664   MSV20: IF A=ASSYN GO MODRET
102667          CALL XPUT
102670          IF A/\177=ASETX OR =ASETB OR =ASUS THEN MIN MOSW FI % READ 2 CRC NEXT
102703          IF A=177 GO FAR MOSWX                               % END OF BLOCK
102706          GO MODPIN
102707
102707   %
102707   %      IBM-3270 EMULATOR
102707   %
102707
102707   I3270: IF A=EBSYN GO MODRET
102712          CALL XPUT
102713          IF A=EBSTX THEN T:=6=:MOSW FI             % STX : SET TEXT MODE
102720          IF A=EBEOT GO FAR MOSWY                   % EOT : NEW SYNC MAY FOLLOW
102723          IF A=EBPAD GO FAR MOSWX                   % ENDING PAD
102726          GO MODPIN
102727   %
102727   %      MOSW=6 : 3270 IN TEXT MODE
102727   %
102727
102727
102727   I3271: CALL XPUT
102730          IF A=EBETX OR =EBETB THEN T:=1=:MOSW FI   % ETX/ETB : 2 CRC WILL FOLLOW
102740          GO MODPIN
102741
102741   %
102741   %      BTH/VIP 7750 INTERACTIVE TERMINALS
102741   %
102741   BTH0:  IF A=0 GO MODRET
102742          IF A=377 GO FAR MOSWX                     % PAD : END OF BLOCK
102745          CALL XPUT
102746          A/\177
102747          IF A=ASETX OR =ASETB THEN                 % ETX/ETB : BCC NEXT
102755             2=:MOSW; GO MODPIN
102760          FI
102760          IF A=ASEOT GO FAR MOSWX                   % EOT
102763          GO MODPIN
102764
102764   *)FILL
102773
102773   %
102773   %      STANSAAB, ISO-1745 LINE PROCEDURE.
102773   %
102773
102773   SSAAB: T:=177/\A=:D
102776          IF D=0 OR D=ASSYN GO MODRET
103003          IF D=ASEOT OR D=ASNAK GO FAR MOSW3        % EOT/NAK : END OF BLOCK
103011          CALL XPUT; A/\177
103013          IF A=ASDLE OR A=ASETX THEN 3=:MOSW FI     % DLE/ETX : 1 BCC WILL FOLLOW
103023          GO MODPIN
103024
103024   %
103024   %      UNIVAC UTS-400 EMULATOR
103024   %
103024   UTS0:  IF A=0 OR =ASSYN OR =377 GO FAR MODRET     % UTS-400
103033          CALL XPUT
103034          IF A/\177=ASETX THEN 3=:MOSW; FI          % AFTER ETX : 1 BCC
103042          GO MODPIN
103043
103043   MODPIN:
103043   MODRET: 305/\HDXOK; T:=HDEV+BWRTC;*EXR ST
103050          -2=:TMR
103052          GO HODIN
103053   %
103053   % DRIVER FOR MODEM OUTPUT
103053   MODXX: 1; T:=HDEV+BWTCR; *EXR ST       % SEND SECOND SYN CHAR
103057          105; T+"BWTTC-BWTCR"; *EXR ST
103062          CALL ID12
103063          A:=0; T:=HDEV+BWTCR; *EXR ST    % CLEAR TSOM , GO ON WITH DATA
103067   %
103067   %      IF THIS DRIVER IS RUNNING AS X21-BIS AND OTHER END IS NORD X21 THEN
103067   %      WE CAN NOT TURN OFF RQTS WHEN TRANSFER IS FINISHED I.E. T:=100 NOT
103067   %      T:=0
103067   %
103067   HODUT: DO;*IOF
103070             IF BHOLD=0 THEN 0=:TMR=:HOWSTAT; T:=0; CALL RTACT; GO HIT FI
103077             T:=MBSYMOD; CALL TDBGET; T:=HDEV+BWTDR;*EXR ST
103104             TTMR=:TMR
103106             T:=107
103107   HIT:      T=:A; T:=HDEV+BWTTC; *EXR ST;ION
103114             CALL ID12                                 % WAIT FOR INTERRUPT
103115             T:=HDEV+BRTTS;*EXR ST; BSKP ONE 10 DA     % READ TRANSMITTER TRANSFER STATUS
103121             GO HODUT
103122   %  UNDERRUN:
103122             A:=1;  T:=HDEV+BWTCR;  *EXR ST            % SEND SYNC
103126             A:=105;T+"BWTTC-BWTCR";*EXR ST
103131             CALL ID12
103132             A:=0;  T:=HDEV+BWTCR;  *EXR ST            % CLEAR TSOM
103136          OD
103137
103137   RBUS
103153   *"
"103153   *"8HDMA
"103153   %==============================================================================
103153   % 38.2       H D M O D R I V
103153   %
103153   %
103153   % DRIVER FOR HDLC - BSC/DMA, LEVEL 12 (OUTPUT)
103153   %
103153
103153   SUBR HDMODRIV
103153
103153   INTEGER 9LREG,9TREG,9AREG,9DREG,9XREG
103160   REAL 9TADREG=9TREG
103160
103160   SYMBOL HDHDX=5,HDRFS=6,HDMSCE=200,BROCK=10,BLOVF=13
103160   DISP -44; INTEGER HCTRL,HMOD; PSID
103160
103160   HDMODRIV:
103160          X=:9XREG; TAD=:9TADREG; A:=L=:9LREG
103164          IF 9TREG/\77=52 THEN
103171             A:=120
103172          ELSE
103173             HCTRL
103174          FI
103174          T:=HDEV+13; *EXR ST
103177          IF 9TREG/\77=1 THEN                      % SEND DATA
103204             9AREG; T:=HDEV+15; *IOF; EXR ST
103211             9TREG SH -12/\37+2000; T+2; *EXR ST; ION
103220   9CONT:    CALL ID12; T:=HDEV+12; *EXR ST
103224             IF A NBIT BROCK THEN
103226                A=:X:=164; GO 9ERROR                % DMA-ERROR
103231             FI
103231             IF A BIT BLOVF THEN
103233                A=:X:=237; GO 9ERROR
103236             FI
103236             IF HCTRL BIT HDHDX THEN
103241                HDMSCE; T:=HDEV+13; *EXR ST
103245                T-1; *EXR ST
103247                IF A BIT HDRFS THEN CALL ID12 FI
103252             FI
103252   9OK:      T:=9LREG+2=:P
103255          ELSE
103256             IF A=55 THEN                           % SEND CONTROL BLOCK
103261                9AREG; T:=HDEV+15; *IOF; EXR ST
103266                9TREG SH -12/\37+1400; T+2; *EXR ST; ION
103275                GO 9CONT
103276             ELSE
103277                IF A=52 THEN                        % INITIALIZE
103302                   9AREG; T:=HDEV+15; *IOF; EXR ST
103307                   9TREG SH -12/\37+3400; T+2; *EXR ST; ION
103316                   CALL ID12; A:=100; T:=HDEV+11; *EXR ST     % SET DTR
103323                   T:=HDEV+12; *EXR ST
103326                   GO 9OK
103327                ELSE
103330                   A:=174; X:=0; GO 9ERROR
103333                FI
103333             FI
103333          FI
103333
103333   9BUSY:
103333          T:=9LREG+1=:P
103336
103336   9ERROR:
103336          T:=9LREG=:P
103340
103340   RBUS
103350
103350
103350   %==============================================================================
103350   % 38.3       H D M I D R I V
103350   %
103350   % DRIVER FOR HDLC - BSC/DMA, LEVEL 13 (INPUT)
103350   %
103350
103350   SUBR HDMIDRIV
103350
103350   INTEGER 9LREG
103351
103351   SYMBOL HDHDX=5,HDRFS=6,HDMSCE=200,BROCK=10,CRCER,FORMER,BLOVF
103351   DISP -44; INTEGER HCTRL,HMOD; PSID
103351   DISP -40; INTEGER HSPFL; PSID
103351
103351   HDMIDRIV:
103351          TTMR=:TMR
103353          IF HSPFL><0 THEN
103355             IF A NBIT BROCK THEN                   % BLOCK END ?
103357                GO 9BUSY                            % NO, WAIT FOR INTERRUPT
103360             FI
103360             IF A BIT CRCER THEN
103362                A=:X:=170; GO 9ERROR                % FORMAT ERROR
103365             FI
103365             IF A BIT FORMER THEN
103367                A=:X:=236; GO 9ERROR                % FORMAT ERROR
103372             FI
103372             IF A BIT BLOVF THEN
103374                A=:X:=163; GO 9ERROR                % BLOCK OVERFLOW
103377             FI
103377          ELSE
103400             GO 9TBUS                               % FLAG NOT SET
103401          FI
103401
103401   9OK:   IF RTRES><0 THEN
103403             0=:HSPFL=:TMR; CALL RTACT
103406          FI
103406   9BUSY: CALL ID13
103407   9TBUS: T:=HDEV+10; *EXR ST
103412          IF A NBIT BROCK GO 9BUSY
103414          A=:HSPFL; GO HDMIDRIV
103416   9ERROR:
103416          A=:CERRCODE; X BONE 4=:HSTAT; GO 9OK
103422
103422   RBUS
103426   *"
"103426   *"8CRD+8CRD2
"103426   *"7NDDI
"103426   @DEV 1
103426   @DEV (S-S-L)MP-P2-HDLC-DRIV:NPL
103426   *"8CXHD
"103426

103426   %=======================================================================
103426   % 40.10
103426   %      H D S T A    L T O U T    B A C K      S B Y T C
103426   %      F A L S E    D R E R R    R B Y T C    R A C T B
103426   %
103426   %      H D L C - DRIVER.    COMMON PART
103426   %
103426   %=======================================================================
103426
103426   %PURPOSE:    TRANSMITT DATA, AND CONTROLE THE OUTPUT PART
103426   %            OF THE HDLC DAM-INTERFACE.
103426
103426   %ENTRY:      B-REG - DATAFIELDPOINTER
103426   %            MESSAGE:        FUNCTION
103426   %                            STATUS
103426   %                            APPROPRIATE ADDITIONAL INFO
103426
103426   %EXIT:       STAUTS IS GIVEN WITHIN THE MESSAGE SEND
103426   %            BACK TO USER.
103426
103426   %OPERATION:  THIS COMMON PART IS ACTIVATED EVERY TIME A MESSAGE IS
103426   %            SENT FOR ANY HDLC-DRIVER. AN ACTION-ROUTINE WILL BE
103426   %            ACTIVATED ACCORDING TO THE FUNCTION IN THE MESSAGE.
103426   %            THE RESULTS OF DRIVER OPERATIONS IS SENT BACK TO THE
103426   %            USER WITHIN THE SAME MESSAGE.
103426   %            THE USER WILL GET THE RESULTS BY DOING A RECEIVE-MESSAGE
103426   %            COMMAND ON THE SAME PORT AS THE ORIGINAL MESSAGE
103426   %            WAS SENT. HOWEVER, THE RESULTS MAY BE RECEIVED ASYNCHRONOUSLY
103426   %            WITH RESPECT TO THE SENDING OF MESSAGES.
103426   %
103426   %
103426   %ACTIVATION POINT
103426   %
103426   SUBR   HDSTA,LTOUT,BACKX,SBYTC,FALSE,DRERR,RBYTC,RACTB,XMPAT,SADTS,SCRET
103426   INTEGER ARRAY HDENT:=(SMCLEAR,SIDAT,SIRES,SMCLEAR,HDSIN,SPSTA,XSSND,XSHDR) % *H*
103436   HDSTA: CALL DICHAIN;                             %WAIT FOR MESSAGE
103437   FALSE: CALL WTADR                                %ENTRY IF FALSE INTERRUPT
103440          CALL RBYTC                                %MESSAGE LENGTH IN T-REG
103441          IF A>=6 THEN GO MSOK FI
103445          IF A>=4 THEN                              % Message too small
103450             ETOSM;      X:=X+BHEAD;                % X-reg points to XCFUNC
103452             CALL SCRET; X:=X-BHEAD                 % X-reg points to XCHAIN
103454          FI
103454          CALL OCHAIN; GO HDSTA
103456   MSOK:  X + BHEAD =: OMSG                         %CURRENT MESSAGE POINTER
103460   %
103460   %      GO TO ACTION ROUTINE
103460   %
103460          IF HXDOK ><X21OP THEN ELOCK; GO BACKX FI   % CHECK IF LOCKED BY X21
103466          T:=MASTB; * XCFUN@3 LDATX
103470          IF X:=A >> DRBI THEN               % *81F*
103474   HDEFR:    EILFNC
103475          ELSE
103476             *1BANK
103477             HDENT(X); *2BANK
103501             X:=OMSG; A=:P
103503          FI
103503   %
103503   %      EXIT SEQUENCE
103503   %
103503   %      B-REG - DATAFIELD POINTER
103503   %      OMSG -  CURRENT MESSAGE
103503   %      A-REG - RETURN STATUS INFO
103503   %
103503   BACKX: X:=OMSG; T:=MASTB; * CRET@3 STATX
103506          X-BHEAD; T:=6; CALL SBYTC
103511          CALL OCHAIN
103512          GO HDSTA
103513   %
103513   %
103513   SIDAT: GO SRDAT                                  % JMP THROUGH DATAFIELD
103514   SIRES: CALL SRREST; GO BACKX
103516
103516   %      ENTRY: X POINTS TO DMA LIST ENTRY
103516   %             T - FRAME LENGTH+DISP1 (IF XMSG) OR TOTAL DCB LENGTH (IF NOT XMSG)
103516   %      THE CORRESPONDING DCB ENTRY IS FOUND IN THE DCBLIST
103516   %      THE DCB LENGTH OR FRAME LENGTH IS SAVED IN THE DCB
103516   %      EXIT: X POINTS TO THE DCB (USER PART)
103516
103516   XMPAT: 0=:X.LBYTC; A:=X-LISTP SHZ -2=:X
103523          * AAX DCBX; LDX 0,X,B                     % NOW X POINTS TO DCB
103525          T=:D:=MASTB; X - BHEAD; * BBID@3 LDATX
103531          IF A < 0 THEN                            % IS IT AN XMSG DCB ?
103532            A:=D; X + BHEAD; *XHBYT@3 STATX         % YES, SAVE FRAME LENGTH + DISP1
103535          ELSE
103536            A:=D+BCHEA; * BBYTC@3 STATX            % NO, SAVE TOTAL DCB LENGTH
103541            X + BHEAD
103542          FI; EXIT
103543   %
103543   %      INTERNAL TIMOUT
103543   %
103543   LTOUT: *JPC LOUT; EXIT
103545   LOUT:  A:=ETOU2; T:=MASTB; X:=OMSG; *ADSTA@3 STZTX; ION
103552          GO BACKX
103553   %
103553   %      STORE BYTECOUNT IN MESSAGE
103553   %
103553   SBYTC: T=:A:=MASTB; * BBYTC@3 STATX
103556          EXIT
103557   %
103557   %      STORE HW STATUS
103557   SADTS: T:=MASTB; * ADSTA@3 STATX
103561          EXIT
103562   %
103562   %      STORE STATUS
103562   SCRET: T:=MASTB; * CRET@3 STATX
103564          EXIT
103565   %
103565   %
103565   %      READ ACTUAL BYTECOUNT OF MESSAGE
103565   %
103565   RACTB: T:=MASTB; * BBYTC@3 LDATX
103567          EXIT
103570   %
103570   %      READ MAX BYTECOUNT OF MESSAGE
103570   %
103570   RBYTC: T:=MASTB; * BMBYT@3 LDATX
103572          EXIT
103573   %
103573   %
103573   %      XSSDATA ERROR ROUTINE
103573   %
103573   %ENTRY:      A-REG           HARDWARE STATUS
103573   %            B-REG           DATAFIELDPOINTER
103573   %            X-REG           MESSAGE ADDRESS
103573   %
103573   DRERR: A\/DSTAT =: DSTAT                         %OR HW-STATUS
103575          HDERC+1 =: HDERC                          %ERROR COUNTER
103600          MIN RTDYN; GO SRDAT                       %TRY AGAIN
103602          XRETRY=:RTDYN; EXIT                        %TO MANY ERRORS, GIVE UP
103605   RBUS
103616
103616   SUBR ZXCHK
103616   %
103616   %      ZXCHK - CHECK XMSG DCB AND INTERFACE INITIALISED
103616   %
103616   ZXCHK: T:=MASTB; X-BHEAD; *BBID@3 LDATX
103621          X+BHEAD
103622          IF A > 0 THEN EILFNC; GO BACKX  FI        % THIS FUNCTION IS ONLY FOR XMSG *H*
103626          IF INTSTA >< 2 THEN ENINIT; GO BACKX FI
103634          EXIT
103635   RBUS
103636

103636   %=======================================================================
103636   % 40.11     X S D A T A    H O I N T    O I N I T    P O F T O
103636
103636   %
103636   %PURPOSE: TRANSMITT DATA TO REMOTE MACHINE
103636   %
103636   %OPERATION:  RECEIVES MESSAGES CONTAINING DATA TO BE SENT TO
103636   %            REMOTE MACHINE. THE RESULTS OF THE TRANSFER IS SENT
103636   %            BACK TO USER IN THE SAME MESSAGE.
103636   %
103636   %MESSAGE DECRIPTION:
103636   %         - FUNCTION = DATA
103636   %         - STATUS   = RET-STATUS
103636   %         - ADDSTA   = HARDWARE STATUS
103636   %         - DATA     = DATA TO BE TRANSMITTED / DMA LIST POINTER *81F*
103636   %
103636   SUBR XSSDATA,HOINT,POFTO,XSSND
103636          INTEGER SNDAC=?
103636          DISP 0; INTEGER AC; PSID
103636   XSSDATA: IF INTSTA >< 2 THEN A:=ENINIT; GO BACKX FI
103644          LISTP =: LIINT                            % *81F*
103646          X-BHEAD; CALL RACTB; X+BHEAD              % MESSAGE SIZE
103651          IF A < 7 THEN A:=EILFZ; GO BACKX FI       % MESSAGE IS TOO SMALL
103656          IF A-BCHEA>MAXR THEN A:=EILSIZ; GO BACKX FI  % TOO LONG FRAME
103664          A-DISP1=:LIINT.LBYTC                      % BYTECOUNT FOR LIST
103667          A:=OMSG+CHEAD=:X.LMEM2=:D                 % SET BUFFER ADDR.
103673          T:=MASTB=:X.LMEM1                         % PHYSICAL BANK IN LMEM2 AND IN T
103675          FSERM=:X.LKEY                             % TRANSMIT ONE BLOCK ONLY
103677          D=:X
103700          *LDATX
103701          A=:SNDAC
103702          0=:D                                      % *81F*
103703   %
103703   %      START INTERFACE
103703   %
103703   XHMST: LIINT+DPITPHYS;
103705   XXHMST:T:=HDEV+WDMA; *IOF; EXR ST%LIST ADDRESS *81F*
103711          A:=2000\/D; T+"WDCR-WDMA"; *EXR ST        %START TRANSMITTER  *81F*
103715          T+"RDCR-WDCR"; X:=-20;*EXR ST
103720          CALL LTOUT; *JAF *-2; ION
103723          1134+CMODI; T:=HDEV+WTTC; *EXR ST
103730          1 =: ACTSW                                % *H*
103732          OMSG =: DCBX
103734   %
103734   %      ENABLE TIMEOUT
103734   %
103734   CONT:  A:=TTMR=:TMR
103736          CALL ID12                                 %WAIT FOR INTERRUPT
103737          GO HOINT; *)FILL
103750
103750   %
103750   %      OUTPUT INTERRUPT DETECTED,
103750   %      GET STATUS
103750   %      LOG STATUS, DEVICE NUMBER AND 1.WORD IN FRAME
103750   %      SEND FRAME TO USER
103750
103750          INTEGER TELL:=0
103751          INTEGER DUIN:=0                           % INCREMENTED IF DUMMY INTERRUPTS *H*
103752          SYMBOL BUFSIZ=20
103752          SYMBOL TELMA=BUFSIZ-1
103752          INTEGER ARRAY BUFF0(BUFSIZ)               % 1.WORD IN FRAME
103772          INTEGER ARRAY BUFF1(BUFSIZ)               % DEVICE NUMBER
104012          INTEGER ARRAY BUFF2(BUFSIZ)               % DEVICE STATUS
104032          INTEGER SNDAC:=0                          % AC FIELD OF BUFFER TO TRANSMIT
104033
104033   %
104033   HOINT: 0=:TMR                                    %RESET TIMER
104034          T:=HDEV+RTTS; *EXR ST                     %READ STATUS
104037          A=:HASTAT                                 %SAVE STATUS
104040          IF T:=ACTSW = 0 THEN MIN DUIN; P+0; CALL WT12 FI         % *H*
104046          0=: ACTSW                                 % *H*
104047          IF CMODI = 40 THEN
104053            T:=HDEV+WTTC; *EXR ST   %TURN OFF RQTS
104056          FI
104056          GO HNOTRA                         % PATCH IF TRACE IS WANTED
104057          MIN TELL; P+0
104061          TELL /\ TELMA=:TELL
104064          A:=SNDAC                          % GET FIRST WORD IN FRAME
104065          X:=TELL; *1BANK
104067          A=:BUFF0(X); *2BANK               % LOG 1.WORD IN FRAME  (BANK 0 ONLY) *81F*
104071          HDEV; *1BANK
104073          A=:BUFF1(X); *2BANK               % LOG DEVICE USED
104075          HASTAT; *1BANK
104077          A=:BUFF2(X); *2BANK               % LOG DEVICE STATUS
104101   HNOTRA:X:=OMSG
104102          IF A/\ "SILFO+TXUND" = 0 THEN
104104                XRETRY=:RTDYN; A:=0; CALL SADTS
104110          ELSE
104111                A:=HASTAT; CALL SADTS; CALL DRERR
104114                A:=EUND
104115          FI
104115          0=:DCBX; GO FAR BACKX
104117   %
104117   %
104117   %      OUTPUT TIMEOUT ROUTINE
104117   %
104117   POFTO: X:=OMSG; 0=:DCBX
104121          A:=CMODI; T:=HDEV+WTTC; *EXR ST
104125          A:=0; CALL SADTS; A:=ETOU1; GO FAR BACKX
104131   %
104131   %      SPECIAL ENTRY FOR PRIVILEGED USERS (MESSID<0)       *81F*
104131   %      THE FIRST TWO DATA WORDS OF THE DCB POINTS TO A
104131   %      TRANSMITTER LIST. THE LIST IS USED DIRECTLY BY HARDWARE.
104131   %
104131   XSSND: CALL ZXCHK                                % CHECK DCB IS FROM XMSG
104132          T:=MASTB; *XMLIS@3 LDDTX
104134          % SUBRTRACT FIRST PAGE NO OF DPIT TO IT RIGTH IN XMST
104134          A:=:D; A=:LIINT                           % BANK BITS IN D-REG
104136          T:=2000=:L                                % *K*ND-110*
104140          T:=D; A=:X
104142          X+L; *LMEM1@3 LDDTX                       % *K*ND-110*  CACHE MISS
104144          X-L                                       % *K*ND-110*
104145          *LMEM1@3 LDDTX
104146          T:=:A; D=:X; A=:D; *AC@3 LDATX
104152          A=:SNDAC; A:=LIINT
104154          GO FAR XXHMST
104155   RBUS
104171

104171   %=======================================================================
104171   % 40.12     H D R E C    H I I N T    S H D R E
104171   %
104171   %PURPOSE:    RECEIVE DATA FROM REMOTE MACHINE
104171   %
104171   %OPERATION:  RECEIVES EMTY (NO DATA) MESSAGES, WHICH WILL BE LINKED
104171   %            TO THE HDLC RECEIVER LIST. WHEN DATA (FRAMES) IS RECEIVED
104171   %            FROM REMOTE MACHINE, THE MESSAGES ARE FILLED AND SENT
104171   %            BACK TO USER.
104171   %MESSAGE DECRIPTION:
104171   %            - FUNCTION = EDATA
104171   %            - STATUS   = RET-STATUS
104171   %            - ADDSTA   = HARDWARE STATUS
104171   %            - DATA     = RECEIVED DATA
104171   %
104171   SUBR HDREC,HIINT,XSHDR
104171   HDREC: IF INTSTA >< 2 THEN A:=ENINIT; GO FAR BACKX FI
104177          X-BHEAD; CALL RBYTC; X+BHEAD; A-BCHEA     % GET MAX BYTECOUNT
104203          IF A < MAXR THEN A:=ETOSM; GO FAR BACKX FI
104210          CALL HXST                                 %*81F*
104211          A:=X+CHEAD=:D:=MASTB                      %BUFFER ADDRESS     *81F*
104215   HSPEC: X=:T; AD=:LISTF.LMEM                      % *H*
104220          A:=X-LISTP SHZ -2:=:X                     % CALCULATE INDEX IN DCB TABLE *H*
104224          * AAX DCBX; STT 0,X,B                     % SAVE DCB ADDR. IN DCB TABLE *H*
104226          X:=A                                      % X POINTS TO DMA LIST ENTRY *H*
104227          ERB=:X.LKEY                               % *81F*
104231          LISTF+4=:LISTF                            %LIST FILLER OF NEXT MESSAGE
104234          A:=2000; X:=LISTF+A; X.LKEY               % *K*ND-110* CACHE MISS
104240          IF LISTF.LKEY=NLP THEN
104245                LISTP=:LISTF                        %REACHED END OF LIST
104247          FI
104247          IF ACTSW = 1 THEN GO FAR HDSTA FI         % TRANSMITTER ACTIVE
104254   HDENA:
104254   *CCM09, TRR 10                                   % CLEAR CACHE
104255          A:=2000; X:=LIINT+A; X.LKEY               % *K*ND-110* CACHE MISS
104261          IF LIINT.LKEY/\"3777"><"ERB" THEN
104267                GO FAR HDSTA                        % DO NOT START EMPTY LIST
104270          FI
104270   ZSTARC: IF ACTSW = 0 THEN
104272                 HXDOK/\MAINT; T:=HDEV+WRTC; *EXR ST  % CLEAR OLD GARBAGE
104277                 % ADD DPITPHYS TO GET PHYSICAL ADDRESS
104277                 LIINT+DPITPHYS; T:=HDEV+WDMA; *EXR ST% START RECEIVER
104304                 A:=1001; T+"WDCR-WDMA"; *EXR ST
104307                 T+"RDCR-WDCR"; X:=-10; *EXR ST
104312                 CALL LTOUT; *JAF *-2
104314                 1=:ACTSW
104316          FI
104316   OUT1:  A:="1734"\/MAINT/\HXDOK
104321          T:=HDEV+WRTC; * EXR ST
104324          GO FAR HDSTA                              %ANY MORE MESSAGES ?
104325          *)FILL
104340   %
104340   %
104340   %      INPUT INTERRUPT DETECTED:
104340   %            GET STATUS
104340   %            LOG STATUS, USER DEVICE NUMBER AND 1.WORD IN FRAME
104340   %            SEND MESSAGE BACK TO USER.
104340   %
104340   %
104340
104340          DISP 0; INTEGER AC; PSID
104340          SYMBOL BUFSIZ=20
104340          SYMBOL TELMA=BUFSIZ-1
104340          INTEGER ARRAY BUFF0(BUFSIZ)               % 1.WORD IN FRAME
104360          INTEGER ARRAY BUFF1(BUFSIZ)               % DEVICE NUMBER
104400          INTEGER ARRAY BUFF2(BUFSIZ)               % DEVICE STATUS
104420          INTEGER ARRAY BUFF3(11)                   % LIST KEYS WHEN DEVICE STOPPED
104431          INTEGER T1:=0
104432          INTEGER T2:=0
104433          INTEGER TELL:=0
104434          INTEGER T9:=0                             % DUMMY INTERRUPTS
104435          INTEGER ARRAY POINTER P0BUFF:=BUFF0
104436   HIINT: T:=HDEV+RRTS; *EXR ST                     % READ RECEIVER STATUS
104441          A=:HASTAT
104442          IF T:=ACTSW = 0 THEN MIN T9; P+0; GO OUT1 FI % EXPECTING NOTHING *81F*
104450          IF A/\ HX21M >< 0 THEN                    % X21-ERROR?
104452   *CCM10,   TRR 10                                 %*80B*
104453             T:=2000; X:=LIINT+T; T:=X.LKEY         % *K*ND-110* CACHE MISS
104457             A\/ LIINT.LKEY=:X.LKEY                 % YES, SAVE IT *H*
104462             IF A BIT HX21S THEN                    % X21 CLEAR INDICATION?
104464                HASTAT BONE BLDON=:HASTAT           % YES, SET BLOCK DONE TO
104467                LIINT.LKEY BONE XBLDN=:X.LKEY       % TO TERMINATE
104473             FI
104473          FI
104473          IF HASTAT/\"EMTY" >< 0 THEN
104476                0=:ACTSW                            % DEVICE STOPPED
104477                MIN STPCNT                          % LACK OF BUFFER, INC COUNTER
104500                P+0                                 % IN CASE OF SKIP
104501                LISTP=:T1; 0=:T2
104504                DO
104504                   T:=2000; X:=T1+T; X.LKEY         % *K*ND-110* CACHE MISS
104510                WHILE T1.LKEY >< "NLP"              % MAKE COPY OF DMA LIST
104515                   X:=T2; *1BANK
104517                   A=:BUFF3(X); *2BANK              % WHEN DEVICE STOPPED
104521                   MIN T2; 0/\0; T1+4=:T1
104526                OD
104527          FI
104527   %
104527   %      LOOK AT RECEIVER MESSAGE
104527   %
104527   MORE:
104527   *CCM11,TRR 10                                    % CLEAR CACHE
104530          A:=2000; X:=LIINT+A; X.LKEY               % *K*ND-110* CACHE MISS
104534          A:=LIINT.LKEY=:D
104537          IF A NBIT XBLDN THEN                       % ANY MORE FILLED BLOCKS ?
104541                IF A = "ERB" THEN GO FAR ZSTARC FI   % NO, ENABLE RECEIVER
104545                GO FAR OUT1
104546          FI
104546          GO HNOTRA                                 % PATCH IF TRACE IS WANTED
104547          MIN TELL; P+0
104551          TELL /\ TELMA=:TELL=:X
104555          HDEV; *1BANK
104557          A=:BUFF1(X); *2BANK                       % LOG USER DEVICE NUMBER
104561          HASTAT; *1BANK
104563          A=:BUFF2(X); *2BANK                       % LOG DEVICE STATUS
104565          T:=LIINT.LMEM1; X:=X.LMEM2; *AC@3 LDATX
104571          X:=TELL; *1BANK
104573          A=:P0BUFF(X); *2BANK                      % LOG 1.WORD IN FRAME
104575          GO HNOTRA; *)FILL
104611   HNOTRA: X:=LIINT; A:=2000; X+A; X.DLSTS          % *K*ND-110* CACHE MISS;  LKEY & LBYTC
104615          A:=LIINT.LBYTC+DISP1=:T                   % RECEIVED MESSAGE SIZE
104621          CALL XMPAT                                % *H* GET DCB FROM DCB LIST
104622          X=:L; A:=LIINT.LKEY=:D; 0=:X.LKEY; 0=:X.LMEM2;  X:=L
104631          IF A /\ "LMASK" = 3 THEN
104635                A:=0; CALL SCRET; CALL SADTS
104640          ELSE
104641                IF A BIT HX21S THEN EX21 ELSE EINP FI
104646                CALL SCRET
104647                A:=D; CALL SADTS; A\/DSTAT=:DSTAT
104653                HDERC+1=:HDERC
104656          FI
104656          X-BHEAD; CALL OCHAIN                               % SEN MESSAGE BACK TO USER
104660          LIINT+4=:LIINT
104663          A+2000; A.LKEY                                     % *K*ND-110* CACHE MISS
104666          IF LIINT.LKEY=NLP THEN
104673                LISTP=:LIINT
104675          FI
104675          GO MORE
104676          *)FILL
104705   %      ARE WE RUNNING ?
104705   HXST:  IF ACTSW = 0 THEN
104707            LISTP=:LISTF=:LIINT
104712              ELSE
104713            IF LISTF=LIINT THEN A:=ETOMUCH; GO FAR BACKX FI
104721          FI
104721          EXIT
104722   %
104722   %      SPECIAL ENTRY FOR PRIVILEGED USERS (MESSID<0)
104722   %      FIRST TWO DATA WORDS OF DCB POINTS TO RECEIVER BUFFER.
104722
104722   XSHDR: CALL ZXCHK                                % CHECK DCB IS FROM XMSG
104723          CALL HXST
104724          T:=MASTB; * XHBUF@3 LDDTX
104726          GO FAR HSPEC
104727          RBUS
104733

104733   %=======================================================================
104733   % 40.13     S M C L E A R
104733
104733   %
104733   %PURPOSE:    TOTAL CLEAR OF INTERFACE
104733   %
104733   %OPERATION:  PERFORMS A DEVICE CLEAR. UNTREATED MESSAGES
104733   %            ARE SENT BACKX TO USER.
104733   %MESSAGE DECRIPTION:
104733   %         - FUNCTION = MCLEAR
104733   %         - NOT APPLICABLE
104733   %
104733   %ENTRY:   B-REG DATAFIELDPOINTER
104733   SUBR SMCLEAR
104733   SMCLEAR: T:=HDEV+WTCR; A:=2; *EXR ST             % SEND EOM TO AVOID YELLOW LIGTH
104737          * TRR 10; IOF                             % CLEAR CACHE
104741          A:=100; T:=HDEV+WRTC; *EXR  ST            %*80B*
104745          A:=140; *EXR ST                           %*80B*    KEEP DTR/C HIGH
104747          T+"WDCR-WRTC";*EXR ST; ION
104752          X:=OMSG; T:=MASTB; * XCFUN@3 LDATX
104755          IF A = 0 THEN                             % SPECIAL CLEAR (SUPER) *H*
104756            0=: HINIF =: OQUEU =: IQUEU =: WAKEF    % CLEAR EVERYTHING
104762            1=:INTSTA                               % TAKE OPPOSITE DATAFILED
104764            IF DFOPP << B THEN  0 =: ACTSW FI       % RESET ACTSW IN INPUT DF
104770            A=:B
104771            0=: HINIF =: OQUEU =: IQUEU =: WAKEF    % CLEAR EVERYTHING
104775            1=:INTSTA
104777            IF DFOPP << B THEN  0 =: ACTSW FI       % RESET ACTSW IN INPUT DF
105003            A=:B
105004            GO FAR HDSTA                            % GIVE NO RESPONCE TO USER
105005          ELSE
105006            1=:INTSTA; CALL SRRES                     %RESET THIS SIDE
105011            DFOPP=:B; 1=:INTSTA; CALL SRRES           %RESET OTHER SIDE
105016            DFOPP=:B; X:=OMSG
105021            A:=0 CALL SADTS GO FAR BACKX
105024          FI
105024   RBUS
105027

105027   %=======================================================================
105027   % 40.14     H D S I N
105027   %
105027   %PURPOSE: INITIATE INTERFACE AND SET MODUS
105027   %
105027   %MESAGE DECRIPTION:
105027   %         - FUNCTION = INIT
105027   %         - STATUS   = RETURN STATUS
105027   %         - ADDSTA   = HARDWARE STATUS
105027   %         - MODUS    = 0 - FULL DUPLEX
105027   %                      1 - HALF DUPLEX
105027   %                      2 - MAINTENANCE MODUS
105027   %         - CFSIZE   = MAX FRAMESIZE
105027   %         - IRTRY    = # OF RETRIES WANTED IF ERROR. NOT APPLICABLE FOR INPUT
105027   %         - IDISP    = DISPLACEMENT IN # OF BYTES
105027   %
105027   %ENTRY:   B-REG DATAFIELDPOINTER
105027   %         X-REG MESSAGE POINTER
105027   %
105027   %EXIT:    AS ENTRY
105027   %
105027   SUBR HDSIN
105027   HDSIN: IF INTSTA><1 THEN A:=ENCLEAR; GO FAR BACKX FI
105035          T:=MASTB; * IMODU@3 LDATX
105037          IF A=:D >> MAMOD THEN A:=EPAR; GO FAR BACKX FI
105045          IF A:=D = HALF THEN T:=40 ELSE T:=0 FI
105054          T=:CMODI                                  %SET HALF OR FULL DUPLEX
105055          IF A = MAMOD THEN A:=140 ELSE A:=100 FI   %*80B*
105063          A=:MAINT
105064          T:=HDEV+WRTC; *EXR ST                     %SET POSSIBLE MAINTENANCE MODE
105067          T:=MASTB; * IFSIZ@3 LDATX
105071          A=:MAXR                                    %MAX RECEIVER FRAMESIZE
105072          IF A < 1 THEN A:=EILFZ; GO FAR BACKX FI    % TOO SMALL MESSAGE
105077          0=:CHECK
105100          T:=MASTB; * IRTRY@3 LDATX
105102          A-=:XRETRY                                 %NUMBER OF RETRYES WANTED
105104          X-BHEAD; CALL RACTB; X+BHEAD
105107          IF A>15 THEN
105112             T:=MASTB; * IDISP@3 LDATX
105114          ELSE
105115             A:=0
105116          FI
105116          A=:DISP1+MAXR=:MAXR
105121          % ADD DPITPHYS TO GET PHYSICAL ADDRESS
105121          A:=XINITA+DPITPHYS; T:=HDEV+WDMA; *IOF; EXR ST
105127          401; T+"WDCR-WDMA";*EXR ST
105132          T+"RDCR-WDCR"; X:=-10;*EXR ST
105135          CALL LTOUT; * JAF *-2
105137          *ION
105140   *CCM12,TRR 10                                    %CLEAR CACHE
105141          A:=2000; B+A; T:=CHECK; B-A               % *K*ND-110* CACHE MISS
105145          A:=CHECK                                  %CHECKSUM FROM INTERFACE
105146          IF A><INTCH THEN
105151                T:=MASTB; X:=OMSG; *ADSTA@3 STATX
105154                A:=EILLINT; GO FAR BACKX
105156          FI
105156          X:=DFOPP                                  %UPPDATE OPPOSITE DATAFIELD
105157          XRETRY=:X.XRETRY
105161          MAXR=:X.MAXR
105163          MAINT=:X.MAINT; DISP1=:X.DISP1
105167          2=:X.INTSTA
105171          2=:INTSTA; A:=0; X:=OMSG; CALL SADTS; GO FAR BACKX
105177   RBUS
105206

105206   %========================================================================
105206   % 40.15     T R A S E T    R E C S E T
105206
105206   %PURPOSE:    RESET TRANSMITTER
105206   %CHANGES FOR H VERSION: THE DCB FOR XMSG MAY CONTAIN A POINTER TO A DMA LIST,
105206   %                       THUS THE DCB LIST MUST BE USED FOR TAPPING
105206   SUBR TRASET,RECSET
105206   TRASET:      A:=0
105207          T:=HDEV+WTTC; *EXR ST
105212          A:=L=:XREENT; 0=:WAKEF
105215          IF X:=DCBX >< 0 THEN                      % ANY CURRENT DCB ?
105217            0=:DCBX; ECLEAR; CALL SCRET             % YES, SEND IT BACK
105222            A:=0; CALL SADTS; X-BHEAD; T:=6; CALL SBYTC; CALL OCHAIN
105230          FI
105230          0=:TMR
105231          A:=XREENT=:P
105233   %
105233   %      RECSET
105233   %
105233   %PURPOSE:    RESET RECEIVER
105233   %
105233   RECSET:      A:=MAINT\/100                       %*80B*
105235          T:=HDEV+WRTC; *EXR ST
105240          0=:TMR; GO SENDB
105242          GO SENDB
105243   %
105243   %      SENDB
105243
105243   %PURPOSE:    SEND BACK (TO USER) UNTREATED MESSAGES
105243   %
105243   SENDB: LISTP=:LIINT
105245          A:=L=:XREENT                               % TEMP SAVE OF L-REG
105247          DO
105247             X:=LIINT; A:=2000; X+A; X.LKEY          % *K*ND-110* CACHE MISS
105253          WHILE LIINT.LKEY >< "NLP"
105260                IF A >< 0 THEN                       % *H*
105261                     A:=2000; X+A; T:=X.LMEM2; X-A   % *K*ND-110* CACHE MISS
105265                     IF X.LMEM2 >< 0 THEN            % WE DO NOT TRUST THE KEY
105267                                0=:X.LMEM2
105270                                0=:X.LKEY=:X.LBYTC   % X POINTS TO DMA ENTRY
105272                                T:=0; CALL XMPAT     % FIND DCB ENTRY AND SET LENGTH
105274                                ECLEAR; CALL SCRET   % X POINTS TO DCB
105276                                A:=0; CALL SADTS
105300                                X-BHEAD; T:=6; CALL SBYTC
105303                                CALL OCHAIN
105304                      FI
105304                FI
105304                LIINT+4=:LIINT
105307          OD
105310          A:=XREENT=:L
105312          A:=0=:ACTSW
105314          EXIT
105315   RBUS
105325

105325   %=======================================================================
105325   % 40.16     S P S T A
105325   %
105325   %PURPOSE:    GIVE PORT STATUS
105325   %
105325   %MESSAGE DECRIPTION:
105325   %      - FUNCTION  = POSTAT
105325   %      - STATUS    = NOT APPLICABLE
105325   %      - ADDSTA    = NOT APPLICABLE
105325   %      - ERRNO     = TOTALE # OF ERRORS (RELATED TO ADSTA)
105325   %      - ORERR     = OR FUNCTION OF ALL ERRORS (RELATED TO ADSTA)
105325   %      - LHAST     = LAST HARDWARE STATUS (RRTS OR RTTS)
105325   %      - SSTPC     = RECEIVER STOPP COUNTER
105325   %      - MAXEM     = MAX NUMBER OF EMTY BUFFERS HELD BY RECEIVER. (LIST LENGTH
105325   %      - HHMAX     = BUFFER SIZE IN BYTES FOR THIS LDN
105325   %      - HHEAD     = SYSTEM PART (REDUNDENCE) OF EACH DCB
105325   %
105325   %
105325   SUBR SPSTA
105325   SPSTA: X-BHEAD; CALL RBYTC; X+BHEAD              % GET BYTECOUNT
105330          IF A<20 THEN
105333                ETOSM; CALL SCRET                       % MESSAGE TOO SMALL
105335                A:=0; CALL SADTS; GO SP1
105340          FI
105340          X+CHEAD =: OMSG                           % POINT TO USER INFORMATION
105342          IF A >=24 THEN
105345                T:=MASTB; MAX; * HHMAX@3 STATX      % IN BYTES
105350                "BHEAD"+2 SH 1; * HHEAD@3 STATX     % IN BYTES
105354          FI
105354          T:=MASTB
105355          A:=HDERC; * ERRNO@3 STATX
105357          A:=DSTAT; * ORERR@3 STATX
105361          A:=HASTAT; * LHAST@3 STATX
105363          A:=STPCNT; * SSTPC@3 STATX
105365          A:=LISTL; * MAXEM@3 STATX
105367          0=:HDERC=:DSTAT=:STPCNT
105372          X-CHEAD; A:=0; CALL SCRET; CALL SADTS
105376          X-BHEAD; T:=24; CALL SBYTC
105401   SP1:   CALL OCHAIN; GO HDSTA
105403   RBUS
105411   *"
"105411
105411   @DEV 1
105411   @DEV (S-S-L)MP-P2-X21-DRIV:NPL
105411   *"8C1X2+8C2X2+8C3X2+8C4X2
"105411   %

105411   %=============================================
105411   % 40.20
105411   %      X 2 1 2 S    X 2 1 3 S    X 2 S N D
105411   %      X 2 S S S
105411
105411   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
105411   %
105411   %      X 2 1  DRIVER FOR HANDLING X21 DCB'S
105411   %
105411   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
105411
105411
105411   %PURPOSE:    CONNECT AND DISCONNECT TO A X 21 NETWORK
105411
105411   %ENTER:      B-REG DATAFIELDPOINTER
105411   %            MESSAGE:      COMMAND
105411   %                          FACILITY
105411   %                          STATUS
105411   %                          SELECTIONS SIGNALS
105411   %                          DTE/DCE PROVIDED INFORMATION
105411
105411
105411   %EXIT:       MESSAGE SENT BACK TO USER WITH APPROPRIATE STATUS INFORMATION.
105411
105411
105411   %HDLC REGISTER CONTENT DEFINITION
105411   %
105411   %
105411   % SYMBOL CPCR = 100                                % IOX + 1
105411   % SYMBOL CSAR = 377% IOX + 3
105411   % SYMBOL CCL  = 347                                %IOX + 4  7BITS BYTE+PARITY
105411   % SYMBOL CTCW =   1% IOX + 7
105411   % SYMBOL CWTTC= 104% IOX + 13
105411   % SYMBOL CRTTC= 104% IOX + 11
105411   %
105411   %
105411
105411   %
105411   %
105411   %      X21 LOGGING ROUTINES
105411   %**************************
105411
105411
105411          SYMBOL X22SIZ = 20
105411          SYMBOL X2LMA = X22SIZ-1
105411          SYMBOL DCEMS = X22SIZ*10+4
105411
105411          INTEGER ARRAY X2A00(X22SIZ)
105431          INTEGER ARRAY X2A02(X22SIZ)
105451          INTEGER ARRAY X2A05(X22SIZ)
105471          INTEGER ARRAY X2A10(X22SIZ)
105511          INTEGER ARRAY X2A11(X22SIZ)
105531          INTEGER ARRAY X2A12(X22SIZ)
105551          INTEGER ARRAY X2AST(X22SIZ)
105571          INTEGER ARRAY X2ATL(X22SIZ)
105611
105611          INTEGER ARRAY X2PATC(100)
105711          INTEGER X2PAFR
105712
105712
105712   %
105712   %
105712   %      LOGG IN ARRAYS
105712
105712   SUBR STORE
105712          INTEGER X2LL:=0
105713          INTEGER X2LL1:=-1
105714          INTEGER X2LL2:=0
105715          INTEGER X2LL4:=0
105716          INTEGER X2LL5:=0
105717   STORE: X:=X2LL; *1BANK;
105721          T:=X2A00(X); *2BANK
105723          IF X2D00 >< T                GO XUP21
105726          *1BANK;
105727          T:=X2A02(X); *2BANK
105731          IF X2D02 >< T  AND >< "0"    GO XUP21
105737          *1BANK;
105740          T:=X2A05(X); *2BANK
105742          IF X2D05 >< T                GO XUP21
105745          *1BANK;
105746          T:=X2A10(X); *2BANK
105750          IF X2D10 >< T                GO XUP21
105753          *1BANK;
105754          T:=X2A11(X); *2BANK
105756          IF X2D11 >< T                GO XUP21
105761          *1BANK;
105762          T:=X2A12(X); *2BANK
105764          IF X2D12 >< T                GO XUP21
105767          *1BANK;
105770          T:=X2AST(X); *2BANK
105772          IF X2DST >< T                GO XUP21
105775          MIN X2LL4; P+0; X:=X2DMP
106000          EXIT
106001   XUP21: MIN X2LL1; P+0
106003          X2LL1 /\ X2LMA=:X2LL=:X
106007          X2D00; *1BANK
106011          A=:X2A00(X); *2BANK
106013          X2D02; *1BANK
106015          A=:X2A02(X); *2BANK
106017          0=:X2D02; X2D05; *1BANK
106022          A=:X2A05(X); *2BANK
106024          X2D10; *1BANK
106026          A=:X2A10(X); *2BANK
106030          X2D11; *1BANK
106032          A=:X2A11(X); *2BANK
106034          X2D12; *1BANK
106036          A=:X2A12(X); *2BANK
106040          X2DST; *1BANK
106042          A=:X2AST(X); *2BANK
106044          X2LL-1=:X2LL5
106047          IF X2LL5 < 0 THEN "X22SIZ-1"=:X2LL5 FI; *1BANK
106054          X2LL4=:X2ATL(X2LL5); 0=:X2LL4; *2BANK
106061          X:=X2DMP; EXIT
106063   RBUS
106074
106074

106074   %****************************
106074   %
106074   %      SOME USEFUL ROUTINES
106074   %
106074   %****************************
106074
106074
106074   %      SERVICE ROUTINE FOR UPATINNG IDENT TABLES
106074   %************************************************
106074
106074
106074   %      EXCHANGE "X2OLD" IN IDENTTABLE WITH "X2NEW"
106074   %      "X2OLD" MAY ALSO BE FOUND IN EXTENDED IDENTTABLE
106074   %      ENTRY X212S - LEVEL 12(D)
106074   %      ENTRY X213S - LEVEL 13(D)
106074
106074   %      INPUT PARAMS:
106074
106074   INTEGER X2NEW:=0                                 % ADDR TO BE INSERTED
106075   INTEGER X2OLD:=0                                 % ADDR TO BE REMOVED
106076   DOUBLE  X2DNEW=X2NEW                             % TO STORE NEW AND OLD
106076
106076   %      SCRATCH LOCATIONS
106076
106076   SUBR X212S,X213S
106076   INTEGER X2TA1:=0                                 % ADDR TO TABLE
106077   INTEGER X2TA2:=0                                 % ADDR TO EXTENDED TABLE
106100   INTEGER X2SSP:=0                                 % WORKING
106101
106101   DISP 0; INTEGER XNUL1; INTEGER EN; PSID
106101
106101   X212S: IDNTS(2)=:X2TA1+"MAX12"=:X2SSP; EXTDS(2)=:X2TA2; GO X2HER
106112   X213S: IDNTS(3)=:X2TA1+"MAX13"=:X2SSP; EXTDS(3)=:X2TA2
106122
106122   X2HER: FOR X:=X2TA1 STEP 1 TO X2SSP DO
106126             *1BANK; LDA ,X
106130             T:=X2OLD
106131             IF A=T THEN
106133                X2NEW; *STA ,X; 2BANK
106136                EXIT
106137             FI
106137             *2BANK
106140          OD
106142
106142   %      LOOK IN EXTENDED TABLE
106142
106142          DO X:=X2TA2; X+1; *1BANK;  LDA ,X
106146          WHILE A><-1
106151             X:=X2TA2; X+1; * LDA ,X
106154             T:=X2OLD
106155             IF A=T THEN
106157                X2NEW; *STA ,X; 2BANK
106162                EXIT
106163             FI
106163             MIN X2TA2; P+0
106165          OD
106166          *2BANK
106167          A:=X2FNI; CALL X21UT                      % ENTRY NOT FOUND
106171   RBUS
106200
106200   %
106200   %      SEND ONE CHARACTER
106200   %      THE ROUTINE WILL GENERATE ODD PARITY
106200   %
106200   %      INPUT: A-REG IS CHARACTER TO BE TRANSMITTED
106200   %
106200   %      OUTPUT: STATUS IN X2D12 IN DATAFIELD
106200   %
106200   %**************************************************
106200
106200   SUBR X2SND
106200   X2SND: T:=L=:X2DLS;
106202          CALL X21PG; A=:X2D05
106204          T:=X2DHD+XWTDR; *EXR ST
106207          105
106210          T+"XWTTC-XWTDR"
106211          *EXR ST
106212          CALL X21LV; T:=X2DHD+XRTTS; *EXR ST
106216          A=:X2D12; CALL STORE; A:=X2DLS=:P
106222
106222
106222   %      ROUTINE FOR PARITY GENERATION ( ODD PARITY)
106222   %**************************************************
106222
106222   X21PG: *BSET ONE 70 DA
106223          *BSKP ZRO 60 DA; BSET BCM 70 DA
106225          *BSKP ZRO 50 DA; BSET BCM 70 DA
106227          *BSKP ZRO 40 DA; BSET BCM 70 DA
106231          *BSKP ZRO 30 DA; BSET BCM 70 DA
106233          *BSKP ZRO 20 DA; BSET BCM 70 DA
106235          *BSKP ZRO 10 DA; BSET BCM 70 DA
106237          *BSKP ZRO  0 DA; BSET BCM 70 DA
106241          EXIT
106242   RBUS
106245
106245   %
106245   %      ROUTINE FOR STARTING TRANSMITTER PART OF INTERFACE
106245   %      AND SENDING "SYN,SYN"
106245   %
106245   %*********************************************************
106245
106245   SUBR X2SSS
106245   X2SSS: A:=L=:X2DLS
106247          1=:X2DPC
106251          FOR X2DPC STEP 1 TO 4 DO                  % SEND 4 SYNC
106255             1; T:=X2DHD+XWTCR; *EXR ST
106261   L1:       105; T:=X2DHD+XWTTC; *EXR ST
106265             CALL X21LV
106266             T:=X2DHD+XRTTS; *EXR ST
106271             A=:X2D13
106272             IF A NBIT 0 THEN GO L1 FI
106275          OD
106301          0=:A; T:=X2DHD+XWTCR; *EXR ST
106305          A:=X2DLS=:P
106307   RBUS
106310
106310
106310

106310   % ======================================================
106310   % 40.21
106310   %      X 2 1 E R    X 2 S T A     X 2 S B Y    X 2 R B Y
106310   %      X 2 R A C    X 2 1 U T
106310   %========================================================
106310
106310   %*******************************
106310   %
106310   %      MESSAGE HANDLING
106310   %
106310   %*******************************
106310
106310   SUBR X21ER,X2STA,X32ST,X2SBY,X2RBY,X2RAC,X21UT
106310
106310   %
106310   %
106310   %      MESSAGE RECEPTION
106310   X32ST:
106310   X2STA: IF X2DST=10 THEN                          % ARE YOU IN READY STATE?
106314             CALL XTSTC; GO NOMES                   % YES, ANY MESSAGE?
106316                CALL X2114                          % CONTROLLED NOT READY
106317                0=:X2DST=:X2DPIN
106321                X:=X2DMP;       *1BANK
106323                X2FNC=:X.X2MST; *2BANK;
106326                CALL O3CHA                          % RETURN MESSAGE
106327                0=:X2DMP; 1=:X2DDF
106332          FI
106332   NOMES: CALL D3CHA; CALL X21LV; 0=:X2DER; CALL X2RBY      % GET NEW MESSAGE
106336          IF A >= 10 THEN CALL X21C FI              % DECODE COMMAND
106342          IF A >= 6 THEN
106345             *1BANK
106346             X2FSM=:X.CRET; *2BANK                  % TOO SMALL MESSAGE
106351          FI
106351          CALL O3CHA; 0=:X2DMP; GO X2STA            % RETURN MINI MESSAGE
106354
106354
106354   %
106354   %
106354   %      MESSAGE SENDING       (RETURN IT TO SENDER)
106354
106354   X21ER: X:=X2DMP;   *1BANK
106356          A=:X.X2MST; *2BANK
106360          A=:X2DER; CALL STORE;  CALL X2116
106363          CALL X2121; CALL X211; CALL X2114
106366          X:=X2DMP; GO X21UU                        % LEAVE AT STATE 24
106370
106370   X21UT: X:=X2DMP;   *1BANK
106372          A=:X.X2MST; *2BANK                        % SET STATUS
106374          CALL STORE
106375   X21UU: CALL X2RBY; A+X2DBC=:T; CALL X2SBY
106401          CALL O3CHA; 0=:X2DMP; 1=:X2DDF
106405          GO FAR X2STA
106406
106406   %
106406   %
106406   %      SOME USEFUL MESSAGE MAINTENANCE ROUTINES
106406
106406
106406   %      STORE BYTECOUNT IN MESSAGE
106406
106406   X2SBY: *1BANK
106407          T=:X.BBYTC; *2BANK; EXIT
106412
106412   %
106412   %      READ ACTUAL BYTECOUNT
106412
106412   X2RAC: *1BANK
106413          A:=X.BBYTC; *2BANK; EXIT
106416
106416   %
106416   %      READ MAX BYTECOUNT
106416
106416   X2RBY: *1BANK
106417          A:=X.BMBYTE; *2BANK; EXIT
106422
106422   %
106422   %      ANY MESSAGES FOR ME?
106422
106422   XTSTC: IF IQUEU><0 THEN  EXITA FI
106425          EXIT
106426   RBUS
106444

106444   %============================
106444   % 40.22
106444   %      X 2 1 C
106444   %
106444   %============================
106444
106444
106444   %******************************
106444   %
106444   %      THE X21 COMMANDS
106444   %
106444   %******************************
106444
106444
106444   SUBR X21C,X21RE,X21LG,X21CL,X21CN,X21CH,X21DC,X21AA,X21RD,X21BR
106444
106444   %      S T A T U S
106444   %      ***********
106444
106444   X21AA: IF X2DCN = 0 THEN X21SA; GO LLL FI        % NOT CONNECTED
106450          IF X2DST = 14 THEN X21SB ELSE X21SC FI    % DATA-PHASE OR CONNECTED
106457   LLL:   T:=X2DBC+2=:X2DBC
106462          IF T:=X2DBC<0 THEN                        % ENOUGH MESSAGE SPACE ?
106465             X:=X2DMP;   *1BANK                     % YES
106467             A=:X.X2MSL; *2BANK
106471             A:=0
106472          ELSE
106473             A:=X2FSM                               % NO
106474          FI
106474          CALL X21UT
106475
106475   %      C A L L
106475   %      *******
106475
106475   X21CA: IF X2DCN=0 THEN X2FFF; CALL X21UT FI      % MUST CONNECT FIRST
106501          IF X2DST=14 OR X2DCC = 2 THEN A:=X2FIS; CALL X21UT FI  % ILLEGAL COMMAND IN DATA PHASE
106513          X:=X2DMP; *1BANK
106515          X.X2MFA;  *2BANK
106517          IF A NBIT X21C3 THEN                      % DIRECT CALL ?
106521             CALL X2RAC; A=:D; X:=0                 % NO, LOOK FOR "+"
106524             DO WHILE A><"X21PL"                    % ANY "+" IN SELECTION SIGNAL ?
106527                T:=X2DMP+X2M3; *1BANK; LBYT; 2BANK
106534                X+1
106535                IF X>D OR X>25 THEN A:=X2FNP; CALL X21UT FI % NO, ERROR
106544             OD
106545          FI
106545          CALL X211
106546          IF T><0 THEN T=:A; CALL X21ER FI
106552          CALL X212                                 % STATE 2 - 6
106553          0 =: X2DPS                                % CLEAR CP-SIGNAL (STATUS FROM X217)
106554   LOOP:  CALL X2GET; A=:A
106556             IF X2D10 BIT 6 THEN 0=:TMR; CALL X2112 FI  % DCE READY FOR DATA
106563             IF T = 0  GO LOOP                          % WAIT FOR DATA
106565             IF X2D00="X21SY" OR ="X21PL" OR ="177" OR ="X21NL" THEN
106602                GO LOOP                             % "X21NL" MUST BE ACCEPTED IN ORDER TO WAIT FOR
106603             FI                                     % DCE CLEAR REQUEST AFTER CP-SIGNAL
106603             T:=X21T3 =: TMR                        % CP/DCE-INFO RECEIVED. SET T3
106605             IF A="X21ST" OR ="X21SL" OR = ##- THEN % TEST ON "*", "/" AND ("-" FOR GERMANY)
106616                CALL X2110                          % ENTER STATE 10
106617                IF T><0 THEN T=:A; CALL X21ER FI
106623             ELSE
106624                IF A <##0 OR >##9 THEN GO LOOP FI   % CHECK FOR ASCII '0' TO '9'
106633                CALL X217                           % CALL PROGRESS SIGNALS
106634                IF X2FCP = T THEN                   % T-REG NOT DESTROYED
106637                   X2FCP =: X2DPS; GO LOOP          % SAVE X2FCP IN X2DPS. CP IN DF NOW
106642                FI                                  % CONTAINS INFO:SERIOUS CP RECEIVED.
106642                IF T><0 THEN T=:A; CALL X21ER FI
106646             FI
106646          GO LOOP
106647   *)FILL
106660
106660   %      R E A D Y
106660   %      *********
106660
106660   X21RE: IF X2DCN=0 THEN X2FFF; CALL X21UT FI      % MUST CONNECT FIRST
106664          IF X2DST=14 OR X2DCC = 2 THEN A:=X2FIS; CALL X21UT FI  % ILLEGAL COMMAND IN DATAPHASE
106676          CALL X211
106677          IF T><0 THEN T=:A; CALL X21ER FI
106703          CALL X218                                 % EXECUTE STATE 8 - 9
106704          DO CALL X2GET; A=:A                       %
106706          WHILE X2D10 NBIT 6
106711             IF T=1 AND X2D00="X21ST" THEN CALL X2110       % CALLING LINE IDENTIFICATION
106721               IF T><0 THEN 0=:TMR; T=:A; CALL X21ER FI  % TOO SMALL MESSAGE
106726             FI
106726          OD
106727          0=:TMR
106730          CALL X2112                                % READY FOR DATA
106731
106731
106731   %      C L E A R  R E Q U E S T
106731   %      ************************
106731
106731   X21CL: IF X2DCN=0 THEN X2FFF; CALL X21UT; FI     % MUST CONNECT FIRST
106735          IF X2DBR >< 0 THEN                        % BREAK REQUESTED
106737             X:=X2DBR;   *1BANK
106741             X2FBR=:X.X2MST                         % SET STATUS
106743             4=:X.BBYTC; *2BANK                     % SET BYTECOUNT
106746             0=:X2DBR;                              % CLEAR BREAKMSG POINTER
106747             CALL O3CHA                             % SEND IT TO USER
106750          FI
106750          CALL X2116; CALL X2121
106752          IF X2DCC=1 THEN                           % EXPECTING CHARGING INFO ?
106756             CALL X21GC                             % GET CHARGING
106757          FI
106757          CALL X21SH; CALL X2SSS; CALL X2114
106762          X21LO=:X2DUI.HXDOK=:X2DUO.HXDOK           % LOCK USER DRIVER
106767          A:=0; CALL X21UT
106771   *)FILL
107007
107007   %      C O N N E C T  T O  X 2 1
107007   %      *************************
107007   *)FILL
107007
107007   X21CN: IF X2DCN><0 THEN X2FAC; CALL X21UT FI     % ALLREADY CONNECTED
107013          CALL X2RAC
107014          IF A<16 THEN A:=X2FSM; CALL X21UT FI      % TOO SMALL MESSAGE
107021          X:=X2DMP;   *1BANK
107023          A:=X.X2MSL; *2BANK
107025          CALL LOGPH; A=:X2DUI                      % GET USER INPUT DATAFIELD ADR
107027          IF A=0 THEN A:=X2FIL; CALL X21UT FI
107032          X:=X2DMP;   *1BANK
107034          A:=X.X2MSS; *2BANK
107036          CALL LOGPH; A:=D=:X2DUO                   % GET USER OUTPUT DATAFIELD ADR
107041          IF A=0 THEN A:=X2FIL; CALL X21UT FI
107044          X:=X2DMP;   *1BANK
107046          A:=X.X2MS2; *2BANK
107050          IF A=0 THEN A:=CURPR FI
107052          IF A><X2DUO.RTRES  THEN
107056             X2FNR; CALL X21UT                      % NOT RESERVED BY YOU
107060          FI
107060          IF A><X2DUI.RTRES THEN
107064             X2FNR; CALL X21UT                      % NOT RESERVED BY YOU
107066          FI
107066
107066   %      GET NEW DATAFIELD IF HASP-DMA IS USED
107066
107066          IF X2DUO.TYPRING BIT 5HDMA THEN
107072            A:=X.CLOGDV; CALL LOGPH A=:X2DUO        % NB SHOULD HAVE BEEN OUTPUT
107075            A:=X2DUI.CLOGDV; CALL LOGPH; A=:X2DUI
107101          FI
107101
107101
107101   %      GET HARDWARE DEVICE NUMBER (HDEV)
107101
107101          A:=X2DUO.HDEV=:HDEV
107104          IF A><X2DUI.HDEV THEN X2FNM=:A; CALL X21UT FI  % NOT MATCHING HDEV
107113
107113   %      REROUTE INTERRUPTS TO X21 DRIVER
107113
107113          X2DUO=:D; B=:A; *1BANK
107117          AD=:X2DNEW; *2BANK
107121          CALL X212S                                % UPDATE LEVEL 12
107122          X2DUI=:D; B=:A; *1BANK
107126          AD=:X2DNEW; *2BANK
107130          CALL X213S                                % UPDATE LEVEL 13
107131          1=:X2DCN; A:=0; CALL X21UT
107135   *)FILL
107144
107144   %      R E D I R E C T
107144   %      ***************
107144
107144   X21RD: A:=X2FIC; CALL X21UT
107146
107146   %      D I S C O N N E C T  F R O M  X 2 1
107146   %      ***********************************
107146
107146   X21DC: IF X2DCN=0 THEN A:=X2FFF; CALL X21UT; FI  % NOTHING CONNECTED
107152          IF X2DST=14 THEN A:=X2FIS; CALL X21UT; FI % YOU ARE IN DATA PHASE !
107160          D:=B; X2DUO; *1BANK
107163          AD=:X2DNEW; *2BANK
107165          CALL X212S                                % REROUTE LEVEL 12
107166          X2DUI; *1BANK
107170          A=:X2NEW; *2BANK
107172          CALL X213S                                % REROUTE LEVEL 13
107173          A:=0=:X2DCN; CALL X21UT                   % OK, RETURN
107176
107176
107176   %      G E T  C H A R G I N G  I N F O R M A T I O N
107176   %      *********************************************
107176
107176   X21CH: IF X2DCC >< 3 THEN X2FAB; CALL X21UT FI   % NO CHARGING RECEIVED
107204          IF X2DBC>-10 THEN X2FSM; CALL X21UT FI    % TOO SMALL MESSAGE
107212          0=:X2DPC
107213          DO WHILE X2DPC < 14
107217             T:=X2DCI; X:=X2DPC; *1BANK; LBYT; 2BANK
107224             T:=X2DMP+X2M3; *1BANK; SBYT; 2BANK
107231             MIN X2DPC; P+0
107233             MIN X2DBC; P+0
107235             IF A = "X21PL" THEN GO ASD FI
107241          OD
107242   ASD:   0=:X2DCC; A:=0; CALL X21UT
107245
107245   %      R E T U R N    W H E N    C O N N E C T I O N    B R O K E N
107245   %      ************************************************************
107245
107245   X21BR: IF X2DST >< 14 THEN X2FBR; CALL X21UT FI  % NOT IN DATAPHASE
107253          X =: X2DBR; 1=:X2DDF
107256          GO FAR X2STA
107257   %*****************************
107257   %
107257   %     X 2 1 COMMAND DECODER
107257   %
107257   %*****************************
107257
107257   X21C:  X=:X2DMP; A-; A+10=:X2DBC; *1BANK
107264          A:=X.X2MFU-; *2BANK                       % POSITIVE FUNCTIONS
107267          IF A < 1 OR > X21PM THEN
107275             A:=X2FIC; CALL X21UT                   % ILLEGAL COMMAND
107277          FI
107277          0=:X2DDF                                   % EXPECTING NO CHARGING INFO
107300          GOSW X21C,FAR X21CA,X21RE,X21CL,X21CH,X21CN,X21DC,X21RD,FAR X21AA,X21BR
107313   RBUS
107332

107332   %==========================================
107332   % 40.23
107332   %      X 2 1 L V    X 2 1 I N    X 2 1 G C
107332   %
107332   %==========================================
107332
107332   %***************************************
107332   %
107332   %      INTERRUPT HANDLING ROUTINES
107332   %
107332   %***************************************
107332
107332   SUBR X21LV,X21IN,X321I
107332
107332   %      LEAVE X21, WAITING FOR INTERRUPT
107332
107332          INTEGER SAVEB
107333   %      INTEGER CPOF(0); *POF
107333   X21LV: A:=L=:X2DL3; *TRA STS
107336          IF A BIT 10 THEN GO FAR WT13 ELSE GO FAR WT12 FI
107342   %
107342   %
107342   %      LEVEL 12 AND 13 INTERRUPT HANDLING
107342
107342   X321I:
107342   X21IN: *TRA STS                                  % WHICH LEVEL ?
107343          IF A BIT 10 THEN
107345
107345   %      LEVEL 13
107345   %      ********
107345
107345          T:=X2DHD+XRRTS; *EXR ST                   % GET STATUS
107350          A=:X2D10
107351          IF A BIT DCE19 THEN                       % DCE CLEAR INDICATION ?
107353           IF X2DDF >= 0 THEN                       % NOT ENTRY HERE TWICE
107355            A BONE 17 =: X2DDF
107357            IF X2DST >< 20 THEN                     % DON'T CARE IF WAITING FOR DCE TO GET READY *H*
107363              CALL X2120; 1=:WAKEF                  % LOCK KICK FROM MONCALL PART
107366              X21LO=:X2DUI.HXDOK=:X2DUO.HXDOK       % LOCK USER DRIVER
107373              X21T6=:TMR; CALL X2121
107376              IF X2DCC = 1 THEN CALL X21GC FI       % GET CHARGING IF REQUESTED
107403              CALL X21SH; CALL X2SSS; CALL X2114    % NB X2SSS BRINGS US FROM LEVEL 13 TO LEVEL 12
107406              0=:WAKEF                              % UNLOCK KICK FROM MONCALL
107407              IF X2DBR >< 0 THEN                    % BREAK REQUESTED ?
107411                 X:=X2DBR;     *1BANK               % YES
107413                 X2FBR=:X.X2MST                     % SET STATUS
107415                 4=:X.BBYTC;   *2BANK
107420                 0=:X2DBR; CALL O3CHA               % SEND BREAK MESSAGE FOR USER
107422              FI
107422              IF X2DDF NBIT 0 THEN                  % X21 MODUS ?
107425                IF X2DPS = X2FCP THEN
107431                   0=: X2DPI                        % SET STATUS IN DCB TO CP RECEIVED.
107432                   0=: X2DPS
107433                   CALL X21UT
107434                ELSE                                % YES
107435                   X:=X2DMP;
107436                   A:=X2DST+30; *1BANK
107441                   A=:X.X2MST                       % STATUS TO DCB
107442                   6=:X.BBYTC; *2BANK
107445                   CALL O3CHA                       % SEND IT BACK TO USER
107446                   0=:X2DST=:X2DPI=:X2DMP
107451                   1=:X2DDF; GO FAR X2STA           % NOT X21 MODUS ANY MORE
107454                FI
107454              FI
107454              X2DDF BONE 16; A BZERO 17=: X2DDF     %
107460             FI
107460           FI
107460          FI
107460
107460   %      ACTIVATE X21 DRIVER ?
107460
107460          IF X2DDF NBIT 0 OR A BIT 17 THEN          % X21 ACTIONS ?
107465            IF X2DPIN = 0 THEN GO X21LV FI          % NOT PINNED, SKIP IT
107470            A:=X2D10; 0=:X2DPIN; T:=X2DL3=:P        % GO TO X21 ROUTINE
107474          FI
107474
107474   %      ACTIVATE DATA DRIVER
107474
107474          IF X2DDF BIT 16 THEN                      % CONNECTION BROKEN ?
107477            A:=B=:SAVEB
107501            A:=X2DUI=:B; T:="DRIVER"+3; A:=HX21M
107506            *IOF; IRW LV13B DA
107510            CALL STL13                              % FIRST START DRIVER, THEN RETURN
107511            A=:B:=SAVEB:=:B; * ION                  % RESTORE BREG FOR X.21
107515            GO FAR X2STA
107516          ELSE
107517            A:=X2D10                                %
107520            T:=X2DUI=:B; T:="DRIVER"+3; T=:P         % GO TO USER DRIVER
107525          FI
107525          FI
107525
107525   %      LEVEL 12
107525   %      ********
107525
107525          IF X2DDF > 0 THEN                         % DATA PHASE ?
107530             A:=X2DUO=:B; GO DRIVER                    % YES, GO TO USER DRIVER
107533          FI
107533          A:=X2DL3=:P                               % LEVEL = 12
107535
107535   RBUS
107553
107553   SUBR X21GC
107553
107553   %      ROUTINE FOR RECEIVING CHARGING INFORMATION
107553   %      ******************************************
107553
107553   X21GC: A:=L=:X2DSL
107555          2=:X2DCC                                  % WAITING FOR CHARGING
107557             CALL X211; X21T7=:TMR; CALL X218       % YES, GET READY FOR IT
107563             0=:X2DPC=:WAKEF
107565   KAST:     CALL X2GET; *JMP *-1
107567                IF X2D00 = "X21BL" OR A = "X21SY" THEN
107576                  GO KAST
107577                FI
107577                0=:TMR
107600                X:=X2DPC; T:=X2DCI; *1BANK; SBYT; 2BANK   % STORE CHARGING INFO.
107605                MIN X2DPC; P+0                            % IN DATAFIELD
107607                IF X2D00 >< "X21PL" AND X2DPC < 14 THEN
107617                  GO KAST
107620                FI
107620             3=:X2DCC; CALL X2116; CALL X2121       % TERMINATE CHARGING CALL
107624             CALL X211
107625          A:=X2DSL=:P                               % EXIT
107627   RBUS
107634

107634   %============================
107634   % 40.24
107634   %      X 2 1 T O    X 2 G E T
107634   %
107634   %============================
107634   %**********************
107634   %
107634   %      TIMOUT HANDLING
107634   %
107634   ***********************
107635
107635   %      NON RESIDENT PART
107635
107635   SUBR X21TO,X321T
107635   X321T:
107635   X21TO: IF X2DPIN = 0 THEN GO FAR WT13 FI         % NOT PINNED, SKIP IT
107640          0=:X2DPIN
107641          IF X2DCC = 2 THEN
107645             0=:X2DCC; CALL X2114; GO FAR WT13      % WAITING FOR CHARGININFO ?
107650          FI
107650
107650          IF X2DST = -1 THEN
107654             CALL X2114; X2F01; CALL X21UT
107657          FI
107657
107657          IF X2DST = 3 THEN                         % STATE 1, STATE 14
107663             CALL X21SH; CALL X2SSS
107665             CALL X2114; A:=33; CALL X21UT
107670          FI
107670
107670          IF X2DST = 7  OR = 12 THEN                % T3 IS EXPIRED IN STATE 7 OR STATE 10
107677             A+30; CALL X21UT
107701          FI
107701
107701          IF X2DST = 20 OR = 24 OR = 25 THEN        % T5 OR T6 EXPIRED FROM STATE 16/20
107713             X2DST =:X2DRL                          % SAVE STATUS IN THE LOCATION X2DRL
107715             CALL X2118; CALL X211; CALL X2114      % TIMEOUT FROM X211 IF NETW. NOT OK
107720             IF X2DDF NBIT 0 THEN                   % X21 MODUS?
107723                0=:WAKEF                            % UNLOCK KICK FROM MONCALL
107724                X2DRL+30;                           % X2DRL IS USED TO SAVE X2DST
107726                CALL X21UT
107727             ELSE
107730                IF X2DBR >< 0 THEN
107732                   X:=X2DBR;   *1BANK
107734                   X2FBR=:X.X2MST
107736                   4=:X.BBYTC; *2BANK
107741                   0=:X2DBR ; CALL O3CHA
107743                FI
107743                X21LO=:X2DUI.HXDOK=:X2DUO.HXDOK
107750                0=:WAKEF; 60000; T:=X2DUI=:B;       % 60000 MEANS CONNECTION BROKEN BY X21
107754                T:="DRIVER"+3; T=:P                 % ACTIVATE DRIVER
107757             FI
107757          FI
107757          IF X2DER >< 0 THEN CALL X21SH; CALL X2SSS; X2F01; CALL X21UT; FI    % ERROR IN ERROR SEQUENCE
107765          X2DST+30; CALL X21ER
107770   RBUS
110002   %*****************************************************************************
110002   %
110002   %      WAIT FOR ANY INPUT REACTION
110002   %      THE INPUT CHARACTER IS STORED IN X2D00 IN DATAFIELD
110002   %      STATUS IS SAVED IN X2D10
110002   %
110002   %      RETURN: SKIP IF INPUT DATA ELSE NOSKIP
110002   %
110002   %*****************************************************************************
110002
110002   SUBR X2GET
110002   X2GET: A:=L=:X2DLS; -2=:X2D0C                    % SAVE RETURN ADDRES
110006          X2D11; T:=X2DHD+XWRTC; *EXR ST            % ENABLE RECEIVER, C = ON
110012          1=:X2DPI; CALL X21LV                      % PINNED FOR INPUT (SEE X21TO)
110015          A=:X2D10                                  % SAVE IT
110016          IF A BIT 1 THEN                           % STATUS AVAILABLE
110020                T:=X2DHD+XRRSR; *EXR ST             % GET STATUS
110023                A=:X2D02
110024          FI
110024          IF X2D10 BIT 0 THEN                       % ANY DATA AVAILABLE
110027             T:=X2DHD+XRRDR; *EXR ST                % GET DATA
110032             A BZERO "7" =:X2D00; X2DLS+1=:X2DLS    % SKIP RETURN IF DATA
110037             T:=1                                   % T = 1  I.E DATA
110040          ELSE
110041             T:=0                                   % T = 0 I.E NO DATA
110042          FI
110042   OUT:   A:=X2DLS=:P                               % NO DATA, NO SKIP
110044   RBUS
110045
110045
110045

110045   %==================================
110045   % 40.25      R E A D Y    X 2 1 S H    X 2 1 1 4
110045
110045   %***************************************************************
110045   %
110045   %      R E A D Y                                 % ** STATE 1 **
110045   %      T = 1  C = OFF
110045   %
110045   %      EXIT: T = 0     OK
110045   %            T ><0     ERROR CODE IN T
110045   %
110045   %***************************************************************
110045
110045   SUBR X211
110045   X211:  A:=L=:X2DSR; 1=:X2DST                     % SAVE RETURN ADDR
110051          CALL X21SH                                % DEFINE SYN = HIGH, ENABLING
110052                                                    % INTERFACE TO DETECT R = HIGH
110052          100=:A; T:=X2DHD+XWTTC; *EXR ST           % T = 1
110057          -3=:X2D0C; -1=:X2DST                      % **** POSSIBLE -7 HERE *****
110063   X21L:  005; T:=X2DHD+XWRTC; *EXR ST              % C = OFF, IS R = 1 ?
110067          X21TA=:TMR; 1=:X2DPI; CALL X21LV          % WAIT FOR R = 1
110074          A=:X2D10                                  % SAVE STATUS
110075          IF A/\ "101" >< "001" THEN                % IS I OFF ?
110101                T:=X2F01;  GO OUT                   % NO, REPORT ERROR
110103          FI                                        % YES,  I = OFF
110103          T:=X2DHD+XRRDR; *EXR ST                   % GET R
110106          A=:X2D00
110107          IF A >< "377" THEN                        % IS R = HIGH ?
110112                T:=X2F01; GO OUT                    % NO, NETWORK NOT READY
110114          FI                                        % I DO NOT LIKE STATE 8 NOW
110114          MIN X2D0C; GO X21L                        % MUST DETECT 3 SUCH CHAR, THUS
110116                                                    % MAKE SURE T = 1 IN 24 BIT
110116          0=:TMR                                    % INTERVALLS
110117          0=:A; T:=X2DHD+XWRTC; *EXR ST             % DISABLE RECEIVER
110123          40; *EXR ST
110125          147; T:=X2DHD+XWPCR; *EXR ST              % 8 BITS CHAR,STRIP SYNC
110131                                                    % NO PARITY CONTROL
110131          X21SY; T:=X2DHD+XWSAR; *EXR ST            % REDEFINE SYNC CHARACTER
110135          100; T:=X2DHD+XWTTC; *EXR ST              % T = 1
110141          CALL STORE; T:=0
110143   OUT:   A:=X2DSR=:P                               % EXIT
110145   RBUS
110152
110152   %      SET READY (1,OFF) DONT CARE ABOUT DCE
110152
110152   SUBR X2118
110152
110152   X2118: A:=L=:X2DSR; T:=22=:X2DST; CALL STORE
110157          CALL X21SH; 100; T:=X2DHD+XWTTC; *EXR ST
110164          A:=0; T+"XWRTC-XWTTC"; *EXR ST
110167          A:=X2DSR=:P
110171
110171   RBUS
110173
110173   %      STATE 14 CONTROLLED NOT READY
110173
110173   SUBR X2114
110173   X2114: A:=0; T:=X2DHD+XWRTC; *EXR ST
110177          A:=40; *EXR ST
110201          A:=0; *EXR ST
110203          A:=107; T+"XWPCR-XWRTC"; *EXR ST
110206          A:=252; T+"XWSAR-XWPCR"; *EXR ST
110211          A:=0; T+"XWCHL-XWSAR"; *EXR ST
110214          A:=104; T+"XWTTC-XWCHL"; *EXR ST
110217          A:=1; T+"XWTCR-XWTTC"; *EXR ST
110222          EXIT
110223   RBUS
110224   %
110224   %
110224   %      ENABLE INTERFACE TO SEE R = HIGH
110224
110224   SUBR   X21SH
110224   X21SH: A:=0; T:=X2DHD+XWRTC; *EXR ST             % DEVICE CLEAR
110230          A:=40; *EXR ST                            % SET MAINTENANCE MODUS
110232          *AAT 6; EXR ST                            % CLEAR DMA ALSO *H*
110234          A:=0; T:=X2DHD+XWRTC; *EXR ST             % DEVICE CLEAR, OUT OF MAINT.MOD
110240          A:=107; T:=X2DHD+XWPCR; *EXR ST           % BCP MODUS, NO VCR CONTROL
110244                                                    % STRIP ONLY TWO SYN
110244          377; T:=X2DHD+XWSAR; *EXR ST              % SPECIFY SYNC CHAR
110250          A:=0; T:=X2DHD+XWCHL; *EXR ST             % CHARACTER LENGTH = 8 BITS
110254          EXIT
110255   RBUS
110256

110256   %===========================================================
110256   % 40.26      X 2 1 1 9    X 2 1 2 0    X 2 1 2 1    X 2 1 1 6
110256
110256   %*************************************************
110256   %
110256   %      DTE/DCE CLEARING STATES  (16,17,19,20,21)
110256   %
110256   %*************************************************
110256
110256   SUBR X2119,X2120,X2121,X2116
110256
110256
110256
110256
110256   %      DCE CLEAR INDICATION                     ** STATE 19 **
110256   %      D = 0  I = OFF
110256
110256   X2119: A:=L=:X2DSR; 23=:X2DST; CALL STORE
110263          A:=X2DSR=:P
110265
110265
110265
110265   %      CLEAR (DTE UNCONTROLLED)                 ** STATE 20 **
110265   %      T = 0  C = OFF
110265
110265   X2120: A:=L=:X2DSR; 24=:X2DST; CALL STORE
110272          CALL X21SH                                % SYN = HIGH TO DETECT STATE 21
110273          140; T:=X2DHD+XWTTC; *EXR ST              % T = 0
110277          7=:X2D11; T+"XWRTC-XWTTC"; *EXR ST        % C = OFF
110303          A:=X2DSR=:P                               % EXIT
110305
110305
110305   %      DCE READY (DTE UNCONTROLLED)             ** STATE 21 **
110305
110305   X2121: A:=L=:X2DSR
110307          DO CALL X2GET; A=:A                       %
110311          WHILE T=0 OR X2D00><"X21EN" OR X2D10 BIT "6" OR X2DDF NBIT 17
110325                                                    % WAIT FOR R = 1, C = OFF,ST 21
110325          OD
110326          25=:X2DST; CALL STORE
110331          0=:TMR
110332          A:=X2DSR=:P                               % EXIT
110334
110334
110334   %      DTE CLEAR REQUEST
110334   %      T = 0  C = OFF
110334
110334   X2116: A:=L=:X2DSR; 20=:X2DST; CALL STORE        % RETURN ADDR
110341          CALL X21SH                                % SYN = HIGH,
110342          140; T:=X2DHD+XWTTC; *EXR ST              % T = 0
110346          207=:X2D11; X21T5=:TMR                    % C = OFF, TIMING UNTIL ST. 21
110352          A:=X2DSR=:P                               % EXIT
110354   RBUS
110360
110360
110360
110360

110360   %====================
110360   % 40.27      X 2 1 2
110360
110360   %************************************************************
110360   %
110360   %      DTE CALL REQUEST ROUTINES  (STATE 2,3,4,5)
110360   %
110360   %************************************************************
110360
110360   SUBR X212
110360   %
110360   %      DTE CALL REQUEST                         ** STATE 2 **
110360   %      T = 0  C = ON
110360
110360   %
110360   X212:  A:=L=:X2DSR; 2=:X2DST; CALL STORE
110365          X21T1=:TMR; 307=:X2D11                    % C = ON
110371          140; T:=X2DHD+XWTTC; *EXR ST              % T = 0
110375
110375   %      PROCEED TO SELECT ( WAIT FOR "+" )
110375
110375          3=:X2DST
110377          DO
110377             CALL X2GET; *JMP *-1                   % WAIT FOR DATA
110401          WHILE X2D00><"X21PL"  OD                  % WAIT FOR "+"
110406          0=:TMR                                    % RECEIVED "+"
110407
110407
110407   %      SEND SELECTOR SIGNALS                    ** STATE 4 **
110407   %      T = IA5  C = ON
110407
110407          300; T:=X2DHD+XWRTC; *EXR ST              % MUST SEE DCE CLEAR REQUEST
110413          X21TB=:TMR; 4=:X2DST; CALL STORE
110420          X:=X2DMP;   *1BANK
110422          A:=X.X2MFA; *2BANK
110424          IF A NBIT X21C3 THEN                      % SKIP ALL THIS IF DIRECT CALL
110426          CALL X2SSS                                % SEND "SYN,SYN"
110427          X:=X2DMP;   *1BANK
110431          A:=X.X2MFA; *2BANK
110433          IF A /\ 7 >< 0 THEN                       % ANY PREFIX ?
110435             IF A BIT X21C1 THEN                    % CHARGING REQUEST ?
110437                ##6; CALL X2SND                     % YES, PREFIX = "61"
110441                ##1; CALL X2SND
110443             FI
110443             X:=X2DMP;   *1BANK
110445             A:=X.X2MFA; *2BANK
110447             IF A BIT X21C2 THEN                    % CALLED LINE ID ?
110451                IF A BIT X21C1 THEN
110453                   ##,; CALL X2SND
110455                FI
110455                ##6; CALL X2SND                     % YES, SEND ",62"
110457                ##2; CALL X2SND
110461             FI
110461   %         X:=X2DMP;   *1BANK
110461   %         A:=X.X2MFA; *2BANK
110461   %         IF A BIT X21C4 THEN                    % THE USER MAY DO THIS
110461   %            IF A /\ 3 >< 0 THEN                 % EXPLISIT BY PREFIXING
110461   %               ##,; CALL X2SND                  % WITH "."
110461   %            FI
110461   %            ##.; CALL X2SND
110461   %         FI
110461             ##-; CALL X2SND                        % TERMINATION OF PREFIX
110463          FI
110463          0=:X2DPC
110464             DO                                     % NO, SEND SELECTION SIGNALS
110464                X:=X2DPC; T:=X2DMP+X2M3; *1BANK; LBYT; 2BANK
110472                CALL X2SND
110473                MIN X2DPC
110474             WHILE X2D05><"X21PP" OD                % LAST CHAR IS "+"
110501   %      FI
110501          FI
110501          0=:TMR
110502          X:=X2DMP
110503          300=:A; T:=X2DHD+XWRTC; *EXR ST             % GET RID OF OVERRUN SITUATION
110510          T:=X2DHD+XRRDR; *EXR ST
110513          A=:X2D00
110514          T:=X2DHD+XRRTS; *EXR ST
110517          A:=X2D10; T:=X2DHD+XRRSR; *EXR ST
110523          A=:X2D02; CALL STORE
110525
110525
110525   %      DTE WAITING                              ** STATE 5 **
110525   %      T = 1  C = ON
110525
110525          5=:X2DST; 0=:A; T:=X2DHD+XWTTC; *EXR ST   % T = 1
110533          X21T2=:TMR; A:=X2DSR=:P                   % EXIT
110537   RBUS
110547

110547
110547   %==========================================================
110547   % 40.28      X 2 1 7    X 2 1 1 0    X 2 1 1 2    X 2 1 R T
110547   %******************************************
110547   %
110547   %      INFORMATION FROM DCE
110547   %
110547   %*******************************************
110547
110547   %
110547   %
110547   %     CALL PROGRESS SIGNALS                     ** STATE 7 **
110547   %      T-REG AT EXIT:
110547   %      T = CODE GROUP NO
110547   %      T < 0 MEANS  T = ERRORCODE-
110547
110547   SUBR X217
110547   X217:  T:=7=:X2DST; A:=L=:X2DSR; CALL STORE      % ENTERING STATE 7
110554          0=:X2DPC=:X2DPS
110556          DO WHILE X2D00><"X21PL"
110562             IF T:=X2DBC<0 THEN
110565                X:=X2DPC
110566                T:=X2DMP+X2M2; *1BANK; SBYT; 2BANK  % SAVE BYTE IN MESSAGE
110573             ELSE
110574                T:=X2FSM; GO OUT                    % MESSAGE TOO SMALL
110576             FI
110576             MIN X2DPC; P+0
110600             MIN X2DBC; P+0
110602             IF X2D00><"X21PL" OR ><"X21KO" THEN
110611                X2DPS*12=:T; X2D00-60\/T=:X2DPS     % CONVERT FROM ASCII
110620             FI
110620             IF X2D00="X21KO" AND X2DPS<=24 THEN    % IMPORTENT CP SIGNAL?
110630                0=:X2DPS=:X2DPC                     % NO, FOREGET IT
110632             FI
110632             CALL X2GET; *JMP *-1                   % GET NEXT CHARACTER
110634          OD
110635          IF X2DPS>=24 THEN T:=X2FCP; GO OUT FI     % SERIOUS CP  STOPP
110643          IF X2DPC > 2 THEN T:=X2FEC; GO OUT FI     % EXTENDED CP SIGNAL
110651          T:=0
110652   OUT:   X:=X2DMP; A:=X2DSR=:P
110655   RBUS
110660
110660
110660   %      TAKE ACTION ACCORDING TO CALL PROGRESS SIGNAL
110660
110660
110660   %
110660   %
110660   %      CALLED/CALLING LINE IDENTIFICATION        ** STATE 10
110660   %      OR DCE PROVIDED INFORMATION
110660
110660   SUBR X2110
110660   X2110: T:=12=:X2DST:=L=:X2DSR; CALL STORE        % ENTERING STATE 10
110665          X:=0=:X2DPC
110667             DO WHILE X2D00><"X21PL"
110673                X:=X2DPC
110674                T:=X2DMP+X2M3; *1BANK; SBYT; 2BANK  % STORE IN MESSAGE
110701                MIN X2DBC; P+0                      % MESSAGE LENGTH INCREMENTED
110703                MIN X2DPC; P+0
110705                IF X2DBC = 0 THEN T:=X2FSM; GO OUT FI % NO MORE SPACE IN MESSAGE
110711                CALL X2GET; *JMP *-1
110713             OD
110714             X:=X2DPC; T:=X2DMP+X2M3; A:="X21PL"; *1BANK; SBYT; 2BANK
110723             MIN X2DBC; P+0                         % MESSAGE LENGTH INCREMENTED
110725             T:=0
110726   OUT:   A:=X2DSR=:P                               % EXIT
110730   RBUS
110732
110732
110732

110732   %***********************************
110732   %
110732   %      READY FOR DATA, AND LEAVE X21
110732   %
110732   %************************************
110732
110732   SUBR X2112,X21RT
110732
110732   %
110732   %
110732   %      READY FOR DATA
110732
110732   X2112: 0=:TMR; 14=:X2DST                         % POSSIBLE DELAY HERE ?????
110735
110735              %
110735              % Initialize the HDLC to BOP by using  the parameters
110735              % residing in the HDLC datafield X2DUI and X2DUO.
110735              %
110735
110735              % CLEAR INTERFACE
110735   X2IHD:     *JMP * 2; ASBEF                           % JMP I * 1 (TO ASBEF) TO
110737                                                        % AVOID INITIALIZATION OF
110737                                                        % HDLC FROM X.21 DRIVER
110737              A:=X2DUI.TYPRING
110741              IF  A BIT 5IOBT THEN
110743                   GO FAR ASBEF
110744              FI
110744              10 =: X.PCREG        % CRC SELECTION AND
110746                                   % IDLE MODE=1 (TRANSMIT FLAGS DURING UNDERRUN)
110746              A:=100; T:=X2DHD+XWRTC; *EXR ST           % DEVICE CLEAR, KEEP C ON
110752              A:=140; *EXR ST                           % SET MAINTENANCE MODUS, CLEAR PULSE
110754              T:=X2DHD+XWDCR; *EXR ST                   % CLEAR DMA ALSO
110757
110757              X:=-30; T:=X2DHD+XRDCR; *EXR ST           % WAIT FOR DMA TO BE READY
110763              *JPC TODMA; JAF *-2                       % LEAVE ON TIMEOUT
110765
110765              A:=100; T:=X2DHD+XWRTC; *EXR ST           % DEVICE CLEAR, OUT OF MAINT.MOD
110771
110771              % INITIATE INTERFACE
110771              A:=X2DUI.XINITA+DPITPHYS                  % ADD DPITPHYS TO GET PHYS. ADDR.
110774              T:=X2DHD+XWDMA; *IOF;     EXR ST          % USE THE SAVE LOCATIONS IN HDLC-DF
111000              401;    T+"XWDCR-XWDMA"; *EXR ST          % FOR DMA INITIALIZE.
111003              X:=-30; T+"XRDCR-XWDCR"; *EXR ST          % READ STATUS ( TO BE 0)
111006              *JPC TODMA; JAF *-2
111010              *ION  %%; TRR 10                              % CLEAR CACHE
111011              A:=2000; X:=X2DUI+A; X.CHECK              % FORCE CACHE MISS
111015              IF X2DUI.CHECK><INTCH THEN GO TODMA FI    % ERROR, DO NOT USE DMA NOW.
111023              T:= X2DHD+WTCR
111025              A:=5; *EXR ST
111027              A:=0; X:=X2DUI
111031              A=: X.PCREG
111032
111032              A:=134;  T:=X2DHD+XWTTC;  *EXR ST         % ENABLE DMA & XMIT, RQTS ON
111036
111036              % START RECEIVER
111036              X2DUI.MAINT;      T:=X2DHD+XWRTC; *EXR ST % CLEAR OLD GARBAGE
111043              X.LIINT+DPITPHYS; T:=X2DHD+XWDMA; *EXR ST % OLD LISTPTR IS USED !!
111050              A:=1001; T+"XWDCR-XWDMA";         *EXR ST % START RECEIVER (BANK 1)
111053              X:=-30;  T+"XRDCR-XWDCR";         *EXR ST % READ STATUS
111056              *JPC TODMA; JAF *-2
111060              GO ASBEF
111061   *)FILL
111066   TODMA:     *ION
111067              X:=X2DUI                                  % HDLC INPUT
111070              0=:X.HINIF=:X.OQUEU=:X.IQUEU=:X.WAKEF     % CLEAR EVERYTHING
111074              1=:X.INTSTA
111076              X:=X2DUO                                  % HDLC OUTPUT
111077              0=:X.HINIF=:X.OQUEU=:X.IQUEU=:X.WAKEF     % CLEAR EVERYTHING
111103              0=:X.ACTSW;   1=:X.INTSTA
111106                                                     % GIVE NO RESPONCE TO USER
111106                                                     % ERROR WILL OCCUR WHEN ACCESSING
111106                                                     % ACCESSING THE QUEUES.
111106   ASBEF:                                            % As before.
111106
111106          304; T:=X2DHD+XWRTC; *EXR ST              % TAKE CARE OF MODEM STATUS
111112          CALL STORE
111113
111113   %
111113   %
111113   %      LEAVE X21
111113
111113   X21RT: X:=X2DMPM;  *1BANK
111115          A:=X.X2MFA; *2BANK
111117          IF A BIT X21C1 THEN 1=:X2DCC FI           % MARK IF CHARGING REQUEST
111123          IF X2DCC = 2 THEN 0=:X2DCC FI             % WILL NOT SAVE OLD CHARGING
111130          X21OP=:X2DUI.HXDOK=:X2DUO.HXDOK           % OPEN LOCK IN USER DRIVER
111135          X2FOK; CALL X21UT
111137
111137   RBUS
111142
111142

111142   %============================================
111142   % 40.29      X 2 1 8         X 2 1 9
111142
111142   %*******************************
111142   %
111142   %      CALLED DTE
111142   %
111142   %*******************************
111142
111142   SUBR X218,X219
111142   %      INCOMMING CALL                            ** STATE 8 **
111142
111142   X218:  10=:X2DST; A:=L=:X2DSR; CALL STORE
111147          CALL XTSTC; GO NOMES; CALL X2STA          % ANY NEW MESSAGES ON MY WAY IN HERE ?
111152   NOMES: 0=:WAKEF                                  % WAKE ME IF ANY MESSAGES
111153          7=:X2D11                                  % C= OFF
111155          DO WHILE X2D00><"X21BL"                   % WAIT FOR BELL
111161             CALL X2GET; *JMP *-1
111163          OD
111164
111164
111164   %
111164   %      CALL ACCEPTED
111164   %      T = 1, C = ON, R = BEL, I = OFF
111164   %
111164   X219:  1=:WAKEF; 307=:X2D11; 11=:X2DST           % C = ON, ENABLE RECEIVER
111172          X21T4=:TMR; CALL STORE
111175          X2DSR=:P
111177   RBUS
111204
111204   %===============================================================================
111204   %
111204   %      SOME INTERFACE ROUTINES
111204   %
111204   SUBR O3CHA,D3CHA
111204   INTEGER SAVL,SAVL2
111206   O3CHA: A:=L=:SAVL; X=:D; A:=0; AD SHZ 6; T:="PITEX" SHZ -12
111215          A-T+MPTPHPAGE
111217          AD SHZ -6; D=:X
111221          CALL OCHAIN
111222          A:=SAVL=:P
111224   D3CHA: A:=L=:SAVL2
111226          CALL DICHAIN; GO NSKIP
111230          MIN SAVL2; P+0
111232          X=:D; A:=0; AD SHZ 6; T:="PITEX" SHZ -12
111237          A-MPTPHPAGE+T; AD SHZ -6; D=:X
111243   NSKIP: A:=SAVL2=:P
111245   RBUS
111251
111251
111251   *"
"111251
111251   *"8C1X2
"111251   INTEGER ARRAY X2S01(200)
111451   INTEGER ARRAY X2E01(0)
111451   *"
"111451   *"8C2X2
"111451   INTEGER ARRAY X2S02(200)
111651   INTEGER ARRAY X2E02(0)
111651   *"
"111651   *"8C3X2
"111651   *"8C4X2
"111651   *"8C5X2
"111651   *"8C6X2
"111651
111651   @DEV 1
111651   @DEV (S-S-L)MP-P2-PERF-DATA:NPL
111651

111651   *"8MPRF
"111651   % Revision log:
111651   %
111651   % 871020: eny: Removed label NPRST from descriptor table
111651   % 871029: eny: Removed primitive #33,#34.
111651   % 871122: btt: Removed primitive #35.
111651   % 871125: btt: Several changes concerning prim. 2 and multi-CPU.
111651   %
111651   %
111651   %
111651
111651   INTEGER S13INDEX                   % Index in jump-table on level 13
111652   INTEGER MLVINDEX                   % Index in jump-table on level 2
111653   INTEGER MPITBANK,MPITADDR
111655   DOUBLE  DMPITADDR=MPITBANK         % Phys addr of start of mpit segment
111655
111655   INTEGER ARRAY PRIMACTIVES(MXACTPRIMS) % Primitive numbers of current active primitives
111665   INTEGER ARRAY XBUSARRAY(40)        % Addr of double words on mpit to
111725                                      % Add the value of dbuphysaddr into.
111725   DOUBLE  ARRAY DXRARRAY(0)
111725   INTEGER ARRAY XRARRAY(40)          % Addr of option specific routines for
111765                                      % Initializing option dependent buffers
111765
111765
111765   INTEGER ARRAY PARBUFF(MXTPBLENGTH)          % Copy of caller's parameter block
112765
112765   % Array of level 13 and level 2 sampling routines for each primitives
112765   % 2 locations for each primitive.
112765   % Primitive number is index in the table.
112765   @ICR;
112765   DOUBLE  ARRAY SAMPADDRS:=(
112765           0,0,MRP01,MMP01,MRP02,MMP02,0,MMP03,0,MMP04,  % prim.: 1,2,3,4
112777           0,0,0,0,0,0,0,0,0,0,
113011           0,0,0,0,0,0,0,0,0,0,
113023           0,0,0,0,0,0,0,0,0,0,
113035           0,0,0,0,0,0,0,0,0,0,
113047           0,0,0,0,0,0,0,0,0,0,
113061           0,0,0,0,0,0,0,0,0,0,
113073           0,0,0,0,0,0,0,0,0,0,
113105           0,0,0,0,0,0,0,0,0,0,
113117           0,0,0,0,0,0,0,0,0,0,
113131           0,0,0,0,0,0,0,0,0,0,
113143           0,0,0,0,0,0,0,0,0,0,
113155           0,0,0,0,0,0,0,0,0,MMP64,                      % prim.: 64
113167           0,MMP65,MRP66,0,0,0,0,0,0,0,                  % prim.: 65,66
113201           0,0,0,0,0,0,0,0,0,0,
113213           0,0,0,0,0,0,0,0,0,0,
113225           0,0);
113227
113227   % Array of primitive descriptor for each primitive.
113227   % The primitive number is index in the table.
113227
113227   INTEGER ARRAY APRDESCR:=(
113227           0,OPD01,OPD02,OPD03,OPD04,0,0,0,0,0,
113241           0,0,0,0,0,0,0,0,0,0,
113253           0,0,0,0,0,0,0,0,0,0,
113265           0,0,OPD32,0,0,0,OPD36,OPD37,0,0,
113277           0,0,0,0,0,0,0,0,0,0,
113311           0,0,0,0,0,0,0,0,0,0,
113323           0,0,0,0,OPD64,OPD65,OPD66,OPD67,0,0,
113335           0,0,0,0,0,0,0,OPD77,0,0,
113347           0,0,0,0,0,0,0,0,0,0,
113361           0);
113362
113362
113362   %-----------------------------------------------------------------------------
113362   % Option descriptor for primitive # 1, nd-100  cpu utilisation.
113362   %
113362   DATA   (-1,
113363           71, 100000+3, BAR1C, 0);            % Optional buffer descriptor
113367   INTEGER ARRAY OPD01:=(
113367           7,                                  % Max number of options
113370           72,                                 % Data block size
113371           DPR01,                              % Address of datablock
113372           100000, LTCP1, 0, 0,     0,         % Total nd-100 cpu
113377           10000,  LSCP1, 0, 0,     0,         % Nd-100 cpu usage split on user mode,
113404                                               % Mon.call mode and system mode
113404           1000,   LLCP1, 0, 0,     0,         % Cpu usage split on interrupt levels
113411           100,    LRCP1, 0, P01R1, 0,         % Cpu usage by a specific program
113416           200,    ARCP1, 1, 0,     P01X1,     % Cpu usage split over all programs
113423           10,     1RCP1, 0, P01R1, 0,         % Cpu usage by a specific program split
113430                                               % Over user mode, mon.call mode and system overhead
113430           1,      MMP01, 0, 0,     0,         % Nd-110 execution queue length
113435           0);
113436
113436   %-----------------------------------------------------------------------------
113436   % Option descriptor for primitive # 2, nd-500 cpu utilisation
113436   %
113436   DATA   (-1,
113437           56, 40000+2, BAR5C, 0);             % Optional buffer descriptor
113443   INTEGER ARRAY OPD02:=(
113443           6,                                  % Max number of options
113444           57,                                 % Data block size
113445           DPR02,                              % Address of datablock
113446           100000, LTCP5, 0, CH5OK, 0,         % Total nd-500 cpu utilisation
113453           10000,  CP5MO, 0, CH5OK, 0,         % Nd-500 cpu usage split over user mode
113460                                               % And swapper mode
113460           100,    APCP5, 0, P02R2, 0,         % Nd-500 cpu utilisation by a specific process
113465           200,    ALLC5, 1, P02R3, P02X1,     % Nd-500 cpu utilisation split over
113472                                               % All processes
113472           10,     XC5MO, 0, P02R2, 0,         % Nd-500 cpu utilisation by a specific process
113477                                               % Split over user mode and swapper mode
113477           1,      MMP02, 0, CH5OK, 0,         % Nd-500 execution length
113504           0);
113505
113505   %-----------------------------------------------------------------------------
113505   % Option descriptor for primitive # 3, usage of logical units.
113505   %
113505   DATA   (-1,
113506           143, 100000+41, BLUAD, 0);          % Optional buffer descriptor
113512   INTEGER ARRAY OPD03:=(
113512           4,                                  % Max number of options.
113513           144,                                % Data block size.
113514           DPR03,                              % Address of data block.
113515           100000, TUTLG, 0, P03RF,     0,     % Total usage of logical units.
113522           100,    UTLGX, 0, P03R1,     0,     % Usage of logical units by a specific rt-program.
113527           200,    AUTLG, 1, P03RF, P03X1,     % Usage of logical units split over all rt-programs.
113534           1,      LUWQU, 0, P03RF,     0,     % Waiting queue lengths of the logical units.
113541           0);
113542
113542   %-----------------------------------------------------------------------------
113542   % Option descriptor for primitive # 4, usage of nd-500 swapper.
113542   %
113542   DATA   (-1,
113543           7, 40000+2, B5SWA, 0);              % Optional buffer descriptor
113547   INTEGER ARRAY OPD04:=(
113547           3,                                  % Max number of options.
113550           10,                                 % Data block size.
113551           DPR04,                              % Address of data block.
113552           100000, T5SWP, 0, CH5OK,     0,     % Total usage of nd-500 swapper
113557           100,    X5SWP, 0, P04R2,     0,     % Usage of nd-500 swapper by a specific process
113564           200,    A5SWP, 1, CH5OK, P04X1,     % Total usage of nd-500 swapper
113571                                               % Split over all processes
113571           0);
113572
113572   %-----------------------------------------------------------------------------
113572   % Option descriptor for primitive #32, disk access log.
113572   %
113572   DATA   (-1,
113573           123, 0, BDLBU, 0);                  % Optional buffer descriptor
113577   INTEGER ARRAY OPD32:=(
113577           4,                                  % Max number of options
113600           124,                                % Data block size
113601           DPR32,                              % Address of data block
113602           100000, TDALO, 0, P32R1, 0,         % Count all accesses
113607           10000,  TYDAL, 0, P32RF, 0,         % Accesses split on type
113614           1000,   RWDAL, 0, P32RF, 0,         % Accesses split on read/write
113621           100,    XDLOG, 1, P32R4, P32X1,     %
113626           DIALO, 0);                          % Labels to usoption/nusoption code.
113630
113630   %-----------------------------------------------------------------------------
113630   % Option descriptor for primitive #36, nd-100 monitor call log.
113630   %
113630   DATA   (-1,
113631           3, 1000, BMLB1, 0,                  % Optional buffer descriptor
113635           4,    0, BXML1, 0);                 % Optional buffer descriptor
113641   INTEGER ARRAY OPD36:=(
113641           2,                                  % Max number of options
113642           5,                                  % Data block size
113643           DPR36,                              % Address of datablock
113644           100000, PMLAL, 2, P36R1, 0,         % Total mon.call count/total mon.call count for specified program
113651           10000,  PMLXA, 1, P36R2, P36X2,     % 8 mon.calls split over all rt-programs, or
113656                                               % All mon.calls split over 8 rt-programs
113656           PML10,0);                           % Labels to usoption/nusoption code.
113660
113660   %-----------------------------------------------------------------------------
113660   % Option descriptor for primitive #37, nd-500 monitor call log.
113660   %
113660   DATA   (-1,
113661           3, 1250, BMLB5, 0,                  % Optional buffer descriptor.
113665           4,    0, BXML5, 0);                    % Optional buffer descriptor.
113671   INTEGER ARRAY OPD37:=(
113671           2,                                  % Max number of options
113672           5,                                  % Data block size
113673           DPR37,                              % Address of datablock
113674           100000, 5MLAL, 2, P37R1, 0,         % Total mon.call count/total mon.call count for specified process
113701           10000,  5MLXA, 1, P37R2, P37X2,     % 8 mon.calls split over all nd-500 processes.
113706                                               % All mon.calls split over 8 nd-500 processes.
113706           PML50,0);                           % Labels to usoption/nusoption code.
113710
113710   %-----------------------------------------------------------------------------
113710   % Option descriptor for primitive #64, count pages in memory for nd-100 segments
113710   %
113710   DATA   (-1);
113711   INTEGER ARRAY OPD64:=(
113711           1,                                  % Max number of options
113712           33,                                 % Data block size
113713           DPR64,                              % Address of datablock
113714           0,      NOOP,  0, P64R1, 0,         %
113721           0);
113722
113722   %-----------------------------------------------------------------------------
113722   % Option descriptor for primitive #65, count pages in memory for nd-500 segments
113722   %
113722   DATA   (-1);
113723   INTEGER ARRAY OPD65:=(
113723           1,                                  % Max number of options
113724           33,                                 % Data block size
113725           DPR65,                              % Address of datablock
113726           0,      NOOP,  0, P65R1, 0,         %
113733           0);
113734
113734   %-----------------------------------------------------------------------------
113734   % Option descriptor for primitive #66, nd-100 program counter histogram.
113734   %
113734   DATA   (-1);
113735   INTEGER ARRAY OPD66:=(
113735           1,                                  % Max number of options
113736           205,                                % Data block size
113737           DPR66,                              % Address of datablock
113740           0,      NOOP,  0, P66R1, 0,         %
113745           0);
113746
113746   %-----------------------------------------------------------------------------
113746   % Option descriptor for primitive #67, nd-500 program counter histogram.
113746   %
113746   DATA   (-1);
113747   INTEGER ARRAY OPD67:=(
113747           1,                                  % Max number of options
113750           205,                                % Data block size
113751           DPR67,                              % Address of datablock
113752           0,      NOOP,  0, P67R1, 0,         %
113757           P67L1,P67L2,0);                     % Labels to usoption/nusoption code
113762
113762   %==============================================================================
113762   %-----------------------------------------------------------------------------
113762   % Option descriptor for primitive #77, nd-500 TRACE
113762   %
113762   DATA   (-1,
113763           7, 20070, BTRAC, 0)                  % Optional buffer descriptor.
113766   INTEGER ARRAY OPD77:=(
113766           11,                                 % Max number of options
113770           11,                                 % Data block size
113771           DPR77,                              % Address of datablock
113772           100,  TRDEC, 1, P77R1, 0,           % decomess
113777           200,  TRN5C, 1, P77R2, 0,           % n500c
114004           400,  TRACS, 1, P77R3, 0,           % 5actswapper
114011           1000, TRT5X, 1, P77R4, 0,           % ito500xq
114016           2000, TRF5X, 1, P77R5, 0,           % ifm500xq
114023           4000, TTER5, 1, P77R6, 0,           % xter500
114030           10000,TRAC5, 1, P77R7, 0,           % xact500
114035           20000,TRMCC, 1, P7710, 0,           % mcco
114042           40000,TRSWP, 1, P7720, 0,           % swpdecoder
114047           0);                                 % No main primitive routine
114050   @CR;
114050
114050   %=============================================================================
114050   % Data for primitive #1            block size=
114050   %
114050   INTEGER DPR01:=(1,0,0)             % Parblock header
114053   INTEGER 1D1CP,2D1CP                % Total ND-100 CPU utilisation
114055   INTEGER 1U1CP,2U1CP                % ND-100 CPU usage in user mode (user programs)
114057   INTEGER 1M1CP,2M1CP                % ND-100 CPU usage in monitor call mode
114061   INTEGER 1S1CP,2S1CP                % ND-100 CPU usage in system mode (system overhead)
114063   INTEGER 1CPAR(40)                  % ND-100 CPU usage split on each interrupt level
114123   INTEGER 1R1CP,2R1CP                % ND-100 CPU usage while a spesific program is current
114125   INTEGER 1RU1C,2RU1C                % ND-100 CPU usage in user mode while a
114127                                      % spesific program is current
114127   INTEGER 1RM1C,2RM1C                % ND-100 CPU usage in monitor call mode while
114131                                      % a spesific program is current
114131   INTEGER 1RS1C,2RS1C                % ND-100 CPU usage in system mode while a
114133                                      % spesific program is current
114133   DOUBLE  IEXQL                      % Number of programs in execution queue waiting for I/O
114135   DOUBLE  REXQL                      % Number of programs in execution queue waiting for CPU
114137   DOUBLE  SEXQL                      % Number of programs in execution queue waiting for swapper
114141   DATA    (0)
114142   INTEGER ACRTP                      % RT-descr of the "spesific" program.
114143   INTEGER BAR1CPU,SAR1CPU            % Physical addr of data for ND-100 CPU usage
114145   DOUBLE  DBAR1CPU=BAR1CPU
114145
114145
114145   %===========================================================================
114145   % Data for primitive #2
114145   %
114145   INTEGER ARRAY DPR02:=(2,0,0)       % Parblock header
114150   DOUBLE ARRAY D5CP(4)               % Total nd-500(0) cpu utilisation
114160   DOUBLE ARRAY CP5S(4)               % Nd-500(0) cpu utilisation in swapper mode
114170   DOUBLE ARRAY CP5U(4)               % Nd-500(0) cpu utilisation in swapper mode
114200   DOUBLE ARRAY XCP5(4)               % Nd-500(0) cpu usage of a spesific process
114210   INTEGER 1XPRS,2XPRS                % Nd-500(0) swapper usage by a spesific process
114212   INTEGER 1XPRU,2XPRU                % Nd-500(0) cpu usage by a spesific process
114214   DOUBLE  LE5XQ                      % Number of ready processes in nd-500 execution queue
114216   DOUBLE  LW5XQ                      % Number of waiting processes in nd-500 execution queue, not waiting for swappeR.
114220   DOUBLE  LS5XQ                      % Number of processes waiting for swapper in nd-500 executin queue.
114222   DATA    (0)
114223   INTEGER BAR5CPU,SAR5CPU            % Phys addr of data of nd-500 cpu usage
114225   DOUBLE  DBAR5CPU=BAR5CPU
114225   INTEGER LXCPU                      % Specified CPU number
114226   INTEGER Y5PROC                     % Spesified process number
114227   @ICR
114227   INTEGER ARRAY LUADD:=(
114227           ADD1I,ADD1O,ADD2I,ADD2O,ADD3I,ADD3O,ADD4I,ADD4O,
114237           ADD5I,ADD5O,ADD6I,ADD6O,ADD7I,ADD7O,ADD8I,ADD8O);
114247   @CR;
114247   INTEGER ADD1I,ADD1O
114251   INTEGER ADD2I,ADD2O
114253   INTEGER ADD3I,ADD3O
114255   INTEGER ADD4I,ADD4O
114257   INTEGER ADD5I,ADD5O
114261   INTEGER ADD6I,ADD6O
114263   INTEGER ADD7I,ADD7O
114265   INTEGER ADD8I,ADD8O
114267
114267
114267   %-------------------------------------------------------------------------
114267   % Data block for primitive #3
114267   INTEGER ARRAY DPR03:=(3,0,0)       % Data block header
114272   INTEGER 1TL1I,2TL1I                % Total usage of log.unit 1 input
114274   INTEGER 1TL1O,2TL1O(35)            % Total usage of log.unit 1 output
114332                                      % Total usage of the max. 7 other units to log.
114332
114332   INTEGER 1XL1I,2XL1I                % Usage of log.unit 1 input by specific program
114334   INTEGER 1XL1O,2XL1O(35)            % Usage of log.unit 1 output by specific program
114372                                      % Usage of the max. 7 other log.units by specific program
114372
114372   DOUBLE ARRAY ADDLW(0)
114372   INTEGER 1WQ1I,2WQ1I                % Wating queue length of log.unit 1 input
114374   INTEGER 1WQ1O,2WQ1O(35)            % Wating queue length of log.unit 1 output
114432                                      % Waiting queue length of max. 7 other log.units
114432
114432   DATA    (0)
114433   INTEGER ARRAY ADDU1(10)            % Disk drive numbers
114443   INTEGER XLRTP                      % Specific program to log
114444   INTEGER BLUADDR,SLUADDR            % Phys addr of data for usage of the actual logical units,
114446                                      % split over all programs.
114446   DOUBLE  DBLUADDR=BLUADDR
114446
114446
114446   %============================================================================
114446   % Data block for primitive # 4
114446   %
114446   INTEGER ARRAY DPR04:=(4,0,0)       % Data block header
114451   INTEGER 1D5SW,2D5SW                % Total usage of nd-500 swapper
114453   INTEGER 1X5SW,2X5SW                % Usage of nd-500 swapper by a specific process
114455   DATA    (0)
114456   INTEGER B5SWAPP,S5SWAPP            % Phys addr of data for usage of nd-500 swapper
114460                                      % split over all processes.
114460   DOUBLE  DB5SWAPP=B5SWAPP
114460   INTEGER XSWOWNER                   % Mailbox addr of specific process to log
114461
114461
114461
114461
114461   %============================================================================
114461   % Data block for primitive #32
114461   %
114461   INTEGER ARRAY DPR32:=(40,0,0)
114464   INTEGER 1TDA1,2TDA1                % Total disc accesses
114466   INTEGER 11FA1,21FA1                % Total nd-100 file i/o accsesses
114470   INTEGER 11SA1,21SA1                % Total nd-100 swapp accesses
114472   INTEGER 15FA1,25FA1                % Total nd-500 file i/o accesses
114474   INTEGER 15SA1,25SA1                % Total nd-500 swapp accesses
114476   INTEGER 1FSA1,2FSA1                % Total nd-500 "file-as-segment" accesses
114500   DOUBLE  DFSA1=1FSA1
114500   INTEGER 1TRA1,2TRA1                % Total read accesses
114502   INTEGER 1WRA1,2TWA1                % Total write accesses
114504   INTEGER 1XRA1,2XRA1                % 1. number of nd-100 file i/o read accesses
114506                                      %    by a specific rt-program.
114506                                      % 2. number of nd-500 file i/o read accesses
114506                                      %    by a specific nd-500 process.
114506                                      % 3. number of nd-100 swapper read accesses
114506                                      %    on a specific nd-100 segment.
114506                                      % 4. number of nd-500 swapper read accesses
114506                                      %    on a specific nd-500 segment.
114506                                      % 5. number of nd-500 "file-as-segment" read accesses
114506                                      %    on a specific nd-500 segment.
114506   INTEGER 1XWA1,2XWA1                % Same as 1xra1/2xra1 but write accesses.
114510
114510   INTEGER 1TDA2,2TDA2                % Total disc accesses
114512   INTEGER 11FA2,21FA2                % Total nd-100 file i/o accsesses
114514   INTEGER 11SA2,21SA2                % Total nd-100 swapp accesses
114516   INTEGER 15FA2,25FA2                % Total nd-500 file i/o accesses
114520   INTEGER 15SA2,25SA2                % Total nd-500 swapp accesses
114522   INTEGER 1FSA2,2FSA2                % Total nd-500 "file-as-segment" accesses
114524   DOUBLE  DFSA2=1FSA2
114524   INTEGER 1TRA2,2TRA2                % Total read accesses
114526   INTEGER 1WRA2,2TWA2                % Total write accesses
114530   INTEGER 1XRA2,2XRA2                % 1. number of nd-100 file i/o read accesses
114532                                      %    by a specific rt-program.
114532                                      % 2. number of nd-500 file i/o read accesses
114532                                      %    by a specific nd-500 process.
114532                                      % 3. number of nd-100 swapper read accesses
114532                                      %    on a specific nd-100 segment
114532                                      % 4. number of nd-500 swapper read accesses
114532                                      %    on a specific nd-500 segment.
114532                                      % 5. number of nd-500 "file-as-segment" read accesses
114532                                      %    on a specific nd-500 segment.
114532   INTEGER 1XWA2,2XWA2                % Same as 1xra2/2xra2 but write accesses.
114534
114534   INTEGER 1TDA3,2TDA3                % Total disc accesses
114536   INTEGER 11FA3,21FA3                % Total nd-100 file i/o accsesses
114540   INTEGER 11SA3,21SA3                % Total nd-100 swapp accesses
114542   INTEGER 15FA3,25FA3                % Total nd-500 file i/o accesses
114544   INTEGER 15SA3,25SA3                % Total nd-500 swapp accesses
114546   INTEGER 1FSA3,2FSA3                % Total nd-500 "file-as-segment" accesses
114550   DOUBLE  DFSA3=1FSA3
114550   INTEGER 1TRA3,2TRA3                % Total read accesses
114552   INTEGER 1WRA3,2TWA3                % Total write accesses
114554   INTEGER 1XRA3,2XRA3                % 1. number of nd-100 file i/o read accesses
114556                                      %    by a specific rt-program.
114556                                      % 2. number of nd-500 file i/o read accesses
114556                                      %    by a specific nd-500 process.
114556                                      % 3. number of nd-100 swapper read accesses
114556                                      %    on a specific nd-100 segment.
114556                                      % 4. number of nd-500 swapper read accesses
114556                                      %    on a specific nd-500 segment.
114556                                      % 5. number of nd-500 "file-as-segment" read accesses
114556                                      %    on a specific nd-500 segment.
114556   INTEGER 1XWA3,2XWA3                % Same as 1xra3/2xra3 but write accesses.
114560
114560   INTEGER 1TDA4,2TDA4                % Total disc accesses
114562   INTEGER 11FA4,21FA4                % Total nd-100 file i/o accsesses
114564   INTEGER 11SA4,21SA4                % Total nd-100 swapp accesses
114566   INTEGER 15FA4,25FA4                % Total nd-500 file i/o accesses
114570   INTEGER 15SA4,25SA4                % Total nd-500 swapp accesses
114572   INTEGER 1FSA4,2FSA4                % Total nd-500 "file-as-segment" accesses
114574   DOUBLE  DFSA4=1FSA4
114574   INTEGER 1TRA4,2TRA4                % Total read accesses
114576   INTEGER 1WRA4,2TWA4                % Total write accesses
114600   INTEGER 1XRA4,2XRA4                % 1. number of nd-100 file i/o read accesses
114602                                      %    by a specific rt-program.
114602                                      % 2. number of nd-500 file i/o read accesses
114602                                      %    by a specific nd-500 process.
114602                                      % 3. number of nd-100 swapper read accesses
114602                                      %    on a specific nd-100 segment.
114602                                      % 4. number of nd-500 swapper read accesses
114602                                      %    on a specific nd-500 segment.
114602                                      % 5. number of nd-500 "file-as-segment" read accesses
114602                                      %    on a specific nd-500 segment.
114602   INTEGER 1XWA4,2XWA4                % Same as 1xra4/2xra4 but write accesses.
114604   DATA    (0)
114605   INTEGER CABFUNC
114606   INTEGER CDRIV
114607   INTEGER CCDAD
114610   INTEGER CCTAC
114611   INTEGER XDLFLAG
114612   INTEGER C5SEG
114613   INTEGER 5NPAR
114614
114614   INTEGER DLUN1,DDRI1                % Datafelt addr and drive number for 1st. disk drive to log.
114616   INTEGER DLUN2,DDRI2                % Datafelt addr and drive number for 2nd. disk drive to log.
114620   INTEGER DLUN3,DDRI3                % Datafelt addr and drive number for 3rd. disk drive to log.
114622   INTEGER DLUN4,DDRI4                % Datafelt addr and drive number for 4th. disk drive to log.
114624   DOUBLE  XFDA1,XLDA1                % Disk address area to log on disc drive 1.
114630   DOUBLE  XFDA2,XLDA2                % Disk address area to log on disc drive 2.
114634   DOUBLE  XFDA3,XLDA3                % Disk address area to log on disc drive 3.
114640   DOUBLE  XFDA4,XLDA4                % Disk address area to log on disc drive 4.
114644
114644   INTEGER ARRAY DILGU:=(DLUN1,DLUN2,DLUN3,DLUN4)
114650   INTEGER ARRAY CDADR:=(1TDA1,1TDA2,1TDA3,1TDA4)
114654
114654   INTEGER XDLXD                      % Specific nd-100 program/nd-500 process.
114655   INTEGER XDLYD                      % Specific nd-100 segment/nd-500 segment.
114656   INTEGER BDLBUADDR,SDLBUADDR        % Physical addr of "extra data buffer"
114660   DOUBLE  DBDLBUADDR=BDLBUADDR
114660   INTEGER BASEG,SASEG
114662   DOUBLE  DDBASEG=BASEG
114662
114662
114662   %----------------------------------------------------------------------------
114662   % Data block primitive #36
114662   %
114662   INTEGER ARRAY DPR36:=(44,0,0)
114665   DATA    (0,0)
114667   INTEGER BMLB1,SMLB1                % Phys addr of optional buffer 1
114671   DOUBLE  D1BMLB=BMLB1
114671   INTEGER BXML1,SXML1                % Phys addr of optional buffer 2
114673   DOUBLE  D1BXML=BXML1
114673   INTEGER MLXRT
114674   INTEGER X1MLP,X2MLP,X3MLP,X4MLP    % Specific rt-program/mon.call
114700   INTEGER X5MLP,X6MLP,X7MLP,X8MLP
114704   DOUBLE  DX1MLP=X1MLP,DX3MLP=X3MLP
114704   DOUBLE  DX5MLP=X5MLP,DX7MLP=X7MLP
114704   INTEGER MLOFLAG
114705
114705
114705   %----------------------------------------------------------------------------
114705   % Data block primitive #37
114705   %
114705   INTEGER ARRAY DPR37:=(45,0,0,0,0)
114712   INTEGER BMLB5,SMLB5                % Phys addr of optional buffer 1
114714   DOUBLE  D5BMLB=BMLB5
114714   INTEGER BXML5,SXML5                % Phys addr of optional buffer 2
114716   DOUBLE  D5BXML=BXML5
114716   INTEGER MLXPROC
114717   INTEGER Y1MLP,Y2MLP,Y3MLP,Y4MLP    % Specific nd-500 process/mon.call
114723   INTEGER Y5MLP,Y6MLP,Y7MLP,Y8MLP
114727   DOUBLE  DY1MLP=Y1MLP,DY3MLP=Y3MLP
114727   DOUBLE  DY5MLP=Y5MLP,DY7MLP=Y7MLP
114727   INTEGER ML5FLAG
114730
114730
114730
114730
114730   %----------------------------------------------------------------------------
114730   % Data block primitive #64
114730   %
114730   INTEGER ARRAY DPR64:=(100,0,0)
114733   INTEGER ARRAY DA1SG(30)            % Pages-in-memory counter for 8 segments
114763   INTEGER ARRAY F1SGS(10)            % Max 8 segment specifier
114773   DATA    (-1)
114774
114774
114774   %----------------------------------------------------------------------------
114774   % Data block primitive #65
114774   %
114774   INTEGER ARRAY DPR65:=(101,0,0)
114777   INTEGER ARRAY DA5SG(30)            % Pages-in-memory counter for 8 segments
115027   INTEGER ARRAY F5SGS(20)            % Max 8 segment specifier
115047   DATA    (-1)
115050
115050
115050
115050
115050   %----------------------------------------------------------------------------
115050   % Data block primitive #66
115050   %
115050   INTEGER ARRAY DPR66:=(102,0,0)
115053   INTEGER ARRAY 1DAPC(200)           % Histogram data for 64 interval
115253   INTEGER 1OUT1,1OUT2                % Outside address area
115255   INTEGER 1FPRG(100)                 % First addr in area to log.
115355   INTEGER PC1SG                      % Specific segment number to log
115356   INTEGER PCRTP                      % Specific rt-program to log
115357   INTEGER PCLEV                      % Interrupt level to log
115360   INTEGER 1PCIN                      % Interval size when fixed interval size
115361   INTEGER 1PCFLAG                    % Routine switch (option dependant)
115362
115362
115362
115362
115362   %----------------------------------------------------------------------------
115362   % Data block primitive #67
115362   %
115362   INTEGER ARRAY DPR67:=(103,0,0)
115365   INTEGER ARRAY 5DAPC(200)           % Histogram data for 64 interval
115565   INTEGER 5OUT1,5OUT2                % Outside address area
115567   INTEGER 5FHPR,5LHPR(201)           % Lower addr in area to log
115771   DOUBLE  D5FHPR=5FHPR
115771   INTEGER 5MPHF
115772   INTEGER 5MHPROC                    % Process description
115773   INTEGER PC5PROC                    % Specific nd-500 process to log
115774   INTEGER 5PCIN                      % Interval size when fixed interval size
115775   INTEGER 5PCFLAG                    % Routine switch (option dependant)
115776   DOUBLE  DCADR                      % Actual P-reg of process
116000
116000   %----------------------------------------------------------------------------
116000   % Data block primitive #77
116000   %
116000   INTEGER ARRAY DPR77:=(115,0,0)
116003   INTEGER 5TNOPAG                    % number of pages in buffer
116004   INTEGER 5TPT1,5TPT2
116006   DOUBLE  5TPOINTER=5TPT1            % current pointer in buffer
116006   INTEGER 5OKPT                      % first OK pointer in buffer
116007   INTEGER BTRAC,STRAC                % Phys addr of optional buffer 1
116011   DOUBLE  DTRAC=BTRAC
116011
116011   INTEGER PROFLAG                    % which processes to trace
116012   INTEGER TRCSIZE                    % size of current messbuff to be logged
116013   INTEGER TRCOPT                     % curr suboption to be logged
116014   INTEGER TRXREG                     % current message to be logged
116015   INTEGER TRINIT                     % =-1 : pointers need to be updated
116016                                      % = 1 : OK
116016   INTEGER DEPFFLAG                   % decomess pf trap
116017   INTEGER DETRFLAG                   % decomess trap-pf
116020   INTEGER DEMCFLAG                   % decomess mcall
116021   INTEGER DECOSIZE                   % size of messbuff to be logged from decomess
116022   INTEGER DECOPT                     % suboption 100
116023
116023   INTEGER N5SIZE                     % size of messbuff to be logged from n500c
116024   INTEGER N5COPT                     % suboption 200
116025
116025   INTEGER ACTSSIZE                   % size of messbuff to be logged from actsw
116026   INTEGER ACTSCOPT                   % suboptionn 400
116027
116027   INTEGER T5XQSIZE                   % size of messbuff to be logged from ITO500XQ
116030   INTEGER T5XQCOPT                   % suboption 1000
116031
116031   INTEGER F5XQSIZE                   % size of messbuff to be logged from IFM500XQ
116032   INTEGER F5XQCOPT                   % suboption 2000
116033
116033   INTEGER ACTSIZE                    % size of messbuff to be logged from ACT500
116034   INTEGER ACT5COPT                   % suboption 4000
116035
116035   INTEGER TER5SIZE                   % size of messbuff to be logged from TER500
116036   INTEGER TER5COPT                   % suboption 10000
116037
116037   INTEGER MCCOSIZE                   % size of messbuff to be logged from MCCO
116040   INTEGER MCCOCOPT                   % suboption 20000
116041
116041   INTEGER SWPDSIZE                   % size of messbuff to be logged from SWPDECODER
116042   INTEGER SWPDCOPT                   % suboption 40000
116043
116043
116043   INTEGER 5TPAGNO                    % physical page of buffer
116044   INTEGER 5TEN1,5TEN2                %
116046   DOUBLE  5TDEN=5TEN1                % last address of buffer (+1)
116046   INTEGER 5TBANK                     % trace buffer bank number
116047   INTEGER 5TADDRESS                  % address within bank
116050   DOUBLE  5TDADDRESS=5TBANK
116050   INTEGER 5TSTATUS                   % trace buffer status
116051           SYMBOL 5RWRAP=17
116051   INTEGER ARRAY SPACE:=(50,120,160,210)
116055   INTEGER ARRAY 5TTRA:=(40,40,150,200)
116061   INTEGER ARRAY 5XSTA:=(0,0,0,30)
116065
116065   INTEGER Y1TRP,Y2TRP,Y3TRP,Y4TRP
116071   INTEGER Y5TRP,Y6TRP,Y7TRP,Y8TRP
116075   DOUBLE  DY1TRP=Y1TRP,DY3TRP=Y3TRP
116075   DOUBLE  DY5TRP=Y5TRP,DY7TRP=Y7TRP
116075
116075   *"
"116075
116075   @DEV 1
116075   @DEV (S-S-L)MP-P2-PERF-CODE:NPL
116075

116075   *"8MPRF 8N500
"116075   %
116075   % The following primitives are available to operate upon
116075   % with the monitor call MON PERFORMANCE
116075   %
116075   % Primitive no.  1: Use of the ND-100 CPU.
116075   % Primitive no.  2: Use of the ND-500 CPU.
116075   % Primitive no.  3: Use of logical devices in ND-100.
116075   % Primitive no.  4: Use of ND-500 swapper.
116075   % %Primitive no.  5: Use of SIBAS-500.                                  -- B-version --
116075   % %Primitive no.  6: ND-100 CPU utilisation by a set of ND-100 segments -- B-version --
116075   % %Primitive no.  7: Resources reserved by a specific ND-100 program.   -- B-version --
116075   %
116075   % Primitives no. 8-31: not yet defined.
116075   %
116075   % Primitive no. 32: Disc access count.
116075   % Primitive no. 36: Monitor call log in ND-100.
116075   % Primitive no. 37: Monitor call log in ND-500.
116075   %
116075   % Primitives no. 38-63: not yet defined.
116075   %
116075   % Primitive no. 64: Number of pages in memory for a specific ND-100 segment.
116075   % Primitive no. 65: Number of pages in memory for a specific ND-500 segment.
116075   % Primitive no. 66: ND-100 program counter histogram.
116075   % Primitive no. 67: ND-500 program counter histogram.
116075   %
116075   % Primitives no. 68-80: not yet defined.
116075   %
116075   % The monitor call MON PERFO has the following layout:
116075   %
116075   %                LDA (PLIST        % A-reg points to parameter liste
116075   %                MON PERFO
116075   %                JMP ERROR         % error return; A-reg is errorcode
116075   %                                  % skip-return when no error.
116075   %
116075   % Parameter liste, MON PERFO has 5 parameters
116075   % PLIST,         MPRFUNCTION
116075   %                MPRPRIMITIVES
116075   %                MPRPARBLOCK
116075   %                MPRSAMPLERATE
116075   %                MPRSTOPTIME
116075   % MPRFUNCTION, 1
116075   % MPRPRIMITIVES=*; *+5/               % 80 bits=80 primitives
116075   % MPRPARBLOCK=*;   *+xx/              % parameter blocks for active primitives
116075   % MPRSAMPLERATE, 1                    % valid for MPRFUNCTION=1 else dummy
116075   % MPRSTOPTIME, 0;0                    % valid for MPRFUNCTION=1 else dummy
116075   %
116075   %
116075   % Parameter descriptions:
116075   % Function:  16 bits integer
116075   %            =1: initialize measurement.
116075   %            =2: read collected data
116075   %            =3: terminate measurement
116075   %
116075   % Primitives:
116075   %            80 bits bit-array; 1 bit for each primitive.
116075   %            This bit-array has the same layout as PLANC uses.
116075   %            A bit set to one means that the primitive with the number
116075   %            equal to the bit number should be activated.
116075   %            Max. 8 primitives can be active simultaneously.
116075   %
116075   % Parblock:
116075   %            Array used to spesify parameters for each primitive
116075   %            when MPRFUNCTION=1.
116075   %            Array where the collected data is returned
116075   %            when MPRFUNCTION=2.
116075   %
116075   %
116075   % Parblock descriptions for each primitive:
116075   %
116075   %============================================================================
116075   % Primitive no.  1: Use of the ND-100 CPU.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: rt-program (rt-description address)
116075   %
116075   %   Option codes:
116075   %       100000: total ND-100 CPU utilisation.
116075   %       10000:  ND-100 CPU utilisation split on user mode,mon.call mode and sys.mode
116075   %       1000:   ND-100 CPU utilisation split on all hardware interrupt levels.
116075   %       200:    ND-100 CPU utilisation split on all rt-programs.
116075   %       100:    ND-100 CPU utilisation by a specific rt-program.
116075   %       10:     ND-100 CPU utilisation by a specific rt-program, split on user
116075   %               mode, mon.call mode and system mode.
116075   %       1:      ND-100 execution queue length.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4- 5: total ND-100 CPU utilisation.
116075   %      Word  6- 7: ND-100 CPU utilisation in user mode.
116075   %      Word 10-11: ND-100 CPU utilisation in monitor call mode.
116075   %      Word 12-13: ND-100 CPU utilisation in system mode.
116075   %      Word 14-15: ND-100 CPU used on interrupt level 0.
116075   %      Word 16-17: ND-100 CPU used on interrupt level 1.
116075   %      Word 20-21: ND-100 CPU used on interrupt level 2.
116075   %      Word 22-23: ND-100 CPU used on interrupt level 3.
116075   %      Word 24-25: ND-100 CPU used on interrupt level 4.
116075   %      Word 26-27: ND-100 CPU used on interrupt level 5.
116075   %      Word 30-31: ND-100 CPU used on interrupt level 6.
116075   %      Word 32-33: ND-100 CPU used on interrupt level 7.
116075   %      Word 34-35: ND-100 CPU used on interrupt level 8.
116075   %      Word 36-37: ND-100 CPU used on interrupt level 9.
116075   %      Word 40-41: ND-100 CPU used on interrupt level 10.
116075   %      Word 42-43: ND-100 CPU used on interrupt level 11.
116075   %      Word 44-45: ND-100 CPU used on interrupt level 12.
116075   %      Word 46-47: ND-100 CPU used on interrupt level 13.
116075   %      Word 50-51: ND-100 CPU used on interrupt level 14.
116075   %      Word 52-53: ND-100 CPU used on interrupt level 15.
116075   %      Word 54-55: ND-100 CPU used while a specific program was active
116075   %      Word 56-57: ND-100 CPU used in user mode while a specific
116075   %                  program was active
116075   %      Word 60-61: ND-100 CPU used in monitor call mode while a specific
116075   %                  program was active
116075   %      Word 62-63: ND-100 CPU used in system mode while a specific
116075   %                  program was active
116075   %      Word 64-65: Number of programs waiting for ND-100 CPU.
116075   %      Word 66-67: Number of programs in i/o-wait in the Execution queue
116075   %      Word 70-71: Number of programs in swap-wait in the Execution queue.
116075   %      Word 72:    address of array where ND-100 CPU usage, split over
116075   %                  all rt-program, is returned.
116075   %                  The first word in this array will contain the nuber of
116075   %                  elements in the array, (=number of rt-program in the system)
116075   %                  Each element consist of 3 words, the rt-description address
116075   %                  and a double word for ND-100 CPU utilisation for this
116075   %                  rt-program.
116075   %
116075   %=============================================================================
116075   % Primitive no.  2: Use of the ND-500(0) CPU.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: ND-500(0) process number.
116075   %      Word  5: ND-500(0) CPU number
116075   %
116075   %   Option codes:
116075   %       100000: total ND-500(0) CPU utilisation - all CPU's.
116075   %       10000:  ND-500(0) CPU util. split on user and swapper mode - all CPU's.
116075   %       200:    ND-500(0) CPU util. split on all processes - 1 spec. CPU.
116075   %       100:    ND-500(0) CPU util. by a specific process - all CPU's.
116075   %       10:     ND-500(0) CPU utilisation by a specific process, split
116075   %               on user mode and swapper mode.
116075   %       1:      ND-500(0) execution queue length - acc. for all CPU's, split
116075   %               on active, waiting for swapper and other waiting states.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4- 5: total ND-500 cpu utilisation - cpu 1
116075   %      Word  6- 7: total ND-500 cpu utilisation - cpu 2
116075   %      Word 10-11: total ND-500 cpu utilisation - cpu 3
116075   %      Word 12-13: total ND-500 cpu utilisation - cpu 4
116075
116075   %      Word 14-15: total ND-500 cpu swapper util. - cpu 1
116075   %      Word 16-17: total ND-500 cpu swapper util. - cpu 2
116075   %      Word 20-21: total ND-500 cpu swapper util. - cpu 3
116075   %      Word 22-23: total ND-500 cpu swapper util. - cpu 4
116075
116075   %      Word 24-25: total ND-500 cpu user    util. - cpu 1
116075   %      Word 26-27: total ND-500 cpu user    util. - cpu 2
116075   %      Word 30-31: total ND-500 cpu user    util. - cpu 3
116075   %      Word 32-33: total ND-500 cpu user    util. - cpu 4
116075
116075
116075   %      Word 34-35: ND-500 cpu 1 usage by a specific process
116075   %      Word 36-37: ND-500 cpu 2 usage by a specific process
116075   %      Word 40-41: ND-500 cpu 3 usage by a specific process
116075   %      Word 42-43: ND-500 cpu 4 usage by a specific process
116075
116075
116075   %      Word 44-45: ND-500 all cpu usage by the swapper on behalf of
116075   %                  the specific process.
116075   %      Word 46-47: ND-500 all cpu usage by a specific process.
116075   %      Word 50-51: number of processes, ready for execution, in nd-500 execution queue, all CPU's.
116075   %      Word 52-53: number of processes, in waiting state, in nd-500 execution queue, all CPU's.
116075   %      Word 54-55: number of processes, waiting for swapper, in nd-500 execution queue, all CPU's.
116075   %      Word 56:    not used
116075   %      Word 57:    address of array where ND-500 CPU usage for one specified cpu, split over
116075   %                  all processes, is returned.
116075   %                  The first word in this array will contain the number of
116075   %                  elements in the array, (=number of processes in the system)
116075   %                  Each element consist of a double word for ND-500 cpu
116075   %                  utilisation by the process. The process number is index
116075   %                  in the array.
116075   %
116075   %=============================================================================
116075   % Primitive no.  3: Use of logical unit/datafields on ND-100.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: 1st. logical unit/datafield to measure.
116075   %      Word  5: drive number of 1st. log.unit if 1st. unit is disk.
116075   %      Word  6: 2nd. logical unit/datafield to measure.
116075   %      Word  7: drive number of 2nd. log.unit if 2nd. unit is disk.
116075   %      Word 10: 3rd. logical unit/datafield to measure.
116075   %      Word 11: drive number of 3rd. log.unit if 3rd. unit is disk.
116075   %      Word 12: 4th. logical unit/datafield to measure.
116075   %      Word 13: drive number of 4th. log.unit if 4th. unit is disk.
116075   %      Word 14: 5th. logical unit/datafield to measure.
116075   %      Word 15: drive number of 5th. log.unit if 5th. unit is disk.
116075   %      Word 16: 6th. logical unit/datafield to measure.
116075   %      Word 17: drive number of 6th. log.unit if 6th. unit is disk.
116075   %      Word 20: 7th. logical unit/datafield to measure.
116075   %      Word 21: drive number of 7th. log.unit if 7th. unit is disk.
116075   %      Word 22: 8th. logical unit/datafield to measure.
116075   %      Word 23: drive number of 8th. log.unit if 8th. unit is disk.
116075   %      Word 24: spesific rt-program to measure.
116075   %
116075   %   Option codes:
116075   %       100000: total utilisation of the logical device(s).
116075   %       200:    utilisation of the logical device(s), split on all rt-programs.
116075   %       100:    utilisation of the logical device(s) by a specific rt-program.
116075   %       1:      waiting queue length on the logical device(s).
116075   %       Bit #14 set in option code (=40000B), means that the datafields to measure
116075   %       is specified with addresses and not by logical unit numbers.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4- 5: total usage of logical unit/datafield 1 input.
116075   %      Word  6- 7: total usage of logical unit 1 output.
116075   %      Word 10-11: total usage of logical unit/datafield 2 input.
116075   %      Word 12-13: total usage of logical unit 2 output.
116075   %      Word 14-15: total usage of logical unit/datafield 3 input.
116075   %      Word 16-17: total usage of logical unit 3 output.
116075   %      Word 20-21: total usage of logical unit/datafield 4 input.
116075   %      Word 22-23: total usage of logical unit 4 output.
116075   %      Word 24-25: total usage of logical unit/datafield 5 input
116075   %      Word 26-27: total usage of logical unit 5 output
116075   %      Word 30-31: total usage of logical unit/datafield 6 input.
116075   %      Word 32-33: total usage of logical unit 6 output.
116075   %      Word 34-35: total usage of logical unit/datafield 7 input.
116075   %      Word 36-37: total usage of logical unit 7 output.
116075   %      Word 40-41: total usage of logical unit/datafield 8 input.
116075   %      Word 42-43: total usage of logical unit 8 output.
116075
116075   %      Word 44-45: usage of logical unit/datafield 1 input, by a specific program
116075   %      Word 46-47: usage of logical unit 1 output, by a specific program
116075   %      Word 50-51: usage of logical unit/datafield 2 input, by a specific program
116075   %      Word 52-53: usage of logical unit 2 output, by a specific program
116075   %      Word 54-55: usage of logical unit/datafield 3 input, by a specific program
116075   %      Word 56-57: usage of logical unit 3 output, by a specific program
116075   %      Word 60-61: usage of logical unit/datafield 4 input, by a specific program.
116075   %      Word 62-63: usage of logical unit 4 output, by a specific program.
116075   %      Word 64-65: usage of logical unit/datafield 5 input, by a specific program.
116075   %      Word 66-67: usage of logical unit 5 output, by a specific program.
116075   %      Word 70-71: usage of logical unit/datafield 6 input, by a specific program.
116075   %      Word 72-73: usage of logical unit 6 output, by a specific program.
116075   %      Word 74-75: usage of logical unit/datafield 7 input, by a specific program.
116075   %      Word 76-77: usage of logical unit 7 output, by a specific program.
116075   %      Word 100-101: usage of logical unit/datafield 8 input, by a specific program.
116075   %      Word 102-103: usage of logical unit 8 output, by a specific program.
116075   %
116075   %      Word 104-105: waiting queue length of logical unit/datafield 1 input.
116075   %      Word 106-107: waiting queue length of logical unit 1 output
116075   %      Word 110-111: waiting queue length of logical unit/datafield 2 input.
116075   %      Word 111-113: waiting queue length of logical unit 2 output.
116075   %      Word 114-115: waiting queue length of logical unit/datafield 3 input.
116075   %      Word 116-117: waiting queue length of logical unit 3 output.
116075   %      Word 120-121: waiting queue length of logical unit/datafield 4 input.
116075   %      Word 122-123: waiting queue length of logical unit 4 output.
116075   %      Word 124-125: waiting queue length of logical unit/datafield 5 input.
116075   %      Word 126-127: waiting queue length of logical unit 5 output.
116075   %      Word 130-131: waiting queue length of logical unit/datafield 6 input.
116075   %      Word 132-133: waiting queue length of logical unit 6 output
116075   %      Word 134-135: waiting queue length of logical unit/datafield 7 input.
116075   %      Word 136-137: waiting queue length of logical unit 7 output.
116075   %      Word 140-141: waiting queue length of logical unit/datafield 8 input.
116075   %      Word 142-143: waiting queue length of logical unit 8 output.
116075
116075   %      Word 144:   address of buffer where the utilisation of the specified
116075   %                  logical units, split over all rt-programs, is stored.
116075   %                  The first location in this buffer, contains the number of
116075   %                  rt-descriptions (number of elements in the buffer).
116075   %                  Each entry consist of the following 33 words.
116075   %                  Word  1:    address of rt-description.
116075   %                  Word  2- 3: usage of logical unit 1 input, by this program.
116075   %                  Word  4- 5: usage of logical unit 1 output, by this program
116075   %                  Word  6- 7: usage of logical unit 2 input, by this program.
116075   %                  Word 10-11: usage of logical unit 2 output, by this program.
116075   %                  Word 12-13: usage of logical unit 3 input, by this program.
116075   %                  Word 14-15: usage of logical unit 3 output, by this program.
116075   %                  Word 16-17: usage of logical unit 4 input, by this program.
116075   %                  Word 20-21: usage of logical unit 4 output, by this program.
116075   %                  Word 22-23: usage of logical unit 5 input, by this program.
116075   %                  Word 24-25: usage of logical unit 5 output, by this program.
116075   %                  Word 26-27: usage of logical unit 6 input, by this program.
116075   %                  Word 30-31: usage of logical unit 6 output, by this program.
116075   %                  Word 32-33: usage of logical unit 7 input, by this program.
116075   %                  Word 34-35: usage of logical unit 7 output, by this program.
116075   %                  Word 36-37: usage of logical unit 8 input, by this program.
116075   %                  Word 40-41: usage of logical unit 8 output, by this program.
116075   %
116075   %=============================================================================
116075   % Primitive no.  4: Use of ND-500 Swapper.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: nd-500 process number.
116075   %
116075   %   Option codes:
116075   %       100000: total utilisation of ND-500 Swapper.
116075   %       200:    utilisation of ND-500 Swapper split on all ND-500 processes.
116075   %       100:    utilisation of ND-500 Swapper by a specific ND-500 process.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4- 5: Total utilisation of ND-500 Swapper.
116075   %      Word  6- 7: Utilisation of ND-500 Swapper by a specific process.
116075   %      Word 10:    address of array where ND-500 Swapper usage, split over
116075   %                  all processes, is returned.
116075   %                  The first word in this array will contain the nuber of
116075   %                  elements in the array, (=number of processes in the system)
116075   %                  Each element consist of a double word for ND-500 Swapper
116075   %                  utilisation by the process. The process number is index
116075   %                  in the array.
116075   %
116075   %=============================================================================
116075   % Primitive no. 32: ND-100 Disk Access log.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: logical device number of 1st. disk drive to log.
116075   %      Word  5: disk unit number, drive number, of 1st. disk drive to log.
116075   %      Word  6- 7: lower disk addr of specific disk area, on 1st. disk drive to log.
116075   %      Word 10-11: upper disk addr of specific disk area, on 1st. disk drive to log.
116075   %      Word 12-17: same as word 4-11, but for 2nd. disk drive to log
116075   %      Word 20-25: same as word 4-11, but for 3rd. disk drive to log
116075   %      Word 26-33: same as word 4-11, but for 4th. disk drive to log
116075   %      Word 34:    option dependent.
116075   %                  RT-Description addr, or
116075   %                  ND-500 process number.
116075   %      Word 35:    option dependent.
116075   %                  ND-100 segment number, or
116075   %                  ND-500 segment number.
116075   %
116075   %   Option codes:
116075   %       100000: total disk accesses.
116075   %       140000: total disk accesses to a limited disk address area.
116075   %       10000:  disk accesses split on type. Type is ND-100 file, ND-100 swap,
116075   %               ND-500 file, ND-500 swap, ND-500 file-as-segment.
116075   %       1000:   disk accesses split on read and write.
116075   %       100:    ND-100 file accesses split on read/write for all or a
116075   %               specific rt-program. Rt-program=0 means all rt-programs
116075   %       101:    ND-100 swap accesses to a specific or to all segments,
116075   %               split on read/write for all or a specific rt-program.
116075   %               Segment number=0 means all segments.
116075   %               Rt-program=0 means all rt-programs
116075   %       102:    ND-500 file accesses split on read/write for all or a
116075   %               specific ND-500 process. ND-500 process=-1 means all processes.
116075   %       103:    ND-500 swap accesses to a specific segment or to all segments
116075   %               split on read/write for all or a specific ND-500 process.
116075   %               Segment number=0 means all segments.
116075   %               ND-500 process. ND-500 process=-1 means all processes.
116075   %       104:    ND-500 file-as-segment accesses to a specific segment or to any segment,
116075   %               split on read/write for all or a specific ND-500 process.
116075   %               Segment number=0 means any segment.
116075   %               ND-500 process=-1 means all processes.
116075   %       110:    ND-100 file accesses, split on read/write, split on all rt-programs.
116075   %       111:    ND-100 swap accesses, split on read/write, split on all rt-programs.
116075   %       112:    ND-500 file accesses, split on read/write, split on all ND-500 processes.
116075   %       113:    ND-500 swap accesses, split on read/write, split on all ND-500 processes.
116075   %       114:    ND-500 file-as-segment accesses, split on read/write,
116075   %               split on all ND-500 processes.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4- 5: total disk accesses on 1st. disk drive to log.
116075   %      Word  6- 7: total ND-100 file I/O accesses on 1st. disk drive to log.
116075   %      Word 10-11: total ND-100 swap accesses on 1st. disk drive to log.
116075   %      Word 12-13: total ND-500 file I/O accesses on 1st. disk drive to log.
116075   %      Word 14-15: total ND-500 swap accesses on 1st. disk drive to log.
116075   %      Word 16-17: total ND-500 file-as-segment swap accesses on 1st. disk drive to log.
116075   %      Word 20-21: total read accesses on 1st. disk drive to log.
116075   %      Word 22-23: total write accesses on 1st. disk drive to log.
116075   %      Word 24-25: total read accesses of specific type, on 1st. disk drive to log.
116075   %      Word 26-27: total write acesses of specific type, on 1st. disk drive to log.
116075   %      Word 30-53: same as words 4-27, but for 2nd disk drive to log.
116075   %      Word 54-77: same as words 4-27, but for 3rd disk drive to log.
116075   %      Word 100-123 same as words 4-27, but for 4th disk drive to log.
116075   %      Word 124: address of array for option dependent results.
116075   %            Option code=110: 1st word in array is number of elements in the array,
116075   %                             equals to the number of rt-descriptions in the system.
116075   %                             Each entry consist of the following 5 words.
116075   %                             word 0:   rt-description address.
116075   %                             word 1-2: number of ND-100 file read accesses by this program.
116075   %                             word 3-4: number of ND-100 file write accesses by this program.
116075   %            Option code=111: 1st word in array is number of elements in the array,
116075   %                             equals to the number of rt-descriptions in the system.
116075   %                             Each entry consist of the following 5 words.
116075   %                             word 0:   rt-description address.
116075   %                             word 1-2: number of ND-100 swap read accesses by this program.
116075   %                             word 3-4: number of ND-100 swap write accesses by this program.
116075   %            Option code=112: 1st word in array is number of elements in the array,
116075   %                             equals to the number of ND-500 processes in the system.
116075   %                             Each entry consist of 2 double words, 1st double
116075   %                             word is the number of ND-500 file read accesses by
116075   %                             this process, and the 2nd double word is the number
116075   %                             of ND-500 file write accesses by this process number.
116075   %                             The ND-500 process number is index in the array.
116075   %            Option code=113: 1st word in array is number of elements in the array,
116075   %                             equals to the number of ND-500 processes in the system.
116075   %                             Each entry consist of 2 double words, 1st double
116075   %                             word is the number of ND-500 swap read accesses by
116075   %                             this process, and the 2nd double word is the number
116075   %                             of ND-500 swap write accesses by this process number.
116075   %                             The ND-500 process number is index in the array.
116075   %            Option code=114: 1st word in array is number of elements in the array,
116075   %                             equals to the number of ND-500 processes in the system.
116075   %                             Each entry consist of 2 double words, 1st double
116075   %                             word is the number of ND-500 file-as-segment read accesses by
116075   %                             this process, and the 2nd double word is the number
116075   %                             of ND-500 file-as-segment write accesses by this process number.
116075   %                             The ND-500 process number is index in the array.
116075   %
116075   %============================================================================
116075   % Primitive no. 36: ND-100 monitor call log.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: rt-program. (Option code dependent).
116075   %      Word  5-14: 8 rt-programs to split all monitor calls on, or
116075   %                  8 monitor call numbers to log split on all rt-programs.
116075   %
116075   %   Option codes:
116075   %       100000: log all monitor calls.
116075   %       140000: log all monitor calls for a specific rt-program.
116075   %       10000:  log all monitor calls split on 8 specified rt-programs.
116075   %       14000:  log 8 specified monitor calls, split on all rt-programs.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4: addess of option code dependent buffer #1.
116075   %          This buffer consist of 400b double word elements. Each element is
116075   %          a monitor call counter. The monitor number is index in the buffer.
116075   %          (monitor call number range: 0-377b).
116075   %      Word  5: addess of option code dependent buffer #2.
116075   %          Option code=10000:
116075   %                The buffer consist of 400b elements.
116075   %                Each element consist of 30b words, an element can be divided
116075   %                into 8 subelements, 1 element for each of the 8 rt-programs
116075   %                to log monitor calls for. Each subelements consists of the
116075   %                following 3 words, 1 word specifying the rt-program, and a
116075   %                double word for the monitor call counter.
116075   %                The monitor call number is index in the buffer.
116075   %
116075   %          Option code=14000:
116075   %                The buffer consist of the following.
116075   %                The 1st. word contains the number of elements in the buffer,
116075   %                equal to the number of rt-descriptions in the system.
116075   %                Each element consist of 40b words, an element can be divided
116075   %                into 8 subelemnts, 1 element for each of the 8 monitor call
116075   %                to log. Each subelemnt consist of the following 4 words,
116075   %                word 1: rt-program, word 2: monitor call number,
116075   %                words 3-4: monitor call counter.
116075   %
116075   %============================================================================
116075   % Primitive no. 37: ND-500 monitor call log.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: ND-500 process number. (Option code dependent).
116075   %      Word  5-14: 8 ND-500 processes to split all monitor calls on, or
116075   %                  8 monitor call numbers to log split on all Nd-500 processes.
116075   %
116075   %   Option codes:
116075   %       100000: log all monitor calls.
116075   %       140000: log all monitor calls for a specific ND-500 process.
116075   %       10000:  log all monitor calls split on 8 specified ND-500 processes.
116075   %       14000:  log 8 specified monitor calls, split on all ND-500 processes.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4: address of option code dependent buffer #1.
116075   %                This buffer consist of 524b double word elements. Each element is
116075   %                a monitor call counter. The monitor call number is index in the buffer.
116075   %                (monitor call number range: 0-523b).
116075   %      Word  5: address of option code dependent buffer #2.
116075   %               Option code=10000:
116075   %                The buffer consist of 524b elements.
116075   %                Each element consist of 30b words, an element can be divided
116075   %                into 8 subelements, 1 element for each of the 8 ND-500 processes
116075   %                to log monitor calls for. Each subelements consists of the
116075   %                following 3 words, 1 word specifying the ND-500 process, and a
116075   %                double word for the monitor call counter.
116075   %                The monitor call number is index in the buffer.
116075   %
116075   %               Option code=14000:
116075   %                The buffer consist of the following.
116075   %                The 1st. word contains the number of elements in the buffer,
116075   %                equal to the number of ND-500 processes in the system.
116075   %                Each element consist of 30b words, an element can be divided
116075   %                into 8 subelemnts, 1 element for each of the 8 monitor call
116075   %                to log. Each subelemnt consist of the following 3 words,
116075   %                word 1: ND-500 process number, word 2-3: monitor call counter.
116075   %                The ND-500 process number is index in the buffer.
116075   %
116075   %============================================================================
116075   % Primitive no. 64: count pages-in-memory for ND-100 segment.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4-13: ND-100 segment numbers to count pages in memory for.
116075   %                  Max. 8 segments can be specified, segment number equals zero,
116075   %                  means no segmet.
116075   %
116075   %   Option codes: No options for this primitive.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4-33: 8 elements, each element consist of 3 words, 1st. word
116075   %                  is the segment number, word 2 and 3 is a double word for
116075   %                  accumulating the number of pages-in-memory for the actual
116075   %                  segment.
116075   %
116075   %============================================================================
116075   % Primitive no. 65: count pages-in-memory for ND-500 segment.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4-13: ND-500 segment numbers to count pages in memory for.
116075   %                  Max. 8 segments can be specified, segment number equals zero,
116075   %                  means no segmet.
116075   %
116075   %   Option codes: no option codes.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4-33: 8 elements, each element consist of 3 words, 1st. word
116075   %                  is the segment number, word 2 and 3 is a double word for
116075   %                  accumulating the number of pages-in-memory for the actual
116075   %                  segment.
116075   %
116075   %============================================================================
116075   % Primitive no. 66: ND-100 program counter histogram.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: interval size. (option dependent)
116075   %      Word  5: ND-100 interrupt level or ND-100 rt-program. (Option dependent).
116075   %               RT-program=0 means any rt-program.
116075   %      Word  6: ND-100 segment number. (Option dependent)
116075   %               Segment number=0 means any segment.
116075   %      Words 7-107: 1 word specifing the lower address in the address area
116075   %                   to loig, or 64 address intervals. (option dependent)
116075   %                   The address intervals must be specified in ascending order,
116075   %                   word 7 is start of 1st. interval, word 10 is start of 2nd.
116075   %                   interval......, and word 107 is end-of-64th-interval+1.
116075   %
116075   %   Option codes:
116075   %       100000: program histogram on a specific ND-100 interrupt level.
116075   %               64 intervals with fixed interval size.
116075   %       140000: program histogram on a specific ND-100 interrupt level,
116075   %               64 intervals with variable interval size.
116075   %       120000: program histogram on level 1, any or specific rt-program,
116075   %               any or specific segment.
116075   %               64 intervals with fixed interval size.
116075   %       110000: program histogram on level 1, any or specific rt-program,
116075   %               any or specific segment.
116075   %               64 intervals with variable interval size.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4-203: 64 double words, each represent the utilisation within each
116075   %                   address interval.
116075   %      Word 204-205: utilisation outside address area to log.
116075   %
116075   %============================================================================
116075   % Primitive no. 67: ND-500 program counter histogram.
116075   %   Function=1: initialize measurement.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of parameter block.
116075   %      Word  3: option code.
116075   %      Word  4: interval size. (option dependent)
116075   %      Word  5: ND-500 process number. (Option dependent).
116075   %               ND-500 process number=-1 means any process.
116075   %      Words 6-207: A double word specifing the lower addr in the address area
116075   %                   to log, or 64 32-bits address intervals. (option dependent)
116075   %                   The address intervals must be specified in ascending order,
116075   %                   words 6-7 is start of 1st. interval, words 10-11 is start of 2nd.
116075   %                   interval......, and words 206-207 is end-of-64th-interval+1.
116075   %
116075   %   Option codes:
116075   %       100000: program histogram for any or a specific ND-500 process.
116075   %               64 intervals with fixed interval size.
116075   %       140000: program histogram for any or a specific ND-500 process.
116075   %               64 intervals with variable interval size.
116075   %
116075   %   Function=2: read collected data.
116075   %      Word  1: primitive number.
116075   %      Word  2: length of data-block.
116075   %      Word  3: addr of next data-block.
116075   %      Word  4-203: 64 double words, each represent the utilisation within each
116075   %                   address interval.
116075   %      Word 204-205: utilisation outside address area to log.
116075   %
116075
116075   SUBR FFREAD,FTERMINATE
116075   RBUS
116075
116075   INTEGER ARRAY S13AR=?
116075   INTEGER ARRAY SMLAR=?
116075
116075   SUBR MOPERFORMANCE
116075
116075   INTEGER CLLPG,CFPAG,CNPAG,CENDP,C61IN
116102   INTEGER PM615:=("5",CNPAG,CFPAG,CLLPG,"0","0")
116110   INTEGER POINTER 61LREG
116111   TRIPLE TADREG; INTEGER XREGXX
116115
116115   % Local subroutine to allocate a contiguous memory area.
116115   % The memory area must reside inside one memory bank
116115   %
116115   % Entry:         A=size of area in words
116115   % Exit:          error, no area allocated
116115   % Exit+1:        A=first phys.page in memory area
116115   %                T=memory area identifier
116115   %
116115   GPHBUFF:
116115           D:=0; AD SHZ -12; IF D><0 THEN A+1 FI; A=:CNPAG       % Number of pages in buffer
116123           ENDPAGE=:CENDP                                        % Last phys.page is upper limit for buffer
116125           A:=L=:"61LREG"; A:=AMPIT=:D; CALL DALTON
116132           -1=:CLLPG
116134           DO
116134              CLLPG+1=:CFPAG+77=:CLLPG                           % Try within each memory bank
116141           WHILE CLLPG<<CENDP
116145              "PM615"; *MON 61
116147              GO ENDLOOP; GO BUFOK
116151   ENDLOOP:
116151           OD; CALL SINALTPIT
116153           ENPHBUF; GO 61LREG                                    % No buffer area found
116155
116155   % Buffer area found
116155   BUFOK:  CALL SINALTPIT
116156           % Clear the buffer area
116156           TAD=:TADREG; X=:XREGXX
116160           A=:D:=0; AD SH 12; T:=A; X:=D
116165           DO WHILE CNPAG><0
116167              A:=X+2000                                          % A=end of page (+1)
116171              DO WHILE X><A
116173                 *STZTX; AAX 1
116175              OD; CNPAG-1=:CNPAG
116201           OD; TAD:=TADREG; X:=XREGXX
116204           MIN "61LREG"; GO 61LREG
116206   *)FILL
116216
116216
116216   INTEGER PRIMINDEX=?                                           % Current primitive index
116216   INTEGER SHAINSTR(0); *SHA
116217   INTEGER PARBLENGTH=?                                          % Sum of parameter block length
116217   INTEGER INDXX=?
116217   INTEGER CINDEX=?
116217
116217   MOPERFORMANCE: CALL GETMP                                     % Call special get-routine
116220           MLEV; *MST PIE
116222           IF BACKGROUND><0 THEN
116224              "BFIELD".TTIFIELD.BSTATE=:M344BSTATE; 5BCOM=:X.BSTATE
116232              X.FLAGB=:M344FLAGB
116234              CALL ESCOFF
116235           FI
116235           IF MPRFUNCTION=0 OR A>>3 THEN EILLFUNC; GO FAR ERET FI
116244           A-1 GOSW FAR FINIT,FAR FFREAD,FAR FTERMINATE
116251
116251
116251   % Function=1: initilize measurement
116251   FINIT:  CALL DOTERMINATE; GO FAR ERET
116253           *1BANK
116254           0=:S13INDEX=:MLVINDEX
116256           *2BANK
116257           0=:NPRIACTIVE
116260           % Find the primitive numbers to activate
116260           0=:PRIMINDEX
116261           FOR PRIMINDEX TO MAXPRIMINDEX DO
116265              PRIMINDEX/\17+SHAINSTR=:T
116271              PRIMINDEX SHZ -4=:X
116274              MPRPRIMS(X); *EXR ST
116276              IF A<0 THEN                                        % Primitive activated?
116277                 IF X:=NPRIACTIVE>>=MXACTPRIMS THEN
116303                    EMXACTPRIMS; GO FAR ERET                     % Too many active primitives
116305                 FI
116305                 *1BANK
116306                 PRIMINDEX+1=:PRIMACTIVES(X)                     % Save primitive number to activate
116311                 X=:L:=A+X; AD:=SAMPADDRS(X)
116315                 IF A><0 THEN                                    % Clock level sampling routine addr
116316                    X:=S13INDEX+1; A=:S13AR(X)
116321                    X+1=:S13INDEX
116323                 FI
116323                 IF D><0 THEN                                    % Monitor level sampling routine addr
116325                    X:=MLVINDEX+1; A:=D=:SMLAR(X)
116331                    X+1=:MLVINDEX
116333                 FI
116333                 *2BANK
116334                 MIN NPRIACTIVE                                  % Count number of active primitives
116335              FI
116335           OD
116341           IF NPRIACTIVE=0 THEN ENACTPRIMS; GO FAR ERET FI       % No active primitves
116345
116345           % Find total length of parameter blocks
116345           X:=MPRPARBADDR; T:=NPRIACTIVE-1; CALL USALTPIT; 0=:PARBLENGTH
116352           0=:INDXX
116353           FOR INDXX TO T DO
116356              X.PBLENGTH; X+A; A+PARBLENGTH=:PARBLENGTH
116362           OD
116366           IF PARBLENGTH>>MXTPBLENGTH THEN
116372              CALL SINALTPIT; EPBLENGTH; GO FAR ERET             % Sum of par.blocks too large
116375           FI
116375
116375           % Move paramter blocks to PARBBUFF on MPIT
116375           PARBLENGTH=:L; A:=X-PARBLENGTH=:D; T:="PARBUFF"; *MOVAN
116404           CALL SINALTPIT
116405           GO OVFILL; *)FILL
116436
116436   INTEGER PRIMINDEX         % Current primitive index
116437   INTEGER PARBLENGTH        % Sum of parameter block length
116440   INTEGER INDXX
116441   INTEGER CINDEX
116442
116442   OVFILL:
116442   %        0=:BUFREQUIREMENTS
116442           0=:XBUFREQUIREMENTS                  % Clear data-buffer requirements
116443           *1BANK
116444           0=:XBUSARRAY(0)                                       % Clear array of phys buffer addrs
116446           0=:XRARRAY(X)                                         % Clear array of buffer initialisation routines
116447           *2BANK
116450           0=:INDXX
116451           FOR INDXX TO NPRIACTIVE-1 DO
116456              *1BANK
116457              PRIMACTIVES(INDXX)=:D
116462              X:="PARBUFF"
116463              *2BANK
116464              0=:CINDEX
116465              FOR CINDEX TO NPRIACTIVE-1 DO                      % Find correct parameter area in parameter block
116472                 *1BANK
116473                 IF X.PBIDENT=D THEN
116476                    *2BANK                                       % Parameter area found
116477                    CALL PRIMHANDLE; GO ERET
116501                    GO EFOR
116502   %                 *1BANK
116502   %                 X:=X.PBIDENT:=APRDESCR(X)                    % Mark that this primitive is active
116502   %                 X.PRBUFSIZE                                  % Data-block size of primitive
116502   %                 *2BANK
116502   %                 A+BUFREQUIREMENTS=:BUFREQUIREMENTS           % Sum of data-block sizes of all active primitives
116502                 ELSE
116503                    X.PBLENGTH; X+A                              % Check next paramter area
116505                 FI; *2BANK
116506              OD; EILPARS; GO ERET; *)FILL                       % All parblocks not found
116523   EFOR:      *2BANK
116524           OD; *2BANK
116531
116531           IF MPRSAMPLRATE=0 THEN EILSRATE; GO ERET FI
116535           A-=:MPERFREQUENCY=:M13FREQUENCE=:M2FREQUENCE          % Sampel rates in mil.secs.
116541   %        A:=BUFREQUIREMENTS; CALL FAR GPHBUFF; GO ERET         % Allocate phys-memory for all active primitive's data-blocks
116541   %        T=:MBUFINDEX; A=:BUFPAGE                              % Area ident and first phys page of data-blocks
116541           IF XBUFREQUIREMENTS><0 THEN                           % Any option dependent buffers?
116543              CALL FAR GPHBUFF; GO ERR1                          % Yes, allocate phys area for this buffers
116545              T=:MBUFXINDEX                                      % Buffer identifier
116546              A=:XBUFPAGE=:D:=0; AD SH 12
116552              AD=:DBUPHYSADDR                                    % Phys addr of start of buffer
116553              A=:XBUBANK                                         % Memory bank of buffer
116554              *1BANK
116555              X:="XBUSARRAY"
116556              DO WHILE X.S0><0                                   % Add start of buffer to all option-dependent-buffer addrs.
116560                 X=:L:=A; T:=X.S1                                % T=relative start of buffer within the whole buffer area
116563                 *2BANK
116564                 AD:=DBUPHYSADDR; D+T                            % Add buffer start addr
116566                 *1BANK
116567                 AD=:X.DS0                                       % Save in buffer pointer
116570                 X:=L+1
116571              OD
116572           FI
116572           0=:INDXX
116573           DO
116573              *1BANK
116574           WHILE XRARRAY(INDXX)><0                               % Any buffer initialisation routines?
116577              AD:=DXRARRAY(X)                                    % Yes
116600              *2BANK
116601              X:=A; D=:L; L:=:P; GO ERET                         % Call subroutine
116605              MIN INDXX; MIN INDXX
116607           OD
116610           *IOF; 2BANK
116612           1=:ACTMPERFORM                                        % Measuring starts now
116614           *ION
116615
116615   OKRET:  MIN ZPREG; 0/\0; 0=:ZAREG                             % Skip return when ok
116620           CALL RSBSTATE
116621           GO RET
116622
116622   ERR1:
116622   ERET:   A=:ZAREG
116623   ERR:    CALL DOTERMINATE; 0/\0
116625           CALL RSBSTATE
116626           GO MXRET
116627
116627   RBUS
116647
116647
116647   %============================================================================
116647   % Subroutine to handle a parameter block in the init function
116647   %
116647   % Entry:  X=address, on mpit, to the actual paramter block
116647   %         A=primitive number
116647   % Exit:   error detected in primhandle
116647   % Exit+1: ok
116647   %
116647   SUBR PRIMHANDLE
116647
116647   INTEGER PPRADD
116650
116650   % Local subroutine to activate a primitive by setting usoption
116650   % in the actual labels.
116650   %
116650   INTEGER CPRIDESCR=?,CPRADDR=?,SAVX=?
116650   SUSPRIMITIVE:
116650           CPRIDESCR.MXOPTION*"OPTDESCRSIZE"+"FOPTDESCR"; X+A
116655           DO WHILE X.S0><0                                      % A=addr of label
116657              X=:D
116660   %          IF A>>="PITST+4000" THEN                           % On mpit
116660   %             A-"PITST"+MPITADDR=:X; T:=MPITBANK
116660   %             A:=USOPTION; *STATX
116660   %          ELSE IF A>>="PITST" THEN                           % Ex-Common
116660   %             A-T=:PPRADD
116660   %             T:=0; X:="ECOFPAGE"; *LDTAX
116660   %             A=:X SH -6 =:T
116660   %             A:=X /\77 SH 12 + PPRADD=:X
116660   %             USOPTION; *STATX
116660   %          ELSE
116660                 A=:X:=USOPTION=:X.S0                            % Common
116663   %          FI;FI
116663              X:=D+1
116664           OD; EXIT
116666   *)FILL
116671
116671   % Local subroutine to activate/passivate an option
116671   % by storing usoption/nusoption in the actual labels.
116671   %
116671   SUSOPTION:
116671           X:=CPRADDR.OPTRADDR
116673   %       IF X>>="PITST+4000" THEN                                   % Mpit
116673   %          A:=:X-"PITST"+MPITADDR:=:X; T:=MPITBANK
116673   %          *STATX
116673   %       ELSE IF X>>="PITST" THEN                                  % Ex-Common
116673   %          A=:D
116673   %          X-T=:PPRADD
116673   %          T:=0; X:="ECOFPAGE"; *LDTAX
116673   %          A=:X SH -6 =:T
116673   %          A:=X /\77 SH 12 + PPRADD=:X
116673   %          A:=D; *STATX
116673   %       ELSE
116673              A=:X.S0                                            % Common
116674   %       FI
116674           EXIT
116675
116675   TRIPLE TADREG(0); INTEGER XX,CCPRIMNO,YY
116700   INTEGER POINTER LREG
116701
116701   OKOUT:  X:=SAVX; TAD:=TADREG; MIN "LREG"
116704           GO LREG
116705
116705   ERR:    *2BANK
116706           GO LREG
116707   *)FILL
116707
116707
116707   INTEGER CMXOPTION=?,CINDEX=?,CUROPTION=?,CFACT=?
116707
116707   PRIMHANDLE: TAD=:TADREG; X=:SAVX
116711           T:=L=:"LREG"
116713           IF A=0 OR A>>MAXPRIMINDEX THEN EILPNUMBER; GO ERR FI
116721           *1BANK
116722           A:=X.PBOPTION=:CUROPTION                              % Current option code
116724           X:=APRDESCR(CCPRIMNO)                                  % Addr of primitive's description table
116726           IF X=0 THEN EPRINIMPEL; GO ERR FI
116732           X=:CPRIDESCR                                          % Addr of primitive descriptor
116733           % Clear all option-dependent buffer sizes
116733           DO WHILE X.COPTBSIZE><-1; 0=:X.COPTBSIZE; X-SIZBOPTSIZE; OD
116742           0=:CINDEX
116743           CPRIDESCR.MXOPTION=:CMXOPTION                         % Max number of options for current primitive
116746           CPRIDESCR.PRBUFSIZE-PRDHEAD=:D                        % Size of primitives's data block
116752           X:=X.PRIDADDR+PRDHEAD; D+X                            % Addr of primitive's data block
116755           DO WHILE X><D; 0=:X.S0; X+1; OD                       % Clear primitive's data block
116762           GO LABEL; *)FILL
116764
116764   INTEGER CMXOPTION,CINDEX,CUROPTION,CPRADDR
116770   INTEGER CFACT,CPRIDESCR,SAVX
116773
116773   LABEL:
116773           DO WHILE CINDEX><CMXOPTION
116777              CINDEX*"OPTDESCRSIZE"+"FOPTDESCR"+CPRIDESCR=:CPRADDR=:X % Addr of first option descriptor
117005              IF X.COPTCODE/\CUROPTION=X.COPTCODE THEN
117012                 IF X.PAROPRADDR><0 THEN                         % Any option dependent paramter cheking routine?
117014                    *2BANK
117015                    X:=SAVX; A=:L; L:=:P; GO ERR                 % Call option dependent paramter routine.
117021                 FI; *1BANK
117022                 IF CPRADDR.INDXOPTBUF><0 THEN                   % Option-buffer required for this option?
117025                    A-1*SIZBOPTION; X:=CPRIDESCR-A               % X=addr of option-buffer descriptor
117031                    IF X.CURBU BIT BNRTP THEN                    % Buffer size dependent of number of rt-descriptors?
117034                       A/\377=:CFACT; *2BANK
117037                       A:=RTEND-RTSTART=:D:=0
117043                       T:=5RTSIZE; *RDIV ST
117045                       A+1*CFACT
117047                    ELSE IF A BIT BN5PROCS THEN                  % Buffer size dependent of number of nd-500 processes?
117052                       *2BANK
117053                       A/\377=:CFACT; A:=MX5PROCS+2*CFACT
117060                    ELSE IF A BIT BPR77 THEN
117063                       A/\ 77 =:CFACT; A SH 12
117066                    FI; FI; FI; *1BANK
117067                    A=:X.COPTBSIZE                               % Size of option-buffer
117070                    IF A><0 THEN
117071                       X:=X.COPTADRBUF                           % X=addr to store option-buffer addr into
117072                       *2BANK
117073                       T:=XBUFREQUIREMENTS                       % Total sum of option-buffers
117074                       A+XBUFREQUIREMENTS=:XBUFREQUIREMENTS      % Add sum of option-buffer
117076                       IF C THEN A:=EBUBIG; GO ERR FI            % 1 bank (64k word), is max
117102                       *1BANK
117103                       T=:X.S1; 0=:X.S0                          % T=addr of current option-buffer rel. to start of option-buffer
117105                       X=:T:=0
117107                       DO WHILE XBUSARRAY(X)><0; X+1; OD
117113                       T=:XBUSARRAY(X); X+1; 0=:XBUSARRAY(X)     % Insert element in option-buffer addr. table
117116                    FI
117116                 FI
117116                 *1BANK
117117                 IF CPRADDR.XRADDR><0 THEN                       % Any option dependent buffer initializing routine?
117122                    A=:D; X:=0
117124                    DO WHILE XRARRAY(X)><0; X+2; OD
117130                    A:=SAVX; AD=:DXRARRAY(X); X+2; 0=:XRARRAY(X)
117134                 FI
117134                 USOPTION                                        % Activate this option
117135              ELSE
117136                 NUSOPTION                                       % Do not use this option
117137              FI; *1BANK
117140              CALL FAR SUSOPTION                                 % Modifie code to use/not use option
117141              MIN CINDEX
117142           OD; *1BANK
117144           CALL FAR SUSPRIMITIVE                                 % Activate this primitive
117145           *2BANK
117146           GO FAR OKOUT
117147   RBUS
117167
117167   %============================================================================
117167   %       F T E R M I N A T E   D O T E R M I N A T E
117167   %
117167   SUBR FTERMINATE,DOTERMINATE
117167   INTEGER CINDEX,CFPAGE
117171   INTEGER PMO61:=("6",CINDEX,CFPAGE,"0","0","0")
117177
117177   FTERMINATE: CALL DOTERMINATE; 0/\0
117201           MIN ZPREG; 0/\0; 0=:ZAREG
117204           CALL RSBSTATE
117205           GO MXRET
117206
117206   INTEGER POINTER LREG
117207   DOTERMINATE:
117207           A:=L=:"LREG"
117211           0=:ACTMPERFORM
117212           IF MBUFXINDEX><-1 THEN
117216              A=:CINDEX; XBUFPAGE=:CFPAGE
117221              AMPIT=:D; CALL DALTON
117224              "PMO61"; *MON 61; JMP *+1                          % Release option-buffer area
117227              CALL SINALTPIT
117230              -1=:MBUFXINDEX
117232           FI
117232           CALL CLALPRIMITIVES; 0/\0
117234           MIN "LREG"; GO LREG
117236   RBUS
117253
117253
117253   %=========================================================================
117253   %       F F R E A D
117253   %
117253   % Entry:         none
117253   %
117253   SUBR FFREAD
117253
117253   INTEGER INDXX,CNWORDS,TOADDR,FROMADDR
117257   INTEGER COPTDESCR,CADDR,BLTOADDR
117262   INTEGER CCNWORDS,CCTOADDR
117264
117264   FFREAD: IF ACTMPERFORMANCE=0 THEN EMNSTARTED; GO ERR FI       % Measuring not active
117270           MPRPARBADDR=:TOADDR                                   % Addr in user's program where data should be returned
117272           0=:INDXX
117273           FOR INDXX TO NPRIACTIVE-1 DO
117300              *1BANK
117301              X:=PRIMACTIVES(INDXX):=APRDESCR(X)=:COPTDESCR      % X=addr of primitive descriptor element
117305              D:=0
117306              DO WHILE X.COPTBSIZE><-1; D+A; X-SIZBOPTSIZE; OD   % Calculate size of option-buffers
117315              *2BANK
117316              T:=NPRIACTIVE-1
117320              *1BANK
117321              IF INDXX><T THEN                                   % Last primitive?
117324                 COPTDESCR.PRBUFSIZE+D+TOADDR                    % A=addr of extr-buffer in user's program
117330                 X:=X.PRIDADDR; A=:X.PBNEXT                      % Pointer to data for next primitive
117332              FI
117332              COPTDESCR.PRBUFSIZE=:CNWORDS                       % Size of current data-block
117335              X:=X.PRIDADDR=:FROMADDR                            % Addr of data-block on mpit
117337              A=:X.PBLENGTH
117340              *2BANK
117341              CALL USALTPIT
117342              CNWORDS=:L; FROMADDR=:D; T:=TOADDR=:BLTOADDR
117350              *MOVNA                                             % Copy to user's buffer
117351              T=:TOADDR                                          % Next addr in user's buffer
117352              CALL SINALTPIT
117353              COPTDESCR=:CADDR
117355
117355              % Copy all option-buffers of a primitive to user's buffer
117355              DO
117355                  *1BANK
117356              WHILE CADDR.COPTBSIZE><-1
117363                  A=:CNWORDS=:CCNWORDS
117365                  X=:CADDR:=X.COPTADRBUF; AD:=X.DS0              % Ad=phys addr of buffer
117370                  T:=CADDR.XPARBDISP                             % Disp in par.block
117372                  X:=BLTOADDR+T; T:=TOADDR=:CCTOADDR             % Logical addr in user's parblock
117376                  *2BANK
117377                  CALL USALTPIT
117400                  T=:X.S0                                        % Pointer to optional buffer
117401                  IF T:=CNWORDS=0 THEN 0=:X.S0 FI                % Zero pointer when buffer not used
117405                  % Move optional-buffer to user's buffer
117405                  DO WHILE T:=CCNWORDS>>X:=2000
117411                     T-X=:CCNWORDS:=CCTOADDR; L:=X; *MOVPA
117416                     T=:CCTOADDR
117417                  OD
117420                  T=:L:=CCTOADDR; *MOVPA
117423                  T=:TOADDR
117424                  CALL SINALTPIT
117425                  CADDR-SIZBOPTSIZE=:CADDR
117430              OD; *2BANK
117432           OD
117436           0=:ZAREG; MIN ZPREG; 0/\0
117441           CALL RSBSTATE
117442           GO RET
117443   ERR:    A=:ZAREG
117444           CALL RSBSTATE
117445           GO RET
117446
117446   RBUS
117460
117460
117460   %=========================================================================
117460   % Subroutine to passivate all sampling routines
117460   %
117460   % Entry:         none
117460   % Exit:          error
117460   % Exit+1:        ok
117460   %
117460   SUBR CLALPRIMITIVES
117460
117460   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
117464   INTEGER INDXX,CSAVB,PPRADD
117467   INTEGER POINTER LREG
117470
117470   CLALPRIMITIVES: TAD=:TADREG; X=:XREG; A:=L=:"LREG"
117474           "5MPIT"*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *BPAGL@3 LDATX
117502           A=:D:=0; AD SH 10
117505           *1BANK
117506           AD=:DMPITADDR                                         % Phys addr of start of mpit segment
117507           0=:INDXX
117510           % Reset all previous used sampling routines
117510           FOR INDXX TO MXACTPRIMS-1 DO
117515              X:=INDXX+X+1; "XENDX"=:S13AR(X); "MLEND"=:SMLAR(X)
117523           OD
117527           *2BANK
117530           IF X:=MPHMESS><0 THEN
117532              CALL GCPUDF; CALL ERRFATAL; A:=:B=:CSAVB
117536              *IOF
117537   *NNT50=*
117537              CALL TER500; 0/\0                                  % Stop nd-500
117541              CALL SLOCK; 0/\0
117543              CALL IFM500XQ                                      % Remove histogram message from nd-500 xq
117544              CALL SUNLOCK
117545              CALL LOWACT
117546              *ION
117547   %          T:=5MBBANK; *LINK1@3 STZTX; LINK2@3 STZTX
117547              CSAVB=:B
117551           FI
117551           0=:INDXX; *1BANK
117553           FOR INDXX TO MAXPRIMINDEX+1 DO                        % Nusoption in all primitive's labels
117560              IF X:=APRDESCR(INDXX)><0 THEN
117563                 X.MXOPTION*"OPTDESCRSIZE"+"FOPTDESCR"; X+A
117567                 DO WHILE X.S0><0
117571                    X=:D
117572   %                IF A>>="PITST+4000" THEN                          % Mpit
117572   %                   A-"PITST"+MPITADDR=:X; T:=MPITBANK
117572   %                   A:=NUSOPTION; *STATX
117572   %                ELSE IF A>>="PITST" THEN                   % Ex-Common
117572   %                   A-T=:PPRADD
117572   %                   T:=0; X:="ECOFPAGE"; *LDATX
117572   %                   A=:X SH -6 =:T
117572   %                   A:=X /\ 77 SH 12 +PPRADD=:X
117572   %                   NUSOPTION; *STATX
117572   %                ELSE
117572                      A=:X:=NUSOPTION=:X.S0                      % Common
117575   %                FI;FI
117575                    X:=D+1
117576                 OD
117577              FI
117577           OD
117603           *2BANK
117604           TAD:=TADREG; X:=XREG
117606           MIN "LREG"; GO LREG
117610   RBUS
117634
117634
117634   %===================================================================
117634   % Subroutine to reset bstate and flagb for background programs
117634   % before returning from mon.call
117634   %
117634   SUBR RSBSTATE
117634   INTEGER LREG
117635   RSBSTATE:
117635           IF BACKGROUND><0 THEN
117637              A:=L=:LREG
117641              M344BSTATE=:"BFIELD".TTIFIELD.BSTATE
117645              IF M344FLAGB BIT 5ESCON THEN
117650                 X:=X.TDRADDR
117651                 *IOF
117652                 T:="FLAGB"; CALL XGTDFADDR
117654                 A BONE 5ESCON; T:="FLAGB"; CALL XSTDFADDR
117657                 *ION
117660              FI; LREG=:L
117662           FI; EXIT
117663   RBUS
117672
117672
117672   %===================================================================
117672   % Paramter checking routine for primitive #1, option code=100 and
117672   % option code=10.
117672   %
117672   % Entry:         X=addr of actual paramter block on mpit
117672   % Exit:          error
117672   % Exit+1:        ok
117672   %
117672   SUBR P01R1
117672   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER XREG
117676   INTEGER POINTER LREG
117677   P01R1:  TAD=:TADREG; X=:XREG; T:=L=:"LREG"
117703           *1BANK
117704           A:=X.S3; *2BANK                                       % Rt-descr addr
117706           CALL CHRTADDR; GO ERR; *1BANK
117711           A=:ACRTP                                              % Rt-program
117712           MIN "LREG"
117713   L1:     TAD:=TADREG; X:=XREG
117715           GO LREG
117716   ERR:    EILPARS=:AREG; GO L1
117721   RBUS
117723
117723   %=====================================================================
117723   % Paramter checking routine for primitive #2, option code=100.
117723   %
117723   % Entry:         X=addr of actual paramter block on mpit
117723   % Exit:          error
117723   % Exit+1:        ok
117723   %
117723   SUBR P02R2
117723   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
117726   INTEGER POINTER LREG
117727   P02R2:  TAD=:TADREG; A:=L=:"LREG"
117732           *1BANK
117733           A:=X.S3                                               % Nd-500 process number
117734           *2BANK
117735           CALL CH5PROC; GO ERR; *1BANK
117740           A=:Y5PRO                                              % Save in data-block. (nd-500 proc.number)
117741           MIN "LREG"
117742   OUT:    TAD:=TADREG
117743           GO LREG
117744   ERR:    A=:AREG; GO OUT                                        % Illegal nd-500 process number
117746   RBUS
117750
117750   %=====================================================================
117750   % Paramter checking routine for primitive #2, option code=200.
117750   %
117750   % Entry:         X=addr of actual paramter block on mpit
117750   % Exit:          error
117750   % Exit+1:        ok
117750   %
117750   SUBR P02R3
117750   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
117753   INTEGER POINTER LREG
117754   P02R3:  TAD=:TADREG; A:=L=:"LREG"
117757           *1BANK
117760           A:=X.S4
117761           *2BANK
117762           IF A>4 OR A<1 THEN EILPARS ; GO ERR FI
117772           CALL CHE5CPU; GO ERR; *1BANK                          % Specified CPU no. OK
117775           A=:LXCPU
117776           MIN "LREG"
117777   OUT:    TAD:=TADREG
120000           GO LREG
120001   ERR:    A=:AREG; GO OUT                                        % Illegal nd-500 process number
120003   RBUS
120005
120005   %=============================================================================
120005   % Common subroutine for all paramter checking routine for primitive #3
120005   %
120005   % Entry:         X=addr of paramter block on mpit
120005   % Exit:          error, A=error code
120005   % Exit+1:        ok, addr of log.unit's datfields are set up
120005   %
120005   SUBR P03RF
120005   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
120011   INTEGER POINTER LREG,XLREG
120013   INTEGER LUFOUND,CNDX
120015
120015   % Local subroutine to check for legal datafield addrs.
120015   %
120015   % Entry:         A=log.dev. no or datafield addr.
120015   % Exit:          error
120015   % Exit+1:        A=input datafield; d=output datafield
120015   %
120015   CSUBR: T:=L=:"XLREG"
120017           A=:D
120020           IF A><0 THEN
120021              IF XREG.PBOPTION BIT 16 THEN                        % Datafield address
120025                 *2BANK
120026                 IF D.RTRES><0 THEN                              % Check if addr can be a datafield
120031                    A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
120036                    IF D><0 THEN EILPARS; GO XLREG FI
120042                 ELSE
120043                    IF X.BWLINK><X THEN EILPARS; GO XLREG FI
120050                 FI; A:=X; D:=0
120052                 MIN LUFOUND
120053              ELSE
120054                 *2BANK
120055                 A:=D; CALL LOGPH
120057                 IF A=0 AND D=0 THEN EILPARS; GO XLREG FI
120064                 MIN LUFOUND
120065              FI
120065           FI; *1BANK
120066           MIN "XLREG"; GO XLREG
120070
120070   P03RF:  TAD=:TADREG; X=:XREG; T:=L=:"LREG"
120074           0=:LUFOUND=:CNDX
120076           *1BANK
120077           DO WHILE CNDX<20                                     % 8 log.units, 2 words for each
120103              XREG+CNDX=:X; X.S3; CALL CSUBR; GO ERR             % X.s3=log.unit or datafield
120111              T:="ADD1I"; X:=CNDX+T; AD=:X.DS0                  % Save input and output data field for sampling routines
120115              IF A>>="9FDFD" AND A<<"9EDFD" THEN                 % Disk
120123                 XREG+CNDX=:X
120126                 IF X.S4>>3 THEN EILPARS; GO ERR FI              % Drive number
120134                 A=:X:=CNDX SHZ -1+"ADDU1":=:X; A=:X.S0         % Save disk drive number for sampling routines
120142              FI
120142              CNDX+2=:CNDX
120145           OD
120146           IF LUFOUND=0 THEN EILPARS; GO ERR FI                  % No log.units specified
120152           MIN "LREG"
120153   L1:     TAD:=TADREG; X:=XREG
120155           *2BANK
120156           GO LREG
120157   ERR:    A=:AREG; GO L1
120161
120161   RBUS
120167
120167
120167   %=====================================================================
120167   % Paramter checking routine for primitive #3, option code=100.
120167   %
120167   % Entry:         X=addr of actual paramter block on mpit
120167   % Exit:          error
120167   % Exit+1:        ok
120167   %
120167   SUBR P03R1
120167   DISP 23; INTEGER S23; PSID
120167   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
120173   INTEGER POINTER LREG
120174   P03R1:  TAD=:TADREG; A:=L=:"LREG"; X=:XREG
120200           CALL P03RF; GO ERR                                    % Check log.units
120202           *1BANK
120203           X.S23                                                 % Rt-program
120204           *2BANK
120205           CALL CHRTADDR; GO ERR1
120207           *1BANK
120210           A=:XLRTP                                              % Rt-program
120211           *2BANK
120212           MIN "LREG"
120213   L1:     TAD:=TADREG; X:=XREG
120215           GO LREG
120216   ERR1:   EILPARS
120217   ERR:    A=:AREG; GO L1                                         % Illegal nd-500 process number
120221   RBUS
120224
120224
120224   %=====================================================================
120224   % Paramter checking routine for primitive #4, option code=100.
120224   %
120224   % Entry:         X=addr of actual paramter block on mpit
120224   % Exit:          error
120224   % Exit+1:        ok
120224   %
120224   SUBR P04R2
120224   TRIPLE TADREG
120227   P04R2:  TAD=:TADREG
120230           IF MX5PROC=0 GO ERR                                   % Error if no nd-500 procs
120232           *1BANK
120233           T:=X.S3; *2BANK                                       % Nd-500 process number
120235           IF A<<T OR T=0 GO ERR                                 % Nd-500 proc.no. within legal range?
120241           A:=T-5SWPROC*5PRDSIZE+"S500S"=:X                      % Proc.descr.
120246           IF X.MESSBUFF=0 GO ERR                                % Mailbox defined?
120250           *1BANK
120251           A=:XSWOWNER                                           % Mailbox addr.
120252           *2BANK
120253           TAD:=TADREG
120254           EXITA
120255   ERR:    EILPARS; EXIT                                         % Illegal nd-500 process number
120257   RBUS
120264
120264
120264   %=====================================================================
120264   % Paramter checking routine for primitive #32, all option codes
120264   %
120264   % Entry:         X=addr of actual paramter block on mpit
120264   % Exit:          error
120264   % Exit+1:        ok
120264   %
120264   SUBR P32RF
120264   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
120270   INTEGER POINTER LREG
120271   INTEGER INDXX,FOUND
120273   P32RF:  TAD=:TADREG; A:=L=:"LREG"; X=:XREG
120277           0=:FOUND=:INDXX
120301           *1BANK
120302           X:="DLUN1"; A:=-1=:D:=0
120306           DO WHILE X<<="DLUN4"; AD=:X.DS0; X+2 OD               % Clear log.units and drive numbers
120314           DO WHILE INDXX<4                                      % Max 4 disk drives to log
120320              INDXX*6+3+XREG=:X                                   % X=addr of element in parblock
120325              IF X.S0><0 THEN                                    % A=log unit
120327                 *2BANK
120330                 CALL LOGPH; *1BANK
120332                 IF A=0 OR A<<"9FDFD" OR A>>="9EDFD" GO ERR      % Not disk
120341                 A=:D                                            % D=datafield addr
120342                 IF X.S1>>3 GO ERR                               % Illegal drive number
120346                 T:=INDXX SH 1; X:="DLUN1"+T
120352                 A:=:D; AD=:X.DS0                                % Store datafield addr and drive number
120354                 X=:L:="DLUN1"
120356                 DO WHILE X<<L
120360                    IF T:=X.S0=A AND T:=X.S1=D GO ERR            % Same paramter twice
120366                    X+2
120367                 OD
120370                 MIN FOUND
120371              FI; MIN INDXX
120372           OD
120373           IF FOUND=0 GO ERR                                     % No paramters
120375           MIN "LREG"
120376   L1:     TAD:=TADREG; X:=XREG
120400           *2BANK
120401           GO LREG
120402   ERR:    EILPARS=:AREG; GO L1
120405   RBUS
120413
120413
120413   %=====================================================================
120413   % Paramter checking routine for primitive #32,
120413   % option code=100000 or option code=140000.
120413   %
120413   % Entry:         X=addr of actual paramter block on mpit
120413   % Exit:          error
120413   % Exit+1:        ok
120413   %
120413   SUBR P32R1
120413   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
120417   INTEGER POINTER LREG
120420   INTEGER INDXX
120421   P32R1:  TAD=:TADREG; A:=L=:"LREG"; X=:XREG
120425           CALL P32RF; GO ERR
120427           *1BANK
120430           IF X.PBOPTION/\140000=140000 THEN                     % Log limited disk area(s)
120435              0=:INDXX
120436              DO WHILE INDXX<4                                   % Max 4 disk drives to log
120442                 INDXX SH 1+"DLUN1"
120445                 IF A.S0><0 THEN                                 % Disk drive defined?
120450                    INDXX*6+3+XREG=:X                             % X=addr of lower disk limit in parblock
120455                    AD:=X.DS1; A=:T; D=:L; AD:=X.DS2
120461                    IF A<<T OR A=T AND D<<L THEN
120467                       EILPARS; GO ERR                           % Error, lower addr>>upper addr
120471                    FI; INDXX*4+"XFDA1"=:L                       % L=addr of lower limit in data block
120475                    AD:=X.DS1; X:=:L; AD=:X.DS0                  % Move disk addr. limits
120500                    X:=:L
120501                    AD:=X.DS2; X:=:L; AD=:X.DS1
120504                 FI; MIN INDXX
120505              OD; A:=USOPTION
120507           ELSE
120510              A:=NUSOPTION
120511           FI; A=:"TDALX".S0                                     % Use/not use logging of limited disk area
120513           MIN "LREG"
120514   L1:     TAD:=TADREG; X:=XREG
120516           *2BANK
120517           GO LREG
120520   ERR:    A=:AREG; GO L1
120522   RBUS
120532
120532
120532   %=====================================================================
120532   % Paramter checking routine for primitive #32, option codes 100-117
120532   %
120532   % Entry:         X=addr of actual paramter block on mpit
120532   % Exit:          error
120532   % Exit+1:        ok
120532   %
120532   SUBR P32R4
120532
120532   DISP 33; INTEGER S33,S34; PSID
120532
120532   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
120536   INTEGER POINTER LREG
120537   INTEGER COPTION
120540   INTEGER CXPAR=?,CYPAR=?
120540
120540   OUT:    MIN "LREG"
120541   L1:     TAD:=TADREG; X:=XREG
120543           *2BANK
120544           GO LREG
120545
120545   ERR:    A=:AREG; GO L1
120547   ERRP:   EILPARS=:AREG; GO L1
120552
120552   % Local subroutine to compute the physical address of the variable "breg"
120552   % in the "rwsegm" routine. (on mpit).
120552   CRWSEGM:
120552           A:="MPIT"*200+174000=:X
120556           A:="RWSEGM"+53; AD SHZ -12; A SH 1; X+A; T:=0; *LDATX 10
120565           T:=D SHZ -6; A=:D:=0; AD SH 12; D+T
120573           *1BANK
120574           AD=:DDBASEG                                           % Phys addr of breg in rwsegm routine
120575           *2BANK
120576           EXIT
120577   *)FILL
120603
120603   P32R4:  TAD=:TADREG; A:=L=:"LREG"; X=:XREG
120607           CALL P32RF; GO ERR
120611           *1BANK
120612           X.S33=:CXPAR                                          % Rt-program/nd-500 process.
120614           X.S34=:CYPAR                                          % Nd-100 segment/nd-500 segment number.
120616           X.PBOPTION/\117=:COPTION
120621           0=:"OPD32".CURBU                                      %
120623           *2BANK
120624           COPTION-100
120626   @ICR;
120626           A GOSW L1FIL,L1SWP,L5FIL,L5SWP,LFSEG,ERRP,ERRP,ERRP,
120637                  LA1FI,LA1SW,LA5FI,LA5SW,LAFSG,ERRP,ERRP,ERRP;
120647   @CR;
120647   *)FILL
120652
120652   INTEGER CXPAR,CYPAR
120654
120654   L1FIL:  A:=CXPAR                                              % Nd-100 file accesses by specific rt-program
120655           IF A><0 THEN CALL CHRTADDR; GO ERR FI                 % Check rt-descr addr
120660           T:=X1FIL
120661           GO OK
120662
120662   L5FIL:  A:=CXPAR                                              % Nd-500 file accesses by specific nd-500 process
120663           IF A><-1 THEN
120666              CALL CH5PROC; GO ERR
120670              A-5SWPROC*"5PRDSIZE"+"S500S"
120673           ELSE
120674              A:=0
120675           FI
120675           T:=X5FIL
120676   OK:     *1BANK
120677           T=:XDLFL                                              % Routine switch for logging routine
120700           A=:XDLXD                                              % Rt-program/nd-500 process
120701           GO FAR OUT
120702
120702   L1SWP:  A:=CXPAR                                              % Nd-100 swap access by specific segment
120703           IF A><0 THEN CALL CHRTADDR; GO ERR FI                 % Check rt-descr addr
120706           *1BANK
120707           A=:XDLXD                                              % Rt-program
120710           *2BANK
120711           IF CYPAR><0 THEN                                      % Segment number
120713              IF A<<2 OR A>>SGMAX GO ERR
120721              CALL CRWSEGM
120722              A:=CXPAR*5SEGSIZE+SEGSTART                         % Addr of segment table element
120725           FI; T:=X1SWP
120726           *1BANK
120727           A=:XDLYD
120730           T=:XDLFL
120731           GO FAR OUT
120732
120732   L5SWP:  A:=XSW50                                              % Nd-500 swap acces by specific segment
120733   5FELLS: *1BANK
120734           A=:XDLFL                                              % Routine switch
120735           *2BANK
120736           CALL CH5OK; GO ERR                                    % Nd-500 swap acces by specific segment
120740           IF CXPAR><-1 THEN                                     % Nd-500 process number
120744              CALL CH5PROC; GO ERR
120746              A-5SWPROC*"5PRDSIZE"+"S500S"
120751              A.MESSBUFFR                                        % Nd-500 mailbox addr
120753           ELSE
120754              A:=0
120755           FI; *1BANK
120756           A=:XDLXD                                              % Nd-500 mailbox addr
120757           *2BANK
120760           IF CYPAR><0 THEN
120762              IF A>>"N500D".NPHSEG GO FAR ERRP
120766           FI
120766           *1BANK
120767           A=:XDLYD
120770           GO FAR OUT
120771
120771   LFSEG:  A:=XFISG                                              % Nd-500 file-as-segment accesses by specific segment
120772           GO 5FELLS
120773
120773   LA1FI:  A:=Y1FIL                                              % Nd-100 file access split on all rt-programs
120774   1FELL:  *1BANK
120775           A=:XDLFL
120776           *2BANK
120777           A:=RTEND-RTSTART=:D:=0                                % Nd-100 file access split on all rt-programs
121003           T:=5RTSIZE; *RDIV ST
121005           A+1*5
121007           *1BANK
121010           A=:"OPD32".CURBU
121012           GO FAR OUT
121013
121013   LA5FI:  A:=Y5FIL                                              % Nd-500 file access split on all nd-500 processes
121014   55FEL:  *1BANK
121015           A=:XDLFL
121016           *2BANK
121017           CALL CH5OK; GO FAR ERR                                % Nd-500 file access split on all nd-500 processes
121021           MX5PROC+1*4+1
121025           *1BANK
121026           A=:"OPD32".CURBU
121030           GO FAR OUT
121031
121031   LA1SW:  A:=Y1SWP                                              % Nd-100 swap access split on all rt-programs
121032           GO 1FELL
121033
121033   LA5SW:  A:=Y5SWP                                              % Nd-500 swap accesses split on all nd-500 procesdses
121034           GO 55FEL
121035
121035   LAFSG:  A:=YFISG                                              % Nd-500 file-as-segment accesses split on all nd-500 processes
121036           GO 55FEL
121037
121037   RBUS
121064
121064
121064   %=====================================================================
121064   % Paramter checking routine for primitive #36, option code=100000
121064   %
121064   % Entry:         X=addr of actual paramter block on mpit
121064   % Exit:          error
121064   % Exit+1:        ok
121064   %
121064   SUBR P36R1
121064
121064   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
121070   INTEGER POINTER LREG
121071
121071   P36R1:  TAD=:TADREG; T:=L=:"LREG"
121074           *1BANK
121075           IF X.PBOPTION/\140000=140000 THEN                     % Mon.call log for specific program
121102              X.S3; *2BANK                                       % Rt-program
121104              CALL CHRTADDR; GO ERR
121106              *1BANK
121107              X.S3
121110           ELSE
121111              A:=0
121112           FI
121112           *1BANK
121113           A=:MLXRT                                              % Rt-program
121114           MIN "LREG"
121115   OUT:    *2BANK
121116           TAD:=TADREG; X:=XREG
121120           GO LREG
121121   ERR:    A:=EILPARS=:AREG; GO OUT
121124   RBUS
121127
121127
121127   %=====================================================================
121127   % Paramter checking routine for primitive #36, option code=10000.
121127   %
121127   % Entry:         X=addr of actual paramter block on mpit
121127   % Exit:          error
121127   % Exit+1:        ok
121127   %
121127   SUBR P36R2
121127
121127   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
121127
121127   INTEGER XINDX,CAVAL,CXVAL
121132
121132   % Local subroutine to check if same program/mon.call is defined
121132   % more than one time in the paramter block.
121132   %
121132   CSUBR:  0=:XINDX; A=:CAVAL; X=:CXVAL
121135           DO WHILE XINDX<10
121141              "X1MLP"+XINDX
121143              IF A.S0=CAVAL THEN EXIT FI                         % Error element already exists
121151              MIN XINDX
121152           OD; A:=CAVAL; X:=CXVAL
121155           EXITA
121156
121156   MBERR:  IF A=0 THEN EXIT FI
121160           GO ERR
121161
121161   INTEGER CNDX,TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
121166   INTEGER POINTER LREG
121167
121167   P36R2:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
121173           *1BANK
121174           A:=-1=:D; AD=:"X1MLP".DD0=:X.DD1=:X.DD2=:X.DD3        % Reset buffer
121203           IF XREG.PBOPTION/\14000=14000 THEN                     % Log 8 mon.calls for all progs
121211              0=:CNDX
121212              DO WHILE CNDX<10
121216                 XREG+CNDX; A.S4                                 % Mon.call number
121222                 IF A><-1 THEN
121225                    IF A>> 377 GO ERR
121230                    CALL CSUBR; CALL MBERR
121232                 FI
121232                 T:=A; "X1MLP"+CNDX; T=:A.S0                    % Save mon.call number for sampling routines
121237                 WHILE T+1><0
121242                 MIN CNDX
121243              OD; *2BANK
121245              A:=RTEND-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
121253              A*40+1; X:=1                                       % Size of optional data buffer
121256           ELSE
121257              0=:CNDX                                           % Log all mon.calls for 8 progs
121260              DO WHILE CNDX<10
121264                 XREG+CNDX
121266                 IF A.S4=0 THEN A:=-1 FI                        % A=rt-program
121272                 IF A><-1 THEN
121275                    *2BANK
121276                    CALL CHRTADDR; GO ERR
121300                    *1BANK
121301                    X.S4; CALL CSUBR; GO ERR
121304                 FI; T:=A; "X1MLP"+CNDX; T=:A.S0                % Save rt-program for sampling routines
121311                 WHILE T+1><0
121314                 MIN CNDX
121315              OD; A:=400*30; X:=0                              % Size of optional data buffer
121321           FI; *1BANK
121322           X=:MLOFL; A=:"OPD36".CURBU                            % Size of opt. data buffer into opt. data buffer descr.
121325           MIN "LREG"
121326   OUT:    *2BANK
121327           TAD:=TADREG; X:=XREG
121331           GO LREG
121332
121332   ERR:    EILPARS=:AREG; GO OUT
121335   RBUS
121350
121350
121350   %=====================================================================
121350   % Paramter checking routine for primitive #37, option code=100000
121350   %
121350   % Entry:         X=addr of actual paramter block on mpit
121350   % Exit:          error
121350   % Exit+1:        ok
121350   %
121350   SUBR P37R1
121350
121350   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
121354   INTEGER POINTER LREG
121355
121355   P37R1:  TAD=:TADREG; T:=L=:"LREG"
121360           CALL CH5OK; GO ERR
121362           *1BANK
121363           IF X.PBOPTION/\140000=140000 THEN                     % Mon.call log for specific nd-500 process
121370              X.S3; *2BANK                                       % Nd-500 process
121372              IF A>>MX5PROC GO ERR
121375           ELSE
121376              A:=-1
121377           FI
121377           *1BANK
121400           A=:MLXPR                                              % Nd-500 process number
121401           MIN "LREG"
121402   OUT:    *2BANK
121403           TAD:=TADREG; X:=XREG
121405           GO LREG
121406   ERR:    A:=EILPARS=:AREG; GO OUT
121411   RBUS
121415
121415
121415   %=====================================================================
121415   % Paramter checking routine for primitive #37, option code=10000.
121415   %
121415   % Entry:         X=addr of actual paramter block on mpit
121415   % Exit:          error
121415   % Exit+1:        ok
121415   %
121415   SUBR P37R2
121415
121415   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
121415
121415   INTEGER CNDX,XINDX,CAVAL,CXVAL
121421
121421   % Local subroutine to check if same process number/mon.call number
121421   % is used more than one time in the paramter block.
121421   %
121421   CSUBR:  0=:XINDX; A=:CAVAL; X=:CXVAL
121424           DO WHILE XINDX<10
121430              "Y1MLP"+XINDX
121432              IF A.S0=CAVAL THEN EXIT FI                         % Error element already exists
121440              MIN XINDX
121441           OD; A:=CAVAL; X:=CXVAL
121444           EXITA
121445
121445   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
121451   INTEGER POINTER LREG
121452
121452   MBERR:  IF A=0 THEN EXIT FI
121454           GO ERR
121455
121455   P37R2:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
121461           CALL CH5OK; GO ERR
121463           *1BANK
121464           A:=-1=:D; AD=:"Y1MLP".DD0=:X.DD1=:X.DD2=:X.DD3
121473           IF XREG.PBOPTION/\14000=14000 THEN
121501              0=:CNDX
121502              DO WHILE CNDX<10
121506                 XREG+CNDX; A.S4                                 % A.s4=mon.call number
121512                 IF A><-1 THEN
121515                    IF A>> 523 GO ERR                               % Within legal range?
121520                    CALL CSUBR; CALL MBERR
121522                 FI
121522                 T:=A; "Y1MLP"+CNDX; T=:A.S0                    % Save mon.call number for sampling routines
121527                 WHILE T+1><0
121532                 MIN CNDX
121533              OD; *2BANK
121535              A:=MX5PROC+1*30+1; X:=1                              % Size of optional data buffer
121542           ELSE
121543              0=:CNDX
121544              DO WHILE CNDX<10
121550                 XREG+CNDX; A.S4                                 % A.s4=nd-500 proc.number
121554                 IF A><-1 THEN
121557                    *2BANK                                        % Check for legal RT-description
121560                    CALL CH5PROC; GO ERR
121562                    *1BANK                                        % and for redundancy
121563                    CALL CSUBR; GO ERR
121565                 FI
121565                 T:=A; "Y1MLP"+CNDX; T=:A.S0                     % Save nd-500 process number for sampling routines
121572                 WHILE T+1><0                                    % End of buffer?
121575                 MIN CNDX
121576              OD; A:=524*30; X:=0                              % Size of optional data buffer
121602           FI; *1BANK
121603           X=:ML5FL                                              % Routine switch for sampling routines
121604           A=:"OPD37".CURBU                                      % Size of opt. data buffer into opt. data buffer descr.
121606           MIN "LREG"
121607   OUT:    *2BANK
121610           TAD:=TADREG; X:=XREG
121612           GO LREG
121613
121613   ERR:    EILPARS=:AREG; GO OUT
121616   RBUS
121630
121630
121630   %=====================================================================
121630   % Paramter checking routine for primitive #64 & primitive #65
121630   %
121630   % Entry:         X=addr of actual paramter block on mpit
121630   % Exit:          error
121630   % Exit+1:        ok
121630   %
121630   SUBR P64R1,P65R1
121630
121630   INTEGER XINDX=?,CSGNU=?,CVAL=?,CNDX=?,YINDX=?
121630   INTEGER CSGNU=?,CSGAD=?,ROUTSWITCH=?,BREG=?
121630   INTEGER 15SEGTAB=?,25SEGTAB=?; DOUBLE D5SEGTAB=?
121630
121630   INTEGER CLGPAGE,CLGADDR; DOUBLE DCLGADDR=CLGPAGE
121632   INTEGER POINTER L2REG
121633   F5SGTABLE: A:=L=:"L2REG"
121635           T:=55NSG; CALL M1MEXY
121637           AX5DP=:D; CALL DALTON
121642           X:="ABASSW"; X.DS0; CALL ALTOFF; CALL M1MEXY          % Get logical addr of swappers segment table
121646           A/\3777; AD SHZ 5                                     % A=log page number of swappers segment table
121650           D SHZ -6                                              % D=displacement within page
121651           AD=:DCLGADDR
121652           A:=B=:BREG
121654           "S5CPUDF"=:B
121656           IF MIFLAG BIT MUDOM THEN                              % 16 OR 32
121661              T:=3                                               % BITS PST ?
121662           ELSE
121663              T:=1
121664           FI
121664           BREG=:B
121666           A:="N500DF".5PSTPAGE+X.ADRZERO                        % Phys page of nd-500 pst
121671           A=:D:=0; AD SH 12
121674           D:=D+T; A:=A+C; *EXAM                                 % Page of index-page for phys.seg #1
121677           A:=T/\37777+X.ADRZERO=:D:=0
121704           AD SH 12; A:=:D+CLGPAGE:=:D; A:=A+C; *EXAM            % T=phys page of start of swappers seg.table
121712           A:=T+X.ADRZERO
121714           A=:D:=0; AD SH 12; A:=:D+CLGADDR; A:=:D; A:=A+C
121723           GO L2REG
121724   *)FILL
121734
121734   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
121737   INTEGER BREG
121740   INTEGER POINTER LREG
121741   INTEGER XREG=?
121741   OKRET:  MIN "LREG"
121742   OUT:    X:=XREG; TAD:=TADREG
121744           *2BANK
121745           GO LREG
121746   ERR:    EILPARS=:AREG
121750           GO OUT
121751
121751
121751   P64R1:  TAD=:TADREG
121752           "F1SGS"=:CSGAD; "DA1SG"=:CSGNU
121756           0=:ROUTSWITCH
121757           T:=L=:"LREG"; X=:XREG
121762           GO FAR FELLS
121763
121763
121763   % Local subroutine to check if same segment number is specified
121763   % More than once in the parameter block.
121763   %
121763   % Entry:         A=segment number.
121763   % Exit:          error, element already used
121763   % Eita:          ok.
121763   %
121763   CSUBR:  A=:CVAL; 0=:XINDX
121765           DO WHILE XINDX><CNDX
121771              XINDX*3+CSGNU=:X
121775              IF X.S0=CVAL THEN EXIT FI
122002              MIN XINDX
122003           OD; A:=CVAL
122005           EXITA
122006   *)FILL
122012
122012   P65R1:  TAD=:TADREG; A:=L=:"LREG"
122015           CALL CH5OK; GO ERR
122017           X=:XREG
122020           IF "N500DF".SYSINITFLAG NBIT BSWLOAD GO ERR           % Swapper not loaded
122024           "F5SGS"=:CSGAD; "DA5SG"=:CSGNU
122030           1=:ROUTSWITCH
122032           CALL FAR F5SGTABLE
122033           AD=:D5SEGTAB                                          % Phys addr of nd-500 swapper's seg.table
122034           GO FELLS
122035   *)FILL
122042
122042   INTEGER XREG
122043
122043   % Clear unused entries in paramter-table for the sampling routines
122043   CLREST: *1BANK
122044           DO WHILE YINDX><CNDX
122050              IF ROUTSWITCH=0 THEN
122052                 YINDX+CSGAD
122054              ELSE
122055                 A:=YINDX SH 1+CSGAD
122060              FI; X:=A; -1=:X.S0
122063              MIN YINDX
122064           OD; EXIT
122066
122066   INTEGER XINDX,CNDX,CVAL,YINDX
122072   INTEGER CSGNU,CSGAD,ROUTSWITCH
122075   INTEGER 15SEGTAB,25SEGTAB; DOUBLE D5SEGTAB=15SEGTAB
122077
122077   FELLS:  0=:CNDX=:YINDX
122101           DO WHILE CNDX<<10
122105              *1BANK
122106              XREG+CNDX
122110              IF A.S3><0 THEN                                    % Segment number
122113                 CALL FAR CSUBR; GO FAR ERR
122115                 A=:X:=YINDX*3+CSGNU; A:=:X; A=:X.S0
122123                 *2BANK
122124                 IF T:=ROUTSWITCH=0 THEN                         % Nd-100 segment
122127                    IF A>>SGMAX GO FAR ERR
122132                    A*5SEGSIZE+SEGSTART
122134                    *1BANK
122135                    A=:X:=YINDX+CSGAD; A:=:X; A=:X.S0            % Save addr. of segment table entry
122142                 ELSE
122143                    IF A>>"N500DF".NPHSEG GO FAR ERR
122147                    T:=5SSEG; *RMPY ST DA                      % Nd-500 segment
122151                    A:=:D+25SEGTAB; A:=:D; A:=A+C+15SEGTAB
122156                    *1BANK
122157                    T:=YINDX SH 1; X:=CSGAD+T; AD=:X.DS0         % Save phys.addr of swappers segment table
122164                 FI; MIN YINDX
122165              FI; MIN CNDX
122166           OD; CALL FAR CLREST                                   % Mark unused log.devs
122170           GO FAR OKRET
122171   RBUS
122203
122203
122203   %=====================================================================
122203   % Paramter checking routine for primitive #66, all option codes.
122203   %
122203   % Entry:         X=addr of actual paramter block on mpit
122203   % Exit:          error
122203   % Exit+1:        ok
122203   %
122203   SUBR P66R1
122203
122203   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
122207   INTEGER COPTION
122210   INTEGER POINTER LREG
122211
122211   P66R1:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
122215           *1BANK
122216           X.PBOPTION=:COPTION
122220           IF A/\170000=100000 OR A=140000 THEN
122227              IF X.S4>>17 GO ERR                                 % Illegal interrupt level
122233              A=:PCLEV
122234              IF COPTION=100000 THEN
122240                 X.S3=:1PCIN                                     % Interval size
122242                 X.S6=:1FPRG                                     % First address in target area
122244                 A:=0                                            % Routine switch
122245              ELSE
122246                 A:=X+6=:D; T:="1FPRG"; A:=101=:L; *MOVNN        % Move interval specs
122255                 A:=1                                            % Routine switch
122256              FI
122256           ELSE IF A=120000 OR A=110000 THEN
122265              1=:PCLEV                                           % Log level 1
122267              IF X.S4><0 THEN                                    % Rt-program
122271                 *2BANK
122272                 CALL CHRTADDR; GO ERR
122274                 *1BANK
122275              FI; A=:PCRTP                                       % Rt-program to log
122276              IF X.S5><0 THEN                                    % Segment number
122300                 *2BANK
122301                 IF A>>SGMAX GO ERR
122304                 A=:D*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SGSTA@3 LDATX
122312                 IF A BIT 5NCLSEG THEN
122314                    *LOGAD@3 LDATX
122315                    A SHZ -6 BONE 17                             % Test for pit.
122317                 ELSE
122320                    A:=D
122321                 FI; *1BANK
122322              FI; A=:PC1SG                                       % Segment number or pit. number
122323              IF COPTION=120000 THEN
122327                 XREG.S3=:1PCIN                                   % Interval size
122332                 X.S6=:1FPRG                                     % First address in target area
122334                 A:=2                                            % Routine switch
122335              ELSE
122336                 A:=XREG+6=:D; T:="1FPRG"; A:=101=:L; *MOVNN      % Move interval specs
122345                 A:=3                                            % Routine switch
122346              FI
122346           ELSE GO ERR
122350           FI; FI
122350           A=:1PCFL                                              % Routine switch for sampling routines
122351           MIN "LREG"
122352   OUT:    TAD:=TADREG; X:=XREG
122354           *2BANK
122355           GO LREG
122356   ERR:    EILPARS=:AREG
122360           GO OUT
122361   RBUS
122401
122401
122401   %=====================================================================
122401   % Paramter checking routine for primitive #67, all option codes.
122401   %
122401   % Entry:         X=addr of actual paramter block on mpit
122401   % Exit:          error
122401   % Exit+1:        ok
122401   %
122401   SUBR P67R1
122401
122401   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
122405   INTEGER POINTER LREG
122406
122406   P67R1:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
122412           *1BANK
122413           X.S4                                                  % Nd-500 process number
122414           *2BANK
122415           IF A><-1 THEN
122420              A=:T; CALL CH5PROC; GO ERR
122423              A-5SWPROC*5PRDSIZE+"S500S"
122426           ELSE
122427              CALL CH5OK; GO ERR
122431              A:=0=:T
122433           FI; *1BANK
122434           T=:PC5PR                                              % Nd-500 process number
122435           A=:5MHPR                                              % Process description address
122436           IF X.PBOPTION/\140000=100000 THEN
122443              X.S3=:5PCIN                                        % Address interval size
122445              X+5; X.DS0=:D5FHPR                                 % First address in area to log
122450              A:=0                                               % Routine switch
122451           ELSE IF A=140000 THEN
122455              A:=X+5=:D; T:="5FHPR"; A:=202=:L; *MOVNN
122464              A:=1                                               % Routine switch
122465           ELSE GO ERR
122467           FI; FI
122467           A=:5PCFL
122470           *2BANK
122471           X:=MPHMESS; T:=5MBBANK; *1BANK
122474           PC5PR; *AAX WANTP; STATX
122477           *AAX 5CPUN-WANTP; LDATX; 2BANK
122502           CALL CHE5CPU; GO ERR                            % Alive and OK ?
122504           A=:D; *1BANK
122506           X:=5MHPR; *2BANK                                % Logged process in same CPU as hist proc.
122510           IF X><0 THEN
122511              X:=X.MESSBUFF; D=:A; *AAX 5CPUN; STATX       % Specific process
122515              *AAX 5MSFL-5CPUN; LDATX
122517              A BONE 5CPUBOUND; *STATX
122521           FI
122521           MIN "LREG"
122522   OUT:    TAD:=TADREG; X:=XREG
122524           *2BANK
122525           GO LREG
122526   ERR:    EILPARS=:AREG
122530           GO OUT
122531   RBUS
122551
122551   %=====================================================================
122551   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=100-116
122551   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=200-216
122551   %
122551   % ENTRY:         X=ADDR OF ACTUAL PARAMTER BLOCK ON MPIT
122551   % EXIT:          ERROR
122551   % EXIT+1:        OK
122551   %
122551   SUBR P77R1,P77R2
122551
122551   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
122551
122551
122551
122551   LA5P1:  0=:PROFLAG; GO OUT1                          % Log all 500 proc
122553
122553   L85P1:  A:=1; CALL CHTR5P; GO ERR                % Log 8 500 procs
122556           GO OUT1
122557
122557   L8RT1:  A:=2; CALL CHTRRT; GO ERR               % Log 8 RT-programs
122562           GO OUT1
122563
122563   INTEGER TREG=?,AREG=?,DREG=?; TRIPLE TADREG=?
122563   INTEGER POINTER LREG=?
122563   INTEGER XREG=?
122563   INTEGER COPTION=?
122563
122563   ERR:    A=:AREG; GO OUT
122565   ERRP1:  EILPARS=:AREG; GO OUT
122570   OUT1:   MIN "LREG"
122571   OUT:    *2BANK
122572           TAD:=TADREG; X:=XREG
122574           GO LREG
122575
122575   P77R1:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
122601           CALL CH5OK; GO ERR
122603           *1BANK
122604           A:=-1=:D; A=:TRINIT; 100=:DECOPT
122611           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
122616           IF XREG.PBOPTION/\60=0 THEN
122622              1=:DEPFFLAG; FI                                    % PF TRAP
122624           IF X.PBOPTION/\60=40 THEN
122631              1=:DEMCFLAG; FI                                    % MCALL - 377
122633           IF X.PBOPTION/\60=20 THEN
122640              1=:DETRFLAG; FI                                    % TRAP-PF
122642           X.PBOPTION/\117=:COPTION                              % OPTION CODE = 100-116
122645           IF X.PBOPTION/\14=0 THEN
122650              0=:DECOSIZE                                          % mess buff 0-37
122651           ELSE IF A=4 THEN
122655              1=:DECOSIZE                                          % mess buff 0-37 100-146
122657           ELSE IF A=10 THEN
122663              2=:DECOSIZE                                          % mess buff 0-146
122665           ELSE
122666              3=:DECOSIZE                                          % mess buff -30-146
122670           FI; FI; FI; *1BANK
122671           COPTION-100
122673
122673   @ICR;
122673           A GOSW LA5P1,L85P1,L8RT1,ERRP1,LA5P1,
122701                  L85P1,L8RT1,ERRP1,LA5P1,L85P1,
122706                  L8RT1,ERRP1,LA5P1,L85P1,L8RT1,
122713                  ERRP1;
122714   @CR;
122714   *)FILL
122732   INTEGER XREG
122733   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
122736   INTEGER POINTER LREG
122737   INTEGER COPTION
122740
122740
122740   P77R2:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
122744           CALL CH5OK; GO FAR ERR
122746           *1BANK
122747           A:=-1=:D; A=:TRINIT; 200=:N5COPT
122754           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
122761           XREG.PBOPTION/\217=:COPTION                           % OPTION CODE = 200-216
122765           IF X.PBOPTION/\14=0 THEN
122770              0=:N5SIZE                                          % mess buff 0-37
122771           ELSE IF A=4 THEN
122775              1=:N5SIZE                                          % mess buff 0-37 100-146
122777           ELSE IF A=10 THEN
123003              2=:N5SIZE                                          % mess buff 0-146
123005           ELSE
123006              3=:N5SIZE                                          % mess buff -30-146
123010           FI; FI; FI; *1BANK
123011           COPTION-200
123013   @ICR;
123013           A GOSW FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123020                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123024                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123030                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1;
123034   @CR;
123034   *)FILL
123051
123051
123051   RBUS
123051
123051   %=====================================================================
123051   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=400-416
123051   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=1000-1016
123051   %
123051   % ENTRY:         X=ADDR OF ACTUAL PARAMTER BLOCK ON MPIT
123051   % EXIT:          ERROR
123051   % EXIT+1:        OK
123051   %
123051   SUBR P77R3, P77R4
123051
123051   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
123051
123051   LA5P1:  0=:PROFLAG; GO OUT1                          % Log all 500 proc
123053
123053   L85P1:  A:=1; CALL CHTR5P; GO ERR                    % Log 8 500 procs
123056           GO OUT1;
123057
123057   L8RT1:  A:=2; CALL CHTRRT; GO ERR                    % Log 8 RT-programs
123062           GO OUT1;
123063
123063   INTEGER TREG=?,AREG=?,DREG=?; TRIPLE TADREG=?
123063   INTEGER POINTER LREG=?
123063   INTEGER XREG=?
123063   INTEGER COPTION=?
123063
123063   ERR:    A=:AREG; GO OUT
123065   ERRP1:  EILPARS=:AREG; GO OUT
123070   OUT1:   MIN "LREG"
123071   OUT:    *2BANK
123072           TAD:=TADREG; X:=XREG
123074           GO LREG
123075
123075   P77R3:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123101           CALL CH5OK; GO ERR
123103           *1BANK
123104           A:=-1=:D; A=:TRINIT; 400=:ACTSCOPT
123111           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123116           XREG.PBOPTION/\417=:COPTION                           % OPTION CODE = 400-416
123122           IF X.PBOPTION/\14=0 THEN
123125              0=:ACTSSIZE                                        % mess buff 0-37
123126           ELSE IF A=4 THEN
123132              1=:ACTSSIZE                                        % mess buff 0-37 100-146
123134           ELSE IF A=10 THEN
123140              2=:ACTSSIZE                                        % mess buff 0-146
123142           ELSE
123143              3=:ACTSSIZE                                        % mess buff -30-146
123145           FI; FI; FI; *1BANK
123146           COPTION-400
123150   @ICR;
123150           A GOSW FAR LA5P1,FAR L85P1,L8RT1,ERRP1,FAR LA5P1,
123156                  FAR L85P1,FAR L8RT1,ERRP1,
123161                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1,
123165                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1;
123171   @CR;
123171   *)FILL
123207   INTEGER XREG
123210   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
123213   INTEGER POINTER LREG
123214   INTEGER COPTION
123215
123215   P77R4:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123221           CALL CH5OK; GO ERR
123223           *1BANK
123224           A:=-1=:D; A=:TRINIT; 1000=:T5XQCOPT
123231           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123236           XREG.PBOPTION/\1017=:COPTION                           % OPTION CODE = 1000-1016
123242           IF X.PBOPTION/\14=0 THEN
123245              0=:T5XQSIZE                                        % mess buff 0-37
123246           ELSE IF A=4 THEN
123252              1=:T5XQSIZE                                        % mess buff 0-37 100-146
123254           ELSE IF A=10 THEN
123260              2=:T5XQSIZE                                        % mess buff 0-146
123262           ELSE
123263              3=:T5XQSIZE                                        % mess buff -30-146
123265           FI; FI; FI; *1BANK
123266           COPTION-1000
123270   @ICR;
123270           A GOSW FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123275                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123301                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123305                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1;
123311   @CR;
123311
123311   RBUS
123325
123325   %=====================================================================
123325   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=2000-2016
123325   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=4000-4016
123325   %
123325   % ENTRY:         X=ADDR OF ACTUAL PARAMTER BLOCK ON MPIT
123325   % EXIT:          ERROR
123325   % EXIT+1:        OK
123325   %
123325   SUBR P77R5, P77R6
123325
123325   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
123325
123325
123325   LA5P1:  0=:PROFLAG; GO OUT1                          % Log all 500 proc
123327
123327   L85P1:  A:=1; CALL CHTR5P; GO ERR                    % Log 8 500 procs
123332           GO OUT1
123333
123333   L8RT1:  A:=2; CALL CHTRRT; GO ERR                    % Log 8 RT-programs
123336           GO OUT1
123337
123337   INTEGER TREG=?,AREG=?,DREG=?; TRIPLE TADREG=?
123337   INTEGER POINTER LREG=?
123337   INTEGER XREG=?
123337   INTEGER COPTION=?
123337
123337   ERR:    A=:AREG; GO OUT
123341   ERRP1:  EILPARS=:AREG; GO OUT
123344   OUT1:   MIN "LREG"
123345   OUT:    *2BANK
123346           TAD:=TADREG; X:=XREG
123350           GO LREG
123351
123351   P77R5:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123355           CALL CH5OK; GO ERR
123357           *1BANK
123360           A:=-1=:D; A=:TRINIT; 2000=:F5XQCOPT
123365           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123372           XREG.PBOPTION/\2017=:COPTION                           % OPTION CODE = 2000-2016
123376           IF X.PBOPTION/\14=0 THEN
123401              0=:F5XQSIZE                                        % mess buff 0-37
123402           ELSE IF A=4 THEN
123406              1=:F5XQSIZE                                        % mess buff 0-37 100-146
123410           ELSE IF A=10 THEN
123414              2=:F5XQSIZE                                        % mess buff 0-146
123416           ELSE
123417              3=:F5XQSIZE                                        % mess buff -30-146
123421           FI; FI; FI; *1BANK
123422           COPTION-2000
123424   @ICR;
123424           A GOSW FAR LA5P1,FAR L85P1,L8RT1,ERRP1,FAR LA5P1,
123432                  FAR L85P1,FAR L8RT1,ERRP1,
123435                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1,
123441                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1;
123445   @CR;
123445   *)FILL
123463   INTEGER XREG
123464   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
123467   INTEGER POINTER LREG
123470   INTEGER COPTION
123471
123471
123471   P77R6:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123475           CALL CH5OK; GO ERR
123477           *1BANK
123500           A:=-1=:D; A=:TRINIT; 4000=:TER5COPT
123505           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123512           XREG.PBOPTION/\4017=:COPTION                           % OPTION CODE = 4000-4016
123516           IF X.PBOPTION/\14=0 THEN
123521              0=:TER5SIZE                                        % mess buff 0-37
123522           ELSE IF A=4 THEN
123526              1=:TER5SIZE                                        % mess buff 0-37 100-146
123530           ELSE IF A=10 THEN
123534              2=:TER5SIZE                                        % mess buff 0-146
123536           ELSE
123537              3=:TER5SIZE                                        % mess buff -30-146
123541           FI; FI; FI; *1BANK
123542           COPTION-4000
123544   @ICR;
123544           A GOSW FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123551                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123555                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
123561                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1;
123565   @CR;
123565
123565   RBUS
123601
123601
123601   %=====================================================================
123601   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=10000-10016
123601   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=20000-20016
123601   %
123601   % ENTRY:         X=ADDR OF ACTUAL PARAMTER BLOCK ON MPIT
123601   % EXIT:          ERROR
123601   % EXIT+1:        OK
123601   %
123601   SUBR P77R7,P7710
123601
123601   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
123601
123601   LA5P1:  0=:PROFLAG; GO OUT1                          % Log all 500 proc
123603
123603   L85P1:  A:=1; CALL CHTR5P; GO ERR                    % Log 8 500 procs
123606           GO OUT1
123607
123607   L8RT1:  A:=2; CALL CHTRRT; GO ERR                    % Log 8 RT-programs
123612           GO OUT1
123613
123613   INTEGER TREG=?,AREG=?,DREG=?; TRIPLE TADREG=?
123613   INTEGER POINTER LREG=?
123613   INTEGER XREG=?
123613   INTEGER COPTION=?
123613
123613   ERR:    A=:AREG; GO OUT
123615   ERRP1:  EILPARS=:AREG; GO OUT
123620   OUT1:   MIN "LREG"
123621   OUT:    *2BANK
123622           TAD:=TADREG; X:=XREG
123624           GO LREG
123625
123625   P77R7:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123631           CALL CH5OK; GO ERR
123633           *1BANK
123634           A:=-1=:D; A=:TRINIT; 10000=:ACT5COPT
123641           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123646           XREG.PBOPTION/\10017=:COPTION                        % OPTION CODE = 10000-10016
123652           IF X.PBOPTION/\14=0 THEN
123655              0=:ACTSIZE                                        % mess buff 0-37
123656           ELSE IF A=4 THEN
123662              1=:ACTSIZE                                        % mess buff 0-37 100-146
123664           ELSE IF A=10 THEN
123670              2=:ACTSIZE                                        % mess buff 0-146
123672           ELSE
123673              3=:ACTSIZE                                        % mess buff -30-146
123675           FI; FI; FI; *1BANK
123676           COPTION-10000
123700   @ICR;
123700           A GOSW FAR LA5P1,FAR L85P1,L8RT1,ERRP1,FAR LA5P1,
123706                  FAR L85P1,FAR L8RT1,ERRP1,
123711                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1,
123715                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1;
123721   @CR;
123721   *)FILL
123737   INTEGER XREG
123740   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
123743   INTEGER POINTER LREG
123744   INTEGER COPTION
123745
123745   P7710:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
123751           CALL CH5OK; GO ERR
123753           *1BANK
123754           A:=-1=:D; A=:TRINIT; 20000=:MCCOCOPT
123761           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
123766           XREG.PBOPTION/\107=:COPTION                           % OPTION CODE = 20000-20016
123772           IF X.PBOPTION/\14=0 THEN
123775              0=:MCCOSIZE                                        % mess buff 0-37
123776           ELSE IF A=4 THEN
124002              1=:MCCOSIZE                                        % mess buff 0-37 100-146
124004           ELSE IF A=10 THEN
124010              2=:MCCOSIZE                                        % mess buff 0-146
124012           ELSE
124013              3=:MCCOSIZE                                        % mess buff -30-146
124015           FI; FI; FI; *1BANK
124016           COPTION-20000
124020   @ICR;
124020           A GOSW FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
124025                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
124031                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1,
124035                  FAR LA5P1,FAR L85P1,FAR L8RT1,FAR ERRP1;
124041   @CR;
124041
124041   RBUS
124055
124055   %=====================================================================
124055   % PARAMTER CHECKING ROUTINE FOR PRIMITIVE #77, OPTION CODE=40000-40017
124055   %
124055   % ENTRY:         X=ADDR OF ACTUAL PARAMTER BLOCK ON MPIT
124055   % EXIT:          ERROR
124055   % EXIT+1:        OK
124055   %
124055   SUBR P7720
124055
124055   DISP 0; DOUBLE DD0,DD1,DD2,DD3; PSID
124055
124055   LA5P1:  0=:PROFLAG; GO OUT1                          % Log all 500 proc
124057
124057   L85P1:  A:=1; CALL CHTR5P; GO ERR                    % Log 8 500 procs
124062           GO OUT1
124063
124063   L8RT1:  A:=2; CALL CHTRRT; GO ERR                    % Log 8 RT-programs
124066           GO OUT1
124067
124067   INTEGER XREG
124070   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
124073   INTEGER POINTER LREG
124074   INTEGER COPTION
124075
124075   ERR:    A=:AREG; GO OUT
124077   ERRP1:  EILPARS=:AREG; GO OUT
124102   OUT1:   MIN "LREG"
124103   OUT:    *2BANK
124104           TAD:=TADREG; X:=XREG
124106           GO LREG
124107
124107   P7720:  TAD=:TADREG; T:=L=:"LREG"; X=:XREG
124113           CALL CH5OK; GO ERR
124115           *1BANK
124116           A:=-1=:D; A=:TRINIT; 40000=:SWPDCOPT
124123           AD=:"Y1TRP".DD0=:X.DD1=:X.DD2=:X.DD3
124130           XREG.PBOPTION/\40017=:COPTION                         % OPTION CODE = 40000-40016
124134           IF X.PBOPTION/\14=0 THEN
124137              0=:SWPDSIZE                                        % mess buff 0-37
124140           ELSE IF A=4 THEN
124144              1=:SWPDSIZE                                        % mess buff 0-37 100-146
124146           ELSE IF A=10 THEN
124152              2=:SWPDSIZE                                        % mess buff 0-146
124154           ELSE
124155              3=:SWPDSIZE                                        % mess buff -30-146
124157           FI; FI; FI; *1BANK
124160           COPTION-40000
124162   @ICR;
124162           A GOSW FAR LA5P1,FAR L85P1,L8RT1,ERRP1,FAR LA5P1,
124170                  FAR L85P1,FAR L8RT1,ERRP1,
124173                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1,
124177                  FAR LA5P1,FAR L85P1,FAR L8RT1,ERRP1;
124203   @CR;
124203
124203   RBUS
124221   % ==========================================================
124221   % GENERAL ROUTINE TO CHECK FOR LEGAL PARAMETERS
124221   % A=PROFLAG; X=PARBLOCKADDR
124221   %
124221   SUBR CHTRRT,CHTR5P
124221
124221   % LOCAL SUBROUTINE TO CHECK IF SAME PROCESS NUMBER/RT-DESCRIPTION
124221   % IS USED MORE THAN ONE TIME IN THE PARAMETER BLOCK.
124221   %
124221   INTEGER XINDX,CAVAL,CXVAL
124224   CSUBR:  0=:XINDX; A=:CAVAL; X=:CXVAL
124227           DO WHILE XINDX<10
124233              "Y1TRP"+XINDX
124235              WHILE A.S0 >< -1                                % END OF BUFFER
124242              IF A=CAVAL THEN EXIT FI                         % ERROR ELEMENT ALREADY EXISTS
124246              MIN XINDX
124247           OD; A:=CAVAL; X:=CXVAL
124252           EXITA
124253
124253   INTEGER CNDX,XREG,AREG
124256   INTEGER POINTER LREG
124257
124257   CHTRRT: K:="1"; GO FLLS
124261   CHTR5P: K:="0"
124262   FLLS:   T:=L=:LREG; X=:XREG
124265           A=:PROFLAG
124266           0=:CNDX                                      % TRACE LOG FOR 8 SPEC PROCESSES
124267           DO WHILE CNDX < 10
124273              XREG+CNDX; A.S3                           % A.S3=PROC NO
124277                 IF A >< -1 THEN                        % A=-1 END OF BUFFER
124302                   *2BANK
124303                   IF K THEN
124305                      CALL CHRTADDR; GO ERR
124307                   ELSE
124310                      CALL CH5PROC; GO ERR                 % CHECK FOR LEGAL 500 PROCESS
124312                   FI
124312                   *1BANK
124313                   CALL CSUBR; GO ERR
124315                 FI
124315              T:=A; "Y1TRP"+CNDX; T=:A.S0
124322              WHILE T+1 >< 0
124325              MIN CNDX
124326           OD
124327           MIN "LREG"
124330   OUT:    *2BANK
124331           X:=XREG; GO LREG
124333   ERR:    A=:AREG; GO OUT
124335
124335   RBUS
124341
124341   %=============================================================================
124341   % Buffer initialisation routine for primitive #1, option code=300
124341   %
124341   % Entry:         none
124341   % Exit:          error
124341   % Exit+1:        ok
124341   %
124341   SUBR P01X1
124341   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER XREG
124345   P01X1:  TAD=:TADREG; X=:XREG
124347           A:=RTEND-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
124355           *1BANK
124356           A=:T; AD:=DBAR1CPU; A:=:T; X:=D
124362           *STATX                                                % Number of rt-descrs into buffer
124363           *2BANK
124364           A:=RTEND=:D:=RTSTART
124367           DO WHILE A<<D
124371              *STATX 10                                          % Store rt-descr addr
124372              X+3; A+5RTSIZE                                     % 3 locations for each entry
124374           OD; TAD:=TADREG; X:=XREG
124377           EXITA
124400   RBUS
124403
124403
124403   %=============================================================================
124403   % Buffer initialisation routine for primitive #2, option code=300
124403   %
124403   % Entry:         none
124403   % Exit:          error
124403   % Exit+1:        ok
124403   %
124403   SUBR P02X1
124403   TRIPLE TADREG; INTEGER XREG
124407   P02X1:  TAD=:TADREG; X=:XREG
124411           T:=MX5PROCS+1
124413           *1BANK
124414           AD:=DBAR5CPU; A:=:T; X:=D
124417           *STATX                                                % Number of nd-500 procs in the system into buffer
124420           *2BANK
124421           TAD:=TADREG; X:=XREG
124423           EXITA
124424   RBUS
124426
124426
124426   %=============================================================================
124426   % Buffer initialisation routine for primitive #3, option code=300
124426   %
124426   % Entry:         none
124426   % Exit:          error
124426   % Exit+1:        ok
124426   %
124426   SUBR P03X1
124426   TRIPLE TADREG; INTEGER XREG
124432   P03X1:  TAD=:TADREG; X=:XREG
124434           A:=RTEND-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
124442           *1BANK
124443           A=:T; AD:=DBLUADDR; A:=:T; X:=D
124447           *STATX                                                % Number of rt-descrs into buffer
124450           *2BANK
124451           A:=RTEND=:D:=RTSTART
124454           DO WHILE A<<D
124456              *STATX 10                                          % Store rt-descr addr
124457              X+41; A+5RTSIZE                                    % 41 locations for each entry
124461           OD; TAD:=TADREG; X:=XREG
124464           EXITA
124465   RBUS
124470
124470
124470   %=============================================================================
124470   % Buffer initialisation routine for primitive #4, option code=300
124470   %
124470   % Entry:         none
124470   % Exit:          error
124470   % Exit+1:        ok
124470   %
124470   SUBR P04X1
124470   TRIPLE TADREG; INTEGER XREG
124474   P04X1:  TAD=:TADREG; X=:XREG
124476           T:=MX5PROCS+1
124500           *1BANK
124501           AD:=DB5SWAPP; A:=:T; X:=D
124504           *STATX                                                % Number of nd-500 procs in the system into buffer
124505           *2BANK
124506           TAD:=TADREG; X:=XREG
124510           EXITA
124511   RBUS
124513
124513
124513   %=============================================================================
124513   % Buffer initialisation routine for primitive #32, option codes 100-117
124513   %
124513   % Entry:         none
124513   % Exit:          error
124513   % Exit+1:        ok
124513   %
124513   SUBR P32X1
124513   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER XREG
124517   P32X1:  TAD=:TADREG; X=:XREG
124521           *1BANK
124522           A:=XDLFL                                              % Routine switch
124523           *2BANK
124524           A GOSW ERR,OUT,OUT,OUT,OUT,OUT,LA1FI,LA1SW,LA5FI,LA5SW,LAFSG
124540
124540   LA1SW:
124540   LA1FI:  A:=RTEND-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
124546           *1BANK
124547           A=:T; AD:=DBDLBU; A:=:T; X:=D; *STATX                 % Number of rt-descrs into buffer
124554           *2BANK
124555           A:=RTEND=:D:=RTSTART
124560           DO WHILE A<<D
124562              *STATX 10                                          % Store rt-descr addr
124563              X+5; A+5RTSIZE                                     % 5 locations for each entry
124565           OD; GO OUT
124567
124567   LAFSG:
124567   LA5SW:
124567   LA5FI:  T:=MX5PROCS+1
124571           *1BANK
124572           AD:=DBDLBU; T:=:A; X:=D; *STATX
124576           GO OUT
124577
124577   OUT:    TAD:=TADREG; X:=XREG
124601           EXITA
124602
124602   ERR:    EILPARS=:AREG; TAD=:TADREG; X:=XREG
124606           EXIT
124607   RBUS
124614
124614
124614   %=============================================================================
124614   % Buffer initialisation routine for primitive #36, option code=10000.
124614   %
124614   % Entry:         none
124614   % Exit:          error
124614   % Exit+1:        ok
124614   %
124614   SUBR P36X2
124614   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
124620   INTEGER XINDX,CNDX,YINDX
124623   INTEGER CSTA,CEND; DOUBLE DCADDR
124627   P36X2:  TAD=:TADREG; X=:XREG
124631           *1BANK
124632           A:=MLOFL                                              % Routine switch
124633           *2BANK
124634           IF A=0 THEN                                           % Log mon.calls for max 8 progs
124635              *1BANK
124636              0=:CNDX
124637              DO WHILE CNDX<<400
124643                 CNDX*30=:X; AD:=D1BXML; D+X; AD=:DCADDR        % Phys addr of buffer element
124651                 0=:XINDX; 0=:YINDX
124653                 DO WHILE XINDX<<10
124657                    "X1MLP"+XINDX
124661                    IF A.S0><-1 THEN
124666                       T:=A; YINDX*3=:X; AD:=DCADDR; D+X; *DEPO  % Save rt-descr. addr.
124675                       MIN YINDX
124676                    FI; MIN XINDX
124677                 OD; MIN CNDX
124701              OD
124702           ELSE                                                  % Log max. 8 mon.calls split on all rt-programs
124703              A:=RTEND-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
124711              *1BANK
124712              T:=A; AD:=D1BXML; *DEPO                            % Number of rt-programs in the system
124715              *2BANK
124716              RTEND=:CEND; RTSTA=:CSTA
124722              *1BANK
124723              0=:CNDX
124724              DO WHILE CSTA<<CEND
124730                 CNDX*40=:X; AD:=D1BXML; D+X+1; AD=:DCADDR      % Phys addr of buffer element
124736                 0=:XINDX=:YINDX
124740                 DO WHILE XINDX<<10
124744                    "X1MLP"+XINDX
124746                    IF A.S0><-1 THEN
124753                       T:=A; YINDX*4=:X; AD:=DCADDR; D+X+1; *DEPO% Mon.call number
124762                       T:=CSTA; D-1; *DEPO                       % Rt-program
124765                       MIN YINDX
124766                    FI; MIN XINDX
124767                 OD; CSTA+5RTSIZE=:CSTA
124773                 MIN CNDX
124774              OD
124775           FI
124775           *2BANK
124776           TAD:=TADREG; X:=XREG
125000           EXITA
125001   RBUS
125013
125013
125013   %=============================================================================
125013   % Buffer initialisation routine for primitive #37, option code=10000.
125013   %
125013   % Entry:         none
125013   % Exit:          error
125013   % Exit+1:        ok
125013   %
125013   SUBR P37X2
125013   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
125017   INTEGER XINDX,CNDX,YINDX
125022   INTEGER CSTA,CEND; DOUBLE DCADDR
125026   P37X2:  TAD=:TADREG; X=:XREG
125030           *1BANK
125031           A:=ML5FL
125032           *2BANK
125033           IF A=0 THEN                                           % Log mon.calls for max 8 processes
125034              *1BANK
125035              0=:CNDX
125036              DO WHILE CNDX<<524
125042                 CNDX*30=:X; AD:=D5BXML; D+X; AD=:DCADDR        % Phys. addr of buffer element
125050                 0=:XINDX; 0=:YINDX
125052                 DO WHILE XINDX<<10
125056                    "Y1MLP"+XINDX
125060                    IF A.S0><-1 THEN
125065                       T:=A; YINDX*3=:X; AD:=DCADDR; D+X; *DEPO  % Save process number
125074                       MIN YINDX
125075                    FI; MIN XINDX
125076                 OD; MIN CNDX
125100              OD
125101           ELSE                                                  % Log max 8 mon.calls for all nd-500 processes
125102              T:=MX5PROCS+1
125104              *1BANK
125105              AD:=D5BXML; *DEPO                                  % Number of nd-500 processes
125107              T=:CEND
125110              0=:CNDX
125111              DO WHILE CNDX<<=CEND
125115                 CNDX*30=:X; AD:=D5BXML; D+X+1; AD=:DCADDR      % Phys addr of buffer element
125123                 0=:XINDX=:YINDX
125125                 DO WHILE XINDX<<10
125131                    "Y1MLP"+XINDX
125133                    IF A.S0><-1 THEN
125140                       T:=A; YINDX*3=:X; AD:=DCADDR; D+X; *DEPO  % Save mon.call number
125147                       MIN YINDX
125150                    FI; MIN XINDX
125151                 OD
125152                 MIN CNDX
125153              OD
125154           FI
125154           *2BANK
125155           TAD:=TADREG; X:=XREG
125157           EXITA
125160   RBUS
125167
125167
125167   %============================================================================
125167   % Subroutine to check if nd-500 is present and initialized
125167   %
125167   % Entry:         none
125167   % Exit:          error, nd-500 not present or not initialized
125167   % Exit+1:        ok
125167   %
125167   SUBR CH5OK
125167   INTEGER ASAV
125170   CH5OK:  A=:ASAV
125171           IF 5MSINIT NBIT 5INBUF OR MX5PROC=0 THEN EILPARS; EXIT FI
125200           A:=ASAV
125201           EXITA
125202   RBUS
125204
125204
125204   %=============================================================================
125204   % Subroutine to check for legal nd-500 process number
125204   %
125204   % Entry:         A=process number
125204   % Exit:          error, illegal process number or nd-500 not initialized
125204   % Exit+1:        ok
125204   %
125204   SUBR CH5PROC
125204   INTEGER TREG,AREG,DREG; TRIPLE TADREG=TREG
125207   INTEGER POINTER LREG
125210   CH5PROC: TAD=:TADREG; A:=L=:"LREG"
125213           CALL CH5OK; GO ERR
125215           IF AREG>>MX5PROC THEN EILPARS; GO ERR FI
125223           MIN "LREG"
125224   OUT:    TAD:=TADREG; GO LREG
125226   ERR:    A=:AREG; GO OUT
125230   RBUS
125232   %=============================================================================
125232   % Subroutine to check for legal nd-500 CPU number
125232   %
125232   % Entry:         A=CPU number
125232   % Exit:          error, illegal CPU number or nd-500 not initialized
125232   % Exit+1:        ok
125232   %
125232   SUBR CHE5CPU
125232   INTEGER TREG,AREG,DREG,BREG; TRIPLE TADREG=TREG
125236   INTEGER POINTER LREG
125237   CHE5CPU: TAD=:TADREG; A:=L=:"LREG"; A:=B=:BREG
125244            CALL CH5OK; GO ERR
125246            A:=AREG
125247            A-1 *5CPUDSIZE+"S5CPUDF"=:B
125253            IF CPUAVAILABLE=0 THEN A:=2052; GO ERR FI
125257            IF A NBIT 5ALIVE THEN A:=2061; GO ERR FI
125263            X:=MAILINK;T:=5MBBANK;*AAX X5CPU ;LDATX
125267            IF A><MPACTIVE THEN A:=2061; GO ERR FI
125274            MIN "LREG"
125275   OUT:     BREG=:B; TAD:=TADREG; GO LREG
125301   ERR:     A=:AREG; GO OUT
125303   RBUS
125311
125311
125311   %=============================================================================
125311   % Subroutine to check for legal rt-description address.
125311   %
125311   % Entry:         A=rt-description address.
125311   % Exit:          error
125311   % Exit+1:        ok
125311   %
125311   SUBR CHRTADDR
125311   TRIPLE TADREG
125314   CHRTADDR: TAD=:TADREG
125315             IF A>>=RTSTART AND A<<RTEND THEN
125323                A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
125330                IF D=0 THEN L+1 FI
125333             FI; TAD:=TADREG; EXIT
125335   RBUS
125337   *"
"125337
125337   @DEV 1
125337   @DEV (S-S-L)MP-P2-PERF-SAMP:NPL
125337

125337   *"8MPRF 8N500
"125337   SUBR UTLGX,AUTLG,LUWQU
125337   RBUS
125337
125337   %=========================================================================
125337   % Mon Performance dummy routine
125337   %
125337   SUBR NOOP
125337   NOOP: EXIT
125340   RBUS
125340
125340
125340   %=========================================================================
125340   % Routine to find the disk access type
125340   %
125340   % Entry:         X=datafield addr
125340   %                A=log type
125340   % Exit :         A=log type
125340   %
125340   % Called in 1BANK mode; returns in 1BANK mode
125340   %
125340   SUBR FDTYP
125340   INTEGER POINTER LREG
125341
125341   FDTYP:  IF A><NODTY THEN EXIT FI
125345           *2BANK
125346           T:=L=:"LREG"
125350           X:=X.RTRES                                           % if not sort, x=b
125351           IF X><0 THEN
125352              IF A:=X="CLFIE".RTRES THEN
125357                 ACC1S                                           % Nd-100 swapping
125360              ELSE IF A.ACTPRI SH -13/\17=4 THEN                 % Find type by normal pit.
125370                 CALL FSEMA; GO IACC1; GO IACC5                  % 500 proc using filesystem ?
125373   IACC1:        ACC1F                                           % Nd-100 file access
125374              ELSE IF A=5 THEN
125400   IACC5:        ACC5F                                        % Nd-500 file access
125401              ELSE IF A=10 AND X="5SWAP" THEN
125410                 T:=5MBBANK; X:=SWMSG; *AAX PAR2; LDDTX       % sin-l and swapper  returning flag and segno
125414                 *1BANK
125415                 T:=D=:C5SEG
125417                 IF A=1 THEN                                  % File as segment
125422                    ACCFS
125423                 ELSE
125424                    ACC5S                                     % Nd-500 ord. swapping
125425                 FI
125425              ELSE
125426                 ACCXY                                        % Unclassified access
125427              FI FI FI FI             % FI KGT
125427           FI
125427   FDOUT:  *1BANK
125430           GO LREG
125431   RBUS
125440
125440
125440   %=========================================================================
125440   %       X M B D S    G D U N I     M B D Q U
125440   %
125440   SUBR XMBDS, GDUNI, MBDQU
125440
125440   DOUBLE  DIDF(0); *9FDFD;9EDFD
125442   INTEGER CDUN,CNDX
125444
125444   % Subroutine to check for disks with disk optimisation
125444   %
125444   % Entry:         X=datafield addr
125444   %                A=index
125444   % Exit:          disk with optimisation
125444   % Exit+1:        not disk or disk without optimisation
125444   %
125444   % Called in ?BANK mode; returns in ?BANK mode
125444   %
125444
125444   XMBDS:  A=:CNDX; AD:=DIDF
125446           IF X>>=A AND X<<D THEN
125452              *2BANK
125453              IF X<<"9ESTR" AND X.STREN=0 THEN EXITA FI
125461              CNDX SHZ -1; *1BANK
125464              D:=X; ADDU1(A)=:CDUN; *2BANK
125471              X:=D; EXIT
125473           FI
125473           EXITA
125474
125474   % Subroutine to check for requested disk drive
125474   %
125474   % Entry:         A=function code
125474   % Exit:          not requested disk drive
125474   % Exit+1:        requested disk drive; function is read
125474   % Exit+2:        requested disk drive; function is write
125474   %
125474   % Called in ?BANK mode; returns in 1BANK mode
125474   %
125474   GDUNI:  *1BANK
125475           IF A=:D SHZ -6/\7=CDUN THEN
125503              L+1; IF D BIT 0 THEN L+1 FI
125507           FI
125507           EXIT
125510
125510   % Subroutine to check for any ongoing seek
125510   % on the requested disk drive
125510   %
125510   % Entry:         X=disk datafield
125510   % Exit:          no ongoing seek
125510   % Exit+1:        ongoing seek; function is read.
125510   % Exit+2:        ongoing seek; function is write.
125510   %
125510   % Called in ?BANK mode; leaves in 1BANK mode
125510   %
125510   MBDQU: *2BANK
125511           A:=X.PSTRA=:D; *1BANK               % D= UNIT DF. FOR STARTED TRANSFER
125514           T:=CDUN; X+T; *AAX PUNDF            % X= ADDR IN PUNDF
125517           *2BANK
125520           IF X:=X.S0 ><0 AND X >< D AND X:=X.SLINK><0 THEN
125526              L+1
125527              IF X.ABFUN BIT 0 THEN L+1 FI
125533           FI
125533          *1BANK
125534          EXIT
125535   RBUS
125540
125540   %MBDQU: *2BANK
125540   %       IF X.SRSEEK><0 THEN
125540   %           *1BANK
125540   %           T:=CDUN; X+T; *AAX PUNDF
125540   %           *2BANK
125540   %           IF X:=X.S0><0 AND X:=X.SLINK><0 THEN
125540   %              L+1
125540   %              IF X.ABFUN BIT 0 THEN L+1 FI
125540   %           FI
125540   %       FI
125540   %       *1BANK
125540   %       EXIT
125540
125540
125540   %=========================================================================
125540   % Subroutine to check if log.dev is a disc, and if so,
125540   % check if this disc drive should be logged.
125540   %
125540   % Entry:    X=datafield addr
125540   %           A=index
125540   % Exit:     disk should not be logged
125540   % Exit+1:   disk "input" should be logged or not disk.
125540   % Exit+2:   disk "output" should be logged
125540   %
125540   % Called in 1BANK mode; returns in 1BANK mode
125540   %
125540   SUBR MBDIS
125540   DOUBLE  DIDF(0); *9FDFD;9EDFD
125542   INTEGER CNDX
125543
125543   MBDIS:  A=:CNDX
125544           AD:=DIDF
125545           IF X>>=A AND X<<=D THEN
125551              X=:D; CNDX SHZ -1
125554              T:=ADDU1(A)
125556              *2BANK
125557              D.CTRG=:D
125562              *1BANK
125563              IF A SHZ -6/\7=T THEN
125567                 L+1; IF D BIT 0 THEN L+1 FI
125573              FI
125573           ELSE
125574              L+1
125575           FI
125575           EXIT
125576   RBUS
125600
125600
125600   %==============================================================================
125600   % Monitor level routine for mon.call type 36
125600   %
125600   SUBR MMPERF
125600   MMPERF: X:=RTREF; "DFMPE"=:B; CALL BRESERVE
125604           IF A<0 THEN
125605              205; *IRW ALEVB DA
125607           ELSE
125610              A:=B; CALL SWAPP
125612           FI; GO MONEN
125613   RBUS
125621
125621
125621   %==============================================================================
125621   %      M S A M P
125621   % Called from routine ENT13 for sampling on level 13
125621   %
125621   SUBR MSAMP,XENDX
125621   INTEGER POINTER LREG
125622
125622   MSAMP: IF ACTMPERFORM=0 THEN EXIT FI
125625          MIN M13FREQUENCY; EXIT
125627          A:=L=:"LREG"
125631          MPERFREQUENCY=:M13FREQUENCY
125633   INTEGER ARRAY S13AR(0)
125633          *JPL I *1; XENDX
125635          *JPL I *1; XENDX
125637          *JPL I *1; XENDX
125641          *JPL I *1; XENDX
125643          *JPL I *1; XENDX
125645          *JPL I *1; XENDX
125647          *JPL I *1; XENDX
125651          *JPL I *1; XENDX
125653   XENDX: "LREG"=:L; EXIT
125656   RBUS
125661
125661
125661   %==============================================================================
125661   %      M M S M P
125661   % Patch in the routine ICLK for sampling on level 2
125661   %
125661   SUBR MMSMP,MLEND
125661   INTEGER POINTER LREG
125662   MMSMP: IF ACTMPERFORM=0 THEN EXIT FI
125665          MIN M2FREQUENCY; EXIT
125667          A:=L=:"LREG"
125671          MPERFREQUENCY=:M2FREQUENCY
125673   INTEGER ARRAY SMLAR(0)
125673          *JPL I *1; MLEND
125675          *JPL I *1; MLEND
125677          *JPL I *1; MLEND
125701          *JPL I *1; MLEND
125703          *JPL I *1; MLEND
125705          *JPL I *1; MLEND
125707          *JPL I *1; MLEND
125711          *JPL I *1; MLEND
125713   MLEND: "LREG"=:L; EXIT
125716   RBUS
125721
125721
125721   %=========================================================================
125721   % Primitive #1            M R P 0 1
125721   %
125721   % Level 13 routine for measuring ND-100 CPU utilisation
125721   %
125721   SUBR MRP01,LTCP1,LSCP1,LLCP1,LRCP1,ARCP1,1RCP1
125721   INTEGER PRVLV=?                    % Previous level
125721
125721   MRP01:  *TRA PVL
125722           A SHZ -3/\17=:PRVLV
125725
125725           % Total ND-100 CPU utilisation
125725   LTCP1:  P+1; GO LSCP1
125727           IF A=0 GO LLCP1                                       % Level 0 is prvious
125731           *1BANK
125732           MIN 2D1CP; P+1; MIN 1D1CP; 0/\0
125736           *2BANK
125737
125737           % Total ND-100 CPU utilisation split on user mode, monitor call mode and
125737           % system mode
125737   LSCP1:  P+1; GO LLCP1
125741           IF A=ALEVL THEN
125744              CURPROC.ACTPRI SH -7=:D
125750              IF A/\17>=3 OR A:=D SHZ -4/\17>=3 GO MOMOD
125762              *1BANK
125763              MIN 2U1CP; P+1; MIN 1U1CP; 0/\0                    % User mode
125767           ELSE IF A=BLEVL THEN
125773   MOMOD:     *1BANK
125774              MIN 2M1CP; P+1; MIN 1M1CP; 0/\0                    % Monitor call mode
126000           ELSE
126001              *1BANK
126002              MIN 2S1CP; P+1; MIN 1S1CP; 0/\0                    % System mode
126006           FI FI
126006           *2BANK
126007
126007           % Total ND-100 CPU utilisation split on hardware interrupt levels
126007   LLCP1:  P+1; GO LRCP1
126011           PRVLV; X:="1CPAR"+A+A
126015           *1BANK
126016           MIN X.S1; P+1; MIN X.S0; 0/\0
126022           *2BANK
126023
126023           % ND-100 CPU usage while a spesific program is active
126023   LRCP1:  P+1; GO ARCP1
126025           IF PRVLV=ALEVL OR A=BLEVL THEN
126034              CURPROC
126035              *1BANK
126036              IF A=ACRTPROC THEN
126041                 MIN 2R1CP; P+1; MIN 1R1CP; 0/\0
126045              FI
126045              *2BANK
126046           FI
126046
126046           % Total ND-100 CPU utilisation split over all rt-programs
126046   ARCP1:  P+1; GO 1RCP1
126050           IF PRVLV><0 THEN
126052              IF A><ALEVL AND A><BLEVL GO 1RCP1
126060              CURPROC-RTSTART=:D; A:=0; T:=5RTSIZE; *RDIV ST
126066           FI
126066           *1BANK
126067           A*3; X:=SAR1C+A; T:=BAR1C; *LDDTX 20
126074           D+1; A:=A+C; *STDTX 20
126077           *2BANK
126100           GO 1RCP1
126101
126101   INTEGER PRVLV                      % Previous level
126102   *)FILL
126132
126132           % ND-100 CPU usage while a spesific program is active,
126132           % split on user mode, monitor call mode and system overhead
126132   1RCP1:  P+1; EXITA
126134           *1BANK
126135           ACRTPROC
126136           *2BANK
126137           IF A=CURPROC THEN
126142              IF PRVLV=ALEVL THEN
126146                 IF CURPROG.ACTPRI SH 1 SHZ -14>=3 GO RMOMO
126155                 *1BANK
126156                 MIN 2RU1C; P+1; MIN 1RU1C; 0/\0
126162              ELSE IF A=BLEVL THEN
126166   RMOMO:        *1BANK
126167                 MIN 2RM1C; P+1; MIN 1RM1C; 0/\0
126173              ELSE
126174                 *1BANK
126175                 MIN 2RS1C; P+1; MIN 1RS1C; 0/\0
126201              FI FI
126201              *2BANK
126202           FI
126202           EXITA
126203   RBUS
126213
126213
126213   %=========================================================================
126213   % Primitive #1            M M P 0 1
126213   %
126213   % Monitor level
126213   % Find length of ND-100 execution queue
126213   %
126213   SUBR MMP01
126213   INTEGER POINTER LREG
126214   INTEGER NXSWW
126215
126215   MMP01:  P+1; EXITA
126217           A:=L+1=:"LREG"; D:=0; L:=0; 0=:NXSWW
126224           X:=BEXQU; T:="BEXQU-2"
126226           DO WHILE X><T
126230              IF X.STATUS<0 THEN
126232                 IF A NBIT 5SWWA THEN L+1
126235                 ELSE MIN NXSWW; 0/\0 FI
126240              ELSE
126241                 D+1
126242              FI
126242              X:=X.WLINK
126243           OD
126244           *1BANK
126245           D=:T; AD:=REXQL; D+T; A:=A+C; AD=:REXQL
126252           AD:=IEXQL; D+L; A:=A+C; AD=:IEXQL
126256           T:=NXSWW; AD:=SEXQL; D+T; A:=A+C; AD=:SEXQL
126263           *2BANK
126264           GO LREG
126265   RBUS
126272
126272
126272   %=========================================================================
126272   % Primitive # 2           M R P 0 2
126272   %
126272   % Level 13
126272   % Utilisation of ND-500 CPU
126272   %
126272   SUBR MRP02,LTCP5,CP5MO,APCP5,ALLC5,XC5MO
126272   INTEGER CC5PROC=?                  % Current executing nd-500 process
126272   INTEGER BREG=?
126272   INTEGER POINTER LREG=?
126272
126272   MRP02:  "S5CPUDF"; A:=:B=:BREG; A:=L+1=:"LREG"
126277   LOOP:   IF B>>"E5CPUDF" GO FAR ALLC5
126302             IF CPUAVAILABLE NBIT 5ALIVE GO FAR END02              % Nd-500 cpu unavailable?
126305             CALL GETC5PROC; A=:CC5PROC                            % Current active nd-500 process
126307             IF A<0 GO FAR END02                                   % If =-1 then nd-500 is passive
126311             IF CPUAVAILABLE/\5CPUTYPE=SAMSON THEN
126316                IF MAILINK=-1 GO FAR END02                         % Samson message queue initialized ?
126322             ELSE
126323                T:=HDEV+"RSTA5"; *IOXT
126326                IF A NBIT 5ILOC OR A BIT 5POWOFF GO FAR END02      % Nd-500 locked or power fail?
126332             FI
126332
126332             % Total ND-500 CPU utilisation.
126332   LTCP5:    P+1; GO CP5MO
126334             CPUNO-1 SH 1=:X
126340             *1BANK
126341             AD:=D5CP(X); D+1; A:=A+C; AD=:D5CP(X)
126345             *2BANK
126346
126346             % ND-500 CPU utilisation
126346   CP5MO:    P+1; GO APCP5
126350             CPUNO-1 SH 1 =:X
126354             IF CC5PROC><5SWPROC THEN
126360                *1BANK
126361                AD:=CP5U(X); D+1; A:=A+C; AD=:CP5U(X) % User mode
126365             ELSE
126366                *1BANK
126367                AD:=CP5S(X); D+1; A:=A+C; AD=:CP5S(X) % Swapper mode (ND-500 swapper is active).
126373             FI
126373
126373             % ND-500 CPU usage by a spesific process
126373   APCP5:    P+1; GO XC5MO
126375             *1BANK
126376             IF CC5PROC=Y5PROC THEN
126402                *2BANK
126403                A-5SWPROC*5PRDSIZE+"S500S"=:X; X:=X.MESSBUFF
126410                T:=5MBBANK; *AAX 5CPUN; LDATX
126413                A-1 SH 1 =:X ;*1BANK
126417                AD:=XCP5(X); D+1; A:=A+C; AD=:XCP5(X)
126423             FI
126423             *2BANK
126424             GO XC5MO
126425   *)FILL
126447   INTEGER CC5PROC                    % Current executing nd-500 process
126450   INTEGER BREG
126451   INTEGER POINTER LREG
126452
126452             % ND-500 CPU usage split on user mode and swapper mode
126452             % while a spesific process is active
126452   XC5MO:    P+1; GO END02
126454             *1BANK
126455             X:=Y5PROC
126456             *2BANK
126457             IF X>>MX5PROCS GO END02
126462             IF X=CC5PROC THEN
126465                *1BANK
126466                MIN 2XPRU; P+1; MIN 1XPRU; 0/\0
126472             ELSE
126473                IF CC5PROC=5SWPROC THEN                          % Swapper active?
126477                   A:=X-5SWPROC*5PRDSIZE+"S500S"                 % X=Y5PROC
126503                   A.MESSBUFF=:L
126506                   T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
126513   *NNC50,         CNVBYADR
126516                   IF D=L THEN
126520                      *1BANK
126521                      MIN 2XPRS; P+1; MIN 1XPRS; 0/\0
126525                   FI
126525                FI
126525             FI
126525   END02:    *2BANK
126526             B+5CPUDFSZ
126527           GO FAR LOOP
126530
126530           % ND-500 CPU usage split over all processes
126530   ALLC5:  P+1; GO OUT
126532           *1BANK
126533           LXCPU ; *2BANK
126535           A-1*5CPUDFSIZE+"S5CPUDF"=:B
126541           CALL GETC5PROC
126542           *1BANK
126543           IF A>=0 THEN
126544              A SH 1; X:=SAR5C+A; T:=BAR5C; *LDDTX 10
126551              D+1; A:=A+C; *STDTX 10
126554           FI
126554   OUT:    *2BANK
126555           BREG=:B ; GO LREG
126560
126560   RBUS
126603
126603
126603   %=========================================================================
126603   % Primitive # 2           M M P 0 2
126603   %
126603   % Monitor level.
126603   % Find length of ND-500 execution queue
126603   %
126603   SUBR MMP02
126603   INTEGER N5SWAP
126604   INTEGER N5WAIT
126605   INTEGER N5ACT
126606   INTEGER POINTER LREG
126607
126607   MMP02:  P+1; EXITA
126611           *IOF
126612           A:=L+1=:"LREG"
126614           "S5CPUDF"=:B; 0=:N5WAIT=:N5SWAP=:N5ACT
126621           DO WHILE B<<="E5CPUDF"
126624              IF X:=MAILINK><-1 THEN
126630                 DO
126630                    T:=5MBBANK; *LINK@3 LDDTX
126632                 WHILE D><-1
126635   *NNC51,          CNVBYADR
126640                    IF X:=D><DUMMESS THEN
126644                       CALL RN5STATUS                        % Read status
126645                       IF A=MSGN500 OR A=WAITING THEN        % Active?
126653                          MIN N5ACT; 0/\0
126655                       ELSE IF A=SWPWAIT THEN                % Waiting for Swapper?
126661                          MIN N5SWAP; 0/\0
126663                       ELSE                                  % All other states
126664                          MIN N5WAIT; 0/\0
126666                       FI FI
126666                     FI
126666                 OD
126667                 IF CPUAVAILABLE/\5CPUTYP=SAMSON GO OUT   % Only one exec. q.
126674              FI
126674              B+5CPUDF
126675           OD
126676   OUT:    *1BANK
126677           T:=N5ACT;  AD:=LE5XQ; D+T; A:=A+C; AD=:LE5XQ
126704           T:=N5WAIT; AD:=LW5XQ; D+T; A:=A+C; AD=:LW5XQ
126711           T:=N5SWAP; AD:=LS5XQ; D+T; A:=A+C; AD=:LS5XQ
126716           *2BANK; ION
126720           GO LREG
126721   RBUS
126733
126733
126733   %=========================================================================
126733   % Primitive #3            M M P 0 3     T U T L G
126733   % Monitor level
126733   % Log utilisation of logical device(s)
126733   %
126733   SUBR MMP03,TUTLG
126733   INTEGER POINTER LREG
126734   INTEGER CNDX
126735
126735   MMP03:  A:=L=:"LREG"
126737   TUTLG:  P+1; GO UTLGX
126741           0=:CNDX; "1TL1I"=:B
126744           DO WHILE X:=CNDX<<20
126750              *1BANK
126751              X:=LUADD(X)
126752              IF X:=X.S0><0 THEN                                 % Datafield defined?
126754                 CNDX; CALL XMBDS; GO DISK                       % Disk optimisation ?
126757                 *2BANK
126760                 IF X.RTRES=0 GO ELOOP                           % Datafield reserved?
126762                 *1BANK
126763                 CNDX; CALL MBDIS; GO ELOOP; GO DIIN; GO L1      %
126770   DISK:         *IOF; 2BANK
126772   NOTRN:        CALL MBDQU; GO ELOOP; GO DIIN
126775   L1:           B+2; MIN CNDX
126777   DIIN:         MIN S1; P+1; MIN S0; 0/\0                   % Yes, increment counter
127003                 *ION
127004              FI
127004   ELOOP:     B+2; MIN CNDX
127006           OD
127007           *ION; 2BANK
127011           "LREG"=:L; GO UTLGX
127014
127014   RBUS
127023
127023
127023   %=========================================================================
127023   % Primitive #3            U T L G X
127023   % Monitor level
127023   % Log utilisation of logical device(s), by a spesific program
127023   %
127023   SUBR UTLGX
127023   INTEGER POINTER LREG
127024   INTEGER CNDX
127025
127025   UTLGX:  P+1; GO AUTLG
127027           A:=L=:"LREG"
127031           0=:CNDX; "1XL1I"=:B
127034           DO WHILE X:=CNDX<<20
127040              *1BANK
127041              X:=LUADD(X)
127042              IF X:=X.S0><0 THEN                                 % Log.unit defined?
127044                 CNDX; CALL XMBDS; GO GDSK; *2BANK               % Disk optimisation ?
127050                 A:=X.RTRES; *1BANK
127052                 IF A><XLRTP GO ELOOP                       % In use by specified program?
127055                 CNDX; CALL MBDIS; GO ELOOP; GO DIIN; GO L1
127062
127062   GDSK:         *IOF; 1BANK
127064                 T:=XLRTP; *2BANK
127066                 IF X.STPRW><T GO NOTRN                      % Might be SCSI
127071                 X.CTRG; CALL GDUNI; GO NOTRN; GO DIIN
127075   L1:           B+2; MIN CNDX; GO DIIN
127100   NOTRN:        CALL MBDQU; GO ELOOP; GO RTCHK
127103                 B+2; MIN CNDX
127105   RTCHK:        *2BANK
127106                 A:=X.RTRES
127107                 *1BANK
127110                 IF A=XLRTP THEN
127113   DIIN:            MIN S1; P+1; MIN S0; 0/\0              % Yes, incremnet counter
127117                 FI
127117              FI
127117   ELOOP:     *ION
127120              B+2; MIN CNDX
127122           OD
127123           *2BANK
127124           "LREG"=:L; GO AUTLG
127127   RBUS
127137
127137
127137   %=========================================================================
127137   % Primitive #3            A U T L G
127137   % Monitor level
127137   % Log utilisation of logical device(s), split over all programs
127137   %
127137   SUBR AUTLG
127137   INTEGER POINTER LREG
127140   INTEGER CNDX
127141   INTEGER CCNT
127142
127142   AUTLG:  P+1; GO LUWQU
127144           A:=L=:"LREG"
127146           0=:CNDX
127147           DO WHILE X:=CNDX<<20
127153              *1BANK
127154              X:=LUADD(X)
127155              IF X:=X.S0><0 THEN                                 % Log.unit defined?
127157                 CNDX; CALL XMBDS; GO GDSK; *2BANK              % Disk optimisation ?
127163                 A:=X.RTRES; *1BANK
127165                 IF A=0 GO ELOOP                                   % Log.unit reserved?
127166                 CNDX; CALL MBDIS; GO ELOOP; P+1; MIN CNDX
127173                 *2BANK
127174                 X.RTRES; GO L1
127176
127176   GDSK:         *IOF; 2BANK
127200   NOTRN:        CALL MBDQU; GO ELOOP; P+1; MIN CNDX
127204                 *2BANK
127205                 X.RTRES
127206   L1:           A-RTSTART=:D; A:=0; T:=5RTSIZE; *RDIV ST; 1BANK
127214                 A*41+SLUADDR; X:=CNDX; X+X+A; T:=BLUADDR; *LDDTX 20
127223                 D+1; A:=A+C; *STDTX 20
127226              FI
127226   ELOOP:     *ION
127227              MIN CNDX
127230           OD
127231           *2BANK
127232           "LREG"=:L; GO LUWQU
127235   RBUS
127246
127246
127246   %=========================================================================
127246   % Primitive #3            L U W Q U
127246   % Monitor level
127246   % Log utilisation of logical device(s)
127246   % Sample the length of the waiting queue for the specified log.units
127246   %
127246   SUBR LUWQU
127246   INTEGER POINTER LREG
127247   INTEGER CNDX
127250   INTEGER CCNT
127251
127251   LUWQU:  P+1; EXITA
127253           A:=L+1=:"LREG"
127255           0=:CNDX
127256           DO WHILE X:=CNDX<<20
127262              *1BANK
127263              X:=LUADD(X)
127264              IF X:=X.S0><0 THEN                                 % Log.unit defined?
127266                 CNDX; CALL XMBDS; GO GDSK; *2BANK              % Disk optimisation ?
127272                 X=:D; "BWLINK-WLINK"; X+A; T:=0
127276                 DO WHILE X:=X.WLINK><D; T+1; OD
127303                 IF T=0 GO ELOOP; *1BANK
127306                 GO L1
127307
127307   GDSK:         *IOF; 2BANK
127311                 0=:CCNT
127312                 CALL MBDQU; GO ELOOP; 0/\0; MIN CCNT; 0/\0; *2BANK
127320                 DO WHILE X:=X.NLINK><0; MIN CCNT; 0/\0; OD
127325                 T:=CCNT; *1BANK
127327   L1:           X:=CNDX; X+X; AD:=ADDLW(X)
127332                 D+T; A:=A+C; AD=:ADDLW(X)
127335              FI
127335   ELOOP:     *ION
127336              MIN CNDX
127337           OD
127340           *2BANK
127341           GO LREG
127342   RBUS
127347
127347
127347   %=========================================================================
127347   % Primitive #4
127347   %
127347   SUBR MMP04,T5SWP,X5SWP,A5SWP
127347   INTEGER CFLG
127350   INTEGER POINTER LREG,LRG
127352
127352   % Local subroutine to check Swapper status
127352   % Called in 2BANK mode; returns in 2BANK mode
127352   %
127352   CH5SW:  IF CFLG=0 THEN
127354              A:=L=:"LRG"
127356              X:=SWMSG; CALL RN5STATUS
127360              T:="LRG"=:L
127362              IF A><MFREE AND A><PSWWAIT THEN
127370                 A:=1; L+1                                       % Swapper is in use
127372              ELSE
127373                 A:=-1                                           % Swapper not in use
127374              FI
127374              A=:CFLG
127375           ELSE
127376              IF A>=0 THEN L+1 FI
127400           FI
127400           EXIT
127401
127401           % Log utilisation of the ND-500 Swapper.
127401   MMP04:  *IOF
127402           A:=L=:"LREG"; 0=:CFLG
127405
127405           % Total utilisation of the nd-500 swapper
127405   T5SWP:  P+1; GO X5SWP
127407           CALL CH5SW; GO ENDL4
127411           *1BANK
127412           MIN 2D5SW; P+1; MIN 1D5SW; 0/\0
127416           *2BANK
127417
127417           % Utilisation of nd-500 swapper by a specific process.
127417   X5SWP:  P+1; GO A5SWP
127421           CALL CH5SW; GO ENDL4
127423           T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
127430   *NNC52, CNVBYADR
127433           *1BANK
127434           IF D=XSWOWER THEN
127437              MIN 2X5SW; P+1; MIN 1X5SW; 0/\0
127443           FI
127443           *2BANK
127444
127444           % Utilisation of nd-500 swapper split over all processes.
127444   A5SWP:  P+1; GO ENDL4
127446           CALL CH5SW; GO ENDL4
127450           T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWO; LDDTX
127455   *NNC53, CNVBYADR
127460           X:=D; *SENDE@3 LDATX
127462           *1BANK
127463           T:=B5SWAP; X:=S5SWAP+A+A; *LDDTX 10
127470           D+1; A:=A+C; *STDTX 10
127473           *2BANK
127474   ENDL4:  "LREG"=:L; *ION
127477           EXITA
127500   RBUS
127516
127516   %
127516   % Sampling routines for disks moved to EXCOM (btt - 880428)
127516   %
127516
127516   %===========================================================================
127516   % Primitive #36               P M L 1 0
127516   %
127516   % Patch in the routine ENT14 on level 14
127516   %
127516   SUBR PML10,PMLAL,PMLXA
127516   INTEGER TREG,AREG,DREG
127521   INTEGER POINTER LREG
127522   TRIPLE  TADREG=TREG
127522   INTEGER ARRAY POINTER QQIND=?
127522
127522   OUT1:   TAD:=TADREG
127523           *2BANK
127524           GO LREG
127525
127525   %
127525   % Local subroutine to search array for match.
127525   %
127525   % Entry : D = mon.call/RT-descr.
127525   % Exit  : no match
127525   % Exit+1: match ( X = index )
127525   %
127525   CSUBR:  FOR X:=0 TO 7 DO
127531              WHILE QQIND(X) >< -1
127535              IF A=D THEN EXITA FI
127540           OD
127542           EXIT
127543
127543
127543   PML10:  0/\0; EXIT
127545           IF X:=ACTMPERFORM=0 THEN EXIT FI
127551           TAD=:TADREG
127552           A:=L=:"LREG"
127554
127554           % Count all monitor calls
127554   PMLAL:  0/\0; GO PMLXA
127556           T:=RTREF
127557           *1BANK
127560           IF MLXRT=0 OR A=T THEN
127564              TREG/\377 SH 1
127567              T:=BMLB1; X:=SMLB1+A; *LDDTX
127573              D+1; A:=A+C; *STDTX
127576           FI
127576           *2BANK
127577           GO PMLXA
127600
127600   *)FILL
127607   INTEGER ARRAY POINTER QQIND
127610
127610
127610           % Log all monitor calls by 8 specific programs,
127610           % split on all moncalls
127610   PMLXA:  0/\0; GO OUT1
127612           RTREF=:D
127614           *1BANK
127615           "DX1MLP"=:"QQIND"
127617           IF MLOFL=0 THEN
127621              CALL CSUBR; GO OUT1                    % Logged RT-prog ?
127623              A:=X*3=:X
127626              TREG/\377*30+X
127632              T:=BXML1; X:=SXML1+A; *LDDTX 10
127636              D+1; A:=A+C; *STDTX 10
127641           ELSE
127642              % Log max 8 mon.calls for all RT-programs
127642              TREG/\377=:D; CALL CSUBR; GO OUT1               % Logged mon. call ?
127647              A:=X SH 2=:X
127652              *2BANK
127653              RTREF-RTSTART=:D; A:=0; T:=5RTSIZE; *RDIV ST
127661              *1BANK
127662              A*40+X; T:=BXML1; X:=SXML1+A; *LDDTX 20
127670              D+1; A:=A+C; *STDTX 20
127673           FI
127673           GO FAR OUT1
127674
127674   RBUS
127707
127707   %===========================================================================
127707   % Primitive #37                  P M L 5 0
127707   %
127707   % ND500: Patch in routine MCHANDLE on level 12
127707   %
127707   SUBR PML50,5MLAL,5MLXA
127707   INTEGER TREG,AREG,DREG
127712   TRIPLE  TADREG=TREG
127712   INTEGER POINTER LREG
127713   INTEGER CINDX=?,XREG=?
127713   INTEGER ARRAY POINTER QQIND=?
127713
127713   OUT1:   "LREG"=:L; TAD:=TADREG; X:=XREG
127717           *2BANK
127720           EXIT
127721
127721   %
127721   % Local subroutine to search array for match.
127721   %
127721   % Entry : D = mon.call/ND-500 process no.
127721   % Exit  : no match
127721   % Exit+1: match ( X = index )
127721   %
127721   CSUBR:  FOR X:=0 TO 7 DO
127725              WHILE QQIND(X) >< -1
127731              IF A=D THEN EXITA FI
127734           OD
127736           EXIT
127737
127737
127737   PML50:  0/\0; EXIT
127741           IF T:=ACTMPERFORM=0 THEN EXIT FI
127745           TAD=:TADREG; X=:XREG; A:=L=:"LREG"
127751
127751           % Count all monitor calls
127751   5MLAL:  0/\0; GO 5MLXA
127753           *1BANK
127754           MLXPROC=:D
127756           *2BANK
127757           IF A><-1 THEN
127762              T:=5MBBANK; *SENDE@3 LDATX
127764              IF A><D GO 5MLXA
127766           FI
127766           T:=5MBBAK; *AAX MCNO; LDATX
127771           IF A>>=524 GO OUT1
127774           *1BANK
127775           A SH 1; T:=BMLB5; X:=SMLB5+A; *LDDTX
130002           D+1; A:=A+C; *STDTX
130005           *2BANK
130006           GO 5MLXA
130007   *)FILL
130016   INTEGER XREG,CINDX
130020   INTEGER ARRAY POINTER QQIND
130021
130021           % Log all nd-500 mon.calls for max 8 processes
130021           % split on all moncalls
130021   5MLXA:  0/\0; GO OUT1
130023           T:=5MBBANK
130024           *1BANK
130025           "DY1MLP"=:"QQIND"
130027           IF ML5FL=0 THEN
130031              X:=XREG; *SENDE@3 LDATX
130033              A=:D; CALL CSUBR; GO OUT1                           % Match ?
130036              A:=X*3=:CINDX
130041              *2BANK
130042              T:=5MBBANK; X:=XREG; *AAX MCNO; LDATX
130046              IF A>>=524 GO OUT1
130051              *1BANK
130052              A*30+CINDX; T:=BXML5; X:=SXML5+A; *LDDTX 10
130060              D+1; A:=A+C; *STDTX 10
130063           ELSE
130064              % Log max 8 mon.calls for all ND-500(0) processes
130064              X:=XREG; *AAX MCNO; LDATX
130067              A=:D; CALL CSUBR; GO OUT1                          % Match ?
130072              A:=X*3=:CINDX
130075              *2BANK
130076              T:=5MBBANK; X:=XREG; *SENDE@3 LDATX
130101              *1BANK
130102              A*30+CINDX; T:=BXML5; X:=SXML5+A; *LDDTX 20
130110              D+1; A:=A+C; *STDTX 20
130113           FI
130113           GO FAR OUT1
130114
130114   RBUS
130125
130125
130125   %===========================================================================
130125   % Primitive #64
130125   %
130125   SUBR MMP64
130125   DISP 0; DOUBLE DD1=S1; PSID
130125   INTEGER CNDX
130126
130126   MMP64:  0=:CNDX
130127           DO
130127              *1BANK
130130              CNDX+"F1SGS"
130132              X:=A.S0
130134              *2BANK
130135           WHILE X><-1
130140              T:=SEGTBANK; *BPAGL@3 LDXTX
130142              D:=0; T:=CORMBANK
130144              DO WHILE X><0
130145                 D+1; *PAGLI@3 LDXTX
130147              OD
130150              IF D><0 THEN
130152                 CNDX*3+"DA1SG"=:X
130156                 *1BANK
130157                 T:=D; AD:=X.DD1; D+T; A:=A+C; AD=:X.DD1
130164                 *2BANK
130165              FI
130165              MIN CNDX
130166           OD
130167           EXITA
130170   RBUS
130175
130175   %===========================================================================
130175   % Primitive #65
130175   %
130175   SUBR MMP65
130175   DISP 0; DOUBLE DD1=S1; PSID
130175   INTEGER CNDX
130176
130176   MMP65:  IF 5MSINIT BIT 5INBUF THEN
130201              0=:CNDX
130202              *1BANK
130203              DO
130203                 CNDX SH 1 +"F5SGS"=:X
130207              WHILE X.S0><-1
130213                 T:=A; X:=X.S1
130215                 *AAX SSCPI; LDATX
130217                 IF A><0 THEN
130220                    A=:T:=CNDX*3+"DA5SG"=:X
130225                    AD:=X.DD1; D+T; A:=A+C; AD=:X.DD1
130231                 FI
130231                 MIN CNDX
130232              OD
130233              *2BANK
130234           FI
130234           EXITA
130235   RBUS
130241
130241   %===========================================================================
130241   % Primitive #66
130241   %
130241   SUBR MRP66
130241   INTEGER CLEVL                      % Previous level
130242   INTEGER CPREG                      % Actual P-reg on previous level
130243   INTEGER CNDX
130244
130244   MRP66:  *TRA PVL
130245           A=:D; *EXR SA
130247           A=:CPREG
130250           A:=D SH -3/\17=:CLEVL
130254           *1BANK
130255           IF A=PCLEV THEN
130260              % Log a specified level, fixed interval length.
130260              *1BANK
130261              IF A=2 OR A=3 THEN
130267                 % Log level 1 for specific rt-program, within specific segment, fixed interval.
130267                 *2BANK
130270                 X:=CURPROC
130271                 *1BANK
130272                 IF PCRTPROC=0 OR A=X THEN
130276                    IF T:=PC1SG><0 THEN
130301                       IF T>0 THEN
130303                          *2BANK
130304                          AD:=X.DACTS
130305                          IF A><T AND D><T AND X.RSEGM><T GO OUT
130314                       ELSE
130315                          *2BANK
130316                          X.ACTPRI SH -13/\17
130321                          *1BANK
130322                          IF A><PC1SG BZERO 17 GO OUT
130326                       FI
130326                    FI
130326                 FI
130326                 IF 1PCFL=2 GO FXFEL; GO VXALV
130333              ELSE IF 1PCFL=0 OR A=1 THEN
130341                 IF CPREG<<1FPRG GO OUTSIDE
130345                 IF 1PCFL=0 THEN
130347   FXFEL:           CPREG-1FPRG=:D; A:=0; T:=1PCIN; *RDIV ST
130355                    IF A>>=100 GO OUTSIDE
130360   FELLS:           A SH 1+"1DAPC"=:X
130363                    MIN X.S1; P+1; MIN X.S0; 0/\0
130367                 ELSE
130370                    % Log a specific level, variable interval length.
130370   VXALV:           X:="1FPRG"; 0=:D; A:=CPREG=:D
130374                    DO
130374                       IF X.S1>>D THEN CNDX; GO FELLS FI
130401                       WHILE CNDX<100
130405                       MIN CNDX; X+1
130407                    OD
130410   OUTSIDE:         MIN 1OUT2; P+1; MIN 1OUT1; 0/\0
130414                 FI
130414              FI FI
130414           FI
130414   OUT:    *2BANK
130415           EXITA
130416   RBUS
130431
130431
130431   %===========================================================================
130431   % Primitive #67                  P 6 7 L 1
130431   %
130431   % ND500: Called from CHN5STATUS
130431   %
130431   SUBR P67L1
130431   INTEGER CNDX,BREG
130433
130433   P67L1:  0/\0; EXIT
130435           A:=B=:BREG
130437           T:=MPHMESS
130440           IF X><T THEN EXIT FI
130443           IF ACTMPERFORM=0 THEN
130445   *NNT51=*
130445              CALL XTER500; 0/\0
130447              CALL SLOCK; 0/\0
130451              CALL IFM500XQ                                      % Measurement not active, remove mess from queue
130452              CALL SUNLOCK
130453           ELSE
130454              T:=5MBBANK; *AAX ACPRO; LDATX; AAX -ACPRO          % Is current process the target process?
130460              *1BANK
130461              T:=PC5PR
130462              *2BANK
130463              IF A><T AND T><0 GO OUT                           % Not target process active
130467              MFREE; CALL WN5STATUS                              % Message free
130471              *1BANK
130472              5LHPR=:L; *AAX N500A; LDDTX
130476              AD=:DCADR                                          % Current address
130477              D-L; A:=A+C-1
130502              IF A<5FHPR GO OUTSIDE
130505              IF T:=5PCFL=0 THEN
130510                 T:=5PCIN; Z:="0"; *RDIV ST
130513                 IF Z GO OUTSIDE
130515                 IF A>>=100 GO OUTSIDE
130520   FELLS:        A SH 1+"5DAPC"=:X
130523                 MIN X.S1; P+1; MIN X.S0; 0/\0
130527              ELSE
130530                 0=:CNDX; X:="5FHPR+2"
130532                 AD:=DCADR; A=:B; D=:L        % B-L IS CURRENT PREG
130535                 DO
130535                    AD:=X.DS0
130536                    IF B<<=A AND L<<D THEN    % INSIDE AREA ?
130542                       CNDX; GO FELLS
130544                    FI
130544                 WHILE CNDX<<100
130550                    MIN CNDX; X+2
130552                 OD
130553   OUTSIDE:      MIN 5OUT2; P+1; MIN 5OUT1; 0/\0
130557              FI
130557              *2BANK
130560           FI
130560   OUT:    A:=BREG=:B; GO NXTMSG
130563   RBUS
130606
130606
130606   %============================================================================
130606   % Sampling control routine for primitive #67     P 6 7 L 2
130606   %
130606   % ND500: Called from 500HIST, level 2
130606   %
130606   SUBR P67L2
130606   INTEGER POINTER LREG
130607
130607   P67L2:  0/\0; EXIT
130611           IF ACTMPERFORM=0 THEN EXIT FI
130614           A:=L=:"LREG"
130616           X:=MPHMESS; CALL GCPUDF; CALL ERRFATAL; A=:B
130622   *NNT52=*
130622           CALL TER500; 0/\0
130624           T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
130630           IF A NBIT 5IEXQUEUE THEN
130632              CALL SLOCK; 0/\0
130634              CALL ITO500XQ
130635              CALL SUNLOCK
130636           FI
130636           *1BANK
130637           X:=5MHPR
130640           *2BANK
130641           IF X><0 AND X.RTRES=0 THEN GO LREG FI
130645           X:=MPHMESS; MSGN500; CALL WN5STATUS
130650           CALL XACTRDY
130651           CALL LOWACT500
130652           GO LREG
130653   RBUS
130670
130670   %===========================================================================
130670   % Primitive #77    T R D E C
130670   %
130670   % ND500: TRDEC: Called from routine DECOMESS on level 12
130670   %        TRN5C: Called from routine N500C on level 2 (monitor level)
130670   %        TRACS: Called from routine 5ACTSWAPPER
130670   %        TRT5X: Called from routine ITO500XQ
130670   %        TRF5X: Called from routine IFM500XQ
130670   %        TTER5: Called from routine XTER500
130670   %        TRAC5: Called from routine XACT500
130670   %        TRMCC: Called from routine MCCO
130670   %        TRSWP: Called from routine SWPDECODER
130670   SUBR TRDEC,TRN5C,TRACS,TRT5X,TRF5X,TTER5,TRAC5,TRMCC,TRSWP
130670   SYMBOL N5SWAP=  377
130670
130670
130670
130670   % Local subroutine to init buffer pointers if TRINIT=-1
130670
130670   BINIT: A:=STRAC; A SHR 12=:D
130673          *2BANK
130674          A:=XBUFPAGE; *1BANK
130676          A+D=:5TPAGNO
130700          "OPD77".CURBU; A SHR 12=:5TNOPAG   % ???
130704          A:=5TPAGNO=:D:=0; AD SH 12=:5TDADDRESS
130711          AD=:5TPOINTER; A:=5TPAGNO+5TNOPAG=:D:=0
130716          AD SH 12 =:5TDEN; 0=:5OKPT; 1=:TRINIT
130723          EXIT
130724
130724   *)FILL
130736   INTEGER TREG=?,AREG=?,DREG=?
130736   TRIPLE  TADREG=?
130736   INTEGER POINTER LREG=?
130736   INTEGER XREG=?
130736
130736   INTEGER ARRAY POINTER QQIND=?
130736   %
130736   % Local subroutine to search array for match.
130736   %
130736   % Entry : D = ND-500 process no.
130736   % Exit  : no match
130736   % Exit+1: match ( X = index )
130736   %
130736   GSUBR:  FOR X:=0 TO 7 DO
130742              WHILE QQIND(X) >< -1
130746              IF A=D THEN EXITA FI
130751           OD
130753           EXIT
130754
130754   OUT1:   "LREG"=:L; TAD:=TADREG; X:=XREG
130760   OUT:    *2BANK
130761           EXIT
130762
130762           % Log all 500-processes , 8 specified processes or
130762           % 8 spec RT-programs from DECOMESS
130762   TRDEC:  0/\0; EXIT
130764           IF T:=ACTMPERFORM=0 THEN EXIT FI
130770           TAD=:TADREG; X=:XREG; A:=L=:"LREG"
130774           *1BANK
130775           IF TRINIT=-1 THEN
131001              CALL BINIT
131002           FI
131002           DECOSIZE=:TRCSIZE; XREG=:TRXREG
131006           *2BANK
131007           T:=5MBBANK; X:=XREG; *AAX STOPR; LDATX; AAX -STOPR
131014           IF A=TRAPCODE THEN
131017              *AAX TRAPN-1; LDDTX; AAX 1-TRAPN          % D=TRAP NO
131022              *1BANK
131023              IF D=46 THEN                              % PAGE FAULT TRAP
131026                 IF DEPFFLAG=1 THEN
131032                    DECOPT=:TRCOPT; CALL FELLE; 0/\0; FI        % LOGG PF TRAP
131036              ELSE IF DETRFLAG=1 THEN
131043                    DECOPT\/20=:TRCOPT; CALL FELLE; 0/\0; FI      % LOGG TRAP - PF
131050              FI
131050           ELSE IF A=MOCALL THEN
131054              *AAX MCNO; LDATX; AAX-MCNO
131057              IF A=N5SWAP THEN GO FAR OUT1; FI
131063              *1BANK
131064              IF DEMCFLAG=1 THEN
131070                 DECOPT\/60=:TRCOPT; CALL FELLE; 0/\0; FI           % LOGG MCALL - 377
131075           FI;FI
131075           GO FAR OUT1
131076   *)FILL
131116   INTEGER TREG,AREG,DREG
131121   TRIPLE  TADREG=TREG
131121   INTEGER POINTER LREG, FLREG
131123   INTEGER XREG
131124   INTEGER ARRAY POINTER QQIND
131125
131125
131125   % LOCAL SUBROUTINE
131125   % TRXREG=current message
131125   % TRCOPT=current sub option
131125   % TRSIZE=current size of message to log
131125
131125   FELLE:  *1BANK
131126           A:=L=:"FLREG"
131130           IF PROFLAG=0 THEN                            % LOG ALL 500 PROCESSES
131132              X:=TRXREG; T:=TRCOPT; A:=TRCSIZE
131135              CALL TRLOGG; GO FLREG                     % LOGG ROUTINE
131137           ELSE IF A=1 THEN                             % LOG 8 SPECIFIED PROCS
131143              *2BANK
131144              T:=5MBBANK
131145              *1BANK
131146              "DY1TRP"=:"QQIND"
131150              X:=TRXREG; *SENDE@3 LDATX
131152              A=:D; CALL FAR GSUBR; GO FLREG
131155              X:=TRXREG; T:=TRCOPT; A:=TRCSIZE
131160              CALL TRLOGG; GO FLREG                     % LOGG ROUTINE
131162           ELSE IF A=2 THEN                             % LOGG 8 SPEC RT-PROGRAMS
131166              *2BANK
131167              T:=5MBBANK
131170              *1BANK
131171              "DY1TRP"=:"QQIND"
131173              X:=TRXREG; *AAX XADPR; LDXTX
131176              A:=X.S1
131177              A=:D; CALL FAR GSUBR; GO FLREG             % Match ?
131202              *1BANK
131203              X:=TRXREG; T:=TRCOPT; A:=TRCSIZE
131206              CALL TRLOGG; GO FLREG                      % LOGG ROUTINE
131210           FI; FI; FI
131210           MIN "FLREG"; GO FLREG
131212   *)FILL
131222
131222           % Log all 500-processes , 8 specified processes or
131222           % 8 spec RT-programs from N500C
131222   TRN5C:  0/\0; EXIT
131224           IF T:=ACTMPERFORM=0 THEN EXIT FI
131230           TAD=:TADREG; X=:XREG; A:=L=:"LREG"
131234           *1BANK
131235           IF TRINIT=-1 THEN
131241              CALL FAR BINIT
131242           FI
131242           N5SIZE=:TRCSIZE; XREG=:TRXREG; N5COPT=:TRCOPT
131250           *2BANK
131251           T:=5MBBANK; X:=XREG; *MICFU@3 LDATX
131254           IF A=3START OR A=3TRACO THEN
131262              *AAX TRAPN; LDATX; AAX TRAPN              % D=TRAP NO
131265              *1BANK
131266              IF A=46 THEN GO FAR OUT1; FI              % PAGE FAULT TRAP
131272           FI
131272           CALL FAR FELLE; 0/\0; GO FAR OUT1
131275
131275           % Log all 500-processes , 8 specified processes or
131275           % 8 spec RT-programs from 5ACTSWAPPER
131275   TRACS:  0/\0; EXIT
131277           IF T:=ACTMPERFORM=0 THEN EXIT FI
131303           TAD=:TADREG; X=:XREG; A:=L=:"LREG"
131307           *1BANK
131310           IF TRINIT=-1 THEN
131314              CALL FAR BINIT
131315           FI
131315           ACTSIZE=:TRCSIZE; XREG=:TRXREG; ACTSCOPT=:TRCOPT
131323           *2BANK
131324
131324           CALL FAR FELLE; 0/\0; GO FAR OUT1
131327   *)FILL
131344
131344   INTEGER XTREG=?,XAREG=?,XDREG=?
131344   TRIPLE YTADREG=?
131344   INTEGER POINTER XLREG=?
131344   INTEGER XXREG=?
131344
131344   XOUT1:  "XLREG"=:L; TAD:=YTADREG; X:=XXREG
131350   XOUT:   *2BANK
131351           EXIT
131352           % Log all 500-processes , 8 specified processes or
131352           % 8 spec RT-programs from ITO500XQ
131352   TRT5X:  0/\0; EXIT
131354           IF T:=ACTMPERFORM=0 THEN EXIT FI
131360           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131364           *1BANK
131365           IF TRINIT=-1 THEN
131371              CALL FAR BINIT
131372           FI
131372           T5XQSIZE=:TRCSIZE; XXREG=:TRXREG; T5XQCOPT=:TRCOPT
131400           *2BANK
131401
131401           CALL FAR FELLE; 0/\0; GO XOUT1
131404
131404           % Log all 500-processes , 8 specified processes or
131404           % 8 spec RT-programs from IFM500XQ
131404   TRF5X:  0/\0; EXIT
131406           IF T:=ACTMPERFORM=0 THEN EXIT FI
131412           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131416           *1BANK
131417           IF TRINIT=-1 THEN
131423              CALL FAR BINIT
131424           FI
131424           F5XQSIZE=:TRCSIZE; XXREG=:TRXREG; F5XQCOPT=:TRCOPT
131432           *2BANK
131433
131433           CALL FAR FELLE; 0/\0; GO XOUT1
131436   *)FILL
131451
131451   INTEGER XTREG,XAREG,XDREG
131454   TRIPLE YTADREG=XTREG
131454   INTEGER POINTER XLREG
131455   INTEGER XXREG
131456
131456
131456
131456           % Log all 500-processes , 8 specified processes or
131456           % 8 spec RT-programs from XTER500
131456   TTER5:  0/\0; EXIT
131460           IF T:=ACTMPERFORM=0 THEN EXIT FI
131464           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131470           IF XXREG=-1 THEN GO XOUT1; FI
131475           *1BANK
131476           IF TRINIT=-1 THEN
131502              CALL FAR BINIT
131503           FI
131503           TER5SIZE=:TRCSIZE; XXREG=:TRXREG; TER5COPT=:TRCOPT
131511           *2BANK
131512
131512           CALL FAR FELLE; 0/\0; GO XOUT1
131515
131515           % Log all 500-processes , 8 specified processes or
131515           % 8 spec RT-programs from XACT500
131515   TRAC5:  0/\0; EXIT
131517           IF T:=ACTMPERFORM=0 THEN EXIT FI
131523           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131527           *1BANK
131530           IF TRINIT=-1 THEN
131534              CALL FAR BINIT
131535           FI
131535           ACTSIZE=:TRCSIZE; XXREG=:TRXREG; ACT5COPT=:TRCOPT
131543           *2BANK
131544
131544           CALL FAR FELLE; 0/\0; GO FAR XOUT1
131547
131547           % Log all 500-processes , 8 specified processes or
131547           % 8 spec RT-programs from MCCO
131547   TRMCC:  0/\0; EXIT
131551           IF T:=ACTMPERFORM=0 THEN EXIT FI
131555           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131561           *1BANK
131562           IF TRINIT=-1 THEN
131566              CALL FAR BINIT
131567           FI
131567           MCCOSIZE=:TRCSIZE; XXREG=:TRXREG; MCCOCOPT=:TRCOPT
131575           *2BANK
131576
131576           CALL FAR FELLE; 0/\0; GO FAR XOUT1
131601
131601           % Log all 500-processes , 8 specified processes or
131601           % 8 spec RT-programs from SWPDECODER
131601   TRSWP:  0/\0; EXIT
131603           IF T:=ACTMPERFORM=0 THEN EXIT FI
131607           TAD=:YTADREG; X=:XXREG; A:=L=:"XLREG"
131613           *1BANK
131614           IF TRINIT=-1 THEN
131620              CALL FAR BINIT
131621           FI
131621           SWPDSIZE=:TRCSIZE; XXREG=:TRXREG; SWPDCOPT=:TRCOPT
131627           *2BANK
131630
131630           CALL FAR FELLE; 0/\0; GO FAR XOUT1
131633   *)FILL
131653   RBUS
131653
131653   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
131653   % Primitive #77 TRACE ND 500
131653   %               LOGGING ROUTINE
131653   %
131653   SUBR TRLOGG
131653
131653   % ===================================================================
131653   %       Data definitions for trace
131653   %
131653   %         Header
131653
131653   DISP  0; INTEGER 5RIDENT          ;PSID % Currenet option code
131653   DISP  1; INTEGER 5RNEXT           ;PSID % Pointer to next record
131653   DISP  2; INTEGER 5RPR             ;PSID % ND-500 process number
131653   DISP  3; INTEGER 5RTPROC          ;PSID % RT program address
131653   DISP  4; DOUBLE  5RATIME          ;PSID % Copy of ATIME when traced
131653   %ISP  6; INTEGER size                   % Size of buffer (mess buff part + head)
131653   %ISP  7; INTEGER free                   %
131653   %ISP 10; INTEGER first free
131653   %

131653
131653
131653
131653   % ===================================================================
131653   %   T R L O G G   -   Reserve space in trace buffer
131653   %                     and initialize header
131653   %                       NB!  The whole trace buffer must be traced
131653   %                            within a IOF sequence.
131653   %
131653   %       Input:   A - Size    (total)
131653   %                X - Message buffer address
131653   %                T - Current option code
131653   %
131653   %  Skip Return:  OK   Trace done
131653   %
131653   %  Norm Return:  Trace not done
131653   %
131653
131653   SYMBOL XADRPROC=144
131653   INTEGER SIZ=?                      % Size of current trace rec. data(-head)
131653   INTEGER IMESS=?                    % Current message buffer address
131653   INTEGER ITYPE=?                    % Trace record type option code
131653   INTEGER ICURR=?                    % First free pointer ( in record)
131653   INTEGER 5TRECORD=?                 % Current record pointer
131653   INTEGER TSAVL=?
131653   INTEGER SAVL=?
131653
131653
131653   TRLOGG:
131653         SPACE(A)=:SIZ
131656         T=:ITYPE; X=:IMESS; A:=L=:TSAVL
131662   % -----------------------------------------------
131662   %     Find area for record        (limited to one bank)
131662         5TPT2=:D+SIZ=:5TPT2
131666         IF C OR A >= 5TEN2 THEN
131673             5TADDRESS=:D+SIZ =: 5TPT2
131677             5TSTATUS BONE 5RWRAP =: 5TSTATUS   % Wrap around
131702             A:=5TADDRESS; X:=5TREC; T:=5TBANK
131705             *STATX 10                          % Prev record.next=start
131706         FI
131706         A:=D=:5TRECORD
131710
131710   % -----------------------------------------------
131710   %     Find next old ok buffer pointer
131710         IF 5TSTATUS NBIT 5RWRAP THEN   % Not wrap around
131713            5TADDRESS=:5OKPT            % First OK buffer
131715            GO HEAD
131716         FI
131716   NEW:  IF 5OKPT >= 5TPT2 OR 5OKPT = 5TADD AND 5TREC >< 5TADD THEN
131732            GO HEAD
131733         FI
131733         X:=5OKPT; T:=5TBANK; *LDATX 10
131736         A=:5OKPT; GO NEW
131740   % -----------------------------------------------
131740   %     Make HEAD part
131740
131740   HEAD: *2BANK
131741         T:=5MBBANK; X:=IMESS; *SENDE@3 LDATX
131744         A=:D; *AAX XADRP; LDXTX
131747         A:=X.S1
131750         *1BANK
131751         T:= 5TPT1; X:= 5TRECORD
131753         *STATX 30                       % rt prog
131754         A:=D; *STATX 20                 % proc no
131756         ITYPE; *STATX                   % record id
131760         5TRECORD+SIZ;  *STATX 10       % next
131763         AD:=ATIME ; *STDTX 40            % atime
131765         5TRECORD+6=:ICURR
131770         A:=SIZ; CALL SAVEMESSAGE; 0/\0
131773         *1BANK
131774         T:=TSAVL=:L; EXIT
131777
131777
131777
131777   % -------------------------------------------
131777   %       Local data for trace routines
131777
131777   INTEGER SIZ                       % Size of current trace rec. data(-head)
132000   INTEGER IMESS                      % Current message buffer address
132001   INTEGER ITYPE                      % Trace record type current option code
132002   INTEGER ICURR                      % First free pointer ( in record)
132003   INTEGER 5TRECORD                   % Current record pointer
132004   INTEGER TSAVL                      % L in TRLOGG
132005   INTEGER SAVL                       % L in SAVEMESAGE
132006   INTEGER TEMP,TEMP2
132010           DOUBLE TEMPD=TEMP
132010   *)FILL
132023
132023   % ====================================================
132023   %     SAVEMESSAGE
132023   %
132023   %     INPUT: A - Message buffer part choice
132023   %
132023   %                0 : (0:37)
132023   %                1 : (0:37)+(100:146)
132023   %                2 : (0:146)
132023   %                3 : (-30:146)
132023   %
132023
132023
132023   SAVEMESSAGE:
132023         IF A>>3 THEN EXIT FI
132027         A=:TEMP
132030         IF SPACE(A) > SIZ THEN EXIT FI       % Room?
132036         IF ICURR-5TRECORD >= 10 THEN EXIT FI
132044         A:=L=:SAVL
132046         TEMP; CALL STOR2; GO NOSAVE           % TYPE
132051   % ------------------------------
132051   %       First block
132051
132051         A:=5TTRA(TEMP)=:L                     % LENGTH
132054         IMESS-5XSTA(X)=:D; *2BANK
132060         A:=5MBBANK; *1BANK                    % SOURCE
132062         X:=5TPT1; T:=5TRECORD+10              % DESTINATION
132065         *MOVPP
132066   % ------------------------------
132066   %       Second ?
132066         IF TEMP-1 = 0 THEN
132071             A:=50=:L
132073             IMESS+100=:D; *2BANK
132077             A:=5MBBANK; *1BANK
132101             *MOVPP
132102         FI
132102         T=: ICURR
132103         *MIN SAVL
132104   NOSAVE:
132104         T:=SAVL=:L
132106         EXIT
132107
132107   % =================================================
132107   %     STOR2      Store 16 bits word in trace
132107   %
132107   %     INPUT:
132107   %            A = DATA
132107   %
132107   %     RETURN: No trace done
132107   %
132107   % SKIPRETURN: OK
132107
132107   STOR2:
132107           A=: TEMP
132110           T:=5TPT1; X:=5TRECORD; *LDATX 10    % NEXT
132113           IF X:=ICURR >= A THEN EXIT FI
132117           TEMP; *STATX
132121           *MIN ICURR
132122           EXITA
132123
132123
132123   % =================================================
132123   %     STOR4      Store 32 bits word in trace
132123   %
132123   %     INPUT:
132123   %            AD = DATA
132123   %
132123   %     RETURN: No trace done
132123   %
132123   % SKIPRETURN: OK
132123
132123   STOR4:
132123           AD=: TEMPD
132124           T:=5TPT1; X:=5TRECORD; *LDATX 10    % NEXT
132127           IF X:=ICURR >= A THEN EXIT FI
132133           TEMPD; *STDTX
132135           ICURR+2=:ICURR
132140           EXITA
132141   RBUS
132147
132147
132147   *"-8MPRF 8N500
"132147
132147   @DEV 1
132147   @DEV (S-S-L)MP-P2-N500:NPL
132147   *"8N500
"132147   %==========================================================================
132147   %
132147   %       C X - M P I T - N 5 0 0
132147   %
132147   %==========================================================================
132147   %--------------------------------------------------------------------------
132147   %      ( C )    5 R R T W T    5 X A C T R T   5 S W A C T R T
132147   %
132147   % ROUTINE TO REMOVE MESSAGE FROM EXECUTION QUEUE
132147   % AND RESTART ND-500 SHADOW PROGRAM IN ND-100.
132147   %
132147   % WHEN CALLED FROM OTHER LEVELS THAN THE DRIVER LEVEL
132147   % THESE ROUTINES MUST BE CALLED WITH INTERRUPT OFF.
132147   %
132147   % ENTRY:     X=ACTUAL MESSAGE
132147   %
132147   % EXIT:      T,A,D REGISTERS DESTROYED
132147   %
132147   SUBR 5RRTWT,5XACTRT,5SWACTRT
132147   INTEGER POINTER LREG,LRG
132151   INTEGER CMESS
132152   5RRTWT: A:=L=:"LREG"=:"LRG"
132155          T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
132161          IF A BIT 5SYSRES THEN
132163             *SENDE@3 LDDTX
132164             IF A=D THEN EPFINSWAP; CALL XRSTARTALL; GO LRG FI
132171          FI
132171          CALL SLOCK; 0/\0
132173          CALL IFM500XQ                                 % REMOVE MESSAGE FROM EX-QUEUE
132174          CALL SUNLOCK
132175   ACTRT: IF X><-1 THEN
132200             T:=5MBBANK; *SENDE@3 LDATX
132202             IF A+1=0 GO LREG                           % HISTOGRAM/WATCHDOG MESSAGE
132205             X=:CMESS; *AAX XADPR; LDXTX                % X=PROCESS DESCRIPTION
132210   ACT5SWAP: X.PSTAT BONE F5BUFF BZERO T5BUFF=:X.PSTAT  % MARK THAT PROCESS IS RESTARTED BY THE DRIVER
132214             X:=:B
132215             *TRA STS
132216             IF A NBIT 17 THEN CALL XRTACT ELSE CALL RTACT FI  % INTERRUPT OFF OR ON?
132223             X:=:B:=CMESS
132225          FI; GO LREG
132226
132226   5XACTRT:  A:=L=:"LREG"; GO ACTRT                      % MESSAGE OF PROCESS TO RESTART, NOT IN EX-QUEUE
132231   5SWACTRT: A:=L=:"LREG"; X:="S500S"; GO ACT5SWAP       % START 5SWAP
132235
132235   RBUS
132246
132246   %============================================================================
132246   %      ( M )    E S C 5 0 0   -    S Y S A B O R T
132246   %
132246   % ENTRY: X=ADDR OF INPUT DATAFIELD
132246   % MONITOR LEVEL
132246   %
132246   SUBR ESC500,SYSABORT
132246   INTEGER POINTER HASSWAP:=CLFIE+1                     % CLFIE.RTRES (SWAPPING PROGRAM)
132247   INTEGER POINTER ESCLL
132250   ESC500: A:=L=:"ESCLL"
132252          T:="DBPROG"; X:=B; CALL XGTDFADDR             % GET BACKGROUND PROGRAM
132255          A=:D; CALL FSEMA; GO ESCLL                    % FIND PROCESS DESCRIPTION
132260          *IOF                                          % X=PROCESS DESCRIPTION
132261          CALL SLOCK; 0/\0
132263          T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
132267          A BONE 52ESCSET; *STATX
132271          IF A BIT 5IBRK THEN                           % ALREADY IN ESCAPE OR CLEAN-UP SEQUENCE
132273             CALL SUNLOCK; GO MONEN
132275          FI
132275          A BONE 5IBRK; *STATX
132277          CALL SUNLOCK
132300          "IORESTART"=:MFUNC; *ION
132303          X:=RTRES; CALL S5ESCF
132305          IF X:=RTRES><0 THEN
132307             IF X.TLINK><0 THEN CALL FTIMQU FI
132312             IF X=CURPROG THEN
132315                "FROMESC"; *IRW ALEVB DP                % FORCE PROGR TO START IN FROMESC
132317                "N5PIT+ADPIT+ALEVB+ERNG2"
132320                A=:X.ACTPRI; *TRR PCR                   % FROMESC IS ON 5PIT
132322             ELSE                                       % NOT CURRENTLY ACTIVE PROGRAM
132323   SYSABORT:    CALL MRLCLFIE; CALL FRWQU; CALL TOEXQU
132326                IF HASSWAP >< X THEN                    % IF PROGRAM IS NOT SWAPPING THEN
132331                    X.STATUS BZERO 5WAIT=:X.STATUS          % RESET I/O-WAIT STATE
132334                FI
132334                "N5PIT+ADPIT+ALEVB+ERNG2"=:X.ACTPRI     % SET NEW PCR, NPT=5PIT, APT=DPIT
132336                X:=X.RTDLGADDR                          % REGISTER BLOCK PART OF RT-DESCRIPTION
132337                T:=0                                    % BANK NO OF SAME
132340                "FROMESC"                               % START HERE ON APPLICATION LEVEL
132341                *DPREG@3 STATX                          % ADDR OF FROMESC INTO P OF PROGRAM
132342                1=:MTOR                                 % MAKE SURE MONEN SEARCHES EXECUTION QUEUE
132344             FI
132344          FI; GO MONEN
132345   RBUS
132366
132366
132366   %==========================================================================
132366   %            R L 5 P D E S C   -   1 R L 5 P D E S C
132366   %
132366   % RELEASE THE ND-500 PROCESS DESCRIPTION AFTER THE ND-500 PROCESS HAS BEEN
132366   % TERMINATED. THIS IS CALLED WHEN AN ERROR IS DETECTED BY SINTRAN III MONITOR
132366   % (IN MON.CALL ETC...)
132366   %
132366   % EXECUTED ON MONITOR LEVEL
132366   %
132366   % ENTRY: T=MONITOR LEVEL ROUTINE TO EXECUTE AFTER THE PROCESS IS TERMINATED.
132366   %        X=RT-DESCRIPTION ADDR. (WHEN RL5PDESC)
132366   %
132366   % RETURN: TO STUPR IF THE PROGRAM HAS RESERVED AN ND-500 PROC. ELSE EXIT
132366   %
132366   SUBR RL5PDESC,1RL5PDESC
132366   INTEGER POINTER RL5RL
132367   INTEGER MLVPADDR
132370   1RL5PDESC: X:=RTREF
132371   RL5PDESC: A:=L=:"RL5RL"; T=:MLVPADDR
132374          X=:D; CALL FSEMA; GO RL5OUT               % ANY ND-500 PROCS. RESERVED?
132377          X:=D; CALL MRLCLFIE                       % YES, REMOVE PROGRAM FROM ND-100 SWAPPING QUEUE
132401          CALL FRWQU; CALL TOEXQU                   % SET PROGR IN EX-QUEUE
132403          X.STATUS BZERO 5WAIT=:X.STATUS            % RESET I/O-WAIT BIT
132406          IF A BIT 5BACKR THEN
132410             AD:=X.DSEGM                            % BACKGR: ORIGNIAL SEGMENTS
132411          ELSE
132412             A:=0; D:=0                             % RT-PROG.: NO SEGMENT INCASE OF "OUTSIDE SEGM. BOUDS" ETC
132414          FI; AD=:X.DACTSEG
132415          "N5PIT+ADPIT+ALEVB+ERNG2"=:X.ACTPRI
132417          X=:D
132420          "ERABORT"; X:=X.RTDLGADDR; T:=0
132423          *DPREG@3 STATX                            % UPDATE PROGR'S P-REG  ( IN CASE NOT CURPROG)
132424          MLVPADDR; *DBREG@3 STATX                  % UPDATE PROGR'S B-REG
132426          IF X:=D=CURPROG THEN                      % IS THE ACTUAL PROGRAM CURRENT-RUNNING PROGR?
132432             "N5PIT+ADPIT+ALEVB+ERNG2"
132433             *TRR PCR                               % YES, SET PCR FOR PROGR
132434             "ERABORT"; *IRW ALEVB DP               % FORCE START IN ERABORT LEV 1
132436             MLVPADDR;  *IRW ALEVB DB
132440          FI; GO STUPR
132441   RL5OUT: X:=D; GO RL5RL
132443   RBUS
132454
132454
132454   %===========================================================================
132454   %        ( M )      R T B A K   -   A P L R S T A R T
132454   %
132454   % MONITOR LEVEL ROUTINE TO REMOVE ND-100 PROGRAM FROM I/O-WAIT
132454   %
132454   % ENTRY:     X=PROCESS DESCRIPTION
132454   %
132454   SUBR RTBAK,APLRSTART,5FRTBAK
132454   INTEGER ROUTSWITCH
132455   INTEGER 15PHYB,25PHYB; DOUBLE C5PHYB=15PHYB
132457   INTEGER CMAILB
132460   5FRTBAK: 1=:ROUTSWITCH
132462          "RTBAK"=:X.MFUNC
132464          GO L1
132465   RTBAK: 0=:ROUTSWITCH
132466   L1:    X=:B
132467          IF X:=RTRES><0 THEN
132471             IF X.WLINK = 0 THEN
132473                CALL FTIMQU; CALL TOEXQ; GO INRTBAK
132476             FI
132476             *IOF                              % PROTECT PSTAT
132477             IF PSTAT BIT 5REWA THEN
132502                A BZERO 5REWA=:PSTAT
132504   INRTBAK:     X.STATUS BZERO 5WAIT=:X.STATUS
132507                IF ROUTSWITCH><0 THEN
132511                   % Reserve 500-file-transfer-buffer-header
132511                   IF X:=5DVBFREE><0 THEN
132513   NYTRY:             X.RESLINK=:5DVBFREE; 0=:X.RESLINK
132516                      X.MESSBUFF=:CMAILB; A:=RTRES
132521                      X=:B:=A; CALL BRESERVE
132524                      IF A<0 THEN CALL ERRFATAL FI
132526                      T:=5MBBANK; X:=CMAILB; *AAX 5PHYB; LDDTX
132532                      AD SHZ -1=:C5PHYB
132534                      A:="N500DF".ADRZERO=:D:=0; AD SH 12
132541                      A:=:D+25PHYB:=D; A:=A+C+15PHYB
132546                      AD=:DBPAG
132547                   ELSE
132550                      X:=5DVBSTART
132551                      DO WHILE X<<5DVBEND
132554                         IF X.RTRES=0 THEN
132556                            5DVBFREE=:X.RESLINK; X=:5DVBFREE
132561                         FI; X+DBLEN
132562                      OD
132563                      IF X:=5DVBFREE><0 GO NYTRY
132566                      X:=RTRES
132567                      5DVBWAIT=:B
132571                      CALL FREXQU; CALL TOWQU
132573                   FI
132573                FI
132573             FI; 1=:MTOR
132575          FI; GO MONEN
132576
132576   %
132576   % MONITOR LEVEL ROUTINE TO ACTIVATE ND-100 APPLICATION
132576   % WAITING FOR SIBAS IN ND-500
132576   %
132576   APLRSTART: 0=:ROUTSWITCH
132577              X=:B; IF X:=RTRES><0 GO INRTBAK
132603              GO MONEN
132604   RBUS
132623
132623
132623   %=============================================================================
132623   %        ( M )       5 0 0 H I S T
132623   %
132623   % L e v e l   2   routine called each basic time unit
132623   %
132623   % Called from ICLCK
132623   % Called in iof and return in iof, but have ion sequences inside
132623   % the routine.
132623   % All registers are destroyed.
132623   %
132623   SUBR 500HIST
132623
132623   SYMBOL LIDLE=2               % Process is idle
132623   SYMBOL LSWPWAIT=4            % Process is waiting for swapper
132623   SYMBOL LSWPPING=6            % Process is using swapper
132623   SYMBOL LINMCALL=10           % Process is executing mon.call
132623   SYMBOL LACTIVE=12            % Process is active
132623   SYMBOL LCPU=14               % Process is waiting for nd-500 cpu (in ex-queue)
132623
132623   INTEGER POINTER LREG
132624
132624   500HIST:
132624          IF 5MSINIT NBIT 5INBUF THEN EXIT FI
132630          IF "N500DF".SYSINITFLAG BIT B5STOP THEN EXIT FI
132635          A:=L=:"LREG"
132637          A:=0; X:="S5CPUDF"
132641          DO WHILE X<<="E5CPUDF"; A\/X.C5STAT; X+5CPUDFSIZE; OD
132647          IF A/\C5PFMASK><0 THEN EXIT FI            % Anything concerning powerfail ?
132652          AD:=ATIME=:"N500DF".5ATIME                % Copy atime to nd-500 system datafield
132655          DO
132655             "N500DF"=:B
132657             X:=X500DF; T:=5MBBANK; *AAX X5BTI; LDDTX
132663          WHILE D><-1                               % Search time queue and start procs.
132666   *NNC05,   CNVBYADR
132671             T:=A; X:=D; *AAX D5TIM; LDDTX; AAX -D5TIM
132676             A=:L:=5ATM2-D:=5ATM1; *RADD ADC CM1 SL DA
132703          WHILE A>=0                                % Until no more procs to start
132704             CALL SLOCK; 0/\0
132706             CALL GCPUDF; CALL ERRFATAL; A=:B
132711   *NNT02=*
132711             CALL XTER500; 0/\0                      % No, stop it
132713             CALL FR5TMQU
132714             A:=0; CALL SPITMQ
132716             CALL ITO500XQ                          % Restart process after mon 5tmout
132717             CALL SUNLOCK
132720             CALL XACTRDY
132721             CPUAVAILABLE BONE LV2ACT=:CPUAVAILABLE
132724          OD
132725          "S5CPUDF"=:B
132727          DO WHILE B<<="E5CPUDF"
132732             IF CPUAVAILABLE BIT LV2ACT THEN
132735                A BZERO LV2ACT=:CPUAVAILABLE
132737                CALL LOWACT500
132740                *ION; IOF
132742             FI
132742             B+5CPUDFSZ
132743          OD
132744          *ION; IOF
132746          GO FAR 500H2; *)FILL
132772
132772   5HIRET: CALL P67L2                               % Performance logging
132773           GO LREG                                   % Return to ICLCK
132774
132774
132774   % Local subroutine to test if nd-500 active
132774   500HA: IF B<<"S5CPUDF" OR B>>"E5CPUDF" THEN EXIT FI
133003          IF CPUAVAILABLE/\5CPUTYPE><SAMSON THEN    % DMA interface?
133010             T:=HDEV+RSTA5; *IOXT
133013             IF A NBIT 5ILOCK OR A BIT 5POWOF THEN EXIT FI
133020          FI
133020          EXITA
133021
133021
133021   500H2: A:="S5CPUDF"=:B
133023          DO WHILE B <<= "E5CPUDF"
133026             IF CPUAVAILABLE BIT 5ALIVE AND MAILINK><-1 THEN  % Nd-500 cpu present?
133035                CALL 500HA; GO 500H3                % Yes, running ?
133037                CALL GETC5PROC                      % Get current active process
133040                IF A >= 5SWPROC THEN                % Any active process in this nd-500?
133043                   A-5SWPROC*5PRDSIZE+"S500S"       % Yes
133046                   X:=A.MESSBUFF; T:=5MBBANK
133051                   *AAX 500TU; LDDTX                % Increment nd-500 cpu time used
133053                   D+1; A:=A+C; *STDTX              % For current active process
133056                FI
133056   500H3:       IF 5HIFLAG=3 THEN                   % Process-logg-all
133062   %               IF B = "S5CPUDF" THEN
133062                      MIN "5HIDATA".S5; P+1; MIN X.S4; 0/\0    % Increment number of samples
133067                      X:=SWMSG; CALL RN5STATUS                 % A:=swmsg.n5status
133071                      IF A><PSWWAIT THEN                       % Swapper active?
133074                         MIN "5HIDATA".S1; P+1; MIN X.S0; 0/\0 % Yes, increment swapper-active counter
133101   %                  FI
133101                   FI
133101                   CALL GETC5PROC
133102                   IF A>=5SWPROC THEN               % Any active process in this nd-500?
133105                      A SH 1+"5HIDATA"+6=:X         % Yes
133111                      MIN X.S1; P+1; MIN X.S0; 0/\0 % Inrement "current active" counter for this proc.
133115                   FI
133115                FI
133115             FI; B+5CPUDFSZ
133116          OD
133117          IF 5HRTP=0 OR 5HIFLAG=0 GO FAR 5HIRET     % Histogram/proc-log-one defined and started?
133124          IF 5HIFLAG=1 THEN                         % Histogram
133130             X:=HIMESS; CALL RN5STATUS
133132             IF A<<=ANSWER THEN                     % Should histogram message be restarted?
133135                T:=5MBBANK; *AAX WANTP; LDATX       % May be
133140                A-5SWPROC*5PRDSIZE+"S500S"=:X       % Calculate addr of process description
133144                IF X.PSTAT/\5RUNSTATUS=5ACTIVE THEN % Is process to do histogram on active?
133151                   X:=HIMESS; CALL GCPUDF; CALL ERRFATAL
133154                   A=:B; CALL 500HA; GO FAR 5HIRET  % ND-500 running ?
133157                   A:=MSGN500; X:=HIMESS; CALL WN5STATUS  % Yes
133162                   CALL XACTRDY
133163                   CALL LOWACT500
133164                FI
133164             FI; GO FAR 5HIRET; *)FILL
133212          FI
133212          IF A=2 THEN                               % Process-logg-one
133215             5LOGPROC-5SWPROC*5PRDSIZE+"S500S"
133221             X:=A.MESSBUFF; CALL GCPUDF; GO 500H4
133225             A=:B; CALL FAR 500HA; GO FAR 5HIRET    % ND-500 running ?
133230             MIN "5HIDATA".S1; P+1; MIN X.S0; 0/\0  % Incremnt total number of samples counter
133235             CALL GETC5PROC
133236             IF A=5LOGPROC THEN                     % Is process to be logged active?
133241                LACTIVE;                              % Yes
133242             ELSE
133243                5LOGPROC-5SWPROC*5PRDSIZE+"S500S"
133247                IF A.RTRES=0 OR X.PSTAT/\5RUNSTATUS>< 5ACTIVE AND A><5INMCALL THEN
133262   500H4:          LIDLE                            % Process is idle
133263                ELSE
133264                   X:=X.MESSBUFF; CALL RN5STATUS
133266                   IF A=SWPWAIT THEN
133271                      LSWPWAIT                      % Waiting for swapper
133272                   ELSE
133273                      IF A=SWPPING THEN
133276                         LSWPPING                   % Using the swapper
133277                      ELSE
133300                         T:=5MBBANK; *AAX XADPR; LDATX
133303                         IF A.PSTAT/\5RUNSTATUS=5ACTIVE THEN
133311                            LCPU                    % Waiting for nd-500 cpu (in exqueue)
133312                         ELSE
133313                            IF A=5INMCALL THEN
133316                               LINMCALL             % Monitor call processing
133317                            ELSE LIDLE              % Rest counts as idle
133321             FI FI FI FI FI FI
133321             X:="5HIDATA"+A
133323             MIN X.S1; P+1; MIN X.S0; 0/\0          % Increment counter according to process status
133327          FI; GO FAR 5HIRET
133330   RBUS
133344
133344
133344   %=============================================================================
133344   %        ( M )     N 5 0 0 C
133344   %=============================================================================
133344   %
133344   % L e v e l   2   (monitor level) routine to execute commands to nd-500
133344   %
133344   % Entry:     X=process description
133344   %
133344   % Returns to MONEN/STUPR
133344   %
133344   SUBR N500C
133344   INTEGER CCN5ST
133345   N500C: X:=X.MESSBUFF=:5MMESSAGE                           % SAVE CURRENT MESSAGE ADDR
133347          CALL GCPUDF; CALL ERRFATAL; A=:B
133352          IF CPUAVAILABLE NBIT 5ALIVE GO FAR EN5TIMOUT
133355          CALL RN5STATUS
133356          A=:CCN5ST                                           % MESSAGE STATUS
133357          IF A/\160000><0 THEN                                % SOMETHING ABOUT POWER FAIL
133361             IF A BIT POWDET THEN                             % POWER FAIL DETECTED?
133363                *IOF                                          % YES, GIVE ALL ACTIVE
133364                C5STAT BONE BHPFAIL=:C5STAT                   % PROCESSES THE MESSAGE:
133367                CCN5ST/\17777; CALL WN5STATUS                 % "POWER DOWN"
133372                CALL SLOCK; 0/\0; CALL ITO500XQ; CALL SUNLOCK
133376                KPOWDOWN; CALL XRSTARTALL
133400             ELSE
133401                IF A BIT POWUP AND C5STAT NBIT BHPFAIL GO FAR RESENT % RESTART PROC. WIRH "POWER UP" MESSAGE
133406                CALL SLOCK; 0/\0; CALL ITO500XQ; CALL SUNLOCK
133412                TTMR=:TMR
133414             FI; GO MONEN
133415          FI
133415          IF CCN5ST><MSGN500 AND A><WAITING GO FAR TOQUEUE
133424          T:=5MBBANK; *MICFU@3 LDATX
133426          A=:D; X:=SWMSG; *AAX 5MSFL; LDATX; AAX -5MSFL
133433          IF A BIT 5IEXQUEUE AND D=3SWMESS THEN
133440             IF FERROR=N5STOPPED GO FAR XEILSTAT
133444             CALL GCPUDF; CALL ERRFATAL
133446             IF A.FERROR><0 GO FAR XEILSTAT
133452          ELSE
133453             IF FERROR><0 GO FAR XEILSTAT                      % ND-500 FATAL ERROR
133456          FI
133456          T:=5MBBANK; X:=5MMESSAGE; *MICFU@3 LDATX
133461          IF A>>5MFMAX GO FAR MILLFU                           % ILLEGAL ND-500 MICRO.PROGRAM COMMAND (FUNCTION)
133464          GO N5XXC
133465   *)FILL
133512   @ICR
133512   N5XXC: A GOSW                                               % GO TO ROUTINE ACCORDING TO MIC.FUNC.
133512             STUPR,       RMICVE,    FAR MILLFU,  FAR MILLFU,  % 00-03
133517             FAR MILLFU,  SWMESS,    EXAMD,       DEPMD,       % 04-07
133523             RMEMD,       WMEMD,     CACHE,       RAMED,       % 10-13
133527             WAMED,       FAR RNEWCO,EXARG,       DEPRG,       % 14-17
133533             REREG,       WRREG,     FAR P0START, FAR STAOPP,  % 20-23
133537             FAR MONCO,   FAR MTRACO,FAR WMONCO,  FAR 5RLBH,   % 24-27
133543             MPHSREAD,    MPHSWRITE, EXAMP,       DEPMP,       % 30-33
133547             RMEMP,       WMEMP,     FAR FQUEUE,  RAMEP,       % 34-37
133553             WAMEP,       RLIMI,     PRTRAP,      WLIMI,       % 40-43
133557             FAR MILLFU,  MPCLR,     FAR MILLFU,  FAR MILLFU,  % 44-47
133563             FAR MILLFU,  FAR MILLFU,FAR NKREL,   FAR MILLFU,  % 50-53
133567             FAR MILLFU,  FAR MILLFU,FAR MILLFU,  FAR MILLFU,  % 54-57
133573             CLRPROC,     FAR MILLFU,FAR MILLFU,  FAR MILLFU,  % 60-63
133577             FAR MILLFU,  FAR MILLFU,FAR MILLFU,  FAR MILLFU,  % 64-67
133603             TRC70,       TRC71,     TRC72,       TRC73,       % 70-73
133607             TRC74,       TRC75,     SCACHEMODE,  RSCRREG;     % 74-77
133613   @CR;
133613   *)FILL
133626
133626
133626   RMICVE:;  WAMED:;  RAMED:;  EXARG:;  DEPRG:;  REREG:;  RLIMI:
133626   WLIMI:;   WRREG:;  EXAMP:;  DEPMP:;  RMEMP:;  WMEMP:;  PRTRAP:
133626   WAMEP:;   RAMEP:;  EXAMD:;  DEPMD:;  RMEMD:;  WMEMD:;  CACHE:
133626   MPHSREAD:; MPHSWRITE:; CLRPROC:; MPCLR:
133626   TRC70:;   TRC71:;  TRC72:;  TRC73:;  TRC74:;  TRC75:; SCACHEMODE:; RSCRREG:
133626
133626          IF TMR << TTMR THEN A:=T FI
133633          A=:TMR                                              % SET TIMER
133634          GO FAR TOQUEUE                                      % INSET MESSAGE IN EX-QUEUE
133635
133635
133635   % MESSAGE TO SWAPPER
133635   INTEGER CCKFLIP=?
133635   INTEGER CC5CPUDF=?
133635   SWMESS:
133635          IF 5INITFLAG BIT BRESPLACE GO FAR EEIRESPL          % Illegal when in resident-place
133640          T:=5MBBANK; *SWFUN@3 LDATX                          % A:=X.SWFUNC
133642          IF A=MSWSTART THEN                                  % Start swapper
133645             SWPPING; CALL WN5STATUS                           % Set process in "using Swapper" state
133647             A:=5MBBANK; D:=X
133651   *NNC06,   CNVWADR                                           % Convert multi-port adress
133654             X:=SWMSG; T:=5MBBANK; *AAX HSWPI; STDTX; AAX -HSWPI        % MMESSAGE=:SWMSG.SWPINFO
133661             3START; *MICFU@3 STATX
133663             5SWPROC; *SENDE@3 STATX; 5RECE@3 STATX
133666             SWACTIVE; *AAX SWPFU; STATX
133671             A:=300; *AAX 5PRIO-SWPFU; STATX                  % Set priority = 300
133674             CPUNO; *AAX 5CPUN-5PRIO; STATX
133677             X:=5MMESSAGE; *AAX 5MSFL; LDATX; 5SCPU@3 BLDA DA
133703             X:=SWMSG; *AAX 5MSFL; LDATX; 5CPUB@3 BSTA DA; STATX
133710             X:=SWMSG; MSGN500; CALL WN5STATUS
133713             *AAX XADPR; LDXTX
133715             X.PSTAT BZERO SLICE=:X.PSTAT                     % Swapper is not timesliced
133720             A:=B
133721             IF X:="5SWAP"=CURPROG THEN
133725                *IRW ALEVB DB
133726             ELSE
133727                T:=0; X:=X.RTDLGADDR; *DBREG@3 STATX
133732             FI
133732             *IOF
133733             X:=SWMSG
133734             CALL SLOCK; GO FAR N500ERR
133736   *NNT03=*
133736             CALL XTER500; GO FAR N500ERR                      % Stop nd-500
133740             CALL ITO500XQ; CALL SUNLOCK                      % Insert swapper-mess. in ex-queue
133742   SWME1:    CALL XACTRDY
133743             CALL LOWACT500; LTTMR=:TMR                       % Reactivate nd-500
133746             *ION
133747             X:=5MMESSAGE; ANSWER; GO FAR XEILSTAT            % Restart proc. that started the swapper
133752             *)FILL
133775          FI
133775          IF A=MSWSWAIT THEN                                  % Restart Swapper and wait (after allocate page..)
134000             X:=SWMSG; T:=5MBBANK; *AAX HSWPI; LDDTX          % A:=SWMSG.SWPINFO
134004             IF D><-1 THEN
134007   *NNC07,      CNVBYADR
134012             FI
134012             IF D><X:=5MMESSAGE GO FAR EIL5STAT
134015             *IOF
134016             T:=5MBBANK; *AAX SKFLI; LDATX; AAX -SKFLI
134022             IF A=:CCKFLIP=0 THEN                             % NO ERRORS
134024                L:=0; *AAX PRET2; LDATX
134027                IF A><0 THEN                                  % RETURN VALUE IN 2ND PAR.
134030                   L BONE 1; *AAX RETP2-PRET2; LDDTX
134033                   X:=SWMSG; *AAX RETP2; STDTX
134036                FI; X:=5MMESSAGE; *AAX PRET4; LDATX
134041                IF A><0 THEN                                  % RETURN VALUE IN 4TH PAR
134042                   L BONE 3; *AAX RETP4-PRET4; LDDTX
134045                   X:=SWMSG; *AAX RETP4; STDTX
134050                FI; X:=5MMESSAGE; *AAX PRET5; LDATX
134053                IF A><0 THEN                                  % RETURN VALUE IN 5TH PAR
134054                   L BONE 4; *AAX RETP5-PRET5; LDDTX
134057                   X:=SWMSG; *AAX RETP5; STDTX
134062                FI; X:=5MMESSAGE; *AAX PRET6; LDATX
134065               IF A><0 THEN                                   % RETURN VALUE IN 6TH PAR
134066                   L BONE 5; *AAX RETP6-PRET6; LDDTX
134071                   X:=SWMSG; *AAX RETP6; STDTX
134074                FI; X:=SWMSG; A:=L; *AAX NUMPA; STATX
134100             FI
134100             X:=5MMESSAGE; *AAX OLDMI; LDATX; AAX -OLDMI; MICFU@3 STATX
134105             CALL SLOCK; GO FAR N500ERR
134107             SWPPING; CALL WN5STATUS
134111   *NNT04=*
134111             CALL XTER500; GO FAR N500ERR
134113             CALL ITO500XQ; CALL SUNLOCK
134115             X:=SWMSG; CALL GCPUDF; CALL ERRFATAL; A=:CC5CPUDF
134121             IF A><B THEN CALL LOWACT500; TTMR=:TMR FI
134126             CC5CPUDF=:B
134130             X:=5MMESSAGE; T:=5MBBANK; *AAX SWRST; LDATX
134134             X:=SWMSG; A=:D:=0; *AAX FUNCV; STDTX
134141             CCKFLIP; *AAX KFLIP-FUNCV; STATX; AAX -KFLIP
134145             3MONCO; *MICFU@3 STATX
134147             CALL MCCO
134150             CALL XACTRDY                                    % Reactivate nd-500 with "swapper message"
134151             CALL LOWACT500
134152             GO MONEN
134153          FI
134153          *IOF
134154          CALL 5ACTSWAPPER
134155          GO TRACO
134156
134156   INTEGER CCKFLIP
134157   INTEGER CC5CPUDF
134160   *)FILL
134202
134202   WMONCO:
134202   MONCO:   X=:L; T:=5MBBANK; *AAX XADPR; LDXTX
134206            IF X.PSTAT BIT 5LTSLPRI AND A BIT SLICE THEN
134213               X:=X.MESSBUFF; *AAX 5PRIO; LDDTX               % A=5PRIO; D=HTSLLOWPRI
134216               IF A<D THEN
134220                  A+1; *STATX                                 % INCREMENT 5PRIOR
134222               FI
134222            FI; X:=L
134223   STAOPP:
134223   MTRACO:
134223   TRACO:
134223            LTTMR=:TMR
134225   TOQUEUE: *IOF
134226            CALL SLOCK; GO N500ERR
134230   *NNT05=*
134230            CALL XTER500; GO N500ERR
134232            CALL ITO500XQ; CALL SUNLOCK
134234            CALL XACTRDY                                     % Reactivate nd-500 with "swapper message"
134235            CALL LOWACT500
134236            GO MONEN
134237   *)FILL
134247
134247   N500ERR: *IOF
134250          CALL WN5STATUS; CALL XRSTARTALL
134252          X:=5MMESSAGE; T:=5MBBANK; *AAX XADPR; LDXTX
134256          X.PSTAT BZERO T5BUFF BONE F5BUFF=:X.PSTAT  % MARK MESSAGE FROM ND-500
134262          GO MONEN
134263
134263   EN5TIMOUT: N5TIMOUT; GO XEILSTAT
134265   EEIRESPL: EIRESPL; GO XEILSTAT                   % ERROR IN RESIDENT-PLACE
134267   MILLFU:   ILMICFUNC; GO XEILSTAT                 % ILLEGAL MICROPROGRAM FUNCTION
134271   EIL5STAT: ILN5STATUS                             % ILLEGAL N500 ANSWER
134272   XEILSTAT: X:=5MMESSAGE; CALL WN5STATUS
134274
134274   % RESTART ND-100 PROCESS
134274   RESENT: *IOF
134275           IF X><-1 THEN                            % X=MESSAGE ADDR
134300              T:=5MBBANK; *SENDE@3 LDATX
134302              IF A<<=MX5PROCS THEN
134305                 T:=5MBBANK; *AAX XADPR; LDXTX      % X=PROCESS DESCRIPTION
134310                 X.PSTAT BZERO T5BUFF BONE F5BUFF=:X.PSTAT  % MARK MESSAGE FROM ND-500
134314              FI
134314           FI
134314           GO MONEN
134315   *)FILL
134327
134327   % DELAYED ABORT-HANDLING FOR NUCLEUS
134327   NKREL:  CALL 5NUREL; GO MONEN
134331
134331
134331   % RESTART CURRENT PROCESS WHICH IS NOW LOADING MIC.PROGR AFTER POWER UP,
134331   % AND FIND ANOTHER PROCESS TO LOAD THE MIC.PROGR.
134331   % X=MESSAGE OF PROCESS TO RESTART (RESTART IN ND-100)
134331   RNEWCO: *IOF
134332          CALL SLOCK; 0/\0
134334          CALL GETC5PROC; A=:D
134336          T:=5MBBANK; *SENDE@3 LDATX
134340          IF A=D OR MIFLAG NBIT MUDOM THEN
134345             CALL XTER500; 0/\0
134347          FI
134347          CALL IFM500XQ
134350          CALL SUNLOCK
134351          X:=MAILINK
134352          DO
134352             T:=5MBBANK; *LINK@3 LDDTX              % Skip dummy msg
134354          WHILE D><-1
134357   *NNC08,   CNVBYADR
134362             IF X:=D><DUMMESS THEN
134366                A=:T; X=:5MMESSAGE; *SENDE@3 LDDTX
134371                A:=:D; A-5SWPROC*5PRDSIZE+"S500S"=:X
134376                IF D><-1 AND D>>5SWPROC AND X.PSTAT BIT 5REWA THEN
134407                   X:=5MMESSAGE
134410                   CALL SLOCK; 0/\0; CALL IFM500XQ; CALL SUNLOCK
134414                   GO STUPR
134415                FI
134415                X:=5MMESSAGE
134416             FI
134416          OD
134417          GO STUPR
134420   *)FILL
134437
134437   % REMOVE THE SWAPPER FROM THE EX-QUEUE
134437   INTEGER CCMESS
134440   FQUEUE: *IOF
134441          CALL SLOCK; 0/\0
134443          X=:CCMESS:=SWMSG; T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
134451          IF A BIT 5IEXQUEUE THEN
134453             CALL GCPUDF; CALL ERRFATAL; A=:B
134456             CALL GETC5PROC; A=:D
134460             T:=5MBBANK; *SENDE@3 LDATX
134462             IF A=D OR MIFLAG NBIT MUDOM THEN
134467                CALL XTER500; 0/\0
134471             FI
134471             CALL IFM500XQ
134472          FI
134472          ANSWER; X:=CCMESS; CALL WN5STATUS
134475          CALL SUNLOCK
134476          *ION
134477          GO FAR RESENT
134500
134500   % MESSAGE TO START PROCESS-0
134500   P0START:
134500          CALL SLOCK; 0/\0
134502          X:=WATCHDOG; CALL ITO500XQ
134504          T:=5MBBANK; *MICFU@3 STATX
134506          MSGN500; CALL WN5STATUS
134510          CALL SUNLOCK
134511          CALL XACTRDY       % Reactivate nd-500 with "swapper message"
134512          CALL LOWACT500
134513          IF TMR << TTMR THEN A:=T FI; A=:TMR
134521          X:=5MMESSAGE; GO FAR RESENT
134523   *)FILL
134542
134542   % RELEASE 500-FILE-TRANSFER-BUFFER-HEADER BEFORE
134542   % CONTINUE AFTER MONCALL
134542   INTEGER XREG,BREG
134544   5RLBH:  X=:XREG
134545           *IOF
134546           RTREF; CALL F5DBHS; CALL ERRFATAL
134551           A:=:B=:BREG; X:=RTREF; CALL BRELEASE         % RELEASE DEV.BUF HEADER
134555           IF 5DVBWAIT.BWLINK><X THEN                   % ANYONE WAITING FOR BUFFER HEADER?
134561              X=:B; A.WLINK=:BWLINK; 0=:X.WLINK         % YES, REMOVE PROC FROM WAITING QUEUE
134566              CALL BRESERVE; CALL TOEXQU                % RESERVE DEV.BUF HEADER FOR FIRST IN WAITING QUEUE
134570              1=:MTOR
134572           FI; X:=BREG=:B:=XREG
134575           GO FAR MONCO                                 % GOTO RESTART-AFTER-MONCALL
134576   RBUS
134607
134607

134607   SUBR ITRAPDECODER
134607   RBUS
134607
134607   %==============================================================================
134607   %        ( M )     N 5 0 0   -   P 1 2 D C N   -   5 S T D R I V
134607   %==============================================================================
134607   %
134607   % L e v e l  1 2  -  ND5000 communication driver kernel
134607   %
134607   SUBR 5STDRIV,N500,XN500,NXTMSG,CALLID12
134607   INTEGER CC5CPU
134610
134610   5STDRIV:
134610          IF CPUAVAILABLE NBIT 5ALIVE GO CALLID12
134613   N500:
134613          DO
134613             IF C5STAT/\C5PFMASK >< 0  GO CALLID12
134617   *CCM03,   TRR CCLR
134620   *NNJ07=*
134620             GO XN500                                         % Continue in XN500 if nd5000
134621             A:=B=:CC5CPU
134623             177377; CALL CLE5STATUS                          % READ STATUS AND MASK IT
134625             IF A/\720><0 THEN
134627                IF A BIT 5PFAIL THEN                          % POWER FAIL?
134631                   C5STAT BONE BHPFAIL BZERO BCSLPFAIL=:C5STAT% YES,
134635                   TTMR=:TMR; KPOWDOWN                        % RESTART ALL PROCS WITH "POWER DOWN"
134640                ELSE IF A BIT 5DMAERR THEN N5DMAERR           % DMA ERROR
134644                ELSE N5IERR                                   % ND-500 COMMUNICATION ERROR
134646                FI; FI
134646                GO N500ERR
134647             FI
134647             X:=MAILINK                                       % SCANN EX-QUEUE FROM "MAR"
134650             DO
134650             WHILE X><-1
134653                T:=5MBBANK; *LINK@3 LDDTX
134655             WHILE D><-1
134660                X:=D=:N5MESSAGE                               % MESSAGE IS ALWAYS CURRENTLY HANDLED MESS.
134662                IF X><DUMMESS THEN
134665                   CALL CHN5STATUS; GO N500ERR
134667                FI
134667   NXTMSG:
134667   *NNJ08=*
134667                GO XN500                                      % Continue in XN500 if nd5000
134670                X:=N5MESSAGE
134671             OD
134672             CC5CPU=:B; CALL XACT500
134675   CALLID12: CALL WT12
134676          OD
134677
134677   N500ERR:
134677          CALL XRSTARTALL; GO CALLID12              % RESTART ALL PROCS.
134701   *)FILL
134723
134723   XN500:
134723          DO
134723             DO
134723                X:="N500DF".X500DF; T:=5MBBANK; *AAX X5MXF; LDATX
134730                A=:L; *AAX X5HEN-X5MXF; LDDTX
134733             WHILE A><D                             % WHILE HENTE><FYLLE
134735                IF A=:D+1>=L THEN                   % FIFO FILLED?
134741                   A:=0                             % YES, START FROM ZERO
134742                FI; *STATX                          % STORE NEXT HENTE
134743                D SH 1=:L; *AAX X5FIF-X5HEN; LDDTX  % HENTE*FIFO ELEMENT SIZE+FIFO START
134747                *CNVBYADR
134752                X:=D+L; T:=A+C; *LDDTX
134756                *CNVBYADR
134761                X:=D=:N5MESSAGE
134763                T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
134767                IF A BIT 5IEXQUEUE THEN
134771                   CALL CHN5STATUS; GO N500ERR
134773                FI
134773             OD
134774             GO CALLID12
134775          OD
134776   RBUS
135004
135004
135004   %=============================================
135004   %      C H N 5 S T A T U S
135004   %
135004   % DRIVER LEVEL
135004   % Entry:   X=Message address
135004   %
135004   SUBR CHN5STATUS
135004   INTEGER POINTER LREG
135005   CHN5STATUS: T:=L=:"LREG"
135007          CALL GCPUDF; CALL ERRFATAL; A=:B
135012          CALL RN5STATUS
135013          IF A=ANSWER THEN                 % ANSWER FROM ND-500
135016             IF X=HIMESS THEN
135021                CALL HISTSAMPLE            % HISTOGRAM MESSAGE
135022             ELSE
135023                CALL P67L1                 % PERFORMANCE LOGGING
135024                IF X=WATCHDOG THEN       % TIMER MESSAGE
135027                   CALL SLOCK; GO LREG
135031                   CALL IFM500XQ
135032                   CALL SUNLOCK
135033                   0=:TMRXQ; LTTMR=:TMR
135036                ELSE
135037                   CALL DECOMESS              % DECODE ANSWER FROM ND-500
135040                FI
135040             FI
135040          ELSE IF A=5ERANSWER THEN
135044             CALL DECOERRMESS              % DECODE ERROR-ANSWER FROM ND-500
135045          ELSE IF A>>100 THEN
135051             CALL 5RRTWT                   % RESTART ND-100 PROCESS
135052          ELSE IF A=MSGN500 OR A=WAITING THEN
135061   *NNT06=*
135061             CALL XTER500; GO LREG
135063   *CCM04,   TRR CCLR
135064          FI FI FI FI
135064          MIN "LREG"; GO LREG
135066   RBUS
135103
135103
135103   %=============================================
135103   %      H I S T S A M P L E
135103   %
135103   % DRIVER LEVEL
135103   % X=HIMESS
135103   %
135103   SUBR HISTSAMPLE
135103   INTEGER CAAT
135104   HISTSAMPLE:
135104          T:=5MBBANK; *AAX WANTP-1; LDDTX                     % D=PROCESS TO DO HISTOGRAM ON
135107          *AAX ACPRO-WANTP+1; LDATX                           % A=ACTUAL RUNNING PROCESS
135111          IF A=D THEN
135113             *AAX -ACPRO                                      % UPDATE HISTOGRAM
135114   %         MFREE; CALL WN5STATUS                             % MARK HISTOGRAM MESSAGE FREE
135114             5HISTART; A=:CAAT; D=:L; *AAX N500A; LDDTX
135121             D-L; A:=A+C-1-CAAT
135125             IF A<0 GO OUTSIDE                                % IS P-REG WITHIN "TARGET" AREA?
135126             T:=5HINTERVAL; Z:="0"; *RDIV ST
135131             IF A < 5HICHANNELS AND Z NBIT THEN
135136                A SH 1=:X; 5HIDATA(X); D+1; A:=A+C
135143                AD=:5HIDATA(X)                                % UPDATE IN INTERVAL
135144             ELSE
135145   OUTSIDE:     5HIOUTSIDE; D+1; A:=A+C; AD=:5HIOUTSIDE       % UPDATE OUTSIDE TARGET AREA
135151             FI
135151          FI; GO NXTMSG                         % HANDLE NEXT MESSAGE IN EX-QUEUE
135152   RBUS
135161
135161
135161   %============================================================================
135161   %      D E C O M E S S
135161   %
135161   % DECODE "ANSWER-MESSAGE" FROM N500
135161   % THE ACTUAL MESSAGE IS FOUND IN MESSAGE
135161   %
135161   % DRIVER LEVEL
135161   %
135161   % ENTRY:   X=ACTUAL MESSAGE (=MESSAGE)
135161   %          B=N500 CPU-DATAFIELD
135161   %
135161   % RETURNS TO NXTMSG IN DRIVER KERNEL N500.
135161   %
135161   SUBR DECOMESS
135161   DECOMESS:
135161          T:=5MBBANK; *AAX SPFLA; LDATX; AAX -SPFLA
135165          IF A><0 THEN A=:P FI                                 % GOTO ROUTINE ADDR FOUND IN SPFLAG
135167          *MICFU@3 LDATX                                       % MIC.FUNC
135170          IF A=3MONCO OR A=3TRACO OR A=3START OR A=3WMONCO THEN
135204             T:=5MBBANK; *AAX STOPR; LDATX; AAX -STOPR
135210             IF A=MOCALL THEN CALL MCHANDLE                    % STOP-REASON IS MON.CALL
135214             ELSE IF A=5FMOCALL THEN CALL MCHANDLE             % STOP-REASON IS FILE-TRANSFER MONCALL
135221             ELSE IF A=TRAPCODE THEN CALL TRAPDECODER          % STOP-REASON IS TRAP
135226             ELSE CALL 5RRTWT                                  % RESTART ND-100 PROCESS
135230             FI FI FI
135230          ELSE
135231             CALL 5RRTWT                                       % RESTART ND-100 PROCSESS
135232          FI
135232          GO NXTMSG                                            % HANDLE NEXT MESS. IN EX-QUEUE
135233   RBUS
135240
135240
135240   %==============================================================================
135240   %      D E C O E R R M E S S
135240   %
135240   % DECODE "ERROR-ANSWER" MESSAGES FROM N500
135240   % THE ACTUAL MESSAGE IS FOUND IN MESSAGE
135240   %
135240   % DRIVER LEVEL
135240   %
135240   % ENTRY:     X=ACTUAL MESSAGE
135240   %            B=N500 CPU-DATAFIELD
135240   %
135240   % RETURNS TO NXTMSG IN DRIVER KERNEL N500.
135240   %
135240   SUBR DECOERRMESS
135240   DECOERRMESS:
135240          T:=5MBBANK; *AAX TRAPN-1; LDDTX           % D=TRAPNO
135243          *AAX 1-TRAPN; MICFU@3 LDATX               % A=MICFUNC
135245          IF D=46 AND A=3MONCO OR =3RMED OR =3WMEP
135257          OR =3RMEP OR =3WMONCO OR =3PHSREAD OR =3PHSWRITE % LEGAL MICFUNCS FOR
135273          OR =3WMED OR =3TRACO OR =3START GO ITRAPDECODER  % PAGE-FAULT
135306          CALL 5RRTWT                                      % RESTART ND-100 PROC.
135307          GO NXTMSG                                        % HANDLE NEXT MESS. IN EX-QUEUE
135310   RBUS
135314
135314
135314   %==========================================================================
135314   %      T R A P D E C O D E R
135314   %
135314   % DECODE "TRAP-MESSAGES" FROM N500
135314   %
135314   % DRIVER LEVEL
135314   %
135314   % ENTRY:     X="TRAPPED" MESSAGE
135314   %            B=N500 CPU-DATAFIELD
135314   %
135314   % RETURNS TO NXTMSG IN THE DRIVER KERNEL N500.
135314   %
135314   SUBR TRAPDECODER,ITRAPDECODER
135314   INTEGER ARRAY TRPELIST(0)
135314   INTEGER TRPETRAP,TRPEPROC,TRPERTREF,TRPECPU          % PARAMETERS FOR "TRAP IN PROCESS"
135320
135320   TRAPDECODER:
135320          T:=5MBBANK; *AAX TRAPN-1; LDDTX; AAX 1-TRAPN  % D=TRAPNO
135324          IF D>53 THEN
135327             ILTRAP; CALL WN5STATUS                     % UNKNOWN TRAP
135331             CALL 5RRTWT                                % RESTART ND-100 PROCESS
135332          ELSE IF D = 46 THEN                           % PAGE FAULT
135336   ITRAPDECODER: IF X>< SWMSG THEN
135341                   X=:L
135342                   IF 5INITFLAG BIT BRESPLACE
135343                   OR "N500DF".SYSINITFLAG NBIT BSWSTARTED THEN
135351                      X:=L; CALL 5RRTWT; GO NXTMSG      % RESTART ND-100 PROC. AND HANDLE NEXT IN EX-QUEUE
135354                   FI
135354                   T:=5MBBANK; X:=L; *5RECE@3 LDATX     % RECEIVER
135357                   IF A-5SWPROC=0 GO ITRPERR            % PAGE FAULT IN SWAPPER? BACKGROUND MONITOR HANDLES THAT
135361                   MSWPFAULT SHZ 10+D
135364                   *AAX TRAPN; STATX; AAX -TRAPN
135367                   CALL 5ACTSWAPPER                     % ACTIVATE THE SWAPPER
135370                ELSE
135371                   EPFINSWAP; CALL XRSTARTALL            % FATAL ERROR, PAGE FAULT IN SWAPPER
135373                FI
135373          ELSE
135374   ITRPERR:
135374   *"8N500 8FTS5
"135374             A:=ETRIPRC+D
135376   ITRP2ERR: A=:TRPETRAP; T:=5MBBANK; *AAX 5CPUN; LDATX % ERROR MSG (TRAPCODE,PROCESS#,RTREF,CPU#)
135402             A/\377=:TRPECPU; *AAX -5CPUN; SENDE@3 LDATX
135406             A=:TRPEPROC; X=:D; *AAX XADPR; LDXTX
135412             IF X><0 THEN X:=X.RTRES FI; X=:TRPERTREF; *1BANK
135416             X:=D; CALL 9FLER(TRPELIST,4); *2BANK
135423   *"8N500
"135423             CALL 5RRTWT                                % RESTART ND-100 PROC. WITH TRAP MESSAGE
135424          FI;FI; GO NXTMSG                             % HANDLE NEXT MESSAGE IN EX-QUEUE
135425   RBUS
135443
135443
135443   %============================================================================
135443   %      S W P D E C O D E R
135443   %
135443   %      Message demanding swapp is marked "swapwait" in status
135443   %      The swapper is activated with page-fault info in the message
135443   %      and the swapped process is marked "swapping"
135443   %
135443   %  Nd-500 driver level (level 12)
135443   %
135443   % Entry:     X=swapper message
135443   %            B=nd-500 cpu-datafield
135443   %
135443   % Returns to nd-500 driver kernel n500.
135443   %
135443   SUBR SWPDECODER,5RDTRANSFER
135443   SWPDECODER:
135443          T:=5MBBANK; *AAX SWPFU; LDATX                       % Swap-function
135446          IF A >> SWFMAX GO FAR ESWPFATAL                     %
135451   @ICR
135451          A GOSW
135451             FAR ESWPFATAL, LNEWSWAP,      FAR LSWPAGE, FAR LPRSUSPEND,
135456             FAR LALLOPAGE, FAR LDATREADY, FAR LCLTSB;
135461   @CR;
135461
135461   *)FILL
135470
135470   % Start message currently being served by the swapper, if any,
135470   % and find next process requesting the swapper.
135470   % The processes requesting the swapper, are handled according
135470   % to the nd-500 priority of the processes.
135470   %
135470   INTEGER CSWPM=?
135470   INTEGER SSTAT=?
135470   INTEGER BREG=?
135470
135470   LNEWSWAP:
135470          T:=5MBBANK; X:=SWMSG; *AAX HSWPI; LDDTX             % AD:=X.SWPINFO
135474          IF D><0 THEN                                        % Any proc. currently served?
135476   *NNC09,   CNVBYADR
135501             X:=D=:CSWPM
135503             CALL SLOCK; 0/\0
135505             T:=5MBBANK; *AAX 5MSFL; LDATX                    % Yes, escape while using swapper?
135510             A BZERO 5IBRK; *S5IBR@3 BLDA DA                  % K:=S5IBRK
135512             *5IBRK@3 BSTA DA                                 % K=:5IBRK
135513             A BZERO S5IBRK
135514             IF A BIT 52ESCSET AND A NBIT 5IBRK THEN
135520                A BZERO 52ESCSET BONE 5IBRK; *STATX; AAX -5MSFL
135524                CALL SUNLOCK
135525                CALL RN5STATUS
135526                IF A=SWPPING THEN ESCSTOP FI                  % Escape typed while using Swapper
135532                GO SWPD1; *)FILL
135542             FI
135542             *STATX
135543             CALL SUNLOCK
135544             X:=SWMSG; *AAX SWPST; LDATX                      % A:=SWMSG.SWPSTAT
135547             A=:D
135550             IF A><0 THEN                                     % Error-answer from swapper?
135551                *AAX HSWPI-SWPST; STZTX                       % 0=:X.SWPINFO
135553                *AAX SWPIN-HSWPI; STZTX                       % 0=:X.SWPINFO
135555                X:=CSWPM; *AAX SPFLA; LDATX
135560                IF A><0 THEN                                  % A:=SWMSG.SWPINFO.SPFLAG
135561                   *STZTX                                     % 0=:X.SPFLAG
135562                   D=:A                                       % Swpstat, error code
135563                   X:=CSWPM; CALL EMONICO                     % Restart proc. with error code after mon.call
135565                   CALL XACTRDY
135566                ELSE
135567                   D=:A                                       % Swpstat, error code
135570   SWPD1:          X:=CSWPM; GO FAR SWPD2
135572                FI
135572             ELSE                                             % Ok answer from the swapper
135573                X:=CSWPM; CALL RN5STATUS                      % A:=SWMSG.SWPINFO.N5STATUS
135575                IF A/\17777=SWPPING THEN                      % Power bits might be set
135601                   T:=5MBBANK; *MICFU@3 LDATX                 % D:=SWMSG.SWPINFO.MICFUNC
135603                   A=:D
135604                   IF 3SWMESS=D THEN                          % Message to swapper?
135607                      *SWFUN@3 LDATX
135610                      IF A=MSCRS OR =MSCRENEWVERS THEN
135616                         T:=5MBBANK; X:=SWMSG; *AAX RETP4+1; LDATX
135622                         X:=CSWPM; *AAX 10; STATX; AAX -10
135626                      FI
135626                      CALL RN5STATUS; A/\160000\/ANSWER       % Take care of power fail flags
135631                      GO FAR SWPD2                            % Yes, restart nd-100 proc
135632                   ELSE                                       % Restart nd-500 proc.
135633                      IF 3START=D THEN
135636                         3TRACO; *MICFU@3 STATX               % 3TRACO=:X.MICFUNC
135640                      ELSE
135641                         IF 3WMONCO=D THEN                    % Writeback buffer restart?
135644                            *AAX SM26N; LDATX
135646                            *AAX 26NRB-SM26N; STATX
135650                            *AAX SM26A-26NRB; LDDTX
135652                            *AAX 26ADD-SM26A; STDTX
135654                         FI
135654                      FI
135654                      X:=CSWPM; CALL RN5STATUS
135656                      A/\160000\/MSGN500             % Keep pow. fail flags
135660                      CALL WN5STATUS                 % MSGN500=:X.N5STATUS
135661                      CALL XACTRDY
135662                      CALL GCPUDF; CALL ERRFATAL
135664                      IF A><B THEN
135666                         A:=:B=:BREG
135670   *NNA01=*
135670                         CALL XACT500
135671                         BREG=:B
135673                      FI
135673                   FI
135673                FI
135673             FI
135673          FI
135673          GO SWPD3
135674
135674   INTEGER BREG
135675   INTEGER CSWPM
135676   INTEGER SSTAT
135677   *)FILL
135716   INTEGER NHENT
135717
135717   SWPD2: A=:SSTAT
135720          CALL GCPUDF; CALL ERRFATAL; A:=:B=:BREG
135724   *NNT07=*
135724          CALL XTER500; GO FAR N500ERR
135726          SSTAT; CALL WN5STATUS                                % Restart nd-100 proc with error code
135730          CALL 5RRTWT
135731          IF B><BREG THEN
135734   *NNA02=*
135734             CALL XACT500
135735          FI
135735          BREG=:B
135737   SWPD3:
135737   *NNJ09=*
135737          GO SWPD4
135740          X:=SWMSG; CALL IFM500XQ
135742          T:=5MBBANK; *AAX PLINK; LDATX; AAX -PLINK
135746          A=:N5MESSAGE
135747   SWPD4: PSWWAIT; X:=SWMSG; CALL WN5STATUS                    % Mark swapper free
135752          % Search from Swap-queue fifo buffer for processes
135752          % waiting for service by the Swapper
135752          DO
135752             CALL SLOCK; GO FAR N500ERR
135754             T:=5MBBANK; X:="N500DF".X500DF; *AAX X5MXF; LDATX
135761             A=:L; *AAX X5SWH-X5MXF; LDDTX                  % Get Swap-fifo Hente-/Fylle-pointer
135764          WHILE A><D                                        % More messages in Swap-fifo?
135766             IF A=:D+1>=L THEN A:=0 FI; A=:NHENT
135774             D SH 1=:L; *AAX X5SWB-X5SWH; LDDTX
136000   *NNC10,   CNVBYADR
136003             X:=D+L; T:=A+C; *LDDTX                       % Next process to be served
136007   *NNC11,   CNVBYADR
136012             X:=D; CALL SUNLOCK
136014             CALL RN5STATUS
136015             IF A/\160000><0 GO EMPTY                   % Do not serve if pf
136017             T:=5MBBANK; X:="N500DF".X500DF; *AAX X5SWH
136023             NHENT; *STATX                              % Update Swap-fifo Hente-pointer
136025             X:=D; CALL RN5STATUS
136027             IF A=SWPWAIT THEN
136032                X:=D; CALL GCPUDF; CALL ERRFATAL; A:=:B=:BREG
136037                CALL 5ACTSWAPPER
136040                IF BREG><B THEN
136043   *NNA03=*
136043                   CALL XACT500
136044                FI
136044                BREG=:B; GO NXTMSG
136047             FI
136047          OD
136050   EMPTY: A:=0=:D; T:=5MBBANK
136053          X:="N500DF".X500DF; *AAX X5SWO; STDTX
136057          X:=SWMSG; *AAX HSWPI; STZTX
136062          *AAX SWPIN-HSWPI; STZTX
136064          CALL SUNLOCK
136065          GO NXTMSG
136066   *)FILL
136111
136111
136111   INTEGER CC5CPUDF
136112   LSWPAGE:                                                   % Disk I/O
136112          X:=SWMSG; PSW1WAIT; CALL WN5STATUS
136115          11=:L; SWMSG+"SWPINFO"=:D; 5MBBANK; T:="XSDUNIT"; *MOVPA   % Move parameters from swmsg to par.array for 5swap
136125          A:=XSDUNIT; CALL LOGPH; A=:X
136130
136130          IF A>>="9BBHD" AND A<<"9EEHD" THEN
136136             % Hard disc with disc optimization
136136             IF XABSFUNC/\77=60 THEN XABSFUNC+6=:XABSFUNC FI  % Use func=66 instead of 60
136146             XABSFUNC SHZ -6/\7+"HTABL"
136152             X:=:B; X=:CC5CPUDF
136154             X:=B+A:=X.S0                                     % X=addr of disk-layout table
136157             IF X.S10=20 THEN                                 % Is it phoenix disc?
136163                A:=XABLO/\7 SHZ 11\/XABSFUNC=:XABSFUNC        % Yes, set subunit bits in function
136170                0=:XABLO                                      % Use only 16 bits disc-addr
136171             FI
136171
136171             IF B >> "9FSTR" AND B << "9ESTR" AND STREN=0 GO OLWA  % Disc sorting/parallel seek
136201
136201             T:="QP100".QP5SW                              % 500 SWAPPER ELEMENT
136203             -1=:X.QP5SW; X:=T                % "LINK OUT"
136206             IF X = 0 OR X.RTRES >< 0 THEN CALL ERRFATAL FI
136212             "5SWAP"=:X.RTRES; 0=:X.NLINK     % " RESERVE QUE"
136215             *LDF I (XABSF; STF ABFUN,X
136217             *LDD I (XABLO; STD ABPA2,X
136221             *LDA I (XABLN; STA ABP31,X
136223             CALL M5TRANS; GO BUSR
136225             0=:X.RTRES; -1=:X.NLINK          % "RELEASE QUE"
136230             T:=X; T=:"QP100".QP5SW; X:=T     % "LINK INN"
136234             GO 5RDTRANSFER
136235   BUSR:     CC5CPUDF=:B; GO NXTMSG           % TRANSFER IS STARTED
136240
136240   OLWA:     CC5CPUDF=:B
136242          FI
136242          X:=SWMSG; CALL 5SWACTRT; GO NXTMSG                  % Activate 5swap
136245
136245   5RDTRANSFER:                                               % Return after disc-transfer
136245           IF "N500DF".SYSINITFLAG BIT B5STOP GO WT12
136251           X:=SWMSG; CALL GCPUDF; GO WT12; B=:X:=A            % B=cpu.df; Xx=disc.acc.queue element
136256           IF X.SSSTAT NBIT 4 THEN
136261              X:=SWMSG; CALL OKMONICO                         % Transfer ok
136263           ELSE
136264              X:=SWMSG; A:=1055; CALL EMONICO                 % Error in transfer (swderr=1055)
136267           FI
136267           CALL XACT500
136270           GO CALLID12
136271
136271   LPRSUSPEND: GO FAR ESWPFATAL                               % Suspend proc. not implemented
136272   *)FILL
136331
136331   % Copy swapper-message to requesting proc's message and
136331   % Restart nd-100 process with this info.
136331   DOUBLE SWDD1,SWDD2,SWDD3                                   % Saved part of swapper's message
136337   DOUBLE CCN100ADDR
136341   INTEGER CSWINF=?
136341   LDATREADY:
136341          X:=SWMSG; T:=5MBBANK; *AAX HSWPI; LDDTX
136345          IF D=0 GO FAR ESWPFATAL
136347   *NNC12,CNVBYADR
136352          X:=D; CALL RN5STATUS
136354          IF A><SWPPING GO SSWPFREE                 % Process requesting swapper is not waiting for the swapper
136357          X=:L:=SWMSG; T:=5MBBANK; *AAX N500A; LDDTX
136364          *STD SWDD1; LDDTX 20; STD SWDD2           % Save part of swmsg
136367          *LDDTX 40; STD SWDD3
136371          X:=L; *AAX ABUFA; LDDTX
136374   *NNC13,CNVWADR
136377          AD=:CCN100ADDR
136400          X:=SWMSG; T:=5MBBANK; *AAX 42; LDDTX      % 42=padr2; addr of par #2
136404          *AAX N500A-42; STDTX                      % Prepare data-memory read message
136406          AD:=CCN100ADDR; *AAX N100A-N500A; STDTX
136411          A:=400; *AAX NRBYT-N100A; STATX
136414          *AAX 5DITN-NRBYT; STZTX
136416          "INLDATREADY"; *AAX SPFLA-5DITN; STATX; AAX -SPFLA
136422          3RMED; *MICFU@3 STATX
136424          MSGN500; CALL WN5STATUS
136426          CALL XACTRDY
136427          GO NXTMSG
136430
136430   INTEGER CSWINF
136431   INLDATREADY:                                     % Return here after data-mem read
136431          T:=5MBBANK; *AAX SPFLA; STZTX             % Clear spflag
136434          X:="N500DF".X500DF; *AAX X5SWO; LDDTX
136440   *NNC14,CNVBYADR
136443          X:=D=:CSWINF; CALL RN5STATUS
136446          IF A=SWPPING THEN                         % Process still waiting for swapper
136451             X:=SWMSG; CALL RN5STATUS            % Restart process
136453             X:=CSWINF; CALL WN5STATUS
136455             IF MIFLAG BIT MUDOM THEN
136460                CALL 5RRTWT
136461             FI
136461          FI; X:=SWMSG; T:=5MBBANK; *AAX N500A      % Rebuild swmsg message
136464          *LDD SWDD1; STDTX; LDD SWDD2; STDTX 20
136470          *LDD SWDD3; STDTX 40
136472   SSWPFREE:
136472          X:=SWMSG; CALL OKMONICO
136474          CALL XACTRDY
136475          GO NXTMSG
136476   *)FILL
136513
136513   % Allocate a new page to a file.
136513   INTEGER SWCPU=?
136513   LALLOPAGE:
136513          X:=SWMSG; PSW1WAIT; CALL WN5STATUS                  % PSWWAIT=:X.N5STATUS
136516          T:=5MBBANK; *AAX HSWPI; LDDTX
136521          IF D=0 GO ESWPFATAL
136523   *NNC15,CNVBYADR
136526          T:=5MBBANK; X:=D=:CSWINF; *MICFU@3 LDATX
136532          *AAX OLDMI; STATX; AAX -OLDMI                       % Save micfunc
136535          X:="STOPREASON"; T:=CSWINF+X
136540          A:=120=:L:=SWMSG+X=:D:=5MBBANK; X:=A; *MOVPP        % Copy swapper message to actual message
136550   SUSP2: X:=CSWINF; 5IALLOPAGE; CALL WN5STATUS               % Allocate page=:swmsg.swpinfo.n5status
136553          CALL GCPUDF; CALL ERRFATAL; A:=:B=:SWCPU
136557   *NNT08=*
136557          CALL XTER500; GO N500ERR
136561          CALL 5RRTWT
136562          IF SWCPU><B THEN
136565   *NNA04=*
136565             CALL XACT500
136566          FI
136566          SWCPU=:B; GO NXTMSG
136571
136571   % Fatal error from the swapper, restart all active-procs. with
136571   % an error code.
136571   ESWPFATAL:  X:=SWMSG; SWPFATAL
136573   N500ERR:    CALL XRSTARTALL; GO CALLID12
136575   *)FILL
136613
136613   % Clear TSB for multi ND500 cpu system
136613   INTEGER SWCPU,SWPCLRMASK
136615   LCLTSB:
136615          CALL CHACTIVEQ; GO EOD
136617          IF A=1 GO EOD
136622   *NNJ10=*
136622          GO LMPCLR                                   % Continue in LMPCLR if nd5000
136623          A:="S5CPUDF":=:B=:SWCPU
136626          DO WHILE B<<="E5CPUDF"
136631             IF B><SWCPU AND CPUAVAILABLE BIT 5ALIVE
136635             AND C5STAT NBIT BHPFAIL AND SPREF=0 THEN
136644                X:=WATCHDOG
136645                CALL XTER500; 0/\0
136647                3RMICV; T:=5MBBANK; *MICFU@3 STATX
136652                MSGN500; CALL WN5STATUS
136654                CALL ITO500XQ; X=:TMRXQ; LTTMR=:TMR
136660                CALL XACT500
136661             FI
136661             B+5CPUDFSZ
136662          OD
136663          SWCPU=:B; GO EOD
136666
136666   % Clear-function; ND5000 only
136666   %
136666   LMPCLR:
136666          T:=5MBBANK; X:=SWMSG; *AAX 5DP2; LDATX
136672          A=:SWPCLRMASK
136673          CALL SLOCK; 0/\0
136675          A:="S5CPUDF":=:B=:SWCPU
136700          DO WHILE B<<="E5CPUDF"
136703             IF B><SWCPU AND CPUAVAILABLE BIT 5ALIVE
136707             AND C5STAT NBIT BHPFAIL AND SPREF=0 THEN
136716                T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX; AAX -X5CPU
136723                IF A=MPACTIVE THEN
136726                   SWPCLRMASK; T:=5MBBANK; *AAX X5CLR; STATX
136732                   CLRKICK; CALL XKICK500
136734                FI
136734             FI
136734             B+5CPUDFSZ
136735          OD
136736          CALL SUNLOCK
136737          SWCPU=:B
136741   EOD:   X:=SWMSG; CALL OKMONICO
136743          CALL XACTRDY
136744          GO NXTMSG
136745   RBUS
136764
136764
136764
136764   @ICR;
136764   SUBR N5FUD,STAPROC,NSTOPROC,SWITPROC,NINSTR,NOUTSTR,
136764        GERRC,5SIBMO,SPRIO,SWMC,DVIO,A5XMSG,B5XMSG,M5TMOUT,5MTRANS;
136764   RBUS
136764   @CR;
136764
136764   %=============================================================================
136764   %      M C H A N D E L
136764   %
136764   % DECODING MONITOR CALL MESSAGES FROM N500
136764   %
136764   % CALLED FROM : DECOMESS
136764   %
136764   % DRIVER LEVEL
136764   %
136764   % ENTRY:     X=ACTUAL MESSAGE (=MESSAGE)
136764   %            T=STOP-REASON
136764   %            B=ND-500 CPU DATAFIELD
136764   %            THE ACTUAL PROCESS IS FOUND IN PROCAD
136764   %
136764   % RETURNS TO NXTMSG IN ND-500 DRIVER KERNEL N500.
136764   %
136764   SUBR MCHANDEL,NORMMC,M516,M517,M520,M521,M522,M523
136764
136764   SYMBOL L12MIN=               500       % FIRST MON CALL THAT REQUIRES SPECIAL
136764                                          % TREATMENT ON LEVEL 12
136764   SYMBOL L12MAX=               523       % LAST
136764   SYMBOL CERN=                 376       % SPECIAL MON.CALL TO EXECUTE ND-100 INSTRUCTIONS
136764   SYMBOL N5SWAP=               377       % MON.CALL USED BY THE SWAPPER.
136764   INTEGER CSTOPREASON,CURX,CNT
136767   INTEGER 5CMNO=?
136767
136767   NORMMC:
136767           IF CSTOPREASON=5FMOCALL THEN
136773              X=:D
136774              "5FRTBAK"=:PROCAD.MFUNC
136777              X:=D
137000           FI
137000           CALL 5RRTWT; GO NXTMSG
137002   *)FILL
137006
137006   MCHANDEL: T=:CSTOPREASON
137007          IF 5MLOPROC><0 THEN                                 % MONITOR CALL LOGING?
137011             T:=5MBBANK; *LDATX X5SND
137013             IF A=5MLOPROC OR A:=-1=T THEN                    % LOG FOR THIS PROC OR FOR ALL?
137021                T:=5MBBANK; *AAX MCNO; LDATX                  % YES, LOG
137024                IF A<<1000 THEN                               % MON.CALL NUMBER 777B IS THE HIGEST MON.CALL TO LOG
137027                   A SH 1; T:="N500DF".5BUBANK
137032                   X:=X.5BUSTART+A; *LDDTX                    % INCREMENT  -
137035                   D+1; A:=A+C; *STDTX                        % MONITOR CALL COUNT
137040                   X:=N5MESSAGE
137041                FI
137041             FI
137041          FI
137041          CALL PML50                                          % PERFORMANCE LOGGING
137042          T:=5MBBANK; *AAX XADPR; LDATX
137045          A=:PROCAD                                           % PROCESS DESCR. OF CURRENT PROC.
137046          *AAX MCNO-XADPR; LDATX; AAX SMCNO-MCNO; STATX       % SAVE MON.CALL NUMBER IN SMCNO
137052          IF A=2TUSED THEN                                    % MON TIME-USED?
137055             CALL MBSUSPROC
137056             T:=5MBBANK; X:=N5MESSAGE; *AAX 500TU; LDDTX      % AD=ND-500 CPU-TIME USED (500TUSED)
137062             T:=0; X:=N5MESSAGE; CALL MONICO                  % RESTART ND-500 PROC
137065             CALL XACTRDY
137066             GO NXTMSG; *)FILL                                % HANDLE NEXT PROC. IN ND-500 EX-QUEUE
137102          FI
137102          IF A=2CLOCK THEN
137105             CALL MBSUSPROC
137106             -7=:CNT; N5MESSAGE+"ABUFADR"=:X; T:=5MBBANK; *LDDTX  % MON 60 BUFFER
137115             A=:T; A:=D=:CURX
137120             FOR CNT DO
137120                ACL7(CNT); X:=CURX; *SWAP SA DD CLD; STDTX
137125                MIN CURX; MIN CURX
137127             OD
137131             X:=N5MESSAGE; T:=5MBBANK
137133             IF MIFLAG BIT WSMC THEN                          % MP WRITE BACK ?
137136                *AAX PDR1; LDDTX; AAX 26ADD-PDR1; STDTX       % Logical address (destination)
137142                *AAX SM26A-26ADD; STDTX                       % Save logical address (destination)
137144                A:=34; *AAX 26NRB-SM26A; STATX
137147                *AAX SM26N-26NRB; STATX                       % No of bytes to move
137151                A:=0=:D; *AAX FUNCV-SM26N; STDTX              % Set Ok monitor call
137155                *AAX KFLIP-FUNCV; STZTX
137157                *AAX NUMPA-KFLIP; STZTX; AAX -NUMPA
137162                3WMONCO; *MICFU@3 STATX
137164                CALL MCCO
137165             ELSE
137166                *AAX PDR1; LDDTX; AAX N500A-PDR1; STDTX
137172                A:=34; *AAX NRBYT-N500A; STATX
137175                *AAX 5DITN-NRBYT; STZTX; AAX -5DITN
137200                *AAX ABUFA; LDDTX; AAX N100A-ABUFA; STDTX
137204                "INCLCK"; *AAX SPFLA-N100A; STATX; AAX -SPFLA
137210                3WMED; *STATX XMICF
137212                MSGN500; CALL WN5STATUS
137214                CALL XACTRDY
137215                GO NXTMSG
137216   INCLCK:      T:=5MBBANK; *AAX SPFLA; STZTX; AAX -SPFLA
137222                CALL OKMONICO
137223             FI
137223             CALL XACTRDY
137224             GO NXTMSG; *)FILL
137240          FI
137240          X:=N5MESSAGE
137241          IF A=N5SWAP THEN                                    % SPEC. MONITOR CALL FROM SWAPPER
137244             IF X=SWMSG THEN
137247                CALL SWPDECODER                               % DECODE FUNCTION FROM SWAPPER
137250             ELSE
137251                IF 5DBFLAG><0 THEN
137253                    E5DEBUG; CALL XRSTARTALL
137255                    GO NXTMSG
137256                FI
137256                A:=25; CALL WN5STATUS                          % YOU ARE NOT AUTHORIZE TO DO THIS
137260                CALL 5RRTWT                                    % WILL BE CONVERTED TO ILL. MON CALL
137261             FI; GO NXTMSG
137262          FI
137262          IF A=CERN THEN                                       % VERY SPECIAL MONITOR CALL FOR CERN
137265             IF T:=CERNENABLE >< 0 THEN                        % THIS MONITOR CALL LEGAL?
137270                40=:L                                          % LENGTH OF CODE TO BE MOVED
137272                X+100=:D; A:=5MBBANK                           % SOURCE ADDRESS (MONITOR CALL PARAMETERS)
137275                T:="CERNCODE"                                  % DESTINATION ADDRESS
137276                *MOVPN                                         % MOVE PARAMETERS TO CODE AREA (ALTERNATIVE TO NORMAL)
137277                CALL CERNCODE                                  % EXECUTE PARAMETERS!
137300                X:=N5MESSAGE                                   % WILL HOPEFULLY CONTINUE HERE
137301                CALL MONICO                                    % CERN IS RESPONSIBLE FOR A, D, AND T
137302                CALL XACTRDY
137303                GO NXTMSG
137304             FI
137304          FI
137304          A=:T
137305          PROCAD.PSTAT/\5CLRUNSTATUS+5INMCALL=:X.PSTAT         % MARK PROC. IN MON.CALL.
137312          A:=T; X:=N5MESSAGE
137314   *"8N500 8F5UD
"137314          IF A=333  AND 5FUDMA><0 THEN
137321             CALL MBSUSPROC
137322             CALL N5FUD; GO NORMMC; GO NXTMSG                % MON UDMA, MAY BE FAST CALL
137325          FI
137325   *"8N500
"137325   *N5MPA, JMP *2; JMP * 1                                    % FOR PATCHING
137327          IF A = 347 GO 5SERVER                               % NUCLEUS MON CALL
137332          IF A >= L12MIN AND A <= L12MAX THEN                 % SPECIAL HANDLING ON LEVEL 12?
137340             A=:5CMNO; CALL MBSUSPROC
137342   @ICR
137342             5CMNO-L12MIN GOSW
137342                STAPROC,    NSTOPROC,   SWITPROC,   NINSTR,
137351                NOUTSTR,    GERRC,      5SIBMO,     SPRIO,
137355                SWMC,       DVIO,       A5XMSG,     B5XMSG,
137361                M5TMOUT,    5MTRANS,    M516,       M517,
137365                M520,       M521,       M522,       M523;
137371   @CR;
137371          FI
137371          GO NORMMC         % MONITOR CALL SHOULD BE HANDLED BY THE SYSTEM MONITOR.
137372   *)FILL
137451
137451   % ENTRIES FOR PATCHING IN ADDRS TO NEW "DRIVER-LEVEL" MONITOR CALLS
137451   M516:    GO NORMMC; 0/\0
137453   M517:    GO NORMMC; 0/\0
137455   M520:    GO NORMMC; 0/\0
137457   M521:    GO NORMMC; 0/\0
137461   M522:    GO NORMMC; 0/\0
137463   M523:    GO NORMMC; 0/\0
137465
137465   INTEGER 5CMNO
137466   INTEGER CERNCODE(40)                                 % EXECUTED IN CERN MONITOR CALL!
137526   RBUS
137527
137527
137527
137527
137527   %
137527   %      SPECIAL TREATMENT OF MONITOR CALLS ON LEVEL 12
137527   %
137527
137527   %=============================================================================
137527   %       N 5 F U D      U D F U N C      C O A F     R I O W A
137527   %
137527   % ACTIVATED WHEN MON 333 (UDMA) FROM ND500,   DRIVER LEVEL
137527   % CALLED FROM MCHANDEL
137527   % ENTRY:   B= ND-500 CPU DATAFIELD
137527   %          X= MONITOR CALL MESSAGE IN 5MBBANK
137527   % RETURN:
137527   %   EXIT   ERROR, TRY AGAIN ON LEVEL 1
137527   %   EXIT+1 OK, UDRxx RT-PROG STARTED
137527   %
137527   SUBR N5FUD,COAF,UDFUNC,RIOWA
137527
137527   *"8N500 8F5UD
"137527   % FIXED 500 MEMORY DESCRIPTION
137527   % TX DISP
137527   %SYMBOL XFFPA=2            % FIRST LOGICAL PAGE
137527   %SYMBOL XFPHP=4            % ND-100 PHYS ADDR
137527   SYMBOL FIXCONT=14,FIXABST
137527
137527   INTEGER POINTER LREG=?
137527   INTEGER N5CP=?,N5ME=?,RTPD=?,ALOP=?
137527   INTEGER N5SE=?,UFU=?,UPIO=?,UNI=?,CCAP=?
137527   DOUBLE  DBUA=?,IPAR1=?
137527
137527
137527   DISP 7                     % SPECIAL DF. FOR UDRXX RT-PROG
137527          INTEGER UR5M                          % ADDRESS TO MESSAGE FROM N500 PROC.
137527          INTEGER POINTER FUNCP                 % FUNCTION
137527          DOUBLE  POINTER MEMOP                 % MEMORY ADDRESS
137527          INTEGER POINTER BLOCP                 % NOT USED
137527          DOUBLE  POINTER NWORP                 % NR OF 16 BITS WORDS
137527   PSID
137527   *"8N500
"137527
137527   N5FUD:
137527   *"8N500 8F5UD
"137527          X=:N5ME;                              % SAVE ADDRESS TO CURRENT MESSAGE AND 500 DATAFIELD
137530          A:=L=:"LREG"
137532   %-------------------------- GET PARAMETERS
137532          T:=5MBBANK; *LDATX X5SND              % GET 500 PROC. NO
137534          A=:N5SE
137535          *AAX 5PPA2; LDDTX                     % GET BUFFER ADDRESS
137537          AD=:DBUA;  *AAX 5AP1-5PPA2; LDDTX     % GET FUNCTION
137542          IF A >< 0 GO UERR; A:=D=:UFU
137545          *AAX 5AP2-5AP1; LDDTX                   % GET PIO DATA
137547          A:=D=:UPIO
137551          *AAX 5AP3-5AP2; LDDTX                   % GET LOG DEV
137553          IF A >< 0 GO UERR; A:=D=:UNI
137556          *AAX 5AP4-5AP3; LDDTX                   % GET IPAR1
137560          AD=:IPAR1
137561
137561          IF UNI < LUDV OR > HUDV GO UERR       % CHECK LOGICAL UNIT
137570          CALL LOGPH; IF A=0 GO UERR            % NOT EXSIST
137572          IF A.RTRES >< 0 GO UERR               % INPUT MUST BE FREE (ABSTR FRAM UDRxx)
137575          IF D=0 GO UERR;
137577          T:=5MBBANK; X:=N5ME;* AAX XADPR; LDXTX
137603          IF X.RTRES >< D.RTRES GO UERR         % DEVICE NOT RESERA=:ALOP                 % ABS. NUMBER OF LOGICAL PAGES -1
140014          T:=3777
140015          AD:=DBUA; D/\T=:X
140020          AD:=IPAR1
140021          IF D/\T+X > 4000 THEN            % IF BUFFER ADDRESS+LENGTH CROSS
140026              MIN ALOP; 0/\0               % + A PAGE BOUNDARY
140030          FI
140030          AD:=DBUA                         % ND-500 BUFFER ADDRESS
140031          IF D BIT "0" GO UERR             % ODD BYTE ADDRESS?
140033
140033          AD SHZ -13;  A=:D                % D = LOGICAL SEG NO
140035          A:=N5SE-1*MFANT+5DSPS+D=:X
140043          T:=5FXBNK; *LDATX                % A = CAPABILITY
140045          A=:CCAP                          % DATA SEGMENT CAPABILITY
140046          A /\ 1777 =: CPYS                % CURRENT PHYSICAL SEGMENT
140050          AD:=DBUA SHZ 5;                  % A= PAGE NO
140052          D SHZ -6                         % D = DIP (ND-100)
140053          A=:FLP + ALOP =:LLP              % 1. AND LAST LOG PAG
140056          A:=D=:CDIS                       % ND-100 DISPLACEMENT WITHIN PAGE
140060
140060          A:=N5SE-1*"MFSIZE*MFANT"+5FXTBL=:X+"MFSIZE*MFANT"=:MXTA
140067          DO
140067             T:=5FXBNK; *LDDTX             % AD = MFDESCR
140071             IF A BIT FIXABS OR A BIT FIXCONT THEN
140075             IF D = CPYS THEN
140100                T:=5FXBNK; *XFFPA@3 LDDTX         % A=FIRST FIXED LOG PAGE, D = LAST
140102                IF D >= LLP AND A <= FLP THEN     %  FIXED AREA FOUND
140110                   T-A=:D                         %  FLP-A IS DISP IN 5FXTBL
140112                   T:=5FXBNK; *XFPHP@3 LDATX      %  ND-100 PHYS PAGE
140114                   A+D                            %  ADD DISP IN 5FXTBL
140115                   AD SHZ -20; AD SHZ 12;         %  A:=D; A=0; AD=PAGE ADDR
140117                   T:=CDIS; D+T; A:=A+C           %  ND 100 PHYS ADDR IN AD
140122                   EXIT
140123                FI
140123             FI;FI
140123             X:=X+MFSIZE
140124          WHILE X<< MXTA
140127          OD
140130          GO FAR UERR; *)FILL
140142
140142   % MONITOR FUNCTION, REMOVING RT-PROG FROM I/O WAIT
140142   RIOWA: X=:B; IF X:=RTRES=0 GO MONEN
140146          X.STATUS BZERO 5WAIT=:X.STATUS
140151          GO STUPR
140152   *)FILL
140154   *"8N500 -8F5UD
"140154   RBUS
140154
140154
140154   %=============================================================================
140154   %       S T A P R O C     S W I T P R O C
140154   %
140154   % Entry: X=current message (=MESSAGE)
140154   %        B=nd-500 cpu datafield
140154   %
140154   SUBR NSTOPROC,STAPROC,SWITPROC
140154   SYMBOL PRSWITCH=502                                        % PROCESS SWITCH MONITOR CALL
140154
140154   % Entry: X=current message (=MESSAGE)
140154   %        B=nd-500 cpu datafield
140154   %
140154   INTEGER CN5STATUS,BREG
140156
140156   STAPROC:                                                   % Start process
140156   SWITPROC:                                                  % Switch process (stop current and restart another one)
140156          T:=5MBBANK; *AAX NPROC; LDDTX                       % A=proc.no, D=magno
140161          IF A<=5SWPROC OR A >> MX5PROCS GO ILPROC            % Legal process number?
140167          A-5SWPROC*5PRDSIZE+"S500S"; X:=A.MESSBUFF
140174          T:=5MBBANK; *AAX MAGNO; LDATX                       % A=magno
140177          *AAX XADPR-MAGNO; LDXTX                             % X=process descr.
140201          IF A><D OR X.RTRES = 0 THEN                         % Illegal magno or process not in use?
140205   ILPROC:   A:=EILPROC; X:=N5MESSAGE; CALL EMONICO           %
140210             CALL XACTRDY
140211             GO NXTMSG
140212          FI
140212          % - If process stopped (by stoppr etc.) then restart it
140212          X.PSTAT=:D; X:=X.MESSBUFF
140215          CALL RN5STATUS
140216          IF D BIT T5BUFF AND A=STOPPED OR A=I5TMQ THEN
140226             A=:D; CALL GCPUDF; CALL ERRFATAL; A:=:B=:BREG
140233             IF D=STOPPED THEN
140236                IF BREG><B THEN
140241   *NNT09=*
140241                   CALL XTER500; 0/\0
140243                FI
140243                CALL OKMONICO
140244             ELSE                                             % Restart process
140245                CALL FR5TMQU
140246                CALL SLOCK; 0/\0
140250   *NNT10=*
140250                CALL XTER500; 0/\0
140252                A:=1; CALL SPITMQ
140254                CALL ITO500XQ
140255                CALL SUNLOCK
140256             FI
140256             CALL XACTRDY
140257             IF BREG><B THEN
140262   *NNA05=*
140262                CALL XACT500
140263             FI
140263             BREG=:B
140265          ELSE
140266             CALL SLOCK; 0/\0
140270             T:=5MBBANK; *AAX 5MSFL; LDATX
140273             A BONE 55REP; *STATX
140275             CALL SUNLOCK
140276          FI
140276          X:=N5MESSAGE; T:=5MBBANK; *AAX MCNO; LDATX; AAX -MCNO
140303          IF A><PRSWITCH THEN
140306             CALL OKMONICO                                    % If mon switch-process then stop current
140307             CALL XACTRDY
140310             GO NXTMSG
140311          FI                                                  % ..else continue in stoppr
140311
140311
140311   NSTOPROC:                                                  % STOP PROCESS
140311          CALL SLOCK; 0/\0
140313          T:=5MBBANK; *AAX 5MSFL; LDATX
140316          IF A BIT 55REP THEN                                 % REP BIT SET?
140320             A BZERO 55REP; *STATX; AAX -5MSFL                % YES, RESET REP BIT
140323             CALL SUNLOCK
140324             CALL OKMONICO                                    % AND RESTART ND-500 PROC.
140325             CALL XACTRDY
140326          ELSE
140327             CALL SUNLOCK
140330             STOPPED; X:=N5MESSAGE; CALL WN5STATUS             % MARK PROC. IS STOPPED BY MON STOPR
140333          FI
140333          GO NXTMSG
140334   RBUS
140363
140363
140363   %===============================================================================
140363   %       Monitor call   M 5 T M O U T
140363   %
140363   % ENTRY: X=current message (=MESSAGE)
140363   %        B=nd-500 cpu datafield
140363   %
140363   SUBR M5TMOUT
140363   INTEGER CTM1=?,CTM2=?; DOUBLE CC5ATM=?
140363   INTEGER CRREASON=?
140363
140363   M5TMOUT: CALL SLOCK; 0/\0
140365            T:=5MBBANK; *AAX 5MSFL; LDATX                     % A=message flag
140370            IF A BIT 55REP THEN                               % Rep bit set?
140372                A BZERO 55REP; *STATX                         % Yes, reset rep bit
140374                CALL SUNLOCK
140375                A:=-1
140376   N5TMF:       A=:CRREASON; X:=N5MESSAGE                     % Reason for restarting after mon 5tmout
140400   *NNT11=*
140400                CALL XTER500; 0/\0
140402                A:=CRREASON; CALL SPITMQ
140404                CALL XACTRDY
140405                GO NXTMSG
140406            FI
140406            CALL SUNLOCK
140407            X:=N5MESSAGE; T:=5MBBANK; *AAX 5ADP1; LDDTX       % AD=no. of time units
140413            IF A><0 THEN
140414   LILP1:      X:=N5MESSAGE; A:=EC174
140416               CALL EMONICO
140417               CALL XACTRDY
140420               GO NXTMSG                                      % Restart nd-500 proc with error code
140421            FI
140421            IF D=0 GO N5TMF                                   % Restart with restart reason=0 when zero number of time units
140423            D=:L; *AAX 5ADP2-5ADP1; LDDTX                     % AD=time unit
140426            IF A><0 OR D-1>>3 GO LILP1                        % Time unit 1-4 is legal
140433            A:=D SH 1; 8CLCN(A)
140437            T:=L; 0=:X=:L
140442            DO WHILE T><0                                     % Compute time in basic time units
140444                IF T BIT 0 THEN L+D; X+A+C FI
140450                T SHZ -1; AD SH 1
140452            OD; D:=X; A:=L; A+"N500DF".5ATM2; A:=:D; A:=A+C+X.5ATM1
140462            AD=:CC5ATM                                        % Time when the proc. should be restarted
140463            X:=N5MESSAGE; T:=5MBBANK; *AAX D5TM1; STDTX; AAX -D5TM1
140470            CALL SLOCK; 0/\0
140472            CALL IFM500XQ
140473            I5TMQU; CALL WN5STATUS
140475            AD:=CC5ATM; D-; *COPY CM1 ADC SA DA
140500            AD=:CC5ATM
140501            X:="N500DF".X500DF; *AAX X5BTI
140504            DO
140504               X=:L; T:=5MBBANK; *LINK@3 LDDTX
140507            WHILE D><-1
140512   *NNC16,     CNVBYADR
140515               X:=D; T:=5MBBANK; *AAX D5TIM; LDDTX; AAX -D5TIM
140522               A:=:D; A+CTM2; A:=:D; A:=A+C+CTM1
140527            WHILE A<0
140530            OD; GO INSERT
140532   *)FILL
140550   INTEGER CTM1,CTM2; DOUBLE CC5ATM=CTM1
140552   INTEGER CRREASON
140553
140553   INSERT:  X:=L; T:=5MBBANK; *LINK@3 LDDTX
140556            X:=N5MESSAGE; *LINK@3 STDTX
140560            IF D><-1 THEN
140563   *NNC17,     CNVBYADR
140566               T:=A; X=:A:=D; *AAX PLINK; STATX
140573            FI
140573            T:=5MBBANK; X:=N5MESSAGE; *AAX PLINK; LDATX
140577            A=:N5MESSAGE:=L; *STATX; AAX -PLINK
140603            A:=T; D:=X
140605   *NNC18,  CNVWADR
140610            X:=:L; *LINK@3 STDTX
140612            T:=5MBBANK; X:=L; *AAX 5MSFL; LDATX
140616            A BONE 5ITMQUEUE; *STATX
140620            CALL SUNLOCK
140621            GO NXTMSG
140622   RBUS
140627
140627   SUBR NINSTR,XNINSTR
140627   RBUS
140627   %===============================================================================
140627   %       D V I O           N O U T S T R
140627   %
140627   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
140627   %        B=ND-500 CPU DATAFIELD
140627   %
140627   SUBR DVIO,NOUTSTR,OSTRS,PT5RST
140627   DVIO:
140627   NOUTSTR:
140627          CALL 5GTDF; GO NORMMC                               % IF TERMINAL GET ADDR OF DATAFIELD
140631          A:=D; X:=N5MESSAGE; T:=5MBBANK; *AAX TODF; STATX    % TODF=OUTPUT DATAFIELD
140636          *AAX DNOBY-TODF; LDDTX; AAX -DNOBY
140641          IF A><0 OR D>>4000 THEN                             % 4000B BYTES IS MAX BECAUSE OF "COM.BUFFER SIZE"
140645             A:=EC174; CALL EMONICO                           % RESTART ND-500 PROC WITH ERROR CODE
140647             CALL XACTRDY
140650             GO NXTMSG
140651          ELSE IF D=0 THEN                                    % ZERO BYTES?
140654             CALL OSTRS; GO NXTMSG                            % RESTART PROCESS
140656          FI; FI
140656          IF MIFLAG NBIT WSMC THEN                            % IS DATA-BUFFER IN COM-BUFFER? (BY MIC.PROG)
140661             T:=5MBBANK; 3RMED; *STATX XMICF                  % NO, MIC.FUNC=READ DATA MEMORY
140664             A:=D; *AAX NRBYT; STATX                          % NUMBER OF BYTES TO READ
140667             *AAX 5DITN-NRBYT; STZTX
140671             *AAX OSTRA-5DITN; LDDTX; AAX N500A-OSTRA; STDTX  % ND-500 LOGICAL DATA ADDR
140675             *AAX ABUFA-N500A; LDDTX; AAX N100A-ABUFA; STDTX  % ND-100 PHYSICAL ADDR
140701             "STTDRIV"; *AAX SPFLA-N100A; STATX; AAX -SPFLA   % RESTART IN STTDRIV
140705             MSGN500; CALL WN5STATUS
140707             CALL XACTRDY
140710             GO NXTMSG
140711          FI
140711          GO STTDRIV
140712   *)FILL
140725
140725
140725   %      S T T D R I V
140725   %
140725   %      START TERMINAL DRIVER.    CALLED WHEN THE LOGICAL DATA READ
140725   %      IS FINISHED IN DIRECT OUTSTRING TO TERMINAL
140725   %      ND-500 DRIVER LEVEL
140725   %
140725   %      X=ND-500 MESSAGE ADDR
140725   %
140725   INTEGER CCMESS
140726   STTDRIV: X=:CCMESS
140727          T:=5MBBANK; *AAX TODF; LDATX; COPY SA DB            % B=TERMINAL OUTPUT DATAFIELD
140733          *AAX LBUFA-TODF; LDATX; AAX 5HENT-LBUFA; STATX      %
140737          *AAX SPFLA-5HENT; STZTX; AAX -SPFLA                 % 0=:MESSAGE.SPFLAG
140742          X=:A:=:B; T:="ON5MSG"; CALL XSTDFADDR
140746          IF X.TYPRING BIT 5BAD THEN
140751             "L12STDV"
140752          ELSE
140753   %         T:="BHOLD"; CALL XGTDFADDR
140753   %         T:="SBHOLD"; CALL XSTDFADDR
140753             T:="XNOCHAR"; A:=0; CALL XSTDFADDR
140756             "L3STDV"
140757          FI
140757          X:=:B; A=:MFUNC
140761          N5IOWAIT; CALL WN5STATUS                            % MARK PROC. IN I/O WAIT
140763          CALL GCPUDF; CALL ERRFATAL; A=:X                    % X=ND-500 CPU DF.
140766          CALL RTACT                                          % START TERMINAL OUTPUT DRIVER FROM MONITOR LEVEL
140767          X=:B; GO NXTMSG                                     % B=ND-500 CPU DF.
140771   *)FILL
141004
141004
141004   %      O S T R S
141004   % OUTSTRING RESTART - ND-500 DRIVER LEVEL (LEVEL 12)
141004   % ENTRY:     X=ND-500 MESSAGE ADDR
141004   INTEGER POINTER O INCREMENT  -
137035                   D+1; A:=A+C; *STDTX                        % MONITOR CALL COUNT
137040                   X:=N5MESSAGE
137041                FI
137041             FI
137041          FI
137041          CALL PML50                                          % PERFORMANCE LOGGING
137042          T:=5MBBANK; *AAX XADPR; LDATX
137045          A=:PROCAD                                           % PROCESS DESCR. OF CURRENT PROC.
137046          *AAX MCNO-XADPR; LDATX; AAX SMCNO-MCNO; STATX       % SAVE MON.CALL NUMBER IN SMCNO
137052          IF A=2TUSED THEN                                    % MON TIME-USED?
137055             CALL MBSUSPROC
137056             T:=5MBBANK; X:=N5MESSAGE; *AAX 500TU; LDDTX      % AD=ND-500 CPU-TIME USED (500TUSED)
137062             T:=0; X:=N5MESSAGE; CALL MONICO                  % RESTART ND-500 PROC
137065             CALL XACTRDY
137066             GO NXTMSG; *)FILL                                % HANDLE NEXT PROC. IN ND-500 EX-QUEUE
137102    STLREG
141005
141005   OSTRS: A:=L=:"OSTLREG"
141007          CALL GCPUDF; CALL ERRFATAL; A=:B
141012          T:=5MBBANK; *AAX SMCNO; LDATX; AAX -SMCNO   % A=monitorcall number
141016          IF A=511 THEN                               % DVIO
141021             T:=5MBBANK
141022             *AAX 11DMA; LDDTX                        % Load max number of bytes and coninue
141024             *AAX -11DMA                              % In instring
141025             X=:N5MESSAGE; CALL XNINSTR               % XNINSTR in NINSTR routine (mon DVINST)
141027          FI
141027          CALL OKMONICO
141030          CALL XACT500                                % Restart ND-500(0) proc. after mon DVOUTST
141031          GO OSTLREG                                  %
141032   *)FILL
141042
141042
141042   %      L 1 2 S T D V
141042   % Special stdev routine to start TAD output driver
141042   %
141042   L12STDV: *IOF
141043          A:=X;     *IRW  LV10B DB
141045          "BDROUT"; *IRW  LV10B DP
141047          LV10;     * MST  PID
141051          *ION
141052          GO MONEN
141053   *)FILL
141056
141056
141056   %      P T 5 R S T
141056   %      RESTART ND-500 FROM THE TERMINAL OUTPUT DRIVER  (LEVEL 10)
141056   %      MUST BE CALLED WITH INTERRUPT OFF
141056   %
141056   %      ENTRY:    X = ND-500 PROCESS MESSAGE
141056   PT5RST: A:=X; *IRW LV12B DX
141060           "CALLID12"; *IRW LV12B DL
141062           "OSTRS"; *IRW LV12B DP
141064           LV12; *MST PID
141066           EXIT
141067   RBUS
141072
141072
141072   %============================================================================
141072   %      N I N S T R
141072   %      X N I N S T R
141072   %
141072   % MONITOR CALL DVIO AND DVINST
141072   % LEVEL 12.
141072   %
141072   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141072   %        B=ND-500 CPU DATAFIELD
141072   %
141072   SUBR NINSTR,XNINSTR
141072   INTEGER CCMESS=?,CWNDMESS=?,BREG=?
141072
141072   NINSTR:  T:=5MBBANK; X:=N5MESSAGE
141074            *AAX DMAXB; LDDTX; AAX -DMAXB        % AD=MAX. BYTECOUNT
141077   XNINSTR:
141077          IF A><0 OR D>>4000 THEN                % 4000B BYTES IS THE MAX. DUE TO THE SIZE OF "COMM.BUFFERS"
141103            X:=N5MESSAGE; A:=EC174
141105            CALL EMONICO
141106            CALL XACTRDY
141107            GO NXTMSG                            % RESTART ND-500 PROC WITH ERROR CODE
141110          FI
141110          A:=B=:BREG
141112          CALL 5GTDF; GO NORMMC                  % NOT TERMINAL OR TAD
141114          IF A.TYPRING BIT 5BAD THEN
141120             X:=N5MESSAGE; GO NORMMC
141122          FI
141122          X=:B; N5MESSAGE=:CCMESS                % SAVE CURRENT MESSAGE ADDR IN CCMESS
141125          CALL SET12WINDOW                       % SET UP TERMINAL WINDOW
141126          IF FLAGB BIT 5LSTA THEN                % HAVE WE LOST OUR TERMINAL?
141131             X:=CCMESS; 0=:IN5MSG
141133             CALL GCPUDF; CALL ERRFATAL; A=:B
141136             A:=316; CALL EMONICO                % TERMINAL LINE IS NOT CONNECTED
141140             CALL XACTRDY
141141             GO FAR XCLPITS                      % CLEAR PIT ENTRIES
141142          FI
141142          A:=CCMESS/\1777+"WNDN5*2000"=:CWNDMESS % LOGICAL ADDR OF ND-500 MESSAGE
141146          T:=5MBBANK SH 6; A:=CCMESS SHZ -12
141152          A+T=:D:=142000
141155          T:=0; X:="WNDN5+WNDN5+174000"; *STDTX  % SET PITENTRY
141160          A:=CWNDMESS.5BRST                      % A=BREAK STRATEGY
141162          IF A=-1 THEN 0=:BRKTAB; GO NOBRK FI    % NO BREAK
141167          IF A<<11 THEN
141172             IF A = 7 THEN                       % USER SUPPLIED BREAK STRATEGY
141175                A:="5BRKTAB"; T:="PBRK7"         % DISPLACEMENT IN MSG AND DF
141177                CALL FAR MOVTAB                  % COPY BREAK TABLE FROM MESS TO DF
141200                A:="PBRK7"+B=:BRKTAB             % SET ADDR OF BRKTAB IN INPUT DF.
141203                GO NOBRK
141204             FI
141204             IF A=10 THEN                        % USE PREVIOUS USER SUPPLIED BREAK STRATEGY
141207                A:="PBRK7"+B=:BRKTAB
141212                GO NOBRK
141213             FI
141213             A:=BRKTB(A)=:BRKTAB                 % USE ONE OF THE SYSTEM INCLUDED BREAK TABLES
141216             X:=CWNDMESS
141217          FI; GO NOBRK; *)FILL
141245
141245   INTEGER CCMESS,CWNDMESS
141247   INTEGER BREG
141250
141250   NOBRK: A:=X.5ECHS                             % ECHO STRATEGY
141251          IF A=-1 THEN 0=:ECHOTAB; GO NECHO FI   % NO ECHO
141256          IF A<<11 THEN
141261             IF A = 7 THEN                       % USER SUPPLIED ECHO STRATEGY
141264                A:="5ECHTAB"; T:="PECH7"         % A=DISP IN MESS; T=DISP IN TERM INPUT DF.
141266                CALL FAR MOVTAB                  % COPY FROM ND-500 MESS TO TERM.INPUT DF.
141267                A:="PECH7"+B=:ECHOTAB            % SET ADDR OF ECHO TABLE IN TERM.INPUT DF.
141272                GO NECHO
141273             FI
141273             IF A=10 THEN
141276                A:="PECH7"+B=:ECHOTAB            % USE PREVIOUS USER SUPPLIED ECHO TABLE
141301                GO NECHO
141302             FI
141302             ECHTB(A)=:ECHOTAB                   % USE ONE OF THE 8 SYSTEM INCLUDED ECHO TABLES
141305             X:=CWNDMESS
141306          FI; GO NECHO; *)FILL
141313
141313   NECHO: X:=CCMESS; N5IOWAIT; CALL WN5STATUS    % MARK PROCESS IS IN I/O-WAIT
141316          0=:CWNDMESS.5FYLLE                     % CLEAR SOME FLAGS
141320          0=:X.MLFLAG=:X.SPFLAG
141322          IF X.SMCNO=511 THEN                    % WHICH MONITOR CALL IS IT
141326             X.11MXBRK                           % MON DVIO
141327          ELSE
141330             X.MAXBYT                            % MON DVINST
141331          FI; A=:BRKMAX                          % SET MAX. CHAR BEFORE BREAK
141332          CCMESS=:IN5MSG                         % IN5MSG=ADDR OF ND-500 MESSAGE (USED BY TERM.INPUT DRIVER)
141334          IF BHOLD><0 THEN                       % ANY CHARACTERS IN TERMINAL INPUT BUFFER?
141336             1=:X.MLFLAG                         % YES, MARK THAT MONITOR LEVEL IS STARTED.
141340             "IBMOVE"=:TDRADDR.MFUNC; CALL CXRTACT
141344          ELSE
141345             IF TDRADDR.ISTAT = -1 OR = -2 THEN  % IS IT NOWAIT?
141355                0=:IN5MSG                        % YES, GIVE END-OF-FILE ERROR MESSAGE
141356                IF CWNDMESS.SMCNO=511 THEN       % WHICH MONITOR CALL IS IT?
141363                   A:=0=:D; AD=:X.11NOCHRET      % MON DVIO; SET NUMBER OF RETURNED BYTES
141366                   100000=:X.NUMPAR              % SET MONITOR CALL WRITE-BACK MASKE
141370                ELSE
141371                   A:=0=:D; AD=:X.NOCHRET        % MON DVINST; SET NUMBER OF RETURNED BYTES.
141374                   4=:X.NUMPAR                   % SET MONITOR CALL WRITE-BACK MASKE
141376                FI
141376                X:=CCMESS; A:=3; CALL EMONICO    % GIVE END-OF-FILE ERROR RETURN
141401                CALL XACTRDY
141402             FI; DFLAG BONE 5ECHO=:DFLAG         % GIVE ECHO CONTROL TO TERMINAL DRIVER
141405          FI
141405   CLPITS:
141405   XCLPIT: T:=0; X:="WNDN5+WNDN5+174000"; *STZTX % CLEAR USED PIT ENTRY (TERM. WINDOW WILL BE RESET IN WT12)
141410           BREG=:B
141412           GO NXTMSG
141413   *)FILL
141424
141424   %      M O V T A B
141424   % MOVE BREAK/ECHO TABLE FROM THE ND-500 MESSAGE TO THE TERMINAL DATAFEIELD
141424   % LEVEL 12.
141424   %
141424   % ENTRY:     X=LOGICAL ADDR OF ND-500 MESSAGE
141424   %            B=LOGICAL ADDR OF TERMINAL INPUT DATAFIELD
141424   %            T=DISPLACEMENT IN THE DATAFIELD TO MOVE INTO
141424   %            A=DISPLACEMENT IN THE ND-500 MESSAGE TO MOVE FROM
141424   %
141424   MOVTAB: A+X=:D                                % D=LOGICAL ADDR. IN MESSAGE
141426          T+B; A:=10:=:L; *MOVAA                 % MOVE FROM MESAGE TO TERM.DF.
141432          A=:P                                   % EXIT
141433
141433   RBUS
141433
141433
141433   %============================================================================
141433   %      G E R R C
141433   %      GET ERROR CODE.  USED AFTER A PROGRAMMED TRAP.
141433   %      DRIVER LEVEL
141433   %
141433   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141433   %        B=ND-500 CPU DATAFIELD
141433   %
141433   SUBR GERRC
141433   GERRC: T:=5MBBANK; *5RECE@3 LDATX
141435          A-5SWPROC+1*REGBSZ+"ERREG"=:T
141442          "N500DF".CNTXPAGE+X.ADRZERO=:D:=0
141447          AD SHZ 12; D+T; A:=A+C; X:=D; T:=A; *LDDTX
141455          *STZTX; AAX 1; STZTX
141460          X:=N5MESSAGE; T:=5MBBANK; *AAX M505E; STDTX
141464          A:=1; *AAX NUMPA-M505E; STATX
141467          A:=0=:D; *AAX FUNCV-NUMPA; STDTX
141473          *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
141476          3MONCO; *MICFU@3 STATX
141500          CALL MCCO
141501          CALL XACTRDY
141502          GO NXTMSG
141503   RBUS
141514
141514
141514   %============================================================================
141514   %      5 S I B M O
141514   %      SPECIAL MONITOR CALL FROM SIBAS SERVER IN ND-500
141514   %      DRIVER LEVEL
141514   %
141514   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141514   %        B=ND-500 CPU DATAFIELD
141514   %
141514   SUBR 5SIBMO
141514   INTEGER CSIBNO,CSIBDF
141516   5SIBMO: T:=5MBBANK; *AAX SIBNO; LDDTX
141521          IF A><0 OR D>>MXSIBAS OR T=0 THEN            % ILLEGAL SIBAS NUMBER
141527            X:=N5MESSAGE; A:=EC174
141531            CALL EMONICO                               % RESTART ND-500 PROC WITH ERROR CODE
141532            CALL XACTRDY
141533            GO NXTMSG
141534          FI
141534          X:=D=:CSIBNO:=SIBBDEVS(X)=:D=:CSIBDF
141541          IF X.RTRES><PROCAD.RTRES THEN                % IS THE ACTUAL SIBAS DF. RESERVED BY ANOTHER?
141546             X:=N5MESSAGE; 5; CALL EMONICO             % YES, GIVE ERROR RETURN
141551             CALL XACTRDY
141552             GO NXTMSG
141553          FI; 1=:D.SIB500                              % MARK THAT THIS SIBAS IS RUNNING IN ND-500
141556          X:=SIBAPDEVS(CSIBNO)=:D; 0=:X.SRTCSTAT       % MARK THAT SIBAS IS WAITNG FOR A REQUEST?
141562          X=:CSIBNO                                    % ADDR OF MON MAPSIB WORKING FIELD
141563          IF X:=X.RTRES><0 AND X.STATUS BIT 5WAIT THEN % ANY PROGRAMS WAITNG TO BE RESTARTED BY SIBAS?
141570             D:=:B; CALL RTACT; B:=D                   % YES, RESTART IT
141573          FI; A:=CSIBDF.TTMR=:X.TMR                    % START TIMER
141576          X:=N5MESSAGE; T:=5MBBANK; *AAX SIBST; LDDTX; AAX -SIBST
141603          IF A=0 AND D=0 GO FAR NSTOPROC               % SIBAS SHOULD BE SET IN STOPPED STATUS
141606          1=:CSIBNO.SRTCSTAT; 0=:CSIBDF.TMR            % MARK SIBAS IS ACTIVE
141613          X:=N5MESSAGE; CALL OKMONICO                  % REACTIVATE SIBAS
141615          CALL XACTRDY
141616          GO NXTMSG
141617   RBUS
141633
141633
141633   %============================================================================
141633   %      S P R I O
141633   %      SET PRIORITY
141633   %      DRIVER LEVEL.
141633   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141633   %        B=ND-500 CPU DATAFIELD
141633   %
141633   SUBR SPRIO
141633   SPRIO: T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL % A=MESSAGE FLAG
141637          IF A BIT SPROK THEN                       % SET PRIORITY ALLOWED FOR THIS PROC?
141641             T:=5MBBANK; *AAX 100; LDDTX; AAX -100  % YES, GET NEW PRIORITY
141645             IF A><0 THEN EC174R; GO SPERET FI      %
141650             D=:A
141651             IF A=0 THEN                            % IF=0 THEN PROC. SHOULD BE TIMESLICED
141652                *AAX XADPR;  LDXTX                  % X=ADDR OF PROC.DESCR
141654                X.PSTAT BONE 55BRKPRIOR BONE SLICE=:X.PSTAT % MARK PROCESS IS TIMESLICED
141660                5BRKPRIOR; X:=N5MESSAGE; *AAX 5PRIO; STATX  % SET NEW PRIORITY
141664                CALL OKMONICO                       % RESTART PROCESS
141665             ELSE
141666                IF A >>= 300 THEN                   % PRIORITY WITHIN LEGAL RANGE?
141671                   A:=EC174R; GO SPERET             % NO, GIVE ERROR RETURN
141673                FI
141673                T:=5MBBANK; *AAX 5PRIO; STATX       % SET NEW PRIORITY
141676                *AAX XADPR-5PRIO; LDXTX             % X=ADDR OF PROC.DESCR.
141700                X.PSTAT BZERO SLICE=:X.PSTAT        % MARK PROC. NOT TIMESLICED
141703                X:=N5MESSAGE
141704                CALL SLOCK; GO N500ERR
141706   *NNT12=*
141706                CALL XTER500; GO FAR N500ERR
141710                CALL OKMONICO                       % RESTART PROCESS
141711                CALL IFM500XQ
141712                T:=5MBBANK; *AAX PLINK; LDATX; AAX -PLINK
141716                A=:N5MESSAGE
141717                CALL ITO500XQ                       % REORGANIZE EX-QUEUE ACCORDING TO PRIORITY
141720                CALL SUNLOCK
141721                CALL XACTRDY
141722             FI
141722          ELSE
141723             A:=EPRMC                               % SPRIO NOT ALLOWED
141724   SPERET:   T:=5MBBANK; X:=N5MESSAGE; CALL EMONICO % GIVE ERROR RETURN
141727             CALL XACTRDY
141730          FI; GO NXTMSG
141731   N500ERR: CALL XRSTARTALL; GO CALLID12             % RESTART ALL PROCS.
141733
141733   RBUS
141753
141753
141753   %============================================================================
141753   %      S W M C
141753   %      MONITOR CALL TO THE SWAPPER
141753   %      DRIVER LEVEL
141753   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141753   %        B=ND-500 CPU DATAFIELD
141753   SUBR SWMC
141753   SWMC:  MSM510 SHZ 10=:D; T:=5MBBANK; *AAX TRAPN; LDATX
141761          A/\377+D; *STATX; AAX -TRAPN
141765          CALL 5ACTSWAPPER; GO NXTMSG
141767   RBUS
141773
141773
141773   SUBR XMWK; RBUS
141773   %=============================================================================%
141773   %                                                                             %
141773   %      A 5 X M S G        B 5 X M S G                                         %
141773   %                                                                             %
141773   %      XMSG interface routines.  Executed on level 12                         %
141773   %                                                                             %
141773   %
141773   SUBR A5XMSG,B5XMSG
141773
141773   @ICR; % - Writeback masks for the different xmsg functions
141773         % - Bit number corresponds to parameter number in xmsg call
141773   INTEGER ARRAY XMRETMASK:=(
141773          16, 0, 4, 0,34, 0,20,20, 0,14, 2, 0, 0,74,34, 4,
142013           0, 0, 0, 0, 0, 0,34, 4, 0, 0, 0, 0, 0, 0, 0, 0,
142033          34, 0, 0, 0, 0, 0, 0, 4,70,360,14,0, 0, 0, 0,16);
142053   @CR;
142053   SYMBOL X5MASK=77             % mask for obtaining xmsg function number
142053   SYMBOL X5MAX=57              % max xmsg function number
142053   INTEGER XREG=?
142053   INTEGER AREG=?
142053
142053   A5XMSG:
142053   B5XMSG:
142053          X=:B; T:=5MBBANK; *AAX N5XFU; LDATX
142057          A/\X5MASK=:D                                  % Save xmsg-function in D-reg
142061          IF A-X5MAXF>0 GO X5EILF                      % Illegal function value?
142064          *AAX XTBLK-N5XFU; LDATX
142066          IF A=0 THEN                                   % Any xtblock allocated?
142067             IF XFDCT=D GO FAR X5LEAVE                  % Ignore call if xmsg-function=disconnect
142072             X:=B; *AAX HBUFA; LDATX                    % No, get one
142075             T:=XFDBK; L:=0; *MON 2XMSG                 % Allocate xtblock
142100             GO FAR X5LEAVE                             % Level 14 part finished
142101             IF T<0 GO FAR X5ERET                       % Check for error
142103             L=:A; X:=B; T:=5MBBANK                     % L=xtblock address obtained from xmsg
142106             *AAX XTBLK; STATX                          % Save it
142110             T:=XFWDF; "XMWK"; *MON 2XMSG               % Define wakeup routine
142113             GO FAR X5LEAVE                             % Level 14 finished
142114          FI
142114          X:=B; T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
142121   @ICR;
142121          A/\X5MASK GOSW
142121          FAR LFDUM, FAR LFDCT, LFGET, LFREL, LFRHD, LFWHD, LFREA, LFWRI,
142133          LFSCM, LFMST, FAR LFOPN, LFCLS, FAR LFSND, LFRCV, LFPST, LFGST,
142143          X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, FAR LFM2P, LFP2M,
142153          X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, LFPRV, LFRTN,
142163          LFRRH, X5EILF, X5EILF, X5EILF, X5EILF, LFDMM, LFALM, FAR LFFRM,
142173          LFLMP, FAR LFRRE, LFCPV, LFWRT, X5EILF, X5EILF, X5EILF, FAR LFGSM;
142203   @CR;
142203   *)FILL
142220
142220   %      Illegal function codes;  not implemented
142220   %
142220   %      LFSIN:    % 20 - Initialize for system functions
142220   %      LFSRL:    % 21 - Service release function (obsolete)
142220   %      LFABR:    % 22 - Absolute read from pof
142220   %      LFABW:    % 23 - Absolute write block to pof area (obsolete)
142220   %      LFMLK:    % 24 - Lock message system (obsolete)
142220   %      LFMUL:    % 25 - Unlock message system (obsolete)
142220   %      LFRIN:    % 30 - Routing initialize (obsolete)
142220   %      LFCRD:    % 31 - Create driver
142220   %      LFSTD:    % 32 - Start driver
142220   %      LFDIB:    % 33 - Define indirect buffer
142220   %      LFRIB:    % 34 - Read from indirect buffer
142220   %      LFWIB:    % 35 - Write to indirect buffer
142220   %      LFDUB:    % 41 - Define user buffer area for current message
142220   %      LFWDF:    % 42 - Define wakeup context (drivers only)
142220   %      LFDBK:    % 43 - Define bank number (drivers lnly)
142220   %      LFSMC:    % 44 - Start multi-call
142220
142220   X5EILF:   XEILF
142221   X5ILP:    AD SH -20; T:=1; X:=B; CALL MONICO
142225             CALL XACTRDY
142226   XNXTMSG:  X:=B; CALL GCPUDF; CALL ERRFATAL; A=:B; GO NXTMSG
142233   *)FILL
142240
142240   % input:         A:=2nd parameter
142240   %                D:=3rd parameter
142240   %                X:=4th parameter
142240   %
142240   LFPRV:           % 36 - Request privliges
142240           *AAX 5MSFL; LDATX; AAX -5MSFL
142243           IF A NBIT 5XMPRIV GO X5EILF
142245
142245   LFGET:           %  2 - Get a message buffer
142245   LFREL:           %  3 - Release a message buffer
142245   LFRHD:           %  4 - Read from header of message buffer
142245   LFWHD:           %  5 - Write to header of current message buffer
142245   LFSCM:           % 10 - Set current message
142245   LFMST:           % 11 - Message status
142245   LFCLS:           % 13 - Close a port
142245   LFRCV:           % 15 - Receive next message
142245   LFPST:           % 16 - Port status
142245   LFGST:           % 17 - General status
142245   LFP2M:           % 27 - Convert port number to magic number
142245   LFRTN:           % 37 - Return a message
142245   LFRRH:           % 40 - Receive and read header
142245   LFDMM:           % 45 - Dynamic definition of max task space
142245   LFCPV:           % 52 - Check system and user privileges
142245          *AAX 5ADP3; LDDTX; AAX 5DP2-5ADP3; LDATX; AAX 5DP4-5DP2; LDXTX
142253          GO MONXM
142254
142254   % input:         D:=2nd parameter
142254   %                X:=4th parameter
142254   %                A:=LBUFA
142254   %
142254   LFREA:           %  6 - Read from current message buffer      use B5XMSG
142254   LFWRI:           %  7 - Write to current message buffer       use B5XMSG
142254   LFWRT:           % 53 - Write and return message
142254          *AAX 5ADP2; LDDTX
142256          IF A><0 OR 4000<<D THEN XEITL; GO FAR X5ILP FI
142264          *AAX N5XFU-5ADP2; LDATX; AAX -N5XFU
142267          IF A/\X5MASK=7 OR A=53 THEN
142276             CALL GCPUDF; CALL ERRFATAL; A=:B
142301             IF MIFLAG NBIT WSMC THEN
142304                A:=D; T:=5MBBANK; *AAX NRBYT; STATX
142310                *AAX 5DITN-NRBYT; STZTX
142312                *AAX X5BUF-5DITN; LDDTX; AAX N500A-X5BUF; STDTX
142316                *AAX ABUFA-N500A; LDDTX
142320   *NNC19,      CNVWADR
142323                T:=5MBBANK; *AAX N100A-ABUFA; STDTX
142326                "INFWRIT"; *AAX SPFLA-N100A; STATX; AAX -SPFLA
142332                3RMED; *STATX XMICF
142334                MSGN500; CALL WN5STATUS
142336                CALL XACTRDY
142337                GO NXTMSG
142340   INFWRIT:     T:=5MBBANK; *AAX SPFLA; STZTX; AAX -SPFLA
142344             FI; X=:B
142345          FI
142345          T:=5MBBANK; *AAX 5ADP2; LDDTX
142350          *AAX LBUFA-5ADP2; LDATX; AAX 5DP4-LBUFA; LDXTX
142354          GO MONXM
142355
142355   % input:         AD:=2nd parameter
142355   %                 X:=3rd parameter
142355   %
142355   LFSND:           % 14 - Send current message
142355   LFM2P:           % 26 - Convert magic number to port and system number
142355          *AAX 5ADP2; LDDTX; AAX 5DP3-5ADP2; LDXTX
142361          GO MONXM
142362
142362   % input:         A:=2nd parameter
142362   %                X:=3rd parameter
142362   %
142362   LFALM:           % 46 - Allocate messages to a task
142362   LFLMP:           % 50 - List messages and ports
142362          *AAX 5DP2; LDATX; AAX 5DP3-5DP2; LDXTX
142366          GO MONXM
142367
142367   % input:         X:=2nd parameter
142367   %                A:=3rd parameter
142367   %
142367   LFFRM:           % 47 - Freeing allocated message buffers
142367          *AAX 5DP3; LDATX; AAX 5DP2-5DP3; LDXTX
142373          GO MONXM
142374
142374   % input:         A:=2nd parameter
142374   %                D:=3rd parameter
142374   %                X:=lbufa
142374   %
142374   LFRRE:           % 51 - Receive and read message
142374          *AAX 5ADP3; LDDTX
142376          IF A><0 OR 4000<<D THEN XEITL; GO FAR X5ILP FI
142404          *AAX 5DP2-5ADP3; LDATX
142406          *AAX LBUFA-5DP2; LDXTX
142410          GO MONXM
142411
142411   % input:         none
142411   %
142411   LFDUM:           %  0 - Dummy xmsg call
142411   LFDCT:           %  1 - Disconnect from xmsg
142411   LFOPN:           % 12 - Open a port
142411   LFGSM:           % 47 - General status multiple
142411   MONXM: T:=5MBBANK; X=:XREG:=B; A=:AREG; *AAX XTBLK; LDATX
142417          A=:L; *AAX N5XFU-XTBLK; LDATX
142422          A=:T:=AREG; X:=XREG; *MON 2XMSG                      % Starts an xmsg function
142426          GO X5LEAVE; GO X5RET
142430
142430   *)FILL
142443
142443
142443   %-------------------------------------------------------------
142443   %
142443   %      Level 14 part of xmsg finished.
142443   %
142443
142443   X5LEAVE: X:=B; T:=5MBBANK; *AAX N5XFU; LDATX
142447            IF A/\X5MASK-XFDCT=0 THEN                   % Disconnect function?
142452                 X:=B; *AAX XTBLK; STZTX
142455                 A:=1; AD SHZ -20; T:=0; X:=B
142461                 CALL MONICO                            % Return to user imediately
142462                 CALL XACTRDY
142463            ELSE                                        % Function was disconnect
142464                 N5XMWAIT; X:=B; CALL WN5STATUS
142467            FI; GO FAR XNXTMSG
142470
142470   *)FILL
142476
142476
142476   %-------------------------------------------------------------
142476   %
142476   %      XMSG function finished and level 12 restarted here
142476   %
142476
142476   INTEGER TREG,AREG,DREG,XREG
142502   TRIPLE  TADREG=TREG; DOUBLE ADREG=AREG
142502
142502   X5RET:
142502          TAD=:TADREG; X=:XREG
142504          IF "N500DF".SYSINITFLAG BIT B5STOP GO WT12
142510          X:=B; CALL RN5STATUS
142512          IF A><N5XMWAIT THEN                           % Process should be waiting for xmsg kick. yes?
142515             T:=5MBBANK; *AAX XTBLK; LDATX; STZTX       % No, forget xmsg call and disconnect xmsg port
142521             IF A><0 THEN
142522                A=:L; T:=XFDCT; *MON 2XMSG; RAND
142526             FI
142526             X:=B; CALL GCPUDF; GO WT12; A=:B; GO CALLID12
142533          FI
142533          T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
142537          A/\X5MASK=:L
142541          IF T:=TREG<0 GO FAR X5ERET
142544          IF T=0 AND 6=L OR 51=L GO FAR X5ERET
142554          T=:A:=5MBBANK; AD SH -20; *AAX FUNCV; STDTX
142561          *AAX KFLIP-FUNCV; STZTX
142563          AD:=ADREG; X:=XREG:=:B
142566   @ICR
142566          L GOSW
142566          RFDUM, X5FATAL, RFGET, FAR RFREL, RFRHD, FAR RFWHD, RFREA, RFWRI,
142577          FAR RFSCM, RFMST, RFOPN, FAR RFCLS, FAR RFSND, RFRCV, RFPST, RFGST,
142607          X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, RFM2P, RFP2M,
142617          X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, FAR RFPRV, FAR RFRTN,
142627          RFRRH, X5FATAL, X5FATAL, X5FATAL, X5FATAL, FAR RFDMM, FAR RFALM, RFFRM,
142637          RFLMP, RFRRE, RFCPV, FAR RFWRT, X5FATAL, X5FATAL, X5FATAL, FAR RFGSM;
142647   @CR;
142647   *)FILL
142672
142672   %      Fatal error  (illegal function codes)
142672   %
142672   X5FATAL:
142672          CALL ERRFATAL
142673
142673   % output:        A=:2nd parameter
142673   %                D=:3rd parameter  /  AD=:3rd parameter
142673   %                X=:4th parameter
142673   %
142673   RFDUM:; RFOPN:; RFGSM:
142673          *AAX 5AP2; STZTX; AAX 5DP2-5AP2; STATX; AAX -5DP2
142700          A:=0
142701   RFP2M:; RFMST:
142701          *AAX 5ADP3; STDTX
142703          A:=0; B=:D; *AAX 5ADP4-5ADP3; STDTX; AAX -5ADP4
142710          GO FAR X5L1
142711
142711   % output:        A=:3rd parameter
142711   %                D=:4th parameter
142711   %                X=:5th parameter
142711   %                T=:6th parameter
142711   %
142711   RFRCV:; RFRRH:; RFRHD:; RFPST:; RFM2P:
142711   RFCPV:; RFGET:; RFGST:; RFFRM:
142711          *AAX 5AP3; STZTX; AAX 5DP3-5AP3; STATX
142715          A:=0; *AAX 5ADP4-5DP3; STDTX
142720          A:=B; AD SH -20; *AAX 5ADP5-5ADP4; STDTX
142724          *AAX FUNCV-5ADP5; LDDTX
142726          *AAX 5ADP6-FUNCV; STDTX; AAX -5ADP6
142731          GO FAR X5L1
142732
142732   % output:        A=:4th parameter
142732   %                D=:5th parameter
142732   %                X=:6th parameter
142732   RFWRI:; RFLMP:
142732          *AAX 5AP4; STZTX; AAX 5DP4-5AP4; STATX
142736          A:=0; *AAX 5ADP5-5DP4; STDTX
142741          B=:D; *AAX 5ADP6-5ADP5; STDTX; AAX -5ADP6
142745          GO X5L1
142746   *)FILL
142750
142750   % output:        D=:5th parameter=:26nrb
142750   %                x5buf=:26add
142750   %
142750   RFREA:
142750          A:=0; *AAX 5ADP5; STDTX; AAX -5ADP5
142754          GO INRFRRE
142755
142755   % output:        A=:5th parameter
142755   %                D=:6th parameter
142755   %                X=:7th parameter=:26nrb
142755   %                T=:8th parameter
142755   %                x5buf=:26add
142755   %
142755   RFRRE:
142755          *AAX 5AP5; STZTX; AAX 5DP5-5AP5; STATX
142761          A:=0; *AAX 5ADP6-5DP5; STDTX
142764          *AAX FUNCV-5ADP6; LDDTX; AAX 5ADP8-FUNCV; STDTX
142770          A:=B; AD SH -20; *AAX 5ADP7-5ADP8; STDTX
142774          *AAX FUNCD-5ADP7; LDATX; AAX -FUNCD
142777          IF A=4 THEN
143002             T:=5MBBANK; *AAX 26NRB; STZTX; AAX -26NRB
143006             GO X5L1
143007          FI
143007   INRFRRE:
143007          CALL GCPUDF; CALL ERRFATAL; A=:B
143012          T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
143016          A/\X5MASK=:L
143020          IF MIFLAG BIT WSMC THEN
143023             A:=D; *AAX 26NRB; STATX; AAX SM26N-26NRB; STATX
143030             IF 51=L THEN
143033                *AAX X5BUF+2-SM26N; LDDTX; AAX 26ADD-X5BUF-2
143036             ELSE
143037                *AAX X5BUF-SM26N; LDDTX; AAX 26ADD-X5BUF
143042             FI; *STDTX; AAX SM26A-26ADD; STDTX; AAX -SM26A
143046          ELSE
143047             D=:L; *AAX FUNCV; LDDTX; AAX 134-FUNCV; STDTX
143054             A:=L; *AAX NRBYT-134; STATX
143057             *AAX 5DITN-NRBYT; STZTX; AAX -5DITN
143062             IF 51=L THEN
143065                *AAX X5BUF+2; LDDTX; AAX N500A-X5BUF-2
143070             ELSE
143071                *AAX X5BUF; LDDTX; AAX N500A-X5BUF
143074             FI; *STDTX
143075             *AAX ABUFA-N500A; LDDTX; AAX N100A-ABUFA; STDTX
143101             "INFRRE"; *AAX SPFLA-N100A; STATX; AAX -SPFLA
143105             3WMED; *STATX XMICF
143107             MSGN500; CALL WN5STATUS
143111             CALL XACT500
143112             GO CALLID12
143113   INFRRE:   T:=5MBBANK; *AAX SPFLA; STZTX
143116             *AAX 134-SPFLA; LDDTX; AAX FUNCV-134; STDTX
143122             *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
143125          FI; GO X5L1
143126   *)FILL
143136
143136   % output:        none
143136   %
143136   RFREL:; RFWHD:; RFSCM:; RFCLS:; RFSND:
143136   RFPRV:; RFRTN:; RFDMM:; RFALM:; RFWRT:
143136   X5L1:  X=:B; T:=5MBBANK; *AAX N5XFU; LDATX
143142          A/\X5MASK=:X=:L
143145          *1BANK
143146          XMRETMASK(X)
143147          *2BANK
143150          A=:D; X:=B; *AAX NUMPA; LDATX
143154          IF L=0 AND A-1=0 THEN D:=0; FI       % Dummy function with 1 param.?
143161          A:=D; *STATX
143163          *AAX N5XFU-NUMPA; LDATX; AAX -N5XFU
143166          A/\X5MASK=:D
143170          CALL GCPUDF; CALL ERRFATAL; A=:B
143173          IF MIFLAG BIT WSMC AND D=6 OR D=51 THEN 3WMONCO ELSE 3MONCO FI
143207   XX5RET: T:=5MBBANK; *MICFU@3 STATX
143211          CALL MCCO
143212          CALL XACT500
143213          GO CALLID12
143214
143214   X5ERET: 5MBBANK; A:=:T; X:=B
143217          AD SH -20; *AAX FUNCV; STDTX
143222          A:=1; *AAX KFLIP-FUNCV; STATX
143225          *AAX NUMPA-KFLIP; STZTX
143227          X:=B; CALL GCPUDF; CALL ERRFATAL; A=:B
143233          3MONCO; GO XX5RET
143235
143235   RBUS
143245
143245
143245
143245   %=============================================================================
143245   %      (M  )     5 M T R A N S
143245   %
143245   % Monitor call executed on driver level
143245   %
143245   % Entry:    X= current message
143245   %           B= nd-500 cpu datafield
143245   %
143245   %  Functions:
143245   %  1.   disk transfer, return immediately with status: OK, request received
143245   %  2.   disk transfer, wait  until transfer finished,
143245   %                      then return status: transfer finished
143245   %  3.   disk transfer, check event, return immediately with status:
143245   %                      transfer completed/restarted by other/ no event ready
143245   %  4.   disk transfer, check event, wait until event occurs,
143245   %                      then returnstatus: transfer completed/restarted by other
143245   %  5.   check event, nowait return status: no event ready/restarted by other
143245   %  6.   check event, wait, return status: transfer completed/ restarted by other
143245   %  7.   start process, return immediately  with status: OK, request received
143245   %  8.   start process and wait (will be restarted by other process)
143245   %
143245   SUBR 5MRDTRANS; RBUS
143245   SUBR 5MTRANS
143245   5MTRANS:
143245   *"8N500 8MTRA
"143245          X=:CMSGA
143246          0=:CUREL; A:=B=:XC5CPUDF
143251          T:=5MBBANK; *AAX 5MNWA; LDDTX; AAX -5MNWA
143255          AD=:NWFUNC
143256          IF 5MFNC NBIT 5DTRANS GO FAR CHEVENT
143261          % Disk transfer,  check device number:
143261          *AAX 5MLGN; LDATX
143263          CALL LOGPH; A=:X
143265          % Must have hard disk with disk optimizition:
143265          IF X>>="9BBHD" AND X<<"9EEHD" THEN
143273             IF X>>="9EDFD" THEN A:=1 ELSE A:=0; FI; A=:5DSKC    % Set disk type code
143302             IF X>>="9FSTR" AND X<<"9ESTR" AND X.STREN=0 GO 3XERR
143312             GO DIST1
143313          FI
143313   3XERR: A:=6; GO FAR XRXX                                      % No disk opti for this device
143315
143315   DIST1: X=:DDFADDR                                             % Disc controller datafield
143316          % Are there any free disk queue elements:
143316          X:="QP100"
143317          IF X.5MQCU=0 THEN
143321             % Wait until free disk queue element is available:
143321             X:=CMSGA
143322             CALL SLOCK; 0/\0
143324   *NNT13=*
143324             CALL XTER500; 0/\0
143326             CALL IFM500XQ; CALL SUNLOCK
143330             T:=5MBBANK; *AAX PLINK; LDATX; AAX -PLINK
143334             A=:N5MESSAGE
143335             % Link message into driver level wait queue
143335             AD:=5MWQU; T:=5MBBANK; *LINK@3 STDTX
143340             A:=T; D:=X
143342   *NNC20,   CNVWADR
143345             AD=:5MWQU
143346             GO NXTMSG                                          % old: GO 5STDR
143347          FI
143347          % Get a disk access queue element:
143347          X=:B; *AAX QPFRH
143351          CALL GETOUT; 5MQCU-1=:5MQCU; T=:CUREL=:B
143357          % Set up parameters in disk access queue element
143357          X:=CMSGA; T:=5MBBANK; *AAX 5MDIS; LDATX
143363          A=:DISID
143364          IF A/\77=0 THEN
143366             T:=60                             % Read from disk, clear cache
143367          ELSE
143370             IF A=1 OR A=7 THEN                % Func 7: write without 'dump dirty'
143376                T:=61                          % Write to disk, microprog checks on func 7.
143377             ELSE
143400                IF A=6 THEN
143403                   T:=66                       % Read, do not clear cache
143404                ELSE
143405                   A:=7; GO FAR XRXX; *)FILL   % Illegal parameter (illegal read/write function code)
143443                FI
143443             FI
143443          FI
143443          DISID/\300+T=:ABFUN; T:=5MBBANK
143450          *AAX 5MEMA-5MDIS; LDDTX
143452          AD=:MEMAD;  *AAX 5DSEC-5MEMA; LDDTX
143455          AD=:ABPA2;  *AAX 5MNOS-5DSEC; LDDTX
143460          A=:ABP31;  *AAX 5MREQ-5MNOS; LDATX
143463          A=:REQID; NWAIT=:5MNOWAIT;
143466          IF 5MFNC/\6><0 THEN 1=:5MNOWAIT; FI
143473          CMSGA=:ADMESS
143475          IF 5DSKC=0 THEN                                        % SMD or SCSI-100
143477             DISID SHZ -6/\7+"HTABL"; X:=DDFADDR
143504             X:=X+A:=X.S0
143506             IF X.S10=20 THEN                                    % Phoenix disk
143512                ABP21 /\7 SHZ 11+ABFUN=:ABFUN
143517                0=:ABP21
143520             FI
143520             CALL FAR CHDISCADDR
143521             X.SECWO*ABP31=:D                                    % Number of words to transfer
143524          ELSE
143525             CALL FAR CHDISCADDR                                 % Domino disk
143526             A:=2000*ABP31=:D                                    % No or words pr sector=2000
143531          FI
143531          T:=5MBBANK; X:=CMSGA; *LDXTX X5SND
143534          D=:T; AD:=MEMAD; CALL CHFIX; GO FAR FERR               % Check if area fixed
143540          % Parameters are now ok, put element into queue:
143540          A:=X-5SWPROC*5PRDSIZE+"S500S"=:X; X.RTRES=:RTRES
143547          X:=:B
143550          DDFADDR=:B; CALL M5TRANS; GO BUSR;   % CALLED WITH: B=CONTR. DF, X=QUEUE DF
143554          X:=:B; GO 5MRDTRANS
143556   BUSR:  0=:CUREL
143557          IF 5MFNC/\6 = 0 THEN
143562             IF NWAIT><0 THEN 1; GO FAR FIN FI
143566             X:=CMSGA; 5MWAIT; CALL WN5STATUS
143571             GO FAR OUT
143572             *)FILL
143621          FI
143621
143621   CHEVENT: X:=XC5CPUDF=:B:=CMSGA                                % X=current message, B=500 cpu datafield
143624          IF T:=5MFNC NBIT 5CHEVENT GO FAR SPROCESS              % Check event
143627          % Search ready queue to see if the request is finished
143627          X=:B; T:=5MBBANK; *AAX 5MHRE; LDDTX
143633          IF 5MFNC BIT 0 THEN
143636             A:=-1=:D; *STDTX
143641          FI
143641          X:="READYQ-NLINK"
143642          DO
143642             X=:T
143643          WHILE X:=X.NLINK><0
143645             % Is the specified request finished
143645             IF X.ADMESS=B THEN
143650                IF D+1=0 GO FOUND; D-1                           % Any request
143654                IF X.REQID=D GO FOUND
143657             FI
143657          OD
143660          % The specified request is not finished
143660          XC5CPUDF=:B; CALL SLOCK; 0/\0
143664          T:=5MBBANK; X:=CMSGA; *AAX 5MSFL; LDATX; AAX -5MSFL
143671          IF A BIT 55REP THEN
143673             A BZERO 55REP; *AAX 5MSFL; STATX; AAX -5MSFL
143677             CALL SUNLOCK
143700             4; GO FAR FIN
143702          FI
143702          CALL SUNLOCK
143703          IF NWAIT><0 THEN
143705             2; GO FAR FIN
143707          ELSE
143710             5MWAIT; CALL WN5STATUS
143712             GO FAR OUT
143713          FI
143713          *)FILL
143727
143727   INTEGER CCUREL
143730   FOUND: % X=found queue element, T=previous element
143730          X=:D=:CCUREL; A:=T+"NLINK"=:X; CALL GETOUT; CALL PTFREE
143737          D=:B; 0=:RTRES=:ADMESS=:5MNOWAIT
143743          T:=5MBBANK; X:=CMSGA; SSSTAT=:D; A:=0; *AAX 5MHIO; STDTX;
143752          A:=REQID=:D; A:=0; *AAX 5MHRE-5MHIO; STDTX; AAX -5MHRE
143760          XC5CPUDF=:B; CALL SLOCK; 0/\0
143764          T:=5MBBANK; *AAX 5MSFL; LDATX
143767          A=:NWAIT                                               % Temporary storage of 5msfl containing 55rep bit
143770          A BZERO 55REP; *STATX; AAX -5MSFL                      % Reset repeat bit
143773          CALL SUNLOCK; CCUREL=:B
143776          % If read, function 0: set clear cache bit mask:
143776          IF ABFUN=60 THEN T:=7400 ELSE T:=0; FI
144005          6=:D;                                                  % Parameter write back mask
144007          IF SSSTAT BIT 4 THEN
144012             A:=11; CALL 5EMONICO
144014          ELSE
144015             IF NWAIT NBIT 55REP THEN
144020                A:=3                                             % Transfer completed
144021             ELSE
144022                A:=13                                            % Transfer completed and restarted by other
144023             FI; CALL 5MONICO
144024          FI
144024          CALL XACTRDY
144025          AD:=5MWQU
144026          IF D><0 THEN                                           % Process waiting for disk access queue element
144030   *NNC21,   CNVBYADR
144033             % Restart first process waiting for a free disk datafield
144033             X:=D; T:=5MBBANK; *LINK@3 LDDTX
144036             AD=:5MWQU
144037             CALL SLOCK; 0/\0
144041             CALL GCPUDF; CALL ERRFATAL; A=:B
144044   *NNT14=*
144044             CALL XTER500; 0/\0
144046             CALL ITO500XQ
144047             CALL ITOFIFOQ                                        % new code
144050             CALL SUNLOCK
144051             TTMR=:TMR
144053          FI
144053          GO FAR OUT
144054          *)FILL
144101
144101   SPROCESS:                                                     % Start process
144101          IF T:=5MFNC NBIT 5STAPRO GO FAR GETMAGNO
144104          T:=5MBBANK; *AAX  5MPRO; LDDTX
144107          IF A=0 OR A>>MX5PROCS GO ILPROC
144113          A-5SWPROC*5PRDSIZE+"S500S"=:X; X:=X.MESSBUFF
144120          T:=5MBBANK; *AAX MAGNO; LDATX; AAX XADPR-MAGNO; LDXTX
144125          IF A><D OR X.RTRES=0 THEN
144131   ILPROC:   % A:=EILPROC=:D; X:=N5MESSAGE; A:=0; *AAX 5MHIO; STDTX; AAX -5MHIO
144131             A:=5; GO FAR XRXX
144133          FI
144133          X=:D
144134          IF X.PSTAT BIT T5BUFF THEN
144137             X:=X.MESSBUFF; CALL RN5STATUS
144141             IF A=STOPPED OR A=I5TMQ THEN                        % new code
144147                A=:D; CALL GCPUDF; CALL ERRFATAL; A=:B           % new code
144153                IF D=STOPPED THEN
144156                   CALL OKMONICO                                 % Start requested process
144157                ELSE
144160                                                                 % old: IF A=I5TMQ THEN
144160                   CALL FR5TMQU
144161                   CALL SLOCK; 0/\0
144163   *NNT15=*
144163                   CALL XTER500; 0/\0
144165                   A:=1; CALL SPITMQ
144167                   CALL ITO500Q
144170                   CALL SUNLOCK
144171               FI
144171               CALL XACTRDY                                      % new code
144172               IF XC5CPUDF><B THEN                              % new code
144175   *NNA06=*
144175                  CALL XACT500                                  % new code
144176               FI                                               % new code
144176               XC5CPUDF=:B                                      % new code
144200             FI
144200          ELSE
144201             CALL SLOCK; 0/\0
144203             D=:X; T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
144210             A BONE 55REP; *STATX
144212             CALL SUNLOCK
144213          FI
144213          IF NWAIT=0 THEN
144215             CALL SLOCK; 0/\0
144217             T:=5MBBANK; X:=CMSGA; *AAX 5MSFL; LDATX
144223             IF A NBIT 55REP THEN
144225                *AAX -5MSFL
144226                STOPPED; CALL WN5STATUS
144230                CALL SUNLOCK
144231                GO FAR OUT
144232             FI
144232             A BZERO 55REP; *STATX
144234             CALL SUNLOCK
144235             4
144236          ELSE
144237             1
144240          FI
144240          GO FAR FIN
144241   *)FILL
144273
144273   INTEGER FCONNO
144274   GETMAGNO:                                                     % Get magic number
144274         IF T:=5MFNC BIT 5GMAGNO THEN
144277              T:=5MBBANK; *AAX 5FILN; LDATX
144302              A=:FCONNO; *AAX -5FILN; LDATX X5SND
144305              A=:T; 40*5CNSIZE; A:=:T; *RMPY SA DT;
144312              A:=D+CNSTART=:X; T+X=:D
144317              T:=CNBANK
144320              DO WHILE X<<D
144322                 *LDATX
144323                 IF A><0 AND A-FCONNO=0 THEN
144326                    % Found, return magic number to caller:
144326                    X=:A; A-CNSTART=:D:=0; T:=5CNSIZE; *RDIV ST
144334                    A=:D:=0; T:=5MBBANK; X:=CMSGA; *AAX 5MAGN; STDTX; AAX -5MAGN
144343                    T:=0; 4=:D; A:=1; CALL 5MONICO
144350                    CALL XACTRDY                                   % new code
144351                    GO FAR OUT
144352                 FI
144352                 X+5CNSIZE
144353              OD
144354              A:=16; GO XRXX                                     % File not opened for direct transfer
144356          FI
144356          A:=12; GO XRXX                                         % Illegal function code
144360   FERR:  % Memory area is not fixed:
144360          A:=10
144361   XRXX:  X:=CMSGA; D:=0; CALL 5EMONICO
144364          CALL XACTRDY                                            % new code
144365          IF T:=CUREL><0 THEN
144370             CALL PTFREE
144371          FI
144371          GO OUT
144372
144372   FIN:   X:=XC5CPUDF=:B:=CMSGA
144375          D:=0; T:=0; CALL 5MONICO
144400          CALL XACTRDY                                            % new code
144401   OUT:   XC5CPUDF=:B; GO NXTMSG
144404   *)FILL
144422
144422   %================================================================================
144422   %      C H D I S K A D D R
144422   % Subroutine to check if disk address is within file
144422   %
144422   % Entry: B-reg: pointer to disk access queue element
144422   %
144422   INTEGER POINTER LREG               % Return address
144423   INTEGER XREG
144424   INTEGER LSEC1,LSEC2                % Last sector no + 1 in transfer
144426   DOUBLE LSECT=LSEC1
144426   CHDISKADDR:
144426           A:=L=:"LREG"; X=:XREG
144431           T:=5MBBANK; X:=CMSGA; *AAX 5MAGN; LDATX; AAX -5MAGN
144436           A=:D; A SHZ -5; *LDXTX X5SND
144441           IF A><X THEN A:=15; GO FAR XRXX; FI                   % Illegal magic number
144445           T:=CNBANK; A:=D*5CNSIZE+CNSTART=:X                    % X= open file entry
144452           *LDATX 10                                             % Access flag
144453           IF A BIT RACCFLAG THEN                                % Read only
144455              IF DISID BIT 0 THEN                                % Check read function
144460                 A:=17; GO FAR XRXX                              % Not write access
144462           FI;FI
144462           *LDDTX 20                                             % Disk datafield and unit
144463           IF A-DDFADDR=0 THEN                                   % Correct disk
144465              DISID SHZ -6;
144467              IF A=D THEN                                        % Correct unit
144471                 *LDDTX 40                                       % Start sector on disk
144472                 A=:T; D=:L
144474                 AD:=ABPA2; D-L; A:=A+C-1-T
144501                 IF A>=0 THEN
144502                    AD:=ABPA2; T:=ABP31; D+T; A:=A+C
144506                    AD=:LSECT; T:=CNBANK; *LDDTX 60              % Last sector
144511                    A:=:D; A-LSEC2; A:=:D; A:=A+C-1-LSEC1
144517                    IF A>=0 THEN                                 % Transfer within file
144520                       X:=XREG; GO LREG
144522                 FI;FI
144522                 A:=20; GO FAR XRXX
144524              FI; A:=21; GO FAR XRXX
144526           FI
144526           A:=22; GO FAR XRXX
144530   *"8N500 -8MTRA
"144530   RBUS
144540
144540
144540   *"8N500 8MTRA
"144540
144540
144540   %============================================================================
144540   %        ( M )     5 M R D T R A N S
144540   %
144540   % Driver level routine activated after transfer is finished
144540   %
144540   % Entry:  B= disk access queue element (removed from acc queue)
144540   %
144540   %
144540   SUBR 5MRDTRANS
144540
144540   5MRDTRANS:
144540           IF "N500DF".SYSINITFLAG BIT B5STOP GO WT12
144544           % First: check if process has terminated:
144544           IF RTRES=0 THEN
144546              B=:T; 0=:REQID; CALL PTFREE
144551              AD:=5MWQU
144552              IF D><0 THEN
144554   *NNC22,       CNVBYADR
144557                 % Restart first process waiting for a free datafield
144557                 X:=D; T:=5MBBANK; *LINK@3 LDDTX
144562                 AD=:5MWQU
144563                 CALL SLOCK; 0/\0
144565                 CALL GCPUDF; CALL ERRFATAL; A=:B
144570   *NNT16=*
144570                 CALL XTER500; 0/\0
144572                 CALL ITO500XQ
144573                 CALL ITOFIFOQ                                    % new code
144574                 CALL SUNLOCK
144575                 GO N500
144576              FI
144576              GO WT12
144577           FI
144577           % Is 500 process waiting until transfer is finished?
144577           IF 5MNOWAIT><0 THEN
144601              % Has the process later gone into wait
144601              X:=ADMESS; CALL RN5STATUS
144603              IF A-5MWAIT=0 THEN
144605                 *AAX 5MREQ; LDATX
144607                 IF A=-1 GO 5RMSTART                             % Waiting for any request
144612                 IF A=REQID GO 5RMSTART                          % Waiting for this request
144615              FI
144615              % The process is not waiting for this request
144615              % Put datafield into ready queue
144615              X:="READYQ-NLINK"
144616              DO
144616                X=:T
144617              WHILE X:=X.NLINK><0
144621              OD
144622              A:=T+"NLINK"=:X; B=:T; CALL PUTIN
144627              GO WT12
144630           FI
144630   5RMSTART: % Process should be restarted
144630           B=:T; CALL PTFREE
144632           T:=5MBBANK; X:=ADMESS; SSSTAT=:D; A:=0; *AAX 5MHIO; STDTX
144641           A:=REQID=:D; 0=:REQID; A:=0;  *AAX 5MHRE-5MHIO; STDTX; AAX -5MHRE
144650           % If read,function 0: set clear cache bit mask:
144650           IF ABFUN=60 THEN T:=7400 ELSE T:=0; FI
144657           6=:D;                                                 % Parameter write back mask
144661           IF SSSTAT BIT 4 THEN
144664              A:=11; CALL 5EMONICO
144666           ELSE
144667              A:=3; CALL 5MONICO
144671           FI
144671           0=:RTRES=:ADMESS=:5MNOWAIT=:SSSTAT
144675           CALL GCPUDF; CALL ERRFATAL; A=:B
144700           CALL XACT500                                  % new code
144701           AD:=5MWQU
144702           IF D><0 THEN
144704   *NNC23,    CNVBYADR
144707              % Restart first process waiting for a free datafield
144707              X:=D; T:=5MBBANK; *LINK@3 LDDTX
144712              AD=:5MWQU
144713              CALL SLOCK; 0/\0
144715              CALL GCPUDF; CALL ERRFATAL; A=:B
144720   *NNT17=*
144720              CALL XTER500; 0/\0
144722              CALL ITO500XQ
144723              CALL ITOFIFOQ                              % new code
144724              CALL SUNLOCK
144725              GO N500
144726           FI
144726           GO WT12                                       % old: go n500
144727   RBUS
144755
144755   *"8N500
"144755
144755

144755   %============================================================================
144755   %      ( M )      5 A C T S W A P P E R
144755   %
144755   % Subroutine to activate the n500 swapper process
144755   %
144755   % When called from other levels than the driver level
144755   % then 5ACTSWAPPER must be called in "iof"
144755   %
144755   % Entry:     X=message requireing service from swapper
144755   %
144755   % exit:      T,A,D regs are destroyed
144755   %
144755   SUBR 5ACTSWAPPER
144755   INTEGER POINTER LREG
144756   INTEGER MSGTOSW
144757   DOUBLE  CMSGTOSW
144761   INTEGER BREG
144762
144762   5ACTSWAPPER: A:=L=:"LREG"
144764          CALL SLOCK; 0/\0
144766          X=:D=:MSGTOSW; A:=5MBBANK
144771   *NNC24,CNVWADR
144774          AD=:CMSGTOSW
144775          SWPWAIT; CALL WN5STATUS                    % Mark that proc. is waiting for swapper
144777          X:=SWMSG; CALL RN5STATUS
145001          IF A=PSWWAIT THEN                          % Swapper free?
145004             T:=5MBBANK; X:=SWMSG
145006             AD:=CMSGTOSW; *AAX HSWPI; STDTX
145011             SWACTIVE; *AAX SWPFU-HSWPI; STATX
145014             X:="N500DF".X500DF; *AAX X5SWO
145017             CMSGTOSW; T:=5MBBANK; *STDTX
145022             X:=MSGTOSW; SWPPING; CALL WN5STATUS    % Mark that process is using the swapper
145025             T:=5MBBANK; *AAX 5MSFL; LDATX          % Disable escape while using swapper
145030             *5IBRK@3 BLDA DA                       % K:=PSTAT.5IBRK
145031             A BONE 5IBRK; *S5IBR@3 BSTA DA; STATX  % K=:PSTAT.S5IBRK
145034             X:=MSGTOSW
145035             T:=5MBBANK; *MICFU@3 LDATX; COPY SA DD % D:=X.MICFUNC
145040             IF 3SWMESS=D THEN                      % Message to swapper?
145043                *SWFUN@3 LDATX                      % Yes
145044             ELSE
145045                *AAX TRAPN; LDATX                   % No, trap (pagefault)
145047                A=:D/\377; *STATX
145052                A:=D SHZ -10
145054             FI
145054             X:=SWMSG; *AAX SWPST; STATX            % Save reason for activating swapper
145057             A:=6; *AAX NUMPA-SWPST; STATX          % Par #2 & par #3 will be written into
145062             A:=0=:D; *AAX FUNCV-NUMPA; STDTX
145066             *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
145071             3MONCO; *MICFU@3 STATX
145073             CALL MCCO                              % Yes, restart swapper after mon.call
145074             CALL SUNLOCK
145075             CALL XACTRDY
145076   *NNJ11=*
145076             GO OUT
145077             CALL XTER500; 0/\0
145101             CALL ITO500XQ
145102             T:=5MBBANK; *AAX 5CPUN; LDATX
145105             A/\177400\/CPUNO; *STATX; AAX -5CPUN
145111          ELSE
145112             % - Insert in Swap-wait-fifo
145112             T:=5MBBANK; X:="N500DF".X500DF; *AAX X5MXF; LDATX
145117             A=:L; *AAX X5SWF-X5MXF; LDATX
145122             IF A=:D+1>=L THEN A:=0 FI; *STATX      % Max Swap-wait-fifo Fylle-pointer?
145130             D SH 1=:L; *AAX X5SWB-X5SWF; LDDTX     % Compute Swap-wait-fifo address
145134   *NNC25,   CNVBYADR                               %
145137             X:=D+L; T:=A+C; CMSGTOSW; *STDTX       % Insert new message
145144             CALL SUNLOCK
145145          FI
145145   OUT:   X:=MSGTOSW; GO LREG
145147   RBUS
145165
145165
145165   %===============================================================================
145165   %       ( M )    X T E R 5 0 0
145165   %
145165   % Routine to terminate (stop) nd-500
145165   %
145165   % Entry:     X=-1 then no actual message
145165   %            X><-1 then x=actual message
145165   %
145165   % Exit:      error, nd-500 not terminated
145165   %
145165   % Exit+1:    ok, nd-500 stopped
145165   %
145165   SUBR XTER500
145165   INTEGER DREG,XREG,LOOPCOUNTER,LOOP2COUNT
145171   INTEGER POINTER LREG
145172   INTEGER 500STATUS=LOOP2COUNT                  % Nd-500 status when entering XTER500
145172
145172   XTER500: IF 5CPUSTOPPED><0 THEN EXITA FI      % Already stopped?
145175          A:=D=:DREG:=L=:"LREG"; X=:XREG
145202          0=:LOOPCOUNTER
145203   *NNJ12=*
145203          GO TER51
145204          T:=HDEV+RSTA5; *IOXT
145207          A=:500STATUS
145210          IF A BIT 5ILOCK THEN                   % Nd-500 running, i/f locked
145212             T+"TERM5-RSTA5"; *IOXT
145214             T+"RSTA5-TERM5"
145215             FOR LOOPCOUNTER DO                  % Wait for nd-500 to unlock i/f
145215                FOR X:=-20 DO; OD
145217                *IOXT
145220                WHILE A BIT 5ILOCK
145222             OD
145224          FI
145224          IF A NBIT 5ILOCK GO OKRET             % Did nd-500 terminate ?
145226          CALL X5MCST                           % Time out; master clear it
145227          GO TER52
145230
145230   TER51:
145230          FOR LOOPCOUNTER DO
145230              IDLEKICK; CALL XKICK500
145232              CALL GETC5PROC
145233              IF A=-1 GO OKRET
145236          OD
145240
145240   TER52: ESPTIMOUT
145241          IF X:=XREG><-1 THEN CALL WN5STATUS FI
145246          A=:FERROR; GO ERR
145250
145250          % Return points
145250   OKRET: MIN 5CPUSTOPPED; 0/\0; MIN "LREG"
145253   ERR:   A=:D:=DREG:=:D; X:=XREG; GO LREG
145260   RBUS
145265
145265   %==========================================================================
145265   %        ( M )     X A C T R D Y
145265   %
145265   % Activate nd-500 with this message if any cpu is idle
145265   % or priority higher than the current running ones
145265   %
145265   % Entry:     X=message
145265   %
145265   % Exit:      ok
145265   %
145265   SUBR XACTRDY
145265   INTEGER SVX
145266   INTEGER DREG=?,XREG=?,BREG=?
145266   INTEGER POINTER LREG=?
145266   INTEGER C5CPU=?,CC5CPU=?,CC5PRIOR=?,CSWITCH=?
145266
145266   XACTRDY:
145266   *NNJ13=*
145266           P+1; EXIT                                   % Direct exit if old 500.
145270           T:=5MBBANK; *N5STA@3 LDATX
145272           IF A><MSGN500 AND A><WAITING THEN EXIT FI
145301           A:=L=:"LREG"; A:=D=:DREG; A:=B=:BREG; X=:XREG
145310           CALL GCPUDF; CALL ERRFATAL; A=:B=:C5CPU
145314           IF C5STAT BIT BHPFAIL GO FAR OUT            % If in power-fail
145317           CALL SLOCK; 0/\0
145321           CPUAVAILABLE; *5EXCL@3 BLDA DA
145323           T:=5MBBANK; X:=XREG; *MICFU@3 LDATX
145326           IF K NBIT AND A=3START OR A=3MONCO OR A=3TRACO OR A=3WMONCO OR A=3FITRNSF THEN
145347              T:=5MBBANK; X:=MAILINK; *AAX X5CCL; LDATX
145353              A=:D; X:=XREG; *AAX 5CCLR; LDATX
145357              A-D=:CSWITCH; *AAX 5MSFL-5CCLR; LDATX
145363              IF A BIT 5CPUBOUND THEN 0=:CSWITCH FI
145366           ELSE
145367              0=:CSWITCH
145370           FI
145370           T:=5MBBANK; X:=XREG; *AAX 5PRIO; LDATX
145374           A=:CC5PRIOR; GO ACT50
145376
145376   *)FILL
145403   INTEGER DREG,XREG,BREG
145406   INTEGER POINTER LREG
145407   INTEGER C5CPU,CC5CPU,CC5PRIOR,CSWITCH
145413
145413   ACT50:  IF CSWITCH><0 THEN
145415              "S5CPUDF"=:B; 0=:CC5CPU
145420              DO WHILE B<<="E5CPUDF"
145423                 IF CPUAVAILABLE BIT 5ALIVE AND C5STAT NBIT BHPFAIL THEN
145431                    T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
145435                    IF A=MPACTIVE THEN
145440                       CALL GETC5PROC
145441                       IF A=-1 GO ACT51; IF A<0 GO ACT52
145445                       A-5SWPROC*55MESSIZE+SWMSG=:X
145451                       T:=5MBBANK; *AAX 5PRIO; LDATX
145454                       IF A<CC5PRIOR THEN A=:CC5PRIOR; A:=B=:CC5CPU FI
145462                    FI
145462                 FI
145462                 B+5CPUDFSZ
145463              OD
145464              IF CC5CPU><0 THEN A=:B; GO ACT52 FI
145470              C5CPU=:B; GO ACT51
145473           ELSE
145474              CALL GETC5PROC
145475              IF A=-1 THEN
145500   ACT51:        T:=5MBBANK; X:=MAILINK; *AAX X5ACT; STZTX
145504              ELSE
145505                 IF A<0 GO ACT52
145506                 A-5SWPROC*55MESSIZE+SWMSG=:X; T:=5MBBANK; *AAX 5PRIO; LDATX
145515                 IF A<CC5PRIOR THEN
145520   ACT52:           N100KICK; CALL XKICK500
145522                 ELSE
145523                    GO ACT51
145524                 FI
145524              FI
145524           FI
145524           CALL SUNLOCK; 0=:5CPUSTOPPED
145526   OUT:    DREG=:D; X:=XREG; BREG=:B; GO LREG
145534   RBUS
145545
145545
145545   %==========================================================================
145545   %        ( M )     X A C T 5 0 0
145545   %
145545   % Activate the nd-500.
145545   %
145545   % Entry:     B=n500 cpu-datafield, X=message
145545   %
145545   % Exit:      T,A,D registers are destroyed
145545   %
145545   SUBR XACT500
145545   INTEGER DREG,XREG
145547   INTEGER POINTER LREG
145550   INTEGER 500STATUS
145551
145551   XACT500:
145551   *NNJ14=*
145551           GO XACTRDY                                    % Continue in XACTRDY if nd5000
145552           A:=D=:DREG; A:=L=:"LREG"; X=:XREG
145557           T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
145563           IF A=MPACTIVE AND C5STAT NBIT BHPFAIL THEN    % If not in power-fail
145571              T:=HDEV+RSTA5; *IOXT                       % Read interface status
145574              A=:500STATUS
145575              IF A NBIT 5CLOST THEN                      % If nd-500 not stopped (clock stopped)
145577                 IF A BIT 5ILOCK THEN                    % If nd-500 not terminated
145601                    CALL XTER500; 0/\0
145603                 FI
145603                 % Activate ND-500 with the first message waitng for ND-500 CPU.
145603                 % Status=msgn500 and status=waiting means waiting for ND-500 CPU.
145603                 X:=MAILINK
145604                 DO                                      % Search ex-queueu to see
145604                    T:=5MBBANK; *LINK@3 LDDTX            % Next message
145606                 WHILE D><-1                             % If any processes is waiting for nd-500 cpu.
145611                    IF X:=D><DUMMESS THEN
145615                       CALL RN5STATUS                    % Message.Status
145616                       IF A=MSGN500 OR A=WAITING GO ACT50% Msgn500 or Waiting?
145624                    FI
145624                 OD
145625                 % No processes waiting for nd-500 cpu.
145625                 T:=5MBBANK; X:=MAILINK; *LINK2@3 LDXTX
145630                 IF X><-1 AND 500STATUS NBIT 5ILOCK THEN % Has ND-500 been terminated?
145636                    % Reactivate it since an interrupt may have been lost
145636   ACT50:           5MBBANK; T:=HDEV+LMAR5; *IOXT
145642                    A:=X; *IOXT
145644                    A:=5; T+"LCON5-LMAR5"; *IOXT
145647                 ELSE
145650                    % Enabale for interrupt
145650                    A:=10; T:=HDEV+LCON5;   *IOXT
145654                    A:=0;  T+"LSTA5-LCON5"; *IOXT
145657                    A:=1;  T+"LCON5-LSTA5"; *IOXT
145662                           T+"SLOC5-LCON5"; *IOXT
145664                    TTMR=:TMR
145666                 FI
145666              FI
145666           FI
145666   OUT:    0=:5CPUSTOPPED
145667           DREG=:D; X:=XREG; GO LREG
145673   RBUS
145700
145700
145700   %============================================================================
145700   %      ( M )   X R S T A R T A L L                     (WM-400)
145700   %
145700   % Routine to restart all sintran iii programs with
145700   % Messages in the N500 execution queue with an error message
145700   %
145700   % Executed on lvl 12
145700   %
145700   % Entry:     A=error status
145700   %            B=cpu df
145700   %
145700   SUBR XRSTARTALL
145700   INTEGER ERRSTAT=?,DREG=?,BREG=?
145700   DOUBLE  ADREG=?
145700   INTEGER POINTER LREG=?
145700   INTEGER CCCLR=?
145700
145700   XRSTARTALL:
145700          AD=:ADREG; T:=L=:"LREG"; T:=B=:BREG
145705          IF A NBIT POWDOWN THEN                                  % Power-fail ?
145707             IF A=:FERROR=N5STOPPED GO RSTA2
145713             T:=5MBBANK; X:=MAILINK; MPFAIL; *AAX X5CPU; STATX
145720             CALL CHACTIVEQ; GO FAR RSTA2
145722          FI
145722          T:=5MBBANK; X:=MAILINK; *AAX X5CCL; LDATX
145726          A=:CCCLR
145727          X:=MAILINK
145730          DO
145730             T:=5MBBANK; *LINK@3 LDDTX
145732          WHILE D><-1                                             % Search the whole ex-queue
145735   *NNC26,    CNVBYADR
145740             IF X:=D><DUMMESS THEN
145744                T:=5MBBANK; *AAX 5CPUN; LDATX; AAX -5CPUN
145750                IF A/\377=CPUNO THEN
145754                   IF ERRSTAT NBIT POWDOWN THEN
145757                      IF X=SWMSG GO FAR RSTA2
145762                      IF MIFLAG BIT MUDOM THEN
145765                         T:=5MBBANK; *AAX 5CCLR; LDATX; AAX -5CCLR
145771                         IF A-CCCLR><0 THEN                       % Can process be moved to another CPU?
145773                            *AAX 5MSFL; LDATX; AAX -5MSFL
145776                            IF A BIT 5SYSRES GO RSTA1
146000                            IF A NBIT 5CPUBOUND THEN CALL XACTRDY; GO RSTA1 FI
146004                         FI
146004                      FI
146004                      CALL RN5STATUS
146005                      IF A=SWPPING THEN
146010                         CALL SLOCK; GO RSTA2
146012                         T:=5MBBANK; *AAX 5MSFL; LDATX
146015                         A BONE 52ESCSET; *STATX; AAX -5MSFL
146020                         ERRSTAT; CALL WN5STATUS
146022                         CALL SUNLOCK; GO RSTA1
146024                      FI
146024                   ELSE
146025                      IF X=SWMSG GO RSTA1
146030                      CALL RN5STATUS
146031                      A BONE POWDOWN
146032                      CALL SLOCK; GO RSTA2
146034                      CALL XTER500; 0/\0
146036                      CALL RN5STATUS
146037                      A BONE POWDOWN
146040                      GO F5XQ
146041                   FI
146041                   CALL SLOCK; GO RSTA2
146043                   CALL XTER500; 0/\0
146045                   ERRSTAT; GO F5XQ
146047
146047   INTEGER CCCLR
146050   INTEGER FTRRSTAT:=E5FATAL                                      % Error code for FTXEL error logger
146051   INTEGER ERRSTAT,DREG,BREG
146054   DOUBLE  ADREG=ERRSTAT
146054   INTEGER POINTER LREG
146055
146055   F5XQ:           CALL WN5STATUS
146056                   CALL IFM500XQ                                  % Remove from ex-queue
146057                   CALL SUNLOCK
146060                   T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
146064                   IF A NBIT 5SYSRES THEN
146066                      CALL 5XACTRT
146067                   FI
146067                FI
146067             FI
146067   RSTA1: OD
146070          GO OUT
146071   *)FILL
146111
146111   RSTA2:
146111          "S5CPUDF"=:B
146113          DO WHILE B<<="E5CPUDF"
146116             IF ERRSTAT NBIT POWDOWN THEN                         % Not power-fail ?
146121                A=:FERROR                                         % Set "global" error-code
146122                T:=5MBBANK; X:=MAILINK
146124                MPFAIL; *AAX X5CPU; STATX
146127             FI
146127             X:=MAILINK
146130             DO
146130                T:=5MBBANK; *LINK@3 LDDTX
146132             WHILE D><-1                                          % Search the whole ex-queue
146135   *NNC27,      CNVBYADR
146140                IF X:=D><DUMMESS THEN
146144                   T:=5MBBANK; *AAX 5CPUN; LDATX; AAX -5CPUN
146150                   IF A/\377=CPUNO THEN
146154                      IF ERRSTAT BIT POWDOWN THEN                 % Power-fail ?
146157                         IF SWMSG=X GO RSTA3                      % Yes, no restart of 5swap
146162                         CALL RN5STATUS
146163                         A BONE POWDOWN
146164                      FI
146164                      CALL WN5STATUS                              % Error-code in status of message
146165                      CALL IFM500XQ                               % Remove from ex-queue
146166                      T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
146172                      IF A NBIT 5SYSRES THEN
146174                         CALL 5XACTRT                             % Restart nd-100 program
146175                      FI
146175                   FI
146175                FI
146175   RSTA3:    OD
146176             B+5CPUDFSZ
146177          OD; GO OUT
146201
146201
146201   OUT:
146201   *"8N500 8FTS5
"146201          *1BANK
146202          IF ERRSTAT BIT POWDOWN THEN                             % Anything with power?
146205             IF A BIT POWUP THEN EPWUP                            % - N500TMR
146210             ELSE IF A BIT POWDET THEN EPWDET
146214             ELSE EPWDOWN FI FI                                   % - N500C
146216             A=:ERRSTAT; CALL 9FLER(ERRSTAT,1)
146222          ELSE
146223             IF A=N5STOPPED THEN
146226                CALL 9FLER(ERRSTAT,1)
146231             ELSE
146232                CALL 9FLER(FTRRSTAT,2)
146235             FI
146235          FI
146235          *2BANK
146236   *"8N500
"146236          BREG=:B; ADREG; GO LREG
146242
146242   RBUS
146262
146262
146262   %============================================================================
146262   %      ( M )    C H A C T I V E Q
146262   %
146262   % Routine to check number of active CPUs in the system.
146262   %
146262   % Entry:  none
146262   % Exit:   none active cpu
146262   % Exit+1: one or more active cpu
146262   %
146262   SUBR CHACTIVEQ
146262   INTEGER XREG,CNCPU
146264
146264   CHACTIVEQ: X=:XREG; 0=:CNCPU
146266         X:="S5CPUDF"
146267         DO WHILE X<<="E5CPUDF"
146272            IF X.C5STAT NBIT BHPFAIL THEN
146275               T:=5MBBANK; X=:D:=X.MAILINK; *AAX X5CPU; LDATX
146302               X:=D; IF A=MPACTIVE THEN MIN CNCPU; 0/\0 FI
146310            FI
146310            X+5CPUDFSZ
146311         OD
146312         X:=XREG
146313         IF CNCPU><0 THEN L+1 FI
146316         EXIT
146317   RBUS
146322
146322
146322   %============================================================================
146322   %      ( M )    K I C K 5 0 0
146322   %
146322   % Kick the nd-500 via octobus
146322   % Called in IOF if called from other level than 12
146322   % Executed on level 12
146322   % Must be called in iof if called from other levels than the driver level
146322   %
146322   SUBR XKICK500
146322   INTEGER CKICKTYPE,CLVL,CPIE
146325   INTEGER POINTER LREG
146326   XKICK500: A=:CKICKTYPE; *TRA STS
146330          A SH -5/\170=:CLVL
146333          *IOF
146334          IF CLVL><LV12B THEN                      % Called from n500 driver level?
146340             A:=B; *IRW LV12B DB                   % No, switch to n500 driver level
146342             "WT12"; *IRW LV12B DL
146344             "LV12KICK";*IRW LV12B DP
146346             LV12; *MST PID
146350             *ION; IOF
146352             CPIE; *MST PIE
146354             EXIT
146355          FI
146355   LV12KICK:                                       % Entry point of "send-octobus-kick" routine on level 12
146355          *ION
146356          A:=L=:"LREG"
146360          T:=5STATION; X:=OCTORING; A:=CKICKTYPE   % Set up kick parameters
146363          CALL SKICK; GO ERR                       % Call octobus kick routine
146365   OUT:   IF CLVL><LV12B THEN                      % Called originally on n500 driver level?
146371             *IOF                                  % No, return to correct level via level 14
146372             "LV14KICK"; *IRW LV14B DP
146374             LV14; *MST PID; ION
146377          FI; GO LREG
146400
146400   ERR:   A=:T; CALL 9ERR(#99); GO OUT
146404
146404   % Level 14 routine to disable all lower levels than
146404   % the calling one to ensure a kind of "iof" sequence
146404   INTEGER CSHSHR(0); *SHD+SHR
146405   INTEGER CSH(0);    *SHD
146406   LV14KICK: *TRA PIE
146407          A=:CPIE:=37777=:D:=CLVL SHZ -3+1
146415          T:=CSHSHR-A; *EXR ST
146420          T:=CSH+A;    *EXR ST
146423          A:=D; *MCL PIE
146425          GO YWAIT
146426   RBUS
146440
146440
146440   %===============================================================================
146440   %      ( M )    X R S 5 C P U
146440   %
146440   % Routine to send Octobus "Reset CPU" multibyte message.
146440   %
146440   % Entry:        B=CPU df
146440   % Exit:         Error
146440   % Exit+1:       Ok
146440   %
146440   SUBR XRS5CPU
146440   INTEGER BREG
146441   INTEGER POINTER LREG
146442   XRS5CPU: A:=L=:"LREG":=B=:BREG
146446          % Build Octobus message
146446          5STATION=:"LMFIELD".MOCTSTATION                     % Station number
146451          OMDACCP =:        X.MOCTOMD                         % OMD number
146453          0       =:        X.MBROADCAST                      % Not broadcast
146454          1       =:        X.MMSGLENGTH                      % Message length = 1 byte
146456          CMCPURES SHZ 10=: X.MCOMMAND                        % Send "Reset CPU"
146461          "LMDF"=:B; T:=5OMDNO; X:=OCTORING
146465          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
146470          CALL MBSEND; 0/\0
146472          BREG=:B; GO LREG
146475
146475   RBUS
146500
146500
146500   %===============================================================================
146500   %      ( M )    R S 5 C P U
146500   %
146500   % Routine to reset all active CPUs.
146500   % Activated from level 1 (5pit).
146500   %
146500   SUBR RS5CPU
146500   RS5CPU: "S5CPUDF"=:B
146502          DO WHILE B<<="E5CPUDF"
146505             IF CPUAVAILABLE BIT 5ALIVE AND MAILINK><-1 THEN
146514                T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
146520                IF A><MPNACTIVE THEN
146523                   IF CPUAVAILABLE/\5CPUTYPE=SAMSON THEN
146530                      CALL XRS5CPU
146531                   ELSE
146532                      CALL XTER500; 0/\0
146534                      CALL X5MCST
146535                   FI
146535                FI
146535             FI
146535             B+5CPUDFSZ
146536          OD
146537          GO WT12
146540   RBUS
146550
146550
146550   %===============================================================================
146550   %      ( M )    5 O M B R E A D
146550   %
146550   % Routine to read Octobus message from  the ACCP
146550   % Activated if multi-byte message is received on reserved OMD number
146550   %-------------------------------------------------------------------------------
146550   % accp:         SEC code:
146550   %
146550   % 5000-mp:      SEC code:
146550   %
146550   % mf-contoller: SEC code: 14 +
146550   %     20b = Corrected memory error
146550   %     30b = Memory timeout
146550   %     31b = Unknown error
146550   %     50b = Memory write parity
146550   %     51b = Memory I/O-error
146550   %     77b = Fatal error in MF-controller
146550   %
146550   % accp:          error record
146550   %    type taccprec=record
146550   %        toctoheader: octoheader
146550   %        byte:        errcode               %
146550   %        byte:        errtype               %
146550   %    endrecord
146550   %    % errcode:
146550   %    constant  hwfault=200b                 % fatal hw fault
146550   %    % errtype:
146550   %    contstant accperr=  1                  % memory error reported from accp
146550   %
146550   % mp:            error record
146550   %    type taccprec=record
146550   %        toctoheader: octoheader
146550   %        byte:        errcode
146550   %        byte:        errtype
146550   %        integer2:    process_no
146550   %        integer4:    trapping_p
146550   %        integer4:    restart_p
146550   %        integer2:    trap_no
146550   %        integer4:    mms_sts
146550   %        integer4:    log_addr
146550   %        integer4:    phys_addr
146550   %        integer2:    Phys_seg
146550   %        integer4:    wr
146550   %        integer2:    asts
146550   %        integer2:    badap
146550   %    endrecord
146550   %    % errtype:
146550   %    constant mperr=2                     % error reported from micro-program
146550   %
146550   % mf-controller: error record
146550   %    type tmfrec=record
146550   %        tocthead: octheader
146550   %        integer2: etype     % error cycle & type
146550   %        integer2: emainstat % mf error event
146550   %        integer2: elog1     % errlog1
146550   %        integer2: elog2
146550   %        integer2: elog3
146550   %        integer2: elog4
146550   %        integer2: emaster
146550   %        integer2: eslave
146550   %        integer2: eaddress
146550   %        integer2: esyndrom
146550   %    endrecord
146550   %
146550   %    Error record sent to Layer Manager (9FLER):
146550   %    type terrec=record
146550   %        integer2: sec_code  % =etype: error cycle & type
146550   %        integer2: octsource % octobus station # of source (sender)
146550   %        integer2: omdsource % octobus omd # of source (sender)
146550   %        integer2: emainstat % mf error event
146550   %        integer2: elog1     % errlog1
146550   %        integer2: elog2
146550   %        integer2: elog3
146550   %        integer2: elog4
146550   %        integer2: emaster
146550   %        integer2: eslave
146550   %        integer2: eaddress
146550   %        integer2: esyndrom
146550   %    endrecord
146550   %
146550   %
146550   SUBR 5OMBREAD,I5OMBR
146550   % Fatal ErrorMessage indicator
146550   INTEGER ARRAY MPFATAL:=(1\0,0\1,0\0,0\0,0\1,1\0)
146556
146556   INTEGER CSTS=?,CMICP=?
146556   INTEGER LMREC=?,LMSIZE=?
146556   5OMBREAD:
146556   %      DO
146556             "LMFIELD"=:D; A:=DPITBANK
146561             X:=OCTORING; T:=5OMDNO; CALL OMBREAD; GO ERR
146565             IF "LMFIELD".MOCTSTATION>=FN5DEST AND A<=LN5DEST THEN
146575                X.ETYPE=:D SHZ -10=:CSTS; A:=D/\377=:CMICP
146604                % ErrorMessage or Ack/Nack from ACCP/Microproram?
146604                X.MOCTSTATION; CALL FAR GN5CPUDF; GO I5OMBR
146607                IF CSTS=MFACK OR A=MFNACK THEN
146616                   % Ack/Nack answer on 'WriteSysPar' message
146616                   % i.e. I'm present
146616                   CPUAVAILABLE BONE 5ALIVE=:CPUAVAILABLE
146621                   GO I5OMBR
146622                FI
146622                % ErrorMessage
146622                IF CSTS/\17<17 THEN
146627                   % Known ErrorMessage
146627                   A=:X; T:="MPFATAL"; *1BANK; LBYT; 2BANK
146634                   IF A><0 THEN
146635                      CSTS\/N5SECCODE; CALL XRSTARTALL
146640                   FI
146640                FI
146640                CPUNO=:"LMFIELD".MOCTSTATION
146643                % HW-fault/General trap reported by the microprogram?
146643                IF CMICP=1 AND CSTS=200 OR A=201 THEN
146656                   "LMFIELD".S5-5SWPROC*5PRDSIZE+"S500S"
146663                   A.RTRES=:"LMFIELD".S4                    % Add shadow process id
146667                   "LMFIELD+2"=:LMREC
146671                   X.MMSGLENGTH+4=:LMSIZE
146674                ELSE
146675                   "LMFIELD+3"=:LMREC
146677                   "LMFIELD".MMSGLENGTH+2=:LMSIZE
146703                FI
146703                CSTS\/N5SECCODE=:CSTS
146706             ELSE IF A>=FMFDEST AND A<=LMFDEST THEN
146715                % ErrorMessage or Ack/Nack from MF-controller
146715                IF X.ETYPE=MFACK GO I5OMBR
146721                A=:CSTS
146722                "LMFIELD+2"=:LMREC
146724                "LMFIELD".MMSGLENGTH+2=:LMSIZE
146730             ELSE
146731                GO I5OMBR
146732                % Octobus error
146732   ERR:         IF A><101410 THEN
146735                   A=:CSTS
146736                   0=:"LMFIELD".MOCTSTATION
146740                   "LMFIELD+2"=:LMREC
146742                   2=:LMSIZE
146744                ELSE
146745                   GO I5OMBR
146746                FI
146746             FI FI
146746             GO BYPASS
146747
146747   INTEGER CSTS,CMICP
146751   *)FILL
146772
146772   BYPASS:   "LMFIELD".MOCTSTATION=:LMREC.EOCTSOURCE
146776             CSTS=:X.ESECCODE
147000             LMSIZE+1 SH -1=:LMSIZE          % Convert # of bytes to # of 16-bits words
147004             CALL 9FLER                      % Parameters to 9FLER follow in the next to locations
147005   INTEGER      LMREC                        % 1st parameter; address of error information
147006   INTEGER      LMSIZE                       % 2nd parameter; size of error information
147007             % Mf-contoller requires ack message
147007             IF "LMFIELD".EOCTSOURCE>=FMFDEST AND A<=LMFDEST THEN
147017                A      =:"LMFIELD".MOCTSTATION     % Station number
147021                MFOMDNO=:        X.MOCTOMD         % OMD number
147023                0      =:        X.MBROADCAST      % Not broadcast
147024                1      =:        X.MMSGLENGTH      % Message length = 1 byte
147026                MFACK SH 10=:    X.MSTS
147031                X:=OCTORING; T:=5OMDNO
147033                "LMFIELD"=:D; A:=DPITBANK
147036                CALL MBSEND; 0/\0
147040             FI
147040   I5OMBR:   "LMDF"=:B; CALL ID12
147043   %      OD
147043          GO FAR 5OMBREAD
147044   *)FILL
147052
147052   % Local subroutine to get N5000 CPU df from
147052   % octobus source station number.
147052   %
147052   %  Entry:      A=octobus station number
147052   %  Exit:       Error; Cpu df not found
147052   %  Exit+1:     Ok; B=cpu df
147052   %
147052   GN5CPUDF: A=:D; "S5CPUDF"=:B
147055         DO WHILE B<<="E5CPUDF"
147060            IF 5STATION=D THEN EXITA FI
147064            B+5CPUDFSZ
147065         OD
147066         EXIT
147067   RBUS
147071
147071
147071   %============================================================================
147071   %      ( M )    C O N 5 O M D
147071   %
147071   % Connect octobus OMD
147071   % To be able to receive multi byte error messages from:
147071   %    - the MF controller
147071   %    - the accp
147071   %    - the 5000 microprogram
147071   %
147071   % Activated from level 1 (5pit)
147071   %
147071   % Entry:  B=working field
147071   %
147071   SUBR CON5OMD
147071   CON5OMD:
147071          X:=OCTORING; CALL CONOMD; GO WT12           % Connect Octobus OMD number to additional cpu df.
147074          A=:5OMDNO
147075          GO WT12
147076   RBUS
147100
147100
147100   %============================================================================
147100   %      ( M )    M F P R E P A R E
147100   %
147100   % Sends OMD numer to mf-controller on which N100 can receive messages
147100   % Activated from level 1 (5pit)
147100   %
147100   % Ack/Nack answer is handled by 5OMBREAD
147100   %
147100   % Entry:  B=working field
147100   %         A=destination octobus station number
147100   %
147100   SUBR MFPREPARE
147100   MFPREPARE:
147100          A       =:"LMFIELD".MOCTSTATION          % Station number
147102          MFOMDNO =:        X.MOCTOMD              % OMD number
147104          0       =:        X.MBROADCAST           % Not broadcast
147105          3       =:        X.MMSGLENGTH           % Message length = 2 bytes
147107          CMSYSPAR SHZ 10\/N100IDENT=:X.MCOMMAND   % Send OMD numer to mf-controller
147113          5OMDNO SH 10=:X.MDP1
147116          X:=OCTORING; T:=5OMDNO
147120          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
147123          CALL MBSEND; GO WT12
147125          GO I5OMBR
147126   RBUS
147133
147133
147133   %============================================================================
147133   %      ( M )    C O N 5 I D E N T
147133   %
147133   % Connect octobus Ident
147133   % (To be able to receive multi byte messages/kicks from the ACCP/Samson)
147133   % Send 'alive' message to the ACCP to verify that it's present
147133   % Activated from level 1 (5pit)
147133   %
147133   % Ack/Nack answer is handled by 5OMBREAD
147133   %
147133   % Entry:  B=CPU datafield
147133   %         X=working datafield
147133   %
147133   SUBR CON5IDENT
147133   INTEGER CWFIELD
147134
147134   CON5IDENT:
147134          X=:CWFIELD; T:=5STATION
147136          X:=OCTORING; N100IDENT=:D; LV12B SHZ -3
147143          CALL ECONID; GO WT12                                % Connect Octobus Ident no.
147145          % Build Octobus message
147145          5STATION=:"LMFIELD".MOCTSTATION                     % Station number
147150          OMDACCP =:        X.MOCTOMD                         % OMD number
147152          0       =:        X.MBROADCAST                      % Not broadcast
147153          7       =:        X.MMSGLENGTH                      % Message length = 1 byte
147155          CMSYSPAR SHZ 10\/N100IDENT=: X.MCOMMAND             % Send system par.
147161          CWFIELD=:B
147163          5OMDNO SHZ 10=:   X.S5
147166          0=:X.S6=:X.S7
147170          T:=5OMDNO; X:=OCTORING
147172          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
147175          CALL MBSEND; GO WT12
147177          GO I5OMBR
147200   RBUS
147206
147206
147206   %============================================================================
147206   %       M B S U S P R O C
147206   %
147206   % SUBROUTINE TO CHECK IF A PROCESS SHOULD BE SUSPENDED
147206   % BECAUSE THE SYSTEM SPENDS TOO MUCH TIME ON HIGHER INTERRUPT LEVELS
147206   % CALLED FROM MCHANDLE.
147206   % IF PROCESS IS SUSPENDED, THEN RETURN TO NXTMSG IN MAIN ND-500 DRIVER
147206   %
147206   % ENTRY:    B=ND-500 CPU DATAFIELD
147206   %           N5MESSAGE=ADDR OF ACTUAL MESSAGE
147206   %
147206   SUBR MBSUSPROC
147206   INTEGER CSUSPTIME:=10        % NUMBER OF TIMESLICE UNITS THE PROCESS WILL BE SUSPENDED
147207   MBSUSPROC:
147207          IF ATIM2-SUSPATIME>62 THEN                  % ND-500 TIMESLICER NOT ACTIVE FOR 1 SEC.
147214             SUSPSTAT; X:=N5MESSAGE; CALL WN5STATUS   % SUSPEND PROCESS
147217             CSUSPTIME; T:=5MBBANK; *AAX SUSPC; STATX; AAX -SUSPC
147224             1=:5SUSPFLAG                             % FLAG FOR TIMESLICER
147226             GO NXTMSG
147227          FI; EXIT
147230   RBUS
147237
147237
147237   %============================================================================
147237   %      G E T   T E R M I N A L    D A T A    F I E L D
147237   %
147237   % ENTRY:     X=ND-500 MESSAGE ADDR
147237   %
147237   % EXIT:      NOT TERMINAL OR TERMINAL NOT RESERVED BY CALLER.
147237   %
147237   % EXIT+1:    A=ADDR OF TERMINAL INPUT DATAFIELD
147237   %            D=ADDR OF TERMINAL OUTPUT DATAFIELD
147237   %
147237   SUBR 5GTDF
147237   INTEGER POINTER GTDFRET
147240   5GTDF:  A:=L=:"GTDFRET"
147242          T:=5MBBANK; *AAX DOUTD; LDDTX             % AD=LOGICAL DEVICE NUMBER
147245          IF A><0 GO NERET                          % ILL. LOG.DEV (MORE THAN 16 BITS)
147246          IF 1=D THEN
147251             *AAX OUTDF-DOUTD; LDXTX
147253             IF X><0 THEN
147254                T:="XDFOPP"; CALL XGTDFADDR         % A=INPUT DATAFIELD
147256                X=:D; MIN "GTDFRET"; GO GTDFRET     % D=OUTPUT DATAFIELD
147261             FI; X:=N5MESSAGE; T:=5MBBANK
147263             *AAX XADPR; LDXTX
147265             IF X:=X.RTRES><0 AND X.STATUS BIT 5BACKGR GO NERET
147272          FI; A:=D                                  % A=LOGICAL DEVICE NUMBER
147273          IF A>=100 AND A<=177 GO NERET             % ASSURE IT'S NOT A FILE WHEN CALLING LOGPH ON LEVEL 12
147301          CALL LOGPH; IF D=0 GO NERET               % NOT OUTPUTDEVICE
147304          A=:L                                      % L=INPUT DATAFIELD; D=OUTPUT DATAFIELD
147305          IF D.TYPRING NBIT 5SPLITDF GO NERET       % ERROR IF NOT TERMINAL
147311          X:=N5MESSAGE; T:=5MBBANK; *AAX XADPR; LDXTX % X=ND-100 PROGR USING ND-500 PROC
147315          IF X.RTRES><D.RTRES GO NERET              % NOT RESERVED BY ACTUAL PROCESS
147322          A:="GTDFRET":=:L                          % A=INPUT DATAFIELD; D=OUTPUT DATAFIELD
147324          EXITA                                     % SKIP RETURN
147325   NERET: X:=N5MESSAGE; GO GTDFRET
147327   RBUS
147334
147334
147334   %=============================================================================%
147334   %      I N S M O N C O
147334   %
147334   %      INSMONCO RESTARTS THE ND-500 PROCESS AFTER THE INPUT BYTES
147334   %      ARE WRITTEN TO THE DATA MEMORY IN THE QUICK INSTRING MONITOR CALL 504.
147334   %
147334   SUBR INSMONCO
147334   INSMONCO: T:=5MBBANK; *AAX SPFLA; STZTX          % CLEAR SPFLAG
147337          *AAX SMCNO-SPFLA; LDATX                   % MONITOR CALL NUMBER
147341          IF A-511=0 THEN A:=100000 ELSE A:=4 FI
147346          *AAX NUMPA-SMCNO; STATX                   % STORE WRITE BACK MASK
147350          A:=0=:D; *AAX FUNCV-NUMPA; STDTX
147354          *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
147357          3MONCO; *MICFU@3 STATX
147361          CALL MCCO
147362          CALL XACTRDY
147363          GO NXTMSG
147364   RBUS
147372
147372
147372   %============================================================================
147372   %       X M W K           N 5 W A K E
147372   % XMWK:
147372   % Started from xmsg when a message arrives on a port belonging
147372   % to nd-500 process.
147372   %
147372   % N5WAKE:
147372   % Started from monitor call handling on 5pit.
147372   %
147372   % Entry:     B = nd-500 message
147372   %
147372   SUBR XMWK,N5WAKE
147372   N5WAKE: K:=1; P+1
147374   XMWK:  K:="0"
147375          T:=5MBBANK; X:=B; *AAX XADPR; LDXTX
147401          X=:B
147402          IF K THEN
147404             CALL XNW5ST; 0/\0
147406          ELSE
147407             CALL NW5ST; P+1; CALL RTACT
147412          FI
147412          X:=MESSBUFF; CALL GCPUDF; CALL ERRFATAL; A=:B
147416          GO CALLID12
147417   RBUS
147426
147426
147426   %============================================================================
147426   %      ( M )   P 1 2 D C N
147426   %
147426   % - DRIVER LEVEL ROUTINE TO DO THE JOB
147426   SUBR P12DCN
147426   P12DCN: T:=XFDCT; * MON 2XMSG
147430          GO CALLID12; GO CALLID12
147432   RBUS
147433
147433
147433   %============================================================================
147433   %       ( M )    S T 0 P S Y S
147433   %
147433   % CONTINUATION ON MLEV OF COMMAND : STOP-SYSTEM
147433   %
147433   % TERMINATE ALL ND-500S (IF ANY) AND SIMULATE POWER FAILURE
147433   %
147433   SUBR ST0PSYS
147433   ST0PSYS: *IOF
147434           IF PN500D><0 AND 5MSINIT BIT 5INBUF THEN
147441             CALL SLOCK; GO BYPASS                        % Lock semaphore
147443             "S5CPUDF"=:B
147445             DO WHILE B<<="E5CPUDF"
147450                IF CPUAVAILABLE BIT 5ALIVE AND A/\5CPUTYPE=SAMSON THEN % CPU present?
147457                   T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
147463                   IF A><0 THEN                           % CPU active?
147464                      77; *AAX X5CLR-X5CPU; STATX         % Clear data tsb+cache+dump+forget process
147467                      CLRKICK; CALL XKICK500
147471                   FI
147471                FI
147471                B+5CPUDFSZ
147472             OD
147473             "S5CPUDF"=:B
147475             DO WHILE B<<="E5CPUDF"
147500                IF CPUAVAILABLE BIT 5ALIVE AND A/\5CPUTYPE=SAMSON THEN % CPU present?
147507                   T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
147513                   IF A-MPACTIVE=0 THEN                           % CPU active?
147515                      1000-=:L
147520                      *AAX X5CLR-X5CPU
147521                      DO
147521                        *LDATX
147522                        WHILE A><0 AND L><0                 % Functions executed ?
147525                        L+1
147526                      OD
147527                      IF L=0 THEN CALL ERRFATAL FI
147532                   FI
147532                FI
147532                B+5CPUDFSZ
147533             OD
147534             FOR X:=0 TO 10000 DO D+1; A:=A+C; OD         % Delay reset-cpu
147544   BYPASS:   "RS5CPU"; *IRW LV12B DP                      % Send "reset cpu" to ACCP
147546             LV12;     *MST PID
147550             *ION
147551             FOR X:=0 TO 10000 DO D+1; A:=A+C; OD         % Delay stop-system
147561             CALL SUNLOCK
147562           FI
147562           "PPWFAIL"; *IRW LV14B DP                     % Continue in "power fail" on level 14
147564           LV14;      *MST PID
147566           *ION
147567           GO STUPR
147570   RBUS
147610
147610
147610   *"-8N500
"147610
147610   @DEV 1
147610   @DEV (S-S-L)MP-P2-DIMIR:NPL
147610   %======================================================================%
147610   %                                                                      %
147610   % ( M )   D I S K   M I R R O R I N G   C O D E                        %
147610   %                                                                      %
147610   %======================================================================%
147610
147610
147610   INTEGER ARRAY DMRMM=?        % READ ACCESS BITS
147610   INTEGER ARRAY DMWMM=?        % WRITE ACCESS BITS
147610   INTEGER ARRAY DMTYP=?        % OPERATIONS CONTROLL FLAGS
147610   INTEGER DHFLG=?              % CLUSTER HEADER FLAGS
147610   INTEGER DIMWA=?              % ADDRESS OF DIMIR WORK AREA
147610   INTEGER DMNRQ=?              % NUMBER OF UNRESERVED QUEUE ELEMENTS
147610   INTEGER DMWCP=?              % CURRENT CLUSTER UPDATE POINTER
147610   INTEGER DMWQP=?              % QUEUE POINTER FOR WRITE CLUSTER WAIT CONDITION
147610   INTEGER DMOFQ=?              % FREELIST POINTER FOR OPERATION DATAFIELDS
147610   INTEGER DMNFO=?              % NUMBER OF UNRESERVED OPERATION DATAFIELDS
147610   INTEGER DMDWQ=?              % POINTER FOR FREE DAQ WAITING QUEUE
147610   INTEGER ERMSA=?, SECNO=?, 9FLP1=?, 9FLP2=?, 9FLP3=?, 9FLP4=?
147610
147610   %====================================================================
147610   %          M T 4
147610   %
147610   % MT4 : MONITOR ENTRY ROUTINE FOR MON SYSU
147610   %
147610   SUBR DMCCU
147610
147610   INTEGER POINTER HOME
147611   DMCCU: A:=L=:"HOME"
147613   *"8DIMI
"147613          IF DMWCP><0 AND "SYUDF".RTRES=0 THEN
147620             0=:DMWCP                            % ABORT WRITE CLUSTER OPERATION
147621             "DMWQP-DLINK"; CALL DMSWQ           % START WAITING QUEUE
147623          FI
147623   *"
"147623          GO HOME
147624   RBUS
147630
147630
147630   *"8DIMI
"147630
147630   %====================================================================
147630   %     D I M I R    D I M S W    D I M S T    D I M R S    D I M E X
147630   %
147630   % DIMIR : MAIN ENTRY POINT FOR DISK MIRRORING
147630   %
147630   %    ENTRY : B = DISK DATAFIELD ADDRESS
147630   %            A = ABSTR PARAMETER LIST ADDRESS
147630   %
147630   %
147630   % DIMST : INITIALIZATION OF DIMIR AFTER WARM START
147630   %
147630   %    ENTRY : X = OPERATION DATAFIELD ADDRESS
147630   %
147630   %
147630   % DIMRS : RESTART FROM MONEN OF OPERATION AFTER WAIT CONDITION
147630   %
147630   %    ENTRY : X = OPERATION DATAFIELD ADDRESS
147630   %
147630   %
147630   % DIMEX : EXIT FROM DISK MIRRORING WHEN OPERATION FINSHED
147630   %
147630   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
147630   %
147630   %    EXIT  :
147630   %
147630   %
147630   SUBR DIMIR, DIMI2, DIMRS, DIMEX
147630
147630   DIMRS: X=:B; IF RTRES=0 GO DIMEX; GO DMRUT  % CONTINUE IF NOT ABORTED
147635
147635
147635   % INITILIAZE DIMIR
147635
147635   INTEGER POINTER DMACT:=DIMST
147636   INTEGER COUNT, CLUPN
147640
147640   DIMST: DHFLG BONE 4WSTA=:DHFLG              % INDICATE WARMSTART
147643          IF X:="DIMWD"><0 THEN CALL RTENTRY FI     % START DIMIR WATCHDOG
147646          "DMCLT-DMTL"=:CLUPN; "-NDMTE"=:COUNT % POINTER AND NUMBER OF CLUSTERS
147652          FOR COUNT DO
147652             CLUPN+"DMTL"=:CLUPN; CALL DMMST   % INITALIZE CLUSTER
147656          OD
147660          CALL DMBST                           % BUILD SEARCH TABLE
147661          "DMPOF"=:"DMACT"=:P                  % ACTIVATE MIRRORING
147664
147664
147664   INTEGER PARP, CTYP, RTPR
147667
147667   *DTRNS=*
147667   DIMIR: A=:PARP; T=:CTYP                     % SAVE PARAMETERS
147671          IF T=0 THEN
147673             L:=0; X:=RTREF=:RTPR              % FROM ABSTR
147676             IF X:=DMNFO-1<=0 THEN
147702                DIMWA=:B; X:="DUMMY"; CALL BRESERVE
147706                X:=RTPR; GO WT                 % WAIT FOR FREE OPERATION DATATFIELD
147710             FI
147710             X=:DMNFO:=DMOFQ; X.DLINK=:DMOFQ   % GET OPERATION DATAFIELD
147714             IF X=0 THEN CALL ERRFATAL FI      % GET OPERATION DATAFIELD
147717          ELSE
147720             X:=RTRES=:RTPR:="QP100".QPFSW     % FROM SWAPPER
147724          FI
147724          X:=:B=:DMCDF; A:=L=:"TRLREG"         % INITALIZE DATAFIELD
147730          0=:DMSTAT; X:=RTPR; CALL BRESERVE    % RESERVE OPERATION DATAFIELD
147733          IF A<0 THEN CALL ERRFATAL FI
147735          CALL WDATA; *IOF                     % SET CALLER TO IOWAIT
147737          X.STATUS BONE 5NOABORT=:X.STATUS; *ION
147743          IF CTYP=0 THEN
147745             PARP; CALL GAPFU                  % PARAMETERS FROM USER
147747          ELSE
147750             PARP; CALL GAPFD                  % PARAMETERS FROM DPIT
147752          FI
147752
147752   %
147752   DIMI2: 0=:DLINK=:HSTAT=:XSTAT=:DMTRG
147756          IF ABFUN=:DMORO/\74=0 THEN
147762             60\/ABFUN=:ABFUN SH -11/\7=:D     % CONVERT TO 32 BITS DISK ADDRESS
147770             ABP21:=:D; AD=:ABPA2
147773          FI
147773          ABFUN=:DMFUN; GO DMACT               % ACTIVATE MIRRORING
147776
147776   *)FILL
150025   %
150025   % COMES HERE WHEN TOTAL OPERATION IS FINISHED
150025   % ENTRY    B = OPERATION DATAFIELD ADDRESS
150025
150025   DIMEX: CALL DMEXC                           % EXIT CLUSTER
150026          IF DMSTAT BIT 6DL12 THEN
150031             *IOF                              % RETURN TO LEVEL 12
150032             DMCDF; *IRW LV12B DB              % DATAFIELD ADDRESS
150034             B=:A; *IRW LV12B DX               % QUEUE ELEMENT
150036             "TRLREG"+1; *IRW LV12B DP         % RETURN ADDRESS
150041             LV12; *MST PID                    % ENABLE LEVEL 12
150043             *ION
150044             GO MONEN
150045          FI
150045          IF X:=RTRES><0 THEN                  % IN CASE ABORTED
150047             CALL RDATA; CALL BRELEASE         % RELEASE OPERATION DATAFIELD
150051          FI
150051          IF "TRLREG"><0 THEN
150053             HSTAT; GO TRLREG                  % RETURN STATUS
150055          FI
150055          CALL DMRTF; IF X=0 GO MONEN          % RETURN OP DATAF TO FREELIST
150060          IF HSTAT BIT 4 THEN A BONE 17 ELSE A BZERO 17 FI
150066          IF X=CURPROG THEN
150071             *IRW ALEVB DA
150072          ELSE
150073             X:=X.RTDLGADDR; T:=0; *AAX DAREG; STATX
150077          FI
150077          GO STUPR
150100
150100   RBUS
150110
150110
150110   %====================================================================
150110   %              D M R T F
150110   %
150110   % DMRTF : RETURN OPERATION DATAFIELD TO FREELIST
150110   %
150110   %    ENTRY : B = OPERATION DATAFIELD
150110   %
150110   %    EXIT  : B = OPERATION DATAFIELD
150110   %
150110   %    USES T,A,D
150110   %
150110   SUBR DMRTF
150110   INTEGER POINTER HOME
150111   INTEGER SAVX
150112
150112   DMRTF: A:=L=:"HOME"; X=:SAVX
150115          DMOFQ=:DLINK; A:=B=:DMOFQ; MIN DMNFO % LINK INTO FREELIST
150122          IF DIMWA.RTRES><0 AND DMNFO>0 THEN
150130             B=:D; X=:B:=0
150133             CALL BRELEASE; D=:B               % RELEASE WAITING SEMAPHORE
150135          FI
150135          X:=SAVX; GO HOME
150137   RBUS
150143
150143
150143   %====================================================================
150143   %              D M E N C    D M E X C
150143   %
150143   % DMENC : ENTER A CLUSTER I.E. BAND UPDATE FROM MON SYSU
150143   %
150143   %    ENTRY : B = OPERATION DATAFIELD
150143   %
150143   %    EXIT  :
150143   %
150143   %    USES T,A,D,X
150143   %
150143   %
150143   % DMEXC : LEAVE A CLUSTER I.E. ALLOW UPDATE FROM MON SYSU
150143   %
150143   %    ENTRY : B = OPERATION DATAFIELD
150143   %
150143   %    EXIT  :
150143   %
150143   %    USES T,A,D,X
150143   %
150143   %
150143   SUBR DMENC, DMEXC
150143   INTEGER POINTER HOME
150144
150144   DMENC: IF X:=CLUPT=DMWCP THEN
150150             "DMWQP-DLINK"                     % MON SYSU WRITE CONDITION
150151             T:="DMCHK"; GO DMTWQ              % RESTART LATER
150153          FI
150153          MIN CLUPT.DMNOS                      % INCREASE COUNT
150155          DMSTAT BONE 6DMIR BONE 6DICL=:DMSTAT % INDICATE INSIDE
150161          EXIT
150162
150162   DMEXC: A:=L=:"HOME"
150164          IF DMSTAT BIT 6DMIR AND BIT 6DICL THEN
150171             A BZERO 6DICL=:DMSTAT             % INDICATE OUTSIDE
150173             IF CLUPT.DMCDP=B THEN
150177                0=:X.DMCDP                     % RESET CRW INDICATOR
150200                "DMCWQ-DLINK"+X; CALL DMSWQ    % RESTART WAITING QUEUE
150203             FI
150203             CLUPT.DMNOS-1=:X.DMNOS            % DECREASE COUNT
150207             IF A=0 AND X=DMWCP THEN
150213                CALL DMWCM                     % PERFORM MSYSU WRITE CLUSTER
150214             FI
150214          FI
150214          DMSTAT SHZ -16; CALL FTSRQ           % RELEASE RESERVED DAQ'S
150217          GO HOME
150220   RBUS
150230
150230
150230   %====================================================================
150230   %              F T S R Q
150230   %
150230   % FTSRQ : RELEASE RESERVED DAQ'S
150230   %
150230   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
150230   %            A = NUMBER OT RELEASE
150230   %
150230   %    USES T,A,D,X
150230   %
150230   SUBR FTSRQ
150230   INTEGER POINTER HOME
150231
150231   FTSRQ: T:=L=:"HOME"
150233          D:=A SHZ 16; T:=DMSTAT-D=:DMSTAT     % REDUCE NUMBER RESERVED
150240          IF C NBIT THEN CALL ERRFATAL FI
150243          A+DMNRQ=:DMNRQ                       % NUMBER OF UNRESERVED DAQ'S
150245          IF X:=DMDWQ><0 THEN                  % SOMEONE WAITING FOR DAQ'S
150247             IF A>=X.DMSTAT SHZ -16 THEN
150253                A-T=:DMNRQ                     % RESERVE NUMBER WANTED
150255                X:=:B; DLINK=:DMDWQ; 0=:DLINK  % REMOVE FROM QUEUE
150261                CALL RTACT; X=:B               % RESTART OPERATION
150263             FI
150263          FI
150263          GO HOME
150264   RBUS
150270
150270
150270   %====================================================================
150270   %              D M E X E
150270   %
150270   % DMEXE : START OPERATION
150270   %
150270   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
150270   %            A = MEMBER NUMBER (0=NOT CLUSTER)
150270   %
150270   %    USES T,A,D,X
150270   %
150270   SUBR DMEXE
150270
150270   DISP 14; TRIPLE PAR1,PAR2,PAR3; PSID
150270
150270   INTEGER POINTER HOME
150271   INTEGER MB, MBPT
150273   INTEGER SAVB=?
150273
150273   DMEXE: A=:MB:=L=:"HOME"; X:="QP100":=:B=:SAVB
150301          IF T:=DMDAQ=0 THEN
150304             X:=X.RTRES; *IOF                  % GET NEW DAQ
150306             CALL GETFREE; CALL ERRFATAL; *ION
150311          ELSE
150312             0=:DMDAQ                          % USE LAST DAQ
150313          FI
150313          B:=T; X:=SAVB.RTRES; CALL BRESERVE   % RESERVE QUEUE ELEMENT
150317          IF A<0 THEN CALL ERRFATAL FI
150321          X:=SAVB=:DMLINK; "CONTOP"=:"TRLREG"  % INITIALIZE QUEUE ELEMENT
150325          X.PAR1=:PAR1; X.PAR2=:PAR2; X.PAR3=:PAR3
150333          IF MB=:CLMNO><0 THEN
150336             A-1*DULEN+X.CLUPT=:MBPT           % POINTER TO CLUSTER MEMBER ENTRY
150342             A.PRDEV/\7 SHZ 6=:T               % GET UNIT
150347             ABFUN/\177077\/T=:ABFUN           % INSERT IN FUNCTION
150353             IF SAVB.DMSTAT BIT 6DADR AND MB><1 THEN
150363                X.CLUPT.PRLOE                  % BASE ADDRESS=LOWER BOUND OF EXTENSION
150365                *COPY CM2 SD DT                % 2'S COMPLEMENT
150366                *COPY ADC CM1 SA DL
150367                ABPA2                          % ABSOLUTE DISK ADDRESS
150370                *RADD SD DT                    % LT = RELATIVE DISK ADDRESS WITHIN EXTENT
150371                *RADD ADC SA DL
150372                MBPT.PRLOE                     % LOWER BOUND OF TARGET EXTENT
150374                *RADD ST DD                    % AD = NEW ABSOLUTE DISK ADDRESS
150375                *RADD ADC SL DA
150376                AD=:ABPA2                      % STORE IN COPY OF PARAM LIST
150377             FI
150377             MBPT.PRCDF                        % GET DATAFIELD ADDRESS
150401          ELSE
150402             X.DMCDF                           % USE ORIGINAL DISK DATAFIELD
150403          FI
150403          *IOF; IRW LV11B DB                   % DISK DATAFIELD
150405          A."STDRIV"; *IRW LV11B DT            % DRIVER START ADDRESS
150410          SAVB:=:B; *IRW LV11B DX              % QUEUE ELEMENT
150413          "SLV11"; *IRW LV11B DP               % LEVEL 11 START ADDRESS
150415          LV11; *MST PID; ION                  % ACTIVATE
150420          DMRWM+40000=:DMRWM                   % COUNT SUBOPERATIONS UP
150423          GO HOME
150424   *)FILL
150440
150440   % COME HERE WHEN A DISC ACCESS QUEUE ELEMENT HAS BEEN RETURNED FROM DRIVER
150440
150440   INTEGER SAVB
150441
150441   CONTOP: X=:DMDAQ                            % DAQ ADDRESS
150442          X.DMLINK=:SAVB:=:B=:X.DMLINK         % GET OPERATION DATAFIELD ADDRESS
150446          DMRWM-40000=:DMRWM                   % COUNT SUBOPERATIONS DOWN
150451          IF RTRES><0 THEN
150453             CALL DMECK; X:=DMDAQ              % CHECK FOR ERRORS
150455             IF T:=DMSTAT NBIT 6DMIR  THEN
150460                X.SSSTAT=:HSTAT                % NOT MIRRORED
150462                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
150466             ELSE
150467             IF T BIT 6DADR THEN
150471                IF 7/\T=1 THEN
150476                   CALL DMCRO                  % CONTINUE READ TYPE OPERATION
150477                ELSE
150500                IF A=2 THEN
150503                   CALL DMCWO                  % CONTINUE WRITE TYPE OPERATION
150504                ELSE
150505                   CALL DMCCO                  % CONCATENATED READ/WRITE OPERATION
150506                FI FI
150506             ELSE
150507                CALL DMCSO                     % CONTINUE SPECIAL OPERATION
150510             FI FI
150510          FI
150510          IF T:=DMDAQ><0 THEN
150513             0=:DMDAQ; "QP100"=:B; *IOF        % RELEASE QUEUE ELEMENT
150517             CALL PUTFREE; SAVB=:B; *ION
150523          FI
150523          GO DMCCK
150524   RBUS
150536
150536
150536   %====================================================================
150536   %              D M W C R     D M W C M
150536   %
150536   % DMWCA : CONTROLS WRITING OF CLUSTER ENTRY. CALLED FROM ALEV
150536   %
150536   % DMWCM : CONTROLS WRITING OF CLUSTER ENTRY. CALLED FROM MLEV
150536   %
150536   %    ENTRY :
150536   %
150536   %    EXIT  :
150536   %
150536   SUBR DMWCA, DMWCM
150536
150536   DISP SUWA=SYUWA
150536      INTEGER ARRAY DMTCOPY(0)
150536   PSID
150536
150536   INTEGER POINTER SAVL
150537
150537   DMWRC: A:=L=:"SAVL"; 0=:DMWCP
150542          IF "CLSEM".RTRES=RTRES AND CLUP.DMRFL NBIT 8DMSS THEN
150553             IF X.DMNOS=0 THEN
150555                FOR X:=0 TO "DMTLW-1" DO
150561                   DMTCOPY(X)=:CLUAP(X)        % COPY CLUSTER ENTRY BACK
150563                OD
150565                CLUP; CALL DMMST; CALL DMBST   % INITIALIZE CLUSTER
150570                0=:ZAREG                       % MARK WRITE PERFORMED
150571             ELSE
150572                X=:DMWCP                       % INDICATE WAIT CONDITION
150573             FI
150573          FI
150573          GO SAVL
150574
150574   DMWCA: "SYUDF"=:B; CLCNG=:ZAREG; CALL DMWRC % TRY TO WRITE
150601          IF DMWCP><0 THEN
150603             X:=RTRES; CALL WDATA; GO RWAIT    % SET IOWAIT
150606          FI
150606          GO MONEN
150607
150607   INTEGER SAVB
150610   INTEGER POINTER HOME
150611
150611   DMWCM: "SYUDF":=:B=:SAVB:=L=:"HOME"
150616          IF RTRES><0 THEN
150620             CALL DMWRC                        % TRY TO WRITE
150621             IF DMWCP=0 THEN
150623                X:=RTRES; CALL RDATA; 1=:MTOR  % REMOVE IOWAIT
150627             FI
150627          ELSE
150630             0=:DMWCP                          % ABORT WRITE
150631          FI
150631          IF DMWCP=0 THEN
150633             "DMWQP-DLINK"; CALL DMSWQ         % RESTART WAITING QUEUE
150635          FI
150635          A:=SAVB=:B; GO HOME
150640   RBUS
150655
150655
150655   %====================================================================
150655   %              D M S W Q
150655   %
150655   % DMSWQ : RESTART A WAITING QUEUE
150655   %
150655   %    ENTRY : A = QUEUE POINTER (OFFSET WITH "DLINK")
150655   %
150655   %    EXIT  :
150655   %
150655   SUBR DMSWQ
150655   INTEGER SAVB
150656   INTEGER POINTER HOME
150657
150657   DMSWQ: A=:X:=L=:"HOME":=B=:SAVB
150664          DO
150664             WHILE X.DLINK><0
150666             A=:B; DLINK=:X.DLINK; 0=:DLINK    % REMOVE FROM QUEUE
150672             CALL RTACT                        % RESTART OPERATION
150673          OD
150674          SAVB=:B; GO HOME
150677   RBUS
150700
150700
150700   %====================================================================
150700   %              C M P 2
150700   %
150700   % CMP2 : COMPARE TWO UNSIGNED DOUBLES
150700   %
150700   %    ENTRY : AD = DOUBLE 1
150700   %            T  = POINTER TO DOUBLE 2
150700   %
150700   %    EXIT  : A = -1 IF D1<D2
150700   %              =  0 IF D1=D2
150700   %              =  1 IF D1>D2
150700   %
150700   %    USES A,D
150700   %
150700   SUBR CMP2
150700   INTEGER SAVX
150701
150701   CMP2:  X=:SAVX:=T
150703          IF A>>X.S0 GO GT; IF A<<T GO LT      % CHECK FIRST WORD
150710          IF D>>X.S1 GO GT; IF D<<T GO LT      % CHECK SECOND WORD
150715          "0"; T:=SAVX:=:X; EXIT
150721   GT:    "1"; T:=SAVX:=:X; EXIT
150725   LT:    "-1"; T:=SAVX:=:X; EXIT
150731   RBUS
150731
150731
150731   %====================================================================
150731   %              C C L N O
150731   %
150731   % CCLNO : COMPUTE CLUSTER NUMBER GIVEN CLUSTER POINTER.
150731   %
150731   %    ENTRY : A = CLUSTER POINTER
150731   %
150731   %    EXIT  : A = CLUSTER NUMBER
150731   %
150731   %    USES T,A,D,X
150731   %
150731   SUBR CCLNO
150731   CCLNO: A-"DMCLT"=:D:=0; T:="DMTL"; *RDIV ST
150736          A+1; EXIT
150740   RBUS
150741
150741   %====================================================================
150741   %            D M C H K    D M R U N    D M C C K
150741   %
150741   %
150741   % DMPOF : ENTRY POINT TO MIRRORING
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   % DMCHK : CHECK IF REQUEST SHOULD BE MIRRORED
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %
150741   % DMRUN : RESTART POINT FROM DAQ WAITING QUEUE
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %
150741   % DMCCK : CONTINUE CHECK ON NEXT CLUSTER
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %    USES T,A,D,X
150741   %
150741   SUBR DMPOF, DMCHK, DMRUN, DMCCK
150741
150741   INTEGER ACMSK=?
150741
150741   DMPOF: 77/\DMFUN=:X; T:="DMTYP"; *LBYT      % GET OPERATION TYPE
150746          X:=DMSTAT\/A BONE 6DMIR=:DMSTAT      % TO STATUS WORD
150752          IF X NBIT 6DMOP THEN GO NOMI FI      % NOT MIRRORED OPCODE
150755          IF 7/\X><3 AND DMFUN BIT 14 AND BIT 15 THEN
150767             ABFUN/\147777=:ABFUN              % REMOVE FORCE BITS
150772             X BONE 6DFNM=:DMSTAT; GO NOMI     % MARK FORCED NOT MIRRORED
150775          FI
150775          IF X BIT 6DADR THEN
150777             T:=ABP31-1; ABPA2                 % COMPUTE
151002             *RADD ST DD; RADD ADC DA          % HIGH ADDRESS OF DISK AREA
151004             AD=:APHDI                         % AND PLACE IN OP DATAF
151005          FI
151005          0=:DMRWM=:HSTAT
151007
151007   DMCHK: IF T:=DMSTAT BIT 6DADR THEN          % CHECK WITHIN EXTENSION
151012             DMFUN SHR -6/\7+DMCDF=:L; X:="DMFST"
151020             DO; X.DS0; WHILE A<<L; X+D; OD    % SEARCH FOR DATAFIELD/UNIT
151025             IF A>>L GO NOMI                   % NOT FOUND
151027             T:=X.S2; X+D; APHDI; CALL CMP2    % COMPARE WITH FIRST IN TABLE
151033             IF A < 0 GO NOMI                  % STRICTLY BELOW I.E. OUTSIDE
151034             DO
151034                X-1; T:=X.S0; APHDI; CALL CMP2 % COMPARE WITH LOW LIMIT OF AREA
151040                WHILE A<0                      % WHILE STRICLY BELOW
151041             OD
151042             ABPA2; T+2; CALL CMP2             % COMPARE WITH HIGH LIMIT OF AREA
151045             IF A>=0 GO NOMI                   % OUTSIDE
151046             "-DMCLT"+T=:D:=0; T=:X:=DMTL; *RDIV ST
151055             IF D>="DULEN" THEN
151060                IF DMSTAT NBIT 6DILS  GO NOMI  % LEGAL ACCESS TO SECONDARY
151063                GO ERREX                       % ILLEGAL ACCESS TO SECONDARY
151064             FI
151064             X-D=:CLUPT; *AAX DMSS0            % ACCESS TO PRIMARY
151067             DO
151067                377/\X.S0+CLUPT=:T             % ADDRESS OF NEXT AREA LOW BOUNDARY
151073                ABPA2; CALL CMP2               % COMPARE WITH ACCESS LOW BOUNDARY
151075                WHILE A>=0; X+1                % UNTIL BELOW A BOUNDARY
151077             OD
151100             APHDI; CALL CMP2                  % CHECK FOR PARTIAL OVERLAP
151102             IF A>=0 THEN                      % PARTIAL OVERLAP !!
151103   ERREX:       NOTAVAIL=:HSTAT                % ILLEGAL ACCESS TO SECONDARY
151105                ILADR; CALL DMEMS; GO DIMEX    % "ILLEGAL ACCESS TO MEMBER OR AREA"
151110             FI
151110             X.S0/\ACMSK=:DMRWM                % AREA ACCESS BITS
151113             CALL DMENC; GO MIROP              % ENTER CLUSTER
151115          FI
151115          GO DMRUN                             % SPECIAL OPERATION
151116          *)FILL
151132   NOMI:  DMSTAT BZERO 6DMIR=:DMSTAT; GO DMRUN % SET NOT MIRRORED
151136   *)FILL
151137
151137
151137   INTEGER ACMSK:=0
151140   * *-1/1@5DRM1+^; *-1/1@5DRM2+^; *-1/1@5DRM3+^    % READ BITMASK
151140   * *-1/1@5DWM1+^; *-1/1@5DWM2+^; *-1/1@5DWM3+^    % WRITE BITMASK
151140
151140   MIROP:  IF CLUPT.DMCDP><0 THEN
151143   % OPERATION MIRRORED, ADDRESS DEPENDENT AND CONCATENATED OPERATION IN PROGRESS
151143             IF 7/\DMSTAT=3 THEN
151150                "DMCWQ-DLINK"+X                % ONLY ONE A TIME
151152                T:="MIROP"; GO DMTWQ           % RESTART LATER
151154             FI
151154             X:=X.DMCDP; CALL CHKOL            % CHECK FOR OVERLAP
151156             X:=CLUPT.DMCWQ                    % START OF WATING QUEUE
151160             DO
151160                WHILE X><0                     % FOR ALL WAITING
151161                CALL CHKOL                     % CHECK FOR OVERLAP
151162                X:=X.DLINK                     % NEXT OPERATION
151163             OD
151164          FI
151164
151164   DMRUN: IF T:=DMSTAT NBIT 6DMIR THEN
151167             "1"; CALL FTSGQ                   % ENSURE THAT A DAQ IS AVAILABLE
151171             "0"; CALL DMEXE                   % NO MIRRORING NECESSARY
151173          ELSE
151174          IF T BIT 6DADR THEN
151176             IF 7/\T=1 THEN
151203                CALL DMSRO                     % START READ TYPE OPERATION
151204             ELSE
151205             IF A=2 THEN
151210                CALL DMSWO                     % START WRITE TYPE OPERATION
151211             ELSE
151212                CALL DMSCO                     % START CONCATENATED READ/WRITE
151213             FI FI
151213          ELSE
151214             CALL DMSSO                        % START SPECIAL OPERATION
151215          FI FI
151215
151215   DMCCK: IF DMRWM SHZ -16=0 THEN              % ALL SUBOPERATIONS FINISHED
151220             IF X:=RTRES><0 THEN
151222                IF DMSTAT BIT 6DMIR AND BIT 6DEMS THEN
151227                   IF HSTAT BIT 4 THEN
151232                      DTRER; CALL DMEMS        % OPERATION FAILED MESSAGE
151234                   FI
151234                FI
151234             FI
151234             GO DIMEX                          % FINSHED
151235          FI
151235          IF RTRES=RTREF GO RWAIT; GO MONEN
151242   *)FILL
151262
151262   % LOCAL ROUTINE TO CHECK FOR OVERLAPPING AREAS
151262   INTEGER POINTER LREG
151263   CHKOL: A:=L=:"LREG"
151265          T:="ABPA2"+B; X.APHDI
151270          CALL CMP2; IF A<0 GO LREG            % ABOVE AREA
151273          "ABPA2"+X=:T; APHDI
151277          CALL CMP2; IF A<0 GO LREG            % BELOW AREA
151302          "DMCWQ-DLINK"+CLUPT                  % OVERLAPPING AREAS
151304          T:="MIROP"; GO DMTWQ                 % RESTART LATER
151306   RBUS
151313
151313
151313   %====================================================================
151313   %              D M M S T
151313   %
151313   % DMMST : INITIALISE A CLUSTER AFTER STATUS CHANGE
151313   %
151313   %    ENTRY : A = POINTER TO CLUSTER ENTRY
151313   %
151313   %    EXIT  :
151313   %
151313   %    USES: T,A,D,X
151313   %
151313   SUBR DMMST
151313   INTEGER POINTER HOME
151314   INTEGER SAVB
151315
151315   DMMST: A:=:B=:SAVB:=L=:"HOME"
151321          IF DMFLG BIT 8DEUS AND BIT 8DMIR THEN
151326             A BONE 8DERR=:DMFLG; D:=0
151331
151331   % CHECK PRIMARY
151331             T:=PRFLG BZERO 9DREA BZERO 9DWRI  % ZERO READ AND WRITE FLAGS
151334             IF T NBIT 9DDIS THEN
151336                T BONE 9DWRI; D BONE 5DWM1     % CONNECTED
151340                IF PRVAL=0 THEN
151342                   T BONE 9DREA; D BONE 5DRM1  % VALID
151344                   DMFLG BZERO 8DERR=:DMFLG    % AT LEAST ONE VALID
151347                FI
151347             ELSE
151350                -1=:PRVAL                      % DISCONNECTED
151352                IF T BIT 9DCNG THEN
151354                   T BONE 9DWRI; D BONE 5DWM1  % DISCONNECT IN PROCESS
151356                FI
151356             FI
151356             T=:PRFLG
151357
151357   % CHECK SECONDARY-1
151357             T:=S1FLG BZERO 9DREA BZERO 9DWRI       % ZERO READ AND WRITE FLAGS
151362             IF S1CDF><0 THEN
151364                IF T NBIT 9DDIS THEN
151366                   T BONE 9DWRI; D BONE 5DWM2       % CONNECTED
151370                   IF S1VAL\/S1NUA=:S1VAL=0 THEN    % IN CASE ACTIVE NO UPDATE AREAS
151374                      T BONE 9DREA; D BONE 5DRM2    % VALID
151376                      DMFLG BZERO 8DERR=:DMFLG      % AT LEAST ONE VALID
151401                   FI
151401                ELSE
151402                   -1=:S1VAL                        % DISCONNECTED
151404                   IF T BIT 9DCNG THEN              % DISCONNECT IN PROCESS
151406                      T BONE 9DWRI; D BONE 5DWM2
151410                   FI
151410                FI
151410             FI
151410             T=:S1FLG
151411
151411   % CHECK SECONDARY-2
151411             T:=S2FLG BZERO 9DREA BZERO 9DWRI  % ZERO READ AND WRITE FLAGS
151414             IF S2CDF><0 THEN
151416                IF T NBIT 9DDIS THEN
151420                   T BONE 9DWRI; D BONE 5DWM3       % CONNECTED
151422                   IF S2VAL\/S2NUA=:S2VAL=0 THEN    % IN CASE ACTIVE NO UPDATE AREAS
151426                      T BONE 9DREA; D BONE 5DRM3    % VALID
151430                      DMFLG BZERO 8DERR=:DMFLG      % AT LEAST ONE VALID
151433                   FI
151433                ELSE
151434                   -1=:S2VAL                        % DISCONNECTED
151436                   IF T BIT 9DCNG THEN
151440                      T BONE 9DWRI; D BONE 5DWM3    % DISCONNECT IN PROCESS
151442                   FI
151442                FI
151442             FI
151442             T=:S2FLG
151443
151443
151443             IF DMFLG BIT 8DERR AND BIT 8DCOE THEN
151450                IF X:=3/\A >< 0 THEN
151453                   DMRMM(X)\/DMWMM(X); D\/A    % USE PASSTHROUGH
151456                FI
151456             ELSE
151457                A/\177770=:DMFLG               % NO PASSTHROUGH
151461             FI
151461
151461             CALL BUSST                        % BUILD SEARCH TABLE
151462          FI
151462          SAVB=:B; GO HOME
151465   *)FILL
151471
151471   % LOCAL ROUTINE TO BUILD CLUSTER SEARCH TABLE (D = ACCESSBITS)
151471
151471   INTEGER MAXEL, COUNT, NNUA, SAVD, ACCBT
151476   INTEGER POINTER SAVL1
151477
151477   BUSST: A:=D=:ACCBT:=L=:"SAVL1"
151503   %
151503   % INSERT PRIMARY EXTENT
151503          "PRLOE"\/D=:DMSST(0)                 % LOW EXTENT
151507          "PRHIE"\/D=:DMSST(1)                 % HIGH EXTENT
151513          1=:MAXEL                             % MAX ELEMENT
151515   %
151515   % INSERT EXTENT OF NO UPDATE AREAS
151515          "-NNUAC"=:COUNT; 0=:NNUA
151520          FOR COUNT DO
151520             ACCBT=:D                          % ORIGINAL BITMASK TO D
151522             NNUA SHZ 3; *ADD (BLDA 10 DT      % BIT LOAD INSTRUCTION
151525             T:=S1NUA; *EXR SA                 % SECONDARY-1 ENABLE BIT TO K
151527             IF K THEN D BZERO 5DRM2 BZERO 5DWM2 FI
151533             T:=S2NUA; *EXR SA                 % SECONDARY-2 ENABLE BIT TO K
151535             IF K THEN D BZERO 5DRM3 BZERO 5DWM3 FI
151541             IF T:=ACCBT><D THEN
151544                NNUA SHZ 2+"DMNUA"; T\/A; A+2\/D=:SAVD
151553                T=:A; CALL SORT1               % LOW BOUNDARY
151555                SAVD; CALL SORT2               % HIGH BOUNDARY
151557             FI
151557             MIN NNUA                          % NEXT AREA
151560          OD
151562          GO SAVL1
151563   *)FILL
151571
151571   % LOCAL ROUTINE TO SORT IN A BOUNDARY AND SET ACCESS BITS
151571
151571   INTEGER NEXT, SAVE
151573   INTEGER POINTER SAVL2
151574
151574   SORT1: 0=:NEXT
151575   SORT2: A=:SAVE:=L=:"SAVL2"
151600          X:=NEXT                              % START INDEX
151601          DO
151601             WHILE X<=MAXEL
151604             DMSST(X)/\377+B=:T                % CURRENT BOUNDARY
151610             377/\SAVE+B; X=:L; A.DS0; X:=L    % BOUNDARY TO SORT
151617             CALL CMP2; WHILE A>0              % GREATER THAN CURRENT
151622             SAVE\/377/\DMSST(X)=:DMSST(X)     % NEW ACCESS BITS
151626             X+1                               % NEXT ELEMENT
151627          OD
151630          X=:T+1=:NEXT
151633          IF X:=MAXEL>=T THEN
151636             IF A<0 THEN
151637                X:="2*NNUAC"; MIN MAXEL        % COPY TABLE ONE POSITION UP
151641                DO WHILE X>=T
151643                   DMSST(X); X+1               % COPY ENTRY
151645                   A=:DMSST(X); X-2            % ONE POSITION UP
151647                OD
151650             FI
151650             DMSST(T)\/377/\SAVE=:DMSST(X)     % NEW ACCESS BITS
151655          FI
151655          GO SAVL2
151656   RBUS
151660
151660
151660   %====================================================================
151660   %              D M B S T
151660   %
151660   % DMBST : BUILD FAST SEARCH TABLE
151660   %
151660   %    ENTRY :
151660   %
151660   %    EXIT  :
151660   %
151660   %    USES: T,A,D,X
151660   %
151660   SUBR DMBST
151660
151660   INTEGER POINTER HOME
151661   INTEGER LOOP, COUNT, SAVB
151664
151664   INTEGER NEXT=?
151664
151664   DMBST: "DMCLT":=:B=:SAVB:=L=:"HOME"
151671          X:="DMFST"=:NEXT; -1=:X.S0           % INITIALIZE TABLE
151675          "-NDMTE"=:LOOP
151677          FOR LOOP DO
151677             "NDMTE"+LOOP*DMTL+"DMCLT"=:B      % CLUSTER POINTER
151704             IF DMFLG BIT 8DMIR THEN
151707                17/\PRDEV+PRCDF; CALL NWEL     % MIRRORING ENABLED
151713                -2=:COUNT
151715                FOR COUNT DO
151715                   B+DULEN                     % NEXT MEMBER
151716                   IF PRFLG BIT 9DWRI THEN
151721                      17/\PRDEV+PRCDF; CALL NWEL
151725                   FI
151725                OD
151727             FI
151727          OD
151731          A:=SAVB=:B; GO HOME
151734
151734   INTEGER POINTER LREG
151735   INTEGER NEXT
151736   INTEGER SAVX
151737
151737   NWEL:  A=:T:=L=:"LREG"; X:="DMFST"
151743          DO; X.DS0; WHILE A<<T; X+D; OD       % SEARCH FOR DATAFIELD/UNIT
151750          IF A>>T THEN
151752             CALL INSW; X+1                    % NEW DATAFIELD/UNIT
151754             T:=3; CALL INSW; X+1              % NEW AREA COUNT
151757          ELSE
151760             MIN X.S1; X=:SAVX+D; *LDT ,X -1   % INCREASE AREA COUNT
151764             PRLOE; CALL CMP2
151766             IF A<0 THEN                       % NEW AREA BELOW LAST IN TABLE ?
151767                X:=SAVX+2                      % YES
151771                DO
151771                   PRLOE; T:=X.S0; CALL CMP2   % COMPARE WITH CURRENT
151774                   WHILE A>0; X+1              % WHILE ABOVE
151777                OD
152000             FI
152000          FI
152000          T:="PRLOE"+B; CALL INSW              % INSERT AREA
152003          GO LREG
152004
152004   % INSERT T IN TABLE, X=POSITION
152004   INSW:  X=:D:=NEXT+1=:NEXT                   % NEXT INDEX
152010          DO
152010             X-1; X.S0=:X.S1                   % MOVE ENTRY 1 POSITION UP
152013             WHILE X><D                        % UNTIL WANTED POSITION
152015          OD
152016          T=:X.S0; EXIT
152020   RBUS
152034
152034
152034   %====================================================================
152034   %                  D M T W Q
152034   %
152034   % DMTWQ : INSERT A DATAFIELD IN A WAITING QUEUE
152034   %
152034   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152034   %            A = QUEUE POINTER (OFFSET WITH "DLINK")
152034   %            T = RESTART ADDRESS
152034   %
152034   SUBR DMTWQ
152034
152034   DMTWQ: T=:"DMRUT"                           % SAVE RESTART ADDRESS
152035          DO; A=:X; WHILE X.DLINK><0; OD       % GET END OF QUEUE
152041          A:=B=:X.DLINK; 0=:DLINK              % INSERT AT END
152044          IF RTRES=RTREF GO RWAIT; GO MONEN
152051   RBUS
152054
152054
152054   %====================================================================
152054   %              F T S G Q
152054   %
152054   % FTSGQ : RESERVE A NUMBER DAQ'S
152054   %
152054   %    ENTRY : B = OPERATION DATAFIELD
152054   %            A = NUMBER OF DAQ'S WANTED
152054   %
152054   %    EXIT  : B = OPERATION DATAFIELD
152054   %            NO RETURN IF NOT ENOUGH DAQ'S
152054   %
152054   % USES T,A,D,X
152054   %
152054   SUBR FTSGQ
152054   INTEGER NODAQ
152055
152055   FTSGQ: A=:NODAQ
152056          IF T:=DMSTAT SHZ -16=0 THEN
152062             A SHZ 16\/DMSTAT=:DMSTAT          % INSERT NUMBER WANTED
152065             IF DMNRQ-NODAQ<0 OR T:=DMDWQ><0 THEN
152073                "DMDWQ-DLINK"
152074                T:="DMRUN"; GO DMTWQ           % RESTART LATER
152076             FI
152076             A=:DMNRQ                          % INDICATE RESERVED
152077          FI
152077          EXIT
152100   RBUS
152105
152105
152105   %====================================================================
152105   %              D M E M S
152105   %
152105   % DMEMS : GIVE ERRORMESSAGE
152105   %
152105   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152105   %            A = ERROR CODE
152105   %
152105   %    USES T,A,D,X
152105   %
152105   SUBR DMEMS
152105   INTEGER POINTER HOME
152106
152106   DMEMS: A=:SECNO:=L=:"HOME"                  % ERROR CODE
152111          CLUPT; CALL CCLNO; A=:9FLP1          % CLUSTER NUMBER
152114          DMORO=:9FLP2                         % ORIGINAL FUNCTION
152116          IF X:=RTRES="RWRT1" THEN
152122             X:="DF1".RTRES
152124          ELSE
152125          IF X="RWRT2" THEN
152130             X:="DF2".RTRES
152132          FI FI
152132          CALL 9FLEX(ERMSA,3)                  % SEND ERROR MESSAGE THROUGH 9FLEA
152135          GO HOME
152136   RBUS
152147
152147
152147   %====================================================================
152147   %              D M E C K
152147   %
152147   % DMECK : DO ERROR CHECKING FOR DISK MIRRORING
152147   %
152147   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152147   %            X = DAQ
152147   %
152147   %    EXIT  :
152147   %
152147   %    USES T,A,D,X
152147   %
152147   SUBR DMECK
152147   INTEGER POINTER HOME
152150   INTEGER MBPT, DAQ, VALFL
152153
152153   DMECK: A:=L=:"HOME"; X=:DAQ
152156          IF X.SSSTAT BIT 4 THEN
152161             IF DMSTAT BIT 6DDCN AND BIT 6DICL THEN
152166   %
152166   % DISCONNECT MEMBER
152166                X.CLMNO-1*DULEN+CLUPT=:MBPT         % POINTER TO MEMBER ENTRY
152173                IF MBPT.PRFLG NBIT 9DDIS THEN
152177                   X.PRFLG BONE 9DDIS BONE 9DCNG=:X.PRFLG
152203                   X.PRVAL=:VALFL                   % SAVE VALIDFLAG
152205                   CLUPT.DMRFL BONE 8DMSS=:X.DMRFL  % INDICATE CHANGED CLUSTER ENTRY
152211                   A:=X; CALL DMMST; CALL DMBST     % UPDATE CLUSTER ENTRY
152214                   MBDCN=:SECNO                     % "MEMBER DISCONNECTED"
152216                   CLUPT; CALL CCLNO; A=:9FLP1      % CLUSTER NUMBER
152221                   DAQ.CLMNO=:9FLP2                 % MEMBER NUMBER
152224                   X.SSSTAT=:9FLP3                  % HARDWARE STATUS
152226                   X.DMTRG=:9FLP4                   % DRIVER T-REGISTER
152230                   X:=0; CALL 9FLEX(ERMSA,5)
152234                   IF VALFL=0 THEN                  % CHECK IF BE LAST VALID
152236                      CLUPT.DMFLG/\177770\/DAQ.CLMNO=:CLUPT.DMFLG
152245                      IF X.PRFLG\/X.S1FLG\/X.S2FLG NBIT 9DREA THEN
152252                         NOVALMB=:SECNO             % "NO VALID MEMBER IN CLUSTER"
152254                         A:=X; CALL CCLNO; A=:9FLP1 % CLUSTER NUMBER
152257                         X:=0; CALL 9FLEX(ERMSA,2)
152263                      FI
152263                   FI
152263                   DHFLG BONE 4DISC=:DHFLG          % WARN DIMWD
152266                   IF X:="DIMWD"><0 THEN
152270                      CALL RTENTRY                  % START DIMIR WATCH DOG
152271                   ELSE
152272                      ILDWD=:SECNO                  % "DIMIR WATCH DOG NOT RUNNING"
152274                      CLUPT; CALL CCLNO; A=:9FLP1   % CLUSTER NUMBER
152277                      DAQ.CLMNO=:9FLP2              % MEMBER NUMBER
152302                      X:=0; CALL 9FLEX(ERMSA,3)
152306                   FI
152306                FI
152306             FI
152306          FI
152306          GO HOME
152307   RBUS
152330
152330
152330   %====================================================================
152330   %              D M S R O    D M C R O
152330   %
152330   % DMSRO : START A READ/READ PARITY/COMPARE OPERATION ON A CLUSTER
152330   %
152330   %    ENTRY : B = OPERATION DATAFIELD
152330   %
152330   %    EXIT  :
152330   %
152330   %
152330   % DMCRO : CONTINUE A READ/READ PARITY/COMPARE OPERATION ON A CLUSTER
152330   %
152330   %    ENTRY : B = OPERATION DATAFIELD
152330   %            X = DAQ OF LAST SUBOPERATION FINISHED
152330   %
152330   %    EXIT  :
152330   %
152330   %    USES T,A,D,X
152330   %
152330   SUBR DMSRO, DMCRO
152330
152330   %
152330   % AUXILLARY RUTINE TO DETERMINE WITCH MEMBER TO READ FROM
152330
152330   DISP 0
152330       INTEGER HTAB0=HTABL
152330   PSID
152330
152330   INTEGER POINTER SAVL
152331   INTEGER SAVX, SMBNO, SECPT, PUND1, PUND2, TEMP
152337
152337   DMREA: A:=L=:"SAVL"; 0=:X=:SMBNO
152343          IF T:=DMRWM BIT 5DRM1 THEN
152346             1=:SAVX
152350             IF CLUPT.DMFLG BIT 8DRDE THEN
152354                X+DULEN
152355                IF T BIT 5DRM2 THEN
152357                   2=:SMBNO
152361                ELSE
152362                IF T BIT 5DRM3 THEN
152364                   X+DULEN
152365                   3=:SMBNO
152367                FI FI
152367                X=:SECPT
152370             FI
152370
152370             IF SMBNO><0 THEN
152372   %
152372   % WE NOW HAVE A CHOICE WHETHER TO READ FROM PRIMARY OR SECONDARY 1
152372                IF CLUPT.DMFLG BIT 8DRDB THEN
152376                   T:="DMRDB"+X; ABPA2; CALL CMP2
152402                   IF A<0 THEN SMBNO=:SAVX FI  % DISK ADDRESS BELOW BOUNDARY
152405                ELSE
152406   %
152406   % WE NOW HAVE A CHOICE WHETHER TO READ FROM PRIMARY OR SECONDARY 1
152406                   17/\SECPT.PRDEV+X.PRCDF=:TEMP
152413                   T:=A.PUND0=:PUND2           % SECONDARY UNIT DATAFIELD
152416                   X:=CLUPT.DMDFU.PUND0=:PUND1 % PRIMARY UNIT DATAFIELD
152422                   IF X.SUNOP > T.SUNOP THEN
152427                      SMBNO=:SAVX              % USE SECONDARY
152431                   FI
152431                FI
152431             FI
152431             X:=SAVX
152432          ELSE
152433          IF T BIT 5DRM2 THEN
152435             X:=2                              % USE SECONDARY-1
152436          ELSE
152437          IF T BIT 5DRM3 THEN
152441             X:=3                              % USE SECONDARY-2
152442          FI FI FI
152442          DMRMM(X)-,/\DMRWM=:DMRWM             % RESET ACCESSABLE BIT
152446          GO SAVL
152447   *)FILL
152452
152452
152452   INTEGER MB
152453   INTEGER POINTER HOME
152454
152454   DMSRO: A:=L=:"HOME"
152456          CALL FAR DMREA                       % GET MEMBER
152457   %
152457   % START OPERATION IF POSSIBLE
152457          IF X=:MB><0 THEN
152461             "1"; CALL FTSGQ                   % ASSURE THAT A BUFFER IS PRESENT
152463             MB; CALL DMEXE                    % START OPERATION
152465          ELSE
152466             NOTAVAIL=:HSTAT                   % NO MEMBER AVAILABLE
152470          FI
152470          GO HOME
152471
152471
152471   INTEGER DAQ
152472
152472   DMCRO: A:=L=:"HOME"; X=:DAQ
152475          IF X.SSSTAT BIT 4 THEN
152500             IF HSTAT=0 OR X.CLMNO=1 THEN
152506                X.SSSTAT=:HSTAT                % SET STATUS
152510                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152514             FI
152514             CALL FAR DMREA                    % TRY AGAIN
152515             IF X><0 THEN A:=X; CALL DMEXE FI
152520          ELSE
152521             A=:HSTAT                          % OK STATUS
152522          FI
152522          GO HOME
152523   RBUS
152526
152526
152526   %====================================================================
152526   %              D M S W O    D M C W O
152526   %
152526   % DMSWO : START A WRITE OPERATION ON A CLUSTER
152526   %
152526   %    ENTRY : B = OPERATION DATAFIELD
152526   %
152526   %    EXIT  :
152526   %
152526   %
152526   % DMCWO : CONTINUE A WRITE OPERATION
152526   %
152526   %    ENTRY : B = OPERATION DATAFIELD
152526   %            X = DAQ OF LAST SUBOPERATION
152526   %
152526   %    EXIT  :
152526   %
152526   %    USES T,A,D,X
152526   %
152526   SUBR DMSWO, DMCWO
152526   INTEGER POINTER HOME
152527
152527   DMSWO: A:=L=:"HOME"
152531   %
152531   % FIRST CHECK ALL MEMBERS AND DETERMINE NUMBER OF DAQ'S REQUIRED
152531          D:=0
152532          IF DMRWM BIT 5DWM1 THEN D+1 FI       % CHECK IF WRITE TO MEMBER 1
152536          IF A BIT 5DWM2 THEN D+1 FI           % CHECK IF WRITE TO MEMBER 2
152541          IF A BIT 5DWM3 THEN D+1 FI           % CHECK WRITE TO MEMBER 3
152544          IF D > 0 THEN
152546             A:=D; CALL FTSGQ                  % MAKE SURE ENOUGH BUFFERS ARE PRESENT
152550             IF DMRWM BIT 5DWM1 THEN "1"; CALL DMEXE FI
152555             IF DMRWM BIT 5DWM2 THEN "2"; CALL DMEXE FI
152562             IF DMRWM BIT 5DWM3 THEN "3"; CALL DMEXE FI
152567          ELSE
152570             NOTAVAIL=:HSTAT                   % NO MEMBER AVAILABLE
152572          FI
152572          GO HOME
152573
152573
152573   DMCWO: A:=L=:"HOME"
152575          IF X.SSSTAT BIT 4 THEN
152600             IF HSTAT=0 THEN
152602                X.SSSTAT=:HSTAT                % SET STATUS
152604                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152610             ELSE
152611             IF HSTAT BIT 4 AND X.CLMNO=1 THEN
152620                X.SSSTAT=:HSTAT                % SET STATUS
152622                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152626             FI FI
152626          ELSE
152627             A=:HSTAT
152630          FI
152630          1; CALL FTSRQ                        % RELEASE DAQ
152632          GO HOME
152633   RBUS
152636
152636   %====================================================================
152636   %              D M S C O    D M C C O
152636   %
152636   % DMSCO : START A CONCATENATED OPERATION
152636   %
152636   %    ENTRY : B = OPERATION DATAFIELD
152636   %
152636   %    EXIT  :
152636   %
152636   % DMCCO : CONTINUE A CONCATENATED OPERATION
152636   %
152636   %    ENTRY : B = OPERATION DATAFIELD
152636   %            X = DAQ OF LAST SUBOPERATION FINISHED
152636   %
152636   %    EXIT  :
152636   %
152636   %    USES T,A,D,X
152636   %
152636   SUBR DMSCO, DMCCO
152636   INTEGER POINTER HOME=?
152636   INTEGER FMASK=?
152636   INTEGER MB
152637
152637   DMSCO: A:=L=:"HOME"; X:=CLUPT
152642          A:=B=:X.DMCDP                        % INDICATE CONCATENATED OPERATION IN PROGRESS
152644          L:=0; A:="0" BONE 9DCRW; T:=DMFUN
152650          IF T BIT 7RWM1 THEN L+1; A/\X.PRFLG FI
152654          IF T BIT 7RWM2 THEN L+1; A/\X.S1FLG FI
152660          IF T BIT 7RWM3 THEN L+1; A/\X.S2FLG FI
152664          IF A=:D:=77/\T=64 THEN
152672             X.DMWFL                           % CONCATENATED READ MEMBER
152673             IF D NBIT 9DCRW THEN "0" FI       % NO WRITE MEMBER SPECIFIED
152676          ELSE
152677             DMFUN SHZ -14                     % COMPARE FROM MEMBER
152701          FI
152701          X:=3/\A                              % FROM MEMBER
152703          IF DMRMM(X)/\DMRWM><0 AND DMFUN/\FMASK><0 THEN
152711             X=:MB; A:=L; CALL FTSGQ           % RESERVE DAQ'S
152714             DMFUN/\140000+66=:ABFUN           % INDICATE READ, DON'T CLEAR CACHE
152720             MB; CALL DMEXE                    % START OPERATION
152722          ELSE
152723             NOTAVAIL=:HSTAT                   % MEMBER NOT AVAILABLE
152725          FI
152725          GO HOME
152726
152726
152726   INTEGER POINTER HOME
152727   INTEGER FMASK:=0; * *-1/1@7RWM1; *-1/1@7RWM2+^; *-1/1@7RWM3+^
152730
152730   DMCCO: A:=L=:"HOME"
152732          IF X.SSSTAT BIT 4 THEN
152735             IF HSTAT >< -1 THEN
152741                IF A NBIT 4 OR A/\7>X.CLMNO THEN
152747                   X.SSSTAT/\177770\/X.CLMNO=:HSTAT % SET MEMBER IN HSTAT
152753                FI
152753             FI
152753          FI
152753
152753          IF 77/\ABFUN=66 OR =60 THEN
152763             IF HSTAT NBIT 4 THEN
152766   %
152766   % SET NEW FUNCTION FOR ABSTR
152766                IF 77/\DMFUN=64 THEN
152773                   DMFUN/\140000+61=:ABFUN     % WRITE
152777                ELSE
153000                   DMFUN/\140000+63=:ABFUN     % COMPARE
153004                FI
153004   %
153004   % CHECK MEMBER 1
153004                IF DMFUN BIT 7RWM1 THEN
153007                   IF DMRWM BIT 5DWM1 THEN
153012                      DMFUN BZERO 7RWM1=:DMFUN % INDICATE STARTED
153015                      "1"; CALL DMEXE          % ON MEMBER 1
153017                   ELSE
153020                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153022                   FI
153022                FI
153022   %
153022   % CHECK MEMBER 2
153022                IF DMFUN BIT 7RWM2 THEN
153025                   IF DMRWM BIT 5DWM2 THEN
153030                      DMFUN BZERO 7RWM2=:DMFUN % INDICATE STARTED
153033                      "2"; CALL DMEXE          % ON MEMBER 2
153035                   ELSE
153036                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153040                   FI
153040                FI
153040   %
153040   % CHECK MEMBER 3
153040                IF DMFUN BIT 7RWM3 THEN
153043                   IF DMRWM BIT 5DWM3 THEN
153046                      DMFUN BZERO 7RWM3=:DMFUN % INDICATE STARTED
153051                      "3"; CALL DMEXE          % ON MEMBER 3
153053                   ELSE
153054                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153056                   FI
153056                FI
153056
153056                0=:CLUPT.DMCDP                 % ALLOW OTHER OPERATIONS
153060                "DMCWQ-DLINK"+X; CALL DMSWQ    % START WAIT QUEUE
153063             FI
153063          ELSE
153064             1; CALL FTSRQ                     % RELEASE DAQ
153066          FI
153066          GO HOME
153067   RBUS
153100
153100
153100   %====================================================================
153100   %              D M S S O    D M C S O
153100   %
153100   % DMSSO : START A SPECIAL OPERATION
153100   %
153100   %    ENTRY : B = OPERATION DATAFIELD
153100   %
153100   %    EXIT  :
153100   %
153100   % DMCSO : CONTINUE SPECIAL OPERATION
153100   %
153100   %    ENTRY : B = OPERATION DATAFIELD
153100   %            X = DAQ OF LAST SUBOPERATION FINISHED
153100   %
153100   %    EXIT  :
153100   %
153100   %    USES T,A,D,X
153100   %
153100   SUBR DMSSO, DMCSO
153100   INTEGER POINTER HOME
153101   INTEGER DMODU
153102
153102   DMSSO: A:=L=:"HOME"
153104          "1"; CALL FTSGQ                      % ENSURE ONE DAQ
153106          0=:DMLDU; GO FELLS
153110
153110   DMCSO: A:=L=:"HOME"
153112
153112   FELLS: IF -1><DMLDU THEN
153116             X:="DMFST"                        % POINTER TO SEARCH TABLE
153117             DO
153117                X.DS0; WHILE A<<=T; X+D        % SKIP PREVIOUS TREATED ELEMENTS
153123             OD
153124             DMFUN SHR -6/\7+DMCDF=:DMODU      % ORIGINAL DATAFIELD/UNIT
153131             DO
153131                X.DS0; WHILE A=:DMLDU<<-1
153136                IF A><DMODU THEN
153141                   D+X=:L; X+2
153144                   DO
153144                      "-DMCLT"+X.S0=:D:=0      % OFFSET WITHIN CLUSTER TABLE
153150                      T:="DMTL"; *RDIV ST      % OFFSET WITHIN CLUSTER ENTRY
153152                      IF D>=DULEN THEN
153155                         X.S0-D=:CLUPT         % CLUSTER POINTER
153160                         X:=:A:=X.DMDFU:=:A    % PRIMARY DATAFIELD/UNIT
153163                         IF A-DMODU=0 THEN
153165                            *RDIV ST           % CALCULATE MEMBER NUMBER
153166                            A+1; CALL DMEXE    % EXECUTE OPERATION
153170                            GO HOME
153171                         FI
153171                      FI
153171                      WHILE X+1><L
153174                   OD
153175                ELSE
153176                   X+D                         % THIS IS ORIGINAL, SKIP IT
153177                FI
153177             OD
153200             DMORO=:ABFUN; "0"; CALL DMEXE     % START ORIGINAL OPERATION
153204          ELSE
153205             0=:HSTAT                          % FINISHED, RETURN OK STATUS
153206          FI
153206          GO HOME
153207   RBUS
153214   *"
"153214   @DEV 1
153214   @EOF
153214
% MP-P2-DIGIO:MAC
153214  "
153214  )LINE

153214  %==============================================================================
153214  % IDENT CODE TABLES
153214
153214  %==============================================================================
153214  % 42.13      I T B 1 0
153214  %
153214  ITB10, DT01W
153215  "8PUN1
153215  ITB10+1/DPNCH
153216  "8LP1
153216  ITB10+2/DLPR
153217  "8DLP1+8DVE1;ITB10+2/DMLP1
153217  "8SMO1
153217  ITB10+3/UDMO1
153220  "8SMO2
153220  ITB10+13/UDMO2
153230  "8LP2
153230  ITB10+22/DLPR2
153237  "8DLP2+8DVE2
153237  ITB10+22/DMLP2
153237  "8TR5 -9SMO1
153237  ITB10+43/DT05W
153260  "8TR6
153260  ITB10+44/DT06W
153261  "8TR7
153261  ITB10+45/DT07W
153262  "8TR8
153262  ITB10+46/DT08W
153263  "8TR9 -9SMO2
153263  ITB10+47/DT09W
153264  "8TR10
153264  ITB10+50/DT10W
153265  "8TR11
153265  ITB10+51/DT11W
153266  "8TR12
153266  ITB10+52/DT12W
153267  "8TR13 -9SMO3
153267  ITB10+53/DT13W
153270  "8TR14
153270  ITB10+54/DT14W
153271  "8TR15
153271  ITB10+55/DT15W
153272  "8TR16
153272  ITB10+56/DT16W
153273  "8TR17 -9SMO4
153273  ITB10+57/DT17W
153274  "8TR18
153274  ITB10+60/DT18W
153275
153275  "8TR19
153275  ITB10+61/DT19W
153276  "8TR20
153276  ITB10+62/DT20W
153277  "8TR21 -9SMO5
153277  ITB10+63/DT21W
153300  "8TR22
153300  ITB10+64/DT22W
153301  "8TR23
153301  ITB10+65/DT23W
153302  "8TR24
153302  ITB10+66/DT24W
153303  "8TR25 -8SMO9
153303  ITB10+67/DT25W
153304  "8TR26
153304  ITB10+70/DT26W
153305  "8TR27
153305  ITB10+71/DT27W
153306  "8TR28
153306  ITB10+72/DT28W
153307  "8TR29 -9SMO6
153307  ITB10+73/DT29W
153310  "8TR30 -9SMO7
153310  ITB10+74/DT30W
153311  "8TR31
153311  ITB10+75/DT31W
153312  "8TR32
153312  ITB10+76/DT32W
153313  "
153313  ITB10+117/DT01W              % 120 - TERM. 1, FOR MULTITERM INTERF.
153334  "8TR33;ITB10+123/DT33W
153340  "8TR34;ITB10+124/DT34W
153341  "8TR35 -8SMO7;ITB10+125/DT35W
153342  "8TR36 -8SMO8;ITB10+126/DT36W
153343  "8TR37 -8SMO9;ITB10+127/DT37W
153344  "8TR38 -9SMO1;ITB10+130/DT38W
153345  "8TR39 -9SMO2;ITB10+131/DT39W
153346  "8TR40 -9SMO3;ITB10+132/DT40W
153347  "8TR41 -9SMO4;ITB10+133/DT41W
153350  "8TR42 -9SMO5;ITB10+134/DT42W
153351  "8TR43 -9SMO6;ITB10+135/DT43W
153352  "8TR44 -9SMO7;ITB10+136/DT44W
153353  "8TR45;ITB10+137/DT45W
153354  "8TR46;ITB10+140/DT46W
153355  "8TR47;ITB10+141/DT47W
153356  "8TR48;ITB10+142/DT48W
153357  "8TR49;ITB10+143/DT49W
153360  "8TR50;ITB10+144/DT50W
153361  "8TR51;ITB10+145/DT51W
153362  "8TR52;ITB10+146/DT52W
153363  "
153363  MAX10=*-ITB10
153363
153363
153363
153363  %==============================================================================
153363  % 42.15      I T B 1 2
153363  %
153363  ITB12, DT01R
153364  "8SMO1
153364  ITB12+3/IDMO1
153367  "8SMO2
153367  ITB12+13/IDMO2
153377  "8CP51
153377  ITB12+15/5CPU1
153401  "8CP53
153401  ITB12+35/5CPU3
153421  "8TR5 -9SMO1
153421  ITB12+43/DT05R
153427  "
153427  "8TR6
153427  ITB12+44/DT06R
153430  "8TR7
153430  ITB12+45/DT07R
153431  "8TR8
153431  ITB12+46/DT08R
153432  "8TR9 -9SMO2
153432  ITB12+47/DT09R
153433  "8TR10
153433  ITB12+50/DT10R
153434  "8TR11
153434  ITB12+51/DT11R
153435  "8TR12
153435  ITB12+52/DT12R
153436  "8TR13 -9SMO3
153436  ITB12+53/DT13R
153437  "8TR14
153437  ITB12+54/DT14R
153440  "8TR15
153440  ITB12+55/DT15R
153441  "8TR16
153441  ITB12+56/DT16R
153442  "8TR17 -9SMO4
153442  ITB12+57/DT17R
153443  "8TR18
153443  ITB12+60/DT18R
153444  "8TR19
153444  ITB12+61/DT19R
153445  "8TR20
153445  ITB12+62/DT20R
153446  "8TR21 -9SMO5
153446  ITB12+63/DT21R
153447  "8TR22
153447  ITB12+64/DT22R
153450  "8TR23
153450  ITB12+65/DT23R
153451  "8TR24
153451  ITB12+66/DT24R
153452  "8TR25 -8SMO9
153452  ITB12+67/DT25R
153453  "8TR26
153453  ITB12+70/DT26R
153454  "8TR27
153454  ITB12+71/DT27R
153455  "8TR28
153455  ITB12+72/DT28R
153456  "8TR29 -9SMO6
153456  ITB12+73/DT29R
153457  "8TR30 -9SMO7
153457  ITB12+74/DT30R
153460  "8TR31
153460  ITB12+75/DT31R
153461  "8TR32
153461  ITB12+76/DT32R
153462  "8CP54
153462  ITB12+113/5CPU4
153477  "8CP52
153477  ITB12+115/5CPU2
153501  "
153501  ITB12+117/DT01R
153503  "8TR33;ITB12+123/DT33R
153507  "8TR34;ITB12+124/DT34R
153510  "8TR35 -8SMO7;ITB12+125/DT35R
153511  "8TR36 -8SMO8;ITB12+126/DT36R
153512  "8TR37 -8SMO9;ITB12+127/DT37R
153513  "8TR38 -9SMO1;ITB12+130/DT38R
153514  "8TR39 -9SMO2;ITB12+131/DT39R
153515  "8TR40 -9SMO3;ITB12+132/DT40R
153516  "8TR41 -9SMO4;ITB12+133/DT41R
153517  "8TR42 -9SMO5;ITB12+134/DT42R
153520  "8TR43 -9SMO6;ITB12+135/DT43R
153521  "8TR44 -9SMO7;ITB12+136/DT44R
153522  "8TR45;ITB12+137/DT45R
153523  "8TR46;ITB12+140/DT46R
153524  "8TR47;ITB12+141/DT47R
153525  "8TR48;ITB12+142/DT48R
153526  "8TR49;ITB12+143/DT49R
153527  "8TR50;ITB12+144/DT50R
153530  "8TR51;ITB12+145/DT51R
153531  "8TR52;ITB12+146/DT52R
153532  "8C1HD;ITB12+147/HDOF1
153533  "8HMO1;ITB12+147/UDHM1
153533  "8C2HD;ITB12+150/HDOF2
153534  "8HMO2;ITB12+150/UDHM2
153534  "8C3HD;ITB12+151/HDOF3
153535  "8HMO3;ITB12+151/UDHM3
153535  "8C4HD;ITB12+152/HDOF4
153536  "8HMO4;ITB12+152/UDHM4
153536  "8C5HD;ITB12+153/HDOF5
153537  "8HMO5;ITB12+153/UDHM5
153537  "8C6HD;ITB12+154/HDOF6
153540  "8HMO6;ITB12+154/UDHM6
153540  "8HDM1;ITB12+155/HDMO1
153541  "
153541  MAX12=*-ITB12
153541
153541
153541  %==============================================================================
153541  % 42.16      I T E 1 0
153541  %
153541  ITE10=*
153541  "8NIU0;140444;MNDF0
153543  "8NIU1;140445;MNDF1
153545  "8NIU2;140446;MNDF2
153547  "
153547  *+XID10/
153561  -1;-1
153563  %==============================================================================
153563  % 42.18      I T E 1 2
153563  %
153563  ITE12=*
153563  "8CD01;*+2/
153565  "8CD02;*+2/
153567  "8PC01; 140002; PIO01
153571  "8PC02; 140003; PIO02
153573  "8PC03; 140004; PIO03
153575  "8PC04; 140005; PIO04
153577  "8ETR1; 140034; ETRN1
153601  "8ETR2; 140035; ETRN2
153603  "8ETR3; 140036; ETRN3
153605  "
153605  *+XID12/
153617  -1;-1
153621
153621  %==============================================================================
153621  % 42.19      I T E 1 3
153621  %
153621  ITE13=*;
153621  *+XID13/
153625  -1
153626  IT13E=*
153626  -1;-1
153630  %==============================================================================
153630  % 42.20      I T B 1 3
153630  %
153630  ITB13, CLCFI
153631  "8BEX1; ITB13+07/BEXDA
153640  "8BEX2; ITB13+10/BEXDA
153641  "8MPM4
153641         ITB13+17/ MPM4D
153650         ITB13+20/ MPM4D
153651         ITB13+21/ MPM4D
153652         ITB13+22/ MPM4D
153653         ITB13+23/ MPM4D
153654         ITB13+24/ MPM4D
153655         ITB13+25/ MPM4D
153656         ITB13+26/ MPM4D
153657         ITB13+27/ MPM4D
153660         ITB13+30/ MPM4D
153661         ITB13+31/ MPM4D
153662         ITB13+32/ MPM4D
153663         ITB13+33/ MPM4D
153664         ITB13+34/ MPM4D
153665         ITB13+35/ MPM4D
153666         ITB13+36/ MPM4D
153667  %%%%      ITB13+37/ MPM4D
153667         ITB13+37/IOCT0;OOCT0
153671  "8C1HD;ITB13+147/HDIF1
154000  "8HMO1;ITB13+147/IDHM1
154000  "8C2HD;ITB13+150/HDIF2
154001  "8HMO2;ITB13+150/IDHM2
154001  "8C3HD;ITB13+151/HDIF3
154002  "8HMO3;ITB13+151/IDHM3
154002  "8C4HD;ITB13+152/HDIF4
154003  "8HMO4;ITB13+152/IDHM4
154003  "8C5HD;ITB13+153/HDIF5
154004  "8HMO5;ITB13+153/IDHM5
154004  "8C6HD;ITB13+154/HDIF6
154005  "8HMO6;ITB13+154/IDHM6
154005  "8HDM1;ITB13+155/HDMI1
154006  "
154006
154006  MAX13=*-ITB13
154006
154006  %============================================================================
154006  %            I D 1 0 T
154006  %
154006  % IDENT CODE TABLE FOR TERMINAL 65-128 OUTPUT (LEVEL 10)
154006
154006  ID10T=*
154006  "8TR65;ID10T+00/DT65W
154007  "8TR66;ID10T+01/DT66W
154010  "8TR67;ID10T+02/DT67W
154011  "8TR68;ID10T+03/DT68W
154012  "8TR69;ID10T+04/DT69W
154013  "8TR70;ID10T+05/DT70W
154014  "8TR71;ID10T+06/DT71W
154015  "8TR72;ID10T+07/DT72W
154016  "8TR73;ID10T+10/DT73W
154017  "8TR74;ID10T+11/DT74W
154020  "8TR75;ID10T+12/DT75W
154021  "8TR76;ID10T+13/DT76W
154022  "8TR77;ID10T+14/DT77W
154023  "8TR78;ID10T+15/DT78W
154024  "8TR79;ID10T+16/DT79W
154025  "8TR80;ID10T+17/DT80W
154026  "8TR81;ID10T+20/DT81W
154027  "8TR82;ID10T+21/DT82W
154030  "8TR83;ID10T+22/DT83W
154031  "8TR84;ID10T+23/DT84W
154032  "8TR85;ID10T+24/DT85W
154033  "8TR86;ID10T+25/DT86W
154034  "8TR87;ID10T+26/DT87W
154035  "8TR88;ID10T+27/DT88W
154036  "8TR89;ID10T+30/DT89W
154037  "8TR90;ID10T+31/DT90W
154040  "8TR91;ID10T+32/DT91W
154041  "8TR92;ID10T+33/DT92W
154042  "8TR93;ID10T+34/DT93W
154043  "8TR94;ID10T+35/DT94W
154044  "8TR95;ID10T+36/DT95W
154045  "8TR96;ID10T+37/DT96W
154046  "8TR97;ID10T+40/DT97W
154047  "8TR98;ID10T+41/DT98W
154050  "8TR99;ID10T+42/DT99W
154051  "9TR00;ID10T+43/T100W
154052  "9TR01;ID10T+44/T101W
154053  "9TR02;ID10T+45/T102W
154054  "9TR03;ID10T+46/T103W
154055  "9TR04;ID10T+47/T104W
154056  "9TR05;ID10T+50/T105W
154057  "9TR06;ID10T+51/T106W
154060  "9TR07;ID10T+52/T107W
154061  "9TR08;ID10T+53/T108W
154062  "9TR09;ID10T+54/T109W
154063  "9TR10;ID10T+55/T110W
154064  "9TR11;ID10T+56/T111W
154065  "9TR12;ID10T+57/T112W
154066  "9TR13;ID10T+60/T113W
154067  "9TR14;ID10T+61/T114W
154070  "9TR15;ID10T+62/T115W
154071  "9TR16;ID10T+63/T116W
154072  "9TR17;ID10T+64/T117W
154073  "9TR18;ID10T+65/T118W
154074  "9TR19;ID10T+66/T119W
154075  "9TR20;ID10T+67/T120W
154076  "9TR21;ID10T+70/T121W
154077  "9TR22;ID10T+71/T122W
154100  "9TR23;ID10T+72/T123W
154101  "9TR24;ID10T+73/T124W
154102  "9TR25;ID10T+74/T125W
154103  "9TR26;ID10T+75/T126W
154104  "9TR27;ID10T+76/T127W
154105  "9TR28;ID10T+77/T128W
154106  "9TR29;  ID10T+200/T129W
154207  "9TR30;  ID10T+201/T130W
154210  "9TR31;  ID10T+202/T131W
154211  "9TR32;  ID10T+203/T132W
154212  "9TR33;  ID10T+204/T133W
154213  "9TR34;  ID10T+205/T134W
154214  "9TR35;  ID10T+206/T135W
154215  "9TR36;  ID10T+207/T136W
154216  "9TR37;  ID10T+210/T137W
154217  "9TR38;  ID10T+211/T138W
154220  "9TR39;  ID10T+212/T139W
154221  "9TR40;  ID10T+213/T140W
154222  "
154222  MXX10=*-ID10T
154222
154222  %============================================================================
154222  %            I D 1 2 T
154222  %
154222  % IDENT CODE TABLE FOR TERMINAL 65-128 INPUT (LEVEL 12)
154222
154222  ID12T=*
154222  "8TR65;ID12T+00/DT65R
154223  "8TR66;ID12T+01/DT66R
154224  "8TR67;ID12T+02/DT67R
154225  "8TR68;ID12T+03/DT68R
154226  "8TR69;ID12T+04/DT69R
154227  "8TR70;ID12T+05/DT70R
154230  "8TR71;ID12T+06/DT71R
154231  "8TR72;ID12T+07/DT72R
154232  "8TR73;ID12T+10/DT73R
154233  "8TR74;ID12T+11/DT74R
154234  "8TR75;ID12T+12/DT75R
154235  "8TR76;ID12T+13/DT76R
154236  "8TR77;ID12T+14/DT77R
154237  "8TR78;ID12T+15/DT78R
154240  "8TR79;ID12T+16/DT79R
154241  "8TR80;ID12T+17/DT80R
154242  "8TR81;ID12T+20/DT81R
154243  "8TR82;ID12T+21/DT82R
154244  "8TR83;ID12T+22/DT83R
154245  "8TR84;ID12T+23/DT84R
154246  "8TR85;ID12T+24/DT85R
154247  "8TR86;ID12T+25/DT86R
154250  "8TR87;ID12T+26/DT87R
154251  "8TR88;ID12T+27/DT88R
154252  "8TR89;ID12T+30/DT89R
154253  "8TR90;ID12T+31/DT90R
154254  "8TR91;ID12T+32/DT91R
154255  "8TR92;ID12T+33/DT92R
154256  "8TR93;ID12T+34/DT93R
154257  "8TR94;ID12T+35/DT94R
154260  "8TR95;ID12T+36/DT95R
154261  "8TR96;ID12T+37/DT96R
154262  "8TR97;ID12T+40/DT97R
154263  "8TR98;ID12T+41/DT98R
154264  "8TR99;ID12T+42/DT99R
154265  "9TR00;ID12T+43/T100R
154266  "9TR01;ID12T+44/T101R
154267  "9TR02;ID12T+45/T102R
154270  "9TR03;ID12T+46/T103R
154271  "9TR04;ID12T+47/T104R
154272  "9TR05;ID12T+50/T105R
154273  "9TR06;ID12T+51/T106R
154274  "9TR07;ID12T+52/T107R
154275  "9TR08;ID12T+53/T108R
154276  "9TR09;ID12T+54/T109R
154277  "9TR10;ID12T+55/T110R
154300  "9TR11;ID12T+56/T111R
154301  "9TR12;ID12T+57/T112R
154302  "9TR13;ID12T+60/T113R
154303  "9TR14;ID12T+61/T114R
154304  "9TR15;ID12T+62/T115R
154305  "9TR16;ID12T+63/T116R
154306  "9TR17;ID12T+64/T117R
154307  "9TR18;ID12T+65/T118R
154310  "9TR19;ID12T+66/T119R
154311  "9TR20;ID12T+67/T120R
154312  "9TR21;ID12T+70/T121R
154313  "9TR22;ID12T+71/T122R
154314  "9TR23;ID12T+72/T123R
154315  "9TR24;ID12T+73/T124R
154316  "9TR25;ID12T+74/T125R
154317  "9TR26;ID12T+75/T126R
154320  "9TR27;ID12T+76/T127R
154321  "9TR28;ID12T+77/T128R
154322  "9TR29;  ID12T+200/T129R
154423  "9TR30;  ID12T+201/T130R
154424  "9TR31;  ID12T+202/T131R
154425  "9TR32;  ID12T+203/T132R
154426  "9TR33;  ID12T+204/T133R
154427  "9TR34;  ID12T+205/T134R
154430  "9TR35;  ID12T+206/T135R
154431  "9TR36;  ID12T+207/T136R
154432  "9TR37;  ID12T+210/T137R
154433  "9TR38;  ID12T+211/T138R
154434  "9TR39;  ID12T+212/T139R
154435  "9TR40;  ID12T+213/T140R
154436  "
154436  MXX12=*-ID12T
154436
154436  )LINE
%
154436  % File : (SAMSON)KILL-MACROS:DUMY
154436
154436  )KILL CNVBYADR CNVWADR
154436  )LINE
032112   %$--:IPIT                     % FOR SPLITTING AV LISTING.
032112   *P2IPI/
032157   @DEV (S-S-L)IP-P2-SEGADM:NPL
032157   % TAB S8,4
032157   %

032157   %==============================================================================
032157   %==============================================================================
032157   %
032157   %   3 7 . 0      S E G M E N T    S U P E R V I S I N G
032157   %
032157   %           SSSSS    EEEEEEE    GGGGG     AAAAA    DDDDD     M     M
032157   %          S     S   E         G     G   A     A   D    D    MM   MM
032157   %          S         E         G         A     A   D     D   M M M M
032157   %          S         E         G         A     A   D     D   M  M  M
032157   %           SSSSS    EEEEEE    G  GGGG   AAAAAAA   D     D   M     M
032157   %                S   E         G     G   A     A   D     D   M     M
032157   %                S   E         G     G   A     A   D     D   M     M
032157   %          S     S   E         G     G   A     A   D    D    M     M
032157   %           SSSSS    EEEEEEE    GGGGG    A     A   DDDDD     M     M
032157   %
032157   %==============================================================================
032157   %==============================================================================
032157   %
032157   %      THIS PART OF SEGADM EXECUTES IN RING 3 AND IS RUN ON
032157   %      PROGRAM LEVEL SLEV. IT IS STARTED FROM MLEV BY SETTING THE
032157   %      SLEV P-REGISTER AND ENABLING THE LEVEL. RETURN TO MLEV
032157   %      AND CALLING RING 2 ROUTINES MUST BE DONE IN A SIMILAR WAY!
032157   %
032157   %==============================================================================
032157   %
032157   %
032157
032157   **-1@-12+1@12/
034000   *SRNG3=*           % START OF RING 3 CODE
034000   %=============================================================================
034000   %      G O M L E V                         C A L L M L E V
034000   %
034000   %      RETURN TO MONITOR LEVEL.            INTERFACE FOR CALLING ROUTINES
034000   %      A - ROUTINE ADDRESS.                ON MONITOR LEVEL.
034000   %                                          FOLLOWING CALL - ROUTINE ADDRESS.
034000   %                                          CALL CALLMLEV(ROUTINE)
034000   SUBR GOMLEV, CALLMLEV
034000   GOMLEV:
034000          *IRW MLEVB DP               % SET P-REGISTER ON MONITOR LEVEL.
034001          MLEV; *MST PIE; MST PID     % ENABLE AND START MONITOR LEVEL.
034004          *WAIT                       % STOP SEGADM LEVEL.
034005          CALL ERRFATAL
034006   INTEGER POINTER LREG
034007   CALLMLEV:
034007          A:=:L                       % GET RETURN ADDRESS, SAVE A IN L.
034010          *1BANK                      % ACCESS PROGRAM BANK
034011          A=:"LREG":=LREG             % SAVE RETURN ADDRESS AND GET DATA FOLLOWING CALL.
034013          *IRW MLEVB DP               % SET P-REGISTER ON MONITOR LEVEL.
034014          A:="LREG":=:L               % RESTORE L AND A.
034016          *2BANK
034017          *WAIT                       % GO DOWN TO MONITOR LEVEL.
034020          EXITA                       % SKIP RETURN OVER ADDRESS.
034021   RBUS
034022

034022   %=============================================================================
034022   % 37.1           S E G A D M
034022   %
034022   % SUBROUTINE TO CHECK IF SEGMENTS ARE OK, CALLED FROM STUPR
034022   % RETURN IF SEGMENTS OK, ELSE TO SEGIN
034022   % ENTRY:     MLEV.X = RTREF
034022
034022   SUBR SEGADM
034022   INTEGER POINTER LREG
034023   INTEGER BREG
034024
034024   SEGADM:*IRR MLEVB DX                   % GET NEW PROGRAM
034025          IF A=FIXCRT THEN                % IF IT IS THE PROGRAM DOING FIXC
034030              CALL XCSEGS; GO FAR OUT     % THEN CLEAR PAGE TABLES AND EXIT
034032          FI
034032          X:=A                            % X POINTS TO RT DESC OF NEW PROGRAM
034033          AD:=X.DACTSEG                   % A:=ACT1SEG, D:=ACT2SEG
034034          IF A           ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGB    % COMPUTE SEGMENT
034040          IF A:=D        ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGA    % TABLE ADDRESSES
034045          A:=X.RSEGM; IF ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGC    % AND SET UP NEW SEGMENTS (NSEG A,B,C)
034052          NSEGA=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI          % CHECK WHETHER THE SEGMENTS ARE OK
034057          NSEGB=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI          % OR IF THEY MUST BE FETCHED BY SEGIN.
034064          NSEGC=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI
034071
034071          GO SKIP1
034072          RTREF; CALL GETXSEG                                         % PERFORM SEGCHECK ON SPECIAL SEGMENTS
034074          A=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI              % IF IN USE BY THIS PROGRAM.
034100
034100   SKIP1:                         % ALL SEGMENTS ARE NOW OK.
034100          CALL XCSEGS             % CLEAR PAGETABLES (EXCEPT SPIT, FPIT, 5PIT AND FUPIT)
034101
034101          NSEGC=:B                % REENTRANT SEGMENT
034103          IF B >< 0 THEN          % IF PROGRAM HAS ONE THEN
034105              *LDASG LOGAD            % GET LOGICAL ADDRESS
034115              IF A SHZ -6=SPIT THEN            % SEGMENT IN SPIT?
034121                  IF S3SEG><B THEN             % SPIT SEGMENT CHANGED?
034124                      CALL CLSEG               % YES, CLEAR CURRENT SPIT SEGMENT
034125                      A:=B=:S3SEG; CALL STRSEG % SETUP NEW SPIT SEGMENT
034130                  FI
034130              ELSE                             % NOT IN SPIT:
034131                  NSEGC; CALL STRSEG           % SETUP REENTRANT SEGMENT
034133              FI
034133          FI
034133          NSEGC=:SEGMC            % NEW REENT. SEGMENT IS NOW CURRENT REENT. SEGMENT
034135          X:=RTREF
034136          CALL CLNREENT           % CLEAR NONREENTRANT PAGES WITHIN REENT SEGM.
034137
034137          0=:MBSYSEG              % USED FOR MARKING SYSTEM SEGMENT CURRENTLY USED OR NOT
034140          NSEGA=:B                % SEGMENT #2
034142          IF B >< 0 THEN          % IF PROGRAM HAS ONE
034144              *LDASG FLAG
034154              A=:MBSYSEG              % SAVE THE FLAG (FOR 5SYSEGM)
034155              *LDASG LOGAD            % GET LOGICAL ADDRESS
034165              IF A SHZ -6=SPIT THEN           % SEGMENT IN SPIT?
034171                  IF S3SEG><B THEN            % SPIT SEGMENT CHANGED?
034174                      CALL CLSEG              % YES, CLEAR CURRENT SPIT SEGMENT
034175                      A:=B=:S3SEG; CALL STSEG % SETUP NEW SPIT SEGMENT
034200                  FI
034200              ELSE                            % NOT IN SPIT:
034201                  NSEGA; CALL STSEG           % SETUP SEGMENT
034203              FI
034203          FI
034203          NSEGA=:SEGMA            % NEW SEGMENT A IS NOW CURRENT SEGMENT A
034205          GO L1; *)FILL
034233
034233   L1:    NSEGB=:B                % SEGMENT #1
034235          IF B >< 0 THEN          % IF PROGRAM HAS ONE
034237              *LDASG FLAG
034247              A\/MBSYSEG=:MBSYSEG     % "OR" FLAG WITH THE OTHER SEGMENTS' FLAG (FOR 5SYSEGM)
034251              *LDASG LOGAD            % GET LOGICAL ADDRESS
034261              IF A SHZ -6=SPIT THEN           % SEGMENT IN SPIT?
034265                  IF S3SEG><B THEN            % SPIT SEGMENT CHANGED?
034270                      CALL CLSEG              % YES, CLEAR CURRENT SPIT SEGMENT
034271                      A:=B=:S3SEG; CALL STSEG % SETUP NEW SPIT SEGMENT
034274                  FI
034274              ELSE                            % NOT IN SPIT:
034275                  NSEGB; CALL STSEG           % SETUP SEGMENT
034277              FI
034277          FI
034277          NSEGB=:SEGMB            % NEW SEGMENT B IS NOW CURRENT SEGMENT B
034301
034301          RTREF=:SEGPROG          % SET UP THE PROGRAM CURRENTLY USING SEGMENTS
034303          IF MBSYSEG NBIT 5SYSEG THEN % IF NEITHER SEGMENT A NOR B WAS A SYSTEM SEGMENT
034306              CALL SETRT              % THEN ENTER RT'S SYS.SEG
034307          FI
034307   *"8LAMU
"034307          CALL SLAMU              % SET UP LAMUS
034310   *"
"034310   OUT:   *WAIT   % RETURN DOWN TO MONITOR LEVEL
034311          CALL ERRFATAL
034312
034312   RBUS
034326

034326   SUBR XINSPG, XREMPG, YINSPG, YREMPG
034326   %
034326   %          ROUTINES TO EMULATE INSPG AND REMPG UNTIL THEY ARE MICROCODED
034326   %
034326   INTEGER FIRST, SEGMENT, XPAGENO, CME, SEGNO
034333   DOUBLE SAVAD=?
034333
034333   XINSPG:AD=:SAVAD
034334          A:=B=:SEGMENT
034336          T=:XPAGENO
034337          X=:D=:CME       % D:=CME
034341          T:=SEGTBANK
034342          X:=A            % X:=SEGMENT
034343          *BPAGL@3 LDATX  % A:=SEGMENT.BPAGLINK
034344          A=:FIRST
034345          A:=:D           % A:=CME; D:=FIRST
034346          *BPAGL@3 STATX  % A=:SEGMENT.BPAGLINK
034347          X:=A            % X:=CME
034350          A:=:D           % A:=FIRST; D:=CME
034351          T:=CORMBANK
034352          *PAGLI@3 STATX   % A=:CME.PAGLI
034353          IF A >< 0 THEN  % IF NONEMPTY PAGE LIST
034354              X:=A            % X:=FIRST
034355              *PREVI@3 LDATX  % A:=FIRST.PREVIOUS
034356              A=:SEGNO
034357              A:=:D           % A:=CME; D:=SEGNO
034360              *PREVI@3 STATX  % A=:FIRST.PREVIOUS
034361              X:=A            % X:=CME
034362              A:=D            % A:=SEGNO
034363          ELSE
034364              A:=B-SEGSTART=:D:=0
034370              T:=5SEGSIZE
034371              *RDIV ST
034372              A SH 2 + 3=:SEGNO
034375              T:=CORMBANK
034376          FI
034376          *PREVI@3 STATX  % SEGNO=:CME.PREVIOUS
034377          A:=XPAGENO
034400          *LOGPA@3 STATX  % A=:CME.LOGPAGE
034401          T:=A
034402          AD:=SAVAD
034403          EXIT
034404
034404   INTEGER CNEXT, CPREV
034406   TRIPLE SAVETAD
034411   DOUBLE SAVAD=SAVETAD
034411
034411   XREMPG:TAD=:SAVETAD
034412          X=:D
034413          T:=CORMBANK
034414          *PAGLI@3 LDATX   % A:=CME.PAGLI
034415          A=:CNEXT
034416          *PREVI@3 LDATX  % A:=CME.PREVIOUS
034417          A=:CPREV
034420          IF A NBIT 0 THEN% INSIDE PAGE LIST
034422              X:=A            % X:=CPREV
034423              A:=CNEXT
034424              *PAGLI@3 STATX   % A=:CPREV.PAGLI
034425          ELSE            % FIRST ELEMENT IN LIST
034426              A SHZ -2 SH 3 + SEGSTART=:X
034432              T:=SEGTBANK
034433              A:=CNEXT
034434              *BPAGL@3 STATX  % A=:SEGMENT.BPAGLINK
034435              T:=CORMBANK
034436          FI
034436          IF A >< 0 THEN  % IF NOT LAST ELEMENT IN LIST
034437              X:=A            % X:=CNEXT
034440              A:=CPREV
034441              *PREVI@3 STATX  % A=:CNEXT.PREVIOUS
034442          FI
034442          X:=D            % X:=CME
034443          *PAGLI@3 STZTX  % 0=:CME.PAGLI
034444          *PREVI@3 STZTX  % 0=:CME.PREVIOUS
034445          TAD:=SAVETAD
034446          EXIT
034447
034447   YINSPG:CALL XINSPG     % PROGRAMMED FROM MLEV OR ALEV
034450          *WAIT           % TO EXECUTE XINSPG
034451
034451   YREMPG:CALL XREMPG     % PROGRAMMED FROM MLEV OR ALEV
034452          *WAIT           % TO EXECUTE XREMPG
034453          CALL ERRFATAL
034454   RBUS
034462

034462   %==============================================================================
034462   %
034462   %           I N S E G L I N K   O U T S E G L I N K
034462   %
034462   %      INSERTION AND REMOVAL OF SEGMENTS TO/FROM THE SEGMENT LIST.
034462   %      (THE SEGMENT LIST IS A CIRCULAR DOUBLE LIST.)
034462   %      X POINTS TO SEGMENT
034462   SUBR INSEGLINK, OUTSEGLINK
034462
034462   INTEGER XRGGG,BRGGG
034464   TRIPLE TADRRG
034467   INSEGLINK:TAD=:TADRRG;X=:XRGGG;A:=B=:BRGGG  % SAVE REGISTERS
034473          T:=SEGTBANK
034474          A:=BSEGLINK=:B      % BSEGLINK
034476          *SEGLI@3 STATX      %         =:IN.SEGLINK
034477          X=:D:=A
034501          *PRESE@3 LDATX      % BSEGLINK.PRESEG
034502          X:=D
034503          *PRESE@3 STATX      %                =:IN.PRESEG
034504          X:=:A               % IN
034505          *SEGLI@3 STATX      %   =:BSEGLINK.PRESEG.SEGLINK
034506          X:=B
034507          *PRESE@3 STATX      % IN=:BSEGLINK.PRESEG
034510          A=:BSEGLINK         % IN=:BSEGLINK
034511          BRGGG=:B;X:=XRGGG;TAD:=TADRRG    % RESTORE REGISTERS
034515          EXIT
034516
034516   OUTSEGLINK:
034516          TAD=:TADRRG;X=:XRGGG;A:=B=:BRGGG  % SAVE REGISTERS
034522          X=:D
034523          T:=SEGTBANK
034524
034524                              % OUT.PRESEG=:OUT.SEGLINK.PRESEG
034524                              % OUT.SEGLINK=:OUT.PRESEG.SEGLINK
034524          *PRESE@3 LDATX      % A:=OUT.PRESEG
034525          *SEGLI@3 LDXTX      % X:=OUT.SEGLINK
034526          *PRESE@3 STATX      % A=:OUT.SEGLINK.PRESEG (OUT.PRESEG=:X.PRESEG)
034527          A:=:X
034530          *SEGLI@3 STATX      % A=:OUT.PRESEG.SEGLINK (OUT.SEGLINK=:X.SEGLINK)
034531          X:=D
034532          *SEGLI@3 STZTX      % 0=:OUT.SEGLINK
034533          *PRESE@3 STZTX      % 0=:OUT.PRESEG
034534          IF X=BSEGLINK THEN  % IF REMOVING THE FIRST SEGMENT THEN
034537              A=:BSEGLINK         % MAKE THE NEXT THE NEW FIRST
034540          FI
034540          BRGGG=:B;X:=XRGGG;TAD:=TADRRG    % RESTORE REGISTERS
034544          EXIT
034545   RBUS
034547
034547

034547   %==============================================================================
034547   % 37.2          P A G E F A U L T   P A G E 2 F A U L T   L I M C H E C K
034547   %
034547   %--MONITOR ENTRY FROM LEVEL 14 IF PAGE FAULT
034547   %  LOGICAL PAGE OF PAGE FAULT IS IN PNUMB
034547   %EXIT TO SEGIN
034547
034547   SUBR PAGEFAULT,PAGE2FAULT,LIMCHECK, SP01J
034547
034547   INTEGER DEMFLAG=?
034547   INTEGER SHAINSTR(0); *SHA
034550   INTEGER CINSTR(0); *BSKP ZRO DT
034551
034551   INTEGER SWLGF=?
034551
034551   PAGE2FAULT:                            % PAGEFAULT ON INBT/OUTBT LEVEL
034551   *"8SWLG
"034551               0=:SWLGF
034552   *"
"034552               CALL CALLMLEV(MLBLEVSET)   % SAVE STATUS FOR BLEV AND PREPARE FOR
034554                                          % RESTARTING IT AFTER PAGE FAULT HANDLING.
034554               GO PAGF
034555   PAGEFAULT:                             % PAGEFAULT ON APPLICATION LEVEL
034555   *"8SWLG
"034555               1=:SWLGF
034557   *"
"034557   PAGF:
034557          IF PNUMB>=WNDBF AND <=WND41 THEN % PNUMB IN WND41,WND12,WND10,WNDN5,WNDBF
034566              % PAGE FAULT IN WINDOWS SHOULD BE HANDLED ON LEVEL 14.
034566              CALL ERRFATAL
034567          FI
034567          A SH 1 \/ 174000=:X:=X.S0       % GET PAGE TABLE ENTRY FOR FAULTED PAGE
034573          IF A><0 THEN CALL ERRFATAL FI   % ENTRY WAS NOT 0
034575
034575          IF X:=SEGMC >< 0 THEN
034577              A:=0 BONE 5DEMAND=:DEMFLAG  % SET DEMAND.
034602              CALL LIMCHECK
034603          ELSE
034604              0=:DEMFLAG                  % SET NOT YET DEMAND.
034605              A:=-1
034606          FI
034606          IF A=0 THEN % PAGE FAULT POSSIBLY WITHIN REENTRANT SEGMENT
034607              B:=X                % FIND ENTRY IN BITMAP
034610              *LDASG LOGAD        % LOGICAL START ADDRESS(PIT) OF SEGMENT
034620              A/\1700=:D          % TO D REGISTER.
034622              A:=PNUMB/\1777-D    % A:=PNUMB-LOGAD
034625   SP01J:     GO SP01L
034626
034626                                          % BITMAP TEST FOR "NEW" CPU
034626              T:=0                        % BANK 0
034627              X:=RTREF.RTDLGADDR+5BITMAP  % BITMAP ADDRESS
034632              *LBITP                      % PHYSICAL LOAD BIT ( K:=TX(A) )
034633              IF K GO NOTREENT            % NOT IN REENTRANT SEGMENT
034635              X:=B   % SEGMC              % YES, IN REENTRANT SEGMENT
034636              GO SP01FI
034637                                          % BITMAP TEST FOR STANDARD CPU
034637   SP01L:     AD SHZ -4; D SHZ -14        % A:=WORD NO. IN BITMAP, D:=BIT NO. IN WORD
034641              X:=RTREF.RTDLGADDR+5BITMAP  % POINTER TO BITMAP
034644              X+A                         % POINTER BITMAP WORD OF THIS PAGE
034645              A:=SHAINSTR                 % "SHIFT" INSTRUCTION
034646              D+A                         % ADD "SHIFT" INSTR. TO SHIFT COUNT.
034647              A:=1; *EXR SD               % SET A ONE AT WANTED BIT POSITION IN WORD.
034651              T:=0                        % BANK 0
034652              *LDXTX                      % X:=BITMAP WORD
034653              IF A/\X><0 GO NOTREENT      % MASK OUT WANTED BIT AND TEST, IF SET NOT REENTRANT SEGMENT.
034655              X:=B  % SEGMC               % YES, IN REENTRANT SEGMENT.
034656
034656          ELSE                                    % PAGE FAULT IN SHADOW SEGMENT.
034657   NOTREENT:  X:=SEGMB; T:=SEGTBANK; *FLAG@3 LDATX
034662              A\/DEMFLAG=:DEMFLAG                 % INCLUDE 5DEMAND FOR SEGMENT B.
034664              X:=SEGMA; T:=SEGTBANK; *FLAG@3 LDATX
034667              A\/DEMFLAG=:DEMFLAG                 % INCLUDE 5DEMAND FOR SEGMENT A.
034671              CALL LIMCHECK                       % TEST FOR SEGMENT A.
034672              IF <0 THEN
034673                  X:=SEGMB
034674                  CALL LIMCHECK                   % IF NOT A, TEST FOR SEGMENT B.
034675                  IF <0 THEN CALL SINCHECK        % IF NOT B, TEST FOR SINTRAN.
034677                      IF <0 THEN                  % IF NOT SINTRAN, THEN
034700                          T:=PNUMB
034701                          IF DEMFLAG BIT 5DEMAND THEN "S14ERR"    % OUTSIDE SEGMENT BOUNDS.
034705                                                 ELSE "S13ERR";FI % PAGE FAULT FOR NON DEMAND.
034707                          CALL GOMLEV             % GO TO MONITOR LEVEL.
034710                      FI
034710                  ELSE
034711                      IF DEMFLAG NBIT 5DEMAND GO PFNDEM % PAGE FAULT FOR NON DEMAND.
034714                  FI
034714              ELSE
034715                  IF DEMFLAG NBIT 5DEMAND GO PFNDEM % PAGE FAULT FOR NON DEMAND.
034720          FI  FI
034720   SP01FI:                    % X POINTS TO PAGE FAULTED SEGMENT
034720          X=:B                % B POINTS TO PAGE FAULTED SEGMENT
034721          CALL SEGIN          % GET IN FAULTED PAGE FROM DISK.
034722
034722   PFNDEM:"S13ERR"; CALL GOMLEV   % PAGE FAULT FOR NON DEMAND.
034724
034724   INTEGER DEMFLAG
034725   *"8SWLG
"034725   INTEGER SWLGF
034726   *"
"034726   *)FILL
034751
034751   LIMCHECK:                              % CHECK WHETHER PNUMB IS WITHIN SEGMENT X OR NOT.
034751          IF X=0 THEN A:=-1 ; EXIT FI     % NO SEGMENT: NO.
034755          T:=SEGTBANK
034756          *LOGAD@3 LDDTX                  % A:=LOGADR, D:=SEGLENGTH
034757          IF A>PNUMB OR A+D<=T THEN       % IF OUTSIDE SEGMENT
034765                A:=-1                     % RETURN NO
034766          ELSE                            % INSIDE SEGMENT
034767   *"8SWLG
"034767                IF CSWLGF><0 THEN                             % SWAPPING-LOG?
034771                   IF T:=SWLGF=0 THEN                         % LEVEL 4
034774                      *MIN I (TPF42; SKP; MIN I (TPF41; JMP *+1
035000                      IF A=RTREF THEN                         % LOG FOR A SPESIFIC PROGRAM
035003                         *MIN I (CPF42; SKP; MIN I (CPF41; JMP *+1
035007                      FI
035007                   ELSE
035010                      *MIN I (TPF12; SKP; MIN I (TPF11; JMP *+1 % LEVEL 1
035014                      IF A=RTREF THEN                         % LOG FOR A SPESIFIC PROGRAM
035017                         *MIN I (CPF12; SKP; MIN I (CPF11; JMP *+1
035023                      FI
035023                   FI;
035023                FI
035023   *"
"035023              A:=0                        % RETURN WITH A=0 (YES)
035024          FI
035024          EXIT
035025
035025   SINCHECK:              % CHECK FOR PAGE FAULT IN SINTRAN SEGMENTS.
035025          L=:B
035026          X:=FILSEGM; CALL LIMCHECK   % IN FILE SYSTEM
035030          IF A=0 THEN B=:P FI
035032   *"8N500
"035032          X:=5NSEGM; CALL LIMCHECK    % IN ND500 SYSTEM MONITOR
035034          IF A=0 THEN B=:P FI
035036   *"8RFAC
"035036          X:=FUSEGM; CALL LIMCHECK    % IN REMOTE FILE ACCESS
035040          IF A=0 THEN B=:P FI
035042   *"
"035042          X:=SEGSTART; CALL LIMCHECK  % SEGMENT 0 IS RPIT.
035044          IF A=0 THEN CALL ERRFATAL FI% PF IN RESIDENT IS FATAL ERROR
035046          A:=-1                       % NOT IN SINTRAN.
035047          B=:P                        % RETURN
035050
035050   RBUS
035072

035072   %==============================================================================
035072   % 37.3       C L S E G   S T R S E G   S T S E G   X C L S E G   Y C L S E G
035072   %            C L P A G E   S T P A G E   S L A M U    C L A M U    C R S E G
035072   %            G E T W I P   1 C L A M
035072   %
035072   %  SUBROUTINES TO UPDATE THE HARDWARE PAGE TABLE
035072   % ENTRY:     A=SEGM. POINTER
035072
035072   @ICR;
035072   SUBR CLSEG, STRSEG, STSEG, CLPAGE, CLWINDOWS, 1CLAM,
035072        CLAMU, SLAMU, STPAGE, XCLSEG, GETWIP, CRSEG,
035072        SP02J, SP03J, SP04J, SP05J, SP10J, SP11J, SP13J, SP14J;
035072   @CR;
035072   *"8LAMU
"035072   DOUBLE ARRAY POINTER PTBG0:=174000     % PIT POINTERS
035073   INTEGER ARRAY POINTER IPTBG=PTBG0
035073   INTEGER POINTER LREG       % RETURN ADDRESS.
035074   INTEGER CL                 % CURRENT LAMU.
035075   INTEGER CACLE              % FIRST LAMU FOR THIS PROGRAM.
035076   INTEGER LAPRF:=0           % =0: PREVIOUS PROG HAS CLEARED LAMU PAGES
035077
035077   1CLAM: "1RCLA"=:"LREG"; K:=1; GO L1            % STARTED FROM MON LAMU
035103   SLAMU: K:="0"; GO LAMU                         % SET UP LAMU.
035105   CLAMU: IF LAPRF=0 THEN EXIT FI; K:=1           % CLEAR LAMU
035111   LAMU:  A:=L=:"LREG";
035113   L1:    IF SEGPROG = 0 GO LREG
035116          A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST   % RT PROGRAM NUMBER.
035123          A=:D+LAMIH=:X; T:=LAMBANK; *LDATX       % LAMU INHIBITED FOR THIS PROGRAM ?
035130          IF A >< 0 AND K NBIT GO LREG
035133          A:=D*GNLPRT*ALMSZ+LAMACT=:CACLE; 0=:CL
035141          FOR CL TO GNLPRT-1 DO
035146                A*ALMSZ+CACLE=:X; T:=LAMBANK; *LDDTX
035153                IF A >< 0 THEN                    % D=FIRST LOGICAL PAGE NO.
035154                   IF A > 0 THEN                  % USER LAMU OR SYSTEM-LAMU
035156                      A*LDTSZ+LAMDT               % ADDRESS IN LAMDT
035160                   ELSE
035161                      A- *SDTSZ+SYLDT             % ADDRESS IN SYLDT
035164                   FI
035164                   A=:X; *LDATX LMNP              % A:=NUMBER OF PAGES IN THIS LAMU.
035166                   L:=D+A-1+L                     % COMPUTE LAST PIT ENTRY FOR THIS LAMU.
035172                   *LDATX LMPP;  LDXTX LMPR       % A:=FIRST PHYS.PAGE OF THIS LAMU.
035174                   T:=X                           % T:=LAMU PROTECTION.
035175                   X:=D+X; D:=A; A:=T
035201                   IF K THEN
035203                      FOR X STEP 2 TO L DO 0=:IPTBG(X) OD        % CLEAR PIT FOR THIS LAMU.
035210                      0=:LAPRF                                   % MARK LAMU CLEARED
035211                   ELSE
035212                      FOR X STEP 2 TO L DO AD=:PTBG0(X); D+1 OD  % SET UP PIT FOR THIS LAMU.
035220                      1=:LAPRF                                   % MARK LAMU SET
035222                   FI
035222                FI
035222          OD
035226          GO LREG
035227   1RCLA: *WAIT
035230          CALL ERRFATAL
035231   *)FILL
035246   *"
"035246
035246   INTEGER PINDEX=?,BRG=?
035246
035246   INTEGER POINTER IWDN5:=WNDN5*2+174000  % POINTER TO N500 WINDOW
035247   INTEGER POINTER IWD41:=WND41*2+174000  % POINTER TO TERMINAL WINDOW
035250   INTEGER POINTER IWDBF:=WNDBF*2+174000  % POINTER TO DATA-BUFFER WINDOW
035251
035251   CLWINDOWS:
035251          0=:IWD41        % CLEAR TERMINAL WINDOW.
035252   *"8N500
"035252          0=:IWDN5        % CLEAR ND500 WINDOW.
035253   *"
"035253          EXIT
035254
035254   CLSEG:                         % CLEAR SEGMENT FROM PAGE INDEX TABLE
035254          IF A=0 THEN EXIT FI     % NO SEGMENT: NO CLEAR.
035256          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B.
035262          T:=SEGTBANK
035263          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035264          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO XOUT % THIS SEGMENT SHOULD NOT BE CLEARED OUT NOW.
035270          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035271   *XLX02, JMP * 2; 0             % FOR LOGGING FACILITY
035273
035273   SP02J: GO SP02L
035274
035274          A:=0                    % CLEAR REGULAR SEGMENT.
035275          *KCLEP                  % NEW CPU/RASK CPU
035276          GO OUT
035277
035277   SP02L: *XCLEP                  % OLD CPU
035313          GO OUT
035314
035314   CRSEG:                         % CLEAR REENTRANT SEGMENT FROM PIT.
035314   SP13J: GO CLSEG                % FOR STD AND CX CPU: USE CLSEG.
035315          IF A=0 THEN EXIT FI     % NO SEGMENT: NO CLEAR.
035317          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B.
035323          T:=SEGTBANK
035324          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035325          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO OUT % THIS SEGMENT SHOULD NOT BE CLEARED OUT NOW.
035331          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035332   *XLX03, JMP * 2; 0             % FOR LOGGING FACILITY
035334
035334   SP10J: GO SP10L
035335
035335          A:=-1                   % CLEAR REENTRANT SEGMENT.
035336          *KCLEP                  % RASK CPU
035337   XOUT:  GO OUT
035340
035340   SP10L: T:=CORMBANK             % PASS THROUGH PAGE LIST FOR THIS SEGMENT
035341          DO WHILE X >< 0         % TO THE END.
035342              *LOGPA@3 LDATX      % A:=LOGICAL PAGE NUMBER
035343              A SH 1\/174000=:B   % B:=PIT POINTER
035346              0=:PITPROTECT       % CLEAR PIT ENTRY.
035347              *PAGLI@3 LDXTX      % NEXT PAGE IN LIST.
035350          OD
035351          GO OUT
035352
035352
035352   STRSEG:                        % SET UP REENTRANT SEGMENT.
035352   SP14J: GO STSEG                % FOR STD AND CX CPU: USE STSEG.
035353          IF A=0 THEN EXIT FI     % NO SEGMENT: NO SETUP.
035355          X=:PINDEX:=B=:BRG:=A    % SAVE B AND X.
035361          T:=SEGTBANK
035362          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035363   *XLX04, JMP * 2; 0             % FOR LOGGING FACILITY
035365   SP03J: GO SP03L
035366
035366          *KSTRP                  % NEW CPU
035367          GO OUT
035370
035370   SP03L: *XSTRP                  % OLD CPU
035406          GO OUT
035407
035407   INTEGER PINDEX,BRG             % SAVED X AND B
035411   *)FILL
035416
035416   STSEG:                         % SET UP SEGMENT IN PAGE INDEX TABLE.
035416          IF A=0 THEN EXIT FI     % NO SEGMENT: NO SETUP.
035420          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B..
035424          T:=SEGTBANK
035425          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035426          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO OUT  % SEGMENT FIXED IN PIT.
035432          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035433   *XLX05, JMP * 2; 0             % FOR LOGGING FACILITY
035435   SP04J: GO SP04L
035436
035436          *KSETP                  % NEW CPU
035437          GO OUT
035440
035440   SP04L: *XSETP                  % OLD CPU
035455
035455                                  % EXIT POINT
035455   OUT:   X:=BRG=:B:=PINDEX       % RESTORE X AND B
035460          EXIT                    % RETURN
035461
035461   CLPAGE:                        % REMOVE PAGE FROM PIT. (X=CORE MAP ELEMENT)
035461          T:=B=:BRG:=CORMBANK     % SAVE B
035464          *LOGPA@3 LDATX          % A:=X.LOGPAGE
035465          A SH 1 \/ 174000=:B     % MAKE PIT POINTER IN B.
035470          0=:S0                   % CLEAR PIT ENTRY.
035471          BRG=:B                  % RESTORE B.
035473          EXIT                    % RETURN
035474
035474   INTEGER DDDRG                          % SAVED D
035475                                          % ENTER PAGE INTO PIT. (X=CORE MAP ELEMENT)
035475   STPAGE:IF X=0 THEN EXIT FI             % NO PAGE: NO ENTER.
035500          T:=B=:BRG:=D=:DDDRG:=CORMBANK   % SAVE B AND D
035505          *LOGPA@3 LDATX                  % A:=X.LOGPAGE
035506          A SH 1 \/ 174000=:B             % MAKE PIT POINTER IN B.
035511          *PROTE@3 LDATX                  % GET PROTECT ENTRY FROM CORE MAP.
035512          D:=X SHZ -2                     % COMPUTE PAGE NUMBER.
035514          AD=:PITENTRY                    % STORE PIT ENTRY.
035515          T:=DDDRG=:D:=BRG=:B             % RESTORE D AND B.
035521          EXIT                            % RETURN
035522
035522                                          % CLEAR SEGMENT FROM PIT REGARDLESS OF SEGSTATUS
035522   XCLSEG:IF A=0 THEN EXIT FI             % NO SEGMENT: NO CLEAR.
035524          X=:PINDEX:=B=:BRG:=A            % SAVE X AND B.
035530          T:=SEGTBANK; *BPAGL@3 LDXTX     % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035532   SP05J: GO SP05L
035533          A:=0
035534          *KCLEP                          % NEW CPU
035535          GO OUT
035536   SP05L: *XCLEP                          % OLD CPU
035552          GO OUT
035553   *)FILL
035556   GETWIP:                                % MOVE WIP BITS FOR 5NCLSEG SEGMENTS TO CORE MAP.
035556                                          % CALLED WITH SEGMENT POINTER IN B.
035556          X=:PINDEX:=B=:BRG               % SAVE X AND B, X:=SEGMENT.
035561          T:=SEGTBANK;*BPAGL@3 LDXTX      % X:=SEGMENT.BPAGLINK
035563   SP11J: GO SP11L
035564
035564          A:=1                            % COPY WIP AND PGU FOR REENTRANT SEGMENTS.
035565          *KCLEP                          % RASK CPU
035566          GO FAR OUT
035567
035567   SP11L: T:=CORMBANK                     % PASS THROUGH THE PAGE LIST FOR THIS SEGMENT
035570          DO WHILE X><0                   % TO THE END.
035571              *LOGPA@3 LDATX              % A:=LOGICAL PAGE NO.
035572              A SH 1 \/ 174000=:B         % B:=PIT POINTER.
035575              A:=PITPROTECT               % GET PROTECT PART OF PIT ENTRY FOR THIS PAGE.
035576              *PROTE@3 STATX              % A=:PROTECT.
035577              *PAGLI@3 LDXTX              % NEXT ENTRY IN PAGE LIST.
035600          OD
035601          GO FAR OUT
035602   RBUS
035606

035606   %=======================================================================
035606   %  37.5           S E T R T    C L E R T
035606   %
035606   %  ROUTINES FOR SETTING/CLEARING RT'S SYSTEM SEGMENT PIT ENTRIES
035606
035606   SUBR CLERT,SETRT
035606
035606   INTEGER XREG
035607   INTEGER ARRAY POINTER CPITADDR:=DPIT*200+174000+SYSST+5ESSZ+SYSST+5ESSZ
035610   DOUBLE  ARRAY POINTER DCPITADDR=CPITADDR
035610   INTEGER ENDLOOP
035611
035611   CLERT: X=:XREG                     % SAVE X
035612          SISYSEG-"5ESSZ"-1 SH 1=:ENDLOOP
035617          FOR X:=0 STEP 2 TO ENDLOOP DO 0=:CPITADDR(X) OD % CLEAR PIT.
035626          T:=CCFPAGE SH 1             % FIRST RT-COMMON PAGE.
035630          A:="UPITN*200+174000"=:X    % POINTER TO USERS NORMAL PAGE INDEX TABLE.
035632          X+T                         % POINTER TO FIRST RT-COMMON PAGE IN PIT.
035633          A+200=:T                    % LAST RT-COMMON PAGE IN PIT.
035635          DO WHILE X<<T               % REMOVE RT-COMMON FROM PIT.
035637              0=:X.S0                 % CLEAR PIT ENTRY
035640              X+2                     % NEXT RT-COMMON PAGE.
035641          OD
035642          GO OUT
035643
035643   SETRT: X=:XREG                     % SAVE X
035644          SISYSEG-"5ESSZ"-1 SH 1=:ENDLOOP
035651          A:=RTSYSG=:D:=162000        % RTSYSG: RT SYSTEM SEGMENT FIRST PAGE.
035654          FOR X:=0 STEP 2 TO ENDLOOP DO   % SET UP PIT FOR RT SYSTEM SEGMENT.
035660              AD=:DCPITADDR(X)        % STORE PIT ENTRY.
035661              D+1                     % NEXT PHYSICAL PAGE.
035662          OD
035664   OUT:   X:=XREG                     % RESTORE X
035665          EXIT                        % RETURN
035666   RBUS
035675
035675

035675   %==============================================================================
035675   % 37.6         S E G C H E C K
035675   %
035675   % SUBROUTINE TO CHECK IF A SEGMENT IS OK
035675   % B=ADDR. IN SEGMENT TABLE; RETURN: A=0 IF OK,ELSE -1
035675   % IF OK THE SEGMENT IS PLACED IN START OF SEGMENT LIST
035675
035675   SUBR SEGCHECK
035675   INTEGER XREG
035676   INTEGER POINTER LREG
035677   SEGCHECK:
035677          IF A:=B=0 THEN EXIT FI              % NO SEGMENT IS OK TOO.
035702          A:=L=:"LREG"                        % SAVE RETURN ADDRESS
035704          *LDASG SGSTA                        % A:=B.SGSTATUS
035714          IF A BIT 5SPTFIXED THEN             % IF SEGMENT IS FIXED IN PIT
035716              A:=0                            % OK
035717              GO LREG                         % RETURN
035720          FI
035720          A=:D                                % D:=SGSTATUS
035721          *LDASG FLAG                         % A:=B.FLAG
035731          IF A BIT 5INHB OR D=0 THEN          % SEGMENT NOT LOADED
035735              A:=B-SEGSTART SHZ -3=:T         % SEGMENT NUMBER IN T
035741              "S16ERR"; CALL GOMLEV
035743          FI
035743          IF A BIT 5OK THEN
035745              *LDASG SEGLI                    % A:=B.SEGLINK
035755              IF A><0 AND B><BSEGLINK THEN    % IF SEGMENT HAS PAGES IN MEMORY AND IS NOT THE FIRST.
035761                  X:=:B
035762                  CALL OUTSEGLINK             % REMOVE SEGMENT.
035763                  CALL INSEGLINK              % INSERT SEGMENT FIRST IN LIST.
035764                  X:=:B
035765              FI
035765              A:=0                            % RETURN OK.
035766          ELSE
035767              A:=-1                           % SEGMENT NOT OK
035770          FI
035770          GO LREG                             % RETURN
035771   RBUS
036000

036000   %==============================================================================
036000   % 37.7       C L N R E E N T R
036000   %
036000   % SUBROUTINE TO RESET NONREENTRANT PAGES IN PAGE INDEX TABLE
036000   % A=SEGMENT ADDRESS,X=RT-DESCR
036000   SUBR CLNREENTR, SP06J
036000
036000   INTEGER ARRAY POINTER PTBLE,RTDSCR
036002   INTEGER SVX
036003
036003   CLNREENTR:
036003          IF A=0 GO OUT           % NO SEGMENT: NO CLNREENTR.
036004   SP06J: GO SP06L
036005                                  % NEW CPU
036005          X=:D                    % SAVE X IN D
036006          X:=X.RTDLGADDR+5BITMAP  % X POINTS TO BITMAP
036010          T:=0                    % BANK 0
036011          *CNREK                  % CLEAR NONREENTRANT PAGES ACCORDING TO BITMAP.
036012          X:=D                    % RESTORE X
036013          EXIT                    % RETURN
036014
036014   SP06L: X=:SVX:=X.RTDLGADDR             % SAVE X
036016          X=:"RTDSCR"                     % X POINTS TO REGISTER BLOCK AND BITMAP.
036017          B=:T:=A                         % SAVE B IN T AND SET TO SEGMENT
036021          *LDASG LOGAD                    % A:=B.LOGADR
036031          A/\1700 SH 1+174000=:"PTBLE"    % MAKE PIT POINTER FOR THIS SEGMENT.
036035          5BITMAP=:D; B:=T                % DISPLACEMENT OF BITMAP INTO D, RESTORE B.
036040          FOR D TO "5BITMAP+7" DO         % TEST ALL BITMAP WORDS.
036043             "PTBLE"+40=:"PTBLE"          % POINTER TO END OF PIT FOR THIS WORD
036046             T:=0; X:="RTDSCR"+D; *LDATX  % GET BITMAP WORD
036052             IF A><0 THEN                 % IF ANY BIT SET IN THIS WORD THEN
036053                FOR X:=-20 DO             % TEST ALL BITS IN THIS WORD
036054                   A SHR -1               % MOVE BIT TO THE SIGN POSITION
036055                   IF A<0 THEN            % IF THIS BIT IS SET THEN
036056                       X=:T+X             % SAVE X IN T AND DOUBLE
036060                       0=:PTBLE(X)        % CLEAR PIT FOR THIS PAGE
036061                       X:=T               % RESTORE X
036062                   FI                     % ENDIF BIT
036062                OD                        % ENDDO BITS
036063             FI                           % ENDIF WORD
036063          OD                              % ENDDO WORDS
036065          X:=SVX                          % RESTORE X
036066   OUT:   EXIT                            % RETURN
036067   RBUS
036072

036072   %==============================================================================
036072   % 37.8         C S E G S   X C S E G S
036072   %
036072   % SUBROUTINES TO CLEAR SEGMENTS
036072   % CSEGS CLEARS IF SEGMENT IS PRESENT (A=SEGMENT POINTER), ALSO SPIT SEGMENTS
036072   % XCSEGS CLEARS ALWAYS, BUT NEVER SPIT SEGMENTS
036072
036072   SUBR CSEGS, XCSEGS, SP12J
036072   *"8N500
"036072   INTEGER POINTER IWDN5:=WNDN5*2+174000  % POINTER TO N500 WINDOW
036073   *"
"036073   INTEGER POINTER IWD41:=WND41*2+174000  % POINTER TO TERMINAL WINDOW
036074   INTEGER POINTER IWDBF:=WNDBF*2+174000  % POINTER TO DATA-BUFFER WINDOW
036075   INTEGER XREG
036076   INTEGER POINTER LREG
036077
036077   XCSEGS:X=:XREG:=L=:"LREG"  % SAVE X AND RETURN ADDRESS.
036102          0=:IWD41            % CLEAR TERMINAL WINDOW
036103          0=:IWDBF
036104   *"8N500
"036104          0=:IWDN5            % CLEAR ND500 WINDOW
036105   *"8LAMU
"036105          CALL CLAMU          % CLEAR LAMUS
036106   *"
"036106          X:=SEGMA            % SEGMENT A
036107          IF X >< 0 THEN      % IF PRESENT
036110              X:=:B
036111              *LDASG LOGAD    % A:=SEGMA.LOGADR
036121              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036125                  B=:A
036126                  CALL CLSEG
036127              FI
036127              X:=:B
036130          FI
036130          X:=SEGMB            % SEGMENT B
036131          IF X >< 0 THEN      % IF PRESENT
036132              X:=:B
036133              *LDASG LOGAD    % A:=SEGMA.LOGADR
036143              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036147                  B=:A
036150                  CALL CLSEG
036151              FI
036151              X:=:B
036152          FI
036152          X:=SEGMC            % SEGMENT C (REENTRANT SEGMENT)
036153          IF X >< 0 THEN      % IF PRESENT
036154              X:=:B
036155              *LDASG LOGAD    % A:=SEGMA.LOGADR
036165              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036171                  B=:A
036172                  CALL CRSEG
036173              FI
036173              X:=:B
036174          FI
036174                                  % EXIT POINT
036174   OUT:   CALL CLERT              % CLEAR PIT ENTRIES FOR RT'S SYSTEM SEGMENT.
036175
036175   SP12J: CALL CHREENTPAGES       % ONLY FOR STD AND CX CPU.
036176          0=:SEGMA=:SEGMB=:SEGMC  % CLEAR CURRENT SEGMENT POINTERS.
036201          X:=XREG                 % RESTORE X
036202          GO LREG                 % RETURN
036203   *)FILL
036214
036214   CSEGS: IF A><SEGMA AND ><SEGMB AND ><SEGMC THEN    % IF A IS NONE OF THE CURRENT SEGMENTS.
036225              IF A><S3SEG THEN        % AND NOT CURRENT SPIT SEGMENT
036230                  EXIT                % THEN RETURN
036231              ELSE
036232                  0=:S3SEG            % CLEAR SPIT SEGMENT
036233                  T:=L=:"LREG"        % SAVE RETURN ADDRESS
036235                  CALL CLSEG          % CLEAR SPIT
036236                  GO LREG             % RETURN
036237          FI  FI
036237                                      % A IS ONE OF THE ACTIVE SEGMENTS.
036237          X=:XREG:=L=:"LREG"          % SAVE X AND RETURN ADDRESS.
036242          0=:IWD41                    % CLEAR TERMINAL WINDOW
036243          0=:IWDBF
036244   *"8N500
"036244          0=:IWDN5                    % CLEAR ND500 WINDOW
036245   *"8LAMU
"036245          CALL CLAMU                  % CLEAR LAMUS
036246   *"
"036246          X:=SEGMA                    % SEGMENT A
036247          IF X >< 0 THEN              % IF PRESENT
036250              X:=:B
036251              *LDASG LOGAD            % A:=SEGMA.LOGADR
036261              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036265                  0=:S3SEG
036266              FI
036266              B=:A; CALL CLSEG; X:=:B % CLEAR SEGMENT
036271          FI
036271          X:=SEGMB                    % SEGMENT B
036272          IF X >< 0 THEN              % IF PRESENT
036273              X:=:B
036274              *LDASG LOGAD            % A:=SEGMA.LOGADR
036304              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036310                  0=:S3SEG; FI
036311              B=:A; CALL CLSEG; X:=:B % CLEAR SEGMENT
036314          FI
036314          X:=SEGMC                    % SEGMENT C (REENTRANT SEGMENT)
036315          IF X >< 0 THEN              % IF PRESENT
036316              X:=:B
036317              *LDASG LOGAD            % A:=SEGMA.LOGADR
036327              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036333                  0=:S3SEG; FI
036334              B=:A; CALL CRSEG; X:=:B % CLEAR SEGMENT
036337          FI
036337          GO OUT                      % GO TO EXIT POINT
036340
036340   RBUS
036350

036350   %=======================================================================
036350   %
036350   %   C H R E E N T P A G E S     CHECK FOR MODIFIED REENTRANT PAGES.
036350   %
036350   SUBR CHREENTPAGES, VSEVSX
036350
036350   INTEGER CSEG, BREG, ERINDICATOR, NXP
036354   INTEGER POINTER LREG
036355
036355   CHREENTPAGES:
036355           IF SEGMC=0 THEN EXIT FI                 % ONLY IF PROGRAM HAS REENTRANT SEGMENT.
036360           A=:CSEG=:X                              % X = REENTRANT SEGMENT
036362           T:=SEGTBANK; *SGSTA@3 LDATX             % A:=X.FLAG
036364           IF A NBIT 5WPM THEN EXIT FI             % IF NOT WRITE PERMIT THEN RETURN
036367           A:=L=:"LREG"; A:=B=:BREG                % SAVE L AND B
036373           0=:ERINDICATOR                          % NO ERRORS YET
036374           *BPAGL@3 LDXTX                          % X := BPAGLINK
036375           T:=CORMBANK
036376           DO WHILE X >< 0                         % DO UNTIL END OF PAGE LIST.
036377               *PROTE@3 LDATX                      % A:=X.PROTECT
036400               IF A BIT 5WIP THEN                  % PAGE IS MODIFIED.
036402                   *PAGLI@3 LDATX                  % GET POINTER TO NEXT PAGE
036403                   A=:NXP                          % AND SAVE IT.
036404                   *REMPG                          % REMOVE PAGE FROM REENTRANT SEGMENT.
036405                   CALL SHADLINK; A=:ERINDICATOR   % LINK PAGE TO SHADOW SEGMENT (SAVE PSBL. ERROR)
036407                   X:=NXP                          % RESTORE POINTER TO NEXT PAGE.
036410                   T:=CORMBANK                     % RESTORE T
036411               ELSE
036412                   *PAGLI@3 LDXTX                  % GET POINTER TO NEXT PAGE.
036413               FI
036413           OD
036414           BREG=:B
036416           T:=SEGTBANK; X:=CSEG; *PAGLI@3 LDATX    % A:=CSEG.PAGLINK
036421           IF A><0 THEN                            % IF SEGMENT IS IN SEGMENT LIST THEN
036422               *BPAGL@3 LDATX                          % IF REENTRANT SEGMENT BECAME EMPTY
036423               IF A=0 THEN CALL OUTSEGLINK FI          % THEN REMOVE IT FROM SEGMENT LIST.
036425           FI
036425           IF T:=ERINDICATOR >< 0 THEN             % IF NO SHADOW SEGMENT UNDER MODIFIED PAGE
036430               "S14ERR"; CALL GOMLEV               % THEN REPORT ERROR. (OUTSIDE SEGMENT BOUNDS)
036432           FI
036432           GO LREG
036433   RBUS
036443

036443   %=======================================================================
036443   %
036443   %   S H A D L I N K         LINK PAGE TO SHADOW SEGMENT.
036443   %
036443   %
036443   SUBR SHADLINK
036443
036443   INTEGER POINTER LREG
036444   INTEGER CME,ERPAGE,SHAINSTR(0); *SHA
036447
036447   SHADLINK:
036447           A:=L=:"LREG"
036451           X=:CME
036452           SEGMA; CALL INSRPAGE        % TRY TO LINK TO SEGMA.
036454           IF A=0 THEN                 % IF FAILED THEN
036455               SEGMB; CALL INSRPAGE    % TRY TO LINK TO SEGMB.
036457               IF A=0 THEN             % IF FAILED THEN
036460                   T:=CORMBANK         % LINK TO DUMMY SEGMENT AND REPORT ERROR.
036461                   *LOGPA@3 LDATX      % GET PAGE NUMBER.
036462                   A=:ERPAGE           % SAVE ERROR.
036463                   XSGRT=:B            % DUMMY SEGMENT.
036465                   *INSPG              % INSERT IN PAGE LIST.
036466                   *LDASG SGSTA        % COPY PROTECT ENTRY TO RESET WIP BIT
036476                   *PROTE@3 STATX
036477                   X:=B; T:=SEGTBANK
036501                   *SEGLI@3 LDATX      % GET SEGLINK OF DUMMY SEGMENT.
036502                   IF A=0 THEN         % IF DUMMY SEGMENT NOT IN SEGMENT LIST.
036503                       CALL INSEGLINK  % INSERT IN SEGMENT LIST
036504                       *SEGLI@3 LDATX  % AND MOVE TO END OF LIST.
036505                       A=:BSEGLINK
036506                   FI
036506                   A:=ERPAGE
036507                   GO LREG             % ERROR RETURN WITH PAGE IN A-REG.
036510           FI  FI
036510                                       % UPDATE BITMAP.
036510           T:=SEGTBANK; X:=SEGMC       % REENTRANT SEGMENTS
036512           *LOGAD@3 LDATX              % A:=LOGADR.
036513           A/\1700=:D                  % D:=BITMAPS LOGICAL START.
036515           T:=CORMBANK; X:=CME         % CORE MAP ENTRYS
036517           *LOGPA@3 LDATX              % A:=LOGPAGE.
036520           A-D; AD SHZ -4; D SHZ -14   % A:=WORD NO. IN BITMAP; D:=BIT NO. IN WORD.
036523           X:=SEGPROG.RTDLGADDR+5BITMAP+A  % X POINTS TO BITMAP WORD.
036527           A:=SHAINSTR                 % "SHIFT" INSTRUCTION.
036530           D+A                         % ADD "SHIFT" INSTRUCTION TO SHIFT COUNT.
036531           A:=1; *EXR SD               % SET A "1" AT WANTED POSITION IN WORD.
036533           A=:D; T:=0; *LDATX          % GET BITMAP WORD.
036536           A\/D; *STATX                % MASK IN THE NEW PAGE AND STORE.
036540           MIN "LREG"                  % OK: SKIP RETURN.
036541           GO LREG
036542   RBUS
036556

036556   %====================================================================
036556   %
036556   %   I N S R P A G E         INSERT PAGE IN SHADOW SEGMENT IF WITHIN IT.
036556   %                           A=SEGMENT,  X:=CORE MAP POINTER
036556   %
036556   %                           RETURN: A=0  :  NOT WITHIN THIS SEGMENT.
036556   %                                   A><0 :  OK, PAGE IS LINKED.
036556   SUBR INSRPAGE
036556
036556   INTEGER CME, SHSEG
036560   INTEGER POINTER LREG
036561
036561   INSRPAGE:
036561           IF A=0 THEN EXIT FI                 % NO SEGMENT: ON INSERT
036563           T:=SEGTBANK
036564           X=:CME:=A; *FLAG@3 LDATX            % A:=SEGMENT.FLAG
036567           IF A NBIT 5DEMAND THEN              % NON-DEMAND SEGMENT:
036571               X:=CME; A:=0; EXIT              %   CANNOT OVERLAP.
036574           FI
036574           A:=L=:"LREG"
036576           X=:SHSEG                            % SAVE SHADOW SEGMENT
036577           *LOGAD@3 LDDTX                      % A:=LOGADR; D:=SEGLENGTH
036600           X:=CME; T:=CORMBANK
036602           *LOGPA@3 LDXTX                      % X:=CME.LOGICAL PAGE
036603           IF X>=A AND X<D+A THEN              % IF WITHIN SEGMENT THEN
036610               T:=X                            % T:=LOGICAL PAGE
036611               SHSEG=:B                        % B:=SEGMENT POINTER
036613               X:=CME                          % X:=CORE MAP POINTER
036614               *INSPG                          % INSERT PAGE INTO SEGMENT.
036615               X:=:B; T:=SEGTBANK              % B:=COREMAP; X:=SEGMENT
036617               *SGSTA@3 LDATX                  % A:=SHSEG.SGSTATUS
036620               A/\777=:D                       % MASK "STATUS"-BITS
036622               X:=:B                           % X:=COREMAP; B:=SEGMENT
036623               T:=CORMBANK;  *PROTE@3 LDATX    %       INTO
036625               A/\177000\/D; *PROTE@3 STATX    %       COREMAP.PROTECT.
036630               X:=B; T:=SEGTBANK               % X:=SEGMENT
036632               *SEGLI@3 LDATX                  % A:=SEGMENT.SEGLINK
036633               IF A=0 THEN CALL INSEGLINK FI   % IF SEGMENT WAS EMPTY THEN
036635               A:=1                            % OK: PAGE IS LINKED TO SHADOW SEGMENT.
036636           ELSE
036637               A:=0                            % NOT WITHIN THIS SEGMENT.
036640           FI; X:=CME; GO LREG
036642   RBUS
036650

036650   %==============================================================================
036650   %
036650   %                S E G M E N T   F E T C H I N G
036650   %
036650   %==============================================================================
036650   % 37.10         S E G I N
036650
036650   % SUBROUTINE TO GET A NEW SEGMENT INTO CORE
036650   % B=SEGMENT ELEMENT; NO RETURN
036650
036650   SUBR SEGIN
036650
036650   INTEGER LSTCALLER  % ADDRESS OF LAST CALL TO SEGIN
036651   SYMBOL 5READ,5WRITE
036651
036651   SEGIN: A:=L=:LSTCALLER
036653          5CLOAD; X:=RTREF; CALL CALLMLEV(MLRESERVE)
036657          IF <0 THEN                      %SEG. TRANSFER GOING ON
036660             IF SWPFLAG><0 THEN
036662                X.STATUS BONE 5WAIT BONE 5SWWAIT=:X.STATUS    % SET IO-WAIT AND SWAP-WAIT
036666                RTREF+"BRESLINK"=:X
036671                DO WHILE X:=X.RESLINK><RTREF
036675                   IF X.TYPRING/\3=3 THEN     % RELEASE ANY SWAPPING RESOURCES HELD
036702                       X=:B:=RTREF
036704                       CALL CALLMLEV(MLBRELEASE)
036706                       RTREF+"BRESLINK"=:X    % RESTART FROM BEGINNING OF LIST
036711                   FI
036711                OD
036712             FI
036712             "RWAIT"; CALL GOMLEV ; *)FILL
036724          FI
036724                          % SINGLE THREAD FROM HERE.
036724          A:=B=:SEGREF    % SET SWAPPING SEGMENT.
036726          X=:SRTREF       % SET SWAPPING PROGRAM.
036727          NSEGA=:TSEGA    % SET SWAPPING PROGRAMS SEGMENTS.
036731          NSEGB=:TSEGB
036733          NSEGC=:TSEGC
036735          CALL XCSEGS     % CLEAR SEGMENTS FROM PIT.
036736          *LDASG FLAG     % A:=B.FLAG
036746          IF A NBIT 5DEMAND THEN      % IF NON DEMAND SEGMENT
036750              IF XSGRT=B GO FAR INSG1 % SEGMENT #1 IS HANDLED IN A SPECIAL WAY
036753              DO                      % UNTIL THE SEGMENT HAS GOT ENOUGH PAGES
036753                  *LDASG SEGLE        % A:=B.SEGLENGTH
036763                  A-=:NUMBER          % -SEGLENGTH =: NUMBER
036765                  *LDXSG BPAGL        % BEGINNING OF PAGE LIST.
036774                  IF X><0 THEN        % IF SEGMENT HAS PAGES IN MEMORY
036775                      *LDASG LOGAD    % A:=B.LOGADR
037005                      A=:D
037006                      *LDACM LOGPA    % A:=X.LOGPAGE
037014                      D-A=:A
037016                      A=:NUMBER       % NUMBER OF PAGES MISSING.
037017                  FI
037017              WHILE NUMBER><0         % NOT ENOUGH PAGES
037021                  CALL LRU; X:=:B         % FIND AN LRU SEGMENT AND PAGE.
037023                  *LDASG FLAG             % LRU.FLAG=:SAVEFLAG BZERO 5OK=:LRU.FLAG
037033                  A=:SAVEFLAG BZERO 5OK   %
037035                  *STASG FLAG             %
037045                  5WRITE; CALL TRNSEG     % WRITE LRU-PAGE TO DISK IF WRITTEN TO.
037047                  IF A><0 THEN            % IF TRANSFER WAS MADE THEN
037050                      A:=SAVEFLAG         % SAVEFLAG=:FLAG
037051                      *STASG FLAG         % RESTORE LRU.FLAG
037061                      GO FAR END1         % THIS PROGRAM HAS USED ENOUGH SWAPPING RESOURCES FOR
037062                      *)FILL              % THE TIME BEING, LET ANOTHER PROGRAM RUN.
037104                  FI
037104                  X:=:B; CALL LINKOVER    % LINK LRU-PAGE TO PAGE REQUESTING SEGMENT (SEGREF).
037106                  IF SAVEFLAG BIT 5DEMAND THEN % IF LRU-SEGMENT IS DEMAND SEGMENT.
037111                      X:=:B                    % THEN RESTORE LRU.FLAG
037112                      *STASG FLAG
037122                      X:=:B
037123                  FI
037123              OD
037124              A:=0    % READ ALL NECESSARY PAGES (NUMBER IS UNKNOWN)
037125          ELSE                    % DEMAND SEGMENT
037126

037126                                  % DEMAND SEGMENT
037126              IF A BIT 5OK THEN   % IF SEGMENT IS OK
037130                  -1=:NUMBER      % GET ONE PAGE
037132                  PNUMB=:CPNUMB   % PNUMB IS PAGEFAULTED PAGE
037134                  *LDASG FLAG     % SEGREF.FLAG
037144                  A BZERO 5OK     %             BZERO 5OK
037145                  *STASG FLAG     %                      =:SEGREF.FLAG
037155                  CALL LRU; X:=:B % FIND AN LRU SEGMENT AND PAGE.
037157                  *LDASG FLAG     % LRU.FLAG
037167                  A=:SAVEFLAG     %         =:SAVEFLAG
037170                  A BZERO 5OK     %                    BZERO 5OK
037171                  *STASG FLAG     %                             =:LRU.FLAG
037201                  5WRITE; CALL TRNSEG         % WRITE LRU-PAGE TO DISK IF WRITTEN TO.
037203                  X:=:B; CALL LINKOVER        % LINK LRU-PAGE TO PAGE REQUESTING SEGMENT.
037205                  IF SAVEFLAG BIT 5DEMAND THEN% IF LRU-SEGMENT IS DEMAND SEGMENT
037210                      X:=:B                    % THEN RESTORE LRU.FLAG
037211                      *STASG FLAG
037221                      X:=:B
037222                  FI
037222                  GO L1; *)FILL
037233   L1:        FI                  % ENDIF A BIT 5OK
037233              A:=-1               % READ 1 PAGE (DEMAND SEGMENT)
037234          FI
037234          A=:NUMBER
037235          5READ; CALL TRNSEG      % READ NUMBER OR ALL NEEDED PAGES.
037237
037237   %SEGMENT OK:
037237          *LDASG FLAG % FLAG
037247          A BONE 5OK  %      BONE 5OK
037250          *STASG FLAG %              =:FLAG
037260          IF A BIT 5DEMAND THEN                   % IF DEMAND SEGMENT
037262              *LDASG SGSTA
037272              IF A BIT 5NCLSEG OR B=S3SEG THEN    % AND (FILSEGM OR 5NSEGM OR FUSEGM OR S3SEGM) THEN
037277                  *LDXSG BPAGL                    % FIRST PAGE IN PAGE LIST (THE JUST READ PAGE)
037306                  CALL STPAGE                     % ENTER IT INTO PIT.
037307          FI; FI
037307   END1:  X:=SRTREF; 5CLOAD
037311          CALL CALLMLEV(MLRELEASE)    % RELEASE SWAPPING SEMAPHORE.
037313          IF X=RTREF THEN             % IF SWAPPING PROGRAM IS RUNNING THEN
037316              "RW"                    % LET IT CONTINUE.
037317          ELSE                        % ELSE
037320              "STUPR"                 % START HIGHEST PRIORITY READY PROGRAM.
037321          FI
037321          CALL GOMLEV                 % GO TO MONITOR LEVEL.
037322   *)FILL
037336
037336   % WRITE ALL SWAPPING PAGES WITH WIP-BIT SET, BACK TO DISC.
037336   % REMOVE ALL SEGMENTS FROM THE SEGMENT LINK, AND LINK ALL SWAPPING PAGES
037336   % TO THE DUMMY SEGMENT
037336   %
037336   INSG1: S3SEG;   CALL XCLSEG    % CLEAR OUT CURRENT SINTRAN SEGMENT.
037340          0=:S3SEG
037341          FILSEGM; CALL XCLSEG    % CLEAR OUT FILE SYSTEM.
037343   *"8N500
"037343          5NSEGM;  CALL XCLSEG    % CLEAR OUT ND500 MONITOR.
037345   *"8RFAC
"037345          FUSEGM;  CALL XCLSEG    % CLEAR OUT REMOTE FILE ACCESS.
037347   *"
"037347          DO
037347             -1=:NUMBER           % ONE PAGE AT A TIME
037351             CALL LRU; X:=:B      % FIND LRU SEGMENT AND PAGE.
037353             *LDASG FLAG          % LRU.FLAG
037363             A=:SAVEFLAG BZERO 5OK %        =:SAVEFLAG BZERO 5OK
037365             *STASG FLAG          %                             =:LRU.FLAG
037375             5WRITE; CALL TRNSEG  % WRITE LRU PAGE TO DISK IF WRITTEN TO.
037377             IF A><0 THEN         % IF TRANSFER WAS MADE THEN
037400                A:=SAVEFLAG       % SAVEFLAG=:FLAG
037401                *STASG FLAG       % RESTORE LRU.FLAG
037411             FI
037411             X:=:B; CALL LINKOVER % LINK LRU PAGE TO DUMMY SEGMENT.
037413          OD                      % EXIT FROM THIS LOOP IS MADE IN LRU WHEN
037414   RBUS                           % NO MORE SWAPPING PAGES CAN BE FOUND.
037427

037427   %==============================================================================
037427   % 37.11      L R U
037427
037427   %SUBROUTINE TO FIND LEAST RECENTLY USED SEGMENT
037427   %ENTRY: B=SEGREF
037427   % RETURN: X=LRU SEGMENT POINTER
037427
037427   SUBR LRU
037427   INTEGER ARRAY TSGN:=(TSEGB,TSEGC,TSEGA,TSEGC,TSEGA,TSEGB,TSEGC,TSEGB)
037437   INTEGER POINTER LREG=?; INTEGER R01
037440   LRU:   A:=L=:"LREG"
037442          *LDASG SGSTA
037452          IF A BIT 5NCLSEG AND B><BSEGLINK THEN   % IF THE PAGE REQUESTING SEGMENT
037457              *LDASG SEGLI                        % IS A "SPECIAL" SEGMENT NOT AT THE
037467              IF A><0 THEN                        % HEAD OF THE SEGMENT LIST, AND HAS
037470                  X:=:B                           % PAGES IN MEMORY,
037471                  CALL OUTSEGLINK                 % THEN MOVE IT TO THE HEAD OF THE
037472                  CALL INSEGLINK                  % SEGMENT LIST TO AVOID TRASHING
037473                  X:=:B                           % BECAUSE OF THESE SEGMENTS.
037474          FI  FI
037474          *LDASG FLAG % A:=B.FLAG
037504          IF X:=MAXP << 200 AND A BIT 5DEMAND THEN % IF THERE IS A LIMIT TO THE NUMBER
037512              *LDXSG BPAGL    % X:=B.BPAGLINK      % OF PAGES A SEGMENT MAY HAVE IN MEMORY,
037521              D:=0                                 % COUNT PAGES IN PAGE LIST.
037522              DO WHILE X><0                        % IF THE PAGE REQUESTING SEGMENT
037523                  *LDXCM PAGLI % X:=X.PAGLI        % HAS MORE THAN THE MAXIMUM
037531                  D+1                              % ALLOWED NUMBER OF PAGES IN MEMORY,
037532              OD                                   % THEN TAKE PAGES FROM ITSELF.
037533              IF D>=MAXP THEN B=:X; GO OUT FI
037540          FI
037540          B=:D    % SAVE B IN D                   % CHECK WHETHER THE PROGRAM USES
037541          FOR X:=-3 DO                            % THREE SEGMENTS OR LESS.
037542              IF TSEGS(X)=0 THEN B:=D; GO NOTF FI % NO, IT USES AT MOST TWO SEGMENTS.
037546              X:=:A=:B
037550              *LDXSG SEGLI    % X:=B.SEGLINK
037557              IF X=0 THEN B:=D; GO NOTF FI        % NO, SEGMENT HAS NO PAGES IN MEMORY.
037563              A=:X
037564          OD
037565          B:=D    % RESTORE B             % YES, SEGMENT HAS THREE SEGMENTS IN MEMORY.
037566          CALL GETLAST                    % CHECK IF LAST SEGMENT IS USED BY THIS PROGRAM
037567          IF =0 GO OUT                    % NO, USE THIS AS LRU SEGMENT.
037570                      % ALL THREE SEGMENTS PRESENT, TAKE ONE OF THE TWO OTHERS.
037570          FOR X:=-3 DO WHILE TSEGS(X)><B OD   % FIND INDEX OF SEGREF IN TSEGS.
037575          R01-,=:R01; X+3+X-A                 % COMPUTE INDEX INTO TSGN TO SELECT
037603          *1BANK                              % ONE OF THE OTHERS.
037604          X:=TSGN(X)                          % TSGN IS A LOCAL ARRAY AND MUST BE
037605          *2BANK                              % ACCESSED IN 1 BANK MODE.
037606          X:=X.S0; GO OUT                     % USE THIS AS LRU SEGMENT.
037610
037610   *)FILL
037622   INTEGER POINTER LREG
037623   INTEGER LRUS2
037624
037624   %      THE PROGRAM HAS AT MOST TWO SEGMENTS IN MEMORY.
037624   NOTF:  CALL GETLAST; IF =0 GO OUT  % IF LAST SEGMENT IS NOT USED BY THE PROGRAM, USE IT AS LRU.
037626          CALL GETLAST; X=:LRUS2      % TRY THE NEXT LAST.
037630          IF <0 THEN CALL GETLAST     % IF ALSO IN USE GET ANOTHER.
037632              IF <0 THEN              % AT MOST TWO SEGMENTS IN MEMORY.
037633                  X=:D:=:B=:T; *LDASG FLAG
037646                  A/\100 SHZ -5               % GET DEMAND STATUS OF THIS SEGMENT.
037650                  X:=LRUS2=:B; *LDXSG FLAG
037661                  *BLDA 60 DX; BSTA 0 DA      % GET DEMAND STATUS OF THE OTHER.
037663                  B:=T; X:=D                  % A IS NOW IN THE RANGE 0 TO 3
037665                  GOSW ERR,FRSTDEM,OUT,BOTHDEM % DEPENDING ON THE 5DEMAND BITS
037672   BOTHDEM:       IF X><B GO OUT              % TWO DEMAND SEGMENTS
037674   FRSTDEM:       X:=LRUS2                    % LRUS2 IS THE FIRST
037675          FI  FI
037675   % X=SEGMENT TO BE REMOVED(LRU-SEG):
037675   OUT:   X=:A; CALL CSEGS                    % CLEAR PAGE TABLES IF SEGMENT IS ACTIVE.
037677          X:=:B; *LDASG SEGLI                 % IF SEGMENT IS NOT IN THE SEGMENT
037710          IF A=0 THEN X:=:B; GO NOTF; FI      % LIST, THEN FIND ANOTHER.
037713          *LDASG SGSTA                        % IF THE LRU SEGMENT IS A "SPECIAL" SEGMENT
037723          IF A BIT 5NCLSEG AND BIT 5WPM THEN  % AND HAS WRITE PERMIT
037727              CALL GETWIP                     % THEN MOVE THE WIP BITS TO THE CORE MAP.
037730          FI
037730          CALL SEGSORT; CALL RANDOM           % FIND A PAGE TO BE SWAPPED OUT.
037732          X=:T                                % SAVE SEGREF IN T.
037733          *LDXSG BPAGL                        % POINTER TO FIRST PAGE OF SEGMENT.
037742          *LDACM PROTE                        % PROTECT ENTRY FOR THIS PAGE.
037750          X:=B; B:=T                          % RESTORE X(LRU) AND B(SEGREF).
037752          IF A BIT 5FIX THEN                  % DO NOT TAKE FIXED PAGES.
037754              X=:A                            % MOVE LAST SEGMENT TO HEAD OF SEGMENT LIST.
037755              T:=SEGTBANK; X:=BSEGLINK        % FIRST SEGMENT.
037757              *PRESE@3 LDXTX                  % FIRST.PREVIOUS = LAST
037760              X=:BSEGLINK                     % LAST =: FIRST
037761              X:=A                            % RESTORE X.
037762              GO FAR NOTF                     % GET ANOTHER SEGMENT.
037763          FI
037763          GO LREG                             % EXIT.
037764   *)FILL
037776   ERR:   IF SEGREF=XSGRT THEN                % SEGMENT 1, FIXC OR SET5NONDEMAND.
040002             "CLFIE"=:B; X:=SRTREF            % RELEASE SWAPPING SEMAPHORE.
040005             CALL CALLMLEV(MLBRELEASE)
040007             0=:X.ACT1SEG=:X.ACT2SEG          % RESET PROGRAMS SEGMENTS.
040011             "STUPR"; CALL GOMLEV             % GO STUPR.
040013          FI
040013          SRTREF=:RTREF
040015          A:="S19ERR"                         % ERROR 19.
040016          CALL GOMLEV                         %          AND GO PRTEXT.
040017   *)FILL
040030
040030   % LOCAL SUBROUTINE TO FIND LAST SEGMENT
040030   % RETURN: X=LRU-SEG;IF =TSEGA OR TSEGB OR =TSEGC :A<0
040030   INTEGER LREG2
040031   GETLAST:B=:D   % SAVE B IN D
040032          IF BSEGLINK=:B=0 THEN CALL ERRFATAL FI  % EMPTY SEGMENT LIST IS FATAL ERROR
040036          *LDXSG PRESE    % X:=BSEGLINK.PRESEG    % GET LAST SEGMENT IN LIST
040045          IF X=TSEGA OR X=TSEGB OR X=TSEGC THEN
040056   MOVESEG:   IF B><X THEN        % IF NOT FIRST SEGMENT THEN
040060                  A:=L=:LREG2
040062                  CALL OUTSEGLINK % MOVE SEGMENT TO HEAD OF LIST
040063                  CALL INSEGLINK
040064                  LREG2=:L
040066              FI
040066              A:=-1               % SEGMENT IS IN USE BY CURRENT PROGRAM
040067          ELSE
040070
040070              GO SKIP2
040071              SRTREF; CALL GETXSEG    % CHECK IF WANTED LRU IS SPECIAL SEGMENT
040073              IF X=A GO MOVESEG       % AND IF IT IS, MOVE IT TO HEAD OF LIST.
040075
040075   SKIP2:     A:=0
040076          FI
040076          B:=D    % RESTORE B
040077          EXIT
040100   RBUS
040112

040112   %==============================================================================
040112   %              G E T X S E G
040112   %
040112   %      FIND OUT WHETHER OR NOT A PROGRAM USES A SPECIAL SEGMENT.
040112   %      RETURNS SEGMENT POINTER OR ZERO.
040112   %      ENTRY: A=RT-PROGRAM.
040112   %      EXIT:  A=SEGMENT POINTER.
040112   %
040112   SUBR GETXSEG
040112
040112   INTEGER ARRAY SGPNT:=(0,0,0,FUSEGM,FILSEGM,5NSEGM)
040120   INTEGER XREG,TREG
040122
040122   GETXSEG: T=:TREG               % SAVE T.
040123          X=:XREG:=A              % SAVE X, X=RT-PROG.
040125          X.ACTPRI SHR 5 /\ 17    % COMPUTE PIT NO. OF NPT.
040130          IF A>=3 AND A<=5 THEN   % IF SPECIAL PIT THEN
040136              *1BANK
040137              X:=SGPNT(A); *2BANK % GET SEGMENT POINTER ADDRESS.
040142              A:=X.S0             % GET SEGMENT POINTER.
040143          ELSE
040144              A:=0                % NOT SPECIAL PIT.
040145          FI
040145          X:=XREG; T:=TREG
040147          EXIT
040150   RBUS
040152

040152   %==============================================================================
040152   % 37.12         S E G S O R T
040152   %
040152   %      SUBROUTINE TO PUT NON-USED PAGES FIRST IN PAGE LINK
040152   %      B=SORT SEGMENT
040152   %
040152   %
040152   SUBR SEGSORT, SP07J, SP07L % SEGSORT FOR NEW ENHANCED CX CPU
040152   INTEGER XREG
040153   INTEGER POINTER LREG
040154
040154   SEGSORT:IF B=XSGRT THEN EXIT FI        % DO NOT SORT DUMMY SEGMENT
040160
040160   SP07J:  GO SP07L
040161           *ILDAS FLAG
040162           IF A NBIT 5DEMAND THEN EXIT FI % DO NOT SORT NON DEMAND SEGMENTS
040165           X=:XREG:=L=:"LREG"
040170           *ILDXS BPAGL                   % START OF PAGE LIST
040171           DO WHILE X >< 0                % PASS BY UNUSED PAGES AT HEAD OF LIST
040172               *ILDAC PROTE               % GET PROTECT WORD
040173           WHILE A NBIT 5PGU AND A NBIT 5FIX  % WHILE PAGE IS UNUSED
040177               *ILDXC PAGLI               % GET NEXT PAGE
040200           OD
040201           DO WHILE X >< 0                % PASS THROUGH REST OF LIST
040202               *ILDAC PAGLI               % GET NEXT PAGE
040203               A=:D                       % AND SAVE IN D
040204               *ILDAC PROTE               % GET PROTECT WORD
040205               IF A NBIT 5PGU AND A NBIT 5FIX THEN % UNUSED PAGE IS FOUND
040211                   *ILDAC LOGPA           % REMEMBER THE LOGICAL PAGE NUMBER
040212                   A=:T                   % IN T
040213                   *IREMP                 % LINK OUT
040214                   *IINSP                 % INSERT FIRST
040215               FI
040215               X:=D                       % RESTORE NEXT PAGE POINTER
040216           OD
040217           X:=XREG
040220           GO LREG                        % RETURN
040221   RBUS
040223

040223   SUBR SP07L     % SEGSORT FOR CX CPU WITH ECO ONLY
040223   INTEGER XREG
040224   INTEGER POINTER LREG
040225
040225   SP07L:  %%% IF B=XSGRT THEN EXIT FI    % DO NOT SORT DUMMY SEGMENT
040225           *LDASG FLAG
040235           IF A NBIT 5DEMAND THEN EXIT FI % DO NOT SORT NON DEMAND SEGMENTS
040240           X=:XREG:=L=:"LREG"
040243           *LDXSG BPAGL                   % START OF PAGE LIST
040252           DO WHILE X >< 0                % PASS BY UNUSED PAGES AT HEAD OF LIST
040253               *LDACM PROTE               % GET PROTECT WORD
040261           WHILE A NBIT 5PGU              % WHILE PAGE IS UNUSED
040263               *LDXCM PAGLI               % GET NEXT PAGE
040271           OD
040272           DO WHILE X >< 0                % PASS THROUGH REST OF LIST
040273               *LDACM PAGLI               % GET NEXT PAGE
040301               A=:D                       % AND SAVE IN D
040302               *LDACM PROTE               % GET PROTECT WORD
040310               IF A NBIT 5PGU THEN        % UNUSED PAGE IS FOUND
040312                   *LDACM LOGPA           % REMEMBER THE LOGICAL PAGE NUMBER
040320                   A=:T                   % IN T
040321                   *REMPG                 % LINK OUT
040322                   *INSPG                 % INSERT FIRST
040323               FI
040323               X:=D                       % RESTORE NEXT PAGE POINTER
040324           OD
040325           X:=XREG
040326           GO LREG                        % RETURN
040327   RBUS
040333

040333   %==============================================================================
040333   % 37.13         R A N D O M
040333
040333   % SUBROUTINE TO TAKE A RANDOM(PREFERABLY NOT USED) PAGE AND PUT IT FIRST
040333   % ENTRY:     B=SEGMENT
040333   SUBR RANDOM, SP08J, SP08L      % RANDOM FOR ENHANCED NEW CX CPU
040333   INTEGER XREG,XN:=3614,CC:=33031,AA:=12465
040337   INTEGER POINTER LREG
040340   RANDOM:
040340   SP08J: GO SP08L
040341
040341          *ILDAS FLAG                 % A:=B.FLAG
040342          IF A NBIT 5DEMAND THEN      % NO RANDOM ON NON DEMAND SEGMENTS.
040344              EXIT FI
040345          X=:XREG:=L=:"LREG"
040350          *ILDXS BPAGL                % GET BEGINNING OF PAGE LIST.
040351          D:=0                        % COUNT PAGES IN D.
040352          DO
040352          WHILE X >< 0                % DO TILL END OF PAGE LIST
040353              *ILDAC PROTE            % A:=X.PROTECT
040354          WHILE A NBIT 5PGU
040356              D+1                     % COUNT UNUSED PAGES
040357              *ILDXC PAGLI            % X:=X.PAGLI
040360          OD
040361          IF D=0 THEN                 % IF NO UNUSED PAGES THEN
040363             DO WHILE X >< 0
040364                D+1                   % COUNT USED PAGES
040365                *ILDXC PAGLI
040366             OD
040367          FI
040367          D=:T; XN*AA+CC=:XN
040374          A BZERO 17=:D:=0; *RDIV ST  % COMPUTE WHICH PAGE TO TAKE
040400          *ILDXS BPAGL                % X:=B.BPAGLINK
040401          IF D > 1 THEN               % IF THE FIRST WAS NOT SELECTED
040404              FOR D-+1+1 TO 0 DO
040411                  *ILDXC PAGLI        % X:=X.PAGLI
040412              OD
040414              *ILDAC LOGPA            % A:=X.LOGPAGE
040415              A=:T
040416              *IREMP                  % MOVE THE SELECTED PAGE TO THE
040417              *IINSP                  % BEGINNING OF THE PAGE LIST
040420          FI
040420          X:=XREG
040421          GO LREG                     % RETURN
040422   RBUS
040423

040423   SUBR SP08L    % RANDOM FOR CX CPU WITH ECO ONLY
040423   INTEGER XREG,XN:=3614,CC:=33031,AA:=12465
040427   INTEGER POINTER LREG
040430
040430   SP08L: *LDASG FLAG                 % A:=B.FLAG
040440          IF A NBIT 5DEMAND THEN      % NO RANDOM ON NON DEMAND SEGMENTS.
040442              EXIT FI
040443          X=:XREG:=L=:"LREG"
040446          *LDXSG BPAGL                % GET BEGINNING OF PAGE LIST.
040455          D:=0                        % COUNT PAGES IN D.
040456          DO
040456          WHILE X >< 0                % DO TILL END OF PAGE LIST
040457              *LDACM PROTE            % A:=X.PROTECT
040465          WHILE A NBIT 5PGU
040467              D+1                     % COUNT UNUSED PAGES
040470              *LDXCM PAGLI            % X:=X.PAGLI
040476          OD
040477          IF D=0 THEN                 % IF NO UNUSED PAGES THEN
040501             DO WHILE X >< 0
040502                D+1                   % COUNT USED PAGES
040503                *LDXCM PAGLI
040511             OD
040512          FI
040512          D=:T; XN*AA+CC=:XN
040517          A BZERO 17=:D:=0; *RDIV ST  % COMPUTE WHICH PAGE TO TAKE
040523          *LDXSG BPAGL                % X:=B.BPAGLINK
040532          IF D > 1 THEN               % IF THE FIRST WAS NOT SELECTED
040535              FOR D-+1+1 TO 0 DO
040542                  *LDXCM PAGLI        % X:=X.PAGLI
040550              OD
040552              *LDACM LOGPA            % A:=X.LOGPAGE
040560              A=:T
040561              *REMPG                  % MOVE THE SELECTED PAGE TO THE
040562              *INSPG                  % BEGINNING OF THE PAGE LIST
040563          FI
040563          X:=XREG
040564          GO LREG                     % RETURN
040565   RBUS
040571

040571   %==============================================================================
040571   % 37.14      T R N S E G  R W S E G M  X T R N S E G
040571
040571   %SUBROUTINE TO READ OR WRITE PAGES OF A SEGMENT; NUMBER=-NEEDED PAGES
040571   % ENTRY:     A=READ/WRITE FLAG, B=SEGMENT
040571   %RETURN WITH A=0 IF NO TRANSFER HAS BEEN DONE
040571
040571   SUBR TRNSEG,RWSEGM,XTRNSEG,INRWSEGM
040571
040571   INTEGER WRITTEN=?,MODUS=?,CNUMBER=?,LMASSNO=?,XREG=?,XREG2=?,BREG=?,CABLPAGE=?
040571   DOUBLE BLSTX=?
040571   INTEGER POINTER LREG
040572
040572   % ENTRY: D=NUMBER OF PAGES TO TRANSFER
040572   %        X=CORMAP ELEMENT OF FIRST PAGE TO TRANSFER
040572   %        A=READ/WRITE FLAG
040572   %        B=SEGMENT ADDRESS
040572   %
040572   XTRNSEG: A=:MODUS:=RTREF=:SRTREF:=D; 0=:WRITTEN; CALL RWSEGM
040600            "STUPR"; CALL GOMLEV
040602
040602
040602   TRNSEG: A=:MODUS:=L=:"LREG"; X=:XREG
040606          0=:WRITTEN                  % NO TRANSFER IS MADE YET.
040607          NUMBER=:CNUMBER             % COPY NUMBER OF PAGES TO LOCAL VARIABLE.
040611          *LDXSG BPAGL                % (X:=BPAGLINK) GET FIRST CORE MAP ELEMENT
040620          FOR CNUMBER DO WHILE X><0
040621             *LDACM PROTE             % A:=X.PROTECT
040627             IF A=:D/\160000\/MODUS=0 OR MODUS SHR 5WIP/\D><0 THEN
040637                                      % IF READ TRANSFER AND PAGE NOT IN MEMORY
040637                                      % OR WRITE TRANSFER AND PAGE IS MODIFIED THEN
040637                1; CALL RWSEGM        % TRANSFER 1 PAGE.
040641             FI
040641             *LDXCM PAGLI             % (X:=X.PAGLI) GET NEXT CORE MAP ELEMENT
040647          OD
040651          IF WRITTEN><0 THEN          % IF A TRANSFER HAS BEEN MADE THEN
040653              X:=SRTREF; LMASSNO      % RELEASE DISK
040655              CALL CALLMLEV(MLRELEASE)
040657          FI
040657          A:=WRITTEN                  % RETURN TRANSFER FLAG IN A
040660          X:=XREG; GO LREG            % RETURN
040662   *)FILL
040674

040674   INTEGER NPGS=?,BMASS=?
040674   INTEGER POINTER LREG2=?
040674
040674   RWSEGM:A=:NPGS                     % SAVE NUMBER OF PAGES TO TRANSFER.
040675          A:=L=:"LREG2":=B=:BREG      % SAVE RETURN ADDRESS AND B.
040701          X=:XREG2                    % SAVE X.
040702          IF WRITTEN=0 THEN           % IF NO TRANSFER HAS YET BEEN MADE.
040704                                      % THEN RESERVE DISK RESOURCES.
040704              *LDASG FLAG             % SEGMENT FILE NO. IS IN TOP OF FLAG.
040714              A SHZ -15               % 3 UPPER BITS.
040715              MASSUNIT(A) SH 6        % DISK UNIT FOR SEGMENT FILE
040720              A+MODUS+60=:SWPMTMODUS  %   + MODUS(READ/WRITE)+ 60(TRANSFER) =: SWAP PARAMETER.
040723              ABLPAGE(X)=:CABLPAGE    % NUMBER OF DISK BLOCKS PER PAGE.
040725              A*NPGS=:SWPBLPAGE       % NUMBER OF BLOCKS TO TRANSFER =: SWAP PARAMETER.
040727              X=:T+X                  % SAVE X IN T AND DOUBLE.
040731              DBLST(X)=:BLSTX         % DISK ADDRESS FOR THIS SEGMENT FILE (DOUBLE WORD).
040733              X:=T                    % RESTORE X (SEGMENT FILE NO.)
040734              IF D=0 AND A=0 THEN CALL ERRFATAL FI    % ZERO DISK ADDRESS IS FATAL ERROR.
040740              GO L1
040741
040741   INTEGER WRITTEN,MODUS,CNUMBER,LMASSNO,XREG,XREG2,BREG,CABLPAGE,NPGS,BMASS
040753   DOUBLE BLSTX
040755
040755   % DISC TRANSFER ERROR, ABORT PROGRAM CURRENTLY USING SEGADM.
040755   %
040755   ERR:   BMASS=:B                    % RESTORE DF-POINTER.
040757          "DISKERR"; CALL GOMLEV      % PRINT ERROR MESSAGE AND
040761                                      % ABORT PROGRAM
040761   *)FILL
040772
040772   INTEGER POINTER LREG2
040773   L1:        MASSNO(X)=:LMASSNO      % LOGICAL UNIT FOR THE DISK OF THIS SEGMENT FILE.
040775              CALL CALLMLEV(MLLOGPH)  % GET DATAFIELD ADDRESS
040777              A=:BMASS=:B             % AND SAVE (BMASS).
041001              X:=SRTREF               % FOR SWAPPING PROGRAM
041002              CALL CALLMLEV(MLBRSERVE)% TRY TO RESERVE DISK.
041004              IF A<0 THEN             % IF THE DISK WAS IN USE THEN
041005                  IF SWPFLAG><0 THEN  % IF SWAPPING STRATEGY >< 0
041007                      BMASS=:B        % DISK DATAFIELD
041011                      A:="LNK1SWAP"   % START "1SWAP".
041012                      CALL GOMLEV     % ON MONITOR LEVEL.
041013                  FI
041013                                      % SWAPPING STRATEGY = 0
041013                  A:=5CLOAD           % RELEASE SWAPPING SEMAPHORE.
041014                  CALL CALLMLEV(MLRELEASE)
041016                  IF X=RTREF THEN "RWAIT" ELSE "STUPR" FI
041024                  CALL GOMLEV         % RESTART THIS OR ANOTHER PROGRAM.
041025                  *)FILL
041037              FI
041037                                      % DISK IS NOW RESERVED.
041037              MIN WRITTEN; BREG=:B    % SET TRANSFER FLAG, RESTORE B
041042          FI
041042          X:=XREG2; *LDACM LOGPA      % RESTORE X, GET LOGICAL PAGE NUMBER.
041051          A=:D
041052          *LDASG LOGAD                % FIRST LOGICAL PAGE OF THIS SEGMENT.
041062          D-A                         % FIND PAGE NUMBER RELATIVE TO START OF SEGMENT.
041063          *LDASG MADR                 % MASS STORAGE ADDRESS OF THIS SEGMENT.
041073          A+D*CABLPAGE=:L             % COMPUTE DISK BLOCK ADDRESS FOR THIS PAGE.
041076          BLSTX; D+L; A:=A+C
041101          AD=:SWPMASSADR              % DISK ADDRESS =: SWAP PARAMETER.
041102          A:=X SHZ -2                 % A:=PHYSICAL PAGE NO. TO TRANSFER TO/FROM.
041104          D:=0; AD SHZ -6=:SWPCOREADR % PHYSICAL PAGE =: SWAP PARAMETER.
041107   *"8SWLG
"041107          IF CSWLG><0 AND MODUS BIT "0" THEN        % COUNT PAGES WRITTEN BACK
041114             *MIN I (SNWP2; SKP; MIN I (SNWP1; JMP *+1
041120          FI
041120   *"
"041120          A:=BMASS=:B:="SWPPARLIST"   % B:=DATAFIELD, A:=SWAP PARAMETER LIST.
041123          CALL CALLMLEV(PMTRANS)      % PERFORM DISK TRANSFER.
041125                                      % RETURNS WITH STATUS IN A-REG.
041125          IF A BIT 4 GO ERR           % ERROR OCCURED IN TRANSFER.
041127          X:=BREG=:B:=XREG2           % RESTORE B AND X
041132          IF MODUS><0 THEN            % IF PAGE WAS WRITTEN TO DISK THEN
041134              *LDACM PROTE            % RESET WIP BIT
041142              A BZERO 5WIP
041143          ELSE                        % ELSE PAGE WAS READ FROM DISK
041144              *LDASG SGSTA            % GET PROTECT ENTRY FROM SEGMENT ENTRY
041154          FI
041154          *STACM PROTE                % STORE PROTECT ENTRY IN CORE MAP ENTRY.
041162          GO LREG2
041163   *)FILL
041174
041174   RBUS
041174

041174   %==============================================================================
041174   % 37.16         L I N K O V E R
041174
041174   %SUBROUTINE TO LINK PAGES OVER TO REQUESTING SEGMENT
041174   % ENTRY: B=REQ.SEGMENT (SEGREF)
041174   %        X=LRU-SEGM
041174
041174   SUBR LINKOVER
041174   INTEGER CURPAGE=?,CNUMBER=?,LRUSEG=?
041174   INTEGER POINTER LREG=?
041174   LINKOVER: A:=L=:"LREG"
041176          X=:LRUSEG                   % SAVE LRU SEGMENT
041177          NUMBER=:CNUMBER             % AND LOCAL COPY OF NUMBER OF PAGES TO LINK.
041201          B=:A                        % CLEAR SEGMENTS IF PAGE REQUESTING
041202          CALL CSEGS                  % IS ACTIVE.
041203          *LDASG SGSTA                % A:=B.FLAG
041213          IF A BIT 5FIX THEN          % FIXED SEGMENTS SHOULD NEVER COME HERE.
041215              CALL ERRFATAL FI          % FATAL ERROR.
041216          A:=B-SEGSTART=:D:=0         % VERIFY THAT THIS IS A VALID
041222          T:=5SEGSIZE; *RDIV ST       % SEGMENT TABLE POINTER.
041224          IF D><0 THEN CALL ERRFATAL FI % NO, FATAL ERROR.
041227          LRUSEG=:D                   % D=LRUSEG, B=SEGREF
041231          GO L1
041232   INTEGER CURPAGE,CNUMBER,LRUSEG
041235   INTEGER POINTER LREG
041236   *)FILL
041243   L1:    FOR CNUMBER DO              % TRY TO GET CNUMBER NUMBER OF PAGES.
041243              D:=:B                   % D=SEGREF, B=LRUSEG
041244              *LDXSG BPAGL            % X:=LRUSEG.BPAGLINK
041253          IF X=0 GO OUT               % WHILE PAGES LEFT IN LRUSEG.
041254              *LDACM PROTE            % A:=X.PROTECT
041262          IF A BIT 5WIP OR BIT 5FIX GO OUT % WHILE THERE ARE NON MODIFIED PAGES TO TAKE.
041266              X=:CURPAGE              % SET CURRENT PAGE.
041267              IF A BIT 5NCLSEG THEN   % IF "SPECIAL" SEGMENT THEN
041271                  CALL CLPAGE         % REMOVE PAGE PROM PIT
041272              FI
041272              *REMPG                  % REMOVE PAGE FROM SEGMENT
041273              B:=:D                   % B=SEGREF, D=LRUSEG
041274              *LDXSG BPAGL            % X:=SEGREF.BPAGLINK
041303              IF X=0 THEN             % IF SEGMENT HAS NO PAGES IN CORE
041305                  *LDASG SEGLI        % A:=SEGREF.SEGLINK
041315                  IF A=0 THEN         % IF SEGMENT IS NOT IN SEGMENT LIST
041316                      X:=B
041317                      CALL INSEGLINK  % LINK IT IN
041320                      X:=0
041321                  FI
041321                  *LDASG LOGAD        % A:=SEGREF.LOGADR
041331                  A-NUMBER            % COMPUTE PAGE NUMBER FOR NON DEMAND SEGMENTS.
041332              ELSE
041333                  *LDACM LOGPA        % A:=X.LOGPAGE
041341              FI
041341              A=:T                    % T=PREVIOUS LOGICAL PAGE NUMBER
041342              X:=CURPAGE              % CURRENT PAGE.
041343              *LDASG FLAG             % A:=SEGREF.FLAG
041353              IF A NBIT 5DEMAND THEN  % IF NON DEMAND SEGMENT
041355                  T-1                 % T=LOGICAL PAGE NUMBER FOR THIS PAGE
041356              ELSE                    % ELSE DEMAND SEGMENT
041357                  T:=CPNUMB           % T=PAGE FAULTED PAGE.
041360              FI
041360              *INSPG                  % INSERT PAGE INTO SEGREF
041361              *STZCM PROTE            % CLEAR THE PROTECT ENTRY SO THE PAGE WILL BE READ FROM DISK
041367          OD
041371          B:=:D                       % B=LRUSEG, D=SEGREF
041372   OUT:   *LDASG BPAGL                % A:=LRUSEG.BPAGLINK
041402          X:=B                        % X=LRUSEG
041403          IF A=0 THEN                 % IF LRU SEGMENT TURNED EMPTY
041404              CALL OUTSEGLINK FI      % THEN LINK IT OUT
041405          B:=D                        % B=SEGREF
041406          GO LREG                     % RETURN
041407   RBUS
041420

041420   %============================================================================
041420   % 37.21         X O V E R L A P
041420   %                                  (CALLED BY PROGRAMMING FROM APPL. LEVEL)
041420   % SUBROUTINE TO SEARCH FOR OVERLAP BETWEEN A REENTRANT SEGMENT AND
041420   %  A SHADOW SEGMENT AND IF NECESSARY DELETE PAGES FROM THE LATTER.
041420   %
041420   % ENTRY:     A=SEGMENT TABLE POINTER, T=REENTRANT SEGMENT
041420   %
041420   SUBR XOVERLAP, SP09J, SP09L    % XOVERLAP FOR ENHANCED CX CPU
041420   INTEGER RSTRT,REND,NXP
041423
041423   XOVERLAP: IF A=0 GO OUT                    % NO SHADOW SEGMENT: NO OVERLAP.
041424   SP09J: GO SP09L
041425
041425          A=:B                                % B=SHADSEG.
041426          *ILDAS SEGLI                        % SEGMENT LINK
041427          IF A=0 GO OUT                       % IF SEGMENT IS NOT IN SEGMENT LIST: NO OVERLAP.
041430          B:=:T                               % B=REENTSEG, T=SHADSEG.
041431          *ILDAS LOGAD                        % R.LOGADR
041432          A=:RSTRT                            %         =:START OF REENTRANT SEGMENT.
041433          *ILDAS SEGLE                        % R.SEGLENGTH
041434          A+RSTRT =:REND                      % + START OF REENTSEG =: END OF REENTRANT SEGMENT.
041436          B:=:T                               % B=SHADSEG, T=REENTSEG.
041437          *ILDXS BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041440          DO WHILE X><0                       % DO FOR ALL PAGES IN SHADOW SEGMENT.
041441              *ILDAC LOGPA                    % GET LOGICAL PAGE NUMBER
041442              IF A>=RSTRT  AND A<REND THEN    % IF WITHIN REENTRANT SEGMENT THEN OVERLAP
041450                  CALL CLPAGE                 % REMOVE PAGE FROM PAGE INDEX TABLES.
041451                  *ILDAC PAGLI                % GET POINTER TO NEXT PAGE
041452                  A=:NXP                      % AND SAVE IT.
041453                  *IREMP                      % REMOVE PAGE FROM SHADOW SEGMENT.
041454                  T:=XSGRT:=:B                % B=DUMMY SEGMENT(XSGRT), T=SHADSEG.
041456                  *IINSP                      % INSERT IT IN DUMMY SEGMENT.
041457                  *ILDAS SGSTA                % COPY PROTECT ENTRY TO RESET 5WIP BIT
041460                  *ISTAC PROTE
041461                  *ILDAS SEGLI                % SEGLINK OF DUMMY SEGMENT.
041462                  IF A=0 THEN                 % IF DUMMY SEGMENT WAS EMPTY
041463                      B:=:X
041464                      CALL INSEGLINK          % INSERT IN SEGMENT LIST
041465                      X:=BSEGLINK:=:B
041467                      *ILDAS SEGLI            % MOVE TO END OF LIST
041470                      A=:BSEGLINK
041471                  FI
041471                  B:=T                        % B=SHADSEG.
041472                  X:=NXP                      % RESTORE POINTER TO NEXT PAGE.
041473              ELSE                            % NO OVERLAP
041474                  *ILDXC PAGLI                % GET POINTER TO NEXT PAGE
041475              FI
041475          OD
041476          *ILDAS BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041477          IF A=0 THEN                         % IF IT BECAME EMPTY
041500              B=:X; CALL OUTSEGLINK FI        % REMOVE IT FROM THE SEGMENT LIST.
041502   OUT:   *WAIT                               % RETURN TO CALLING LEVEL
041503          CALL ERRFATAL
041504   RBUS
041513

041513   SUBR SP09L   % XOVERLAP FOR CX CPU WITH ECO ONLY
041513   INTEGER RSTRT ,REND,NXP
041516
041516   SP09L: %%% IF A=0 GO OUT
041516          A=:B                                % B=SHADSEG.
041517          *LDASG SEGLI                        % SEGMENT LINK
041527          IF A=0 GO OUT                       % IF SEGMENT IS NOT IN SEGMENT LIST: NO OVERLAP.
041530          B:=:T                               % B=REENTSEG, T=SHADSEG.
041531          *LDASG LOGAD                        % R.LOGADR
041541          A=:RSTRT                            %         =:START OF REENTRANT SEGMENT.
041542          *LDASG SEGLE                        % R.SEGLENGTH
041552          A+RSTRT =:REND                      % + START OF REENTSEG =: END OF REENTRANT SEGMENT.
041554          B:=:T                               % B=SHADSEG, T=REENTSEG.
041555          *LDXSG BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041564          DO WHILE X><0                       % DO FOR ALL PAGES IN SHADOW SEGMENT.
041565              *LDACM LOGPA                    % GET LOGICAL PAGE NUMBER
041573              IF A>=RSTRT  AND A<REND THEN    % IF WITHIN REENTRANT SEGMENT THEN OVERLAP
041601                  CALL CLPAGE                 % REMOVE PAGE FROM PAGE INDEX TABLES.
041602                  *LDACM PAGLI                % GET POINTER TO NEXT PAGE
041610                  A=:NXP                      % AND SAVE IT.
041611                  *REMPG                      % REMOVE PAGE FROM SHADOW SEGMENT.
041612                  T:=XSGRT:=:B                % B=DUMMY SEGMENT(XSGRT), T=SHADSEG.
041614                  *INSPG                      % INSERT IT IN DUMMY SEGMENT.
041615                  *LDASG SGSTA                % COPY PROTECT ENTRY TO RESET 5WIP BIT
041625                  *STACM PROTE
041633                  *LDASG SEGLI                % SEGLINK OF DUMMY SEGMENT.
041643                  IF A=0 THEN                 % IF DUMMY SEGMENT WAS EMPTY
041644                      B:=:X
041645                      CALL INSEGLINK          % INSERT IN SEGMENT LIST
041646                      X:=BSEGLINK:=:B
041650                      *LDASG SEGLI            % MOVE TO END OF LIST
041660                      A=:BSEGLINK
041661                  FI
041661                  B:=T                        % B=SHADSEG.
041662                  X:=NXP                      % RESTORE POINTER TO NEXT PAGE.
041663              ELSE                            % NO OVERLAP
041664                  *LDXCM PAGLI                % GET POINTER TO NEXT PAGE
041672              FI
041672          OD
041673          *LDASG BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041703          IF A=0 THEN                         % IF IT BECAME EMPTY
041704              B=:X; CALL OUTSEGLINK FI        % REMOVE IT FROM THE SEGMENT LIST.
041706   OUT:   *WAIT                               % RETURN TO CALLING LEVEL
041707          CALL ERRFATAL
041710   RBUS
041722

041722   %=============================================================================
041722   %
041722   %      1 O U T S E G L I N K       1 I N S E G L I N K
041722   %      OUTSEGLINK AND INSEGLINK CALLED FROM RT LEVEL.
041722   %
041722   %
041722   %      M O U T S E G L I N K       M I N S E G L I N K
041722   %      OUTSEGLINK AND INSEGLINK CALLED FROM MONITOR LEVEL.
041722   %
041722   SUBR 1OUTSEGLINK, 1INSEGLINK, MOUTSEGLINK, MINSEGLINK
041722   MOUTSEGLINK:
041722          *IRR MLEVB DX       % GET X FROM MONITOR LEVEL.
041723          GO FELL1
041724   1OUTSEGLINK:
041724          *IRR ALEVB DX       % GET X FROM RT LEVEL.
041725
041725   FELL1: A=:X                % PUT INTO X.
041726          CALL OUTSEGLINK     % LINK OUT SEGMENT.
041727          *WAIT               % RETURN TO RT LEVEL.
041730          CALL ERRFATAL
041731
041731   MINSEGLINK:
041731          *IRR MLEVB DX       % GET X FROM MONITOR LEVEL.
041732          GO FELL2
041733   1INSEGLINK:
041733          *IRR ALEVB DX       % GET X FROM RT LEVEL.
041734
041734   FELL2: A=:X                % PUT INTO X.
041735          CALL INSEGLINK      % LINK IN SEGMENT.
041736          *WAIT               % RETURN TO RT LEVEL.
041737          CALL ERRFATAL
041740   RBUS
041743   %=============================================================================
041743   %
041743   %      1 X C S E G S                           S M W S E G
041743   %      XCSEGS CALLED FROM RT LEVEL.            CALLING CSEGS AND TRNSEG
041743   %                                              FROM WSEG ON RT LEVEL.
041743   %
041743   %                                              W M W S E G
041743   %                                              CALLING CSEGS AND TRNSEG
041743   %                                              FROM WREENT ON MONITOR LEVEL.
041743   %
041743   SUBR 1XCSEGS, SMWSEG, WMWSEG
041743   1XCSEGS:
041743          CALL XCSEGS     % CLEAR OUT CURRENT SEGMENTS.
041744          *WAIT           % RETURN TO RT LEVEL.
041745          CALL ERRFATAL
041746
041746   % A=SEGMENT TABLE ENTRY
041746   SMWSEG:
041746          IF B><0 AND B=FILSEGM OR B=5NSEGM OR B=FUSEGM THEN  % SPECIAL-PIT SEGMENTS?
041761             B=:D; T:=SEGTBANK; X:=B; *BPAGL@3 LDXTX          % YES
041765             T:=CORMBANK
041766             DO WHILE X><0                                    % COPY PIT-ENTRY TO MEMORY MAP
041767                *LOGPA@3 LDATX
041770                A SH 1+174000=:B; A:=S0                       % A=PIT ENTRY
041774                IF A><0 THEN
041775                   *PROTE@3 STATX                             % PIT-ENTRY TO MEMEORY MAP ELEM
041776                   A BZERO 5WIP=:S0                           % CLEAR 5WIP IN PIT
042000                FI; *PAGLI@3 LDXTX
042001             OD; B:=D                                         % B POINTS TO SEGMENT
042003          ELSE
042004             A:=B; CALL CSEGS  % CLEAR PIT FOR THIS SEGMENT.
042006          FI
042006          1=:NUMBER            % 1 FOR "ALL PAGES" AND FOR WRITE.
042010          CALL TRNSEG          % WRITE ALL PAGES WITH 5WIP SET.
042011          IF WSSG BIT 17 THEN
042014             X:=WSSGA          % SEGMENT ADDRESS
042015             CALL  SREMOVE     % REMOVE PAGES FROM MEMORY
042016          FI
042016          "CLFIE"=:B           % RELEASE THE SWAPPING SEMAPHORE
042020          X:=SRTREF            % FROM THE SWAPPING PROGRAM.
042021          CALL CALLMLEV(MLBRELEASE)
042023          "STUPR"; CALL GOMLEV    % START FIRST READY PROGRAM.
042025
042025   % A=SEGMENT TABLE ENTRY
042025   INTEGER WRPREG             % P REGISTER IN WREENT.
042026
042026   WMWSEG:
042026          *IRR MLEVB DP       % GET P REGISTER ON MONITOR LEVEL (IN WREENT).
042027          A=:WRPREG           % AND SAVE IT.
042030          A:=B                % COPY SEGMENT ENTRY POINTER TO A.
042031          CALL CSEGS          % CLEAR PIT FOR THIS SEGMENT.
042032          1=:NUMBER           % 1 FOR "ALL PAGES" AND FOR WRITE.
042034          CALL TRNSEG         % WRITE ALL PAGES WITH 5WIP SET.
042035          WRPREG; CALL GOMLEV % CONTINUE IN WREENT.
042037   RBUS
042062
042062   %============================================================================
042062   %          S R E M O V E
042062   %
042062   % ROUTINE TO REMOVE ALL PAGES OF A SEGMENT FROM CORE MAP TABLE
042062   % X-REG = SEGMENT ADDRESS WITHIN SEGMENT BANK (SEGTBANK)
042062   %
042062   SUBR SREMOVE
042062     INTEGER ADRSG           % SEGMENT ADDRESS
042063     INTEGER POINTER MBSLR   % LINK ADDRESS
042064   SREMOVE:
042064          A:=L=:"MBSLR"
042066          X =: ADRSG
042067          T := SEGTBANK
042070          *SEGLI@3 LDATX
042071          IF A><0  THEN CALL OUTSEGLINK FI
042073          DO
042073               X:=ADRSG  ; T:=SEGTBANK
042075               *BPAGL@3 LDXTX
042076             WHILE X >< 0
042077               CALL RMVPG
042100          OD
042101          GO MBSLR
042102   RBUS
042105
042105   %============================================================================
042105   %          R M V P G
042105   %
042105   % ROUTINE TO LINK OUT A PAGE FROM A SEGMENT
042105   % AND TO LINK IT INTO THE DUMMY SEGMENT
042105   % X-REG =  ADDRESS OF CORE MAP ELEMENT
042105   % A-REG =  ADDRESS OF SEGMENT TO TAKE PAGE FROM
042105   %
042105   SUBR RMVPG
042105     INTEGER FRSG           % SEGMENT TO LINK OUT PAGE FROM
042106     INTEGER CMEL           % MEMORY MAP ELEMENT
042107     INTEGER POINTER MLRET  % LINK ADDRESS
042110   RMVPG:
042110          T:=L=:"MLRET"
042112          A=:FRSG ; X=:CMEL
042114          T:=CORMBANK ; *PAGLI@3 LDATX
042116          A=:D
042117          IF A >< 0 THEN
042120             *PREVI@3 LDATX
042121             X:=:D ; *PREVI@3 STATX
042123             X:=:D
042124          FI
042124          X:=FRSG  ; T:=SEGTBANK
042126          D=:A     ; *BPAGL@3 STATX
042130
042130          X:=XSGRT ; *BPAGL@3 LDATX      % INSERT PAGE IN SEGMENT DUMMY
042132          A=:D
042133          A:=CMEL ;  *BPAGL@3 STATX
042135
042135          A:=0 ; X:=CMEL ; T:=CORMBANK   % CHANGE PROTECT BIT
042140          *PROTE@3 STATX
042141          *LOGPA@3 STATX
042142          D=:A ; *PAGLI@3 STATX
042144          IF A >< 0 THEN
042145              A:=:X
042146              *PREVI@3 STATX
042147          FI
042147          A:=7 ; X:=CMEL ; T:=CORMBANK     % STORE SEGMENT NUMBER #1
042152          *PREVI@3 STATX
042153
042153          X:=XSGRT ; T:=SEGTBANK
042155          *SEGLI@3 LDATX
042156          IF A=0 THEN  CALL INSEGLINK FI
042160
042160          T:=SEGTBANK                     % SET DUMMY FIRST IN SEGMENT LINK
042161          *IOF
042162           *SEGLI@3 LDATX
042163           A=:BSEGLINK
042164          *ION
042165       GO MLRET
042166   RBUS
042173
042173   %============================================================================
042173   %      ( R )   1 X C L S E G
042173   %
042173   % ROUTINE TO CALL XCLSEG (CLEAR A SEGMENT FROM PIT INDEPENDENT OF SGSTATUS),
042173   % ACTIVATED FROM ALEVL.
042173   % A-REG ON ALEVEL IS SEGMENT TO CLEAR FROM PIT
042173   %
042173   SUBR 1XCLSEG
042173   1XCLSEG: *IRR ALEVB DA
042174            CALL XCLSEG
042175            *WAIT
042176            CALL ERRFATAL
042177   RBUS
042201
042201   %==============================================================================
042201   %      ( R )      1 X S S E G
042201   %
042201   % ROUTINE TO SETUP A SEGMENT IN PIT.
042201   % ACTIVATED FROM ALEV.
042201   % X-REG ON ALEV IS BPAGLINK OF ACTUAL SEGMENT
042201   %
042201   SUBR 1XSSEG
042201   1XSSEG: *IRR ALEVB DX
042202           A=:X
042203           *XSETP
042220           *WAIT
042221           CALL ERRFATAL
042222   RBUS
042225
042225   *ENRG3=*   % END OF RING 3 CODE.
042225
042225   **+200/    % SPACE FOR PATCHING.
042425
042425   **-1@-12+1@12/
044000   *EERG3=*-1
044000   @DEV 1
044000   @DEV (S-S-L)IP-P2-1:NPL
044000   *"8DMVC+8NLP1+8NLP2+8NLP3+8NLP4
"044000   %==============================================================================
044000   % 39.5       C T R V E   B U S Y V   F I N I V   C V C A L L   (MPIT)
044000   %
044000   %
044000   % ROUTINE ON LEVEL 11 FOR VERSATEC TRANSFER
044000   %
044000
044000   SUBR CTRVE,BUSYV,FINIV,FEILV,CVCALL
044000
044000
044000   CTRVE:
044000          T:=X.ABFUN;AD:=X.MEMAD; TAD=:CTADRG; AD=:MEMAD=:CMADR
044005          X.ABP31=:CXRG                        % END OF PARAMETER FETCHING
044007          0=:CERRCODE=:HSTAT=:BUSFL
044012          IF CTRG=24 THEN SHSTAT(0)=:HSTAT; GO FIN FI  %READ LAST STATUS
044022          TTMR=:TMR
044024   CVCALL: TAD:=CTADRG; X:=CXRG
044026          CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
044032   FINIV: X=:HSTAT=:SHSTAT(0)
044035   FIN:   IF RTRES><0 THEN CALL RTACT FI
044040          0=:TMR; CALL ID11;A+1; GO ERR22
044044   FEILV:  A=:CERRCODE; X=:SHSTAT(0); X BONE 4=:HSTAT; GO FIN
044052   BUSYV: CALL ID11;GO CVCALL
044054
044054   RBUS
044060
044060
044060   *"8DLP1+8DLP2+8DVE1+8DVE2
"044060   %==============================================================================
044060   % 39.7       T L P R I N T   C L P 1 0    (MPIT)
044060   %
044060   %
044060   % ROUTINE ON LEVEL 11 TO START DATA TRANSFER TO THE DEVICE ON MONITOR LEVEL
044060   %
044060   SUBR TLPRINT
044060
044060
044060   TLPRINT:
044060          T:=X.ABFUN; AD:=X.MEMAD
044062          T=:TRG; AD=:MEMAD; A:=D=:XCBUFST
044066          X.ABP21=:DRG; X.ABP31=:XRG
044072          0=:HSTAT
044073          IF TRG=1 THEN
044077                IF XRG=0 GO CRTACT                 % NO WORDS TO TRANSFER
044101                A SH 1=:XCBHOLD; 0=:XCHENTE
044104   FELS:        "LP5MF"-"MFUNC"+B=:B
044110   CRTACT:      CALL RTACT; CALL ID11;A+1; GO ERR22
044114          FI
044114          IF A=30 OR A=31 OR A=32 THEN
044125                IF VEFLG><0 THEN
044127                   T=:VEMOD; 0=:XCBHOLD; GO FELS
044132                FI
044132          FI; 201
044133   FINER:  A=:CERRCODE; 20=:HSTAT; GO CRTACT
044137   RBUS
044145
044145   *"8MT1+8MT2+8MT3+8MT4
"044145   %==============================================================================
044145   %      ( I )  C T R M A G T   M B U S Y   M F I N I   M F E I L
044145   %             C T R 2 M A G T   X F I N   X M B U S Y
044145   %
044145   %
044145   % LEVEL 11 ROUTINE TO PERFORM MAG.TAPE TRANSFER
044145   %
044145   % ACTIVATED BY MTRANS WITH B=DTATFIELD, X=ABST PAR.LIST
044145   % PAR0: FUNCTION CODE (SEE DRIVER)
044145   % PAR1: CORE ADDRESS
044145   % PAR2: UNIT NUMBER
044145   % PAR3: NUMBER OF WORDS IF READ/WRITE
044145
044145   SUBR CTRMAGT,CTR2MAGT,MBUSY,MFINI,MFEIL,MFIN,XFIN,XMBUSY,RTMAG,TAPBY,TRFIN
044145
044145
044145   @DEC
044145   SYMBOL DS1600=1600,D6250=6250,DS800=800
044145   @OCT
044145
044145   %=====================================================================
044145   %      ( I )    R E T V A L U E
044145   % LOCAL SUBROUTINE TO STORE RETURN.INFO IN THE CALLER'S LAST PARAMETER.
044145   %
044145   % ENTRY: A=VALUE TO RETURN
044145   %
044145   TRIPLE CTAD
044150   RETVALUE: TAD=:CTAD; T:=A; AD:=ABAD3; *DEPO
044154             TAD:=CTAD; EXIT
044156
044156   %==================================================================
044156   %      ( I )   C S T W O R D
044156   % LOCAL SUBROUTINE TO STORE A WORD IN THE CALLER'S DATA-BUFFER.
044156   %
044156   % ENTRY: T=VALUE TO STORE
044156   %        AD=PHYS.ADDR OF BUFFER
044156   %
044156   CSTWORD: *DEPO
044157            D+1; A:=A+C; EXIT
044162   *)FILL
044162
044162   % SUBROUTINE TO PERFORM READ/WRITE OPERATION
044162
044162   MTRWOPER: A:=L=:"MTLRG"
044164            IF CTRG/\77 BIT 0 THEN                              % WRITE
044170                  CTRG/\177700+20=:T; AD:=CADRG; X:=1
044176                  CALL MAGTRANS                                 % READ STATUS
044177                  IF MWRING/\X=MWSTAT THEN A:=175; GO MTLRG FI  % WRITE PROTECT VIOL
044206                  IF MLOAD/\X><0 AND "TRNSF"="HMAGT" THEN       % NOT ON TMAGT/SMAGT
044215
044215   % LOAD POINT, WRITE ERASE GAP BEFORE OPERATION
044215
044215                     CTRG/\177700+14=:T; AD:=CADRG; X:=1
044223                     CALL MAGTRANS; IF X BIT 4 GO FAR MTERET
044226                  FI
044226                  CMWCNT=:MACOU
044230            ELSE
044231                  IF A=4 OR A=64 THEN               % READ BACKWARDS
044237                     IF X:=CXRG><0 THEN X-1 FI
044242                     AD:=MEMAD; D+X; A:=A+C; AD=:MEMAD=:CMADR
044247                  FI; -1=:MACOU
044251            FI; GO EFI1; *)FILL
044257   EFI1:    FOR MACOU DO                            % NUMBER OF TIMES TO WRITE ERASE GAP IN WRITE OPERATION
044257               CTACNS=:TACOU                        % NUMBER OF RETRIES
044261               FOR TACOU DO
044261                  IF X:="TRNSF"="SMAGT" THEN
044265                     CXRG \/ DWONO =: X                 %%% 24 BIT WORD-COUNT
044270                  ELSE
044271                     X := CXRG                          %%% 16 BIT WORD-COUNT
044272                  FI
044272                  CALL GOMAGTRANS
044273                  IF X NBIT 4 GO MTOKRET
044275
044275   % READ OR WRITE ERROR. BACKSPACE AND TRY AGAIN
044275   % ADVANSE ONE RECORD IF READ BACKWARDS
044275
044275                  IF CTRG/\77=4 OR A=64 THEN T:=16 ELSE T:=15 FI
044310                  CTRG/\177700; T+A; AD:=CADRG; X:=1
044315                  CALL MAGTRANS; IF X BIT 4 GO MTERET
044320               OD
044322
044322   % REPEATED ERROR. WRITE ERASE AND TRY AGAIN IF WRITE FUNCTION:
044322
044322               IF CTRG BIT 0 THEN
044325                  CTRG/\177700+14=:T; AD:=CADRG; X:=1
044333                  CALL MAGTRANS; IF X BIT 4 GO MTERET
044336               FI
044336            OD
044340            IF X:="TRNSF"="SMAGT" THEN
044344               CXRG \/ DWONO =: X                 %%% 24 BIT WORD-COUNT
044347            ELSE
044350               X := CXRG                          %%% 16 BIT WORD-COUNT
044351            FI
044351            CALL GOMAGTRANS            % LAST TRY
044352            IF X NBIT 4 GO MTOKRET; GO OVER; *)FILL
044362    OVER:  IF "TRNSF"="TMAGT" AND CTRG NBIT 0 AND X BIT 16 THEN
044373                  CTACNS=:TACOU
044375                  FOR TACOU DO
044375                     CTRG/\177700+15=:T; AD:=CADRG; X:=1
044403                     CALL MAGTRANS; IF X BIT 4 GO MTERET
044406                     CTRG/\177700=:T
044411                     IF CTRG/\37=0 THEN T+23 ELSE T+24 FI
044417                     AD:=CADRG; X:=CXRG
044421                     CALL MAGTRANS; IF X NBIT 4 GO MTOKRET
044424                  OD; GO MTOKRET
044427            FI; GO MTERET
044430   MTERET: A:=0; GO MTLRG
044432   MTOKRET: MIN "MTLRG"; GO MTLRG
044434   *)FILL
044440
044440
044440   CTRMAGT:
044440   *"8MT1+8MT2+8MT3+8MT4 8DTMT
"044440   % B=DATAFIELD; X=PARAMETER LISTE
044440   CTR2MAGT: X:=:B
044441            AD:=MEMAD=:X.MEMAD=:X.CMADR             % 24-BIT MEMORY ADRESS
044444            A SH 14+ABFUN=:X.CTRG                   % FUNCTION CODE
044447            ABP31=:X.CXRG                           % WORD-COUNT
044451            ABP21=:X.CDRG                           %
044453            ABAD3=:X.ABAD3                          % PHYS.ADDR OF PARAMETER NO. 3
044455            X.CTRG/\700 SHZ -6 \/ X.CDRG=:X.CDRG    % UNIT IN CDRG AND/OR
044462            X.CDRG SH 6\/X.CTRG=:X.CTRG             % BITS 8-6 IN CTRG
044466            IF X."TRNSF" = "SMAGT" THEN             % STC-DRIVES?
044472               0 =: X.DWONO                         % ZERO MOST SIGN. PART OF WORD-COUNT
044473               B=:D:=X
044475               A:=XUNIT (CDRG) =: XNOWUNIT          % GET INBT/OUTBT DATAFIELD
044500               X:=B; B:=D
044502               IF X.DIAMO><0 AND X.DIAOWNER><X.RTRES THEN
044510                  X=:D
044511                  IF A.WLINK><0 OR X.TLINK><0 THEN
044516                     B:=D; A:=204; GO FAR FINER; *)FILL  % CONTROLLER USED FOR "DIAGNOSTIC-MODE"
044525                  FI; 0=:D.DIAMO=:X.DIAOWNER
044530               FI
044530            FI
044530            IF X.CTRG/\77=6 OR A=50 OR A=51 OR A>=60 AND A<=66 THEN % 24-BITS WORD-COUNT?
044551               IF X."TRNSF"><"SMAGT" THEN A:=201; B:=X; GO FAR MBF5ERR FI  % ONLY FOR STC.
044560               ABPA3=:X.ABPA3                    % DOUBLE WORD-COUNT
044562               A=:X.NMTRECS                      % NUMBER OF RECORDS IN FUNCTION 50 & 51
044563               IF X.CTRG/\77 =50 OR A=51 THEN
044573                   0=: X.DWONO
044574               ELSE
044575                   X.NMTRECS=: X.DWONO           % MOST SIGN. WORD-COUNT
044577               FI
044577               A := D =: X.CXRG                  % LOWER HALF TO CXREG
044601            FI
044601            X=:B                                    % B=DATAFIELD
044602            0=:CERRCODE=:HSTAT                      % INITIATE
044604
044604            IF X:=CDRG>MAXUNIT THEN                 % X=MT UNIT NUMBER
044610               A:=173; GO FAR MBF5ERR; *)FILL       % ILLEGAL UNIT
044616            FI
044616            IF CTRG/\77=23 THEN                     % SELECT PARITY AND DENSITY
044623               IF "TRNSF" = "SMAGT" THEN
044627                  IF CXRG = DS1600 THEN "0"         % TRANSFORM '1600' OR '6250' OR '800'
044634                  ELSE IF = D6250 THEN 1
044641                  ELSE IF = DS800 THEN 2 FI FI FI
044646                  A =: CXRG                         % STORE
044647               FI
044647               IF CXRG<0 OR A>6 THEN
044654                  A:=174; GO FAR FINER              % ILLEGAL PAR.
044656               FI; CXRG=:ADNSTY(X); GO FAR FIN      % DENSITY SELECTION
044661            FI
044661
044661            IF A=25 THEN                            % READ TAPE STATUS
044664               IF CXRG<4 THEN
044670                  -1=:HSTAT                         % BUFFER TOO SMALL!!
044672                  A:=0; CALL FAR RETVALUE           % 0=:MRETURN
044674                  GO FAR FIN
044675               FI
044675               AD:=MEMAD
044676               T:=RHSTAT(X); 0=:RHSTAT(X); CALL FAR CSTWORD
044701               T:=RERRCOUNT(X); 0=:RERRCOUNT(X); CALL FAR CSTWORD
044704               T:=WHSTAT(X); 0=:WHSTAT(X); CALL FAR CSTWORD
044707               T:=WERRCOUNT(X); 0=:WERRCOUNT(X); CALL FAR CSTWORD
044712               A:=4; CALL FAR RETVALUE              % 4=:MRETURN
044714               GO FAR FIN; *)FILL
044726            FI
044726
044726            IF A=24 THEN               % READ LAST STATUS
044731               SHSTAT(X)=:HSTAT; GO FAR FIN
044734            FI
044734
044734            IF A=36 THEN                            % READ EXTENDED STATUS
044737               IF "TRNSF"="SMAGT" THEN
044743                  AD:=MEMAD
044744                  FOR X := 0 TO 14 DO
044750                     T := FCST (X); CALL FAR CSTWORD
044752                  OD; A:=15
044755               ELSE
044756                  201=:CERRCODE; 20=:HSTAT; A:=0    % ILLEGAL FUNCTION CODE
044763               FI; CALL FAR RETVALUE; GO FAR FIN
044765            FI
044765
044765            IF A = 42 THEN                          % READ FORMAT/DENSITY CODE.
044770               ADNSTY(X); CALL FAR RETVALUE; GO FAR FIN
044773            FI
044773
044773            IF A = 46 THEN
044776               IF "TRNSF"="HMAGT" THEN
045002                  "0"                               % PERTEC INTERFACE
045003               ELSE
045004                  "1"                               % STC-INTERFACE
045005               FI
045005               CALL FAR RETVALUE; GO FAR FIN
045007            FI
045007
045007            IF A=6 THEN                             % SET RETRY AND ERASE GAP COUNTERS
045012                NMTRECS=:CTACNS=:TACNS
045015                CXRG=:   CMWCNT=:MWCNT
045020                GO FAR FIN
045021            FI
045021            ADNSTY(X)=:CDRG
045023
045023            IF TMR><0 THEN CALL ID11; FI              % WAIT FOR INTERRUPT OR TIME-OUT.
045026
045026            IF CTRG/\77=20 THEN                       % READ STATUS
045033               CTADRG; X:=1; CALL MAGTRANS; GO FAR FIN; *)FILL
045050            FI
045050            IF A>=10 AND A<26 GO FAR NOTRW
045056            IF A >= 33 AND A < 40 GO FAR NOTRW        % STC-CONTROLLER.
045064
045064   % READ OR WRITE
045064
045064          IF A=50 THEN                              % READ MULTIPLE RECORDS
045067             IF CMWCNT=0 THEN MWCNT=:CMWCNT FI
045073             IF CTACNS=0 THEN TACNS=:CTACNS FI
045077             0=:MRECCOUNTER
045100             DO WHILE MRECCOUNTER><NMTRECS
045104                IF CMWCNT=0 THEN -1=:CMWCNT FI
045110                IF CTACNS=0 THEN -1=:CTACNS FI
045114                CALL FAR MTRWOPER
045115                GO F50ERR
045116                CMADR; A:=:D-MEMA2; *RDCR ADC DD
045122                A:=:D-MEMA1
045124                IF A><0 GO XER50                              % TOO LONG RECORD
045125                IF X:=MRECCOUNTER=0 THEN
045130                   A:=D=:CMTRECSIZE
045132                ELSE
045133                   IF CMTRECSIZE><D GO XER50                  % DIFFERENT RECORD SIZE
045136                FI; MIN MRECCOUNTER; 0/\0
045140                CMADR=: MEMAD
045142             OD
045143             GO FIN50
045144          FI
045144
045144          IF A=51 THEN                              % WRITE MULTIPLE RECORDS
045147             IF CMWCNT=0 THEN MWCNT=:CMWCNT FI
045153             IF CTACNS=0 THEN TACNS=:CTACNS FI
045157             0=:MRECCOUNTER
045160             DO WHILE MRECCOUNTER><NMTRECS
045164                IF CMWCNT=0 THEN -1=:CMWCNT FI
045170                IF CTACNS=0 THEN -1=:CTACNS FI
045174                CALL FAR MTRWOPER
045175                GO F51ERR
045176                MIN MRECCOUNTER; 0/\0
045200                CMADR=: MEMAD
045202             OD
045203             GO FIN
045204          FI
045204
045204   % OTHER READ/WRITE FUNCTIONS
045204
045204          TACNS=:CTACNS; MWCNT=:CMWCNT
045210          CALL FAR MTRWOPER; GO EEFIN; GO FINX
045213   *)FILL
045215
045215   XER50:  CTRG SHZ -6/\7=:X; -1=:HSTAT=:SHSTAT(X)  % HSTAT=-1 MEANS READING RECORDS OF DIFFERNET SIZES
045224           GO FIN50
045225   F50ERR:
045225           IF HSTAT BIT 11 OR A BIT 14 THEN         % EOT OR OVERFLOW ON READ
045232               MIN MRECCOUNTER; 0/\0                % INCREASE RECORDCOUNTER
045234               CMADR; A:=:D-MEMA2; *RDCR ADC DD     % CMADR-MEMAD
045240               A:=:D-MEMA1
045242               IF A><0 GO XER50                     % TOO LONG RECORD
045243               A:=D=:CMTRECSIZE
045245               CMADR=:MEMAD
045247           FI
045247
045247   FIN50:  A:=CMTRECSIZE=:D:=MRECCOUNTER
045252           T:=ABA31; X:=ABA32; *STDTX               % NUMBER OF RECORDS AND RECORDSIZE
045255           GO FIN
045256
045256   F51ERR: A=:T
045257           IF HSTAT BIT 11 THEN
045262               MIN MRECCOUNTER;0/\0
045264               CMADR=: MEMAD
045266           FI
045266           MRECCOUNTER; CALL FAR RETVALUE           % UPDATE NUMBER OF RECORDS WRITTEN WITHOUT ERRORS
045270           A:=T
045271   EEFIN: IF A=0 GO FIN
045272          GO FINER
045273
045273   FINX:    A=:X:=CTRG/\77:=:X
045277            IF X<60 OR X>63 THEN                  % IF NOT DOUBLE WORD-COUNT
045305              IF X=4 THEN
045310                IF MEMA2-CMAD2>>CXRG THEN CXRG FI
045316              ELSE
045317                IF A-MEMA2>>CXRG THEN A:=T FI
045324              FI; IF X=26 THEN A SH 1 FI      % NUMBER OF BYTES
045330              CALL FAR RETVALUE
045331           ELSE
045332              IF X=64 THEN
045335                 MEMAD; A:=:D-CMAD2; *RDCR ADC DD
045341                 A:=:D-CMAD1
045343              ELSE
045344                 CMADR; A:=:D-MEMA2; *RDCR ADC DD
045350                 A:=:D-MEMA1
045352              FI; IF X=62 THEN AD SH 1 FI               % NUMBER OF BYTES
045356              T:=ABA31; X:=ABA32; *STDTX                 % RETURN NUMBER OF BYTES (DOUBLE WORD)
045361           FI; GO FIN; *)FILL
045365    MFIN:
045365    FIN:
045365   *"8MT1+8MT2+8MT3+8MT4 8DTMT
"045365            0=:TMR; IF RTRES><0 THEN CALL RTACT; FI
045371            CALL ID11; *JMP *-1
045373   MBF5ERR: A=:CERRCODE
045374          IF CTRG/\77=50 OR A=51 THEN A:=0; CALL FAR RETVALUE FI
045406          GO XFIN
045407   FINER: A=:CERRCODE
045410   XFIN:  HSTAT BONE 4=:HSTAT    % SET OR-OF-ERRORS
045413          GO FIN
045414
045414
045414   *)FILL
045421
045421   % ANOTHER FUNCTION THAN READ OR WRITE
045421
045421    NOTRW: IF A=12 THEN
045424
045424   % WRITE EOF. ERASE FIRST IF LOAD POINT
045424
045424               CTRG/\177700+20=:T; AD:=CADRG; X:=1
045432               CALL MAGTRANS
045433               IF MWRING/\X=MWSTAT THEN A:=175; GO FINER; FI
045442               IF MLOAD/\X><0 AND "TRNSF"="HMAGT" THEN
045451                  CTRG/\177700+14=:T; AD:=CADRG; X:=1
045457                  CALL MAGTRANS; IF X BIT 4 GO FIN
045462            FI FI
045462   % PERFORM OPERATION:
045462
045462            CTADRG; X:=1; CALL MAGTRANS; IF X BIT 4 GO FIN
045467
045467   % BACSPACE EOF-MARK IF TANDBERG TAPE AND REVERSE TO EOF OPERATION:
045467
045467            IF "TRNSF"="TMAGT" AND CTRG/\77=11 THEN
045500               CTRG/\177700+15=:T; AD:=CADRG; X:=1
045506               CALL MAGTRANS
045507            FI
045507            GO FIN
045510   *)FILL
045515   % TRANSFER SUBROUTINE:
045515
045515    GOMAGTRANS: IF CTRG/\77>=50 AND <=66 THEN
045525                   IF A=50 OR A=51 THEN
045533                            A-50
045534                   ELSE IF A=60 OR A=61 OR A=64 THEN
045546                            A-60
045547                   ELSE IF A=62 OR A=63 THEN
045556                            A-34
045557                   ELSE IF A=66 THEN A:=0           % READ TO CACHE INHIBITED AREA
045564                   FI FI FI FI
045564                   A=:T; CTRG/\177700; T\/A
045570                   AD:=CADRG
045571                ELSE CTADRG
045573                FI
045573    MAGTRANS: TAD=:TADRG; X=:XRG
045575            X:=L=:"CLRG"; X:=XRG
045600            DO
045600                  TTMR=:TMR
045602                  CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
045606    MBUSY:        TAD=:TADRG; X=:XRG
045610                  TRG/\700 SHZ -6 +"SHSTAT"+B=:X; HSTAT=:X.S0  % SAVE LAST STATUS
045620                  IF "TRNSF" = "SMAGT" THEN
045624                     CALL MFRESAVE
045625                  FI
045625   *"8MT1+8MT2+8MT3+8MT4 8DTMT
"045625                  CALL ID11
045626    XMBUSY:       TADRG; X:=XRG
045630            OD
045631    MFINI: 0=:TMR; A=:D
045633            X BZERO 4=:HSTAT
045635            TRG/\700 SHZ -6=:X; HSTAT=:SHSTAT(X)=:X           % SAVE STAT.
045644            A:=D; GO CLRG; *)FILL
045655
045655   % ERROR IN MAG.TAPE OPERATION
045655
045655   INTEGER AAREG =?
045655   MFEIL:  0=:TMR; X BONE 4=:HSTAT; A=:AAREG
045661            TRG/\700 SHZ -6=:X; HSTAT=:SHSTAT(X)=:X           % SAVE STAT.
045670            MIN ERCNT; 0/\0; T:=AERRB\/X=:AERRB
045675            IF CTRG/\77=0 OR A=2 OR A = 26 OR A=50 OR A=60 OR A=62 THEN
045717                  IF HSTAT/\BADTAPE><0 THEN
045722                     CTRG SHZ -6/\7=:X
045726                     HSTAT\/RHSTAT(X)=:RHSTAT(X); MIN RERRCOUNT(X); 0/\0
045733                  FI
045733            ELSE IF A=1 OR A=3 OR A = 27 OR A=51 OR A = 61 OR A = 63 THEN
045756                  IF HSTAT/\BADTAPE><0 THEN
045761                     CTRG SHZ -6/\7=:X
045765                     HSTAT\/WHSTAT(X)=:WHSTAT(X); MIN WERRCOUNT(X); 0/\0
045772                  FI
045772                 FI
045772            FI
045772            GO CONT1
045773   *)FILL
045776   INTEGER AAREG
045777
045777   CONT1:   X:=HSTAT
046000            IF TRG/\77<10 OR A>22 THEN
046010                  IF SERRB/\X><0 THEN
046013                    IF HSTAT BIT 11 AND A/\BADTAPE><0 GO RETR   % EOT&BAD DATABLOCK
046020                    IF X BIT 13 THEN                            % DMA-ERROR
046022                      IF X BIT 7 OR X BIT 11 GO RETR            % DMA-ERROR & EOT/EOF
046026                    FI
046026                    GO CFINX
046027                  FI
046027                  IF BADTAPE/\X=0 GO CFINX                      % WARNING!!
046032                  GO RETR                                       % NOT SERIOUS ERROR
046033            ELSE
046034                  IF SERRB/\X><0 OR TRG/\77=22 THEN GO CFINX FI
046045            FI
046045   RETR:  X:=HSTAT
046046          IF CTRG/\77>=60 AND A<=63 THEN
046056             0/\0; 0/\0                             % PATCH FOR GECO
046060          FI; AAREG; GO CLRG
046062    CFINX:IF CTRG/\77 = 50 OR A=51 THEN        % ERROR IN MULT.RECORDS
046072                GO MTLRG                       % RETURN TO CALLING LOOP
046073          ELSE
046074                AAREG; GO FAR FINX             % ERRORS IN OTHER FUNCTIONS
046076          FI
046076    RBUS
046100
046100   *"99SM1+99SM2+99SM3+99SM4
"046100   %======================================================================
046100   %      ( I )     M F R E S A V E
046100   %
046100   % SUBROUTINE TO RESTART USER WITH ASYNC. TIMEOUT IF REWIND-BUSY!!!
046100   % ENTRY: B=DATAFIELD
046100   %
046100   SUBR MFRESAVE
046100
046100   INTEGER XSAVE, LSAVE
046102   MFRESAVE:
046102          IF RTRES = 0 THEN EXIT FI                 % NOT RT-USER!!!
046105          X =: XSAVE := XNOWUNIT
046107          A := L =: LSAVE
046111          IF XRG >< 0 THEN                       % REWINDING!!
046113             * IOF                               % PROTECT!!!
046114             0 =: TMR                            % DON'T USE DMA-TIMEOUT!
046115             X.TTMR =: X.TMR
046117             "SMTBREL"=:MFUNC; CALL XRTACT
046122             * ION                               % UNPROTECT!!!
046123          FI
046123          X := XSAVE; A := LSAVE =: P           % RETURN TO CALEE
046126   RBUS
046130
046130   *"8MT1+8MT2+8MT3+8MT4 8DTMT
"046130   %==============================================================================
046130   % 39.6       T F D I S K   F D I B U S   F D I F I N   F D I F E I L
046130   %            B U F D I S C   F I N F D I S C
046130   %
046130   %
046130   % ROUTINE TO SET UP CALL TO THE FLOPPY DISC DRIVER
046130   % LEVEL 11
046130   %
046130   % ENTRY: B=ADDRESS OF THE DATAFIELD
046130   %        X=ADDRESS OF THE PARAMETER LIST
046130   %
046130   %
046130   % PARAMETERS:
046130   %
046130   %      PAR-0(BIT 0-5)= FUNCTION CODE
046130   %
046130   %             0 - READ
046130   %             1 - WRITE
046130   %             2 - TEST PARITY (READ CRC)
046130   %             3 - DUMMY
046130   %             7 - ERASE TAPE
046130   %            10 - ADVANCE TO EOF
046130   %            11 - REVERCE TO EOF
046130   %            12 - WRITE EOF
046130   %            13 - REWIND TO BOT
046130   %            14 - ADVANCE ONE RECORD
046130   %            15 - REVERCE ONE RECORD
046130   %            21 - CLEAR-DEVICE
046130   %            20 - READ STATUS
046130   %            24 - READ LAST STATUS
046130   %            36 - READ EXTENDED STATUS
046130   %            41 - FORMAT FLOPPY
046130   %            42 - READ FORMAT
046130   %            43 - READ DELETED RECORD
046130   %            44 - WRITE DELETED RECORD
046130   %            46 - READ-CURRENT-ADDRESS
046130   %            47 - WRITE-NEW-ADDRESS
046130   %            54 - COPY-FLOPPY
046130   %            55 - FORMAT-TRACK
046130   %            56 - CHECK-CARTRIDGE (READ AND TEST CRC)
046130   %            57 - TEST CARTRIDGE CAPASITY (WRITE)
046130   %            70 - RETENSION CARTRIDGE
046130   %            71 - PERFORM TEST
046130   %            72 - ILLEGAL COMMAND
046130   %            73 - CLEAR
046130   %            74 - CONTINIOUS READ
046130   %            75 - CONTINIOUS WRITE
046130   %
046130   %       BIT 6-7: UNIT NUMBER  (0,1,2,3)
046130   %
046130   %       BIT 12: STREAMER CASSET
046130   %
046130   %       PAR-1 (24-BIT MEMORY ADDRESS)
046130   %
046130   %       PAR-2 (DISK ADDRESS (LOGIC SECTOR ADDRESS))
046130   %
046130   %       PAR-3 AMOUNT TO TRANSFER (LOGICAL BLOCKS)) IF READ/WRITE
046130   %             ELSE PAR-3=FORMAT NO. IF FUNCTION IS SELECT FORMAT
046130   %
046130   %  THE FUNCTION FLAGS ARE:
046130   %
046130   %      BITS 0 TO 10   = TIMEOUT IN SECONDS
046130   %                          777=MAX (SFTIM(100))
046130
046130   % SYMBOL  3FLOP = 11 % LEGAL ON FLOPPY
046130   % SYMBOL  3STRE = 12 % LEGAL ON STREAMER
046130   % SYMBOL  3FLTI = 13 % SHORT FLOPPY TIMEOUT (SFTIM (101)).
046130   % SYMBOL  3FRES = 14 % LEGAL ONLY FROM RT-PROGS ON RING 2
046130   % SYMBOL  3DOUA = 15 % DOUBLE ADDRESS; BITS 0-5 GIVES NEW FUNCTION TO USE
046130   % SYMBOL  3DOUB = 16 % DOUBLE AMOUNT; BITS 0-5 GIVES NEW FUNCTION TO USE
046130   % SYMBOL  3ILLF = 17 % ILLEGAL FUNCTION
046130
046130   @ICR
046130
046130   INTEGER ARRAY SFTIM := (
046130    7170,   7170,  23056,   1001,     -1,     -1,     -1,   2777,
046140    3700,   1700,   3020,   7200,     -1,   1001,   1001,     -1,
046150    3001,  33073,     -1,     -1,   3001,     -1,     -1,     -1,
046160      -1,     -1,     -1,     -1,     -1,     -1,   3010,     -1,
046170    1010,   1170,   1010,   1010,   1010,     -1,   1001,   1001,
046200      -1,     -1,     -1,     -1,  11400,   1100,   3777,   2777,
046210   21000,  21001,  23003,  21003,  42074,  42075,  21000,     -1,
046220    2777,  12777,   2001,   2777,  12200,  12200,     -1,     -1,
046230    1400,       % MAX TIMEOUT
046231      10);      % SHORT FLOPPY TIMEOUT  (CHANGED FROM 4 TO 10)
046232
046232   @CR;
046232
046232   INTEGER SFFUN                % FLAGS AND TIMOUT COUNTER
046233
046233   SUBR TFDISK,FDIBUS,FDIFIN,FDIFEIL,BUFDISC,FINFDISC,FLV1STFL
046233
046233   % LOCAL SUBROUTINE TO CHANGE FUNCTION CODE WHEN THIS IS REQUIRED
046233   % ENTRY WITH D=DATAFIELD; EXIT WITH X=DATAFIELD
046233   CHFFUNC: X:=77; X/\T; X:=:D; X.CTRG/\177700\/D=:X.CTRG     % NEW FUNCTION
046242            X:=:D
046243            *1BANK
046244            SFTIM(X)=:SFFUN
046246            *2BANK
046247            X:=D
046250            EXIT
046251
046251   TFDISK: X:=:B
046252          0=:X.HSTAT=:X.CERRCODE
046254          T:=ABFUN; AD:=MEMAD=:X.MEMAD; T=:X.CTRG
046260          X=:D:=77; X/\T
046263          *1BANK
046264          T:=SFTIM(X)=:SFFUN                        % FLAGS ACCORDING TO FUNCTION
046266          *2BANK
046267          IF T<0 GO FAR D201ER                      % ILLEGAL FUNCTION
046271          IF T BIT 3FRESTRICTED THEN                % FUNCTION ONLY ALLOWED FROM RT-PROGS ON RING 2-3
046273             IF D.RTRES=0 GO FAR D201ER             % FLOPPY NOT RESERVED
046277             IF A.STATUS BIT 5BACKGR OR X.ACTPRI/\3<2 GO FAR D201ER  % ONLY LEGAL FOR RT-PROGS ON RING 2
046310          FI
046310          IF T BIT 3DOUA THEN                       % DOUBLE FLOPPY DISC ADDRESS
046312             CALL CHFFUNC                           % USE ANOTHER FUNCTION
046313             T:=ABP31; AD:=ABPA2  % PICKYLPAR
046315             IF A><0 THEN X=:B; GO FAR 100ER FI     % OUTSIDE DEVICE LIMITS
046320             A:=D=:X.CDRG                           % FLOPPY DISC ADDRESS
046322          ELSE IF T BIT 3DOUB THEN                  % DOUBLE WORDCOUNT
046325             CALL CHFFUNC                           % USE ANOTHER FUNCTION
046326             T:=ABP21; AD:=ABPA3  % PICKXLPAR
046330             %% A=:X.DWONO                          % NOT USED NOW
046330             A:=D=:X.CXRG                           % WORDCOUNT
046332          ELSE
046333             X:=D; T:=ABP31; A:=ABP21 % PICKLPAR
046336             A=:X.CDRG    % :=D=:X."FRETURN"
046337          FI; FI; T=:X.CXRG
046340          B:=X; GO L1; *)FILL                       % B=ADDR OF DATAFIELD
046350
046350   L1:    IF CTRG/\700 SHZ -6>MAXUNIT GO FAR 173ER  % ILLEGAL UNIT NUMBER
046356          A=:CFLUN
046357
046357          *1BANK
046360          T:=SFFUN
046361          *2BANK
046362          IF CTRG NBIT 14 AND T BIT 3FLTI THEN      % NOT STREAMER AND SHORT TIMOUT
046367             *1BANK
046370             SFTIM(101)
046372             *2BANK
046373          ELSE
046374             *1BANK
046375             IF SFFUN/\777=777 THEN SFTIM(100) FI
046404             *2BANK
046405          FI; A-=:TTMR                              % TIMEOUT IN SECONDS
046407          IF "TRNSF"="BFDIS" THEN -1 ELSE -3 FI
046416          A=:TACNS                                  % RETRY COUNTER
046417          X:=CFLUN                                  % X=FLOPPY UNIT NUMBER
046420          IF CTRG/\77 =24 OR A=20 THEN
046430             SHSTAT(X)=:HSTAT; GO FAR FIN           % READ STATUS/LAST STATUS
046433          FI
046433
046433          IF CTRG BIT 14 GO FAR RWOPER              % STREAMER TAPE
046436
046436          IF A/\77<2 OR A=43 OR A=44 GO FAR RWOPER  % READ & WRITE
046450
046450          IF A=13 OR A=15 OR A=16 OR A=47 THEN      % POSITION THE DISC
046464                IF CTRG/\77=13 THEN A:=0 ELSE       % REWIND
046473                   IF A=15 THEN NFDIADR(X)-1 ELSE   % BACKSPACE ONE RECORD
046501                      IF A=47 THEN CXRG ELSE        % SET CURRENT DISC ADDR
046506                         NFDIADR(X)+1               % ADVANCE ONE RECORD
046510                      FI
046510                   FI
046510                FI; T:=A; X:=FDIFORM(X)             % T=NEW FLOPPY DISC ADDR; X=FLOPPY FORMAT NUMBER
046512                X:=LFADDR(X)                        % X=LAST ADDRESS FOR THIS FORMAT
046513                IF CTRG/\77-16=0 THEN X+1 FI        % ADVANCE ONE RECORD
046520                IF T>>=X GO 100ER                   % OUTSIDE DEVICE LIMITS
046522                T=:NFDIADR(CFLUN); GO FIN; *)FILL   % SET NEXT DISC ADDRESS
046536          FI
046536          IF A=40 THEN                              % SELECT FORMAT
046541                IF X:=CXRG>>17 OR LFADDR(X)<0 THEN 174; GO FINER FI    % ILLEGAL FORMAT
046551                CXRG=:FDIFORM(CFLUN); GO FIN
046555          FI
046555          IF A=41 THEN                              % FORMAT FLOPPY
046560                FDIFORM(X) SH 10+CTRG=:CTRG
046564                1=:CXRG; 0=:CDRG; TAD:=CTADRG; X:=CXRG; CALL CFDISK
046572                IF HSTAT BIT 4 THEN 223; GO FINER FI
046577                GO FIN
046600          FI; GO OVER; *)FILL
046603
046603   RFIN:  T:=ABA31; X:=ABA32; * STATX
046606   FINFDISC:
046606   FIN:   0=:TMR; IF RTRES><0 THEN CALL RTACT FI
046612          CALL ID11; A+1; GO ERR22
046615
046615   173ER:  A:=173; GO FINER
046617   D201ER: D=:B; A:=201; GO FINER
046622   D100ER: D=:B
046623   100ER:  A:=100                                    % OUTSIDE DEVICE LIMITS
046624   FINER:  A=:CERRCODE
046625   EFINER: HSTAT BONE 4=:HSTAT; GO FIN
046631
046631   OVER:  IF A=42 THEN                              % READ FORMAT
046634                FDIFORM(X) SH 10+CTRG=:CTRG
046640                NFDIADR(X)=:CDRG; 1=:CXRG
046644                TAD:=CTADRG; X:=CXRG; CALL CFDISK
046647                IF HSTAT BIT 4 GO EFINER
046652                IF "TRNSF"="BFDIS" THEN A:=D ELSE A:=DRG FI
046661                A/\17=:FDIFORM(CFLUN); GO RFIN
046665          FI
046665          IF A=12 THEN                              % WRITE EOF
046670                FDIFORM(X) SH 10+CTRG/\177700+5=:CTRG % FUNC=5 =WRITE DELETED RECORD
046676                1=:CXRG; A:=B=:CARG
046702                NFDIADR(X)=:CDRG+1=:NFDIADR(X)
046706                X:=FDIFORM(X); T:=LFADDR(X)         % T=LAST ADDRESS FOR THIS FORMAT
046710                IF CDRG>>T GO 100ER                 % OUTSIDE DEVICE LIMIT
046713                TAD:=CTADRG; X:=CXRG; CALL CFDISK; GO FIN
046717          FI
046717          IF A=46 THEN                              % READ CURRENT DISC ADDR.
046722                A:=NFDIADR(X); GO RFIN
046724          FI
046724          IF A=54 THEN                              % COPY FLOPPY DISKETTE
046727                CXRG/\3 SHZ 14                      % DESTINATION UNIT
046732                A\/CTRG=:CTRG                       % TO BITS 14-15 IN FUNC.
046734                GO FAR RWOPER
046735          FI
046735          IF A=10 THEN A:=1 ELSE                    % ADVANCE TO EOF
046742             IF A=11 THEN A:=-1 ELSE                % REVERSE TO EOF
046747                IF A=3 GO FIN                       % COMPARE
046752                GO RWOPER; *)FILL                   % ILLEGAL FUNCTION??
046765             FI
046765          FI; A=:FDIMOD
046766          FDIFORM(X) SH 10+CTRG/\177700+2=:CTRG
046774          1=:CXRG; NFDIADR(X)=:CDRG
047000          IF FDIMOD<0 THEN CDRG-1=:CDRG FI
047005          DO                                        % UNTIL EOF IS FOUND OR UNTIL ERROR
047005                X:=FDIFORM(CFLUN); T:=LFADDR(X)     % T=LAST ADDRESS FOR THIS FORMAT
047010                IF CDRG>>T GO FAR 100ER             % OUTSIDE DEVICE LIMITS
047013                X:=CXRG; TAD:=CTADRG; CALL CFDISK
047016                IF HSTAT BIT 4 GO FAR FIN
047021                IF A BIT 5 THEN                     % DELETED RECORD
047023                      IF FDIMOD>0 THEN A+CDRG=:CDRG FI
047030                      GO OUT
047031                FI; CDRG+FDIMOD=:CDRG
047034          OD
047035   OUT:   CDRG=:NFDIADR(CFLUN)
047040          HSTAT BZERO 4=:HSTAT; GO FAR FIN
047044   *)FILL
047050
047050   % READ AND WRITE FUNCTIONS
047050
047050   RWOPER:IF CTRG NBIT 14 THEN                      % IF NOT STREAMER
047053             FDIFORM(X) SH 10+CTRG=:CTRG
047057             X:=FDIFORM(X); T:=LFADDR(X)            % T=LAST ADDRESS FOR THIS FORMAT
047061             IF CDRG+CXRG>>T GO FAR 100ER           % OUTSIDE DEVICE LIMIT
047065          FI; TACNS=:TACOUNT
047067          FOR TACOUNT DO
047067             AD:=MEMAD=:CMADR; X:=CXRG; TAD:=CTADRG; CALL CFDISK
047074             IF CTRG/\77=43 THEN                 % DELETED RECORD
047101                IF HSTAT NBIT 5 THEN 231; GO FAR FINER FI  % ERROR, NOT DELETED RECORD
047106             ELSE
047107                IF HSTAT BIT 5 THEN 3; GO FAR FINER FI     % ERROR: END-OF-FILE
047114             FI; IF HSTAT NBIT 4 GO FAR FIN
047117          OD; GO FAR FIN
047122
047122   CFDISK: TAD=:TADRG; X=:XRG; A:=L=:"CFLRG"
047126   FLV1STFL: TTMR=:TMR          % RESTARTED HERE FROM RT-PROG WHEN I/O FLOPPY (OLD FLOPPY)
047130          DO
047130                X:=XRG; TAD:=TADRG
047132                CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
047136   FDIBUS:      CALL ID11                                     % RETURN HERE WHEN BUSY
047137          OD
047140
047140   % SAVED FOR EACH ERROR RETURN FROM DRIVER
047140   INTEGER LEHSTAT                        % HSTAT WHEN LAST ERROR RETURN FROM DRIVER
047141   INTEGER LETREG                         % T-REG WHEN LAST ERROR RETURN FROM DRIVER
047142   INTEGER LEAREG                         % A-REG WHEN LAST ERROR RETURN FROM DRIVER
047143   INTEGER LEDREG                         % D-REG WHEN LAST ERROR RETURN FROM DRIVER
047144   INTEGER ECTRG,ECARG,ECDRG,ECXRG        % CALLING PROGRAMS REGISTERS WHEN ERROR OCCURES
047150   TRIPLE LETAD=LETREG,FECTREG=ECTRG
047150
047150   BUFDISC: X BONE 6; GO FDIFEIL                              % TIMEOUT
047152
047152   FDIFEIL: X BONE 4=:HSTAT=:LEHSTAT                % RETURN HERE WHEN ERROR
047155          TAD=:LETAD:=CTADR=:FECTREG; CXRG=:ECXRG
047162          HSTAT=:SHSTAT(CFLUN)
047165          A\/AERRB=:AERRB; MIN ERCNT; 0/\0
047171          GO CFLRG
047172
047172   FDIFIN: X=:HSTAT                                 % RETURN HERE WHEN FINISHED
047173          A:=X=:SHSTAT(CFLUN)
047176          GO CFLRG
047177
047177   RBUS
047207
047207
047207
047207   *"8DBUG
"047207   *"8UDMA+8VICO
"047207   SUBR ND852
047207   @MAC

)9SCLC
047207  %
047207  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
047207  %%  DRIVER FOR ND852 UNIVERSAL DMA INTERFACE
047207  %%
047207  %%
047207  %%  DRIVER TO BE CALLED WITH:
047207  %%
047207  %%  T = FUNCTION CODE,   PARAMETER (D AND X  REG)      INN    /  OUT
047207  %%       0  : DMA INPUT I.E. READ FROM INTERFACE  *   LENGTH     ACTUAL LENGTH
047207  %%       1  : DMA OUTPUT I.E. WRITE TO INTERFACE  *   LENGTH          -
047207  %%       2  : SAME AS 0 BUT IMMEDIATE RETURN      *   LENGTH
047207  %%       3  : SAME AS 1 BUT IMMEDIATE RETURN      *   LENGTH          -
047207  %%       7  : TEST MODE                                 -        HARDW. STATUS
047207  %%       20 : ND852 STATUS READ                         -        HARDW. STATUS
047207  %%       21 : DEVICE CLEAR                              -             -
047207  %%       24 : LAST STATUS FROM DATAFIELD                -        HARDW. STATUS
047207  %%            (HANDLED BY TRANSFER ROUTINE)
047207  %%       54 PIO INPUT  WITHOUT INTERUPT          **   USCO PIOD
047207  %%       55 PIO OUTPUT WITHOUT INTERUPT          **   USCO PIOD
047207  %%       56 : PIO INPUT                          **   USCO PIOD
047207  %%       57 : PIO OUTPUT                         **   USCO PIOD
047207  %%       62 : WAIT ON INTERUPT/DMA FINISH             1/0        HARDW. STATUS
047207  %%       // : ENA/DISA-BLE RTENTRY ON INTERUPT        2/3        HARDW. STATUS
047207  %%       64 : ENABLE ATTENTION INTERRUPT
047207  %%       65 : DISABLE ATTENTION INTERRUPT
047207  %%       70 : USER CONTROL LINES ARE WRITTEN INTO THE  Us.st.lin
047207  %%            CONTROL REGISTER BITS 8 - 15 WITH
047207  %%            BITS 0 - 7 ALL ZERO
047207  %%
047207  %%
047207  %%       MEMORY ADDRESS IN MEMAD AND MEMAD + 1
047207  %%    *  LENGTH IS DOUBLE WORD IN D AND X-REG
047207  %%   **  PARAMETER IN D AND X-REG   DATA FOR PIO OUTPUT IN X-REG.
047207  %%       DATA FROM PIO INPUT IN INDAT (AERRB).
047207  %%       USER CONTROLL LINES TO BE WRITTEN TO CONTROLL WORD IN D-REG.
047207  %%
047207  %%       IN STATUS REGISTER (HSTAT)
047207  %%       I------------------------------------I
047207  %%       I ....  9  8  7  6  5  4  3  2  1  0 I
047207  %%       I-----------I------------------------I
047207  %%       I SET BY    I BIT 0-7 FROM HARDWARE STATUS REG.
047207  %%       I SOFTW.    I BIT 4 : ERROR/ABORT INDICATOR SET BY HARDW. AND SOFTW.
047207  %%
047207  %%       BIT 8 IS THE ATTENTION  INTERRUPT INDICATOR
047207  %%       BIT 9 IS THE TIMEOUT INDICATOR
047207  %%
047207  %%       IN RETURN PARAMETER WHEN FUNCK >< 0
047207  %%       I------------------------------------------------------------I
047207  %%       I .... 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0 I
047207  %%       I-----------I------------------------------------------------I
047207  %%       I LEFT BYTE I   BIT 0-15 FROM HARDWARE STATUS REGISTER
047207  %%       I FROM HSTATI
047207  %%
047207  %%       BIT 16 IS THE ATTENTION  INTERRUPT INDICATOR
047207  %%       BIT 17 IS THE TIMEOUT INDICATOR
047207  %%
047207  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
047207  %%       DEFINITIONS FOR IOX INSTRUCTIONS
047207  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
047207  % REMAR=0      % READ PRESENT MEMORY ADDRESS REGISTER
047207  % LOMAR=1      % LOAD MEMORY ADDRESS REGISTER
047207  DRDAT=2     % READ DATA INPUT REGISTER
047207  DLDAT=3     % LOAD DATA OUTPUT REGISTER
047207  RSTAT=4     % READ STATUS REGISTERS
047207  LCONT=5     % LOAD CONTROL WRITE REGISTER
047207  LWCNT=7     % LOAD WORD COUNTER REGISTER
047207  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
047207  %%
047207  %%       MAIN DRIVER
047207  %%
047207  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
047207  % MACRO TO EXECUTE IOX-INSTR DATA IN A-REG
047207  )MCDEF UIOX  $FUNIX

        LDT   HDEV ,B
        AAT  $FUNIX

        IOXT

]
047207  %
047207  %   MAIN DRIVER
047207  ND852,  1BANK
047210          STF I (9TREG          % SAVE T A & D REG
047211          STX I (9XREG          % SAVE X
047212          COPY  SL DA
047213          STA I (9LREG
047214          2BANK
047215          UIOX  RSTAT

047215
047215          LDT   HDEV ,B
047216          AAT   RSTAT
047216
047217          IOXT
047220
047220
047220          STA   USTAT ,B       % SAVE IN DATA FIELD
047221          JAP   *+2            % ATTENTION INT NOT OCCURED
047222          STA   ATINT ,B       % SET ATTENTION INT OCCURED
047223          AND   (377           % MASK OFF USER STATUS BITS
047224          STA   HSTAT ,B       % SAVE IN DATA FIELD
047225  SWTST,  LDA   SOFTA,B        % SOFTWARE ACTIVATED ?
047226          JAF   FUNCTEST       % YES TEST FUNCTION
047227          LDA   BUSFL ,B       % DMA OR PIO INTERRUPT ?
047230          JAF   *+2            % JMP IF YES
047231          JMP I (USTRT         % NO TEST FOR RTENTRY
047232          AAA   -1
047233          JAF   NOTDMA
047234          LDA   HSTAT ,B       % PICK UP STATUS
047235          BSKP  ONE 20 DA      % DMA INTERRUPT ?
047236          JMP I (DMACT         % JMP IF YES
047237  NOTDMA, AAA   -1             % PIO INPUT INTERRUPT ?
047240          JAF  *+2
047241          JMP I (PIOININT      % JMP IF YES
047242          AAA   -1             % PIO OUTPUT INTERRUPT ?
047243          JAF  *+2
047244          JMP I (PIOOUTINT     % JMP IF YES
047245          AAA   -1
047246          JAF  *+2
047247          JMP I (WODINT        % WAIT ON INTERUPT INTERUPT
047250          JMP I (USTRT
047251  %
047251  %       DMA NOT ACTIVE, TEST FUNCTION FROM USER
047251  %
047251  FUNCTEST, STZ  SOFTA ,B      % CLEAR SOFTA
047252          1BANK
047253          LDA I (9TREG         % FUNCTION
047254          2BANK
047255          BSKP  ZRO 170 DA
047256          JMP I (ERRFU         % ILLEGAL FUNC
047257          JAF   *+2
047260          JMP I (DMAI          % FUNC = 0 DMA INPUT
047261          AAA   -1
047262          JAF   *+2
047263          JMP I (DMAUT         % FUNC = 1 DMA OUTPUT
047264          AAA   -1
047265          JAF   *+2
047266          JMP I (XDMAI         % FUNC = 3 DMA INPUT AND NO WAIT
047267          AAA   -1
047270          JAF   *+2
047271          JMP I (XDMAU         % FUNC = 4 DMA OUTPUT AND NO WAIT
047272          AAA   -4
047273          JAF   *+2
047274          JMP I (UTEST         % FUNC = 7 TEST MODE
047275          AAA   -11
047276          JAF   *+2
047277          JMP I (FINI          % FUNC = 20 INTERFACE STATUS READ
047300          AAA   -1
047301          JAF   *+2
047302          JMP I (DCLEA         % FUNC = 21 CLEAR DEVICE
047303          AAA   -33
047304          JAF   *+2
047305          JMP I (PIONI         % FUNC = 54 PIO INPUT  WITHOUT INTERUPT
047306          AAA   -1
047307          JAF   *+2
047310          JMP I (PIONO         % FUNC = 55 PIO OUTPUT WITHOUT INTERUPT
047311          AAA   -1
047312          JAF   *+2
047313          JMP I (PIOIN         % FUNC = 56 PIO INPUT
047314          AAA   -1
047315          JAF   *+2
047316          JMP I (PIOUT         % FUNC = 57 PIO OUTPUT
047317          AAA   -3
047320          JAF * +2
047321          JMP I (WODMA         % FUNC = 62 WAIT ON INTERUPT
047322          AAA   -2
047323          JAF *+2
047324          JMP I (ENABA         % FUNC = 64 SET ENABLE ATTENTION INTERRUPT
047325          AAA   -1
047326          JAF *+2
047327          JMP I (DISAA
047330          AAA   -3
047331          JAF *+2
047332          JMP I (USERC
047333          JMP I (ERRFU          % WRONG FUNCTION
047334  )FILL
047365
047365
047365  %---------------------------------------------------------------
047365  %       FUNC 0 & 2 DMA INPUT
047365  %
047365  XDMAI,  SAA   -1
047366          STA   NOWFL ,B       % SET NO WAIT
047367          JMP *+2
047370  DMAI,   STZ   NOWFL ,B
047371          SAT   7              % DMA INPUT CONTROL
047372          JMP   DMACO
047373  %
047373  %       FUNC 1 & 3 DMA OUTPUT
047373  %
047373  XDMAU,  SAA   -1
047374          STA   NOWFL ,B       % SET NO WAIT
047375          JMP *+2
047376  DMAUT,  STZ   NOWFL ,B
047377          LDT   (207           % DMA OUTPUT CONTR
047400  DMACO,  STZ   NOWL  ,B
047401          STZ   NOWH  ,B       % ZERO NO OF WORD TRANSF
047402          COPY  ST DD          % SAVE CONTROL IN DREG
047403          LDA   HSTAT ,B       % PICK UP STATUS  %------- NEW TEST
047404          BSKP ONE 20 DA       % DMA ACTIVE ?
047405          JMP   DMAOK          % JUMP IF NO
047406          BSET ONE 40 DA       % SET ERROR INDICATOR
047407          STA   HSTAT ,B
047410          JMP I (FINI          % ACTIVATE USER
047411  DMAOK,  LDA   MEMA1 ,B       % UPPER 16 BITS OF MEMORY ADDRESS
047412          UIOX  LOMAR           % WRITE CORE ADDR REG UPPER PART

047412
047412          LDT   HDEV ,B
047413          AAT   LOMAR
047413
047414          IOXT
047415
047415
047415          LDA   MEMA2,B        % LOWER 16 BITS OF MEMORY ADDRESS
047416          UIOX  LOMAR

047416
047416          LDT   HDEV ,B
047417          AAT   LOMAR
047417
047420          IOXT
047421
047421
047421          LDA   9DREG
047422          UIOX  LWCNT          % WRITE WORDCOUNTER UPPER BITS

047422
047422          LDT   HDEV ,B
047423          AAT   LWCNT
047423
047424          IOXT
047425
047425
047425          LDA   9XREG
047426          UIOX  LWCNT

047426
047426          LDT   HDEV ,B
047427          AAT   LWCNT
047427
047430          IOXT
047431
047431
047431          COPY  SD DA          % SET I/O CONTR AND INTERRUPT ENABLE
047432          ORA   ATTNI ,B       % ENABLE ATTENTION INTERRUPT ?
047433          ORA   UCLIN ,B
047434          UIOX  LCONT          % START DMA TRANSFER

047434
047434          LDT   HDEV ,B
047435          AAT   LCONT
047435
047436          IOXT
047437
047437
047437          SAA   1              % SET DMA ACTIVE
047440          STA   BUSFL ,B
047441          LDA   NOWFL ,B       % NO WAIT MODE ?
047442          JAP   *+2
047443          JMP I (FINA          % YES FINISH DO NOT DESTROY ATINT
047444          JMP I (UDBEX         % NO WAIT ON INTERUPT
047445  %---------------------------------------------------------------
047445  %       DMA ACTIVE  DRIVER STARTED BY AN EXTERNAL INTERRUPT.
047445  DMACT,  JPL I (NOWTR         % CALCULATE NO OF WORD TRANSFERED
047446          LDA   NOWFL ,B       % NO WAIT MODE ?
047447          JAZ   *+2
047450          JMP I (UDBEX         % YES BUSYEX
047451          JMP I (FINI
047452  %---------------------------------------------------------------
047452  %  FUNC = 7    TEST MODE
047452  UTEST,  SAA   10
047453          ORA   UCLIN ,B
047454          UIOX  LCONT

047454
047454          LDT   HDEV ,B
047455          AAT   LCONT
047455
047456          IOXT
047457
047457
047457          JMP I (FINI
047460  %---------------------------------------------------------------
047460  %       FUNC 21 CLEAR  852
047460  DCLEA,  JPL   DCLW
047461          STZ   UCLIN,B
047462          STZ   ATTNI,B
047463          STZ   NOWFL,B         % CLEAR NO WAIT FLAG
047464          LDX   DFOPP,B
047465          STZ   ISTAT,X         % CLEAR RTENTRY ON INTERUPT
047466          JMP I (FINI           % EXIT
047467
047467  % MASK OF ILLEGAL USER CONTROLL LINES IN 9DREG
047467  UCMA,   LDA   9DREG           % DREG= USER CONTROLL LINES FOR PIO INN/OUTPUT
047470          AND   (177400         % MASK OF ILLEGAL BIT
047471          STA   9DREG
047472          EXIT
047473  % CLERA DEVICE AND WRITE ZERO IN THE WORD COUNTER
047473  DCLW,    SAA   20
047474           UIOX  LCONT

047474
047474          LDT   HDEV ,B
047475          AAT   LCONT
047475
047476          IOXT
047477
047477
047477           SAA   0              % ZERO WORD COUNTERR
047500           UIOX  LWCNT

047500
047500          LDT   HDEV ,B
047501          AAT   LWCNT
047501
047502          IOXT
047503
047503
047503           IOXT
047504           EXIT
047505
047505  %---------------------------------------------------------------
047505  %       FUNC 54 PIO INPUT WITHOUT INTERUPT
047505  PIONI,  JPL   DCLW           % CLERA DEVICE AND WRITE ZERO IN THE WORD COUNTER
047506          JPL   UCMA           % MASK OF ILLEGAL USER CONTROLL LINES IN 9DREG
047507          SAA   104            % BIT 2 = ACRIVATE TRANSFER, BIT 6 = PIO MODE
047510          ORA   UCLIN ,B       % PERMANENT USER CONTROLL LINES
047511          ORA   ATTNI ,B       % ATTENTION INT ENABLE ?
047512          ORA   9DREG          % USER CONTROLL LINE(S) FOR HANDSHAKE ETC.
047513          UIOX  LCONT

047513
047513          LDT   HDEV ,B
047514          AAT   LCONT
047514
047515          IOXT
047516
047516
047516          UIOX  DRDAT

047516
047516          LDT   HDEV ,B
047517          AAT   DRDAT
047517
047520          IOXT
047521
047521
047521          STA   INDAT ,B       % SAVE PIO DATA
047522          JMP   I (FINWA       % GET STATUS AND RETURN TO USER
047523  %---------------------------------------------------------------
047523  %       FUNC 55 PIO OUTPUT WITHOUT INTERUPT
047523  PIONO,  JPL   DCLW           % CLERA DEVICE AND WRITE ZERO IN THE WORD COUNTER
047524          JPL   UCMA           % MASK OF ILLEGAL USER CONTROLL LINES IN 9DREG
047525          LDA   (300           % BIT 6 = PIO MODE, BIT 7 = OUTPUT
047526          ORA   UCLIN ,B       % PERMANENT USER CONTROLL LINES
047527          ORA   ATTNI ,B       % ATTENTION INT ENABLE ?
047530          UIOX  LCONT          %

047530
047530          LDT   HDEV ,B
047531          AAT   LCONT
047531
047532          IOXT
047533
047533
047533          LDA   9XREG          % GET PIO DATA
047534          UIOX  DLDAT

047534
047534          LDT   HDEV ,B
047535          AAT   DLDAT
047535
047536          IOXT
047537
047537
047537          LDA   (304           % BIT 2 = ACTIVATE TRANSFER
047540          ORA   UCLIN ,B       % PERMANENT USER CONTROLL LINES
047541          ORA   ATTNI ,B       % ATTENTION INT ENABLE ?
047542          ORA   9DREG          % USER CONTROLL LINE(S) FOR HANDSHAKE ETC.
047543          UIOX  LCONT

047543
047543          LDT   HDEV ,B
047544          AAT   LCONT
047544
047545          IOXT
047546
047546
047546          JMP   FINWA          % GET STATUS AND RETURN TO USER
047547
047547  %---------------------------------------------------------------
047547  %       FUNC 56 PIO INPUT
047547  PIOIN,  JPL   DCLW           % CLERA DEVICE AND WRITE ZERO IN THE WORD COUNTER
047550          JPL   UCMA           % MASK OF ILLEGAL USER CONTROLL LINES IN 9DREG
047551          SAA   100            % BIT 6 = PIO MODE
047552          ORA   ATTNI ,B       % ATTENTION INT ENABLE ?
047553          ORA   UCLIN ,B
047554          UIOX  LCONT          % SET PIO MODE

047554
047554          LDT   HDEV ,B
047555          AAT   LCONT
047555
047556          IOXT
047557
047557
047557          SAA   105            % BIT 0 = ENA. INT. ON RFT, BIT 2 = ACTIVATE TRANSF.
047560          ORA   ATTNI ,B       % ATTENTION INT ENABLE ?
047561          ORA   UCLIN ,B
047562          ORA   9DREG          % USER CONTROLL LINE(S) FOR HANDSHAKE ETC.
047563          UIOX  LCONT

047563
047563          LDT   HDEV ,B
047564          AAT   LCONT
047564
047565          IOXT
047566
047566
047566          SAA   2
047567          STA   BUSFL ,B       % SET PIO INPUT ACTIVE
047570          JMP   UDBEX          % WAIT FOR INTERRUPT
047571  )FILL
047602  %---------------------------------------------------------------
047602  %   PIO INPUT INTERRUPT
047602  PIOININT,UIOX DRDAT          % READ INTERFACE DATA REGISTER

047602
047602          LDT   HDEV ,B
047603          AAT  DRDAT
047603
047604          IOXT
047605
047605
047605          STA   INDAT ,B
047606          JMP   FINI
047607  9LREG,  0
047610  9TREG,  0
047611  9AREG,  0
047612  9DREG,  0
047613  9XREG,  0
047614  %
047614  %---------------------------------------------------------------
047614  %       FUNCTION 57 PIO OUTPUT
047614  PIOUT,  JPL   DCLW           % CLERA DEVICE AND WRITE ZERO IN THE WORD COUNTER
047615          JPL   UCMA           % MASK OF ILLEGAL USER CONTROLL LINES IN 9DREG
047616          LDA   (300           % BIT 6 = PIO MODE, BIT 7 = OUTPUT
047617          ORA   ATTNI ,B       % ENABLE ATTENTION INTERRUPT ?
047620          ORA   UCLIN ,B
047621          UIOX  LCONT          % INIT PIO OUTPUT MODE

047621
047621          LDT   HDEV ,B
047622          AAT   LCONT
047622
047623          IOXT
047624
047624
047624          LDA   9XREG          % PICK UP PIO OUTPUT DATA
047625          UIOX  DLDAT

047625
047625          LDT   HDEV ,B
047626          AAT   DLDAT
047626
047627          IOXT
047630
047630
047630          LDA   (305           % BIT 0 = ENA. INT. ON RFT, BIT 2 = ACTIVATE TRANSF.
047631          ORA   ATTNI ,B       % ENABLE ATTENTION INTERRUPT ?
047632          ORA   UCLIN ,B
047633          ORA   9DREG          % USER CONTROLL LINE(S) FOR HANDSHAKE ETC.
047634          UIOX  LCONT          % ENABLE PIO OUT

047634
047634          LDT   HDEV ,B
047635          AAT   LCONT
047635
047636          IOXT
047637
047637
047637          SAA   3
047640          STA   BUSFL ,B       % SET PIO OUTPUT ACTIVE
047641          JMP   UDBEX          % WAIT FOR INTERRUPT
047642  %---------------------------------------------------------------
047642  %   PIO OUTPUT INTERRUPT
047642  PIOOUTINT,
047643          JMP   FINI
047644  %---------------------------------------------------------------
047644  %       FUNC= 62 WAIT ON INTERUPT    ENA/DISA-BLE RTENTRY ON INTERUPT
047644  WODMA,  LDA   9XREG
047645          AAA -2               % ENABLE RTENTRY ON INTERUPT
047646          JAZ   ENNW
047647          AAA -1
047650          JAZ  DINW            % DISABLE RTENTRY ON INTERUPT
047651  %---------------------------- WAIT ON INTERUPT
047651          LDA   ATINT ,B       % ATTENTION INTERUPT HAS OCCURED
047652          JAF   WFINI
047653          LDA   HSTAT ,B       % PICK UP STATUS
047654          BSKP  ZRO 20 DA      % DMA ACTIVE ?
047655          JMP   WBUSY          % YES JUST EXIT
047656          LDA   9XREG          % WAIT ONLY FOR DMA FINISH ?
047657          JAZ   WFINI          %  YES FINISH
047660          LDA   ATTNI ,B       % IF ATTENTION INTERUPT ENABLET THEN
047661          JAF   WBUSY          %       OK    AND BUSY   EXIT
047662  WFINI,  JMP   FINI           % ELSE  ERROR AND FINISH EXIT; FI
047663  WBUSY,  SAA   4              % SET WAIT ON INTERUPT
047664          STA   BUSFL ,B       %
047665          JMP   UDBEX          % WAIT ON INTERUPT
047666  %------------------ ENA/DISA-BLE RTENTRY ON INTERUPT
047666  ENNW,   SAA -1
047667          JMP *+2
047670  DINW,   SAA 0
047671          LDX ,B DFOPP
047672          STA ,X ISTAT
047673          JMP   FINI
047674
047674  %---------------------------------------------------------------
047674  %       WAIT ON INTERUPT INTERUPT
047674  WODINT, LDA   HSTAT ,B
047675          BSKP  ONE 20 DA      %   IF DMA NOT ACTIVE THEN
047676          JMP   FINI           %     ACTIVATE USER
047677          SAA   1              %   ELSE
047700          STA   BUSFL ,B       %     SET DMA ACTIVE IN BUSFL
047701          JMP   FINW           %     ACTIVATE USER WITHOUT DESTROING BUSFL
047702                               %   FI
047702  %---------------------------------------------------------------
047702  %       FUNC = 64 SET ATTENTION INTERRUPT ENABLE
047702  ENABA,  SAA   40             % BIT 5 IN CONTROLL WRITE REGISTER
047703          STA   ATTNI ,B       % SET ATTENTION INTERRUPT ENABLE
047704          ORA   UCLIN ,B       % AND USER CONTROLL LINES
047705          UIOX  LCONT          % WRITE CONTROL REGISTER

047705
047705          LDT   HDEV ,B
047706          AAT   LCONT
047706
047707          IOXT
047710
047710
047710          JMP   FINI
047711  %
047711  %---------------------------------------------------------------
047711  %       FUNC = 65 RESET ATTENTION INTERRUPT ENABLE
047711  DISAA,  STZ   ATTNI ,B       % RESET ATTENTION INTERRUPT ENABLE
047712          STZ   ATINT ,B       % RESET ATTENTION INTERRUPT OCCURED
047713          JMP   FINI
047714  %
047714  %---------------------------------------------------------------
047714  %       FUNC = 70 WRITE USER CONTROL LINES
047714  USERC,  LDA   9XREG          % PICK UP CODE FROM USER
047715          AND   (177400        % GET RID OF ILLEGAL BITS
047716          STA   UCLIN ,B       % STORE USER CODE
047717          ORA   ATTNI ,B       % ENABLE ATTENTION INTERRUPT ?
047720          UIOX  LCONT          % WRITE CONTROL REGISTER

047720
047720          LDT   HDEV ,B
047721          AAT   LCONT
047721
047722          IOXT
047723
047723
047723          JMP   FINWA          % READ STATUS AND RETURN TO USER
047724
047724  %---------------------------------------------------------------
047724  %       BUSY EXIT
047724  UDBEX,  LDA   9LREG
047725          COPY  SA DL
047726          LDF   9TREG          % UNSAVE REGISTERS
047727          LDX   9XREG
047730          EXIT  AD1            % BUSY EXIT
047731
047731  %---------------------------------------------------------------
047731  % ENTRY FROM  FUNCTIONS WITHOUT INTERUPT
047731  FINWA,  UIOX  RSTAT          % GET AND SAVE STATUS BEFORE RETURNING TO USER

047731
047731          LDT   HDEV ,B
047732          AAT   RSTAT
047732
047733          IOXT
047734
047734
047734          STA   USTAT ,B
047735          AND   (377
047736          STA   HSTAT ,B
047737          JMP   FINW
047740  %---------------------------------------------------------------
047740  %      FINISH  EXIT          % NORMAL ENTRY
047740  FINI,   STZ   BUSFL ,B
047741  FINW,   LDX   HSTAT ,B       % ENTRY FROM  WODINT
047742          LDA   ATINT ,B
047743          JAZ   FINA
047744          BSET  ONE 100 DX     % SET ATTENTION INTERRUPT OCCURED
047745          STX   HSTAT ,B
047746          STZ   ATINT ,B       % CLEAR ATTENTION INT OCCURED FLAG
047747  FINA,   LDA   9LREG          % ENTRY FROM DMA AND NO WAIT
047750          COPY  SA DL
047751          RINC  DL             % INCREMENT RETURN ADDR TO FINISHED EXIT
047752          LDA   9AREG
047753          EXIT  AD1
047754  )FILL
047760  %---------------------------------------------------------------
047760  %       TEST IF INTERRUPT SHOULD START RTENTRY
047760  USTRT,  LDX   DFOPP ,B       % OUTPUT DF. USED TO START A MONITOR LEVEL FUNCTION
047761          LDA   RTRES ,X
047762          JAZ   UDBEX
047763          LDA   ISTAT ,X
047764          JAZ   UDBEX
047765          COPY SB DD
047766          COPY SX DB
047767          JPL I (RTACT
047770          COPY SD DB
047771          JMP   UDBEX        % BUSY EXIT
047772
047772  %---------------------------------------------------------------
047772  % CALCULATE NO OF WORD TRANSFERED
047772  NOWTR,  UIOX  REMAR

047772
047772          LDT   HDEV ,B
047773          AAT   REMAR
047773
047774          IOXT
047775
047775
047775          COPY  SA DD
047776          UIOX  REMAR

047776
047776          LDT   HDEV ,B
047777          AAT   REMAR
047777
050000          IOXT
050001
050001
050001          AND   (377            % AD HOLD MEMORY ADDRESS REGISTER
050002          LDT   MEMA1 ,B
050003          LDX   MEMA2 ,B
050004          COPY  CM2 SX DX
050005          COPY  CM1 ADC ST DT
050006          RADD SX DD
050007          RADD  ST DA ADC
050010          STD   NOWH  ,B
050011          EXIT
050012  %---------------------------------------------------------------
050012  %       WRONG FUNCTION CODE FROM USER
050012  ERRFU,  SAA   -1             % WRONG FUNCTION CODE
050013          STA   HSTAT ,B       % SET HW STATUS TO -1
050014          JMP   FINI
050015  %
050015  %       END OF DRIVER
050015  )FILL
050017  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050017  %%
050017  %%       LEVEL 11 ROUTINE TO PERFORM TRANSFER
050017  %%       ON  852 UNIVERSAL DMA INTERFACE INCLUDING
050017  %%       PIO TRANSFERS.
050017  %%
050017  %%  PARAMETER LIST TRANSFERD BY A-REG TO ABSTRANS
050017  %%
050017  %%  INTEGER POINTER FUNCP          % FUNCTION
050017  %%  DOUBLE  POINTER MEMOP          % MEMORY ADDRESS
050017  %%  INTEGER POINTER BLOCP          % NOT USED
050017  %%  DOUBLE  POINTER DATP           % PARAMETER INN/OUT
050017  %%
050017  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050017
050017  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050017  %%       ACTIVATED FROM STDRIV
050017  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050017  USDRV,  LDF ,X ABFUN
050020
050020          STT ,B CTRG          % FUNCTION CODE
050021          STD ,B MEMA1         % MEMORY ADDRES
050022
050022
050022          LDD  ,X ABPA3        %   24 BIT WORD COUNTER
050023          STD  ,B CDRG         %   CDRG= UPPER BITS, CXRG= LOWER BITS
050024                               %   PIO DATA IN CXRG, PIO UCLIN MASK IN CDRG
050024                               %   END OF PARAMETER FETCHING
050024
050024          LDA   ,B CTRG        % PICK UP FUNCTION
050025          AAA   -24
050026          JAZ   UFIN           % JUST EXIT STATUS IS ALREADY IN HSTAT ,B
050027          LDA   ,B TTMR        % SET TIMEOUT TIME
050030          STA   ,B TMR
050031  ULOOP,  LDF   CTRG ,B        % PICK UP PARAMETERS
050032          LDX   CXRG ,B
050033          MIN   SOFTA ,B       % SET SOFTWARE ACTIVATED
050034          COPY  SA DA          % JGA SOFTA=0 TRANSFER DONE (DUMMY)
050035          JPL I TRNSF ,B       % CALL DRIVER
050036          JMP I ERROR ,B       % ERROR EXIT
050037          JMP I BUSY ,B        % BUSY EXIT
050040          JMP I FINIS ,B       % TRANSFER COMPLETE EXIT
050041
050041  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050041  %%       ACTIVATED FROM DRIVER
050041  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050041  UDDRV,  SAA   -1             % JGA INSERTED TO TELL ROUTINE
050042          STA   SOFTA ,B       % THAT CALL WAS NOT SOFTWARE INITIATED.
050043          JMP   ULOOP          % CALL TRANSFER AGAIN.
050044  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050044  %%       BUSY / ERROR
050044  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050044  UBUSY,  STF   CTRG ,B        % SAVE PARAMETERS
050045          STX   CXRG ,B
050046          JPL I (WT11          % WAIT FOR INTERRUPT.
050047  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050047  %%       FINISH
050047  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050047  UFIN,   LDA   RTRES ,B       % ACTIVATE USER ?
050050          JAZ   NOONE          % JMP IF NOONE TO ACTIVATE
050051          LDA   CTRG  ,B       % PICK UP FUNCTION
050052          JAF   NO0            % IF FUNC = 0 THEN RETURN NO OF WORD TRANSF.
050053          LDD   NOWH  ,B
050054          JMP   DAPAR
050055  NO0,    AAA   -54            %
050056          JAZ   *+3
050057          AAA   -2
050060          JAF   NOPO           % IF FUNC =54 OR =56 THEN RETURN PIO DATA
050061          LDA   INDAT ,B       %
050062          SAD ZIN SHR 20       % A=:D; A:="0"
050063          JMP   DAPAR          %
050064  NOPO,   LDA   USTAT ,B       %  ELSE RETURN USER STATUS
050065          COPY  SA DD
050066          LDA   HSTAT ,B       % HSTAT HAVE TIMEOUT, ATTINT ETC.
050067          SHA ZIN SHR 10       %
050070  DAPAR,  LDT   ,B ABA31
050071          LDX   ,B ABA32
050072          STDTX                % RETURN PARAMETER
050073          JPL I (RTACT         % ACTIVATE USER
050074  NOONE,  STZ   ,B TMR         % CLEAR TIMEOUT TIME
050075          JPL I (WT11          % GO AND WAIT FOR INTERRUPTS
050076  )FILL
050100  %%
050100  %%      END OF LEVEL 11 TRANSFER ROUTINE
050100  %%
050100  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050100  %%
050100  %%     ROUTINE ON LEVEL 11 TO HANDLE TIMEOUT
050100  %%
050100  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050100
050100  UD11T,  UIOX  RSTAT          % READ STATUS

050100
050100          LDT   HDEV ,B
050101          AAT   RSTAT
050101
050102          IOXT
050103
050103
050103          STA   USTAT ,B
050104          JAN   AYES           % ATTENTION INT ?
050105          LDX   ATINT ,B       % PREVIOUS ATTENTION INT ?
050106          JXZ   ANOT
050107  AYES,   BSET  ONE 100 DA     % SET ATTENTION INT OCCURED
050110          JMP   *+2
050111  ANOT,   BSET  ZRO 100 DA
050112          AND   (777
050113          BSET  ONE 40 DA      % SET ERROR INDICATOR
050114          BSET  ONE 110 DA     % SET TIME OUT INDICATOR
050115          STA   HSTAT ,B       % SAVE IN DATAFIELD
050116          STZ   ATINT ,B       % RESET ATTENTION INTERRUPT INDICATOR
050117          LDA   NOWFL,B        % PICK UP STATUS
050120          JAN   UFIN           % NO WAIT MODE, DO NOT STOP DMA
050121          LDA   BUSFL ,B       % PICK UP BUSY INDICATOR
050122          STZ   BUSFL ,B       % CLEAR BUSY INDICATOR
050123          AAA   -4             % IF WAIT ON INTERUPT THEN
050124          JAZ   UFIN           %   DO NOT CLEAR DEVICE; FI
050125          SAA   20             % BIT 4 = DEVICE CLEAR
050126          ORA   ATTNI ,B       % ENABLE ATTENTION INTERRUPT ?
050127          STZ   UCLIN ,B       % USER CONTROLL LINES
050130          UIOX  LCONT

050130
050130          LDT   HDEV ,B
050131          AAT   LCONT
050131
050132          IOXT
050133
050133
050133          JMP I FINIS ,B       % CONTINUE AS WHEN TERMINATING DRIVER
050134
050134  )FILL
050135  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050135  %% INPUT DATA FIELD LAYOUT
050135  %%  DISP.  SYMBOL  CONTENS
050135  %%  -45 - -40                     % NOT USED
050135  %%  -37    MRETURN                % NOT USED
050135  %%  -35    BUSFL                  % 0= IDLE, 1=DMA , 2=PIO IN ,3=PIO OUT
050135  %%                                % 4= WAIT ON INTERUPT
050135  %%  -34    NOWFL                  % -1 = NO WAIT (FUNC 2 AND 3)
050135  %%  -30    NOWH                   % NO OF WORD TRANSFERD UPPER BITS
050135  %%  -27    NOWL                   % NO OF WORD TRANSFERD LOWER BITS
050135  %%  -26    CTRG                   % FUNCTION CODE
050135  %%  -25    CARG                   %
050135  %%  -24    CDRG                   % WORDCOUNT UPPER BIT
050135  %%  -23    CXRG                   % WORDCOUNT LOWER BIT OR PIO OUTPUT DATA
050135  %%  -22    ATTNI                  % =40 ATTENTION INTERUPT IS ENABLED
050135  %%  -21    EXTIO                  % NOT USED
050135  %%  -20    USTAT                  % UNMASKED STATUS REG.
050135  %%  -17    INDAT                  % PIO INPUT DATA
050135  %%  -16    UCLIN                  % USER CONTROLL LINES
050135  %%  -15    ATTINT                 % >< 0 IF ATTENTION INTERUPT HAS OCCURED
050135  %%                                % BUT NOT RECIVED BY USER
050135  %%  -14    SOFTA                  %
050135  %%  -12    TRNSF/ND852            % DRIVER
050135  %%  -11    BUYSY/UBUSY            % BUSY EXIT FROM DRIVER
050135  %%  -10    FINISH/UFIN            % FINISHED EXIT FROM DRIVER
050135  %%  - 7    ERROR/UBUSY            % ERROR EXIT TREATED AS BUSY EXIT
050135  %%  - 6    TMSUB/UDTMO            % TIMEOUT SUBROUTINE
050135  %%  - 5    TMR                    % TIMEOUT COUNTER
050135  %%  - 4    TTMR/177771            % CA 6-7 SEC TIMEOUT
050135  %%  - 3    HDEV                   % IOX DEVICE ADDRESS
050135  %%  - 2    STDRIV/USDRV           % START ADDRESS LEVEL 11
050135  %%  - 1    DRIVER/UDDRV           % DRIVER
050135  %%    2    BWLIN                  % BWLINK
050135  %%    3    TYPRI                  % TYPRING
050135  %%    4    ISTATE                 % NOT USED
050135  %%    6    MFUNC/RETRA            % RETRANS AS FOR MAG TAPE
050135  %%   11    MTRAN/MTRNS            % MTRNS AS FOR MAG TAPE
050135  %%   14    MEMA1                  % MEMORY ADDRESS UPPER BIT
050135  %%   15    MEMA2                  % MEMORY ADDRESS LOWER BIT
050135  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
050135  )KILL DRDAT DLDAT RSTAT LCONT LWCNT UIOX SWTST OTDMA CTEST
050135  )KILL XDMAI DMAI XDMAU DMAUT DMACO DMAOK DMACT UTEST DCLEA PIONI
050135  )KILL PIONO PIOIN ININT 9LREG 9TREG 9AREG 9DREG 9XREG PIOUT UTINT
050135  )KILL WODMA WFINI WBUSY ODINT ENABA DISAA USERC USYEX FINI NOAT FINWA
050135  )KILL NOWLR NOWTR ERRFU ULOOP NO0 NOPO DAPAR NOONE UDBEX
050135  )KILL AYES ANOT PFIN FINW DCLW UCMA ENNW DINW USTRT FINA
050135  )9RCLC
)9SLPL
050135   RBUS
050135   *"
"050135

050135   *"8GPI0+8GPI1+8GPI2+8GPI3+8GPI4+8GPI5+8GPI6+8GPI7 8XMSG
"050135   SUBR GPIBT,GPIBH,GPBUS,GPFIN,GPERR,GPITR
050135   %====================================================================
050135   %                                                                   =
050135   % EXTENDED TRANSFER ROUTINE FOR GENERAL PURPOUSE INTERFACE BUS      =
050135   %                                                                   =
050135   %====================================================================
050135   % FUNCTION CODES:
050135   %
050135   %                     00 : DMA INPUT
050135   %                     01 : DMA OUTPUT
050135   %                     02 : READ STATUS
050135   %                     03 : CLEAR DEVICE
050135   %                     04 : READ PIO
050135   %                     05 : WRITE PIO
050135   %                     06 : ENABLE SRQ INTERRUPT
050135   %                     07 : DISABLE ALL INTERRUPTS
050135   %                     10 : SERIAL POLL
050135   %                     11 : PARALLELL POLL
050135   %                     12 : READ SYSTEM DEVICE LIST
050135   %                     13 : READ USER DEVICE LIST
050135   %                     14 : SEND CONTROL STRING WITHOUT DEVICE LIST
050135   %                     15 : SEND COMMAND BYTE WITH DEVICE LIST
050135   %                     16 : RUN MICROPROGRAM CONTROLLER TEST
050135   %                     17 : LOG OFF
050135   %                     20 : LOG ON AS PRIVILEGED
050135   %                     21 : LOG ON AS UNPRIVILEGED
050135   %                     22 : WAIT FOR SRQ INTERRUPT (CODE NEVER SEEN BY TRANFER ROUTINE)
050135   %                     23 : CHECK FOR SRQ INTERRUPT (CODE NEVER SEEN BY TRANFER ROUTINE)
050135   %                     24 : SET SINGLE USER MODE
050135   %                     25 : RESET SINGLE USER MODE
050135   %                     26 : WHO IS ON
050135   %====================================================================
050135
050135
050135   %  GLOBAL DISP VARIABLES ARE DECLARED AS NEGATIVE
050135   DISP 12
050135     INTEGER GPIBNO               % CONTROLLER NO (ASCII)
050135     INTEGER GPACT                % ACTIV FLAG
050135   PSID
050135   DISP 25
050135     INTEGER GPXTB                % XT-BLOCK ADDRESS
050135     INTEGER SXTBL                % SRQ-TASK XT-BLOCK ADDRESS
050135     INTEGER CPORT                % COMMAND-PORTNUMBER
050135     INTEGER SQTXA                % SRQ-TASK XT-BLOCK ADDRESS
050135     INTEGER DPORT                % DMA-PORTNUMBER
050135     INTEGER DMESA                % DMA MESSAGE ADDRESS
050135     DOUBLE  DBUFA                % DMA BUFFER ADDRESS
050135     INTEGER MVERS                % MICROPROGRAM VERSION AND REV. LEVEL
050135     INTEGER SUSFL                % SINGLE USER FLAG
050135     INTEGER DEVFL                % DEVICE FLAG
050135     INTEGER USCONT               % NUBER OF USERS PRESENTLY LOGGED ON
050135     INTEGER CGPIM                % CURRENT MESSAGE ADDRESS
050135     INTEGER CURMTY               % CURRENT MESSAGE TYPE
050135     DOUBLE  CURM                 % CURRENT MAGIC NUMBER
050135     INTEGER ERADD                % LAST ERROR ADDRESS
050135     INTEGER XERCO                % X-MESSAGE ERRORCODE
050135     INTEGER SRQFL                % SRQ PROCESSING FLAG
050135     INTEGER POINTER MRETA        % RETURN ADDRESS AFTER MONITOR CALL
050135     INTEGER POINTER SRETA        % RETURN ADDRESS AFTER MONITOR CALL
050135     INTEGER POINTER GRETA        % RETURN ADDRESS AFTER TIMEOUT ROUTINE
050135     INTEGER 9TREG                % SAVED TREG WHEN CALLING ID11/WT11
050135     INTEGER 9AREG                % SAVED AREG WHEN CALLING ID11/WT11
050135     INTEGER 9DREG                % SAVED DREG WHEN CALLING ID11/WT11
050135     INTEGER 9XREG                % SAVED XREG WHEN CALLING ID11/WT11
050135     INTEGER DINPT                % INPUT DATA TRANSFER
050135     INTEGER PIODP                % PIO DATA POINTER
050135     INTEGER PIOWC                % PIO WORD COUNTER
050135     INTEGER FIRST                % FIRST WORD TO BE RECEIVED FLAG
050135     INTEGER POINTER SRSTR        % START LOCATION FOR SRQ ROUTINE
050135     INTEGER ARRAY UMESS(20)      % USER MESSAGE TABLE
050135     DOUBLE  ARRAY MNARR(20)      % MAGIC NUMBER ARRAY
050135      INTEGER CURFU               % CURENT FUNCTION CODE
050135      INTEGER CGPUS               % CURENT USER NO.
050135      INTEGER ARRAY GPISA(10)     % INSTRUMENT NO. ARRAY
050135      DOUBLE  CURAD               % CURENT DATA ADDRESS
050135      INTEGER CURBC               % NUMBER OF BYTES TO BE TRANSFERED
050135      DOUBLE  ARRAY UENV(20)      % USER TERMNO / RT ADDRESS TABLE
050135      DOUBLE  DINSO=CURM          % PHYS. MEMORY ADDRESS FOR RETURN DATA ARRAY
050135      INTEGER GABSF=USCONT        % FLAG SET IF DRIVER USED BY ABSTR
050135      INTEGER PUSER=ISTAT         % PRIV. USER (DIR INDEX)
050135   PSID
050135
050135   SYMBOL MUSER=1
050135   SYMBOL MINNO=2
050135   SYMBOL MADDR=12
050135   SYMBOL MNOBY=14
050135   SYMBOL GPDTA=15
050135
050135
050135   % INSTRUCTION DEFINITIONS
050135
050135   SYMBOL GPLON=101             % LOG ON USER
050135   SYMBOL GPLOF=105             % LOG OFF USER
050135
050135   %========================================================================
050135   %==   SUBROUTINE TO EXECUTE XMSG MONITOR-CALL FOR TRANSFER ROUTINE    ===
050135   %========================================================================
050135
050135   EGXMS: A=:9AREG;A:="SRSTR"=:"DRIVER";A:=GPXTB:=:L=:"MRETA"
050143          IF XFWRI=T OR XFREA=T THEN
050151            A:=9AREG+DPITPHYS                                    % CONV. TO PHYS ADDR.
050153          ELSE
050154            A:=9AREG
050155          FI; *MON 2XMSG;JMP I (WT11
050157          IF T<0 THEN
050161              IF T+23=0 THEN T:=XMTRE=:CURMTY;T:=17=:CURFU;GO FAR LGOF FI
050171              T-23;CALL XERR
050173          FI
050173          GO MRETA
050174
050174   %========================================================================
050174   %======  SUBROUTINE TO EXECUTE XMSG MONITOR-CALL FOR SRQ ROUTINE  =======
050174   %========================================================================
050174   SCALL: A=:9AREG;A:="SRSTR"=:"DRIVER";A:=SXTBL:=:L=:"SRETA":=9AREG
050203          *MON 2XMSG;JMP I (WT11
050205          IF T<0 THEN
050207               IF T+23=0 GO FAR ENSIN
050212               T-23;CALL XERR
050214          FI
050214          GO SRETA
050215
050215   *)FILL
050221
050221   %========================================================================
050221   %====           SUBROUTINE TO REMOVE USER FROM TABLES              ======
050221   %========================================================================
050221    TRIPLE  GTREG                          % SAVELOCATION FOR TAD REG
050224    INTEGER GXREG                          % SAVELOCATION FOR X REG
050225
050225   TREMO: TAD=:GTREG;X=:GXREG                                           % SAVE REGISTERS
050227          X:=CGPUS;0=:UMESS(X)                                          % CLEAR MESSAGE TABLE ENTRY
050231          A:=X SHZ 1 =:X;A:=0=:D;AD=:UENV(X)                            % CLEAR USER/TERMINAL ENTRY
050237          A:=USCONT -1 =:USCONT                                         % UPDATE USER COUNT
050242          TAD:=GTREG;X:=GXREG;EXIT
050245
050245   %========================================================================
050245   %====    SUBROUTINE TO WAIT FOR INERRUPT AND CHECK FOR TIMEOUT     ======
050245   %========================================================================
050245
050245   GTSUB: T=:9TREG;T:=GPRUN; IF T =0 THEN T:=-1 ELSE T:=TTMR FI
050254          T=:TMR                                                        % START TIMER
050255          T:=L=:"GRETA";A=:9AREG;A:=D=:9DREG;X=:9XREG;CALL ID11         % SAVE REGISTERS AND GIVE UP LEVEL
050264          A:=TMR;IF A=0 THEN                                            % CHECK IF TIMEOUT
050266           0=:GPBFL;0=:GPACT;0=:DINPT
050271           T:=GPRUN; IF T =0 THEN T:=-1 ELSE T:=TTMR FI
050277           T=:TMR;T:=3
050301   RSATO:  CALL TRNSF;CALL GPFER;GO WAIT3;GO TORET                      % CLEAR CONTROLLER
050305   WAIT3:  T=:9TREG;CALL ID11
050307           A:=TMR;IF A=0 THEN 0=:GPBFL;T:=105;CALL GPFER FI             % IF TIMEOUT AFTER DEV. CLEAR ABORT GPIB SYSTEM
050314           T:=9TREG;0=:TMR;GO RSATO
050317   TORET:  T:=-1=:9TREG
050321          FI
050321   GTRET: 0=:TMR;T:=9TREG;A:=9DREG=:D;A:=9AREG;X:=9XREG;GO GRETA
050330
050330   *)FILL
050332   %========================================================================
050332   %======= ROUTINE TO STOP GPIB SYSTEM ====================================
050332   %========================================================================
050332
050332   GPIBH: 0=:GPRUN;GO STCON
050334
050334   %========================================================================
050334   %===     ROUTINE FOR NONFATAL GPIB SYSTEM ERRORS     ====================
050334   %========================================================================
050334
050334   NFERR: X:=L;A:=CURFU;CALL 9ERR(#93);L:=X;EXIT
050342
050342
050342   %========================================================================
050342   %====    ROUTINES FOR FATAL GPIB SYSTEM ERRORS       ====================
050342   %========================================================================
050342
050342   XRERR: T-1;A:=400;T+A;GO GPFER                                       % XROUT ERROR
050346   XSERR: T:=A                                                          % XMSG SUBROUTINE ERROR
050347   XERR:  T-,;A:=300;T+A                                                % XMSG ERROR
050352   GPFER: A:=L-1=:ERADD;A:=GPRUN                                        % GPIB ERROR
050356          IF A = 0 THEN T=:GPRUN;GO STCON FI
050361          A:=GPIBNO;AD SHZ -10;A -60 SHZ 3;A:=:D
050366          A SHZ -10; A -60;A+D;CALL 9ERR(#92)
050373          IF T= 344  GO RSXTB                                           % XMSG NOT RUNNING
050376          IF CGPIM=0 GO STCON
050400          T=:CURFU;A:=32=:D;A:=B+"CURFU";X:=0;T:=XFWRI;CALL FAR EGXMS   % STORE STATUS IN MESSAGE
050410          T:=XFSND BONE XFSEC;X:=CPORT;AD:=CURM;CALL FAR EGXMS          % RETURN MESSAGE
050415   STCON: -3=:TMR                                                       % START TIMER
050417          T:=XFDCT;A:=GPXTB=:L;*MON 2XMSG;JPL I (ID11                   % DISCONNECT FROM XMSG SYSTEM
050424          T:=XFDCT;A:=SXTBL=:L
050427          IF A+1=0 THEN GO RSXTB FI;*MON 2XMSG;  JMP *+1                % IF SRQ PORT OPENED, DISCONNECT FROM XMSG SYSTEM
050434   RSXTB: 0=:GPXTB=:SXTBL=:GPRUN;GO WT11
050440
050440   *)FILL
050451   %===========================================================================
050451   %==================== I N I T   G P I B   C O N T R O L L E R ==============
050451   %===========================================================================
050451   INTEGER SVERS:=102             % MICROPROGRAM VERSION THAT WILL WORK WITH THIS SOFTWARE
050452
050452   GPIBT: A:=GPXTB;IF A><0 GO WT11                                      % IF GPIB ALLREADY STARTED GO WT11
050455          0=:CGPIM=:CGPUS=:SUSFL=:GPRUN=:USCONT                         % RESET CURRENT MESSAGE POINTER, USERNO & SINGLE USER FLAG
050462          "SRENT"=:"SRSTR"                                              % INITIATE POINTER TO SRQ INTERUPT ROUTINE
050464          T:=3;CALL TRNSF;CALL FAR GPFER;GO WAIT1;GO RMTST              % CLEAR GPIB CONTROLLER
050471   WAIT1: CALL FAR GTSUB;IF T+1=0 THEN T:=105;CALL FAR GPFER FI         % WAIT FOR STATUS
050477          GO GPIBT
050500   RMTST: T:=16;CALL TRNSF;CALL FAR GPFER;GO WAIT2;GO ILOF              % RUN MICROPROGRAM TEST
050505   WAIT2: CALL FAR GTSUB;IF T+1=0 THEN T:=105;CALL FAR GPFER FI         % WAIT FOR STATUS
050513          GO RMTST
050514   ILOF:  T=:MVERS;T SHZ -10=:A;A-SVERS
050520          IF A><0 THEN
050521             A:=-1=:SXTBL;A:=T;A SHZ 10 \/ SVERS =:MVERS;GO INXM        % IF WRONG MICROPROGRAM SET SXTBL TO -1
050530          FI
050530          A:="GPMSL"+DPITPHYS=:D; A:=DPITBANK; AD=:CURAD
050535          A:=GPLOF SHZ 10=:GPMSL;A:=1=:CURBC
050542   ILOF1: T:=14;CALL TRNSF;CALL FAR GPFER;GO WT22;GO INXM
050547   WT22:  CALL FAR GTSUB;IF T+1=0 THEN T:=105;CALL FAR GPFER FI
050555          GO ILOF1
050556
050556   *)FILL
050564
050564   %========================================================================
050564   %=============== S E T  U P  X M S G   C O M U N C A T I O N ============
050564   %========================================================================
050564
050564   INXM:  L:=0;T:=XFOPN;*MON 2XMSG;JPL I (WT11                          % OPEN COMMAND PORT
050570          IF T<0 THEN CALL FAR XERR FI                                  % CHECK IF ERROR RETURN
050573          A=:CPORT;A:=L=:GPXTB                                          % SAVE PORT NO. AND XTBLK ADDRESS
050576          T:=XFDBK;A:=DPITBANK; *MON 2XMSG;JPL I (WT11                  % SET BANK TO DPIT
050602          T:=XFOPN;CALL FAR EGXMS;A=:DPORT                              % OPEN DMA  PORT
050605          T:=XFGET;A:=GPDZI;A+6;CALL FAR EGXMS                          % GET DMA BUFFER
050611          A=:DMESA=:X CALL DRXMSG(XDINF);CALL FAR XSERR                 % GET DMA BUFFER ADDRESS
050616          AD=:DBUFA                                                     % SAVE DMA BUFFER ADDRESS
050617          X:=2;A:=GPIBNO;A=:GPPNA(X)                                    % WRITE GPIBNO. IN NAME
050622          A:=14=:D;A:="GPXRM";X:=0;T:=XFWRI;CALL FAR EGXMS              % WRITE TO MESSAGE
050630          T:=XFSND BONE XFROU;X:=CPORT;CALL FAR EGXMS                   % NAME PORT
050634          T:=XFRCV BONE XFWTF;A:=CPORT;CALL FAR EGXMS                   % REC. RESPONS FROM XROUT
050640          AD:=DBUFA;*EXAM                                               % READ XROUT STATUS
050642          IF T><0 THEN  CALL FAR XRERR FI                               % IF T><0 FATAL ERROR
050645          A:=SXTBL;IF A+1=0 GO MVERR                                    % IF MICROPROGRAM VERSION ERROR DONT OPEN SRQ PORT
050650          L:=0;T:=XFOPN;*MON 2XMSG;JPL I (WT11                          % OPEN SRQ CPORT
050654          IF T<0 THEN CALL FAR XERR FI                                  % CHECK IF ERROR RETURN
050657          A=:SQTXA;A:=L=:SXTBL                                          % SAVE PORT NO. AND XTBLK ADDRESS
050662          T:=XFGET;A:=6;CALL FAR SCALL                                  % GET SRQ MESSAGE
050665   MVERR: FOR X:=0 TO 17 DO
050671             0=:UMESS(X)                                                % ZERO USERTABLE ENTRY
050672          OD
050674          A:=0=:D
050676          FOR X:=0 STEP 2 TO 36 DO
050702             AD=:UENV(X)
050703          OD
050705          0=:SRQFL
050706          -1=:GPRUN
050710          GO GGPIC
050711
050711   *)FILL
050722
050722   %========================================================================
050722   %=============== W A I T   F O R   C O M M A N D ===========================
050722   %========================================================================
050722
050722
050722   GGPIC:  T:=SXTBL;IF T+1=0 GO RGPIC                                   % IF MICROPROGRAM VERSION ERROR DONT ENABLE SRQ
050726          T:=6;CALL TRNSF;CALL FAR GPFER;CALL FAR GPFER                 % ENABLE SRQ INTERRUPT IF SRQFL >< 0
050732   RGPIC:  0=:CGPIM;T:=XFRCV BONE XFWTF;A:=CPORT;CALL FAR EGXMS         % WAIT FOR COMMAND
050737          T=:CURMTY;A:=D=:CGPIM                                         % SAVE CURRENT MESSAGE ADDRESS AND TYPE
050742          A:=SRQFL;IF A><0 THEN CALL WT11 FI                            % CHECK IF SRQINTERRUPT IS BEING PROCESSED
050745
050745   %========================================================================
050745   %=============== G E T    C O M M A N D ====================================
050745   %========================================================================
050745
050745   PRCOM: T:=7;CALL TRNSF;CALL FAR GPFER;CALL FAR GPFER                 % DISABLE SRQ INTERRUPT IF SRQFL >< 0
050751          A:=CGPIM;
050752          T:=XFMST;CALL FAR EGXMS                                       % GET MESSAGE STATUS
050754          AD=:CURM                                                      % SAVE MAGIC NUMBER
050755          A:=32=:D;A:=B+"CURFU";X:=0;T:=XFREA;CALL FAR EGXMS            % GET PARAMETER BLOCK INTO DATAFIELD
050764          X:=CGPIM;CALL DRXMSG(XDINF);CALL FAR XSERR                    % GET BUFFER ADDRESS
050770          X:=GPDTA;*RADD SX DD;COPY SA DA ADC;STD CURAD,B               % SAVE BUFFER ADDRESS
050774          0=:DINPT;A:=CURMTY
050776
050776   %===========================================================================
050776   %=============== D E C O D E   C O M M A N D ===============================
050776   %===========================================================================
050776
050776
050776          IF A=XMTRE THEN 17=:CURFU;GO FAR LGOF FI                      % IF RETURNED MESSAGE GO LGOF
051004          IF A=XMROU GO FAR LOGON                                       % IF ROUTED MESSAGE GO LOGON
051007          T:=SXTBL;IF T+1 = 0 THEN                                      % CHECK IF MICROPROGRAM VERSION ERROR
051013          T:=110;GO FAR ERET FI                                        % RETURN ERROR CODE
051015          A:=CURFU;IF A=3 GO FAR CLDEV                                  % CHECK IF CLEAR DEVICE
051021          IF A<=1 GO FAR DMAT                                           % CHECK IF DMA TRANSFER
051024          IF A=16 GO FAR MICTE                                          % CHECK IF RUN MICRO TEST
051027          IF A=17 GO FAR LGOF                                           % CHECK IF LOGOFF
051032          IF A=24 GO FAR SSUSE                                          % CHECK IF SET SINGLE USER
051035          IF A=25 GO FAR RSUSE                                          % CHECK IF RESET SINGLE USER
051040          IF A=26 GO FAR RETUR                                          % CHECK IF WHO-IS-ON COMMAND
051043          IF A=27 GO FAR GPTRA                                          % CHECK IF TRANSF BETWEEN DEVICES
051046          T:=CURFU;GO GDRIV
051050
051050   *)FILL
051070
051070   %========================================================================
051070   %=============== C A L L   D R I V E R =====================================
051070   %========================================================================
051070
051070   GDRIV: CALL TRNSF;GO ERROR;GO BUSY;GO FINISH                         % CALL DRIVER
051074   GPBUS: CALL FAR GTSUB
051075          IF T+1=0 THEN T:=105;0=:CURBC;GO ERET FI
051103          T:=9TREG;GO GDRIV
051105   GPFIN: A:=CURFU;IF A-11=0 THEN  T=:GPISA(0) FI
051112          T:=0
051113
051113
051113   %========================================================================
051113   %=============== R E T U R N   S T A T U S   T O   U S E R =================
051113   %========================================================================
051113
051113   RETUR: A:=CURFU;IF A-17=0 GO GGPIC                                   % IF LOGOF WAIT FOR NEXT COMMAND
051116          IF A-1=0 OR A-1=0 THEN                                        % IF LOGON STORE MESSAGEADDRESS IN USERTABLE
051122             X:=CGPUS;A:=CGPIM=:UMESS(X)
051125          FI
051125          A:=CURFU;X:=DINPT;IF A=0 AND X BIT 17 THEN                    % CHECK IF DMA INPUT AND BYTCONT > GPUZI
051132             T:=XFSCM;A:=DPORT=:D;A:=DMESA;CALL FAR EGXMS               % SET DMA BUFFER AS CURRENT MESSAGE
051137             T:=XFWHD;A:=CURBC=:D;A:=0;X:=0;CALL FAR EGXMS              % WRITE STATUS IN DMABUFFER
051145             X:=DMESA;A:=-1;CALL DRXMSG(XDSBP);CALL FAR XSERR           % SET MESSAGE SIZE TO ZERO
051152             X:=DMESA;A:=CURBC+6;CALL DRXMSG(XDSBP);CALL FAR XSERR      % SET CORRECT SIZE OF BUFFER
051160             T:=XFSND BONE XFSEC;X:=DPORT;AD:=CURM;CALL FAR EGXMS       % SEND DMA BUFFER TO USER
051165             T:=XFRCV BONE XFWTF;A:=DPORT;CALL FAR EGXMS                % WAIT FOR DMA BUFFER
051171             A:=T;IF A=XMTRE THEN 17=:CURFU;GO FAR LGOF FI              % IF RETURNED MESSAGE GO LGOF
051200             T:=XFSCM;A:=CPORT=:D;A:=CGPIM;CALL FAR EGXMS               % SET USERS MESSAGE AS CURRENT MESSAGE
051205             0=:DINPT;T:=0
051207          FI
051207
051207   %========================================================================
051207   %============= R E T U R N   S T A T U S   T O   U S E R  ===============
051207   %========================================================================
051207
051207
051207   ERET:  A:=CURFU;IF A-17=0 THEN                                       % IF LOGOF WRITE ERROR MESS AND WAIT FOR NEXT COMMAND
051212             CALL FAR NFERR;GO FAR GGPIC                                % WRITE ERROR MESSAGE
051214          FI
051214          A:=CURFU;X:=32; IF A-26=0 THEN                                % IF WHO IS ON COMMAND, ALSO SEND TERMNO. ARRAY
051220          X:=100=:CURBC;X:=132
051223          FI
051223          T=:CURFU;D:=X;A:=B+"CURFU";X:=0;T:=XFWRI;CALL FAR EGXMS       % WRITE STATUS IN MESSAGE
051232          T:=DINPT;IF T><0 THEN
051235             X:=CGPIM;A:=-1;CALL DRXMSG(XDSBP);CALL FAR XSERR           % SET MESSAGE SIZE TO ZERO
051242             X:=CGPIM;A:=CURBC+32;CALL DRXMSG(XDSBP);CALL FAR XSERR     % SET CORRECT SIZE OF BUFFER
051250          FI
051250          T:=XFSND BONE XFSEC;X:=CPORT;AD:=CURM;CALL FAR EGXMS          % RETURN MESSAGE
051255          GO FAR GGPIC
051256
051256   *)FILL
051266
051266   %===========================================================================
051266   %=============== R U N   M I C R O P R O G R M    T E S T ==================
051266   %===========================================================================
051266
051266   MICTE: A:=CGPUS;IF A><0 THEN T:=102;GO ERET FI                      % CHECK IF PRIVILIDGED
051272          A:=USCONT;IF A > 1 THEN T:=112;GO ERET FI
051300          T:=CURFU;GO FAR GDRIV
051302
051302   %========================================================================
051302   %====== T R A N S F E R   D A T A   B E T W E E N   D E V I C E S =======
051302   %========================================================================
051302
051302   GPTRA: AD:=DBUFA;D:=:A;A+3;*COPY SD DD ADC;SWAP SA DD;STD CURAD,B    % STORE DMA BUFFER ADDRESS IN DATAFIELD
051310          T:=0;GO FAR GDRIV
051312
051312   %========================================================================
051312   %=============== C L E A R   C O N T R O L L E R ========================
051312   %========================================================================
051312
051312   CLDEV: A:=CGPUS;IF A><0 THEN T:=102;GO ERET FI                      % CHECK IF PRIVILIDGED
051316          T:=CURFU;GO FAR GDRIV
051320
051320   %========================================================================
051320   %=============== S E T   S I N G L E   U S E R   M O D E ================
051320   %========================================================================
051320
051320   SSUSE: A:=USCONT; IF A>1 THEN T:=112;GO ERET FI;                    % CHECK IF OTHER USERS IS ON
051326          T:=1=:SUSFL:=0; GO FAR RETUR
051332
051332   %========================================================================
051332   %=============== R E S E T   S I N G L E   U S E R   M O D E ============
051332   %========================================================================
051332
051332   RSUSE: 0=:SUSFL=:T; GO FAR RETUR
051335
051335   %========================================================================
051335   %=============== D M A   T R A N S F E R ================================
051335   %========================================================================
051335
051335   DMAT:  A:=CURBC;T:=GPUZI;IF A<=T THEN T:=CURFU;GO FAR GDRIV FI       % CHECK IF BYTECOUNT > GPUZI
051343          A:=CURBC;T:=GPDZI;IF A>T THEN T:=107;GO ERET FI              % CHECK IF BYTECOUNT > GPDZI
051351          AD:=DBUFA;D:=:A;A+3;*COPY SD DD ADC;SWAP SA DD;STD CURAD,B    % STORE DMA BUFFER ADDRESS IN DATAFIELD
051357          A:=CURFU;IF A=1 GO UTDMA                                      % CHECK IF OUTPUT
051363          A:=DINPT BONE 17 =:DINPT;T:=CURFU;GO FAR GDRIV                % SET BIT 15 IN DINPT TO FLAG DMA IN AND BYTCONT > GPUZI
051370   UTDMA: T:=XFSCM;A:=DPORT=:D;A:=DMESA;CALL FAR EGXMS                  % SET DMA BUFFER AS CURRENT MESSAGE
051375          T:=XFSND BONE XFSEC;AD:=CURM;X:=DPORT;CALL FAR EGXMS          % SEND DMA BUFFER TO USER
051402          T:=XFRCV BONE XFWTF;A:=DPORT;CALL FAR EGXMS                   % WAIT FOR DMA BUFFER
051406          A:=T;IF A=XMTRE THEN 17=:CURFU;GO FAR LGOF FI                 % IF RETURNED MESSAGE GO LGOF
051415          T:=XFSCM;A:=CPORT=:D;A:=CGPIM;CALL FAR EGXMS                  % SET COMMAND BUFFER AS CURRENT MESSAGE
051422          T:=CURFU;GO FAR GDRIV
051424
051424
051424   *)FILL
051430
051430   %========================================================================
051430   %========== E R R O R   R E T U R N   F R O M   D R I V E R =============
051430   %========================================================================
051430
051430   GPERR: 0=:TMR
051431          A:=CURMTY;IF A-XMROU = 0 THEN
051434             CALL FAR TREMO                                             % IF ERROR ON LOG ON, CLEAR TABLES
051435          FI
051435          GO FAR ERET
051436   %========================================================================
051436   %========== L O G   O N   N E W   U S E R ===============================
051436   %========================================================================
051436
051436   LOGON: T:=SXTBL;IF T+1=0 THEN
051442          T:=110;GO FAR ERET                                           % IF MICROPROGRAM VERSION ERROR RETURN ERRCODE
051444          FI
051444          A:=CURFU SHZ -10
051446          IF A=20 GO PRIUS
051451          IF A><21 THEN T:=100;GO FAR ERET FI
051456          FOR X:=1 TO 17 DO
051462          A:=UMESS(X);IF A=0 GO UFOUN OD
051466   NOUSP: T:=103;GO FAR ERET                                           % NO USER SPACE
051470
051470   PRIUS: IF UMESS(0) >< 0 THEN T:=104;GO FAR ERET FI
051475          IF  PUSER >< -1 AND A >< GPISA(5) THEN                      % OK FOR ALL OR PRIV. USER ?
051505            A:=GPISA(4)-RTSTA=:D:=0; T:=5RTSI; * RDIV ST              % NO, TEST FOR RT PROG
051514            IF  GPISA(4) >> RTEND OR A << RTSTA OR D >< 0 THEN
051526              T:=102;GO FAR ERET                                      % NOT LEGAL RT PROG
051530            FI
051530          FI
051530   UFOUN: A:=SUSFL;IF A><0 THEN
051532             A:=USCONT; IF A><0 THEN
051534               T:=111;GO FAR ERET
051536             FI
051536          FI
051536          A:=CGPIM;T:=XFREL;CALL FAR EGXMS                              % RELEASE USER MESSAGE
051541          A:=GPUZI+32;T:=XFGET BONE XFWTF;CALL FAR EGXMS                % GET NEW USER MESSAGE WITH CORRECT SIZE
051546          A=:CGPIM=:UMESS(X)                                            % STORE MESSAGE IDENT IN USER ARRAY
051550          D:=A;A:=CPORT;A:=:D;T:=XFSCM;CALL FAR EGXMS                   % SET CURRENT MESSAGE
051555          X=:CGPUS
051556          T:=CGPUS SHZ 1;GPISA(4)=:D;GPISA(5);AD=:UENV(T)               % STORE TERMINAL NO. / RT DESC. ADDRESS
051567          A:=GPDZI=:GPISA(0);A:=GPUZI=:GPISA(1)                         % STORE USERNO. AND BUFFER SIZES IN MESSAGE
051575          A:=MVERS=:GPISA(2);A:=DEVFL=:GPISA(3)                         % STORE MICROPROGRAM VERSION AND DEVICEFLAG IN MESSAGE
051603          A:=PUSER=:GPISA(4)                                            % STORE PRIV USER
051606          A:=CGPUS SHZ 1=:X;AD:=CURM=:MNARR(X)                          % STORE USERS MAGIC NUMBER
051613          A:=USCONT +1 =:USCONT
051616          A:=GPLON SHZ 10;A=:GPSCR;A:="GPSCR"+DPITPHYS=:D;A:=DPITBANK
051625          AD=:CURAD;A:=1=:CURBC;T:=14;GO FAR GDRIV
051632   *)FILL
051641   %========================================================================
051641   %========== L O G   O F F   U S E R =====================================
051641   %========================================================================
051641
051641   LGOF:  A:=CGPIM=:D;FOR X:=0 TO 17 DO
051647          A:=UMESS(X);IF A=D GO ULOF OD
051654          A:=D;T:=XFREL;CALL FAR EGXMS;GO FAR GGPIC
051660   ULOF:  X=:CGPUS;CALL FAR TREMO;T:=XFREL;CALL FAR EGXMS
051664          A:=GPLOF SHZ 10;A=:GPSCR;A:="GPSCR"+DPITPHYS=:D;A:=DPITBANK;AD=:CURAD
051674          A:=1=:CURBC;T:=14;GO FAR GDRIV
051700   *)FILL
051705   %========================================================================
051705   %========== S R Q / D E V   I N T E R R U P T   E N T R Y ===============
051705   %========================================================================
051705
051705   SRGET: T:=XFGET;A:=6;CALL FAR SCALL                                                % GET NEW MESSAGE
051710   SRENT: 0=:CGPUS=:CGPIM
051712   SRCDR: T:=10=:CURFU=:SRQFL
051715          CALL TRNSF;GO SRERR;GO WAIT4;GO PSREC
051721   WAIT4: CALL FAR GTSUB;IF T+1=0 THEN T:=105;GO SRERR FI
051727          GO SRCDR
051730   PSREC: T=:CURFU;IF T+1=0 GO ENSIN                                    % CHECK IF NON EKSPECTED SRQ-INTERRRUPT
051734          A:=CURFU;AD SHZ -6;A SHZ 1;A BONE "0";A BONE 11;AD SHZ 6      % UNPAC POLLSTATUS AND SET BIT 6 AND 17
051742          X:=A;A:=GPIBNO;AD SHZ -10;A -60 SHZ 3;A:=:D
051750          A SHZ -10; A -60;D+A;A:=X
051754          T:=XFWHD;X:=0;CALL FAR SCALL
051757          A:=CURFU SHZ -14;A SHZ 1=:X;AD:=MNARR(X)                      % GET USERS MAGIC NUMBER
051764          X:=SQTXA;T:=XFSND;CALL FAR SCALL                              % SEND MESSAGE TO USER
051767          T:=XFGET;A:=6;CALL FAR SCALL;T:="SRENT"=:"SRSTR"                                                % GET NEW MESSAGE
051774   ENSIN: 0=:SRQFL;T:=CGPIM;IF T><0 GO FAR PRCOM                        % CHECK IF NEW COMMAND IS RECEIVED
052000          T:=6;CALL TRNSF;CALL FAR GPFER;CALL FAR GPFER;CALL ID11
052005          GO SRSTR
052006   SXERR: T-,;A:=300;T+A;A:="SRGET"=:"SRSTR"                            % XMSG ERROR
052013   SRERR: CALL FAR NFERR;GO ENSIN                                                     % WRITE ERRORMESSAGE
052015
052015   *)FILL
052026   %============================ GPIBD ===========================================
052026   %
052026   %       DRIVER FOR GPIB BUS CONTROLLER
052026   %       CALLING SEQUENCE :
052026   %                          JPL I (DGPIB
052026   %                          JMP ERROR    % ERROR RETURN
052026   %                          JMP BUSY     % BUSY RETURN
052026   %                          JMP FINISH   % OPERATION FINISHED
052026   %
052026   %==============================================================================
052026   % PARAMETERS:
052026   %             T-REGISTER  : FUNCTION CODE
052026   %             B-REGISTER  : DATA FIELD
052026   %             X-REGISTER  : NO. OF BYTES ( FUNC 14)
052026   % RETURN :
052026   %             T-REGISTER  : STATUS
052026   %=============================================================================
052026   % FUNCTION CODES:
052026   %                     00 : DMA INPUT
052026   %                     01 : DMA OUTPUT
052026   %                     02 : READ STATUS
052026   %                     03 : CLEAR DEVICE
052026   %                     04 : READ PIO
052026   %                     05 : WRITE PIO
052026   %                     06 : ENABLE SRQ INTERRUPT
052026   %                     07 : DISABLE ALL INTERRUPTS
052026   %                     10 : SERIAL POLL
052026   %                     11 : PARALLELL POLL
052026   %                     12 : READ SYSTEM DEVICE LIST
052026   %                     13 : READ USER DEVICE LIST
052026   %                     14 : SEND CONTROL STRING WITHOUT DEVICE LIST
052026   %                     15 : SEND COMMAND BYTE WITH DEVICE LIST
052026   %                     16 : RUN MICROPROGRAM CONTROLLER TEST
052026   %=========================================================================
052026
052026   % REGISTER DEFINITION:
052026
052026   % RDMEM=0
052026   SYMBOL LOMEM=1
052026   SYMBOL DRDAT= 2
052026   SYMBOL DLDAT= 3
052026   SYMBOL RSTA=4
052026   SYMBOL LCON=5
052026   SYMBOL LWORC=7
052026
052026   %=========================================================================
052026
052026   % GPIB CONTROLLER FUNCTION CODES
052026
052026   SYMBOL DMAUT=142
052026   SYMBOL EXSP= 102
052026   SYMBOL PIOUT=144
052026   SYMBOL PIOIN=145
052026   SYMBOL LSYSD=106
052026   SYMBOL LUSDV=104
052026   SYMBOL MTCOD=167
052026
052026   @MAC

)9SCLC
052026  %==========================================================================
052026
052026  GPIBD, STF   TSAV
052027         STX   XSAV
052030         COPY  SL DX
052031         STX    LSAV
052032         COPY  ST DA
052033         AAA   -3
052034         JAZ   CLRDV           % CHECK IF FUNCTION=CLEAR DEVICE
052035         LDT   HDEV,B
052036         AAT   RSTA
052037         IOXT
052040         STA   SSTAT
052041         LDA   TSAV
052042         AAA   -2              % CHECK IF FUNCION = READ STATUS
052043         JAZ   FINEX
052044         LDA   SSTAT
052045         BSKP  ZRO 40 DA
052046         JMP   ERREX
052047  %      BSKP  ONE 20 DA
052047         JMP   I (IFRDY
052050
052050         % BUSY EXIT
052050
052050  UDBEX, SAA   1
052051         STA   GPBFL,B
052052         LDA   LSAV
052053         COPY  SA DL
052054         LDF   TSAV
052055         LDX   XSAV
052056         EXIT  AD1
052057
052057         % CLEAR DEVICE WITHOUT TEST
052057
052057  CLRDV, LDA   GPBFL,B
052060         JAF   RRES
052061         LDT   HDEV,B
052062         AAT   LCON
052063         SAA   20
052064         IOXT
052065         SAA   3
052066         IOXT
052067         JMP   UDBEX
052070  RRES,  LDT   HDEV,B
052071         AAT   DRDAT
052072         IOXT
052073         COPY  SA DT
052074         SUB   STMAS
052075         JAF   CEREX
052076
052076         % OPERATION FINISHED
052076
052076  FINEX, LDA   LSAV
052077         COPY  SA DL
052100         LDD   ASAV
052101         LDT   SSTAT
052102         STZ   GPBFL,B
052103         STZ   GPACT,B
052104         COPY  SL DL AD1
052105         EXIT  AD1
052106
052106         % ILLEGAL FUNCTION CODE OR
052106         % CORE ADDRESS REGISTER ERROR
052106
052106  ILFUC, SAT   100
052107         JMP   *+2
052110  CAERR, SAT   101
052111         LDA   LSAV
052112         COPY  SA DL
052113         STZ   GPBFL,B
052114         STZ   GPACT,B
052115         EXIT
052116
052116  )FILL
052117         % ERROR EXIT
052117
052117  ERREX, LDT   HDEV,B
052120         AAT   DRDAT
052121         IOXT
052122         AND   STMAS        % REMOVE USER NO.
052123         COPY  SA DT
052124  CEREX, LDA   LSAV
052125         COPY  SA DL
052126         LDD   ASAV
052127         LDX   XSAV
052130         STZ   GPBFL,B
052131         STZ   GPACT,B
052132         STZ   DINPT,B
052133         EXIT
052134
052134  )FILL
052134
052134         % INTERFACE READY
052134
052134  IFRDY, LDA   TSAV
052135         COPY  SA DT
052136         AAA   -17
052137         JAP   ILFUC
052140         RADD  ST DP
052141         JMP      DMA             % OPERATION IS DMA INPUT
052142         JMP      DMA             % OPERATION IS DMA OUTPUT
052143         JMP   I (FINEX           % OPERATION IS READ STATUS
052144         JMP   I (CLRDV           % OPERATION IS CLEAR DEVICE (THIS BRANCH SHOULD NEVER BE USED)
052145         JMP   I (RPIO            % OPERATION IS READ PIO
052146         JMP   I (WPIO            % OPERATION IS WRITE PIO
052147         JMP   I (SRQEN           % OPERATION IS ENABLE SRQ INTERRUPT
052150         JMP   I (DISIN           % OPERATION IS DISABLE ALL INTERRUPTS
052151         JMP   I (POLL            % OPERATION IS SERIAL POLL
052152         JMP   I (POLL            % OPERATION IS PARALLEL POLL
052153         JMP   I (RDEVL           % OPERATION IS READ SYSTEM DEVICE LIST
052154         JMP   I (RDEVL           % OPERATION IS READ USER DEVICE LIST
052155         JMP   I (WCOMD           % OPERATION IS SEND CONTROL STRING (WITHOUT DEVICE LIST)
052156         JMP   I (WCOTD           % OPERATION IS SEND CONTROL STRING (WITH DEVICE LIST)
052157         JMP   I (MTST            % OPERATION IS RUN MICROPROGRAN TEST
052160
052160  )FILL
052173  TSAV,  0
052174  ASAV,  0
052175  DSAV,  0
052176  BSAV,  0
052177  XSAV,  0
052200  LSAV,  0
052201  SSTAT, 0
052202  STMAS, 377
052203  PADDR, 0;0
052205
052205
052205         % DMA OPERATION
052205
052205  DMA,   LDA   GPBFL,B
052206         JAZ   INDMA
052207         LDA   GPACT,B
052210         JAZ   DMACT
052211         LDT   HDEV,B
052212         IOXT
052213         LDT   SSTAT
052214         LDX   DSAV
052215         RSUB  SX DA
052216         SHA   ZIN 1
052217         BSKP  ZRO 130 DT
052220         RDCR  DA
052221         STA   CURBC,B
052222         LDA   TSAV
052223         SKP   IF DA UEQ 0
052224         TRR   CCLR         % CLEAR CACHE
052225         JMP   I (FINEX
052226
052226         % ENABLE SRQ INTERRUPT
052226
052226  SRQEN, SAA   0
052227         BSET  ONE 60 DA
052230         LDT   HDEV,B
052231         AAT   LCON
052232         IOXT
052233         JMP   I (FINEX
052234
052234         % DISABLE INTERRUPTS
052234
052234  DISIN, SAA   0
052235         LDT   HDEV,B
052236         AAT   LCON
052237         IOXT
052240         JMP   I (FINEX
052241
052241         % ACTIVATE DMA TRANSFER
052241
052241  DMACT, LDD   CURAD,B
052242         LDT   HDEV,B
052243         AAT   LOMEM
052244         IOXT
052245         COPY  SD DA
052246         IOXT
052247         LDA   CURBC,B
052250         SHA   ZIN SHR 1
052251         BSKP  ZRO SSM
052252         AAA   1
052253         LDT   HDEV,B
052254         AAT   LWORC
052255         IOXT
052256         SAA   7
052257         LDT   TSAV
052260         BSKP  ONE 00 DT
052261         BSET  ONE 130 DA
052262         LDT   HDEV,B
052263         AAT   LCON
052264         IOXT
052265  ACTEX, SAA   1
052266         STA   GPACT,B
052267         JMP   I (UDBEX
052270
052270         % INIT DMA TRANSFER
052270
052270  INDMA, JPL   I (SUSER
052271         SAA   DMAUT
052272         LDX   TSAV
052273         BSKP  ONE 00 DX
052274         AAA   -1
052275         IOXT
052276         LDA   DINPT,B
052277         BSET  ONE 00 DA
052300         BSKP  ONE 00 DX
052301         STA   DINPT,B
052302         JPL   I (SNOBY
052303         JPL   I (SINST
052304         JMP   I (ENINT
052305
052305         % PROGRAMMED I/O WRITE
052305
052305  WPIO,  LDA   GPBFL,B
052306         SKP   IF DA EQL 0
052307         JMP   I (FINEX
052310         JPL   I (SUSER
052311         SAA   PIOUT
052312         IOXT
052313         JPL   I (SNOBY
052314         JPL   I (SINST
052315         JPL   WGPID
052316         JMP   I (ENINT
052317
052317         % WRITE DATA
052317
052317  WGPID, LDD   CURAD,B
052320         STD   PADDR
052321         LDX   CURBC,B
052322  WNXTW, LDD   PADDR
052323         EXAM
052324         RINC  DD
052325         COPY  SA DA ADC
052326         STD   PADDR
052327         RCLR  DA
052330         COPY  ST DD
052331         SAD   ZIN 10
052332         LDT   HDEV,B
052333         AAT   DLDAT
052334         IOXT
052335         RDCR  DX
052336         JXZ   NODAT
052337         RCLR  DA
052340         SAD   ZIN 10
052341         IOXT
052342         RDCR  DX
052343         SKP   IF DX EQL 0
052344         JMP   WNXTW
052345  NODAT, EXIT
052346
052346  )FILL
052354
052354         % PROGRAMMED I/O READ
052354
052354  RPIO,  LDA   GPBFL,B
052355         JAZ   RPINI
052356         LDA   FIRST,B
052357         JAZ   RGPDA
052360
052360         % READ BYTECOUNT FROM INTERFACE AND INIT WORCOUNT AND DATAPOINTER
052360
052360  RBCON, LDT   HDEV,B
052361         AAT   DRDAT
052362         IOXT
052363         STA   CURBC,B
052364         LDT   GPUZI,B
052365         SKP   IF DT MLST SA
052366         JMP   BCOK
052367         SAT   106
052370         JMP   I (CEREX
052371  BCOK,  SHA   ZIN SHR 1
052372         BSKP  ZRO SSM
052373         AAA   1
052374         STA   PIOWC,B
052375         SKP   IF DA UEQ 0
052376         JMP   I (FINEX
052377         STZ   FIRST,B
052400         STZ   PIODP,B
052401         SAA   1
052402         STA   DINPT,B
052403         SAA   3
052404         LDT   HDEV,B
052405         AAT   LCON
052406         IOXT
052407         JMP   I (UDBEX
052410
052410         % INIT PIO TRANSFER
052410
052410  RPINI, JPL   SUSER
052411         SAA   PIOIN
052412         STA   FIRST,B
052413         IOXT
052414         JPL   SNOBY
052415         JPL   SINST
052416         JMP   ENINT
052417
052417
052417  SUSER, LDA   CGPUS,B
052420         LDT   HDEV,B
052421         AAT   DLDAT
052422         IOXT
052423         EXIT
052424
052424
052424  SNOBY, LDA   CURBC,B
052425         IOXT
052426         SHA   ZIN SHR 10
052427         IOXT
052430         EXIT
052431
052431  ICONT, 0
052432
052432  SINST, SAX   0
052433         SAA   -10
052434         STA   ICONT
052435  NXINS, LDA   GPISA,B,X
052436         SAD   ZIN SHR 10
052437         IOXT
052440         BSKP  ZRO 70 DA
052441         JMP   LINS
052442         SAD   ZIN 10
052443         IOXT
052444         BSKP  ZRO 70 DA
052445         JMP   LINS2
052446         AAX   1
052447         MIN   ICONT
052450         JMP   NXINS
052451         JMP   IERR
052452  LINS,  BSKP  ONE 60 DA
052453         JMP   IFI
052454         SAD   ZIN 10
052455         IOXT
052456         JMP   IFI
052457  LINS2, BSKP ONE 60 DA
052460         JMP   IFI
052461         AAX   1
052462         LDA   GPISA,B,X
052463         SAD   ZIN SHR 10
052464         IOXT
052465  IFI,   EXIT
052466  IERR,  SAA   70
052467         BSET  ONE 70 DA
052470         IOXT
052471         EXIT
052472
052472
052472  ENINT, SAA   3
052473         BSET  ONE 100 DA
052474         LDT   HDEV,B
052475         AAT   LCON
052476         IOXT
052477         JMP   I (UDBEX
052500
052500  )FILL
052503
052503         % READ DATA
052503
052503  RGPDA,  LDT   HDEV,B
052504         AAT   DRDAT
052505         IOXT
052506         COPY  SA DT
052507         LDD   CURAD,B
052510         LDX   PIODP,B
052511         RADD  SX DD
052512         COPY  SA DA ADC
052513         DEPO
052514         AAX   1
052515         STX   PIODP,B
052516         LDA   PIOWC,B
052517         AAA   -1
052520         STA   PIOWC,B
052521         JAZ   FINI
052522         SAA   3
052523         LDT   HDEV,B
052524         AAT   LCON
052525         IOXT
052526         JMP   I (UDBEX
052527  FINI,  JMP   I (FINEX
052530
052530  )FILL
052532
052532         % SEND COMMAND BYTES WITHOUT DEVICELIST
052532
052532  WCOMD, LDA   GPBFL,B
052533         SKP   IF DA EQL 0
052534         JMP   I (FINEX
052535         JPL   SUSER
052536         JPL   I (WGPID
052537         JMP   WINT
052540
052540         % SEND COMMAND WITH DEVICELIST
052540
052540  WCOTD, LDA   GPBFL,B
052541         SKP   IF DA EQL 0
052542         JMP   I (FINEX
052543         JPL   SUSER
052544         LDD   CURAD,B
052545         COPY  ST DX
052546         EXAM
052547         COPY  ST DA
052550         COPY  SX DT
052551         IOXT
052552         JPL   SINST
052553  WINT,  SAA   2
052554         BSET  ONE 100 DA
052555         LDT   HDEV,B
052556         AAT   LCON
052557         IOXT
052560         JMP   I (UDBEX
052561
052561
052561
052561         % READ POLLSTATUS
052561
052561  POLL,  LDA   GPBFL,B
052562         JAZ   POINI
052563         LDT   HDEV,B
052564         AAT   DRDAT
052565         IOXT
052566         1BANK; STA I (SSTAT; 2BANK
052571         JMP   I (FINEX
052572
052572         % INIT SERIAL OR PARALLEL POLL
052572
052572  POINI, JPL   I (SUSER
052573         SAA   EXSP
052574         1BANK; LDT I (TSAV; 2BANK
052577         BSKP  ZRO 00 DT
052600         AAA   1
052601         LDT   HDEV,B
052602         AAT   DLDAT
052603         IOXT
052604         SAA   3
052605         LDT   HDEV,B
052606         AAT   LCON
052607         IOXT
052610         JMP   I (UDBEX
052611
052611         % READ SYS/USER DEVICELIST
052611
052611  RDEVL, LDA   GPBFL,B
052612         JAZ   RDINI
052613         LDA   FIRST,B
052614         JAF   BCON
052615         JMP   I (RGPDA
052616  BCON,  JMP   I (RBCON
052617  RDINI, LDA   CGPUS,B
052620         LDT   HDEV,B
052621         AAT   DLDAT
052622         IOXT
052623         SAA   LSYSD
052624         1BANK; LDX I (TSAV; 2BANK
052627         BSKP  ZRO 00 DX
052630         SAA   LUSDV
052631         IOXT
052632         SAA   3
052633         STA   FIRST,B
052634         LDT   HDEV,B
052635         AAT   LCON
052636         IOXT
052637         JMP   I (UDBEX
052640
052640  MTST,  LDA   GPBFL,B
052641         JAF   RDCDE
052642         LDT   HDEV,B
052643         AAT   DLDAT
052644         SAA   MTCOD
052645         IOXT
052646         AAT   -DLDAT+LCON
052647         SAA   3
052650         IOXT
052651         JMP   I (UDBEX
052652  RDCDE, LDT   HDEV,B
052653         AAT   DRDAT
052654         IOXT
052655         1BANK; STA I (SSTAT; 2BANK
052660         SHA   ZIN 10
052661         SKP   IF DA EQL 0
052662         JMP   I (FINEX
052663         JMP   I (ERREX
052664  )FILL
052675
052675
052675  )PCL GPIBD
052675  % )KILL RDMEM LOMEM DRDAT DLDAT RSTA LCON LWORC DMAUT EXSP PIOUT
052675  %)KILL LOMEM DRDAT DLDAT RSTA LCON LWORC DMAUT EXSP PIOUT
052675  %)KILL PIOIN LSYSD LUSDV MTCOD UDBEX CLRDV RRES FINEX ILFUC CAERR
052675  %)KILL ERREX CEREX IFRDY DMA SRQEN DISIN DMACT ACTEX INDMA WPIO
052675  %)KILL WGPID WNXTW NODAT RPIO RBCON BCOK RPINI SUSER SNOBY SINST
052675  %)KILL NXINS LINS LINS2 IFI IERR ENINT RGPDA FINI WCOMD WCOTD WINT
052675  %)KILL POLL POINI RDEVL BCON RDINI MTST RDCDE TSAV ASAV DSAV BSAV
052675  %)KILL XSAV LSAV SSTAT ICONT STMAS PADDR
052675  )9RCLC
)9SLPL
052675
052675   %========================================================================
052675   %===============  ROUTINE TO PERFORM TRANSFER TO GPIB DRIVER  ==============
052675   %===============  ACKTIVATED FROM ABSTRANS                    ==============
052675   % PARAMETER LIST:   PAR, IFUNC (abfun) % DUMMY
052675   %                        DMEM  (MEMAD) % PHYS. MEMORY ADDRESS  FOR DMA
052675   %                        DINSI (ABPA2) % PHYS. MEMORY ADDRESS TO DATA ARRAY
052675   %                        DINSO (ABPA3) % PHYS. MEMORY ADDRESS FOR RETURN DATA ARRAY
052675   %========================================================================
052675   INTEGER LOOP
052676   GPITR: IF GPRUN = -1 GO GPAE1                     % XMSG DRIVER RUNNING
052702          1=:GABSF                                   % SET ABSTR FLAG
052704
052704          T:=X.ABP21; X:=X.ABP22; "CURFU"=:D
052710          -15=:LOOP; FOR LOOP DO
052712            *LDATX; SWAP SD DX; STA ,B,X; SWAP SD DX % MOVE DATA ARRY TO DATAFIELD
052716            X+1;D+1
052720          OD
052722          AD:=MEMAD=:CURAD                           % GET DMEM
052724
052724          IF CURFU = 6 OR = 7 OR = 10 OR > 22 GO GPAE1
052741   GPATR: T:=CURFU; X:=CURBC; 0=:HSTAT; AD:=CURAD
052745          CALL TRNSF; GO GPAER; GO GPABY; 0=:CURFU; GO GPAFI;
052752   GPAER: T=:CURFU; GO GPAFI
052754
052754   GPABY: TTMR=:TMR; CALL ID11; A:=TMR; 0=:TMR
052761          IF A >< 0 GO GPATR                      % RESTART DRIVER IF NOT TIME OUT
052762          0=:GPACT=:GPBFL; 105=:CURFU             % SET RETURN STATUS TO TIMEOUT
052766   GPAS:  T:=3; CALL TRNSF;                       % CLEAR CONTROLLER
052770          GO GPAFI; GO GPAT; GO GPAFI             % SHOULD NEVER ERROR RETURN HERE
052773   GPAT:  TTMR=:TMR; CALL ID11; A:=TMR; 0=:TMR
053000          IF A >< 0 GO GPAS                       % CALL DRIVER AGAIN TO GET STATUS
053001
053001   GPAFI: IF RTRES >< 0 THEN
053003            AD:=ABPA3; A=:T;D=:X; "CURFU"=:D           % GET ADDRESS TO DATA ARRAY
053010            -15=:LOOP; FOR LOOP DO                     % RETURN DATA ARRAY
053012              *SWAP SD DX; LDA ,B,X; SWAP SD DX; STATX;
053016              X+1; D+1;
053020            OD
053022            GO L1
053023          ELSE
053024            GO L2
053025          FI
053025   GPAE1: -1=:HSTAT
053027   L1:    0=:GABSF;  CALL RTACT
053031   L2:    CALL ID11; GO GPATR
053033   RBUS
053036   *"
"053036   *"8F16+8DM01+8DM02+8DM03+8DM04+8DM05+8DM06+8DM07+8DM08+8DM09+8DM10
"053036
053036   @DEV 1
053036   @DEV (S-S-L)IP-P2-DISK-LOGG:NPL
053036   *"8DILG
"053036
053036   %============================================================================
053036   %            W R D I L O G
053036   %
053036   % SUBROUTINE TO START THE RT-PROGRAM FOR WRITING TO THE DISC LOG FILE
053036   %
053036   % ALL REGISTERS EXCEPT THE B-REGISTER ARE USED IN THIS ROUTINE
053036   %
053036   SUBR WRDILOG
053036   WRDILOG:
053036          IF "DFDIL".2DIBADDR+4000=X.DILBPNT THEN             % BUFFER #2 IS FULL
053044             X.DILGFLAG BONE 2DILBFULL=:X.DILGFLAG            % MARK BUFFER #2 TO WRITE
053047             X.2DIBADDR=:X.DILBPNT                            % SET NEW BUFFER ADDR
053051             GO STRTDIL                                       % START RT-PROGRAM
053052             EXIT
053053          FI
053053          IF X.2DIBADDR+2000=T THEN                           % BUFFER #1 IS FULL
053057             X.DILGFLAG BONE 1DILBFULL=:X.DILGFLAG            % MARK BUFFER #1 TO WRITE
053062             GO STRTDIL                                       % START RT-PROGRAM
053063          FI; EXIT
053064
053064   % START DISC-ACCESS-LOG TRANSFER PROGRAM
053064   INTEGER POINTER LREG
053065   STRTDIL: A:=L=:"LREG"
053067            X:="XDILD"; *AAX -MLINK
053071            X:=:B; CALL RTACT
053073            B:=X; GO LREG
053075   RBUS
053102
053102   %=============================================================================
053102   %            D V D I L O G
053102   %
053102   % ROUTINE ON LEVEL 11 FOR DISC LOG
053102   %
053102   % ENTRY:     B=DISC LOG DATAFIELD
053102   %            X=ABSTR PARAMETER LIST
053102   %
053102   SUBR DVDILOG
053102
053102   INTEGER CCMBNK=?,CCMADDR=?
053102   DOUBLE POINTER DCCMADR:=CCMBNK
053103   INTEGER CFUNC
053104
053104   DVDILOG: T:=X.ABFUN; AD:=X.MEMAD
053106            *1BANK
053107            AD=:DCCMADR
053110            *2BANK
053111            T=:CFUNC
053112            IF CFUNC>>13 GO FAR ERET                % ILLEGAL FUNCTION
053116   @ICR;
053116            A GOSW FAR ERET,FUN1,FUN2,FAR FUN3,FUN4,FUN5,
053125                   FAR FUN6,FAR FUN7,FAR FUN10,FAR FUN11,
053131                   FAR FUN12,FAR FUN13;
053133   @CR;
053133
053133   INTEGER POINTER PNCMBNK:=CCMBNK,PNCMADR:=CCMADR
053135
053135   FUN1:                        % WRITE DISC LOG RECORD
053135   FUN2:                        % WRITE DISC LOG RECORD, CLEAR REST OF DISC LOG FILE BUFFER
053135                                % AND WRITE DISC LOG BUFFER TO LOG FILE
053135          IF A:=DILGFLAG=:L NBIT DILSTART OR A NBIT DILBOK GO FAR ERET
053143          *1BANK
053144          T:=PNCMBNK; X:=PNCMADDR;*2BANK
053147          IF T=0 AND X=0 GO FAR ERET; *LDDTX
053154          T:=DILBANK; X:=DILBPNT; *STDTX
053157          *1BANK
053160          T:=PNCMBNK; X:=PNCMADDR; *LDDTX 20;2BANK
053164          T:=DILBANK; X:=DILBPNT; *STDTX 20
053167          IF L NBIT DILSMALL THEN
053171             *1BANK
053172             T:=PNCMBNK; X:=PNCMADDR; *LDDTX 40;2BANK
053176             T:=DILBANK; X:=DILBPNT; *STDTX 40
053201             *1BANK
053202             T:=PNCMBNK; X:=PNCMADDR; *LDDTX 60;2BANK
053206             T:=DILBANK; X:=DILBPNT; *STDTX 60
053211             X+4=:DILBPNT
053213          FI
053213          X+4=:DILBPNT
053215          IF CFUNC=2 THEN
053221             D:=0; T:=DILBANK
053223             DO WHILE A:=X/\1777><0
053226                A:=0; *STDTX; AAX 2
053231             OD; X=:DILBPNT
053233          FI; CALL WRDILOG
053234          GO FAR OKRET
053235   *)FILL
053250
053250   FUN4:  IF DILGFLAG NBIT DILDEFINED GO FAR ERET   % START DISC LOG
053253          A BONE DILSTART=:DILGFLAG
053255   L1:    X:="XDILD-MLINK":=:B; CALL RTACT; X=:B
053261          GO FAR OKRET
053262
053262   FUN5:  DILGFLAG BZERO DILSTART=:DILGFLAG         % STOP DISC LOG
053265          GO L1
053266
053266   INTEGER CDILGFLAG
053267   FUN6:  0=:CDILGFLAG                              % START DISC-ACCESS-COUNTER
053270          T:=CCMBNK; X:=CCMADDR; IF T=0 AND X=0 GO FAR ERET; *LDATX  % FLAG
053277          A=:CDILGFLAG
053300          IF A BIT DAC1UNIT THEN                    % COUNT FOR ONE UNIT ONLY
053302             *LDATX 20                              % UNIT NUMBER
053303             IF A>>3 GO FAR ERET
053306             A=:DLAUNIT
053307             CDILGFLAG BONE DAC1UNIT=:CDILGFLAG
053312          FI
053312          IF CDILGFLAG BIT DAC1CONTROLLER THEN      % COUNT FOR ONE CONTROLLER ONLY
053315             T:=CCMBNK; *LDATX 10
053317             CALL LOGPH; IF A=0 GO FAR ERET
053322             CALL CCHDILOG; GO FAR ERET
053324             A=:DLALOGDV
053325             CDILGFLAG BONE DAC1CONTROLLER=:CDILGFLAG
053330          FI; DILGFLAG BZERO DAC1UNIT BZERO DAC1CONTROLLER
053333          A BONE DILCOUNT\/CDILGFLAG=:DILGFLAG
053336          GO FAR OKRET
053337
053337   FUN7:  DILGFLAG BZERO DILCOUNT=:DILGFLAG         % STOP DISC ACCESS COUNTER
053342          GO FAR OKRET
053343
053343   FUN10: A:=0=:D; AD=:DXNDACCESSES=:DXNWDACCESSES  % CLEAR DISC ACCESS COUNTER
053347          GO FAR OKRET
053350
053350   FUN11: T:=CCMBNK; X:=CCMADDR                     % READ DISC ACCESS COUNTER
053352          AD:=DXNDACCESSES; *STDTX
053354          AD:=DXNWDACCESSES; *STDTX 20
053356          GO FAR OKRET
053357   *)FILL
053365
053365   INTEGER CCMBNK,CCMADDR
053367
053367   CCHDILOG: A=:D; X:="DIDLOG"
053371          DO WHILE X.S0><-1
053375             IF A=D THEN EXITA FI
053400             X+2
053401          OD; EXIT
053403
053403   FUN12:                                           % READ LAST DISC-ERROR INFO
053403          T:=CCMBNK; X:=CCMADDR; *LDATX             % A=:LOGICAL UNIT
053406          CALL LOGPH; IF A=0 GO FAR ERET
053411          CALL CCHDILOG; GO FAR ERET
053413          IF A."TRNSF"><"BDISK" GO FAR ERET
053420          *1BANK
053421          A.S2=:L
053424          T:=CCMBNK; X:=CCMADDR
053426          X:=:L; X.DS0; X+2:=:L; *STDTX
053433          X:=:L; X.DS0; X+2:=:L; *STDTX 20
053440          X:=:L; X.DS0; X+2:=:L; *STDTX 40
053445          X:=:L; X.DS0; X+2:=:L; *STDTX 60
053452          X+10:=:L; X.DS0; X+2:=:L; *STDTX
053460          X:=:L; X.S0; X:=:L; *STATX 20
053464          *2BANK
053465          GO FAR OKRET
053466   *)FILL
053474
053474   INTEGER CUN,NNC=CUN
053475   FUN13:                                           % READ DISC ERROR STATUS
053475          T:=CCMBNK; X:=CCMADDR; *LDDTX             % A= LOGICAL DEV. NO; D=UNIT NO.
053500          IF A=0 OR D>>3 GO FAR ERET
053504          A:=:D=:CUN:=D; CALL LOGPH; IF A=0 GO FAR ERET
053512          CALL CCHDILOG; GO FAR ERET
053514          A:=A.DEDFADDR+CUN=:D; D:=:B
053521          T:=CCMBNK; X:=CCMADDR
053523          -14=:NNC
053525          FOR NNC DO
053525             S0; *STATX
053527             B+4; X+1
053531          OD; B:=D; GO FAR OKRET
053535
053535   INTEGER POINTER PCCMBNK:=CCMBNK
053536
053536   % DEFINE DISC LOG
053536   %
053536   FUN3:  IF DILGFLAG BIT DILSTART GO ERET
053541          A BZERO DILDEFINED=:DILGFLAG
053543          *1BANK
053544          T:=PCCMBNK; X:=CCMADDR; *LDDTX ;2BANK           % FIRST DISC ADDR OF LOG FILE
053550          AD=:DILDADDR; *LDATX 20                   % A=NO. OF DISC SECTORS PER TRACK
053552          IF A><2 GO ERET; A=:DILNSEC
053556          *1BANK
053557          T:=PCCMBNK; *LDDTX 30;2BANK                     % NUMBER OF PAGES IN DISC LOG FILE
053562          AD=:DILLADDR                              % LAST LEGAL DISC ADDR IN LOG FILE
053563          IF A<<DIL1DADDR GO ERET; IF A=T AND D<<DIL2DADDR GO ERET
053573          *1BANK
053574          T:=PCCMBNK; *LDDTX 50;2BANK                     % A=LOG.DEV, D=DRIVE NUMBER
053577          AD=:DDILFLOG; CALL LOGPH; IF A=0 GO ERET
053602          IF DILFUNIT>>3 GO ERET
053606          A:=DILGFLAG/\177700=:D
053611          *1BANK
053612          T:=PCCMBNK
053613          *2BANK; LDATX 70                               % A=:FLAG WORD
053615          A/\77\/D=:DILGFLAG; X+10
053621          IF A BIT DIL1CONTROLLER THEN
053623             *1BANK
053624             T:=PCCMBNK; *LDATX 0;2BANK                   % A=LOG.DEV TO LOG
053627             A=:DLLOGDV; CALL LOGPH; IF A=0 GO ERET
053632          FI
053632          IF DILGFLAG BIT DIL1UNIT THEN
053635             *1BANK
053636             T:=PCCMBNK; *LDATX 10;2BANK                  % A=DRIVE NUMBER TO LOG
053641             IF A>>3 GO ERET; A=:DLDRIVE
053645          FI
053645          IF DILGFLAG BIT DILLIMIT THEN
053650             *1BANK
053651             T:=PCCMBNK; *LDDTX 20;2BANK                  % FIRST DISC ADDR TO LOG
053654             AD=:DILFADDR; *LDDTX 40                % LAST DISC ADDR TO LOG
053656             AD=:DILGLADDR
053657          FI
053657          DILGFLAG BZERO 1DILBFULL BZERO 2DILBFULL BONE DILDEFINED=:DILGFLAG
053664   OKRET: 0=:HSTAT
053665   RETU:  IF RTRES><0 THEN CALL RTACT FI; GO WT11
053671   ERET:  -1=:HSTAT; GO RETU
053674   RBUS
053706   *"
"053706   @DEV 1
053706   @DEV (S-S-L)IP-P2-DISK-START:NPL
053706   % IP-P2-DISK-START
053706   %==============================================================================
053706   %            C T R D I S K   B U S Y E   M D R I V   P F E I L
053706   %            C O O P T   D R F E I L
053706   %
053706   % LEVEL 11 ROUTINE TO PERFORM DRUM/DISK TRANSFERS
053706   % ACTIVATED BY MTRANS, WITH B=DATAFIELD, X=ABSTR PAR.LIST
053706
053706
053706   SUBR CTRDISK,BUSYE,MDRIV,PFEIL,COOPT,DRFEIL
053706
053706   DISP 0; DOUBLE POINTER DP1=P1; PSID
053706   DISP 0; DOUBLE DITARG=CTRG,DIDXRG=CDRG; PSID
053706   INTEGER  CBLDA(0); *BLDA 00 DT
053707   INTEGER CUN=?
053707
053707   INTEGER 9XER=?, 9XDV=?, 9XUN=?, 9XTA=?, 9XST=?, 9XFU=?
053707   DOUBLE 9XMA=?, 9XDA=?
053707
053707   CTRDISK:
053707          A:=L=:"CTRLR"
053711   *"8MPRF
"053711          CALL DIALO                               % Mon Performance sampling
053712   *"
"053712          X=:PARDF
053713          X.RTRES=:STPRW                            % SET PROG OWNING THIS ACCESS
053715          T:=X.ABFUN; AD:=X.MEMAD=:MEMAD
053720          IF A=0 AND D=0 THEN CALL ERRFATAL FI      % MEMORY ADDR ZERO IS ILLEGAL
053724          A/\3; A SH 14+T=:CTRG
053730          A SHZ -6/\7 SH 3\/CBLDA
053734          T:=M2UNTYP; *EXR SA
053736          IF K THEN
053740              CTRG BONE 16=:CTRG; 0=:CARG            % IF PHOENIX DISC
053744          ELSE
053745              CTRG/\7000 SHZ -11=:CARG
053751          FI
053751          IF CTRG/\77 >=60 AND A <=66 THEN   % CONVERT TO 0-4 FUNCK
053761               IF A = T THEN CTRG/\177701=:CTRG
053766               ELSE          CTRG/\177703=:CTRG FI
053772               X.ABPA2=:CADRG                                 % DOUBLE DISK ADDRESS
053774          ELSE IF A =43 OR A =44 THEN
054003               X.ABPA2=:CADRG                                 % DOUBLE DISK ADDRESS
054005          ELSE
054006               X.ABP21=:CDRG                                  % SINGLE DISK ADDRESS
054010          FI FI
054010          X.ABP31=:CXRG                                       % NO OF SECTORS
054012   % ----------------------------- END OF PARAMETER FETCHING
054012          CTRG=:TRGINI
054014          IF A/\77=36 THEN                                    % READ ELEMENT IN "DISC-LAYOUT-TABLE"
054020             0=:HSTAT; AD:=PARDF.MEMAD; *EXAM                       % T=FORMAT NUMBER
054024             IF 40>T AND DISPE(T)><0 THEN                     % 37 IS MAX FORMAT NUMBER
054032                T:=PARDF.MEMA1; X:=X.MEMA2; B=:L:=A; "DILEZ"=:D
054041                DO WHILE D><0                                 % COPY "DISC LAYOUT TABLE" ELEMENT TO "DMA-BUFFER"
054043                   S0; *STATX
054045                   X+1; D-1; B+1
054050                OD; B:=L
054052             FI; GO FAR FIN; *)FILL
054066          FI
054066          IF A=42 AND "TRNSF"><"BDISK" GO FAR FIN   % READ FORMAT NOT LEGAL IN DRIVER
054075                                                    % BUT GIVE NO ERROR MESSAGE
054075          IF TMR><0 THEN CALL ID11 FI      % DISP 12 ; 0=:TMRFLG
054100   *"8DILG
"054100          IF "DFDIL".DILGFLAG BIT DILCOUNT THEN
054104             IF A BIT DAC1CONTROLLER AND B><X.DLALOGDV GO L1       % DO'NT COUNT THIS CONTROLLER
054111             IF A BIT DAC1UNIT AND CTRG SHZ -6/\7><X.DLAUNIT GO L1 % DO'NT COUNT THIS UNIT
054121             *MIN 2XNDA,X; SKP; MIN 1XNDA,X; JMP * 1          % COUNT DISC ACCESSES
054125             IF CTRG/\77=1 THEN                               % COUNT WRITE ACCESSES
054132                *MIN 2XNWD,X; SKP; MIN 1XNWD,X; JMP *+1
054136             FI
054136          FI; GO L1; *)FILL
054145   L1:    IF X.DILGFLAG BIT DILSTART AND A BIT DILBOK THEN    % DISC LOG STARTED?
054152             A=:D; X:="DIDLOG"
054154             DO WHILE X.S0><-1                                % FIND LOGICAL UNIT
054160                IF A=B GO LGFOUND
054162                X+2
054163             OD; GO NOTLOG
054165   INTEGER CLUN
054166   LGFOUND:  X.S1=:CLUN; X:="DFDIL"                           % LOGICAL UNIT OF DISC
054171             IF A:=D/\37=0 GO DOLOG                           % LOG EVERY ACCESS
054174             IF D BIT DIL1CONTROLLER THEN                     % LOG ONLY ONE CONTROLLER?
054176                IF X.DLLOGDV><CLUN GO NOTLOG                  % YES, IS IT THIS CONTROLLER?
054202             FI
054202             IF D BIT DIL1UNIT THEN                           % LOG ONLY ONE UNIT?
054204                IF CTRG SHZ -6/\7><X.DLDRIVE GO NOTLOG        % YES, IS IT THIS UNIT?
054212             FI
054212             IF D BIT DILWACCESS THEN                         % LOG ONLY WRITE ACCESSES?
054214                IF CTRG/\77><1 GO NOTLOG
054221             FI
054221             IF D BIT DILRACCESS THEN                         % LOG ONLY READ ACCESSES?
054223                IF CTRG/\77><0 GO NOTLOG
054226             FI
054226             IF D BIT DILLIMIT THEN                           % LIMITED AREA TO LOG?
054230                AD:=CADRG; A=:L; D=:T; AD:=X.DILFADDR         % YES, TEST DISC ADDRESS
054234                IF L<<A GO NOTLOG; IF L=A AND T<<D GO NOTLOG
054242                AD:=X.DILGLADDR
054243                IF L>>A GO NOTLOG; IF L=A AND T>>D GO NOTLOG
054251             FI
054251   DOLOG:    T:="DFDIL".DILBANK; A:=X.DILGFLAG=:L:=X.DILBPNT  % SET UP DISC LOG RECORD
054256             IF L BIT DILSMALL THEN
054260                A+4=:X.DILBPNT; A-4
054263             ELSE
054264                A+10=:X.DILBPNT; A-10
054267             FI; X:=A
054270             AD:=DITARG; *STDTX
054272             IF L BIT DILSMALL THEN
054274                CLUN=:D; A:=CDRG; *STDTX 20
054300             ELSE
054301                AD:=DIDXRG; *STDTX 20
054303                X=:L; AD:=PARDF.MEMAD;X:=L; *STDTX 40
054310                STPRW=:D:=CLUN; *STDTX 60                     % RT PROG AND UNIT
054314             FI; CALL WRDILOG; GO NOTLOG; *)FILL              % WRITE DISC LOG BUFFER
054324          FI
054324   *"
"054324   NOTLOG: 0=:HSTAT
054325          IF DIFTCOUNT=0 THEN 1=:DIFTCOUNT FI                 % ONE RESTART BY TIMRT IS MAX
054331   *"8DILG
"054331          IF "TRNSF"="BDISK" THEN 0=:SPACO=:CORCU=:SRTRY=:SWTRY FI
054341   *"
"054341   LOOP:                                                      % FOR TRANSF AND COMPARE
054341                TACNS=:TACOU
054343                FOR TACOU DO                                  % FOR EACH ERROR
054343                   AD:=PARDF.MEMAD=:CMADR
054346   CREST:          CTADRG=:TADRG; X:=CXRG=:XRG
054352                   DO                                         % FOR EACH PHYSICAL TRANSFER
054352                      TTMR=:TMR; A:=ARG
054355
054355                      CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
054361
054361   BUSYE:             TAD=:TADRG; X=:XRG; CALL ID11           % WAIT FOR INTERRUPT
054364                      IF TMR=0 THEN                           % TIMEOUT
054366   *"8DILG
"054366                         D:=B; X:=DEDFADDR:=:B
054371                         IF X.CTRG SHZ -6/\7<4 THEN           % A=DISC UNIT NUMBER
054377                            IF T:=X.CTRG BIT "0" THEN         % WRITE ACCESS
054402                               MIN DIEWTMOUT(A); 0/\0         % INCREMENT WRITE-ACCESS TIMEOUT COUNTER
054405                            ELSE
054406                               MIN DIERTMOUT(A); 0/\0         % INCREMENT READ-ACCESS TIMEOUT COUNTER
054411                            FI
054411                         FI; D=:B
054412   *"
"054412                         IF DIFTCOUNT=0 GO FAR ERTMOUT
054415                         -1=:HSTAT
054417                      FI
054417
054417   MDRIV:             TADRG; X:=XRG
054421                   OD
054422   % ERROR EXIT
054422   PFEIL:
054422                   SRETF BONE CLDV=: SRETF                    % CLEAR DEVICE HAS BEEN USED
054425                   IF X NBIT 16 AND DIFTCOUNT><0 THEN         % NOT ON CYLINDER
054431                      A-1=:DIFTCOUNT;
054433                      IF STREN = 1 THEN CALL STSERR FI
054440                      CALL ID11; GO CREST     % TIMRT REACTIVATE DRIVER
054442                   FI
054442   DRFEIL:         X BONE 4=:HSTAT; T=:9XFU; AERRB\/X=:AERRB; MIN ERCNT; 0/\0
054452   *"RVERR
"054452                   IF CTRG SHZ -6/\7-4<0 THEN                 % SAVE ERROR INFO FOR EACH UNIT
054457                      A+4=:X=:CUN:=DEDFADDR=:D:=HSTAT; B:=:D
054466                      A=:DIUEXRG(X); T=:DIUETRG(X)
054470                      T:=D.HSTAT
054472                      IF X.CTRG BIT "0" THEN                  % WRITE FUNCTION
054475                         MIN DIEWCOUNT(CUN); 0/\0
054500                         DIEWOR(X)\/T=:DIEWOR(X)
054503                      ELSE
054504                         MIN DIERCOUNT(CUN); 0/\0
054507                         DIEROR(X)\/T=:DIEROR(X)
054512                      FI; CALL UPDIERR; B:=D; X:=HSTAT
054515                   FI
054515   *"
"054515                   IF SERRB/\X><0 GO FIN  %SERIOUS
054520                   IF X BIT 12 THEN TRGINI=:CTRG FI
054524                OD; GO FIN; *)FILL
054535   *"8DILG
"054535   INTEGER CUN
054536   *"
"054536
054536   COOPT:       X=:HSTAT
054537   *"8DILG
"054537                IF CTRG SHZ -6/\7<4 THEN
054545                   A=:X:=DEDFADDR=:D; B:=:D; CALL UPDIERR; B:=D
054553                FI
054553   *"
"054553                IF COMFL=0 GO FIN
054555                IF TRG/\7=3 GO FIN                  % COMPARE HAS BEEN EXECUTED
054562                IF "TRNSF"="BDISK" GO FIN           % NO COMPARE ON ECC DISKS
054566                IF CTRG/\77>1 GO FIN                % COMPARE FOR FUNCTION 0 AND 1
054573                177770/\TRG\/3=:CTRG                % SET COMPARE
054577          GO FAR LOOP; *)FILL
054606
054606   INTEGER 9XER:=1663        % Error code
054607   INTEGER 9XDV              % Device no.
054610   INTEGER 9XUN              % Unit
054611   DOUBLE 9XMA               % Memory address
054613   DOUBLE 9XDA               % Disk address
054615   INTEGER 9XTA              % Number of words
054616   INTEGER 9XST              % HW status   (+ inclusive OR of errors)
054617   INTEGER 9XFU              % Driver error bits (T)
054620
054620   FIN:   0=:DIFTCOUNT;
054621          IF CTRG/\77=42 THEN                                 % READ FORMAT
054626             CTRG SHZ -6/\7=:X                                % X=UNIT NUMBER
054632             X:=HTABL(X); T:=X.DISPN; AD:=PARDF.MEMAD; *DEPO  % RETURN FORMAT NUMBER IN FIRST LOCATION OF "DMA-BUFFER"
054637   *"-8DIMI
"054637          FI
054637
054637          0=:TMR
054640          IF HSTAT BIT 4 THEN
054643             IF 77/\TRG>=42 AND <=44 GO FINE                  % NO ERROR MESSAGE
054653             IF A/\7=3 AND "TRNSF"="BDISK" GO FINE            % NO ERROR MESSAGE WHEN COMPARE ON ECC
054663                1663=:9XER
054665                A:=B; CALL PHLOG; A=:9XDV                     % DEVICE NUMBER
054670                TRG SHZ -6/\7=:9XUN                           % DEVICE UNIT
054674                PARDF.MEMAD=:9XMA; CADRG=:9XDA; CXRG=:9XTA    % PARAMETERS
054703                HSTAT=:9XST; X:=STPRW                         % HARDWARE STATUS WORD
054706                *1BANK
054707                CALL 9FLEX(9XER,12)                           % REPORT ERROR
054712                *2BANK
054713          FI
054713   FINE:  0=:STPRW
054714          GO CTRLR                                           % E X I T
054715   *)FILL
054723
054723   ERTMOUT: HDEV; T:=TRG SH 7 SHZ -15; CALL 9ERR(#26)         % DEVICE TIMEOUT
054731            HSTAT BONE 4=:HSTAT; GO FINE
054735
054735   *"8DILG
"054735   INTEGER XSPACO,XCORCU,XSRTRY,XSWTRY
054741   UPDIERR: B:=:D
054742            IF "BDISK"="TRNSF" THEN
054746                A:=SPACO=:XSPACO:=CORCU=:XCORCU:=SRTRY=:XSRTRY:=SWTRY=:XSWTRY
054756                B:=:D
054757                DIERRTRY(X)+XSRTRY=:DIERRTRY(X)
054762                DIEWRTRY(X)+XSWTRY=:DIEWRTRY(X)
054765                DIECORCU(X)+XCORCU=:DIECORCU(X)
054770                DIESPACO(X)+XSPACO=:DIESPACO(X)
054773            ELSE
054774                B:=:D
054775            FI; EXIT
054776   *"
"054776   RBUS
055000
055000
055000   SUBR STDIS
055000   %---------------------------------------------------------
055000   %   LEV 11 ROUTINE, ACTIVATED FROM MONITOR LEVEL
055000   %  ON SINGLE THREAD DMA DEVICES
055000   %---------------------------------------------------------
055000   STDIS: CALL CTRDISK
055001          1=:ISTATE; CALL RTACT               % RETURN TO MLEV
055004          CALL ID11;  A+1; GO ERR22
055007   RBUS
055013
055013   SUBR PRABP
055013   %--------------------------------------------------------------
055013   % PREPARE ABSTR PARAMETERS TO DISK.
055013   % ENTRY: X= QUE ELEMENT
055013   %--------------------------------------------------------------
055013   PRABP:  IF X.ABFUN /\ 77 >=60 AND A <= 66 THEN  % DOUBLE WORD DISC ADDR
055023              X.TYPCO BONE SSEEK =:X.TYPCO
055026           ELSE IF A >= 0 AND A <= 3    THEN       % MAKE DOUBLE WORD DISC ADDR
055033              X.TYPCO BONE SSEEK =:X.TYPCO
055036              A:=X.ABP21; A=:D:=0; AD:=X.ABPA2
055042              X.ABFUN+60=:X.ABFUN
055045           ELSE
055046           FI FI  A:=X.ABP31=:X.ABP32     % LENGTH IN BOTH
055050           IF A = 0 THEN  X.TYPCO BZERO SSEEK =:X.TYPCO FI
055054           EXIT
055055   RBUS
055056   SUBR DSORT
055056   %--------------------------------------------------------------
055056   % ENTRY:X= UNIT DF.
055056   %       B= QUE  DF.
055056   %--------------------------------------------------------------
055056   INTEGER SAVX, PREVQ, LASTQ
055061   INTEGER POINTER HOME
055062
055062   DSORT: A:=L=:"HOME"; X=:SAVX
055065          T:="SCLINK-NLINK"+X=:PREVQ           % BEFORE FIRST ELEMENT
055070          IF X.PLHAD=0 THEN A:=T FI; A=:LASTQ  % BEFORE FIRST ELEMENT IN OTHER DIRECTION
055074          IF TYPCO BIT SSEEK THEN
055077             X.CHADD; T:="ABPA2"+B; CALL COMPD % COMPARE WITH CURRENT HEAD ADDRESS
055103             T:=X.MOVME
055104             IF A SHZ -17 XOR T BIT 0 THEN
055110                *BSET BCM 00 DT                % CHANGE DIRECTION
055111                IF X.SCLINK><0 THEN
055113                   LASTQ=:PREVQ; 0=:LASTQ      % START FROM MIDPOINT
055116                ELSE
055117                   T=:X.MOVME                  % INITIALIZE DIRECTION
055120                FI
055120             FI
055120             X:=PREVQ; *BLDA 00 DT             % DIRECTION TO K
055122             DO
055122                IF X=LASTQ THEN
055125                   *BSET BCM SSK               % CHANGE DIRECTION
055126                FI
055126                WHILE X:=X.NLINK><0
055130                IF X.TYPCO BIT SSEEK THEN
055133                   IF K THEN                   % INCREASING ADDRESSES
055135                      ABPA2; T:=ABP32; D+T; A:=A+C
055141                      T:="ABPA2"+X
055143                   ELSE                        % DECREASING ADDRESSES
055144                      X.ABPA2; T:=X.ABP32; D+T; A:=A+C
055150                      T:="ABPA2"+B
055152                   FI
055152                   CALL COMPD
055153                   IF A>0 THEN X=:PREVQ FI     % AFTER CURRENT
055156                ELSE
055157                   X=:PREVQ                    % AFTER CURRENT
055160                FI
055160             OD
055161          ELSE
055162             IF X.PLELE><0 THEN A=:PREVQ FI         % AFTER LAST ELEMENT
055165          FI
055165          PREVQ.NLINK=:NLINK; A:=B=:X.NLINK         % INSERT AFTER PREVIOUS
055172          IF X=LASTQ THEN A=:SAVX.PLHAD FI
055177          X:=SAVX; IF 0=NLINK THEN A=:X.PLELE FI
055204          GO HOME
055205   *)FILL
055210
055210   % COMPARE TWO UNSIGNED DOUBLES
055210
055210   INTEGER SAVX2
055211   COMPD: X=:SAVX2
055212          IF A>>T.S0 GO GT; IF A<<T GO LT      % CHECK FIRST WORD
055220          IF D>>X.S1 GO GT; IF D<<T GO LT      % CHECK SECOND WORD
055225          "0";  T:=SAVX2:=:X; EXIT
055231   GT:    "1";  T:=SAVX2:=:X; EXIT
055235   LT:    "-1"; T:=SAVX2:=:X; EXIT
055241   RBUS
055241
055241   SUBR STSERR
055241    %-----------------------------------------------------------------
055241    % SEEK ERROR  ROUTINE                                    ( M )
055241    % B= CONTR DF.
055241    %-----------------------------------------------------------------
055241   INTEGER IBLDA(0);*BLDA DT
055242   INTEGER IBSTC(0);*BSTC DT
055243   INTEGER 9XER:=1665, 9XDV, 9XUN
055246           A:=X.SUNIT SHZ 3 \/IBLDA              % BUILD LOAD K INSTUCTION
055251           INTEGER POINTER SAVL
055252    STSERR:A:=L=:"SAVL"
055254           MIN STIMC; A/\A
055256           IF NSEEK-PESEEK >> 6 THEN           % NSEEK = SEEK COUNTER
055263             0=:ESEEK                          % PESEEL= NSEEK WHEN LAST ERROR
055264           FI                                  % ESEEK = ERROR COUNTER
055264           NSEEK=:PESEEK                       %
055266           IF ESEEK+1=:ESEEK > STMOU THEN      % TOO MANY TIME OUT,
055274             X:=PUND0
055275             DO WHILE X >< 0                   % TRY TO FIND THE UNIT
055276                IF X.SLINK >< 0 THEN
055300                  A:=X.SUNIT SHZ 3 \/IBLDA     % BUILD LOAD K INSTUCTION
055303                  T:=SUNIH ;*EXR SA            % LOAD  K
055305                  IF K GO NUN                  % SEEK ALLREADY INHIBITED
055307                  A:=X.SUNIT SHZ 3 \/IBSTC;*EXR SA %BUILD STORE C0MP.
055313                  T=:SUNIH;                    % DISABLE SEEK ON THIS UNIT
055314                  A:=B; CALL PHLOG; A=:9XDV
055317                  T:=X.SUNIT=:9XUN
055321                  *1BANK
055322                  X:=0; CALL 9FLEX(9XER,3)
055326                  *2BANK
055327                  X:=0
055330                ELSE
055331   NUN:           X:=X.ULINK
055332                FI
055332             OD
055333           FI
055333           GO SAVL
055334   RBUS
055336
055336   SUBR STSURR
055336    %-----------------------------------------------------------------------
055336    %  TRY TO FIND SEEK ERROR UNIT                               ( I )
055336    %  B= CONTR. DF
055336    %-----------------------------------------------------------------------
055336           INTEGER POINTER SAVL
055337    STSURR:A:=L=:"SAVL"
055341           CALL STSERR
055342           IF  PSTRA >< 0 THEN CALL ERRFATAL; FI
055345           X:=PUND0
055346           DO WHILE X >< 0                     % SCAN ALL UNITS
055347              IF X.SLINK >< 0 GO SAVL
055352              X:=X.ULINK
055353           OD
055354           CALL ERRFATAL
055355   RBUS
055357
055357   SUBR TOSECT
055357    %-----------------------------------------------------------------------
055357    %  CONVERT PHYS ADDR TO SCETOR, CYL AND SURF.                ( I )
055357    %  ENTRY:  AD= LOG SECT ADDR,  B= DISK DF, X= UNIT DF
055357    %  EXIT :   A= SECTOR / SURFACE
055357    %           D= CYLINDER
055357    %-----------------------------------------------------------------------
055357   INTEGER SEC,CYL,XREG
055362   DOUBLE SECC=SEC
055362   TOSECT: AD=:SECC; A:=X.SUNIT; X=:XREG:=B
055366           *AAX HTABL; RADD DX SA; LDX ,X % SET UP DISK LAYOUT ELEMENT ADDRESS
055371           AD:=SECC
055372           T:=X.SECSY; *RDIV ST           % COMPUTE CYLINDER
055374           A=:CYL:=0
055376           T:=X.SECTR; *RDIV ST           % COMPUTE SURFACE/ SECT
055400           A SHZ 10:=:D;
055402           IF A-2 < 0 THEN A+X.SECTR;FI     %
055405           A\/D=:SEC
055407           AD:=SECC; X:=XREG
055411           EXIT
055412    RBUS
055412
055412
055412   SUBR BSEEK,WSEEK
055412    %-------------------------------------------------------------------
055412    % L E V E L  1 1    ROUTINES TO START SEEK FOR SORTING ABSTR     ( I )
055412    % B= CONTR DATAFIELD, X=UNIT DF
055412    %-------------------------------------------------------------------
055412    @ICR;
055412           SYMBOL RSC=2,         % REED SEEK COND
055412                  LBA=3,         % LOAD BLOCK ADDR
055412                  RSR=4,         % READ STATUS REG
055412                  LCO=5;         % LOAD CONTR WORD
055412
055412    @CR;
055412
055412    % BSEEK
055412    %-------------------------------------------------------------------
055412    % BNSEEK: INITIATE SEEK
055412    % B= DISK DF, X= UNIT DF
055412    %-------------------------------------------------------------------
055412   INTEGER IBLDA(0);*BLDA DT
055413   BSEEK:  T:=X; A:=X.SLINK.TYPCO; X:=T
055417           IF A NBIT SSEEK THEN EXIT; FI
055422           IF "TRNSF"><"BDISK" THEN EXIT; FI     % NOT PARALELL SEEK
055427           A:=X.SUNIT SHZ 3 \/IBLDA              % BUILD LOAD K INSTUCTION
055432           T:=M2UNTYP;*EXR SA;BSKP ZRO SSK;EXIT  % NOT SEEK ON CARTRIDGE DISC
055436           T:=SUNIH  ;*EXR SA;BSKP ZRO SSK;EXIT  % THIS UNIT IS INHIBITED FORM SEEK
055442           T:=HDEV+LCO
055444           A:=X.SUNIT SHZ 7;    *IOXT       % UNIT SELECT AND RESET CWR
055447           AD:=X.CHADD                      % PHYS ADDR
055450           T+"LBA-LCO";         *IOXT
055452           A:=X.SUNIT SHZ 7 BONE 17         % UNIT SELECT AND SET CWR
055455           T+"LCO-LBA";         *IOXT
055457           A:=D;    T+"LBA-LCO";*IOXT       % BLOCK ADDRESS II
055462
055462           A:=X.SUNIT SHZ 7=:LUNI           % UNIT SELECT AND RESET CWR
055465           A \/ 020004; T+"LCO-LBA"         % INITIATE SEEK
055467           *IOXT
055470           EXITA
055471   *)FILL
055473    % WSEEK
055473    %-------------------------------------------------------------------
055473    % WAIT ON SEEK ROUTINE FOR SMD CONTROLLER
055473    %-------------------------------------------------------------------
055473           INTEGER LOOP
055474    WSEEK: A:=L=:"CTRLR"
055476           -101=:LOOP
055500    L1:    MIN LOOP; GO L2; GO CTRLR        % ERROR
055503    L2:    T:=HDEV+RSR; *IOXT               % READ STATUS
055506           IF A BIT 17 THEN                 % MUST RESET CWR
055510             T+"LCO-RSR"; A:=LUNI; *IOXT
055513             GO L1
055514           FI
055514           IF A  BIT 4 GO CTRLR      % ERROR
055516           IF A NBIT 3 GO L1         % NOT FINISHED
055520           TTMR=:TMR
055522           T+"LCO-RSR";A:=LUNI       % UNIT SELECT ON A VALID UNIT
055524           A \/ 030005; *IOXT        % ENABLE INT, SEEK COMPL. SEARCH
055526           CALL ID11                 % WAIT ON SEEK INTERUPT
055527
055527           T:=HDEV+RSC;       *IOXT                  % READ SEEK CONDITION
055532
055532           IF T:=TMR = 0 GO CTRLR
055535
055535           IF      A BIT 0 THEN X:=0                 % WITCH UNIT ?
055540           ELSE IF A BIT 1 THEN X:=1
055544           ELSE IF A BIT 2 THEN X:=2
055550           ELSE IF A BIT 3 THEN X:=3
055554           ELSE
055555              MIN SUNGL; A/\A;  GO L1
055560           FI FI FI FI
055560           MIN NSEEK; A/\A
055562           IF X:=PUNDF(X)=0 THEN GO CTRLR; FI   % X= UNIT DF
055566           MIN "CTRLR";A/\A
055570           GO CTRLR
055571   RBUS
055573
055573
055573    SUBR  SSCUR,UPCUR
055573    %----------------------------------------------------------------------
055573    % MOVE FROM SCLINK QUE TO SLINK POINTER                ( I )
055573    % B= DISK DF, X= UNIT DF
055573    %     UPCUR: UPDATE POINTERS IF SLINK IS UPDATED OUTSIDE
055573    %----------------------------------------------------------------------
055573    % LOCAL SUBROUTINE TO DECREMENT NO IN QUE
055573   DECN:   SNOIQ-1=:SNOIQ                      % COUNTER FOR NO. IN QUE
055576           X.SUNOP-1=:X.SUNOP                  % COUNTER FOR NO. IN UNIT QUE
055601           EXIT
055602
055602           INTEGER SAQH
055603           INTEGER POINTER SAVL
055604    SSCUR: X=:SAQH; A:=L=:"SAVL"
055607           CALL DECN
055610           IF X.SLINK >< 0 THEN                % ONLY ONE CAN BE STARTED
055612              CALL ERRFATAL; FI
055613           *AAX SCLIN
055614           CALL GETOUT                         % LINK QUE ELEM
055615           *AAX SLINK-SCLIN
055616           CALL PUTIN; *AAX -SLINK             % TO STARTED
055620           IF X.PLELE >< T THEN                % LAST ELEMENT LIKED IN ?
055623             IF X.PLHAD=T THEN                 % NEW DIRECTION ?
055626                0=:X.PLHAD                     % NO MORE IN THIS DIRECTION
055627             ELSE
055630             IF A=0 THEN
055631                X.PLELE=:X.PLHAD               % NEW DIRECTION
055633                MIN X.MOVME; A/\A
055635             FI FI
055635           ELSE                                % LAST ACC
055636             0=:X.PLHAD=:X.PLELE
055640           FI
055640   L1:     X=:T; IF X.SLINK.TYPCO  BIT SSEEK THEN
055645             AD:=X.ABPA2; T=:X                % LOG. SECT. ADDRESS
055647             CALL TOSECT; AD=:X.CHADD         % PHYS ADDRESS
055651           ELSE
055652             T=:X
055653           FI
055653           GO SAVL
055654   UPCUR:  X=:SAQH; A:=L=:"SAVL"
055657           CALL DECN
055660           GO L1
055661   RBUS
055665
055665
055665   SUBR STRDISK
055665    INTEGER CODF              % CONTROLLER DF
055666    INTEGER QUDF              % QUE ELEM  DF
055667    INTEGER UNDF              % UNIT DF
055670    %-------------------------------------------------------------------
055670    % LEVEL 11 DODMA ROUTINE FOR SMD AND ST506                     ( I )
055670    %  ENTRY:  B= CONTR DATAFIELD  X= QUE DF  T= TYPE
055670    %-------------------------------------------------------------------
055670    STRDISK:A:=B=:CODF; X=:QUDF; A:=L=:X.NFUNC
055675           T=:X.TYPCO
055676   % ----------------------------- PREPARE PARAMETERS
055676           CALL PRABP                                  % PREPARE PARAMETERS
055677           A:=X.ABFUN /\ 300 SHZ -6=:LUNI              % UNIT SELECT
055703           IF X:=PUNDF(A)=0 THEN
055707             X:=PUND0; IF X=0 THEN CALL ERRFATAL FI
055713           FI X=:UNDF                                 % X= UNIT DF. (B= CONT DF.)
055714   % --------------------------- WHAT TO DO
055714           MIN SNOIQ; 0/\0; MIN X.SUNOP; 0/\0         % COUNT ELEMENT
055720           IF  SNOIQ >  SNMIQ  THEN A=:  SNMIQ  FI
055725           IF X.SUNOP> X.SUMAX THEN A=: X.SUMAX FI
055732           IF X.SCLINK >< 0 THEN                      % QUE NOT EMPTY
055734             QUDF=:B; CALL DSORT; GO WT11
055740           ELSE IF PSTRA >< 0 OR X.SLINK >< 0 THEN    % CONTROLLER OR UNIT BUSY
055745             QUDF=:X.SCLINK=:X.PLHAD=:X.PLELE; GO WT11
055752           FI FI
055752   % -------------------------- READY TO START SEEK
055752           T:=QUDF=:X.SLINK; CALL UPCUR
055755           CALL BSEEK; GO STRA;
055757   WSEE:   CALL WSEEK  CALL STSURR
055761   STRA:   X=:PSTRA                              % TRANSF. STARTED POINTER
055762           IF X:=X.SLINK=0 THEN CALL ERRFATAL FI
055766           IF X.RTRES >< 0 THEN                  % PROGRAM OWNING THIS ACC ?
055770              0=:TMR; CALL CTRDISK               % DO DISK TRANSFER
055772           ELSE 0=:HSTAT
055774           FI
055774           X:=PSTRA=:D
055776           0=:PSTRA
055777           IF X:=X.SLINK = 0 THEN CALL ERRFATAL FI
056003           HSTAT=:X.SSSTAT=:X.XSTAT
056006           IF A BIT 4 THEN                    % SAVE TREG FROM DRIVER IF ERROR
056010              TRG SHZ -6; X=:L:=7/\A
056015              T:=DEDFADDR:=:B
056017              DIUETRG(X)=:L.DMTRG; T=:B       % FETCH FROM DISK LOG
056023           FI
056023           X:=D; *AAX SLINK
056025           CALL GETOUT; *IOF                       % T= QUE DF.
056027           X:=T; CALL TO11Q; *ION                  % Q U E D F TIL LV11 QUE
056032   % --------------------------------- MORE TO DO ?
056032           X:=PUND0                                % (B=CONT DF.)
056033           DO WHILE X >< 0                         % MORE IN QUE(S) ?
056034             IF X.SCLINK >< 0 AND X.SLINK = 0 THEN
056040                CALL SSCUR; CALL  BSEEK; GO STRA   % START SEEK FOR A NEW ACC.
056043             ELSE IF X.SLINK >< 0 AND SRETF BIT CLDV THEN
056051                CALL  BSEEK; GO STRA               % RESTART OLD SEEK
056053             FI FI; X:=X.ULINK
056054           OD
056055           0=:SRETF                                 % SET CONTROLLER FREE
056056           X:=PUND0 ; DO WHILE X >< 0
056060             IF X.SLINK >< 0 GO WSEE                % SEEK STARTED ?
056062             X:=X.ULINK
056063           OD
056064           CALL ID11;  A+1; GO ERR22                 % FALSE INTERUPT
056067    RBUS
056106
056106   SUBR SSTDI
056106   %---------------------------------------------------------
056106   %  LEV 11 ROUTINE, ACTIVATED FROM MONITOR LEVEL
056106   %  ON MULTI THREAD DMA DEVICES
056106   %  B= CONTR DF. X= QUE DF.
056106   %---------------------------------------------------------
056106   SSTDI: CALL DODMA
056107          T:=X; X:=B; *AAX DIREE
056112          CALL PUTIN; CALL RTACT
056114          GO WT11
056115   RBUS
056120
056120   %===========================================================================
056120   % ROUTINES ACTIVATED ON SMD AND ST506 DEVICES
056120   %----------------------------------------------------------------------------
056120   % STREN=0; ACTIVATED ONLY FROM MLEV.
056120   %
056120   %  LEV11              STDIS  : CALL CTRDISK;"MFUNC"=>RETRANS; CALL ID11 GO ERR22
056120   %                     CTRDISK: L=:"CTRLR"
056120   %
056120   %  MLEV         "MTRANS"=> MTRNS                  RETRANS:
056120   %         MTRNS: L=:"TRLREG"
056120   %               "SDRIV" => STDIS
056120   %
056120   %----------------------------------------------------------------------------
056120   % STREN=1; ACTIVATED FROM  MLEV.
056120   %
056120   %  LEV11              SSTDI  : CALL "DODMA"=>STRDISK; "MFUNC"=>STRETRANS;GO WT11
056120   %                     STRDISK: L=:"NFUNC"; CALL  CTRDISK
056120   %                     CTRDISK: =L=:"CTRLR"
056120   %
056120   %  MLEV         "MTRANS"=> STRNS                   STRETRANS: "TRLREG"
056120   %         STRNS: L=:"TRLREG"                                    EXIT
056120   %               "SDRIV" => SSTDI
056120   %
056120   %----------------------------------------------------------------------------
056120   % STREN=1; ACTIVATED FROM  LEV12
056120   %
056120   %  LEV12        "M5TRANS"=>DRTRA
056120   %         DRTRA: L="TRLREG"                        DL12T:     "TRLREG"
056120   %                "DL11T"=:NFUNC                                EXITA
056120   %                EXIT
056120   %
056120   %  LEV11              DL11T  : CALL "DODMA"=>STRDISK; "DL12T"=>NFUNC; GO WT11
056120   %                     STRDISK: L=:"NFUNC"; CALL  CTRDISK
056120   %                     CTRDISK: =L=:"CTRLR"
056120   %
056120   %----------------------------------------------------------------------------
056120
056120   @DEV 1
056120   @EOF
056120
056120   @DEV (S-S-L)IP-P2-SCSI-DISK:NPL
056120   *"8SCSI
"056120   %==============================================================================
056120   % XX.X       C T R S C S I
056120   %
056120   %
056120   % LEVEL 11 ROUTINE TO PERFORM TRANSFERS ON SCSI CONTROLLERS
056120   % ACTIVATED WITH B=DATAFIELD, X=ABSTR PAR.LIST
056120   %
056120   %
056120   %
056120   %
056120   %    FUNCTIONS
056120   %
056120   %           0: READ
056120   %           1: WRITE
056120   %           2: READ PARITY
056120   %           3: COMPARE
056120   %           4: SEEK
056120   %           5: READ BACKWARDS
056120   %           6: RESERVE DEVICE
056120   %          10: ADVANCE THROUGH EOF
056120   %          11: REVERCE THROUGH EOF
056120   %          12: WRITE EOF
056120   %          13: REWIND
056120   %          14: WRITE SKIP
056120   %          15: REVERSE RECORDS
056120   %          16: ADVANCE RECORDS
056120   %          17: UNLOAD
056120   %          41: FORMAT
056120   %          21: CLEAR SCSI BUS
056120   %          26: READ BYTE RECORD
056120   %          27: WRITE BYTE RECORD
056120   %          30: LOAD
056120   %          35: RELEASE DEVICE
056120   %          37: READ EXTENDED STATUS
056120   %          42: INQUIRY AND READ CAPACITY
056120   %          46: READ CURRENT ADDRESS
056120   %          47: WRITE CURRENT ADDRESS
056120   %          54: COPY
056120   %          70: RETENSION
056120   %          71: WRITE AND VERIFY
056120   %          73: TEST UNIT READY
056120   %          74: EXECUTE USER SPECIFIED SCSI COMMAND BLOCK
056120   %          75: INQUIRY (READ DEVICE TYPE)
056120   %          76: ADVANCE TO END OF RECORDED AREA
056120   %
056120
056120   SUBR SCLLD, SCTIO                           % DUMMY DECLARATIONS
056120   RBUS
056120   SUBR  SWT11
056120
056120   SWT11: IF X:=SCFQP><0 THEN
056122             X.SCULI=:SCFQP; 0=:X.SCULI        % LINK OUT OF QUEUE
056125             A:=X.SCUDF=:B                     % SCSI LUN DATAFIELD
056127             X.HSTAT; T:=X.SCTRG
056131             X=:L:=X."FINISH":=:L; EXIT        % RETURN TO EXTERNAL DRIVER
056135          FI
056135          IF SCRSQ><0 THEN
056137             X:="SCRSQ-SCRSL"
056140             DO WHILE A=:B:=SCRSL><0; X:=B OD  % GET END OF QUEUE
056145             0=:X.SCRSL; GO SCTIO
056147          FI
056147          GO WT11
056150   RBUS
056155
056155   SUBR SCGLN, SCGLB
056155
056155   SCGLB: A/\7; B+A; *LDA ,B SCDVD             % NODE DATAFIELD
056160
056160   SCGLN: IF B:=A=0 THEN T:=NOLUN; EXIT FI     % NO NODE DATAFIELD
056165          IF A:=7/\T<SDNLU THEN
056172             A*SULEN; B+"SDLEN"+A              % LUN DATAFIELD ADDRESS
056175          ELSE
056176             T:=ILNOD; EXIT
056200          FI
056200          EXITA
056201   RBUS
056203
056203   SUBR CTRSCSI
056203
056203   DISP 0; DOUBLE POINTER DP1=P1; PSID
056203
056203   @ICR;
056203   INTEGER ARRAY NEWST:=
056203         (000000, 000000, 000020, 000020, 000020, 000020, 000020, 000020,
056213          000020, 000020, 000020, 000020, 000020, 000020, 000020, 000020);
056223   @CR;
056223
056223   CTRSCSI:
056223
056223   % -- PREPARE CALL TO DRIVER
056223
056223          IF 77/\X.ABFUN=21 GO FAR CLSCB       % CLEAR SCSI BUS
056230          X.ABFUN=:ABFUN; X.MEMAD=:MEMAD       %
056234          X.ABPA2=:ABPA2; X.ABPA3=:ABPA3
056240          ABFUN SHZ -6; T:=7/\A; A SHZ -3/\7   % LUN AND SCSI DEVICE NUMBER
056246          X:=B; CALL SCGLB; GO ERREX           % LUN DATAFIELD
056251
056251   % CALL DRIVER
056251          DO
056251             4; T:=X; CALL SCSID; GO ERREX; CALL ERRFATAL; GO FINEX
056257
056257   ERREX:    A:=T SHZ 11 BONE 4; GO FINE
056263
056263   FINEX:    A=:L/\17-6:=:L; WHILE L=0
056271          OD
056272
056272   FINE:  X=:B:=17/\A
056275          *1BANK
056276          A\/NEWST(X)
056277          *2BANK
056300          A=:HSTAT; CALL RTACT; GO SWT11
056303   *)FILL
056314
056314   CLSCB: "4\0"; CALL SCLLD; GO CLERR; CALL ERRFATAL
056320
056320          "0"; GO FINE                         % OK RETURN
056322
056322   CLERR: A:=T SHZ 11 BONE 4; GO FINE          % SET T-REGISTER
056326
056326   RBUS
056331
056331   %==============================================================================
056331   %        S C S D I S K
056331   %
056331   % LEVEL 11 ROUTINE TO PERFORM TRANSFERS ON SCSI DISKS
056331   %
056331   %
056331   %    FUNCTIONS
056331   %
056331   %           0: READ
056331   %           1: WRITE
056331   %           2: READ PARITY
056331   %           3: COMPARE
056331   %           4: SEEK
056331   %           6: PRIORITY SELECT (DUMMY)
056331   %          34: RESERVE DEVICE
056331   %          35: RELEASE DEVICE
056331   %          36: READ DISK LAYOUT RECORD
056331   %          37: READ EXTENDED STATUS (SCSI SENSE INFO)
056331   %          41: FORMAT
056331   %          42: READ FORMAT
056331   %          43: READ IN CONTROLL AREA
056331   %          44: WRITE IN CONTROLL AREA
056331   %          60: READ (DOUBLE DISK ADDRESS)
056331   %          61: WRITE (DOUBLE DISK ADDRESS)
056331   %          61: READ PARITY (DOUBLE DISK ADDRESS)
056331   %          61: COMPARE (DOUBLE DISK ADDRESS)
056331   %          73: TEST UNIT READY
056331   %          74: EXECUTE USER SPECIFIED SCSI COMMAND BLOCK
056331   %          75: INQUIRY (READ DEVICE TYPE)
056331   %
056331   SUBR SCSDISK
056331
056331   %
056331   % FLAG BITS IN OPERATION TYPE
056331   %
056331
056331   SYMBOL 3SERR=17          % ERROR MESSAGE
056331   SYMBOL 3SNTR=16          % NEUTRAL OPERATION
056331   SYMBOL 3DPA3=15          % PARAMETER 3 DOUBLE
056331   SYMBOL 3DPA2=14          % PARAMETER 2 DOUBLE
056331   SYMBOL 3SPES=13          % SPECIAL OPERATION (NOT SORTED)
056331   SYMBOL 3PART=12          % PARTITION ACCESS
056331   SYMBOL 3WRIT=11          % WRITE OPERATION
056331   SYMBOL 3SF42=10          % FUNCTION 42
056331
056331
056331   %
056331   % RETOP: TERMINATE OPERATION
056331   %
056331   % ENTRY: B = DISK DATAFIELD
056331   %        X = DAQ
056331   %        T = DRIVER STATUS
056331   %        A = SENSE (IF T=0)
056331   %
056331   % ALL REGISTERS PRESERVED
056331   %
056331   @ICR;
056331   INTEGER ARRAY NEWST:=
056331         (040000, 040000, 100020, 140020, 140220, 140020, 140020, 040020,
056341          040020, 140020, 150020, 140020, 040000, 140020, 042020, 140020);
056351   @CR;
056351
056351   TRIPLE SVTAD
056354   INTEGER SVTRG=SVTAD
056354   INTEGER SVXRG
056355   INTEGER POINTER SVLRG
056356   INTEGER 9XER:=1663, 9XDV, 9XUN
056361   DOUBLE 9XMA, 9XDA
056365   INTEGER 9XTA, 9XST, 9XFU
056370
056370   RETOP: TAD=:SVTAD; X=:SVXRG
056372          A=:SCOSS:=:L=:"SVLRG"                % ORIGINAL SCSI STATUS
056375          IF T=0 THEN
056377             IF 76/\X.ABFUN=2 OR =62 THEN
056407                IF 17/\L=5 THEN L:=0 FI        % COMPARE NOT IMPLEMENTED
056415             FI
056415             *1BANK
056416             X:=17/\L; NEWST(X)\/X             % UPDATE ERROR BITS
056422             *2BANK
056423          ELSE
056424             T SHZ 11=:L; 100020               % SERIOUS ERROR
056427          FI
056427
056427          IF A=:SVXRG.HSTAT BIT 4 THEN
056433             L BONE 4
056434             T:=L=:SCOSS=:X.XSTAT              % ERROR INFORMATION TO SWAPPER
056437             T:=X.ABFUN=:X.DMTRG               % SAVE T-REGISTER IF ERROR
056441             IF A<0 AND X.DQOPC BIT 3SERR THEN
056445                A:=B; CALL PHLOG; A=:9XDV      % DEVICE NUMBER
056450                SVXRG.ABFUN=:9XFU              % FUNCTION
056453                A SHZ -6/\7=:9XUN              % DEVICE UNIT
056456                X.MEMAD=:9XMA                  % MEMORY ADDRESS
056460                X.ABPA2=:9XDA; X.ABP32=:9XTA   % DISK ADDRESS AND AMOUNT
056464                SCOSS=:9XST; X:=X.RTRES        % HARDWARE STATUS AND PROGRAM
056467                *1BANK
056470                CALL 9FLEX(9XER,12)            % REPORT ERROR
056473                *2BANK
056474             FI
056474          FI
056474
056474          IF SVXRG.DQOPC BIT 3SNTR THEN
056500             SCOSS=:X.HSTAT                    % RETURN ORIGINAL STATUS
056502          FI
056502          *IOF
056503          CALL TO11Q                           % RETURN TO CALLER
056504          *ION
056505          SVTAD; X:=SVXRG; GO SVLRG
056510   *)FILL
056516
056516   %
056516   % OPERATION TYPE CONTROLL WORDS
056516   %
056516   @ICR;
056516   INTEGER ARRAY OPTYP:=
056516         (100004, 101004, 100004, 100004, 110004, 000000, 104004, 000000,
056526          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
056536          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
056546          000000, 000000, 000000, 000000, 104004, 104004, 044000, 044000,
056556          000000, 104017, 104404, 012004, 013004, 000000, 000000, 000000,
056566          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
056576          110004, 111004, 110004, 110004, 000000, 000000, 110004, 000000,
056606          000000, 000000, 000000, 134002, 074004, 134002, 000000, 000000);
056616   @CR;
056616
056616   INTEGER SAVEX
056617
056617   SCSDISK:
056617          A:=L=:X.NFUNC                        % SAVE RETURN ADDRESS
056621   *"8MPRF 8SCSI
"056621          CALL DIALO; 0/\0                     % MON PERFO DISK UTILIZATION
056623   *"8SCSI
"056623          X.ABFUN; X=:SAVEX:=77/\A
056627          *1BANK
056630          OPTYP(X)
056631          *2BANK
056632          IF A=:SAVEX.DQOPC=0 THEN
056635             T:=ILAOP; GO FAR ERR1             % ILLEGAL OPERATION
056637          FI
056637          IF A=:L NBIT 3DPA2 THEN
056642             X.ABP21=:D                        % CONVERT TO DOUBLE DISK ADDRESS
056644             X.ABFUN SHZ -11/\7
056647             AD=:X.ABPA2
056650          FI
056650          IF L NBIT 3DPA3 THEN
056652             X.ABP31=:X.ABP32; 0=:X.ABP31      % CONVERT TO DOUBLE AMOUNT
056655          FI
056655
056655          IF X.ABFUN SHZ -6/\7>3 OR X:=PUNDF(A)=0 THEN
056667             X:=SAVEX; T:=NOLUN; GO FAR ERR1   % NO UNIT DF GENERATED
056672   *)FILL
056676          FI
056676
056676          X=:B:=SAVEX                          % B=UNIT DF, X=DAQ
056700          IF L NBIT 3SPES THEN
056702             IF L BIT 3PART THEN
056704                X.ABPA2; A/\377; AD=:ABPA2     % ORIGINAL ADDRESS
056707                IF X.ABP21 SHZ -10>NPART-1 GO ERR2  % PARTITION INDEX
056715                A*6; T:=CMAD1; X:=CMAD2+A; *LDATX   % PARTITION CONTROLL WORD
056722                IF L BIT 3WRITE THEN
056724                   IF A NBIT 15 GO ERR2        % NOT WRITE ACCESS
056726                ELSE
056727                   IF A NBIT 16 GO ERR2        % NOT READ ACCESS
056731                FI
056731                *LDDTX 40                      % PARTION LENGTH
056732                AD=:ABPA3; *LDDTX 20           % LOWER LIMIT OF PARTITION
056734                T:=ABP22; D+T                  % ADD LOW LIMIT OF ACCESS
056736                T:=ABP21; *RADD ST ADC DA
056740                AD=:SAVEX.ABPA2                % ACTUAL ADDRESS
056742                ABPA2; T:=X.ABP32; D+T; A:=A+C % ADDRESS + AMOUNT
056746                T:="ABPA3"+B
056750                CALL COMPD; IF A>0 GO ERR2     % CHECK WITHIN BOUNDARIES
056753             ELSE
056754                X.ABPA2                        % DISK ADDRESS
056755                T:=X.ABP32; D+T; A:=A+C        % ADD AMOUNT
056760                T:="UHLIM"+B
056762                CALL COMPD; IF A>0 GO ERR2     % CHECK WITHIN BOUNDARIES
056765             FI
056765          ELSE
056766             X.TYPCO BONE SSEEK=:X.TYPCO       % SORT POSSIBLE
056771          FI
056771
056771   % --- DISK SORTING
056771          MIN SUNOP; 0/\0                      % NUMBER OF OPERATIONS
056773          IF SLINK><0 THEN
056775             X:=:B; CALL DSORT; GO SWT11       % SORT IN QUEUE
057000          FI
057000          GO NEWOP
057001
057001
057001   ERR2:  ULINK=:B; T:=BADPA                   % ILLEGAL PARAMETER
057004
057004   ERR1:  CALL FAR RETOP; GO SWT11             % TERMINATE OPERATION
057006   *)FILL
057016
057016   NEWOP: X=:SLINK; 0=:X.NLINK                 % START NEW OPERATION
057020          X.RTRES=:ULINK.STPRW                 % SET ACCESS OWNER
057023          IF SLINK.DQOPC=:SCOCW NBIT 3SPES THEN
057030             X.ABPA2=:CHADD                    % CURRENT HEAD ADDRESS
057032          ELSE
057033             IF 77/\X.ABFUN=6 THEN
057040                T:=0; "0"; GO FAR RETEX        % DUMMY FUNCTION
057043             ELSE
057044             IF A=36 THEN
057047                T:=X.MEMA1; X:=X.MEMA2; *LDXTX % RETURN DISK LAYOUT FOR INDEX
057052                IF X<<="MAXDI" AND DISPE(X)><0 THEN
057057                   T:=SLINK.MEMA2; X:=X.MEMA1
057062                   A=:D:=11=:L; *MOVAP
057066                   T:=0
057067                ELSE
057070                   T:=BADPA
057071                FI
057071                "0"; GO FAR RETEX
057073             ELSE
057074             IF A=42 THEN
057077                X.MEMAD=:MEMAD; X.ABFUN=:ABFUN
057103                0=:ABP31; 100=:ABP32
057106                SCDFA.SUTYP BZERO 5SCIN=:X.SUTYP
057112             FI FI FI
057112          FI
057112          TACNS=:TACOU; X:=SCDFA:=:B
057116
057116   RETRY: DO
057116             IF SUTYP NBIT 5SCIN AND X.SCOCW NBIT 3SNTR THEN
057124                IF A BIT 3SF42 THEN
057126                   42=:X.ABFUN
057130                ELSE
057131                   36=:X.ABFUN
057133                FI
057133                DO
057133                   T:=X; CALL SCSID; GO FAR ERREX; CALL ERRFATAL
057137                   WHILE D:=A BZERO 17=6 OR =13
057147                   MIN X.TACOU
057150                OD
057151                WHILE D<=1
057154                IF SUTYP SHZ -10><0 THEN
057157                   T:=TYPER; GO FAR ERREX      % ILLEGAL DEVICE TYPE
057161                FI
057161             FI
057161             IF X.SCOCW BIT 3SF42 THEN
057164                177700/\X.ABFUN=:X.ABFUN; L:=X      % INDICATE READ
057170                T:=X.MEMA1; X:=X.MEMA2; *LDDTX 10   % ADDRESS OF CONTROLL RECORD
057173                AD=:L.ABPA2; 0=:X.ABP31; 1=:X.ABP32
057200                X.MEMAD; T:=1000; D+T; A:=A+C       % INCREASE MEMORY ADDRESS
057204                AD=:X.MEMAD; T:=X
057206             ELSE
057207                T:=X.SLINK                     % PARAMETER POINTER
057210             FI
057210
057210   % CALL DRIVER
057210             377/\X.SCOCW; CALL SCSID; GO FAR ERREX; CALL ERRFATAL
057215             WHILE D:=A BZERO 17=6 OR =13      % UNIT ATTENTION OR ABORTED
057225             MIN X.TACOU
057226          OD
057227          GO FINEX
057230   *)FILL
057240
057240   ERREX: IF PFAIL=T OR SBRST=T OR LIRST=T THEN
057251             MIN X.TACOU; GO FAR RETRY         % ATTEMPT RETRY
057253          FI
057253          X=:B; 20; GO RETEX                   % INDICATE ERROR
057256
057256   INTEGER LOOPC
057257
057257   FINEX: X=:B:=SLINK                          % OK RETURN
057261          IF T:=X.DQOPC BIT 3SF42 THEN
057264             IF A=:X.HSTAT BZERO 17<=1 THEN
057271                T:=SCCLR; *EXR ST              % CLEAR CACHE
057273                T:=MEMA1; X:=MEMA2; *LDATX 00
057276                A SHZ -10=:NPART=:L:=-1000=:LOOPC; D:=0
057304                FOR LOOPC DO
057304                   *LDATX 00
057305                   D XOR A; X+1
057307                OD
057311                IF D><0 OR L<=2 OR L>"NCOPA" THEN
057321                   T:=NOCRC; GO FAR RETEX      % NO CONTROLL RECORD
057323                FI
057323                NPART*6=:L; MEMAD; T:=2; D+T; A:=A+C
057332                X:=CMAD1; T:=CMAD2; *MOVPP     % MOVE TO BUFFER AREA
057335                T:=CMAD1; X:=CMAD2; *LDDTX 40  % RETURN DATA AREA SIZE
057340                T:=SLINK.MEMA1; X:=X.MEMA2; *STDTX 10
057344                AD=:UHLIM; 36; *STATX 00
057347                SLINK.HSTAT
057351             FI
057351          FI
057351          T:=0
057352
057352   RETEX: B=:D; X:=ULINK:=:B:=X.SLINK
057356          0=:STPRW; CALL FAR RETOP             % TERMINATE OPERATION
057360          B:=D; 0=:SLINK; SUNOP-1=:SUNOP
057365          IF X:=SCLINK><0 THEN
057367             IF X.NLINK=:SCLINK=0 THEN
057372                0=:PLELE                       % LAST ELEMENT
057373             FI
057373             IF PLHAD=X THEN
057376                0=:PLHAD                       % CURRENTLY LAST IN DIRECTION
057377             ELSE
057400             IF A=0 THEN
057401                PLELE=:PLHAD; MIN MOVME; 0/\0  % CHANGE DIRECTION
057405             FI FI
057405             GO FAR NEWOP
057406          FI
057406          GO SWT11
057407   RBUS
057417
057417
057417   %==============================================================================
057417   %        S C D T R
057417   %
057417   % SCDTR: DRIVER ON MPIT FOR THE COLD-START AND RESTART-SYSTEM COMMANDS
057417   %
057417   %
057417   %
057417   SUBR SCDTR, SCTIO
057417
057417   SCDTR: T=:ABFUN:=L=:"TRLREG"
057422          AD=:ABPA2; 0=:ABP31; X=:ABP32
057425          SCIDN SHZ -4; CALL LOGPH; A:=:B
057431          X:=SCDVD(0)+"SDLEN"; A=:X.SUDAQ
057435          IF NCROK><0 OR "SCWTI"><"ILOOP" THEN
057443             T=:"SCWTI"; 0=:X.SUTHS=:X.SUWQP
057446             0=:BUSFL=:SCTQP=:SCWAQ=:SCCSU=:NCROK=:SCRCO
057454             "4\0"; CALL SCLLD; GO ERREX; CALL ERRFATAL
057460          FI
057460          X=:B:=X.SUDAQ
057462          DO
057462             44; T:=X; CALL SCSID; GO ERREX; CALL ERRFATAL
057467             WHILE A/\17=6 OR =13
057476          OD
057477          IF A<=1 THEN X=:B:=0; "TRLREG"+2=:P FI
057507
057507   ERREX: X=:B:=20; GO TRLREG
057512
057512   ILOOP: IF SCBTU=0 THEN -62=:SCBTU FI        % 50 BTU'S IN ONE SECOND
057516          *IOX 12                              % READ RT CLOCK STATUS
057517          IF A BIT 3 THEN
057521             20000; *IOX 13                    % REMOVE CLOCK INTERRUPT
057523             MIN SCBTU; GO CKINT               % ONE SECOND ELAPSED ?
057525             IF TMR><0 THEN
057527                MIN TMR; GO CKINT; GO SCTIO    % TIME OUT ?
057532             FI
057532          FI
057532   CKINT: GO DRIVER                            % ACTIVATE INTERRUPT HANDLER
057533
057533   RBUS
057544
057544   %==============================================================================
057544   %        S C S T R E A M
057544   %
057544   % LEVEL 11 ROUTINE TO PERFORM TRANSFERS ON SCSI STREAMERS
057544   %
057544   %
057544   %    FUNCTIONS
057544   %
057544   %           0: READ
057544   %           1: WRITE
057544   %           2: READ PARITY
057544   %           3: COMPARE
057544   %           7: ERASE
057544   %          10: ADVANCE THROUGH EOF
057544   %          12: WRITE EOF
057544   %          13: REWIND
057544   %          16: ADVANCE RECORDS
057544   %          17: UNLOAD
057544   %          20: READ STATUS (TEST UNIT READY)
057544   %          23: SELECT DENSITY
057544   %          24: READ LAST STATUS
057544   %          25: READ TAPE STATUS (ERROR COUNTERS)
057544   %          30: LOAD
057544   %          31: RESET DEVICE (BUS DEVICE RESET)
057544   %          34: RESERVE DEVICE
057544   %          35: RELEASE DEVICE
057544   %          37: READ EXTENDED STATUS
057544   %          42: READ FORMAT
057544   %          46: RETURN INTERFACE TYPE (3=SCSI STREAMER)
057544   %          54: COPY
057544   %          70: RETENSION
057544   %          73: TEST UNIT READY
057544   %          74: EXECUTE USER SPECIFIED SCSI COMMAND BLOCK
057544   %          75: INQUIRY (READ DEVICE TYPE)
057544   %          76: ADVANCE TO END OF RECORDED AREA
057544   %
057544   SUBR SCSTREAM
057544
057544   DISP -46
057544      INTEGER SRERS, SRERC      % READ ERROR COUNTERS
057544      INTEGER SWERS, SWERC      % WRITE ERROR COUNTERS
057544   PSID
057544
057544   % DISP -42; INTEGER CERRCODE; PSID
057544
057544   DISP -41
057544      INTEGER CPFUN,CPDEV,CPSTS,CPBLS
057544      INTEGER CPAM1, CPAM2
057544      DOUBLE CPAMT=CPAM1
057544      INTEGER SABFU, SMEM1, SMEM2, SAB21, SAB22, SAB31, SAB32
057544      DOUBLE SMEMA=SMEM1, SABP2=SAB21, SABP3=SAB31
057544      INTEGER OPSTA
057544         SYMBOL 4SRUN=0         % STREAMER ACTIVE
057544         SYMBOL 4SSTA=1         % STATUS RETURNED
057544         SYMBOL 4SRES=2         % DEVICE RESERVED
057544         SYMBOL 4SINI=3         % INITIALIZATION PERFORMED
057544         SYMBOL 4SMSL=4         % MODE SELECT PERFORMED
057544         SYMBOL 4SSTP=5         % REWIND ERROR STATUS PENDING
057544         SYMBOL 4SUAP=10        % UNIT ATTENTION PENDING
057544      INTEGER CUROP, STSTA, P3LUN, CFORM, REWST
057544      INTEGER SCLES=DRIVER      % LAST ERROR STATUS
057544   PSID
057544
057544   SYMBOL 9SAMT=15   % FIXED AMOUNT (IN BITS 16 AND 17)
057544   SYMBOL 9SSWA=14   % SINGLE WORD AMOUNT
057544   SYMBOL 9SRRA=13   % RETURN RESULTING AMOUNT TO USER
057544   SYMBOL 9SCRS=12   % CLEAR PENDING REWIND ERROR STATUS
057544   SYMBOL 9SRUA=11   % REMOVE UNIT ATTENTION
057544   SYMBOL 9SIUA=10   % IGNORE UNIT ATTENTION
057544   SYMBOL 9SSPC=7    % SPECIAL COMMAND
057544
057544
057544
057544   % EXECUTE MODE SENSE
057544
057544   MDSEN: 700/\X.ABFUN\/25=:X.SABFU; 14; GO FELLS
057552
057552   % EXECUTE MODE SELECT FOLLOWING MODE SENSE
057552
057552   INTEGER MSXRG
057553
057553   MDSEL: X=:MSXRG; T:=X.CMAD1; X:=X.CMAD2     % PHYSICAL ADDRESS OF BUFFER
057556          A SHZ 10=:D; *LDATX 20
057561          A/\377\/D; *STATX 20                 % STORE DENSITY
057564          10010; *STZTX 00; STATX 10           % SENSE HEADER
057567          *STZTX 30; STZTX 40                  % ZERO BLOCKS
057571          IF SUTYP NBIT 5SFBM THEN
057574             2000; *STATX 50                   % BLOCK SIZE 1024 BYTES
057576          FI
057576          700/\MSXRG.ABFUN\/23=:X.SABFU:=14    % MODE SELECT FUNCTION
057604
057604   % EXECUTE MODE SENSE/MODE SELECT COMMAND
057604
057604   FELLS: AD SHZ -20=:X.SABP3                  % NUMBER OF BYTES
057606          X.CMADR=:X.SMEMA                     % BUFFER ADDRESS
057610          T:="SABFU-14"+X; "4"; GO SCSID       % ACTIVATE DRIVER
057614   *)FILL
057624
057624   @ICR;
057624   INTEGER ARRAY OPTYP:=
057624         (014010, 014007, 014010, 014010, 000000, 000000, 000000, 000010,
057634          060013, 000000, 060007, 000107, 000000, 000000, 014013, 021107,
057644          000004, 000000, 000000, 010304, 007777, 017777, 000000, 000000,
057654          063007, 003000, 000000, 000000, 000705, 000705, 000000, 007777,
057664          000000, 000000, 000304, 000000, 000000, 000000, 007777, 000000,
057674          000000, 000000, 000000, 000000, 000214, 000000, 000000, 000000,
057704          004010, 004007, 004010, 004010, 000000, 000000, 000000, 000000,
057714          162110, 000000, 000000, 000004, 000014, 000404, 000013, 000000);
057724   @CR;
057724   SCSTREAM:
057724
057724   % --- FETCH PARAMETERS
057724          X.MEMAD=:MEMAD; X.ABPA2=:ABPA2
057730          X.ABPA3=:ABPA3; X.ABAD3=:ABAD3
057734          X.ABFUN=:ABFUN; X:=77/\A
057740          *1BANK
057741          OPTYP(X); X:=B                       % OPERATION CONTROLL WORD
057743          *2BANK
057744          IF A=:X.CUROP BIT 9SSWA THEN
057747             X.ABPA3 SHZ -20=:X.ABPA3          % SINGLE WORD AMOUNT
057752          ELSE
057753          IF A BIT 9SAMT THEN
057755             AD SHZ -36=:X.ABPA3               % SET AMOUNT
057757          FI FI
057757          IF X.OPSTA BIT 4SRUN GO FAR SWT11    % OPERATION ALLREADY IN PROGRESS
057762
057762   NEWOP: 3\/X.OPSTA=:X.OPSTA; 0=:X.CERRCODE   % INDICATE OPERATION STARTED
057766          X.ABFUN SHZ -6/\7=:T:=X.SCDFA
057773          CALL SCGLN; GO FAR ERREX             % GET LUN DATAFIELD
057775          A:=B=:X.P3LUN
057777          X.CUROP=:X.SCOCW; 0=:X.CUROP
060002          IF A=0 THEN
060003             T:=ILAOP; GO FAR ERREX            % ILLEGAL OPERATION
060005          FI
060005          IF A BIT 9SSPC THEN
060007             IF 77/\X.ABFUN=24 THEN
060014                X.STSTA; B:=X; GO FAR RETEX    % READ LAST STATUS
060017             ELSE
060020             IF A=54 THEN
060023                CALL ICCOM; GO FAR ERREX       % INITALIZE COPY COMMAND
060025             ELSE
060026             IF A=46 THEN
060031                X.ABAD3; T:=3; *DEPO           % SET SCSI STREAMER
060034                "0"; B:=X; GO FAR RETEX
060037             ELSE
060040             IF A=37 THEN
060043                T:=X; "0"; CALL SCSID; GO FAR ERREX; CALL ERRFATAL
060050                B:=X; GO FAR RETEX
060052             ELSE
060053             IF A=25 THEN
060056                T:=0; X.ABAD3; *DEPO           % ZERO AMOUNT
060061                IF X.ABP32<4 THEN
060065                   T:=BADPA; GO FAR ERREX      % BUFFER TO SMALL
060067                FI
060067                X.ABAD3; *DEPO                 % AMOUNT EQUALS 4
060071                B:=X; T:=MEMA1; X:=MEMA2
060074                SRERC=:D:=SRERS; *STDTX 00     % READ STATUS
060100                SWERC=:D:=SWERS; *STDTX 20     % WRITE STATUS
060104                0=:SRERC=:SRERS=:SWERC=:SWERS  % ZERO COUNTERS
060110                "0"; GO FAR RETEX
060112   *)FILL
060123             FI FI FI FI FI
060123          FI
060123          IF X.OPSTA BIT 4SSTP THEN
060126             A BZERO 4SSTP=:X.OPSTA            % CLEAR PENDING REWIND STATUS
060130             IF X.SCOCW NBIT 9SCRS THEN
060133                X.REWST; GO FAR RETOP          % RETURN ERROR FROM REWIND
060135   *)FILL
060136             FI
060136          FI
060136          X.TACNS=:X.TACOU                     % RETRY COUNT
060140
060140   RETRY: IF X.OPSTA BIT 4SUAP THEN
060143             IF T:=X.SCOCW NBIT 9SIUA THEN
060146                IF T NBIT 9SRUA THEN
060150                   "26"; GO FAR FINOP          % UNIT ATTENTION PENDING
060152                FI
060152                A BZERO 4SUAP=:X.OPSTA
060154             FI
060154          FI
060154          IF A NBIT 4SINI THEN
060156             IF A BIT 4SRES THEN "34" ELSE "36" FI
060163             A=:X.SABFU:=0; T:="SABFU-14"+X
060167             CALL SCSID; GO FAR ERREX; CALL ERRFATAL
060172             IF A><0 GO FAR CHSEN              % CHECK SENSE
060174             IF SUTYP SHZ -10><1 THEN
060201                T:=TYPER; GO FAR ERREX         % NOT DIRECT ACCESS DEVICE
060203             FI
060203             X.OPSTA BONE 4SINI=:X.OPSTA
060206          FI
060206          IF T:=X.OPSTA NBIT 4SMSL THEN
060211             CALL FAR MDSEN; GO FAR ERREX; CALL ERRFATAL
060214             IF A=0 THEN
060215                CALL GDENS                     % GET DENSITY
060216                CALL FAR MDSEL; GO FAR ERREX; CALL ERRFATAL
060221             FI
060221             IF A><0 THEN
060222                IF T:=X.SCOCW NBIT 9SIUA GO FAR CHSEN
060225             ELSE
060226                IF SUTYP NBIT 5SFBM THEN
060231                   T:=TYPER; GO FAR ERREX
060233                FI
060233                X.OPSTA BONE 4SMSL=:X.OPSTA
060236             FI
060236          FI
060236          T:=X                                 % PARAMETER POINTER
060237          IF X.SCOCW BIT 9SSPC THEN
060242             IF 77/\X.ABFUN-54=0 THEN
060246                CALL BCCOM; GO FAR ERREX       % BUILD COPY COMMAND
060250             ELSE
060251             IF A-"42-54"=0 THEN
060253                CALL FAR MDSEN; GO FAR ERREX; CALL ERRFATAL
060256                IF A><0 GO CHSEN; CALL GDENS   % GET DENSITY
060260                T:=X.ABA31; X=:D:=X.ABA32; *STATX 00  % RETURN FORMAT
060264                X:=D; "0"; GO FAR RETOP
060267             ELSE
060270             IF A-"23-42"=0 THEN
060272                CALL FAR MDSEN; GO FAR ERREX; CALL ERRFATAL
060275                IF A><0 GO CHSEN; X.ABP32      % GET DENSITY
060277                CALL FAR MDSEL; GO FAR ERREX; CALL ERRFATAL
060302                IF A><0 GO CHSEN; GO FAR RETOP
060304   *)FILL
060317             FI FI FI
060317          FI
060317
060317          377/\X.SCOCW; CALL SCSID; GO ERREX; GO IMRET
060324
060324   CHSEN: IF A><0 THEN
060325             K:="0"
060326             IF A=:L:=17/\L=6 THEN             % UNIT ATTENTION
060334                177007/\X.OPSTA BONE 4SUAP=:X.OPSTA
060340                0=:X.CFORM; K:="1"
060342             ELSE
060343             IF A=12 THEN
060346                A:=L; CALL CCOPY; A=:L         % COPY ABORTED
060351             ELSE
060352             IF A=13 THEN
060355                K:=1                           % ABORTED COMMAND
060356             ELSE
060357             IF A=1 OR A=3 THEN
060365                IF A=:D=3 THEN D BONE 4 FI     % INDICATE ERROR
060372                IF 77/\X.ABFUN =61 OR =1 OR =12 THEN
060405                   X.SWERS\/D=:X.SWERS         % WRITE ERROR
060410                   MIN X.SWERC; 0/\0
060412                ELSE
060413                   X.SRERS\/D=:X.SRERS         % READ ERROR
060416                   MIN X.SRERC; 0/\0
060420                FI
060420             FI FI FI FI
060420             IF K THEN MIN X.TACOU; GO FAR RETRY FI
060424             A:=L
060425          FI
060425          GO FINOP
060426
060426   IMRET: X:=:B; OPSTA BZERO 4SSTA=:OPSTA
060432          0=:HSTAT; CALL RTACT; GO SWT11
060435
060435   ERREX: T SHZ 11; 20\/T                      % ERROR IN DRIVER
060440
060440   RETOP: B:=X; GO FAR FINEX
060442
060442   *)FILL
060452
060452
060452   INTEGER OKSTA(0)
060452   @ICR;
060452   INTEGER ARRAY NEWST:=
060452         (000400, 000400, 000020, 100420, 000020, 000020, 000020, 000020,
060462          100420, 000020, 000020, 000020, 000020, 100420, 100420, 000020);
060472   @CR;
060472
060472   INTEGER AMNT1, AMNT2
060474   DOUBLE AMNTD=AMNT1
060474
060474   FINOP: X:=:B
060475          IF T:=SCOCW BIT 9SSPC THEN
060500             A=:D:=77/\ABFUN-54:=:D
060505             IF D=0 THEN
060507                CALL TCCOM; GO FAR FINEX       % TERMINATE COPY
060511             FI
060511          FI
060511          IF A=:L><0 THEN
060513             IF A BIT 5 THEN A\/100420 FI      % ILI
060516             IF A BIT 6 THEN A\/000420 FI      % EOM
060521             IF A BIT 7 THEN A\/100420 FI      % EOF
060524             *1BANK
060525             X=:D:=17/\A; A\/NEWST(X); X:=D
060532             *2BANK
060533             IF T BIT 9SRRA THEN
060535                IF A BIT 4 AND A BIT 10 THEN
060541                   IF A:=:L<0 THEN
060543                      X=:T:=P3LUN.SUSI1:=:T    % SHIFT INSTRUCTION
060547                      ABPA3; *EXR ST           % ADJUST TO PHYSICAL RECORD SIZE
060551                      T:=X.ABP32; *RSUB ST DD
060553                      T:=X.ABP31; *RADD ST CM1 ADC DA
060555                      T:=P3LUN.SUSI2; *EXR ST  % ADJUST TO LOGICAL RECORD SIZE
060560                   ELSE
060561                   IF L BIT 17 THEN
060563                      A:=0; D:=0               % INFO BYTES WAS EXPECTED
060565                   ELSE
060566                      ABPA3
060567                   FI FI
060567                   IF T:=SCOCW BIT 9SSWA THEN
060572                      A:=D; T:=ABA31; X:=ABA32; *STATX
060576                   ELSE
060577                      T:=ABA31; X:=ABA32; *STDTX
060602                   FI
060602                   A:=L; T:=SCOCW
060604                FI
060604             FI
060604          ELSE
060605             OKSTA                             % OK STATUS
060606          FI
060606          IF T NBIT 9SRRA THEN
060610             A BZERO 10                        % NO AMOUNT
060611          FI
060611          IF A=:STSTA NBIT 4 THEN
060614             IF T BIT 9SSPC THEN
060616                IF 77/\ABFUN=34 THEN
060623                   OPSTA BONE 4SRES=:OPSTA
060626                ELSE
060627                IF A=35 THEN
060632                   OPSTA BZERO 4SRES=:OPSTA
060635                FI FI
060635                STSTA
060636             FI
060636          FI
060636
060636   FINEX: IF A=:STSTA BIT 4 THEN
060641             A=:SCLES; CALL SCDTS              % DETERMINE ERROR CODE
060643          FI
060643
060643   RETEX: IF T:=OPSTA BIT 4SSTA THEN
060646             A=:HSTAT; CALL RTACT              % RETURN TO USER
060650          ELSE
060651             IF A=:REWST BIT 4 THEN
060654                OPSTA BONE 4SSTP=:OPSTA        % INDICATE PENDING ERROR
060657             FI
060657             IF CUROP><0 THEN
060661                X:=B; GO FAR NEWOP             % NEW OPERATION WAITING
060663             FI
060663          FI
060663          177774/\OPSTA=:OPSTA; GO SWT11
060667   *)FILL
060700
060700   % LOCAL ROUTINE TO INITIALIZE COPY COMMAND
060700   % B = LUN DATAFIELD, X = DEVICE DATAFIELD
060700
060700   INTEGER POINTER SAVL=?
060700   INTEGER SAVB=?
060700
060700   ICCOM: A:=L=:"SAVL"; X:=:B=:SAVB
060704          T:=MEMA1; X:=MEMA2; *LDDTX 00
060707          A=:CPFUN:=D=:CPDEV
060712          IF SAVB.SUTYP BIT 5SFBM THEN
060716             X.SURSZ                           % RECORD SIZE
060717          ELSE
060720             T:=MEMA1; X:=MEMA2; *LDATX 20     % USER SPECIFIED BLOCK LENGTH
060723             T:=BADPA; A SHZ 1; IF M GO SAVL   % RECORD SIZE IN BYTES
060727          FI
060727          A=:CPBLS; 0=:CPAM1=:CPAM2            % BLOCK SIZE AND COPY AMOUNT
060732          CPDEV SHZ -4; CALL LOGPH; X:=B       % DISK DATAFIELD
060736          IF B:=A<"SCDDB" OR B>="SCDDE" THEN
060745             T:=COPNP; GO SAVL                 % NOT SCSI DISK
060747          FI
060747          IF SCIDN SHZ -4 >< X.SCIDN SHZ -4 THEN
060755             T:=COPNP; GO SAVL                 % NOT ON SAME BUS AS STREAMER
060757          FI
060757          X.CPDEV; X=:L:=17/\A
060763          IF X>3 OR X:=PUNDF(X)=0 THEN
060771             X:=L; T:=BADPA; GO SAVL           % NO SUCH LUN
060774          FI
060774          X:=:L; X.ABPA2; T:=X.ABP32; D+T      % DISK EXTENT
061000          T:=X.ABP31; *RADD ST ADC DA
061002          T:="UHLIM"+L; CALL COMPD             % COMPARE WITH DATA LIMIT
061005          IF A>0 THEN
061007             T:=BADPA; GO SAVL
061011          FI
061011          17/\X.CPDEV=:T:=SCDFA                % GET DISK LUN DATAFIELD
061015          CALL SCGLN; GO SAVL
061017          SAVB:=:B=:X.P3LUN
061022          MIN "SAVL"; 0/\0; GO SAVL
061025   *)FILL
061033
061033   INTEGER POINTER SAVL
061034   INTEGER SAVB
061035
061035   INTEGER FCST1,FCST2,FCST3,FCST4,FCST5,FCST6,FCST7,FCST8
061045   DOUBLE FCS12=FCST1, FCS34=FCST3, FCS56=FCST5, FCS78=FCST7
061045   TRIPLE FCS13=FCST1
061045
061045   INTEGER CCMD1:=0,CCMD2:=0,CCMD3:=0,CCMD4:=0,CCMD5:=0,CCMD6:=0
061053   DOUBLE CCM23=CCMD2
061053   TRIPLE CCM13=CCMD1
061053
061053   % LOCAL ROUTINE TO BUILD COPY COMMAND
061053   % B = LUN DATAFIELD, X = DEVICE DATAFIELD
061053
061053   BCCOM: X.P3LUN:=:B=:SAVB:=L=:"SAVL"
061060          SUDLU SHZ -14 SHZ 5=:D               % SCSI DEVICE NUMBER FOR DISK
061064          7/\X.CPDEV; D\/A SHZ 3               % DISK LUN
061070          7/\X.SCIDN; D\/A SHZ 5               % SCSI DEVICE NUMBER FOR TAPE
061074          700/\X.ABFUN SHZ -6; D\/A            % TAPE LUN
061100          IF X.CPFUN BIT 2 THEN
061103             D SHR 10; T:=4000                 % TO DISK
061105          ELSE
061106             T:=0                              % FROM DISK
061107          FI
061107          A:=0; TAD=:FCS13                     % COPY PARAMETERS
061111          X.CPBLS=:FCST4                       % BLOCK SIZE
061113   % DISK ADDRESS
061113          X.ABPA2; T:=SUSI1; *EXR ST
061116          T:=X.CPAM2; D+T
061120          T:=X.CPAM1; *RADD ST ADC DA
061122   % AMOUNT
061122          AD=:FCS78:=X.ABPA3; T:=SUSI1; *EXR ST
061126          T:=X.CPAM2; D-T; T:=X.CPAM1; *RADD ST CM1 ADC DA
061132          AD=:FCS56; 20; AD SHZ -20=:X.SABP3
061136          700/\X.ABFUN\/74=:X.SABFU; 20=:D
061144          IF 373/\X.CPFUN=0 THEN
061147             T:=14000; D SHZ 10
061151          ELSE
061152          IF A=1 THEN
061155             T:=34400
061156          ELSE
061157          IF A=2 THEN
061162             T:=35002
061163          ELSE
061164             T:=BADPA; EXIT
061166          FI FI FI
061166          700/\X.ABFUN SHZ -1; T\/A
061172          A:=0; TAD=:CCM13
061174          T:=X.CMAD2; X=:B:=X.CMAD1
061177          10=:L; MPTPHPAGE; D:=0; AD SHR 12
061204          A+"FCST1-PITST"; AD SHR -20; *MOVPP
061207          X:=SAVB:=:B; AD=:X.SABP2             % COMMAND POINTER
061212          X.CMADR=:X.SMEMA; T:="SABFU-14"+X    % PARAMETER ADDRESS
061216          MIN "SAVL"; 0/\0; GO SAVL
061221   *)FILL
061233
061233   % LOAD A BYTE FROM I-O BUFFER (X=BYTE NUMBER)
061233
061233   INTEGER LBXRG
061234
061234   LBYTP: X=:LBXRG; A:=X SHZ -1
061237          T:=SMBP1; X:=SMBP2+A+SNSBS; *LDATX   % WORD ADDRESS
061244          IF X:=LBXRG BIT 0 THEN
061247             A/\377
061250          ELSE
061251             A SHZ -10
061252          FI
061252          EXIT
061253   *)FILL
061254
061254   % CHECK SENSE FOR COPY ABORTED
061254   % B = LUN DATAFIELD, X = DEVICE DATAFIELD
061254
061254   INTEGER SAVST=?, SAVEX=?
061254   INTEGER ILST1(0); *ILSEN@11
061255   INTEGER ILST2(0); *CPDER@11
061256   INTEGER POINTE CCLRG
061257
061257   CCOPY: T:=L=:"CCLRG"; X=:SAVEX; K:="0"
061263          A BONE 4=:SAVST\/ILST1=:X.CPSTS
061267          IF A>=0 OR  77/\X.ABFUN><54 GO TERCP % NOT COPY OR EXTENDED SENSE
061275          T:=X.CMAD1; X:=X.CMAD2; *LDDTX 40    % ORIGINAL AMOUNT
061300          T:=ABP32; D-T
061302          T:=ABP31; *RADD ST CM1 ADC DA
061304          T:=SAVEX.CPAM2; D+T
061307          T:=X.CPAM1; *RADD ST ADC DA
061311          AD=:X.CPAMT; T:=X.P3LUN.SUSI2; *EXR ST
061315          T:=SAVEX.ABA31; X:=X.ABA32; *STDTX   % RETURN AMOUNT TO USER
061321          X.CPSTS BONE 10=:X.CPSTS             % NEW STATUS
061324          X:=7; CALL LBYTP                     % ADDITIONAL SENSE LENGTH
061326          IF A+10=:D>SNSBR THEN D:=T FI        % RECEIVED SENSE LENGTH
061334          X:=10; CALL LBYTP                    % SOURCE SENSE
061336          IF A=0 THEN X+1; CALL LBYTP FI       % DESTINATION SENSE
061341          IF =0 OR A:=:D+3<D GO TERCP          % CHECK SUFFICIENT LENGTH
061346          X:=:D; CALL LBYTP                    % ORIGINAL SCSI STATUS BYTE
061350          IF A-2><0 GO TERCP; X+1; CALL LBYTP  % CHECK FOR STATUS 2
061354          IF A/\177-160><0 GO TERCP            % CHECK FOR EXTENDED SENSE
061357          X+2; CALL LBYTP                      % ORIGINAL SENSE KEY
061361          IF T:=SAVEX.CPFUN BIT 2 THEN D-1 FI  % CHECK ERROR SOURCE
061366          IF D=10 THEN A\/ILST2; K:="1" FI     % ERROR FROM DISK
061373          A\/420=:X.CPSTS                      % NEW STATUS
061375          IF A/\17=6 THEN                      % UNIT ATTENTION
061401             X.CPAMT
061402             IF A><0 AND D><0 THEN K:="0" FI   % CHECK FOR NOTHING TRANSFERED
061406          ELSE
061407          IF A=1 THEN
061412             X.TACOU-1=:X.TACOU; K:="1"        % CORRECTED ERROR
061416          ELSE
061417          IF A=13 THEN
061422             K:="1"                            % ABORTED COMMAND
061423          ELSE
061424             K:="0"
061425          FI FI FI
061425   TERCP: SAVST BZERO 17; X:=SAVEX; GO CCLRG   % RETURN STATUS
061431
061431   INTEGER SAVST, SAVEX
061433
061433   % TERMINATE COPY OPERATION
061433   % B = DEVICE DATAFIELD, A = SENSE
061433
061433   TCCOM: X=:SAVEX
061434          IF A=:SAVST=0 THEN
061436             ABPA3
061437             T:=ABA31; X:=ABA32; *STDTX 00     % RETURN AMOUNT
061442             SAVST BONE 10                     % INDICATE AMOUNT VALID
061444          ELSE
061445             IF A/\17=12 THEN
061451                CPSTS                          % COPY ABORTED
061452             ELSE
061453                SAVST                          % OTHER ERROR
061454             FI
061454             A BONE 4
061455          FI
061455          X:=SAVEX; EXIT
061457   *)FILL
061462
061462   % ROUTINE TO DETERMINE WRITE PROTECT AND DENSITY
061462
061462   GDENS: X=:D
061463          T:=X.CMAD1; X:=X.CMAD2; *LDATX 00
061466          IF A SHZ -10-3>=0 THEN
061471             *LDATX 10; BLDA 170 DA       % WRITE PROTECT BIT TO K
061473             IF A/\377-10>=0 THEN
061476                *LDATX 20                 % DENSITY IN HIGH BYTE
061477             ELSE
061500                "0"                       % DENSITY NOT AVAILABLE
061501             FI
061501             A SHZ -10; *BSTA 170 DA      % NEW FORMAT
061503          ELSE
061504             "0"
061505          FI
061505          A=:D.CFORM; EXIT
061510   *)FILL
061511
061511   % ROUTINE TO DETERMINE STATUS (IN CERRCODE)
061511
061511   SCDTS: IF X:=CERRCODE=0 THEN
061514             X:=17/\A; X:=SCSTA(X)             % ERROR CODE
061517             IF X=0 AND D:=A SHZ 1 SHZ -12><0 THEN
061526                IF D=TYPER THEN
061531                   X:=240                      % ILLEGAL DEVICE TYPE
061532                ELSE
061533                IF D=ILAOP THEN
061536                   X:=201                      % ILLEGAL FUNCTION CODE
061537                ELSE
061540                IF D=BADPA THEN
061543                   X:=174                      % ILLEGAL PARAMETER
061544                ELSE
061545                IF D=ILNOD OR D=NOLUN THEN
061553                   X:=33                       % NO SUCH LOGICAL UNIT
061554                ELSE
061555                IF D=COPNP THEN
061560                   X:=3206                     % ILLEGAL REQUEST
061561                ELSE
061562                IF D=TRANE THEN
061565                   X:=141                      % TRANSFER ERROR
061566                ELSE
061567                IF D=SBUSY THEN
061572                   X:=3207                     % DEVICE BUSY
061573                ELSE
061574                IF D=RCONF THEN
061577                   X:=3210                     % RESERVATION CONFLICT
061600                ELSE
061601                IF D=NESER THEN
061604                   X:=3211                     % DEVICE DO NOT ANSWER
061605                ELSE
061606                   X:=232                      % DEVICE ERROR
061607                FI FI FI FI FI FI FI FI FI
061607             FI
061607             X=:CERRCODE                       % SINTRAN ERROR CODE
061610          FI
061610          EXIT
061611   RBUS
061621
061621   %=====================================================================
061621   %
061621   %                  S C S I D
061621   %
061621   %   CALL SEQUENCE:
061621   %
061621   %     JPL I (SCSID
061621   %     JMP   ERROR           % ERROR EXIT
061621   %     JMP   BUSY            % BUSY EXIT
061621   %     JMP   FINIS           % FINISHED EXIT
061621   %
061621   %     REGISTER CONTENTS WHEN ROUTINE IS CALLED:
061621   %
061621   %     T- POINTER TO ABSTR PARAMETER AREA
061621   %         ABFUN: BIT  0- 5: FUNCTION
061621   %                BIT  6- 8: LOGICAL UNIT (SUBUNIT UNDER EACH SCSI NODE)
061621   %                BIT  9-15: NOT USED
061621   %         MEMAD: MEMORY ADDRESS
061621   %         ABPA2: PARAMETER 2 (DOUBLE WORD)
061621   %         ABPA3: PARAMETER 3 (DOUBLE WORD)
061621   %
061621   %     X- POINTER TO DEVICE DATAFIELD
061621   %
061621   %     B- LOGICAL UNIT DATAFIELD
061621   %
061621   %     A- DRIVER FUNCTION CODE
061621   %                BIT  0- 3: LOG 2 OF MAX TIME (TIMEOUT)
061621   %                BIT     4: ==> USE SELECT WITHOUT "ATN"
061621   %                BIT     5: ==> DON'T USE DISCONNECT/RECONNECT
061621   %                BIT     6: ==> RETURN ON COMMAND ACCEPTED
061621   %                               (I.E. FIRST DISCONNECT)
061621   %
061621   %
061621   %     EXIT INFORMATION:
061621   %                 X & B REGISTERS UNCHANGED
061621   %
061621   %     ERROR EXIT:
061621   %                 T- REGISTER CONTAINS DRIVER STATUS
061621   %
061621   %     BUSY EXIT:
061621   %
061621   %     FINISHED EXIT:
061621   %                 A- IF SENSE RECEIVED:
061621   %                       BIT  0- 3: SENSE KEY
061621   %                       BIT     4: NOT USED (ZERO)
061621   %                       BIT     5: EOF
061621   %                       BIT     6: EOM
061621   %                       BIT     7: ILI
061621   %                       BIT  8-14: NOT USED (ZERO)
061621   %                       BIT    15: ONE
061621   %
061621   %
061621
061621   SUBR SCSID
061621
061621   SCSID: A=:X.HSTAT:=L=:X."FINISH":=B=:X.SCUDF
061626          T=:X.SCTRG:=:X; 77/\X.ABFUN; X:=T
061633          IF A=37 THEN
061636             CALL DOEXS                        % READ EXTENDED STATUS
061637             T:=X."FINISH"+2=:L:=0; EXIT
061644          ELSE
061645             IF SUTHS><0 THEN
061647                X=:T:="SUWQP-SCULI"+B          % START OF QUEUE
061652                DO WHILE X.SCULI><0; X:=A OD   % FIND END OF QUEUE
061656                T=:X.SCULI; 0=:T.SCULI         % INSERT ELEMENT
061661                SUDDF=:B; GO SCWTI             % RETURN TO INTERRUPT HANDLING
061664             FI
061664
061664   NEWOP:    X=:SUDAQ:=X.SCTRG
061666             X.ABFUN=:ABFUN; X.MEMAD=:MEMAD
061672             X.ABPA2=:ABPA2; X.ABPA3=:ABPA3
061676             SUDAQ.HSTAT=:SUICO; 0=:SUBWC
061702
061702   REPEAT:   IF 77/\ABFUN=31 GO FAR BDRST      % BUS DEVICE RESET
061707             IF A=74 THEN
061712                CALL GUSCB                     % USER SPECIFIED COMMAND
061713             ELSE
061714                IF A=42 OR =36 GO FAR INQUI    % AUTOMATIC INQUIRY
061722                IF A=23 OR =25 GO FAR MODES    % MODE SENSE/SELECT
061730                CALL CACOB                     % BUILD COMMAND BLOCK
061731             FI
061731
061731             CALL EXCOM; CALL SCEIO; GO FAR IMRET; X:=:B
061735
061735          FI
061735
061735   FINDR: IF SUSTA=:SUSTR><0 THEN
061740             IF A/\36=2 THEN
061744                GO FAR RQSEN                   % REQUEST SENSE
061745             ELSE
061746             IF A=10 THEN
061751                IF SUBWC=0 THEN -140=:SUBWC FI % BUSY RETRY COUNT
061755                X:=:B; T:=SBUSY; "3\1"
061760                MIN X.SUBWC; CALL SCLLD        % ATTEMPT WAIT
061762                CALL SCEIO; CALL ERRFATAL
061764                X:=:B; GO FAR REPEAT           % RETRY
061766             ELSE
061767             IF A=30 THEN
061772                T:=RCONF; GO ERREX             % RESERVATION CONFLICT
061774             ELSE
061775             IF A><4 AND ><20 AND ><24 THEN
062006                T:=UNSTA; GO ERREX             % UKNOWN STATUS
062010                *)FILL
062030             FI FI FI FI
062030             "0"                               % OK RETURN
062031          FI
062031
062031   FINEX: T:=0                                 % OK RETURN
062032
062032   RETEX: IF X:=SUDAQ><0 THEN
062034             A=:X.HSTAT; T=:X.SCTRG; 0=:SUDAQ  % SAVE STATUS
062037             IF T=0 THEN
062041                X."FINISH"+2=:X."FINISH"       % OK RETURN
062044             FI
062044             SCFQP=:X.SCULI; X=:SCFQP          % INSERT IN READY QUEUE
062047          FI
062047          IF SUTHS=0 AND X:=SUWQP><0 THEN
062053             X.SCULI=:SUWQP; GO FAR NEWOP      % START WAITING OPERATION
062056          FI
062056          GO SWT11                             % RETURN TO FINISHED QUEUE
062057   *)FILL
062062
062062   % ===== INTERMIDIATE RETURN
062062
062062   IMRET: IF X=:B:=SUDAQ><0 THEN X."FINISH"+1=:P FI
062070
062070          SUDDF=:B; GO SCWTI                   % RETURN TO INTERRUPT HANDLING
062073
062073   % ===== ERROR IN DRIVER
062073
062073   SCEIO: X=:B                                 % ERROR IN DRIVER
062074
062074   ERREX: "0"; GO RETEX                        % TERMINATE OPERATION
062076   *)FILL
062076
062076   % === INTERNAL RUTINE FOR REQUEST SENSE
062076
062076   INTEGER SSENS
062077
062077   RQSEN: CALL EXRQS; CALL SCEIO; CALL ERRFATAL; X:=:B
062103          IF 36/\SUSTA><0 THEN
062106             IF A=10 THEN                      % BUSY STATUS
062111                IF SUBWC=0 THEN -140=:SUBWC FI % BUSY RETRY COUNT
062115                X:=:B; T:=SBUSY; "3\1"
062120                MIN X.SUBWC; CALL SCLLD        % ATTEMPT WAIT
062122                CALL SCEIO; CALL ERRFATAL
062124                X:=:B; GO FAR RQSEN            % RETRY
062126             FI
062126             T:=RQSER; GO FAR ERREX            % ABORTED
062130          FI
062130          SNSBL SHZ 1 -SUSB2=:SNSBR            % NUMBER OF BYTES RECEIVED
062134          K:="0"; SCCLR; *EXR SA               % CLEAR CACHE
062137          T:=SMBP1; X:=SMBP2+SNSBS; *LDDTX 00  % READ SENSE
062143          A:=:D=:SSENS
062145          IF D SHZ -14=17 THEN
062151             K:="1"; A SHZ 10=:L
062154             T:=SMBP1; *LDDTX 20
062156             AD SHZ -10; A\/L; AD=:ABPA3
062161          ELSE
062162          IF D><7 THEN
062165             T:=ILSEN; GO FAR ERREX            % NOT EXTENDED SENSE
062167          FI FI
062167          SSENS SHZ -10; *BSTA 170 DA          % SENSE KEY
062172          IF T:=17/\A-6=0 THEN
062177             T:=SUTYP BZERO 5SCIN=:SUTYP       % FORCE INQUIRY
062202          FI
062202          GO FAR FINEX
062203   *)FILL
062214
062214   % === INTERNAL RUTINE FOR INQUIRY
062214
062214   INTEGER SMASK:=0; * *-1/1@5SCIN+^; *-1/1@5SCDA+^; *-1/1@5SREM+^
062215                     * *-1/1@5SFBM+^; *-1/1@5SVBS+^;*-1/177777-^
062215   INTEGER SADI=?
062215
062215   INQUI: SUTYP/\SMASK\/77400=:SUTYP           % ZERO OLD STATUS
062221          T:=SMBP1; X:=SMBP2                   % PHYSICAL ADDRESS OF COMMAND BUFFER
062223          11000; *STATX 00; STZTX 10           % COMMAND
062226          "SINBL" SHZ 11; *STATX 20            % ALLOCATION LENGTH
062231          *STZTX 30; STZTX 40; STZTX 50
062234          CALL EXINT; CALL SCEIO; CALL ERRFATAL; X:=:B
062240          IF SUSTA=:SUSTR/\36><0 GO FAR FINDR  % STATUS NOT ZERO !
062245          SADI=:SUSI3; SCCLR; *EXR SA          % STORE SHIFT INSTRUCTION
062251          T:=SMBP1; X:=SMBP2+SINBS; *LDATX 00
062255          A\/377/\SUTYP=:SUTYP                 % UPDATE DEVICE TYPE INFORMATION
062260          IF A SHZ -10=0 OR =3 OR =4 THEN
062270             SUTYP BONE 5SCDA=:SUTYP           % DIRECT ACCESS DEVICE
062273             22400                             % READ CAPACITY
062274          ELSE
062275          IF A=1 THEN
062300             2400                              % READ BLOCK SIZE
062301          ELSE
062302          IF A=177 THEN
062305             T:=NOLUN; GO FAR ERREX            % NO SUCH LUN
062307          ELSE
062310             SUSI3+1=:SUSI1; GO FAR INFIN      % SHIFT INSTRUCTIONS
062314   INTEGER SADI(0); *SAD 0
062315   *)FILL
062332          FI FI FI
062332          T:=SMBP1; X:=SMBP2; *STATX 00        % BUILD COMMAND BLOCK
062335          *STZTX 10; STZTX 20; STZTX 30; STZTX 40
062341          CALL EXINT; CALL SCEIO; CALL ERRFATAL; X:=:B
062345          IF SUSTA=:SUSTR/\36><0 GO FAR FINDR  % STATUS NOT ZERO
062352          SCCLR; *EXR SA                       % CLEAR CACHE
062354          IF SUTYP BIT 5SCDA THEN
062357             T:=SMBP1; X:=SMBP2+SINBS; *LDDTX 20
062363             IF A><0 GO FAR RSZER              % TO BIG
062365             A:=D=:SURSZ                       % DIRECT ACCESS DEVICE SIZE
062367          ELSE
062370          IF A SHZ -10=1 THEN
062374             T:=SMBP1; X:=SMBP2+SINBS; *LDDTX 20
062400             A=:SURSZ=:L; *LDDTX 00
062403             IF A/\377=0 AND D=L THEN
062407                SUTYP BONE 5SFBM=:SUTYP        % FIXED BLOCK MODE
062412             ELSE
062413                SUTYP BONE 5SVBS=:SUTYP        % VARIABLE BLOCK SIZE
062416                0=:SURSZ; IF L>>22 GO FAR RSZER
062422             FI
062422          FI FI
062422          IF SUTYP BIT 5SCDA THEN
062425             X:=12                             % RECORD SIZE 1024 BYTES
062426          ELSE
062427          IF A BIT 5SFBM THEN
062431             X:=12                             % RECORD SIZE 1024 BYTES
062432          ELSE
062433             X:=0                              % BYTECOUNT
062434          FI FI
062434          IF X=:D>1 THEN
062440             IF SURSZ<=1 GO FAR RSZER
062444             DO
062444                WHILE A NBIT 0
062446                X-1; A SHZ -1
062450             OD
062451             IF A><1 GO FAR RSZER              % NOT POWER OF 2
062454          FI
062454          D-X; IF X<0 THEN X:=0 FI             % BYTE AND RECORD SHIFT
062460          SUSI3; X\/A=:SUSI1; A\/D=:SUSI3      % SHIFT INSTRUCTIONS
062465          GO INFIN
062466   *)FILL
062476   INFIN: SUSI1-/\77\/SADI=:SUSI2              % LAST SHIFT INSTRUCTION
062503          SUTYP BONE 5SCIN=:SUTYP              % INITIALIZATION FINISHED
062506          IF 77/\ABFUN=42 GO RCAFI
062513          IF A-36=0 GO FAR FINEX
062516          GO FAR REPEAT
062517   *)FILL
062522   RSZER: T:=ILRCS; GO FAR ERREX               % ILLEGAL RECORD SIZE
062524
062524   DOUBLE SVDRS
062526
062526   RCAFI: X:=SMBP2+SINBS
062530          IF SUTYP BIT 5SCDA THEN
062533             A:=0; D:=1; T:=SUSI1; *EXR ST     % GET RECORD SIZE
062537             D-1=:L; T:=SMBP1; *LDDTX 20
062543             AD=:SVDRS; *LDDTX 00
062545             D-L; *RADD 0 CM1 ADC DA
062547             T:=SUSI2; *EXR ST
062551             T:=MEMA1; X:=MEMA2; *STDTX 10
062554             SVDRS; *STDTX 30
062556             *STZTX 00
062557          ELSE
062560          IF A SHZ -10=1 THEN
062564             T:=SMBP1; *LDATX 00
062566             A=:L; *LDDTX 10
062570             T:=MEMA1; X:=MEMA2; *STDTX 10
062573             A:=L; *STATX 00
062575          FI FI
062575          "0"; GO FAR FINEX
062577   *)FILL
062601
062601   % === SET RECORD SIZE
062601
062601   INTEGER SADIN(0); *SAD 0
062602
062602   SETRS: IF A><SURSZ THEN
062605             IF A=:SURSZ><0 THEN
062607                X:=SUTYP BONE 5SFBM=:SUTYP     % SET FIXED BLOCK MODE
062612                X:=12=:D
062614                DO WHILE A NBIT 0
062616                   X-1; A SHZ -1
062620                OD
062621             ELSE
062622                X:=SUTYP BZERO 5SFBM=:SUTYP    % SET VARIABLE BLOCK MODE
062625                X:=0=:D
062627             FI
062627             D-X; IF X<0 THEN X:=0 FI          % BYTE AND RECORD SHIFT
062633             SADIN; X\/A=:SUSI1-; A\/D=:SUSI3
062641             77/\X\/SADIN=:SUSI2
062645          FI
062645          EXIT
062646
062646   % === EXECUTE MODE SELECT
062646
062646   MODES: CALL CACOB; 2; X:=SUDAQ; CALL EXCOM  % BUILD COMMAND BLOCK
062652          CALL SCEIO; CALL ERRFATAL; X:=:B
062655          IF SUSTA=:SUSTR/\36><0 GO FAR FINDR  % STATUS NOT ZERO !
062662          T:=SCCLR; *EXR ST                    % CLEAR CACHE
062664          IF SUTYP SHZ -10=0 OR =1 OR =3 OR =4 THEN
062700             T:=MEMA1; X:=MEMA2; *LDDTX 00
062703             IF A SHZ -10>=14 OR 77/\ABFUN=23 THEN
062714                IF 377/\D>=10 THEN
062721                   T:=MEMA1; *LDATX 50         % GET RECORD SIZE
062723                   CALL SETRS                  % SET RECORD SIZE
062724                FI
062724             FI
062724          FI
062724          "0"; GO FAR FINEX
062726   *)FILL
062737
062737   % === EXECUTE REQUEST SENSE
062737
062737   DOUBLE SUBBC(0); *0; SNSBL@1
062741
062741   EXRQS: T:=SMBP1; X:=SMBP2+SNSBS             % PHYSICAL ADDRESS OF SENSE BUFFER
062744          A:=T; D:=X; AD=:SUCMA                % COMMAND ADDRESS
062747          AD SHZ 1=:SUIDP; SUBBC=:SUIBC        % DATA POINTER AND BYTECOUNT
062753          7/\SUDLU SHZ 5\/1400; *STATX 00      % COMMAND BYTE 0 + LUN
062760          "0"; D SHZ 10; *STDTX 10             % COMMAND BYTE 1 + 2
062763          0=:SNSBR; X:=SUDDF:=:B; 2; GO SCLLD  % START OPERATION
062770
062770   % === EXECUTE SPECIAL COMMAND
062770
062770   INTEGER SAVA
062771   DOUBLE SUEBC(0); *0; SINBL@1
062773
062773   EXINT: SMBPA; T:="SINBS"; D+T               % PHYSICAL ADDRESS OF DATA BUFFER
062776          AD SHZ 1=:SUIDP; SUEBC=:SUIBC        % BYTEADDRESS AND BYTECOUNT
063002          2=:SAVA; GO FELLS
063005
063005   % === EXECUTE COMMAND
063005
063005   EXCOM: A=:SAVA; MEMAD SHZ 1=:SUIDP          % CONTROLL AND DATA POINTER
063011
063011   FELLS: -1=:SUSTR
063013          T:=SMBP1=:SUCM1; X:=SMBP2=:SUCM2     % PHYSICAL ADDRESS OF COMMAND
063017          7/\SUDLU SHZ 5=:D; *LDATX 00         % GET LUN
063024          A/\177437\/D; *STATX 00              % TO COMMAND BLOCK
063027          X:=SUDDF:=:B; SAVA; GO SCLLD         % START OPERATION
063033
063033   % === GET USER SPECIFIED COMMAND BLOCK
063033
063033   GUSCB: ABPA3=:SUIBC; A:=L=:SAVA:=6=:L       % NUMBER OF WORDS
063041          ABPA2; X:=SMBP1; T:=SMBP2; *MOVPP    % MOVE COMMAND BLOCK
063045          IF ABFUN SHZ -14=0 THEN 377/\SUICO FI
063052          T:=SAVA=:P
063054   *)FILL
063060
063060
063060   % === DO READ EXTENDED STATUS
063060
063060   INTEGER SAVX2
063061   INTEGER POINTER SAVL2
063062
063062   DOEXS:  X=:SAVX2; A:=L=:"SAVL2"
063065           T:=X.SCTRG.MEMA2; X:=X.MEMA1
063070           6=:L; SMBPA; *MOVPP
063074           "SUSTR"+B=:D; L:=1; *MOVAP
063101           "SNSBR"+B=:D; L:=1; *MOVAP
063106           SNSBR+1 SHZ -1=:L
063112           SMBPA; A:=:D+"SNSBS":=:D; *MOVPP
063117           X:=SAVX2; "0"; GO SAVL2
063122   *)FILL
063124
063124   % === EXECUTE BUS DEVICE RESET
063124
063124   BDRST: "2\2"; X:=SUDDF:=:B
063127          CALL SCLLD; GO FAR SCEIO; CALL ERRFATAL
063132          "3\3"; CALL SCLLD; GO FAR SCEIO; CALL ERRFATAL
063136          X:=:B; "0"; GO FAR FINEX
063141   *)FILL
063147
063147

063147   % === CALCULATE COMMAND BLOCK
063147
063147   @ICR;
063147   %
063147   % CODING OF SCSI FUNCTION
063147   %
063147   % THE ARRAYS CONTAINS THE 2 FIRST BYTES OF THE SCSI CONTROL BLOCK.
063147   % BITS 5-7 (I.E. SCSI UNIT NUMBER) CONTAINS INFORMATION ON LAYOUT
063147   % OF OTHER PARTS THE CONTROL BLOCK AS FOLLOWS:
063147   %
063147   %  FOR ALL SCSI DEVICE TYPES (BIT 7 = 0), STANDARD 6 BYTES FORMAT
063147   %
063147   %     000 => ALL PARAMETERS RESERVED, BYTECOUNT 0.
063147   %     001 => ALL PARAMETERS RESERVED, BYTECOUNT FROM WC IN P3
063147   %     010 => AMOUNT FROM P3, BYTECOUNT 0.
063147   %     011 => AMOUNT AND BYTECOUNT FROM P3 (UNMODIFIED).
063147   %     101 => AMOUNT AND BYTECOUNT FROM P3 (WC)
063147   %
063147   %  FOR SCSI DEVICE TYPE 0,4,5:
063147   %
063147   %         BIT 7 => ADDRESS FROM USER
063147   %         100 => AMOUNT = 0, BYTECOUNT = 0.
063147   %         110 => AMOUNT FROM USER (RECORD COUNT), BYTECOUNT = 0.
063147   %         111 => AMOUNT AND BYTECOUNT FROM USER (RECORD COUNT).
063147   %
063147   %  FOR SCSI DEVICE TYPE 1,2,3:
063147   %
063147   %         100 => AMOUNT FROM USER (RECORD COUNT), BYTECOUNT = 0. (NO FIX BIT)
063147   %         110 => AMOUNT FROM USER (RECORD COUNT), BYTECOUNT = 0.
063147   %         111 => AMOUNT AND BYTECOUNT FROM USER (RECORD COUNT).
063147   %
063147
063147   INTEGER ARRAY SCSF1:=(                    % SCSI OP.CODE IN UPPER BYTE
063147      010\340,012\340,057\300,057\342,013\200,377\000,377\000,377\000,   % 00-07
063157      377\000,377\000,377\000,377\000,377\000,377\000,377\000,377\000,   % 10-17
063167      000\000,377\000,377\000,025\140,377\000,032\140,377\000,377\000,   % 20-27
063177      377\000,377\000,377\000,377\000,026\000,027\000,377\000,377\000,   % 30-37
063207      377\000,004\000,045\240,010\340,012\340,377\000,377\000,377\000,   % 40-47
063217      377\000,377\000,377\000,377\000,377\000,377\000,377\000,377\000,   % 50-57
063227      010\340,012\340,057\300,057\342,377\000,377\000,010\340,377\000,   % 60-67
063237      377\000,056\342,377\000,000\000,377\000,022\140,377\000,377\000);  % 70-77
063247
063247   INTEGER ARRAY SCSF2:=(                    % SCSI OP.CODE IN UPPER BYTE
063247      010\340,012\340,023\300,023\342,377\000,377\000,377\000,031\001,   % 00-07
063257      021\101,021\101,020\100,001\000,031\000,021\200,021\200,033\000,   % 10-17
063267      000\000,001\000,001\000,025\140,377\000,032\140,010\140,012\140,   % 20-27
063277      033\100,377\000,377\000,377\000,026\000,027\000,377\000,377\000,   % 30-37
063307      377\000,377\000,005\040,377\000,377\000,377\000,377\000,377\000,   % 40-47
063317      377\000,377\000,377\000,377\000,377\000,377\000,377\000,377\000,   % 50-57
063327      010\340,012\340,023\300,023\342,377\000,377\000,010\340,377\000,   % 60-67
063337      033\100,377\000,377\000,000\000,377\000,022\140,021\003,377\000);  % 70-77
063347   @CR;
063347
063347   INTEGER POINTER HOME
063350   INTEGER SUAM1, SUAM2
063352   DOUBLE SUAMT=SUAM1
063352
063352   CACOB: A:=L=:"HOME"
063354          IF SUTYP NBIT 5SCIN GO FAR INQUI     % START INQUIRY
063357          0=:SUIB1=:SUIB2                      % ZERO BYTECOUNT
063361          T:=SUTYP; *5SCDA@3 BLDA DT           % DEVICE TYPE TO K
063363          77/\ABFUN; X:=A                      % GET COMMAND
063366          *1BANK
063367          IF K THEN X:=SCSF1(X) ELSE X:=SCSF2(X) FI
063374          *2BANK
063375          IF L:=X NBIT 7 THEN
063400             K:="0"                            % NOT DIRECT ACCESS FORMAT
063401             IF L BIT 6 THEN
063403                ABPA3                          % AMOUNT
063404                IF L BIT 5 THEN AD=:SUIBC FI % BYTECOUNT
063407             ELSE
063410                IF L BIT 5 THEN
063412                   ABPA3 SHZ 1=:SUIBC          % BYTECOUNT FROM WORDCOUNT
063415                FI
063415                AD SHZ -40                     % AMOUNT ZERO
063416             FI
063416          ELSE
063417             IF L BIT 6 THEN
063421                ABPA3; T:=SUSI1; *EXR ST       % AMOUNT
063424                IF K THEN
063426                   IF A><0 OR D>>377 OR D=0 THEN
063434                      L BONE 15                % 10 BYTES FORMAT NECESSARY
063435                   FI
063435                ELSE
063436                IF T:=SUTYP BIT 5SFBM THEN
063441                   L BONE "0"                  % SET FIXED BLOCK MODE
063442                FI FI
063442                IF L BIT 5 THEN
063444                   AD=:SUAMT                   % SAVE AMOUNT
063445                   T:=SUSI3; *EXR ST           % CALCULATE BYTECOUNT
063447                   AD=:SUIBC:=SUAMT            % SET BYTECOUNT
063451                FI
063451             ELSE
063452                IF L BIT 5 THEN
063454                   IF K THEN L BZERO 7 FI
063457                   ABPA3 SHZ 1=:SUIBC          % AMOUNT AND BYTECOUNT
063462                ELSE
063463                   IF K NBIT THEN              % AMOUNT 1
063465                      ABPA3; T:=SUSI1; *EXR ST
063470                   ELSE
063471                      AD SHZ -40               % ZERO AMOUNT
063472                   FI
063472                FI
063472             FI
063472          FI
063472          IF K THEN
063474             AD=:SUAMT                         % SAVE AMOUNT
063475             IF L BIT 7 THEN
063477                ABPA2; T:=SUSI1; *EXR ST       % ADDRESS
063502             ELSE
063503                AD SHZ -40
063504             FI
063504             IF A>>37 THEN L BONE 15 FI        % 10 BYTE FORMAT NECESSARY
063510             T:=SMBP1; X:=SMBP2
063512             IF L BIT 15 THEN                  % 10 BYTE FORMAT
063514                *STDTX 10                      % ADDRESS
063515                SUAMT; AD SHZ 10; *STDTX 30    % AMOUNT + CONTROLL
063520             ELSE                              % 6 BYTE FORMAT
063521                L\/A                           % 3 ADDRESS BITS TO BYTE 2
063522                SUAM2 SHZ 10:=:D; *STDTX 10    % ADDRESS + AMOUNT + CONTROLL
063526             FI
063526          ELSE                                 % AMOUNT ONLY FORMAT
063527             AD SHZ 10                         % AMOUNT + CONTROLL
063530             T:=SMBP1; X:=SMBP2; *STDTX 10
063533          FI
063533          177437/\L; *STATX 00                 % OPERATION CODE
063536          377/\SUICO; GO HOME
063541   RBUS
063546   *"
"063546   @DEV 1
063546   @DEV (S-S-L)IP-P2-SCSI-MAGTP:NPL
063546
063546   *"8SCMT
"063546   %==============================================================================
063546   %        S C M A G T A P E
063546   %
063546   % LEVEL 11 ROUTINE TO PERFORM TRANSFERS ON SCSI MAGTAPE
063546   %
063546   %
063546   %    FUNCTIONS
063546   %
063546   %           0: READ
063546   %           1: WRITE
063546   %           2: READ PARITY
063546   %           3: COMPARE
063546   %           7: ERASE
063546   %          10: ADVANCE THROUGH EOF
063546   %          11: REVERSE THROUGH EOF
063546   %          12: WRITE EOF
063546   %          13: REWIND
063546   %          14: WRITE SKIP
063546   %          15: REVERSE RECORD
063546   %          16: ADVANCE RECORD
063546   %          17: UNLOAD
063546   %          20: READ STATUS (TEST UNIT READY)
063546   %          21: CLEAR DEVICE
063546   %          22: CLEAR DEVICE W/ERROR EXIT
063546   %          23: SELECT DENSITY
063546   %          24: READ LAST STATUS
063546   %          25: READ ERROR COUNTERS
063546   %          26: READ BYTE RECORD
063546   %          27: WRITE BYTE RECORD
063546   %          30: LOAD
063546   %          31: CLEAR DEVICE (BUS DEVICE RESET)
063546   %          33: CLEAR SELECTED UNIT
063546   %          34: RESERVE DEVICE
063546   %          35: RELEASE DEVICE
063546   %          37: READ EXTENDED STATUS
063546   %          42: READ FORMAT
063546   %          46: RETURN INTERFACE TYPE (2=SCSI)
063546   %          50: READ MULTIPLE RECORDS
063546   %          51: WRITE MULTIPLE RECORDS
063546   %          54: COPY
063546   %          60: READ WITH DOUBLE AMOUNT
063546   %          61: WRITE WITH DOUBLE AMOUNT
063546   %          62: READ DOUBLE AMOUNT BYTE RECORD
063546   %          63: WRITE DOUBLE AMOUNT BYTE RECORD
063546   %          66: READ WITH DOUBLE AMOUNT, DON'T CLEAR CACHE
063546   %          70: RETENSION
063546   %          73: TEST UNIT READY
063546   %          74: EXECUTE USER SPECIFIED SCSI COMMAND BLOCK
063546   %          75: INQUIRY (READ DEVICE TYPE)
063546   %          76: ADVANCE TO END OF RECORDED AREA
063546   %
063546   SUBR SCMAGTAPE
063546
063546   % DISP -42; INTEGER CERRCODE; PSID
063546
063546   DISP -41
063546      INTEGER CPFUN,CPDEV,CPSTS,CPBLS
063546      INTEGER CPAM1, CPAM2
063546      DOUBLE CPAMT=CPAM1
063546      INTEGER ACTRS=CPSTS,MAXCN=CPBLS,CURCN=CPAM1,ORGRS=CPAM2
063546      DOUBLE MRPAR=CPAM1
063546      INTEGER SABFU, SMEM1, SMEM2, SAB21, SAB22, SAB31, SAB32
063546      DOUBLE SMEMA=SMEM1, SABP2=SAB21, SABP3=SAB31
063546      INTEGER OPSTA
063546         SYMBOL 4SRUN=0         % STREAMER ACTIVE
063546         SYMBOL 4SSTA=1         % STATUS RETURNED
063546         SYMBOL 4SRES=2         % DEVICE RESERVED
063546         SYMBOL 4SINI=3         % INITIALIZATION PERFORMED
063546         SYMBOL 4SMSL=4         % MODE SELECT PERFORMED
063546         SYMBOL 4SSTP=5         % REWIND ERROR STATUS PENDING
063546         SYMBOL 4SUAP=10        % UNIT ATTENTION PENDING
063546         SYMBOL 4SALP=11        % AT SIMULATED LOADPOINT
063546      INTEGER CUROP, STSTA, P3LUN, CFORM, RWSTA
063546      INTEGER SCSSS=TMR         % SCSI STATUS
063546      INTEGER DCONW=HDEV        % DRIVER CONTROLL WORD
063546      INTEGER SCLES=DRIVER      % LAST ERROR STATUS
063546   PSID
063546
063546   SYMBOL 9SWRD=16   % AMOUNT IS WORDS
063546   SYMBOL 9SSWA=15   % SINGLE WORD AMOUNT
063546   SYMBOL 9SAMT=14   % FIXED AMOUNT (IN BITS 15-17)
063546   SYMBOL 9SCRS=13   % CLEAR PENDING REWIND ERROR STATUS
063546   SYMBOL 9SRUA=12   % REMOVE UNIT ATTENTION
063546   SYMBOL 9SIUA=11   % IGNORE UNIT ATTENTION
063546   SYMBOL 9SRWO=10   % RETURN RESULTING AMOUNT TO USER
063546   SYMBOL 9STBM=7    % BACKWARD TAPE MOVEMENT
063546   SYMBOL 9SREW=6    % SIMULATE LOAD POINT
063546   SYMBOL 9SSPC=4    % SPECIAL OPERATION
063546   SYMBOL 9SNOT=3    % NEW OPERATION TYPE (UNIT IN IFUNC)
063546   SYMBOL 9SPLP=2    % PRESERVE LOAD POINT
063546   SYMBOL 9SROS=1    % RETURN ORIGINAL STATUS
063546   SYMBOL 9SONB=0    % ODD NUMBER OF BYTES IS ALLOWED
063546
063546
063546
063546   % EXECUTE MODE SENSE (TO GET WRITE PROTECT)
063546
063546   MDSEN: 700/\X.ABFUN\/25=:X.SABFU; GO FELLS
063553
063553   % EXECUTE MODE SELECT
063553
063553   INTEGER MSXRG
063554
063554   MDSEL: X=:MSXRG; T:=X.CMAD1; X:=X.CMAD2     % PHYSICAL ADDRESS OF BUFFER
063557          A SHZ 10=:D:=10010; *STZTX; STDTX 10 % DENSITY AND SENSE HEADER
063564          *STZTX 30; STZTX 40; STZTX 50        % ZERO REST OF SENSE DATA
063567          700/\MSXRG.ABFUN\/23=:X.SABFU
063574
063574   % EXECUTE MODE SENSE/MODE SELECT COMMAND
063574
063574   FELLS: 0=:X.SAB31; 14=:X.SAB32              % NUMBER OF BYTES
063577          X.CMADR=:X.SMEMA                     % BUFFER ADDRESS
063601          T:="SABFU-14"+X; "4"; GO SCSID       % ACTIVATE DRIVER
063605   *)FILL
063613
063613
063613   @DEC
063613   SYMBOL DS6250=6250,DS1600=1600,DS800=800
063613   @OCT
063613
063613   @ICR;
063613   INTEGER ARRAY OPTYP:=
063613         (060400, 060000, 060421, 000000, 000000, 000000, 000000, 000110,
063623          030000, 170200, 030000, 006100, 100000, 170000, 030200, 016100,
063633          002024, 006024, 006024, 001024, 001020, 021020, 020401, 020001,
063643          036100, 006000, 000000, 002024, 001020, 001020, 000000, 000001,
063653          000000, 000000, 001024, 000000, 000000, 000000, 000020, 000000,
063663          000420, 000020, 000000, 000000, 000032, 000000, 000000, 000000,
063673          040400, 040000, 000421, 000021, 000000, 000000, 040400, 000000,
063703          076110, 000000, 000000, 100000, 001012, 100000, 100000, 000000);
063713
063713   INTEGER ARRAY FUDCW:=
063713         (010\007, 010\000, 000\000, 000\110,
063717          013\013, 007\110, 007\013, 013\011,
063723          004\000, 000\001, 004\001, 010\007,
063727          010\001, 000\000, 004\004, 000\001,
063733          000\000, 004\000, 000\000, 000\000,
063737          010\007, 000\000, 014\000, 000\000,
063743          010\007, 070\010, 000\000, 010\000,
063747          110\000, 000\004, 014\004, 013\000);
063753   @CR;
063753
063753   SCMAGTAPE:
063753
063753   % --- FETCH PARAMETERS
063753          X.MEMAD=:MEMAD; X.ABPA2=:ABPA2
063757          X.ABPA3=:ABPA3; X.ABAD3=:ABAD3
063763          X.ABFUN=:ABFUN
063765          *1BANK
063766          X:=77/\A; T:="FUDCW"; *LBYT          % DRIVER CONTROLL WORD
063772          T:=OPTYP(X)                          % OPERATION CONTROLL WORD
063773          *2BANK
063774          A=:B.CURCN
063776          IF T=:X.CUROP NBIT 9SNOT THEN
064001             177077/\X.ABFUN=:D
064004             7/\ABP21 SHZ 6\/D=:ABFUN
064011          FI
064011          IF T BIT 9SAMT THEN
064013             A:=T; AD SH -35=:X.ABPA3          % SET AMOUNT
064016          ELSE
064017             X.ABPA3
064020             IF T BIT 9SSWA THEN
064022                AD SHZ -20                     % SINGLE WORD AMOUNT
064023             FI
064023             IF T BIT 9SWRD THEN
064025                AD SHZ 1                       % CONVERT TO BYTES
064026             FI
064026             AD=:X.ABPA3
064027          FI
064027          IF X.OPSTA BIT 4SRUN GO FAR SWT11    % OPERATION ALLREADY IN PROGRESS
064032
064032   NEWOP: 3\/X.OPSTA=:X.OPSTA                  % INDICATE OPERATION STARTED
064035          0=:X.CERRCODE=:X.SCSSS               % ZERO STATUS
064037          X.ABFUN SHZ -6/\7=:T:=X.SCDFA
064044          CALL SCGLN; GO FAR ERREX             % GET LUN DATAFIELD
064046          A:=B=:X.P3LUN; X.CURCN=:X.DCONW
064052          X.CUROP=:X.SCOCW; 0=:X.CUROP
064055          IF A=0 THEN
064056             T:=ILAOP; GO FAR ERREX            % ILLEGAL OPERATION
064060   *)FILL
064067          FI
064067          IF A NBIT 9SSPC GO FAR NSPEC
064071             IF X.ABFUN/\77=24 THEN
064076                X.STSTA; GO FAR SETST          % READ READ LAST STATUS
064100             ELSE
064101             IF A=54 THEN
064104                CALL ICCOM; GO FAR ERREX       % INITALIZE COPY COMMAND
064106             ELSE
064107             IF A=2 THEN
064112                0=:X.ABFUN                     % READ ODD NUMBER OF BYTES
064113             ELSE
064114             IF A=50 OR =51 THEN               % MULTIPLE RECORD OPERATIONS
064122                X.ABAD3; T:=0; *DEPO           % ZERO AMOUNT
064125                A.ABPA3=:X.MRPAR               % ORIGINAL PARAMETERS
064130                A:=0; AD SHZ 1=:X.ABPA3        % INITIAL AMOUNT
064133                0=:CURCN=:ACTRS                % ZERO RECORDCOUNT AND SIZE
064135             ELSE
064136             IF A=61 OR =62 THEN
064144                X.ABFUN-34=:X.ABFUN            % READ BYTE RECORD
064147             ELSE
064150             IF A=46 THEN
064153                X.ABAD3; T:=2; *DEPO           % SCSI INTERFACE
064156                "0"; GO FAR FINOP
064160             ELSE
064161             IF A=21 OR =33 OR =22 THEN
064172                IF A=22 THEN 20 ELSE "0" FI    % CLEAR DEVICE FUNCTIONS
064200                GO FAR FINOP
064201             ELSE
064202             IF A=25 THEN
064205                T:=0; X.ABAD3; *DEPO           % ZERO AMOUNT
064210                IF X.ABP32<4 THEN
064214                   T:=BADPA; GO FAR ERREX      % BUFFER TO SMALL
064216                FI
064216                X.ABAD3; *DEPO                 % AMOUNT EQUALS 4
064220                B=:L:=X; T:=MEMA1
064223                RERRCOUNT(0)=:D:=RHSTAT(X)
064227                0=:RERRCOUNT(0)=:RHSTAT(X)
064232                X:=MEMA2; *STDTX 00
064234                WERRCOUNT(0)=:D:=WHSTAT(X)
064240                0=:WERRCOUNT(X)=:WHSTAT(X)
064242                X:=MEMA2; *STDTX 20
064244                B=:X:=L; "0"; GO FAR SETST
064250             ELSE
064251             IF A=37 THEN
064254                T:=X; "0"; CALL SCSID; GO FAR ERREX; CALL ERRFATAL
064261                GO FAR SETST
064262   *)FILL
064272             FI FI FI FI FI FI FI FI FI
064272
064272   NSPEC: X.TACNS=:X.TACOU                     % RETRY COUNT
064274
064274   RETRY: IF X.OPSTA BIT 4SSTP THEN
064277             A BZERO 4SSTP=:X.OPSTA
064301             IF T:=X.SCOCW NBIT 9SCRS THEN
064304                RWSTA; GO FAR FINOP            % REPORT ERROR IN REWIND
064306             FI
064306          FI
064306          IF A BIT 4SUAP THEN
064310             IF T:=X.SCOCW NBIT 9SIUA THEN
064313                IF T NBIT 9SRUA THEN
064315                   "6"; GO FAR FINOP           % UNIT ATTENTION
064317                FI
064317                A BZERO 4SUAP=:X.OPSTA
064321             FI
064321          FI
064321          IF A NBIT 4SINI THEN
064323             IF A BIT 4SRES THEN "34" ELSE "36" FI
064330             A=:X.SABFU:=0; T:="SABFU-14"+X
064334             CALL SCSID; GO FAR ERREX; CALL ERRFATAL
064337             IF A><0 GO FAR CHSEN              % CHECK SENSE
064341             IF SUTYP BIT 5SFBM OR A SHZ -10><1 THEN
064350                T:=TYPER; GO FAR ERREX         % ILLEGAL DEVICE TYPE
064352   *)FILL
064360             FI
064360             X.OPSTA BONE 4SINI=:X.OPSTA
064363          FI
064363          IF T:=X.OPSTA NBIT 4SMSL THEN
064366             CALL FAR MDSEN; GO FAR ERREX; CALL ERRFATAL
064371             IF A=0 THEN
064372                CALL GDENS; A/\377             % GET DENSITY
064374                CALL FAR MDSEL; GO FAR ERREX; CALL ERRFATAL
064377             FI
064377             IF A><0 THEN
064400                IF T:=X.SCOCW NBIT 9SIUA GO FAR CHSEN
064403             ELSE
064404                X.OPSTA BONE 4SMSL=:X.OPSTA
064407             FI
064407          FI
064407          T:=X                                 % PARAMETER POINTER
064410          IF X.SCOCW BIT 9SSPC THEN
064413             IF 77/\X.ABFUN=:D:=54=D THEN
064421                CALL BCCOM; GO FAR ERREX       % BUILD COPY COMMAND
064423             ELSE
064424             IF 42=D THEN
064427                CALL FAR MDSEN; GO FAR ERREX; CALL ERRFATAL
064432                IF A><0 GO CHSEN; CALL GDENS   % GET DENSITY
064434                T:=X.ABA31; X=:D:=X.ABA32; *STATX 00  % RETURN FORMAT
064440                X:=D; "0"; GO FAR FINOP
064443             ELSE
064444             IF 50=D OR 51=D THEN
064452                A-50=:X.SABFU                       % FUNCTION
064454                X.MEMAD=:X.SMEMA; X.ABPA3=:X.SABP3  % MEMORY ADDRESS AND AMOUNT
064460                T:="SABFU-14"+X                     % PARAMETER POINTER
064462             ELSE
064463             IF 23=D THEN
064466                IF X.ABP31=DS1600 THEN 2
064473                ELSE IF A=DS6250 THEN 3
064500                ELSE IF A=DS800  THEN 1
064505                FI FI FI; A=:X.ABP22
064506                CALL FAR MDSEL; GO FAR ERREX; CALL ERRFATAL
064511                IF A><0 GO CHSEN
064512                100000/\X.CFORM\/X.ABP22=:X.CFORM
064516                "0"; GO FAR FINOP
064520   *)FILL
064536             FI FI FI FI
064536          FI
064536
064536          X.DCONW; CALL SCSID; GO ERREX; GO IMRET
064542
064542   CHSEN: IF A><0 THEN
064543             K:="0"
064544             IF A=:L:=17/\L=6 THEN             % UNIT ATENTION
064552                IF 177007/\X.OPSTA NBIT 4SALP THEN
064556                   A BONE 4SUAP                % NOT AT LOAD POINT
064557                FI; A=:X.OPSTA
064560                K:="1"; 0=:X.CFORM=:X.STSTA
064563             ELSE
064564             IF A=12 THEN                      % COPY ABORTED
064567                A:=L; CALL CCOPY; A=:L         % CONTINUE COPY ?
064572             ELSE
064573             IF A=15 THEN                      % ABORTED COMMAND
064576                K:=1
064577             FI FI FI
064577             IF K THEN MIN X.TACOU; GO FAR RETRY FI
064603             A:=L
064604          FI
064604          GO FINOP
064605
064605   IMRET: X:=:B; OPSTA BZERO 4SSTA=:OPSTA
064611          CFORM-, SHZ -16\/20001=:HSTAT        % REWINDING STATUS
064616          CALL RTACT; GO SWT11
064620
064620   ERREX: T SHZ 11; 20\/T=:X.SCSSS             % ERROR IN DRIVER
064624          IF T:=X.SCOCW NBIT 9SPLP THEN
064627             X.OPSTA BZERO 4SALP=:X.OPSTA      % CLEAR LOADPOINT INDICATOR
064632          FI
064632          IF T BIT 9SROS THEN
064634             X.SCSSS                           % RETURN ORIGINAL STATUS
064635          ELSE
064636             100031                            % SIMULATE FATAL ERROR
064637          FI
064637          B:=X; GO FAR FINEX                   % RETURN
064641
064641   SETST: B:=X; GO FAR RETEX                   % RETURN STATUS
064643
064643   *)FILL
064655
064655   INTEGER FINST(0)
064655   @ICR;
064655   INTEGER ARRAY NEWST:=
064655         (000001, 000001, 000020, 000121, 100031, 100031, 000121, 000061,
064665          000121, 000031, 000031, 100031, 000021, 003021, 000021, 000021);
064675   @CR;
064675
064675   INTEGER SAVB=?, SAVF=?
064675
064675   FINOP: X:=:B=:SAVB
064677          IF T:=SCOCW BIT 9SSPC THEN
064702             A=:D:=77/\ABFUN=:SAVF:=:D         % FUNTION CODE
064707             IF D=54 THEN CALL TCCOM FI        % TERMINATE COPY
064713          FI
064713          A=:SCSSS                             % ORIGINAL STATUS
064714          IF T:=SCOCW BIT 9SROS THEN
064717             IF A/\77777><0 AND ><1 THEN
064724                A BONE 4                       % INDICATE ERROR
064725             FI
064725             GO FAR FINEX                      % RETURN ORIGINAL STATUS
064726          FI
064726          L:=0; IF A BIT 4 THEN L BONE 4 FI    % BUILD SIMULATED STATUS
064732          IF A><0 THEN
064733             *1BANK
064734             X:=17/\A; T:=NEWST(X)             % GET STATUS FROM SENSE KEY
064737             *2BANK
064740          ELSE
064741             T:=FINST                          % NORMAL STATUS
064742          FI
064742          GO BYPAS
064743   *)FILL
064747
064747   BYPAS: L\/T                                 % NEW STATUS
064750          IF A><0 THEN                         % EXTENDED SENSE
064751             T:=SCOCW                          % OPERATION CONTROLL WORD
064752             IF A BIT 7 THEN
064754                L BONE 7                       % EOF BIT
064755                IF T BIT 9SRWO THEN L BONE 4 FI
064760             FI
064760             IF A BIT 6 THEN
064762                IF T BIT 9STBM THEN
064764                   L BONE 2 BONE 5             % LOAD POINT
064766                ELSE
064767                   L BONE 11                   % END OF MEDIA
064770                FI
064770                L BONE 4
064771             FI
064771             IF T BIT 9SRWO THEN
064773                IF L NBIT 4 THEN
064775                   K:="0"
064776                   IF A BIT 5 THEN             % WORDCOUNT NOT ZERO
065000                      IF A<0 THEN
065001                         SAVB.ABPA3            % INFORMATION BYTES
065003                         IF A>0 OR A=0 AND D><0 THEN
065010                            L BONE 12; K:=1    % WORDCOUNT NOT ZERO
065012                            T:=ABP32:=:D; *RSUB ST DD
065015                            T:=ABP31:=:A; *RADD ST CM1 ADC DA
065020                            IF A<0 THEN
065021                               T:=ILSEN; X:=:B; GO FAR ERREX
065024   *)FILL
065025   INTEGER SAVB, SAVF
065027                            FI
065027                            IF T:=SCOCW BIT 9SWRD THEN
065032                               AD SHZ -1       % ACTUAL WORDCOUNT
065033                               IF M THEN
065035                                  L BONE 10    % ODD NUMBER OF BYTES TRANSFERED
065036                                  D+1; A:=A+C  % INCREASE WORD COUNT
065040                                  IF T NBIT 9SONB THEN
065042                                     L BONE 4  % ODD BYTES NOT ALLOWED
065043                                  FI
065043                               FI
065043                            FI
065043                         FI
065043                         IF K NBIT THEN
065045                            L BONE 14 BONE 4   % OVERFLOW IN READ
065047                         FI
065047                      FI
065047                   FI
065047                ELSE
065050                   K:=1; A:=0; D:=0            % ZERO AMOUNT
065053                FI
065053                IF K THEN
065055                   IF T BIT 9SSWA THEN
065057                      A:=D; T:=ABA31; X:=ABA32; *STATX
065063                   ELSE
065064                   IF T BIT 9SSPC AND X:=SAVF=50 THEN
065072                      IF X:=74760/\L=0 THEN
065076                         IF X:=ACTRS=0 THEN
065101                            L BZERO 12; A:=D=:ACTRS % NEW RECORD SIZE
065104                            T:=ABA31; X:=ABA32; *STATX 10
065107                            "0"; AD SHZ 1=:ABPA3    % NEW AMOUNT
065112                         ELSE
065113                         IF X><D THEN
065115                            L BONE 12          % DIFFERENT RECORD SIZE
065116                         FI FI
065116                      FI
065116                   ELSE
065117                      T:=ABA31; X:=ABA32; *STDTX
065122                   FI FI
065122                FI
065122             FI
065122          FI
065122
065122          IF T:=SCOCW BIT 9SSPC THEN
065125             IF SAVF=50 OR =51 THEN
065134                IF X:=66760/\L=0 THEN
065140                   CURCN+1=:CURCN              % OPERATION WENT OK
065143                   T:=ABA31; X:=ABA32; *STATX 00    % RETURN NEW COUNT
065146                   IF X:=77770/\L><0 AND A<<MAXCN THEN
065154                      X:=SAVB:=:B
065156                      X.ACTRS+X.MEMA2=:X.MEMA2 % NEXT MEMORY ADDRESS
065161                      X.MEMA1:=A+C=:X.MEMA1
065164                      GO FAR RETRY             % REPEAT OPERATION
065165   *)FILL
065171                   FI
065171                ELSE
065172                IF L BIT 12 THEN
065174                   -1=:L                       % DIFFERENT RECORD SIZES
065176                FI FI
065176             FI
065176          FI
065176
065176          X:=OPSTA                             % DRIVE STATUS
065177
065177          IF T:=SCOCW NBIT 9SPLP THEN
065202             X BZERO 4SALP=:OPSTA              % CLEAR LOADPOINT INDICATOR
065204          FI
065204
065204          IF L NBIT 4 THEN
065206             IF T BIT 9SREW THEN
065210                X BONE 4SALP=:OPSTA            % SET SIMULATED LOADPOINT
065212             FI
065212             IF X BIT 4SALP THEN L BONE 2 FI   % SIMULATE LOADPOINT STATUS
065215             IF T BIT 9SSPC THEN
065217                IF 77/\ABFUN=34 THEN
065224                   X BONE 4SRES=:OPSTA         % INDICATE RESERVED
065226                ELSE
065227                IF A=35 THEN
065232                   X BZERO 4SRES=:OPSTA        % INDICATE NOT RESERVED
065234                FI FI
065234             FI
065234          ELSE
065235             IF ABFUN NBIT 0 THEN
065240                RHSTAT(0)\/L=:RHSTAT(0)
065245                MIN RERRCOUNT(0); 0/\0
065250             ELSE
065251                WHSTAT(0)\/L=:WHSTAT(0)
065256                MIN WERRCOUNT(0); 0/\0
065261             FI
065261          FI
065261          IF T:=CFORM>=0 THEN L BONE 1 FI      % WRITE ENABLED
065265          A:=L; GO FINEX
065267   *)FILL
065267   INTEGER 9XER:=1664, 9XDV, 9XUN, 9XFU, 9XST
065274
065274   FINEX: IF A=:STSTA BIT 4 AND ><-1 THEN
065302             SCSSS=:SCLES; CALL SCDTS; STSTA   % DETERMINE ERROR CODE
065306             IF STSTA BIT 17 THEN
065311                A:=B; CALL PHLOG; A=:9XDV      % DEVICE NUMBER
065314                ABFUN=:9XFU                    % FUNCTION
065316                A SHZ -6/\7=:9XUN              % DEVICE UNIT
065321                SCSSS=:9XST:=STSTA; X:=RTRES   % STATUS WORD AND PROGRAM
065325                *1BANK
065326                CALL 9FLEX(9XER,5)             % REPORT ERROR
065331                *2BANK
065332             FI
065332          FI
065332
065332   RETEX: IF T:=OPSTA BIT 4SSTA THEN
065335             A=:HSTAT; CALL RTACT              % RETURN TO USER
065337          ELSE
065340             IF A=:RWSTA BIT 4 THEN
065343                OPSTA BONE 4SSTP=:OPSTA
065346             FI
065346             IF CUROP><0 THEN
065350                X:=B; GO FAR NEWOP
065352             FI
065352          FI
065352          177774/\OPSTA=:OPSTA; GO SWT11
065356
065356   RBUS
065365   *"
"065365   @DEV 1
065365   @DEV (S-S-L)IP-P2-SCSI-OPDI:NPL
065365
065365   *"8SCOD
"065365   %==============================================================================
065365   %        S C O P T I C A L
065365   %
065365   % LEVEL 11 ROUTINE TO PERFORM TRANSFERS ON SCSI OPTICAL DISKS
065365   %
065365   %
065365   %    FUNCTIONS
065365   %
065365   %           0: READ
065365   %           1: WRITE
065365   %           2: READ PARITY
065365   %           3: COMPARE
065365   %           4: SEEK
065365   %          34: RESERVE DEVICE
065365   %          35: RELEASE DEVICE
065365   %          37: READ EXTENDED STATUS (SCSI SENSE INFO)
065365   %          42: READ FORMAT
065365   %          60: READ (DOUBLE DISK ADDRESS)
065365   %          61: WRITE (DOUBLE DISK ADDRESS)
065365   %          62: READ PARITY (DOUBLE DISK ADDRESS)
065365   %          63: COMPARE (DOUBLE DISK ADDRESS)
065365   %          73: TEST UNIT READY
065365   %          74: EXECUTE USER SPECIFIED SCSI COMMAND BLOCK
065365   %          75: INQUIRY (READ DEVICE TYPE)
065365   %
065365   SUBR SCOPTICAL
065365
065365   DISP 0
065365      INTEGER OPSTA=HDEV
065365         SYMBOL 4SINI=0      % INITIALIZATION PERFORMED
065365         SYMBOL 4SMSL=1      % MODE SELECT PERFORMED
065365         SYMBOL 4SRWO=3      % RECOVER OF WRITE OPERATION IN PROGRESS
065365   PSID
065365
065365   %
065365   % FLAG BITS IN OPERATION TYPE
065365   %
065365
065365   SYMBOL 3SERR=17          % ERROR MESSAGE
065365   SYMBOL 3SNTR=16          % NEUTRAL OPERATION
065365   SYMBOL 3DPA3=15          % PARAMETER 3 DOUBLE
065365   SYMBOL 3DPA2=14          % PARAMETER 2 DOUBLE
065365   SYMBOL 3SPES=13          % SPECIAL OPERATION (NOT SORTED)
065365   SYMBOL 3SF42=12          % FUNCTION 42
065365
065365   %
065365   % RETOP: TERMINATE OPERATION
065365   %
065365   % ENTRY: B = DISK DATAFIELD
065365   %        X = DAQ
065365   %        T = DRIVER STATUS
065365   %        A = SENSE (IF T=0)
065365   %
065365   % ALL REGISTERS PRESERVED
065365   %
065365   @ICR;
065365   INTEGER ARRAY NEWST:=
065365         (000000, 000000, 100020, 100020, 100020, 100020, 100020, 000020,
065375          000020, 100020, 100020, 100020, 000000, 100020, 000020, 100020);
065405   @CR;
065405
065405   TRIPLE SVTAD
065410   INTEGER SVTRG=SVTAD
065410   INTEGER SVXRG
065411   INTEGER POINTER SVLRG
065412   INTEGER 9XER:=1663, 9XDV, 9XUN
065415   DOUBLE 9XMA, 9XDA
065421   INTEGER 9XTA, 9XST, 9XFU, 9XPR
065425
065425   RETOP: TAD=:SVTAD; X=:SVXRG; A:=:L=:"SVLRG"
065431          T SHZ 11; 777/\X.ABFUN\/T=:SCTRG     % SET DRIVER STATUS
065436          IF T=0 THEN
065440             *1BANK
065441             X:=17/\L; NEWST(X)\/X             % GET ERROR STATUS
065445             *2BANK
065446          ELSE
065447             100020\/T                         % SERIOUS ERROR
065451          FI
065451
065451          IF A=:SVXRG.HSTAT BIT 4 THEN
065455             IF A/\17=5 AND 77/\X.ABFUN=3 OR=63 THEN
065471                0=:X.HSTAT                     % COMPARE NOT IMPLEMENTED
065472             FI
065472          FI
065472          IF X.HSTAT BIT 4 THEN
065475             A=:HSTAT=:X.XSTAT                 % ERROR INFORMATION TO SWAPPER
065477             T:=SCTRG=:X.DMTRG
065501             IF A<0 AND X.DQOPC BIT 3SERR THEN
065505                A:=B; CALL PHLOG; A=:9XDV      % DEVICE NUMBER
065510                SVXRG.ABFUN=:9XFU              % FUNCTION
065513                A SHZ -6/\7=:9XUN              % DEVICE UNIT
065516                X.MEMAD=:9XMA                  % MEMORY ADDRESS
065520                X.ABPA2=:9XDA; X.ABP32=:9XTA   % DISK ADDRESS AND AMOUNT
065524                SCOSS=:9XST; X:=X.RTRES        % HARDWARE STATUS AND PROGRAM
065527                *1BANK
065530                CALL 9FLEX(9XER,12)            % REPORT ERROR
065533                *2BANK
065534             FI
065534          FI
065534          *IOF
065535          X:=SVXRG; CALL TO11Q                 % RETURN TO CALLER
065537          *ION
065540          SVTAD; X:=SVXRG; GO SVLRG
065543   *)FILL
065553
065553
065553   % EXECUTE MODE SELECT
065553
065553   INTEGER MSXRG
065554
065554   MDSEL: IF SUTYP SHZ -10=3 THEN
065561             1
065562          ELSE
065563             "0"
065564          FI
065564          X=:MSXRG; T:=X.CMAD1; X:=X.CMAD2     % PHYSICAL ADDRESS OF BUFFER
065567          A SHZ 10; *STZTX 00; STATX 10        % SENSE DATA HEADER
065572          700/\MSXRG.ABFUN\/23=:X.ABFUN        % MODE SELECT FUNCTION
065577          4; AD SHZ -20=:X.ABPA3               % NUMBER OF BYTES
065602          X.CMADR=:X.MEMAD                     % BUFFER ADDRESS
065604          T:="ABFUN-14"+X; "4"; GO SCSID       % ACTIVATE DRIVER
065610   *)FILL
065614   %
065614   % OPERATION TYPE CONTROLL WORDS
065614   %
065614   @ICR;
065614   INTEGER ARRAY OPTYP:=
065614         (100004, 100004, 100004, 100004, 110004, 000000, 000000, 000000,
065624          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
065634          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
065644          000000, 000000, 000000, 000000, 104004, 104004, 044000, 044000,
065654          000000, 000000, 106004, 000000, 000000, 000000, 000000, 000000,
065664          000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000,
065674          110004, 110004, 110004, 110004, 000000, 000000, 110004, 000000,
065704          000000, 000000, 000000, 134002, 074004, 134002, 000000, 000000);
065714   @CR;
065714
065714   INTEGER SAVEX
065715
065715   SCOPTICAL:
065715          A:=L=:X.NFUNC                        % SAVE RETURN ADDRESS
065717   *"8MPRF 8SCOD
"065717          CALL DIALO; 0/\0                     % MON PERFO DISK UTILIZATION
065721   *"8SCOD
"065721          X.ABFUN; X=:SAVEX:=77/\A
065725          *1BANK
065726          OPTYP(X)
065727          *2BANK
065730          IF A=:SAVEX.DQOPC=0 THEN
065733             T:=ILAOP; GO FAR ERR1             % ILLEGAL OPERATION
065735          FI
065735          IF A=:L NBIT 3DPA2 THEN
065740             X.ABP21=:D                        % CONVERT TO DOUBLE DISK ADDRESS
065742             X.ABFUN SHZ -11/\7
065745             AD=:X.ABPA2
065746          FI
065746          IF L NBIT 3DPA3 THEN
065750             X.ABP31=:X.ABP32; 0=:X.ABP31      % CONVERT TO DOUBLE AMOUNT
065753          FI
065753
065753          IF X.ABFUN SHZ -6/\7>3 OR X:=PUNDF(A)=0 THEN
065765             X:=SAVEX; T:=NOLUN; GO FAR ERR1   % NO UNIT DF GENERATED
065770   *)FILL
065774          FI
065774
065774          X=:B:=SAVEX                          % B=UNIT DF, X=DAQ
065776
065776   % --- DISK SORTING
065776          MIN SUNOP; 0/\0
066000          IF L NBIT 3SPES THEN
066002             X.TYPCO BONE SSEEK=:X.TYPCO       % SORT POSSIBLE
066005          FI
066005          IF SLINK><0 THEN
066007             X:=:B; CALL DSORT; GO SWT11       % SORT IN QUEUE
066012          FI
066012          GO NEWOP
066013
066013   ERR1:  CALL FAR RETOP; GO SWT11             % TERMINATE OPERATION
066015   *)FILL
066020
066020   NEWOP: X=:SLINK; 0=:X.NLINK                 % START NEW OPERATION
066022          X.RTRES=:ULINK.STPRW                 % SET ACCESS OWNER
066025          IF SLINK.DQOPC=:SCOCW NBIT 3SPES THEN
066032             X.ABPA2=:CHADD                    % CURRENT HEAD ADDRESS
066034          ELSE
066035             IF 77/\X.ABFUN=42 THEN
066042                X.MEMAD=:MEMAD; X.ABFUN=:ABFUN
066046                0=:ABP31; 100=:ABP32
066051                SCDFA.SUTYP BZERO 5SCIN=:X.SUTYP
066055             ELSE
066056             IF A=36 THEN
066061                T:=X.MEMA1; X:=X.MEMA2; *LDXTX % RETURN DISK LAYOUT FOR INDEX
066064                IF X<<="MAXDI" AND DISPE(X)><0 THEN
066071                   T:=SLINK.MEMA2; X:=X.MEMA1
066074                   A=:D:=11=:L; *MOVAP
066100                   T:=0
066101                ELSE
066102                   T:=BADPA
066103                FI
066103                "0"; GO FAR RETEX
066105             FI FI
066105          FI
066105          X:=SCDFA:=:B; X.TACNS=:X.TACOU       % RETRY COUNT
066111          X.OPSTA BZERO 4SRWO=:X.OPSTA         % CLEAR WRITE RECOVER
066114
066114   RETRY: IF X.SCOCW NBIT 3SNTR THEN
066117             IF X.OPSTA NBIT 4SINI THEN
066122                36=:X.ABFUN; T:=X
066125                CALL SCSID; GO FAR ERRET; CALL ERRFATAL
066130                IF A><0 THEN CALL CHSEN FI
066132                IF SUTYP SHZ -10><3 AND ><4 THEN
066142                   T:=TYPER; GO FAR ERREX      % ILLEGAL DEVICE TYPE
066144                FI
066144                X.OPSTA BONE 4SINI=:X.OPSTA
066147             FI
066147             IF X.OPSTA NBIT 4SMSL THEN
066152                CALL FAR MDSEL; GO FAR ERRET; CALL ERRFATAL
066155                IF A><0 THEN CALL CHSEN FI
066157                X.OPSTA BONE 4SMSL=:X.OPSTA
066162             FI
066162          FI
066162
066162          IF X.OPSTA BIT 4SRWO GO FAR CCRWO    % ATTEMPT TO RECOVER ABORTED WRITE
066165
066165          377/\X.SCOCW; T:=X.SLINK             % CONTROLL WORD AND PARAMETER POINTER
066170          CALL SCSID; GO FAR ERRET; CALL ERRFATAL
066173          IF A><0 THEN CALL CHSEN FI           % CHECK SENSE
066175
066175          IF T:=X.SCOCW BIT 3SF42 THEN
066200             CALL TER42                        % RETURN FUNCTION 42 INFORMATION
066201          FI
066201          X:=:B; T:=0; GO RETEX                % OK RETURN
066204
066204   % CHECK IF SENSE ACCEPTABLE
066204
066204   CHSEN: IF D:=A BZERO 17>1 THEN
066211             IF D=6 OR =13 THEN
066217                MIN X.TACOU; GO RETRY          % UNIT ATTENTION OR ABORTED
066221             FI
066221             B:=X; T:=0; GO RETEX              % ILLEGAL SENSE
066224          FI
066224          EXIT
066225   *)FILL
066243
066243   ERRET: IF PFAIL=T OR SBRST=T OR LIRST=T THEN
066254             D:=X; 77/\X.SLINK.ABFUN; D=:X:=A  % FUNCTION CODE
066262             IF 1=D OR 61=D THEN
066270                X.OPSTA BONE 4SRWO=:X.OPSTA    % WRITE RECOVER NECESSARY
066273             FI
066273             MIN X.TACOU; GO FAR RETRY         % ATTEMPT RETRY
066275          FI
066275
066275   ERREX: B:=X; 20                             % INDICATE ERROR
066277
066277   RETEX: B=:D; X:=ULINK:=:B:=X.SLINK
066303          0=:STPRW; CALL FAR RETOP             % TERMINATE OPERATION
066305          B:=D; 0=:SLINK; SUNOP-1=:SUNOP
066312          IF X:=SCLINK><0 THEN
066314             IF X.NLINK=:SCLINK=0 THEN
066317                0=:PLELE                       % LAST ELEMENT
066320             FI
066320             IF PLHAD=X THEN
066323                0=:PLHAD                       % CURRENTLY LAST IN DIRECTION
066324             ELSE
066325             IF A=0 THEN
066326                PLELE=:PLHAD; MIN MOVME; 0/\0  % CHANGE DIRECTION
066332             FI FI
066332             GO FAR NEWOP
066333          FI
066333          GO SWT11
066334   *)FILL
066340
066340   % UPDATE USERS FUNCTION 42 INFORMATION
066340
066340   INTEGER POINTER SAVL
066341   INTEGER SAVA
066342   INTEGER SAVX=?
066342
066342   TER42: A=:SAVA:=L=:"SAVL"; X=:SAVX
066346          IF SURSZ=4000 THEN
066352             41                                % DISK LAYOUT INDEX (RS=2048 BYTES)
066353          ELSE
066354          IF A=2000 THEN
066357             40                                % DISK LAYOUT INDEX (RS=1024 BYTES)
066360          ELSE
066361             -1                                % NO INDEX
066362          FI FI
066362          T:=MEMA1; X:=MEMA2; *STATX 00        % RETURN INDEX
066365          SURSZ=:L:=44000=:D:=17; *RDIV SL     % RESERVE ONE MEGABYTE FOR TEST
066373          A+1=:L; *LDDTX 10
066376          D-L; *RADD 0 CM1 ADC DA; STDTX 10    % RETURN NEW VALUE
066401          A:=SAVA; X:=SAVX; GO SAVL
066404
066404   % ROUTINE TO RECOVER ABORTED WRITE OPERATION
066404
066404   INTEGER SAVX
066405
066405   CCRWO: X=:SAVX; T:=X.CMAD1=:X.ABP21         % COMMAND ADDRESS
066410          X.CMAD2+2=:X.ABP22=:X
066414          27402; *STATX 00                     % COMPARE COMMAND
066416          SAVX.SLINK.ABPA2; T:=SUSI1; *EXR ST  % DEVICE BLOCK ADDRESS
066423          T:=SAVX.ABP21; X:=X.ABP22; *STDTX 10
066427          SAVX.SLINK.ABPA3; T:=SUSI1; *EXR ST  % DEVICE NUMBER OF BLOCKS
066434          T:=SAVX.ABP21; X:=X.ABP22
066437          A:=0; AD SHZ 10; *STDTX 30
066442          AD SHZ -10; T:=SUSI3; *EXR ST        % BYTECOUNT
066445          AD=:SAVX.ABPA3
066447          X.SLINK.MEMAD=:SAVX.MEMAD            % MEMORY ADDRESS
066453          700/\X.SLINK.ABFUN\/74=:SAVX.ABFUN   % USER SPECIFIED COMMAND
066461          377/\X.SCOCW; T:=X
066464          CALL SCSID; GO FAR ERRET; CALL ERRFATAL
066467          IF A=100010 THEN                     % BLANK CHECK
066472             T:=X.ABP21; X=:SAVX:=X.ABP22      % COMMAND ADDRESS
066475             25000; *STATX 00; LDATX 20        % WRITE COMMAND
066500             A=:L; ABPA3; *STDTX 10; LDDTX 30  % FAILING ADDRESS
066504             AD SHZ -10; ABP32-L=:L:=:D-D      % NEW AMOUNT
066512             AD SHZ -10; *STDTX 30
066514             AD SHZ -10; T:=SUSI3; *EXR ST     % BYTECOUNT
066517             AD=:SAVX.ABPA3; A:=0; D:=L; *EXR ST
066524             AD SHZ -1; A:=:D+X.MEMA2=:X.MEMA2 % MEMORY ADDRESS
066530             A:=D+C+X.MEMA1=:X.MEMA1
066533             377/\X.SCOCW; T:=X
066536             CALL SCSID; GO FAR ERRET; CALL ERRFATAL
066541          FI
066541          IF A><0 THEN CALL FAR CHSEN FI       % CHECK SENSE
066543          GO FAR RETEX
066544
066544   RBUS
066562   *"
"066562   @DEV 1
066562   @DEV (S-S-L)IP-P2-SCSI-DRIV:NPL
066562   SUBR SCLLD, SCINT, SCTIO
066562   %
066562   % CALL SEQUENCE
066562   %
066562   %       JPL I (SCLLD
066562   %       JMP BUSY
066562   %       JMP ERROR
066562   %       JMP FIN
066562   %
066562   % ENTRY:
066562   %          A = FUNTION TYPE
066562   %          X = UNIT DATAFIELD
066562   %
066562
066562   % ERROR CONDITIONS
066562   SYMBOL 7SIDE=5               % INITIATOR DETECTED ERROR
066562   SYMBOL 7SMRJ=7               % MESSAGE REJECT
066562   SYMBOL 7SMPE=11              % MESSAGE PARITY ERROR
066562
066562   %..............................
066562   % DEFINITIONS FOR SCSI DRIVER .
066562   %..............................
066562
066562   SYMBOL RLMAR=00              % READ MEMORY ADDRESS REGISTER BITS 14-0
066562   SYMBOL WLMAR=01              % WRITE MEMORY ADDRESS REGISTER BITS 14-0
066562   SYMBOL REDAT=02              % READ DATA
066562   SYMBOL WRDAT=03              % WRITE DATA
066562   SYMBOL RSTAU=04              % READ STATUS
066562   SYMBOL CTBUS=02              % CONTROLLER BUSY
066562   SYMBOL NCRIT=11              % INTERRUPT FROM NCR
066562   SYMBOL SCREQ=15              % REQ FROM SCSI BUS
066562   SYMBOL WCONT=05              % WRITE CONTROL
066562   SYMBOL ENDMA=05              % ENABLE DMA
066562   SYMBOL RHMAR=06              % READ MEMORY ADDRESS REGISTER BITS 23-15
066562   SYMBOL WHMAR=07              % WRITE MEMORY ADDRESS REGISTER BITS 23-15
066562   SYMBOL RNDAT=40              % READ NCR DATA REGISTER
066562   SYMBOL WNDAT=41              % WRITE NCR DATA REGIISTER
066562   SYMBOL RNCOM=42              % READ NCR COMMAND REGISTER
066562   SYMBOL WNCOM=43              % WRITE NCR COMMAND REGISTER
066562   SYMBOL RNCNT=44              % READ NCR CONTROL REGISTER
066562   SYMBOL WNCNT=45              % WRITE NCR CONTROL REGISTER
066562   SYMBOL RDESI=46              % READ DESTINATION ID REGISTER
066562   SYMBOL WDESI=47              % WRITE DESTINATION ID REGISTER
066562   SYMBOL RAUXS=50              % READ AUXILIARY STATUS
066562   SYMBOL DARGF=07              % DATA REGISTER FULL
066562   SYMBOL WAUXS=51              % WRITE AUXILIARY STATUS
066562   SYMBOL ROIDN=52              % READ OWN ID NUMBER
066562   SYMBOL RITRG=54              % READ INTERRUPT REGISTER
066562
066562   SYMBOL ILCOM=16              % ILLEGAL COMMAND
066562   SYMBOL RECON=14              % RECONNECT
066562   SYMBOL CONEC=13              % CONNECT
066562   SYMBOL DISCO=12              % DISCONNECT
066562   SYMBOL BUSSI=11              % BUS SERVICE INTERRUPT
066562   SYMBOL FUCOM=10              % FUNCTION COMPLETE
066562   SYMBOL PARIT=06              % PARITY ERROR
066562   SYMBOL PAUSE=02              % PAUSED
066562   SYMBOL TCZRO=01              % TRANSFER COUNT ZERO
066562
066562   SYMBOL RSOUI=56              % READ SOURCE ID
066562   SYMBOL RDIST=62              % READ DIAGNOSTIC STATUS
066562   SYMBOL SLFCO=07              % SELFTEST COMPLEAT NCR 5386
066562   SYMBOL RTCM=70               % READ TRANSFER COUNTER MOST
066562   SYMBOL WTCM=71               % WRITE TRANSFER COUNTER MOST
066562   SYMBOL RTC2=72               % READ TRANSFER COUNTER 2ND.
066562   SYMBOL WTC2=73               % WRITE TRANSFER COUNTER 2ND.
066562   SYMBOL RTCL=74               % READ TRANSFER COUNTER LEAST
066562   SYMBOL WTCL=75               % WRITE TRANSFER COUNTER LEAST
066562
066562   SYMBOL 6SFUN=17              % FUNCTION STARTED
066562   SYMBOL 6SIDE=16              % SEND IDENTIFY
066562   SYMBOL 6SRST=15              % SCSI BUS RESET
066562   SYMBOL 6SMSO=12              % MESSAGE OUT PENDING
066562   SYMBOL 6SRFD=11              % RETURN ON COMMAND ACCEPTED (I.E. FIRST DISCONNECT)
066562   SYMBOL 6SDIS=10              % DISCONNECT MESSAGE RECEIVED
066562   SYMBOL 6SCCO=7               % COMMAND COMPLETE MESSAGE RECEIVED
066562   SYMBOL 6SMSI=6               % MESSAGE RECEIVED
066562   SYMBOL 6SARB=5               % ARBITRATION PHASE
066562   SYMBOL 6SSBT=4               % SINGLE BYTE TRANSFER
066562   SYMBOL 6SCRP=3               % CONNECT/RECONNECT PHASE
066562
066562   SYMBOL CNCLR=177000          % MASK FOR FLAGS CLEARED ON CONNECT PATH
066562   SYMBOL DCCLR=136400          % MASK FOR FLAGS CLEARED ON DISCONNECT PATH
066562   SYMBOL NPCLR=137000          % MASK FOR FLAGS CLEARED ON NEW PHASE
066562
066562   % SAVED STATUS ON ERROR RESET
066562
066562   DISP -32
066562      INTEGER SEST1, SEST2, SEST3, SEST4, SEST5
066562   PSID
066562
066562   SCLLD: IF D:=A SHZ -10<3 THEN
066567             A=:X.SUCON:=L=:X.SULRG; 0=:X.SUTRG     % CONTROLL AND RETURN ADDRESS
066573             IF NCROK<0 THEN
066575                T:=NCRST; GO FAR EXDRI              % ERROR IN INTERFACE
066577             FI
066577             CALL INITO                             % INITIALIZE OPERATION
066600             IF BUSFL=0 THEN CALL SELEC FI          % START ARBITRATION
066603          ELSE
066604          IF D=3 THEN
066607             A=:X.SUCON:=L=:X.SULRG; 0=:X.SUTRG     % CONTROLL AND RETURN ADDRESS
066613             "0" BONE 6SFUN=:X.SUTHS                % INITIAL STATUS
066616             CALL ENTIM                             % ENABLE TIMER
066617          ELSE
066620          IF D=4 THEN
066623             IF T:=NCROK NBIT 8SRST THEN
066626                X=:SCRXR:=L=:SCRLR             % SAVE REGISTERS
066631                A=:SCRCO; GO FAR SCRST         % PERFORM RESET
066633             ELSE
066634                T:=0; L+1; EXITA               % ALREADY IN PROGRESS
066637             FI
066637          ELSE
066640             T:=ILDCO                          % ILLEGAL FUNCTION
066641          FI FI FI
066641          GO SCWTI                             % BUSY RETURN
066642   *)FILL
066647
066647   % INTERRUPT HANDLER
066647
066647   DOUBLE RBSIR(0); * 1@BUSSI; NEWPH
066651
066651   SCINT: T:=HDEV+RSTAU; *IOXT                 % READ DEVICE STATUS
066654          IF X:=64/\A><0 THEN
066657             IF A BIT 2 GO SCWTI               % CONTROLLER BUSY
066661             IF A=:SCSSR BIT 5 THEN
066664                T:=SBRST; GO FAR SCDIS         % SCSI BUS RESET RECEIVED
066666             FI
066666             IF A BIT 4 THEN
066670                CALL SCIDE; A:=SCSSR           % "INITIATOR DETECTED ERROR"
066672             FI
066672          FI
066672          IF A=:SCSSR BIT 11 THEN              % INTERRUPT FROM NCR
066675             "0"; T:=HDEV+WCONT; *IOXT         % CLEAR TO MEMORY
066701             T+"RAUXS-WCONT"; *IOXT            % READ AUXILIARY STATUS
066703             AD SHZ -10
066704             T+"RITRG-RAUXS"; *IOXT            % READ INTERRUPT REGISTER
066706             AD SHZ -10
066707             A:=D=:SCNIS; 0=:SCCCW             % NEW STATUS
066712
066712             IF A/\177500=SCEIM THEN           % EXPECTED INTERRUPT
066716                CALL SCISR                     % INTERRUPT SERVICE ROUTINE
066717             ELSE
066720                A SHZ -10; X:=BUSFL
066722                IF A=4 AND X><0 THEN
066726                   IF X:=SCCSU><0 THEN
066730                      CALL DCTHR               % DISCONNECT LOGICAL THREAD
066731                   ELSE
066732                   IF BUSFL BIT 6SARB THEN     % ABITRATION TIMEOUT
066735                      MIN SCWAQ.SUTMR; X:=0    % COUNT RETRIES
066740                      IF X><0 THEN
066741                         0=:SCTST; CALL RSTMR  % RESET TIMER
066743                         CALL RFWAQ            % NOT ABLE TO SELECT DEVICE
066744                         T:=NESER; CALL TEROP  % TERMINATE OPERATION
066746                      FI
066746                   FI FI
066746                   GO FAR BUSFP
066747   *)FILL
066757                ELSE
066760                IF A=1 AND X BIT 6SARB THEN
066765                   CALL RFWAQ                  % ARBITRATION WON
066766                   CNCLR/\X.SUTHS BONE 6SCRP   % FETCH FLAGS
066771                   A=:BUSFL; CALL CNTHR        % CONNECT PHYSICAL PATH
066773                   0=:SCTST; CALL ENTIM        % START TIMER
066775                   RBSIR=:SCNIH                % ALLOW BUS SERVICE INTERRUPTS
066777                ELSE
067000                IF A=20 AND X BZERO 6SARB BZERO 6SRST=0 THEN
067007                   X BONE 6SCRP=:BUSFL         % INDICATE RECONNECT
067011                   RBSIR=:SCNIH                % ALLOW BUS SERVICE INTERRUPTS
067013                ELSE
067014                IF A=1 AND T:=NCROK BIT 8SDIA THEN
067022                   GO FAR STFIN                % SELFTEST FINSHED
067023                ELSE
067024                IF A=SCEIM SHZ -10 AND D BIT PARIT AND 11/\BUSFL=1 THEN
067037                   MIN SCNPE; 0/\0             % COUNT PARITY ERRORS
067041                   IF 17/\BUSFL=7 THEN
067046                      CALL SCMPE               % "MESSAGE PARITY ERROR"
067047                   ELSE
067050                      CALL SCIDE               % "INITATOR DETECTED ERROR"
067051                   FI
067051                   CALL SCISR
067052                ELSE
067053                   T:=NCRER; GO FAR SCDIS      % ILLEGAL INTERRUPT
067055                FI FI FI FI FI
067055             FI
067055          FI
067055          5\/SCCCW; T:=HDEV+WCONT; *IOXT       % ACTIVATE+ENABLE INTERRUPT
067062          GO SCWTI
067063   *)FILL
067073
067073   % TIMEOUT ROUTINE
067073
067073   INTEGER ABFLG=?
067073
067073   SCTIO: IF NCROK BIT 8SCLR THEN
067076             SCRSQ=:SCRSL; A:=B=:SCRSQ         % ENABLE DIRECT TIMEOUT
067102             IF X:=SCCSU><0 THEN
067104                T:=X.SUTRG; 0=:X.SUTRG; CALL TEROP  % DISCONNECT CURRENT
067107                0=:SCCSU; "0" BONE 6SRST=:BUSFL     % ALLOW RECONNECT
067113                GO FAR EXDRI                        % RETURN TO USER
067114             FI
067114             X:="SCTQP-SULINK"+B
067116             DO
067116               WHILE X:=X.SULINK><0
067120               IF X.SUTHS BIT 6SRST THEN
067123                  CALL TEROP; GO FAR EXDRI     % TERMINATE OPERATION
067125               FI
067125             OD
067126             NCROK BZERO 8SCLR=:NCROK          % RESET CLEANUP FINISHED
067131          FI
067131          IF NCROK><0 AND A BZERO 8SRST=0 THEN
067135             0=:NCROK=:SCTST; CALL RSTMR       % RESTART TIMER
067140             IF BUSFL BZERO 6SRST=0 THEN
067143                CALL SELEC                     % RESTART INTERFACE
067144             FI
067144          FI
067144          IF SCRCO><0 AND NCROK NBIT 8SDIA AND NBIT 8SRIN THEN
067153             0=:SCRCO; X:=SCRXR                % RETURN FROM BUS RESET
067155             IF NCROK BIT 8SERR THEN
067160                T:=NCRST; SCRLR=:P             % ERROR RETURN
067163             ELSE
067164                T:=0; SCRLR+2=:P               % OK RETURN
067170   *)FILL
067176             FI
067176          FI
067176          IF TMR=0 THEN
067200             IF NCROK><0 THEN
067202                IF A BIT 8SRIN GO FAR SCRST   % TIMEOUT ON RESET RECEIVE
067204                IF A BIT 8SERR THEN
067206                   IF X:=SCTQP=0 THEN
067211                      IF X:=SCWAQ><0 THEN CALL RFWAQ FI
067214                   FI
067214                   IF X><0 THEN
067215                      SCRSQ=:SCRSL; A:=B=:SCRSQ     % DIRECT TIMEOUT
067221                      T:=NCRST; CALL TEROP          % TERMINATE OPERATION
067223                      GO FAR EXDRI                  % RETURN TO USER
067224                   FI
067224                ELSE
067225                   GO FAR STFIN              % DIAGNOSTICS TIMEOUT
067226                FI
067226             ELSE
067227             IF SCTST=1 THEN
067233                IF BUSFL BIT 6SARB THEN
067236                   MIN SCWAQ.SUTMR; X:=0     % ABITRATION TIMEOUT
067241                   IF X><0 THEN
067242                      CALL RFWAQ; X=:SCCSU   % TERMINATE
067244                      IF X.SUTRG=CMTMO THEN
067250                         T:=CMTMA            % TIMEOUT, NOT ABORT
067251                      ELSE
067252                         T:=ASOTM            % SELECT TIMEOUT
067253                      FI
067253                   ELSE
067254                      T:=ASOTM               % SELECT TIMEOUT
067255                   FI
067255                   T:=ASOTM; GO FAR SCDIS    % RESET INTERFACE
067257                FI
067257             ELSE
067260             IF X:=SCTQP><0 THEN
067262                IF X.SUTMR=0 THEN
067264                   IF SCCSU=X THEN
067267                      T:=CNTMO; GO FAR SCDIS   % CONNECTION TIMEOUT
067271                   FI
067271                   CMTMO=:X.SUTRG              % OPERATION TIMEOUT
067273                   CALL DITIM; ABFLG=:X.SUTHS  % ABORT OPERATION
067276                   177760/\X.SUCON\/2=:X.SUCON % NEW TIMEOUT
067302                   SCWAQ=:X.SULINK; X=:SCWAQ   % INSERT IN ARBITRATION QUEUE
067305                   -1=:X.SUTMR; CALL SELEC     % SEND ABORT
067310                FI
067310                CALL RSTMR                     % RESET TIMER
067311             FI FI FI
067311          FI
067311          GO SCWTI
067312   *)FILL
067325
067325   INTEGER ABFLG:=6; * *-1/1@6SMSO+^; *-1/1@6SIDE+^
067326
067326   % FATAL ERROR: RESET SCSI BUS
067326   SCDIS: IF X:=SCCSU><0 THEN
067330             IF X.SUTRG=0 THEN T=:X.SUTRG FI
067333          FI
067333          BUSFL=:SEST1                         % SAVE STATUS
067335          SCSSR=:SEST2
067337          SCNIS=:SEST3
067341          CMSGI=:SEST4
067343          CMSGO=:SEST5
067345          T=:SCLRE; GO FAR SCRST               % RESET SCSI BUS
067347
067347   % BUS FREE PHASE
067347   BUSFP: CALL SELEC                           % CHECK ARBITRATION QUEUE
067350
067350   % EXIT DRIVER: X = LUN DATAFIELD OR 0. T = STATUS
067350   EXDRI: IF X=0 GO SCWTI; X.SULRG             % NO RETURN
067353          IF T=0 THEN A+2=:P FI                % NORMAL RETURN
067357          IF T<0 THEN
067361             A+1                               % INTERMIDIATE RETURN
067362          ELSE
067363             MIN ERCNT; 0/\0                   % ERROR RETURN
067365          FI
067365          A=:P
067366   *)FILL
067370
067370   % MSGIN: MESSAGE IN HANDLING
067370
067370   INTEGER POINTER HOME2
067371   DOUBLE BSISR(0); * 1@BUSSI; NEWPH
067373
067373   MSGIN: A:=L=:"HOME2"
067375          IF BUSFL BIT 6SMSI THEN CALL MSGI FI % MESSAGE IN HANDLING
067401          4; T:=HDEV+WNCOM; *IOXT              % "Message Accepted" TO NCR
067405          BSISR=:SCNIH; GO HOME2               % ALLOW BUS SERVICE INTERRUPTS
067410
067410
067410   MSGI:  IF X:=SCCSU=0 THEN
067413             IF CMSGI BIT 7 THEN
067416                AD SHZ 15 SHZ -35              % LUN
067420                T:=HDEV+RSOUI; *IOXT           % READ BUS DEVICE NUMBER
067423                X:=7/\A:=SCDVD(X)
067426                IF X><0 AND D<X.SDNLU THEN
067432                   SULEN; *RMPY SD DA
067434                   X+D+"SDLEN"; T:=X.SUTHS
067437                   CNCLR/\T+7=:BUSFL           % RESTORE FLAGS
067443                   IF T BIT 6SDIS GO FAR CNTHR % CONNECT THREAD
067445                   GO FAR SCABO                % CONNECT THREAD
067446                FI
067446             FI
067446             GO FAR SCDIS                      % IMPOSSIBLE
067447             *)FILL
067454          FI
067454
067454          IF CMSGI<=7 THEN
067460
067460             GOSW MSG0,MSG1,MSG2,MSG3,MSG4,MSGR,MSGR,MSG7
067471
067471   MSG0:     BUSFL BONE 6SCCO=:BUSFL           % "COMMAND COMPLETE"
067474             EXIT
067475
067475   MSG2:     SCCDP=:X.SUSDP; SCCBC=:X.SUSBC    % "SAVE DATA POINTER"
067501             EXIT
067502
067502   MSG1:     IF SCEM1=2400 THEN                % MODIFY DATA POINTER
067506
067506             ELSE
067507             IF A=2261 THEN                    % SYNCRONOUS TRANSFER REQUEST
067512
067512             ELSE
067513             IF A=1002 THEN                    % EXTENDED IDENTIFY
067516
067516             FI FI FI
067516             GO FAR MSGR
067517
067517
067517   MSG3:     X.SUSDP=:SCCDP; X.SUSBC=:SCCBC    % "RESTORE POINTERS"
067523             EXIT
067524
067524   MSG4:     BUSFL BONE 6SDIS=:BUSFL           % "DISCONNECT"
067527             EXIT
067530
067530   MSG7:     IF LMSGO/\377=5 OR =11 THEN       % "MESSAGE REJECT"
067540                T:=TRANE; GO FAR SCABO         % SEND "ABORT"
067542             ELSE
067543             IF A=14 THEN
067546                T:=FNIPL; GO FAR SCABO         % NOT IMPLEMENTED
067550             ELSE
067551                T:=SPCER; GO FAR SCABO         % ILLEGAL
067553             FI FI
067553          FI
067553
067553   MSGR:  GO FAR SCMRJ                         % RETURN "MESSAGE REJECT"
067554   *)FILL
067563
067563   % SELEC: ACTIVATE CONTROLLER
067563
067563   TRIPLE SVTAD
067566   INTEGER SAVXR
067567
067567   SELEC: TAD=:SVTAD; X=:SAVXR
067571          -1=:SCEIM                            % DISABLE INTERRUPT
067573          IF X:=SCWAQ><0 THEN
067575             "0"; T:=HDEV+WCONT; *IOXT         % CLEAR TO MEMORY
067601             A BONE 6SARB=:BUSFL               % INDICATE ARBITRATION
067603             X.SUDLU SHZ -14                   % SCSI IDENT
067605             T+"WDESI-WCONT"; *IOXT
067607             WATFS; T+"WTCM-WDESI"; *IOXT      % SET WAITING TIME INTO TRANSFER COUNTER
067612             AD SHZ 10; T+"WTC2-WTCM"; *IOXT
067615             AD SHZ 10; T+"WTCL-WTC2"; *IOXT
067620             10; IF X:=X.SUCON BIT 4SINA THEN 11 FI
067625             T+"WNCOM-WTCL"; *IOXT             % SELECT COMMAND TO NCR
067627             IF X:=SCTST>>2 THEN
067633                TMR=:X.SUTMR                   % SAVE CURRENT TIMER
067635             FI
067635             1=:SCTST; -5=:TMR                 % ENABLE SELECT TIMEOUT
067641          ELSE
067642             0=:BUSFL                          % BUS FREE
067643          FI
067643          5; T:=HDEV+WCONT; *IOXT              % ENABLE INTERRUPT
067647          X:=SAVXR; SVTAD
067651          EXIT
067652
067652   % RFWAQ: REMOVE FROM WAITING FOR ARBITRATION QUEUE.
067652
067652   RFWAQ: IF X:=SCWAQ><0 THEN
067654             X.SULINK=:SCWAQ; 0=:X.SULINK
067657          FI
067657          EXIT
067660   *)FILL
067660
067660
067660   % INITO: INITIALIZE OPERATION
067660
067660   INTEGER INOPR:=0; * *-1/1@6SFUN+^; *-1/1@6SIDE+^
067661   INTEGER INABO:=6; * *-1/1@6SMSO+^
067662   INTEGER INBDR:=14; * *-1/1@6SMSO+^
067663
067663   INITO: IF X.SUCON=:D SHZ -10=0 THEN
067667             INOPR                             % NORMAL OPERATION
067670             IF D BIT 4SRCA THEN
067672                A BONE 6SRFD                   % RETURN ON COMMAND ACCEPTED
067673             FI
067673          ELSE
067674          IF A-1=0 THEN
067676             INABO                             % ABORT
067677          ELSE
067700             INBDR                             % BUS DEVICE RESET
067701          FI FI
067701          A=:X.SUTHS; -1=:X.SUSTA              % INITIAL STATUS
067704          X.SUIDP=:X.SUSDP; X.SUIBC=:X.SUSBC   % INITIAL POINTERS
067710          -2=:X.SUTMR; "SCWAQ-SULINK"+B; T:=X  % INSERT IN ARBITRATION WAITING QUEUE
067715          DO A=:X; WHILE X.SULINK><0 OD
067721          T=:X.SULINK
067722          EXIT
067723
067723   % CNTHR: CONNECT PHYSICAL PATH
067723
067723   CNTHR: X=:SCCSU                             % INDICATE PATH CONNECTED
067724          IF X.SUTHS BIT 6SMSO THEN
067727             A/\377=:CMSGO                     % RESTORE MESSAGE
067731             3; T:=HDEV+WNCOM; *IOXT           % "Set ATN" TO NRC
067735          FI
067735          X.SUSDP=:SCCDP; X.SUSBC=:SCCBC       % RESTORE POINTERS
067741          EXIT
067742
067742   % DCTHR: DISCONNECT PHYSICAL PATH
067742
067742   INTEGER POINTER HOME4
067743
067743   DCTHR: A:=L=:"HOME4"                        % RETURN ADDRESS
067745          IF T:=X.SUTRG=0 AND BUSFL BIT 6SDIS THEN
067753             IF A BIT 6SRFD THEN
067755                A/\DCCLR\/CMSGO=:X.SUTHS       % SAVE THREAD STATUS
067760                T:=-1                          % INTERMIDIATE RETURN
067761             ELSE
067762                A/\DCCLR\/CMSGO=:X.SUTHS       % SAVE THREAD STATUS
067765                X:=0                           % NO RETURN
067766             FI
067766          ELSE
067767             CALL TEROP                        % TERMINATE (T=STATUS)
067770          FI
067770          0=:SCCSU; GO HOME4                   % RETURN
067772   *)FILL
067776
067776   % RESTART LOGICAL UNIT TIMER
067776
067776   INTEGER SAVRX
067777
067777   RSTMR: IF SCTST=0 THEN
070001             IF X=:SAVRX:=SCTQP><0 THEN
070004                IF X.SUTMR=:TMR><0 THEN        % NEW TIME VALUE
070007                   0=:X.SUTMR; X=:SCTST        % INDICATE TIMER RUNNING
070011                ELSE
070012                   SCRSQ=:SCRSL; A:=B=:SCRSQ   % DIRECT TIMEOUT
070016                FI
070016             ELSE
070017                0=:TMR                         % DISABLE TIMER
070020             FI
070020             X:=SAVRX
070021          FI
070021          EXIT
070022
070022   INTEGER SHTIN(0); *SHT ZIN                  % SHIFT INSTRUCTION
070023   INTEGER POINTER HOME5=?
070023   TRIPLE TITAD=?
070023   INTEGER SAVX=?
070023
070023   % ENABLE LOGICAL UNIT TIMER
070023
070023   ENTIM: TAD=:TITAD; X:=:L=:"HOME5"
070026          IF X:=SCTST>>2 THEN
070032             TMR=:X.SUTMR; 0=:SCTST            % SAVE CURRENT TIMER
070035          FI
070035          17/\L.SUCON\/SHTIN; T:=-1; *EXR SA   % CALCULATE MAX TIME
070043          D:=B; X:="SCTQP-SULINK"+B
070046          DO
070046             WHILE X=:B:=X.SULINK><0 AND X.SUTMR>=T
070054             T-A
070055          OD
070056          IF X><0 THEN A-T=:X.SUTMR FI         % UPDATE NEXT ELEMENT
070061          SULINK=:L.SULINK; X=:SULINK; B:=D    % LINK INTO TIMER QUEUE
070066          T=:X.SUTMR; CALL RSTMR               % RESET TIMER
070070          TITAD; GO HOME5
070072   *)FILL
070075
070075   % TEROP: TERMINATE OPERATION, T = STATUS
070075
070075   INTEGER POINTER HOME5
070076   TRIPLE TITAD
070101   INTEGER SAVX
070102
070102   TEROP: IF X.SUTRG=0 THEN
070104             IF SCCSU=X THEN
070107                SCCDP=:X.SUSDP; SCCBC=:X.SUSBC % SAVE DATA POINTERS
070113                IF BUSFL NBIT 6SMSO THEN
070116                   IF A BIT 6SCCO THEN
070120                      IF X.SUSTA<0 THEN
070122                         T:=NOSST              % NO STATUS RECEIVED
070123                      ELSE
070124                         T:=0                  % COMMAND COMPLETE
070125                      FI
070125                   ELSE
070126                   IF X.SUCON SHZ -10=0 AND T=0 THEN
070133                      T:=UNDIS                 % UNEXPECTED DISCONNECT
070134                   FI FI
070134                ELSE
070135                IF T=0 THEN
070137                   IF CMSGO=5 OR =11 THEN
070146                      T:=TRANE                 % PARITY ERROR
070147                   ELSE
070150                      T:=MNIBT                 % MESSAGE NOT IMPLEMENTED
070151                   FI
070151                FI FI
070151             ELSE
070152             IF X.SUCON SHZ -10-3=0 AND CMTMO=T THEN
070161                T:=0                           % TIMER FINISHED
070162             FI FI
070162          ELSE
070163             A=:T                              % ERROR IN OPERATION
070164          FI
070164          0=:X.SUTHS                           % INDICATE FREE
070165
070165   % DITIM: DISABLE LOCICAL UNIT TIMER
070165
070165   DITIM: TAD=:TITAD; X=:SAVX:=:L=:"HOME5"
070171          IF X:=SCTQP><0 THEN
070173             IF X:=SCTST>>2 THEN
070177                TMR=:X.SUTMR; 0=:SCTST         % SAVE TIMER
070202             FI
070202             X:="SCTQP-SULINK"+B
070204             DO
070204                X=:D
070205                WHILE X:=X.SULINK><L AND X><0
070211             OD
070212             IF X=L THEN
070214                IF T:=X.SULINK=:D.SULINK><0 THEN
070221                   0=:L.SULINK
070223                   X.SUTMR+T.SUTMR=:X.SUTMR
070227                FI
070227             FI
070227             CALL RSTMR
070230          FI
070230          X:=SAVX; TITAD; GO HOME5
070233   *)FILL
070235
070235   % START RESET SEQUENCE ON SCSI BUS
070235
070235   INTEGER RWCNT
070236   INTEGER CLMSK:=0; * *-1/1@8SRIN+^; *-1/1@8SDIA+^; *-1/1@8STMR+^
070237                     * *-1/1@8SERR+^; *-1/177777-^
070237
070237   SCRST: IF NCROK=0 THEN
070241             IF X:=SCTST>>2 THEN TMR=:X.SUTMR FI    % SAVE CURRENT TIMER
070247             IF SCSSR BIT 5 THEN
070252                NCROK BONE 8SRIN=:NCROK; T:=SBRST   % RECEIVING RESET
070256             ELSE
070257                T:=LIRST
070260             FI
070260             IF X:=SCCSU><0 THEN
070262                IF X.SUTRG=0 THEN T=:X.SUTRG FI     % SET STATUS
070265                BUSFL BONE 6SRST=:BUSFL             % INDICATE RESET STARTED
070270                NCROK BONE 8SCLR=:NCROK             % RECOVERY NECESSARY
070273             ELSE
070274                "0" BONE 6SRST=:BUSFL               % INDICATE RESET STARTED
070277             FI
070277             X:="SCTQP-SULINK"+B
070301             DO
070301                WHILE X:=X.SULINK><0                % FOR ALL ACTIVE OPERATIONS
070303                IF X.SUCON NBIT 4SRST AND X.SUTHS BIT 6SDIS THEN
070311                   A BONE 6SRST=:X.SUTHS            % INDICATE RESET
070313                   IF X.SUTRG=0 THEN T=:X.SUTRG FI  % SET STATUS
070316                   NCROK BONE 8SCLR=:NCROK          % RECOVERY NECESSARY
070321                FI
070321             OD
070322          ELSE
070323             NCROK/\CLMSK=:NCROK
070326          FI
070326          NCROK BONE 8SRST=:NCROK              % INDICATE RESET STARTED
070331          -1=:SCEIM; 2=:SCTST                  % LOCK INTERFACE
070335          "0"; T:=HDEV+WNCOM; *IOXT            % DISCONNECT TO NCR
070341          20; T+"WCONT-WNCOM"; *IOXT           % CLEAR CONTROLLER
070344          T+"RSTAU-WCONT"; *IOXT               % READ STATUS
070346          IF A BIT 5 THEN
070350             NCROK BONE 8SRIN=:NCROK; -1=:TMR  % RECEIVING RST
070355          ELSE
070356             2000; T+"WCONT-RSTAU"; *IOXT      % SET RESET ON SCSI BUS
070361             -10000=:TMR; FOR TMR DO OD        % LEAVE "RST" ON FOR AT LEAST 250 us
070365             "0"; *IOXT                        % CLEAR RESET
070367             T+"RDIST-WCONT"                   % READ DIAGNOSTIC STATUS
070370             FOR X:=-1000 DO
070371                *IOXT
070372                WHILE A NBIT 7
070374             OD
070375             IF A=200 THEN                     % SELFCHECK OK
070400                NCROK BONE 8SDIA=:NCROK
070403                13; T:=HDEV+WNCOM; *IOXT       % START DIAGNOSTIC
070407                376; T+"WNDAT-WNCOM"; *IOXT    % WRITE DATAREGISTER
070412                5; T+"WCONT-WNDAT"; *IOXT      % ENABLE INTERRUPT
070415                -2=:TMR                        % DIAGNOSTIC TIMER
070417             ELSE
070420                100000=:NCROK                  % ERROR IN INTERFACE
070422             FI
070422          FI
070422          GO SCTIO
070423   *)FILL
070433
070433   % TERMINATE RESET ON SCSI BUS
070433
070433   STFIN: IF NCROK BIT 8SDIA THEN
070436             A BZERO 8SDIA=:NCROK              % DIAGNOSTICS FINSHED
070440             IF TMR><0 AND D BIT DARGF THEN
070444                T:=HDEV+RNDAT; *IOXT           % READ DATAREGISTER
070447                16; T+"WNCNT-RNDAT"; *IOXT     % SET NCR CONTROLL
070452                IF A NBIT 1 THEN
070454                   5; T+"WCONT-WNCNT"; *IOXT   % ENABLE INTERRUPT
070457                FI
070457                0=:TMR
070460                IF T:=NCROK BIT 8SPWF THEN
070463                   T BZERO 8SPWF; X:=SLTMR     % LONG TIMER (POWER LOST)
070465                ELSE
070466                   X:=SRTMR                    % RESET TIMER
070467                FI
070467                IF SCRCO NBIT 0 THEN
070472                   X=:TMR; T BONE 8STMR        % ALLOW DEVICE SETTLE TIME
070474                FI
070474                T=:NCROK
070475             ELSE
070476                0=:TMR; 100000=:NCROK          % ERROR IN INTERFACE
070501             FI
070501          ELSE
070502          IF A BIT 8STMR THEN
070504             A BZERO 8STMR=:NCROK; 0=:TMR      % RESET FINSHED
070507          ELSE
070510             0=:TMR; 100000=:NCROK             % ERROR IN INTERFACE
070513          FI FI
070513          GO FAR SCTIO
070514   *)FILL
070520
070520   % NEW PHASE
070520
070520   TRIPLE SAVRG
070523
070523   NEWPH: T:=BUSFL                             % OLD STATUS
070524          IF 36/\T=0 THEN                      % OLD PHASE WAS DATA
070527             TAD=:SAVRG; K:=1
070531             IF D NBIT TCZRO THEN
070533                *BLDA 00 DT                    % PREFECTH FLAG
070534                T:=HDEV+RTCL; *IOXT            % READ LSB OF BYTECOUNT
070537                AD SHZ -10
070540                T+"RTC2-RTCL"; *IOXT           % READ BYTE 2 OF BYTECOUNT
070542                AD SHZ -10
070543                T+"RTCM-RTC2"; *IOXT           % READ MSB OF BYTECOUNT
070545             ELSE
070546                A:=0; D:=0                     % ZERO BYTECOUNT
070550             FI
070550             T:=SCCB1; X:=SCCB2; AD=:SCCBC     % SAVE OLD AND STORE NEW BYTECOUNT
070553             *RADD SD CM2 DX; RADD SA CM1 ADC DT    % GET BYTES TRANSFERED
070555             SCCDP; *RADD SX DD; RADD ST ADC DA     % AND NEW MEMORY ADDRESS
070560             AD=:SCCDP SHZ -1; X:=A            % EXPECTED MAR
070563             IF M THEN                         % STOPPED ON ODD BYTE
070565                IF BUSFL BIT 0 THEN            % ODD BYTE TO ND-100 MEMORY
070570                   150; T:=HDEV+WCONT; *IOXT   % SET TEST MODE
070574                   T+"RLMAR-WCONT"; *IOXT      % FORCE LAST BYTE TO MEMORY
070576                   "0"; T+"WCONT-RLMAR"; *IOXT % CLEAR TEST MODE
070601                FI
070601                D+1; X:=X+C                    % ADJUST EXPECTED MAR
070603             FI
070603             IF K THEN
070605                T:=HDEV+RLMAR; *IOXT           % READ LEAST SIGNIFICANT MAR
070610                IF A><D GO MARER
070612                T+"RHMAR-RLMAR"; *IOXT         % READ MOST SIGNIFICANT MAR
070614                IF A><X GO MARER
070616             FI
070616             SAVRG
070617          FI
070617          AD SHZ 32 SHZ -15                    % GET NEW PHASE
070621          X:=NPCLR/\T\/A=:BUSFL                % SET NEW STATUS
070625
070625          GOSW DAOPH,DAIPH,COMPH,STAPH,FAR ILOPH,FAR ILIPH,FAR MSOPH,FAR MSIPH
070636
070636   MARER: T:=ILMAR; GO FAR SCDIS               % MAR NOT AS EXPECTED
070640
070640   *)FILL
070646
070646   INTEGER WP1, WP2
070650   DOUBLE DWP=WP1
070650
070650   % #0: DATA OUT PHASE
070650
070650   DAOPH: 40=:SCCCW; GO DATPH
070653
070653   % #1 DATA IN PHASE
070653
070653   DAIPH: 140=:SCCCW
070655   DATPH: IF X>=0 GO FAR ILLPH                 % PHASE ILLEGAL
070657          T:=HDEV+WCONT; *IOXT                 % SET TRANSFER DIRECTION
070662          SCCDP SHZ -1                         % MEMORY ADDRESS
070664          IF M THEN                            % MEMORY ADDRESS ON ODD BYTE !
070666             X BONE 6SSBT=:BUSFL; AD=:DWP; SCCBC
070672             *RADD CM1 DD; RADD CM1 ADC DA     % DECREMENT BYTECOUNT
070674             IF A BIT 17 GO BCZRO; AD=:SCCBC   % NEW BYTECOUNT NEGATIVE !
070677             "0"=:SCCCW; *IOXT                 % CLEAR TO MEMORY
070702             124; T+"WNCOM-WCONT"; *IOXT       % "Transfer info, single byte" TO NCR
070705             IF X BIT 0 THEN
070707                L=:D; CALL RINFO; D=:L:=A      % READ BYTE
070713                T:=WP1; X:=WP2; *LDATX         % GET MSB
070716                A/\177400\/D; *STATX           % STORE NEW WORD
070721             ELSE
070722                T:=WP1; X:=WP2; *LDATX         % GET BYTE
070725                T:=HDEV+WNDAT; *IOXT           % SEND
070730             FI
070730             DWP; D+1; A:=A+C; AD SHZ 1=:SCCDP % NEW MEMORY ADDRESS
070735          ELSE
070736             T+"WHMAR-WCONT"; *IOXT            % WRITE MSW OF MAR
070740             A:=D; T+"WLMAR-WHMAR"; *IOXT      % WRITE LSW OF MAR
070743             SCCBC; IF A=D AND D=0 GO BCZRO    % CHECK BYTECOUNT
070750             T+"WTCM-WLMAR"; *IOXT             % MSB OF TRANSFERCOUNTER
070752             AD SHZ 10; T+"WTC2-WTCM"; *IOXT   % 2B OF TRANSFER COUNTER
070755             AD SHZ 10; T+"WTCL-WTC2"; *IOXT   % LSB OF TRANSFER COUNTER
070760             224; T+"WNCOM-WTCL"; *IOXT        % DMA MODE + TRANSFER INFO
070763          FI
070763          EXIT
070764
070764   BCZRO: T:=BCERR; GO FAR SCDIS
070766   *)FILL
070773
070773   % #2 COMMAND PHASE
070773
070773   COMPH: IF X>=0 GO FAR ILLPH                 % PHASE NOT VALID
070775          40=:SCCCW; T:=HDEV+WCONT; *IOXT      % SET TRANSFER DIRECTION
071002          SCCSU.SUCM1; T+"WHMAR-WCONT"; *IOXT  % WRITE MSW OF MAR
071006          X.SUCM2; T+"WLMAR-WHMAR"; *IOXT      % WRITE LSW OF MAR
071011          "0"; T+"WTCM-WLMAR"; *IOXT           % MSB OF TRANSFERCOUNTER
071014          T+"WTC2-WTCM"; *IOXT                 % 2B OFTRANSFER COUNTER
071016          14; T+"WTCL-WTC2"; *IOXT             % LSB OF TRANSFER COUNTER
071021          224; T+"WNCOM-WTCL"; *IOXT           % DMA MODE + TRANSFER INFO
071024          EXIT
071025   *)FILL
071027
071027   % #3 STATUS PHASE
071027
071027   STAPH: IF X>=0 GO FAR ILLPH                 % PHASE NOT VALID
071031          124; T:=HDEV+WNCOM; *IOXT            % "Transfer info, single byte" TO NCR
071035          L=:D; CALL RINFO                     % READ STATUS BYTE
071037          A=:SCCSU.SUSTA; D=:P
071042   *)FILL
071044
071044   % #4 UNSPECIFIED OUT PHASE
071044
071044   ILOPH: T:=ILEPH; GO FAR SCDIS               % "ILLEGAL PHASE"
071046   *)FILL
071047
071047   % #5 UNSPECIFIED IN PHASE
071047
071047   ILIPH: T:=ILEPH; GO FAR SCDIS               % "ILLEGAL PHASE"
071051   *)FILL
071052
071052   % #6 MESSAGE OUT PHASE
071052
071052   MSOPH: IF T BIT 6SIDE THEN
071054             IF SCCSU.SUCON BIT 4SRNA THEN
071060                7/\X.SUDLU\/200                % "IDENTIFY"
071063             ELSE
071064                7/\X.SUDLU\/300                % "IDENTIFY" + "DISCONNECT ALLOWED"
071067             FI
071067             IF T BIT 6SMSO THEN
071071                X:=BUSFL BZERO 6SMSO=:BUSFL    % MARK MESSAGE TRANSFERED
071074                A SHZ 10\/CMSGO; 0=:CMSGO
071077             FI
071077             X:=A
071100          ELSE
071101          IF 17/\T-6=0 THEN
071105             X:=LMSGO                          % RESEND LAST MESSAGE
071106          ELSE
071107          IF T BIT 6SMSO THEN
071111             BUSFL BZERO 6SMSO=:BUSFL          % MARK MESSAGE TRANSFERED
071114             X:=CMSGO; 0=:CMSGO
071116          ELSE
071117             X:=10                             % "NO OPERATION"
071120          FI FI FI
071120          IF X=:LMSGO<0 THEN
071123             40=:SCCCW; T:=HDEV+WCONT; *IOXT   % SET TRANSFER DIRECTION
071130             T:=X; SCPMB; *DEPO                % STORE MESSAGE
071133             T:=HDEV+WHMAR; *IOXT              % WRITE MSW OF MAR
071136             A:=D; T+"WLMAR-WHMAR"; *IOXT      % WRITE LSW OF MAR
071141             "0"; T+"WTCM-WLMAR"; *IOXT        % MSB OF TRANSFERCOUNTER
071144             T+"WTC2-WTCM"; *IOXT              % 2B OFTRANSFER COUNTER
071146             2; T+"WTCL-WTC2"; *IOXT           % LSB OF TRANSFER COUNTER
071151             224; T+"WNCOM-WTCL"; *IOXT        % DMA MODE + TRANSFER INFO
071154          ELSE
071155             124; T:=HDEV+WNCOM; *IOXT         % "Transfer info, single byte" TO NCR
071161             A:=X; T+"WNDAT-WNCOM"; *IOXT      % SEND MESSAGE
071164          FI
071164          EXIT
071165   *)FILL
071170
071170   % #7 MESSAGE IN PHASE
071170
071170   DOUBLE EMEI1(0); *1@FUCOM; EMFC1            % EXTENDED MESSAGE HANDLER
071172   DOUBLE MSFCS(0); *1@FUCOM; MSGIN            % MESSAGE IN HANDLER
071174   INTEGER POINTER MIRET
071175
071175   MSIPH: A:=L=:"MIRET"
071177          124; T:=HDEV+WNCOM; *IOXT            % "Transfer Info, single byte" TO NCR
071203          CALL RINFO; A=:CMSGI                 % READ MESSAGE
071205          IF A-1=0 THEN
071207             EMEI1=:SCNIH                      % EXTENDED MESSAGE
071211          ELSE
071212             MSFCS=:SCNIH                      % FUNCTION COMPLETE NEXT
071214          FI
071214          BUSFL BONE 6SMSI=:BUSFL; GO MIRET    % RETURN
071220
071220   % FUNCTION COMPLETE FOR EXTENDED MESSAGE BYTE
071220
071220   DOUBLE EMEI2(0); *1@BUSSI; EMRML
071222
071222   EMFC1: 4; T:=HDEV+WNCOM; *IOXT              % "Message accepted"
071226          EMEI2=:SCNIH; EXIT                   % EXPECTED INTERRUPT
071231
071231   % READ LENGTH OF MESSAGE
071231
071231   DOUBLE EMEI3(0); *1@FUCOM; EMFC2
071233
071233   EMRML: 124; T:=HDEV+WNCOM; *IOXT            % "Transfer info, single byte"
071237          D:=L; CALL RINFO; L:=D               % GET MESSAGE LENGTH
071242          IF A=:SCEML>SCMBL GO FAR ILLPH       % MESSAGE TO LARGE FOR BUFFER
071246          EMEI3=:SCNIH; EXIT                   % EXPECTED INTERRUPT
071251
071251   % FUNCTION COMPLETE FOR MESSAGE LENGTH BYTE
071251
071251   DOUBLE EMEI4(0); *1@BUSSI; EMRMB
071253
071253   EMFC2: 4; T:=HDEV+WNCOM; *IOXT              % "Message accepted"
071257          EMEI4=:SCNIH; EXIT                   % EXPECTED INTERRUPT
071262
071262   % READ MESSAGE BYTES
071262
071262   DOUBLE EMEI5(0); *1@FUCOM; MSGIN
071264
071264   EMRMB: A:=L=:"MIRET"
071266          "0"; T:=HDEV+WTCM; *IOXT             % MSB OF TRANSFERCOUNTER
071272          T+"WTC2-WTCM"; *IOXT                 % 2B OF TRANSFER COUNTER
071274          SCEML; T+"WTCL-WTC2"; *IOXT          % LSB OF TRANSFER COUNTER
071277          X:=0; 24; T+"WNCOM-WTCL"; *IOXT      % TRANSFER INFO
071303          DO
071303             CALL RINFO; T:="SCEMB"+B; *SBYT   % READ AND STORE BYTE
071307             WHILE X+1<SCEML
071313          OD
071314          EMEI5=:SCNIH; GO MIRET               % FUNCTION COMPLETE NEXT
071317   *)FILL
071322
071322   % IMPOSSIBLE BUS PHASE
071322
071322   ILLPH: T:=SPCER; GO FAR SCDIS
071324   *)FILL
071325
071325   % READ A INFORMATION BYTE FROM SCSI BUS
071325
071325   INTEGER RDCNT
071326
071326   RINFO: T:=HDEV+RAUXS; -2000=:RDCNT
071332          FOR RDCNT DO
071332             *IOXT
071333             IF A BIT DARGF THEN
071335                T+"RNDAT-RAUXS"; *IOXT
071337                EXIT
071340             FI
071340          OD
071342          GO FAR SCINT                         % CHECK FOR INTERRUPT
071343   *)FILL
071345
071345
071345   % SCMRJ: SET "MESSAGE REJECT" MESSAGE TO TARGET
071345
071345   SCMRJ: 7SMRJ; T:=SPCER; GO EMSGO            % SEND MESSAGE
071350
071350   % SCMPE: SET "MESSAGE PARITY ERROR" MESSAGE TO TARGET
071350
071350   SCMPE: BUSFL BZERO 6SMSI=:BUSFL             % THROW AWAY MESSAGE
071353          7SMPE; T:=TRANE; GO EMSGO
071356
071356   % SCIDE: SET "INITIATOR DETECTED ERROR" MESSAGE TO TARGET
071356
071356   SCIDE: IF BUSFL BIT 6SMSO AND CMSGO=7SIDE THEN EXIT FI
071366          7SIDE; T:=TRANE; GO EMSGO
071371
071371   EMSGO: IF X:=BUSFL BIT 6SMSO THEN
071374
071374   % SCABO: ABORT OPERATION
071374
071374   SCABO:    IF X:=SCCSU><0 THEN
071376                IF X.SUTRG=0 THEN T=:X.SUTRG FI     % SET ERROR MESSAGE
071401             FI
071401             "6"                                    % ABORT MESSAGE
071402          FI
071402
071402   % INDICATE MESSAGE READY
071402
071402         A=:CMSGO; T:=BUSFL BONE 6SMSO=:BUSFL  % SEND MESSAGE
071406         3; T:=HDEV+WNCOM; *IOXT               % "Set ATN" TO NCR
071412         EXIT
071413   *)FILL
071413   RBUS
071413   @DEV 1
071413   @EOF
071413
071413   *"8BFD1+8BFD2
"071413
071413   SUBR BFDIS
071413   %=========================================================================
071413   %  43.9      B F D I S
071413   %
071413   % F L O P P Y   D I S K   D R I V E R   F O R   S I N G L E /
071413   % D O U B L E  D E N S I T Y  &  S I D E
071413   %
071413   %
071413   %       CALLING SEQUENCE:
071413   %       JPL I (BFDIS
071413   %       JMP   ERROR           ERROR EXIT
071413   %       JMP   BUSY            BUSY EXIT
071413   %       JMP   FIN             FINISHED
071413   %
071413   %
071413   %       REGISTER CONTENT WHEN CALLING BFDIS:
071413   %
071413   %       X- NUMBER OF SECTORS TO TRANSFER
071413   %       T- BIT 0-5: FUNCTION CODE
071413   %
071413   %              0 - READ
071413   %              1 - WRITE
071413   %              7 - ERASE TAPE                          *
071413   %             10 - ADVANCE TO EOF
071413   %             11 - REVERCE TO EOF
071413   %             12 - WRITE EOF
071413   %             13 - REWIND TO BOT
071413   %             20 - READ STATUS
071413   %             36 - READ EXTENDED STATUS                *
071413   %             41 - FORMAT FLOPPY                       *
071413   %             42 - READ FORMAT                         *
071413   %             43 - READ DELETED RECORD
071413   %             44 - WRITE DELETED RECORD
071413   %             54 - COPY FLOPPY                         *
071413   %             55 - FORMAT TRACK (FLOPPY)
071413   %             56 - CHECK CARTRIDGE (READ AND TEST CRC) *
071413   %             57 - TEST CARTRIDGE CAPASITY (WRITE)     *
071413   %             70 - RETENSION CARTRIDGE                 *
071413   %             71 - PERFORM TEST                        *
071413   %             72 - ILLEGAL COMMAND                     *
071413   %             73 - CLEAR                               *
071413   %             74 - Continious Read                     *
071413   %             75 - Continious Write                    *
071413   %
071413   %       BIT 6-7: UNIT NUMBER  (0,1,2,3)
071413   %
071413   %       BIT 8-9: BYTES/SECTOR:  0 = 512
071413   %                               1 = 256
071413   %                               2 = 128
071413   %                               3 = 1024
071413   %
071413   %       BIT 10: DOUBLE SIDED DRIVE & DISKETTE
071413   %
071413   %       BIT 11: DUAL DENSITY DISKETTE
071413   %
071413   %       POSSIBLE FORMATS (BITS 8-9-10-11):
071413   %
071413   %             0- IBM SYS-32-II  512 BYTES/SECTOR    SINGLE SIDE, SINGLE DENSITY
071413   %             1- IBM 3600       256 BYTES/SECTOR    SINGLE SIDE, SINGLE DENSITY
071413   %             2- IBM 3740       128 BYTES/SECTOR    SINGLE SIDE, SINGLE DENSITY
071413   %             3- ILLEGAL
071413   %             4- NON IBM        512 BYTES/SECTOR    DOUBLE SIDE, SINGLE DENSITY
071413   %             5- NON  IBM       256 BYTES/SECTOR    DOUBLE SIDE, SINGLE DENSITY
071413   %             6- NON  IBM       128 BYTES/SECTOR    DOUBLE SIDE, SINGLE DENSITY
071413   %             7- ILLEGAL
071413   %            10- NON  IBM       512 BYTES/SECTOR    SINGLE SIDE, DOUBLE DENSITY
071413   %            11- IBM SYS-34     256 BYTES/SECTOR    SINGLE SIDE, DOUBLE DENSITY
071413   %            12- ILLEGAL
071413   %            13- NON  IBM      1024 BYTES/SECTOR    SINGLE SIDE, DOUBLE DENSITY
071413   %            14- NON  IBM       512 BYTES/SECTOR    DOUBLE SIDE, DOUBLE DENSITY
071413   %            15- IBM SYS-34     256 BYTES/SECTOR    DOUBLE SIDE, DOUBLE DENSITY
071413   %            16- ILLEGAL
071413   %            17- NON IBM       1024 BYTES/SECTOR    DOUBLE SIDE, DOUBLE DENSITY
071413   %
071413   %
071413   %       BIT 12: STREAMER CASSET
071413   %
071413   %       BIT 14-15: DESTINATION UNIT DURING COPY COMMAND
071413   %
071413   %       D- DISK ADDRESS (LOGIC SECTOR ADDRESS)
071413   %
071413   %       ADDRESS RANGE:
071413   %
071413   %             0-1150  FORMAT  0   232     PAGES
071413   %             0-2203  FORMAT  1   220.375 PAGES
071413   %             0-3722  FORMAT  2   175.125 PAGES
071413   %                     FORMAT  3
071413   %             0-2320  FORMAT  4   464     PAGES
071413   %             0-4406  FORMAT  5   440.75  PAGES
071413   %             0-7644  FORMAT  6   372.25  PAGES
071413   %                     FORMAT  7
071413   %             0-2203  FORMAT 10   440.75  PAGES
071413   %             0-3722  FORMAT 11   372.25  PAGES
071413   %                     FORMAT 12
071413   %             0-1150  FORMAT 13   464     PAGES
071413   %             0-4406  FORMAT 14  1101.5   PAGES
071413   %             0-7644  FORMAT 15   764.5   PAGES
071413   %                     FORMAT 16
071413   %             0-2320  FORMAT 17  1150     PAGES
071413   %
071413   %  EXIT INFORMATION:
071413   %
071413   %       IF NORMAL OPERATIONS
071413   %         T-REG = HARDWARE STATUS
071413   %         X-REG = STATUS 1 (FROM FSTAT+0):
071413   %         D-REG = STATUS 2 (FROM FSTAT+1):
071413   %
071413   %       IF TEST OPERATIONS
071413   %         T-REG = HARDWARE STATUS
071413   %         X-REG = HARDWARE STATUS
071413   %         D-REG = 177777
071413   %
071413   %                 STATUS 1 (FROM FSTAT+0):
071413   %                                 BIT 0 - NOT USED
071413   %                                     1 - INT. ENABLED
071413   %                                     2 - CONTROLLER BUSY
071413   %                                     3 - CONTROLLER READY
071413   %                                     4 - OR OF ERRORS
071413   %                                     5 - DELETED RECORD
071413   %                                     6 - INTERNAL RETRIES (NO ERROR)
071413   %                                     7 - SERIOUS ERROR, NO MEMORY CONTACT
071413   %                                     8 - NOT USED
071413   %
071413   %                              BIT 9-15 - ERROR CODE:
071413   %                                     0 - TRANSFER OK
071413   %                                     5 - CRC ERROR
071413   %                                     6 - SECTOR NOT FOUND
071413   %                                     7 - TRACK NOT FOUND
071413   %                                    10 - FORMAT NOT FOUND
071413   %                                    11 - DISKETTE DEFECT (IMPOSSIBLE TO FORMAT)
071413   %                                    12 - FORMAT MISMATCH
071413   %                                    13 - ILLEGAL FORMAT SPECIFIED
071413   %                                    14 - SINGLE SIDED DISKETTE INSERTED
071413   %                                    15 - DOUBLE SIDED DISKETTE INSERTED
071413   %                                    16 - WRITE PROTECTED DISKETTE/CARTRIGE
071413   %                                    17 - DELETED RECORD
071413   %                                    20 - DRIVE NOT READY
071413   %                                    21 - CONTROLLER BUSY ON START
071413   %                                    22 - LOST DATA (OVER OR UNDERRUN)
071413   %                                    23 - TRACK ZERO NOT DETECTED
071413   %                                    24 - VCO FREQUENCY OUT OF RANGE
071413   %                                    25 - MICROPROGRAM OUT OF RANGE
071413   %                                    26 - TIMEOUT
071413   %                                    27 - UNDEFINED ERROR
071413   %                                    30 - TRACK OUT OF RANGE
071413   %                                    32 - COMPARE ERROR (DURING COMPARE OF DATA)
071413   %                                    33 - INTERNAL DMA ERRORS
071413   %                                    40 - ND-100 BUS ERROR COMMAND FETCH
071413   %                                    41 - ND-100 BUS ERROR STATUS TRANSFER
071413   %                                    42 - ND-100 BUS ERROR DATA TRANSFER
071413   %                                    43 - ILLEGAL COMMAND
071413   %                                    44 - WORDCOUNT NOT ZERO
071413   %                                    45 - ILLEGAL COMPETION (CONT. TRANSF)
071413   %                                    46 - ADR-REG ERROR
071413   %                                    50 - NO BOOTSTRAP FOUND ON DISKETTE
071413   %                                    51 - WRONG BOOTSTRAP (TOO OLD FLO-MON VERSION)
071413   %                                    60 - STREAMER HANDSHAKE ERROR
071413   %                                    61 - STREAMER STATUS TRANSFER ERROR
071413   %                                    62 - BAD CARTRIGE
071413   %                                    63 - NO CARTRIGE INSTALLED
071413   %                                    64 - END OF TAPE, CARTRIGE FULL
071413   %                                    65 - STREAMER DRIVE ERROR
071413   %                                    66 - UNIDENTIFIED EXCEPTION
071413   %                                    67 - ILLEGAL COMMAND TO STREAMER
071413   %                                    70 - PROM CHECKSUM ERROR
071413   %                                    71 - RAM ERROR
071413   %                                    72 - CTC ERROR
071413   %                                    73 - DMACTRL ERROR
071413   %                                    74 - VCO ERROR
071413   %                                    75 - FLOPPY CONTROLLER ERROR
071413   %
071413   %
071413   %                 STATUS 2 (FROM FSTAT+1):
071413   %                       BIT   0-3  - IF READ FORMAT COMMAND OR FORMAT ERROR:
071413   %                                    FORMAT READ FROM DISKETTE, OTHERWISE = 0
071413   %                             4-5  - NOT USED
071413   %                               6  - TRUE IBM FORMAT (128 B/S ON TR. 0 SIDE 0)
071413   %                               7  - NOT USED
071413   %                             8-9  - LAST ACCESSED UNIT
071413   %                            10-15 - NOT USED
071413   %
071413   %                 HARDWARE STATUS (HDEV+2):
071413   %                         BIT 0-6 - EQUAL TO STATUS 1 (FROM FSTAT+0)
071413   %                               7 - SERIOUS ERROR !!!!!!!!!!!!
071413   %                            8-14 - ALWAYS 0
071413   %                              15 - ALWAYS 1 ( = NEW CONTROLLER)
071413   %
071413

071413   %      USE OF BUFFER WHILE RUNNING TESTS
071413   %
071413   %            *********************************************
071413   % BUFFER +00 * TEST NO                                   *
071413   % BUFFER +01 * BITS SET COROSPONDING TO IOX'S TO PERFORM *
071413   % BUFFER +02 * DATA READ FROM        IOX DEVNO +0        *
071413   % BUFFER +03 * DATA TO BE WRITHEN TO IOX DEVNO +1        *
071413   % BUFFER +04 * DATA READ FROM        IOX DEVNO +2        *
071413   % BUFFER +05 * DATA TO BE WRITHEN TO IOX DEVNO +3        *
071413   % BUFFER +06 * DATA READ FROM        IOX DEVNO +4        *
071413   % BUFFER +07 * DATA TO BE WRITHEN TO IOX DEVNO +5        *
071413   % BUFFER +06 * DATA READ FROM        IOX DEVNO +4        *
071413   % BUFFER +10 * DATA READ FROM        IOX DEVNO +6        *
071413   % BUFFER +11 * DATA TO BE WRITHEN TO IOX DEVNO +7        *
071413   %            *********************************************
071413   %            *  USE USER SPESIFYED CCB                   *
071413   %            *********************************************
071413   % BUFFER +12 *  CCBWO,  COMMAND WORD                     *
071413   % BUFFER +13 *  BFDEV,  DEVICE ADDRESS                   *
071413   % BUFFER +14 *  FMEMH,  MEMORY ADDRESS ( HIGH )          *
071413   % BUFFER +15 *  FMEML,  MEMORY ADDRESS ( LOW )           *
071413   % BUFFER +16 *  OPWCH,  OPTIONS AND WORD COUNT ( HIGH )  *
071413   % BUFFER +17 *  WCOUN,  WORD/RECORD COUNT ( LOW )        *
071413   % BUFFER +20 *  FSTA1,  STATUS 1                         *
071413   % BUFFER +21 *  FSTA2,  STATUS 2                         *
071413   % BUFFER +22 *  LASMH,  LAST MEMORY ADDRESS ( HIGH )     *
071413   % BUFFER +23 *  LASML,  LAST MEMORY ADDRESS ( LOW )      *
071413   % BUFFER +24 *  MREMW,  MOUST REMAINING WORDS            *
071413   % BUFFER +25 *  LREMW,  LEAST REMAINING WORDS            *
071413   %            *********************************************
071413   % BUFFER +26 *  FUTHER EXTENTIONS                        *
071413   % BUFFER +27 *  FUTHER EXTENTIONS                        *
071413   %            *********************************************
071413   % BUFFER +30 *  REAL BUFFER START                        *
071413   %            *********************************************
071413

071413
071413   SYMBOL IOXIN=164000
071413   %SYMBOL RDATA=0               % READ DATA
071413   SYMBOL RSTA=2                % READ STATUS
071413   SYMBOL LCON=3                % LOAD CONTROL WORD
071413   SYMBOL LHPOI=5               % LOAD POINTER HIG
071413   SYMBOL LLPOI=7               % LOAD POINTER LOW
071413   SYMBOL LDATA=7               % LOAD DATA
071413
071413   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
071413   %                              %
071413   %  OPERATION DECLARATIONS      %
071413   %  *):NEW                      %
071413   %                              %
071413   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
071413
071413   SYMBOL RSSTA=20              %   READ STATUS
071413   SYMBOL PTEST=71              % * PERFORM TEST
071413   SYMBOL FCLEAR=73             % * CLEAR
071413
071413   SYMBOL FOCCU=2, CONRE=3, INERR=4, SEERR=7                            %
071413                                                               %
071413   INTEGER TEARG                                               %   TEMPRARY SAVED A-REG DORING TEST IOXS
071414   INTEGER TETRG                                               %   TEMPRARY SAVED T-REG DORING TEST IOXS
071415                                                               %
071415   BFDIS: TAD=:TADRG      ; X=:XRG                             %
071417                                                               %
071417          IF A:=77 /\ T-FCLEAR >< 0 THEN                       %
071423                                                               %
071423            A:=HDEV+RSTA   ; * EXR SA                          %   READ STATUS
071426   %         IF A BIT FOCCU GO HBUSY                            %   CONTROLLER BUSY
071426            IF A NBIT CONRE GO HBUSY                           %   CONTROLLER NOT READY
071430            IF A BIT 6 AND T:=TRG NBIT 14 THEN                 % INHIBIT FLOPPY USE WHEN STREAMER IS BUSY
071435               A BONE 4=:XRG=:X
071440               0=:FSTA2
071441               A:=45030; GO FLERR
071443            FI; X:=A                                           %
071444            K:="0"                                             %
071445            IF A:=BUSFL><0        THEN K:=1 FI                 %   PREVIOUS TRANSFER TO BE CHECKED ?
071450                                                               %   OR
071450            IF A:=77 /\ T-RSSTA=0 THEN K:=1 FI                 %   OPER. READ STATUS ON FLOPPY?
071455            IF K THEN                                          %
071457                                                               %   YES, PREVIOUS TRANSFER TO BE CHECKED
071457              X=:XRG                                           %
071460              T:=HDEV ; * EXR ST                               %   READ STATUS 1
071462   FLERR:     D:=A                                             %
071463              IF X BIT INERR THEN                              %   ERRORS
071465                                                               %
071465   %%%          IF A:=TRG NBIT 14  THEN                        %   IF NOT STREAMER
071465   %%%            T+LCON                                       %
071465   %%%            A:=22 ; * EXR ST                             %   CLEAR DEVICE
071465   %%%          FI                                             %
071465                L-1                                            %   ERROR RETUR
071466                                                               %
071466              ELSE                                             %   NO ERRORS, FINISHED
071467                                                               %
071467                IF A:=77 /\ TRG -PTEST=0 THEN                  %   IF PERFORME TEST
071473                                                               %
071473                  X:=HDEV                                      %
071474                  AD:=MEMAD ; D+1 ; A:=A+C ; * EXAM            %
071500                  T BZERO 10                                   %
071501                  DO                                           %
071501                    D+1 ; A:=A+C                               %
071503                    IF T BIT "0" THEN                          %
071505                      T=:TETRG ; A=:TEARG                      %
071507                      * EXR SX                                 %   EXIQUTE THE INPUT IOX
071510                      T:=A ; A:=TEARG                          %
071512                      * DEPO                                   %   STORE THE READ DATA
071513                      T:=TETRG                                 %
071514                    FI                                         %
071514                  WHILE T SHZ -2 ><0                           %
071517                    X+2 ; D+1 ; A:=A+C                         %
071522                  OD                                           %
071523                                                               %
071523                FI                                             %
071523                                                               %
071523   RETFI:       L+1                                            %   FINISED RETUR
071524                                                               %
071524              FI                                               %
071524              A:=B+2000=:X; A:=X.FSTA2                         %   CLEAR ONE WORD IN CACHE
071530              T:=FSTA2                                         %   STATUS 2 (ERROR CODE & FORMAT NO.)
071531              X:=XRG:=:D                                       %   HWSTAT IN D, FSTA1 IN X
071533              IF A:=77 /\ TRG -PTEST=0  AND D NBIT INERR THEN  %   IF PREFORME TEST WENT OK
071541                X:=D                                           %   HWSTAT TO X
071542                T:=-1                                          %
071543              FI                                               %
071543              T:=:D                                            %   HWSTAT TO T, FSTA2/-1 TO D
071544              A:=ARG                                           %
071545              0=:BUSFL                                         %
071546              GO FAR RETUR                                     %
071547                                                               %
071547   HBUSY:     GO FAR BUSYR                                     %   BUSY RETURN
071550              *)FILL                                           %
071554            FI                                                 %
071554          FI                                                   %
071554
                                                           %
071554                                                               %   START NEW OPERATION
071554          * BLDA 140 DT                                        %   SET K IF STREAMER
071555                                                               %   START CREATING THE CONTROLLWORD IN D
071555          IF A:=77 /\ T -PTEST=0 THEN                          %
071561                                                               %
071561            AD:=MEMAD ; * EXAM                                 %
071563            T SHZ 11                                           %   SHIFT TEST NO. IN PLACE
071564            T BONE 10 BONE 3                                   %
071566            T BONE 1 ; * BSTA 60 DT                            %   TAKE STERAMING FROM K
071570            T=:SFCOM                                           %
071571            X:=HDEV+1                                          %
071573            D+1 ; A:=A+C ; * EXAM ; BLDA 100 DT                %   GET IOX BITS, SAVE USE USER SPESIFYED CCB IN K
071577            T BZERO 10                                         %
071600            DO                                                 %
071600              D+1 ; A:=A+C                                     %
071602              D+1 ; A:=A+C                                     %
071604              IF T  BIT 1 THEN                                 %
071606                T=:TETRG                                       %
071607                * EXAM ; SWAP SA DT                            %
071611                * EXR SX                                       %   EXEQUTE THE WANTED OUTPUT IOX
071612                T=:A:=TETRG                                    %
071614              FI                                               %
071614            WHILE T SHZ -2><0                                  %
071617              X+2                                              %
071620            OD                                                 %
071621            IF K THEN                                          %
071623              T:=HDEV+LLPOI                                    %
071625              AD:=MEMAD  ; A:=:D+12        ; * EXR ST          %   LOAD CCB POINTER LOW
071631              A:=:D:=A+C ; T+"LHPOI-LLPOI" ; * EXR ST          %   LOAD CCB POINTER HIG
071635              A:=:D+16:=:D:=A+C                                %
071641            FI                                                 %
071641                                                               %
071641          ELSE                                                 %
071642                                                               %
071642            IF A:=77 /\ T -FCLEAR=0 THEN                       %
071646              A:=22 ; * BSTA 50 DA                             %   CLEAR + STREAMER IF STREAMER IN USE
071650              A=:SFCOM                                         %   SAVE COMMAND
071651            ELSE                                               %
071652                                                               %
071652              T BZERO 14 =:CCBWO                               %
071654              IF A:=T/\77=55 THEN A:=XRG=:D; FI                %   FORMAT TRACK, WORD COUNT TO BLOCK ADDRESS
071663              0=:OPWCH                                         %
071664              X:=XRG=:WCOUN                                    %   NO. OF SECTORS TO TRANSFER
071666              A:=D=:BFDEV                                      %
071670              IF X=0 GO NOWORDS                                %
071671              A:=DPITBANK    ; T:=HDEV+"LHPOI" ; * EXR ST      %   LOAD COMMAND POINTER, UPPER ADDR
071675              A:="CCBWO"+B+DPITPHYS; T+"LLPOI-LHPOI"; *EXR ST  %   LOWER
071702              D:=0 BONE 10 BONE 1 ; * BSTA 50 DD               %   SET ACTIVATE AND ENABELE INTERUPT BITS, BIT  6 IF STREAMER
071706                                                               %
071706              IF  D NBIT 5 THEN                                %   IF NOT STREAMER
071710                                                               %
071710                A:=CCBWO SHZ 10 SHZ -16 =:X                    %   UNIT NO. TO X
071714                                                               %
071714                IF A:=STEPR(X)><0 THEN D BONE 11 FI            %   SET BIT  9 IF STEP RATE
071717                IF A:=DOORL(X)><0 THEN D BONE 12 FI            %   SET BIT 10 IF DOOR LOCK
071722                IF A:=PRECP(X)><0 THEN D BONE 13 FI            %   SET BIT 11 IF DISABLE PRECOMP
071725                IF A:=DTRCK(X)><0 THEN D BONE 14 FI            %   SET BIT 12 IF DUAL TRACK DENSITY (FUTURE!!)
071730                IF A:=COMFL   ><0 THEN D BONE 15 FI            %   SET BIT 13 IF HARDWARE COMPARE
071733                                                               %
071733              FI                                               %
071733              A:=D=:SFCOM                                      %   SAVE COMMAND
071735              AD:=MEMAD                                        %
071736            FI                                                 %
071736                                                               %
071736          FI                                                   %
071736                                                               %
071736          AD=:FMEMD                                            %   MEMORY ADDRESS
071737          T:=HDEV+LCON                                         %
071741          A:=SFCOM ; * EXR ST                                  %   ACTIVATE
071743          A=:T                                                 %
071744          IF A:=77/\TRG-FCLEAR=0 THEN                          %
071750   NOWORDS: T:=0; L+1                                          %   FINISHED!!!
071752            A:=HDEV+RSTA   ; * EXR SA                          %   READ STATUS
071755            A=:XRG                                             %
071756          FI                                                   %
071756          A:=T                                                 %
071757   BUSYR: A=:BUSFL                                             %   BUSY
071760          X:=XRG                                               %
071761          TAD:=TADRG                                           %
071762   RETUR: EXITA                                                %
071763                                                               %
071763   RBUS                                                        %
071765
071765   *"
"071765
071765   @DEV 1
071765   @EOF
071765
071765

071765   *)9SLPL
071765   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
071765   %                                                                              %
071765   % 50.0 STC MAGTAPE DRIVER    80-07-03   PHE      VERSION  AA                   %
071765   %          LAST MODIFIED     82-02-03   TLS      REV.     01                   %
071765   %          LAST MODIFIED     82-14-06   TP       BIT 6 TO BIT 3 IN STAKO       %
071765   %          LAST MODIFIED     83-05-31   HKD      READ BACKWARDS (CORE.ADDR)    %
071765   %          LAST MODIFIED     83-10-11   TP       ERROR IN STARE CORRECTED      %
071765   %                                                                              %
071765   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
071765   *"99SM1+99SM2+99SM3+99SM4
"071765   %                                                                              %
071765   %      CALLING SEQUENCE:                                                       %
071765   %            JPL I (SMAGT                                                      %
071765   %            JMP ERROR       % ERROR EXIT                                      %
071765   %            JMP BUSY        % BUSY EXIT                                       %
071765   %            JMP FINIS       % FINISH EXIT                                     %
071765   %                                                                              %
071765   %      CALLED WITH:                                                            %
071765   %            X-REG:          BUSY INDICATOR WHEN CALLING THE DRIVER            %
071765   %                            OR RECORD SIZE FOR READ/WRITE TYPE COMMANDS       %
071765   %            T-REG:          BITS 0-5: FUNCTION CODE:                          %
071765   %                                      0= READ ONE RECORD                      %
071765   %                                      1= WRITE ONE RECORD                     %
071765   %                                      2= READ ONE RECORD WITH ODD NUMBER OF   %
071765   %                                         BYTES.ITISTHE SAME AS CODE 0 BUT     %
071765   %                                         IT DOES NOT USE ERROR EXIT IF THE    %
071765   %                                         RECORD HAS ODD NUMBER OF BYTES       %
071765   %                                      3= LOOP WRITE TO READ IN FCU            %
071765   %                                      4= READ ONE RECORD BACKWARDS            %
071765   %                                      10=ADVANCE TO EOF (FORWARD SPACE A      %
071765   %                                         TAPEMARK)                            %
071765   %                                      11=REVERSE TO EOF (BACKSPACE A          %
071765   %                                         TAPEMARK)                            %
071765   %                                      12=WRITE EOF (WRITE A TAPEMARK)         %
071765   %                                      13=REWIND TO BOT                        %
071765   %                                      14=ERASE GAP (SAME AS WRITE SKIP)       %
071765   %                                      15=BACKSPACE NO. OF RECORDS             %
071765   %                                      16=FORWARD SPACE NO. OF RECORDS         %
071765   %                                      17=REWIND AND UNLOAD                    %
071765   %                                      20=READ STATUS (COMPATIBLE WITH PERTEC  %
071765   %                                         MAGTAPES)                            %
071765   %                                      21=CLEAR TAPE SUBSYSTEM                 %
071765   %                                      22=CLEAR TAPE SUBSYSTEM WITH ERROR      %
071765   %                                         EXIT                                 %
071765   %                                      24=READ LAST STATUS                     %
071765   %                                      25=READ TAPE STATUS                     %
071765   %                                      26=READ BYTE-RECORD                     %
071765   %                                      27=WRITE BYTE-RECORD                    %
071765   %                                      33=CLEAR SELECTED UNIT                  %
071765   %                                      34=SET DIAGNOSTIC MODE                  %
071765   %                                      35=NO OPERATION                         %
071765   %                                      37=SENSE DRIVE STATUS                   %
071765   %                            BITS 6-8: UNIT NUMBER                             %
071765   %                            BITS 9-15 SHOULD BE 0                             %
071765   %            D-REG:          BITS 0-1: DENSITY                                 %
071765   %                                      0=1600 BPI (PE-MODULATION)              %
071765   %                                      1=6250 BPI (GCR-MODULATION)             %
071765   %                                      2= 800 BPI (NRZI.NOT AVAILABLE          %
071765   %                                         ON THE STC 1951 DRIVE)               %
071765   %                            BITS 2-15 SHOULD BE 0                             %
071765   %                                                                              %
071765   %            THE 24-BIT MEMORY ADDRESS IS FOUND IN THE DATAFIELD               %
071765   %            WORDS MEMA1 AND MEMA2 (BITS 0-15 IN MEMA2)                        %
071765   %                                                                              %
071765   %            THE 24-BIT WORD-COUNTER IS FOUND IN THE DATAFIELD                 %
071765   %            WORDS DWONO AND CXRG (BITS 0-15 IN CXRG)                          %
071765   %                                                                              %
071765   %      RETURN INFORMATION:                                                     %
071765   %            ERROR EXIT:     X=HARDWARE STATUS (COMPATIBLE WITH OTHER          %
071765   %                              MAGTAPES)                                       %
071765   %            BUSY EXIT:      THE ROUTINE MUST BE CALLED AGAIN AT ONCE OR       %
071765   %                            AFTER INTERRUPT WITH PARAMETERS UNCHANGED         %
071765   %                            IF FUNCTION WAE STARTED,X=0                       %
071765   %                            IF FUNCTION WAS NOT STARTED,X=CONTENT WHEN DRIVER %
071765   %                            WAS ENTERED.(X><0)                                %
071765   %            FINISHED EXIT:  X=HARDWARE STATUS (COMPATIBLE WITH OTHER          %
071765   %                              MAGTAPES)                                       %
071765   %                            A=CORE ADDRESS LOWER 16 BITS                      %
071765   %                            FULL CORE ADDRESS IS FOUND IN DATAFIELD WORDS     %
071765   %                            CMAD1 AND CMAD2 (BITS 0-15 IN CMAD2)              %
071765   %                                                                              %
071765   %            FCU INTERFACE STATUS IS FOUND IN DATAFIELD ARRAY FCST             %
071765   %                                                                              %
071765   %      B IS NOT CHANGED                                                        %
071765   %                                                                              %
071765   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
071765   *"99SM1+99SM2+99SM3+99SM4 CXCPU
"071765   *BZRS0=BSET ZRO 00
071765   *BONS0=BSET ONE 00
071765   *"99SM1+99SM2+99SM3+99SM4 -CXCPU
"071765   %      GLOBAL PARAMETER FIELD FOR STC MAGTAPE DRIVER
071765   %INTEGER DEVTL                % IOX INSTRUCTION
071765   %INTEGER STXSTAT                % STATUS WORD RETURNED IN X-REG
071765   %INTEGER DENSI                % DENSITY CODE
071765   %INTEGER FUNCO                % HARDWARE FUNCTION CODE
071765   %INTEGER WONO                 % WORD NUMBER IN DMA
071765   %INTEGER UNINO                % UNIT NO TO BE USED AS ADDRESSING INDEX
071765   %INTEGER COCOD                % COMMAND TYPE CODE. BIT 3 INDICATES FORWARD MOVEM.
071765   %                            % 0=RESET
071765   %                            % 1=DMA READ
071765   %                            % 2=DMA WRITE
071765   %                            % 3=SPACE TYPE COMMAND
071765   %                            % 4=CONTROLLING TYPE COMMANDS
071765
071765   %============================================================================
071765   % 50.1       S M A G T   E R R E T   B U R E T   F I N E T   E R R E X
071765   %
071765   SUBR SMAGT,STCEE,BURET,FINET,STCERREX
071765
071765   SYMBOL SENS1=4,COMW,SENS2,LWCNT
071765
071765   INTEGER POINTER LSAV
071766
071766   EXIT2: MIN "LSAV"
071767   EXIT1: MIN "LSAV"
071770   EXIT0: GO LSAV
071771
071771   SMAGT: A=:ARG:=L=:"LSAV":=D=:DRG       % SAVE REGISTERS
071776          T=:TRG; A:=T/\77=:FUNCO; X=:XRG
072003
072003          A:=TRG/\300 SHZ 6=:NEWUN       % INITIALIZE PARAMETERS
072007          A:=TRG/\300 SHZ -6=:UNINO
072013          A:=DRG/\3 SHZ 16=:DENSI
072017          A:=HDEV+164000=:DEVTL
072022
072022          IF FUNCO=22 THEN 0=:DIAMO; GO STCEE FI  % CLEAR TAPE SUBSYSTEM WITH ERROR EXIT
072030
072030          IF NEWUN><SELUN THEN            % SELECT ANOTHER UNIT
072034            NEWUN=:SELUN+DENSI
072037            T:=DEVTL+COMW; *EXR ST
072042          FI
072042          X:=UNINO                        % GET UNIT NUMBER
072043          IF XRG=0 THEN                  % IF BUSY OR REWINDING ENTRY
072045               COMCO(X)=:COCOD
072047               CALL STACH                 % CHECK FOR ACCEPTABLE STATUS
072050               GO STCERREX
072051               GO XBURET                  % RETRY-COUNTING!!!
072052               GO FAR FINET
072053               *)FILL                     % FOR MAC.
072063          FI
072063          IF FUNCO=21 THEN                        % CLEAR
072067            -1=:SELUN; 0=:DIAMO; 4=:COCOD
072074            A:=60; T:=DEVTL+DCONT; *EXR ST
072100            0=:XRG; A:=3; *EXR ST
072103            GO BURET                      % BUSY EXIT
072104          FI
072104          0=:COCOD
072105          CALL STARE                      % READ STATUS OF NEW DRIVE
072106          IF FCST(1) BIT 2 THEN           % SET BOT BIT IN DENSITY CODE
072112            ADNSTY(UNINO) BONE 17=:ADNSTY(X)
072116          ELSE
072117            ADNSTY(UNINO) BZERO 17=:ADNSTY(X)
072123          FI
072123          FCST(1)/\12020-12000
072127          IF A=0 THEN                     % DRIVE READY FOR ANY OPERATION?
072130            X:=XNOWUNIT
072131            0=:X.NRDYF; CALL COMEX
072133          FI
072133          IF FUNCO>17 AND ><26 AND ><27 THEN % FUNCTIONS TO BE EXECUTED
072145                                          % INDEPENDENT OF REWINDING OR ON-
072145                                          % LINE STATUS.
072145            CALL COMEX
072146          FI
072146   XBURET:
072146          FCST(1)/\2000-2000              % TEST FOR DRIVE REWIDING.IF SO,WAIT FOR
072152          IF A=0 THEN                     % 5 MINUTES AND GIVE ERROR MESSAGE.IF NOT
072153            X:=XNOWUNIT
072154            IF X.NRDYF=0 THEN            % REWINDING GIVE ERROR EXIT AT ONCE.
072156              RTRES=:X.NRDYF; -226=:X.NRDTR % FIRST TIME REWINDING
072162              GO FAR BURET
072163            ELSE
072164              IF X.NRDTR><0 THEN
072166                A+1=:X.NRDTR; GO FAR BURET % FOLLOWING TIMES REWINDING
072171              ELSE
072172                21=:STXSTAT; GO STCEE      % DEVICE ERROR; ERROR RETURN
072175              FI
072175            FI
072175          FI
072175          GO STCEE                 % ERROR RETURN
072176   *)FILL
072206
072206   INTEGER SAVL,CPAR1,CPAR2,CPAR3
072212   STCEE: A:=20; T:=DEVTL+DCONT; *EXR ST  % ERROR EXIT.CLEAR INTERFACE AND
072216          A:=4000+DENSI+SELUN; T+2; *EXR ST % DRIVE.
072223          A:=4; T-2; *EXR ST
072226   STCERREX: A:=L=:SAVL
072230          CPAR1+1=:CPAR1
072233          DRG=:D:=CMAD2
072236          T:=TRG; X:=STXSTAT
072240          GO FAR EXIT0
072241
072241   BURET: X:=UNINO                        % STORE COMMAND CODE
072242          COCOD=:COMCO(X)
072244          X:=XRG                         % BUSY EXIT
072245          CPAR2+1=:CPAR2
072250          DRG=:D:=ARG
072253          T:=TRG
072254          GO FAR EXIT1                    % EXIT AD1
072255
072255   FINET: DRG=:D                          % FINISHED EXIT
072257          CPAR3+1=:CPAR3
072262          A:=CMAD2                        % GET CORE ADDRESS REG.
072263          T:=TRG; X:=STXSTAT
072265          GO FAR EXIT2                    % EXIT AD2
072266   RBUS
072272
072272   %------------------------------------------------------------------
072272   %      SUBR COMEX
072272   %      EXECUTES COMMAND AS THIS:
072272   %      CHECKS THE FUNCTION CODE FOR VALIDITY
072272   %      SETS PROPER TYPE CODE IN COCOD
072272   %      MAPS FUNCTION CODE INTO TAPE SYSTEM FORMAT
072272   %      ASSEMBLES COMMAND AND CONTROL WORDS
072272   %      INITIATES FUNCTION
072272   %      RETURNS TO SMAGT ON THE PROPER ENTRY POINT
072272
072272   %============================================================================
072272   % 50.3       F U N I L
072272   %
072272   SUBR FUNIL
072272
072272   FUNIL: 60=:STXSTAT; GO STCEE
072275   RBUS
072276
072276   %============================================================================
072276   % 50.4       C O M E A
072276   %
072276   SUBR COMEA
072276
072276   SYMBOL ILL=-1
072276   SYMBOL RDF=1011
072276   SYMBOL WRT=3012
072276   SYMBOL LWR=7002
072276   SYMBOL RDB=5001
072276
072276   INTEGER ARRAY DAMAP:=(RDF,WRT,RDF,LWR,RDB,ILL,ILL,ILL)
072306
072306   COMEA: X:=FUNCO; *BZRS0
072310          A:=DAMAP(X)+1; *BONS0
072313          IF A=0 THEN GO FAR FUNIL FI     % CHECK FOR ILLEGAL FUNCTION CODE
072315          *BZRS0
072316          A:=DAMAP(X)/\17; *BONS0
072321          A=:COCOD
072322          IF X=1 THEN
072325            IF FCST(1) BIT 3 THEN
072331              21=:STXSTAT; GO STCEE       % WRITE PROTECT VIOLATION
072334            FI
072334          FI
072334
072334          IF DIAMO=0 THEN
072336             A:=20; T:=DEVTL+DCONT; *EXR ST  % CLEAR INTERFACE
072342          FI; DWONO; T:=DEVTL+7; *EXR ST     % SET WORD COUNTER BITS 16-23
072346          A:=CXRG; *EXR ST                   % SET WORD COUNTER BITS 0-15
072350          A:=MEMA1; T-6; *EXR ST             % WRITE MEMORY ADDRESS REGISTER
072353          A:=MEMA2; *EXR ST
072355          X:=FUNCO; *BZRS0
072357          A:=DAMAP(X)/\7400; *BONS0
072362          A+DENSI+SELUN
072364          IF X:=DIAMO><0 THEN A+DIACO FI  % IN DIAGNOSTIC MODE
072367          T+4; *EXR ST                    % SET COMMAND REGISTER
072371          A:=7; T-2; *EXR ST              % ACTIVATE AND ENABLE INTERRUPTS
072374          0=:XRG; GO BURET                % BUSY EXIT
072376   RBUS
072404
072404   %============================================================================
072404   % 50.5       C O M E B
072404   %
072404   SUBR COMEB
072404   SYMBOL FSF=2413
072404   SYMBOL BSF=403
072404   SYMBOL WTM=1414
072404   SYMBOL REW=3404
072404   SYMBOL ERG=5414
072404   SYMBOL BSB=4403
072404   SYMBOL FSB=6413
072404   SYMBOL RUN=7404
072404   INTEGER ARRAY SPMAP:=(FSF,BSF,WTM,REW,ERG,BSB,FSB,RUN)
072414
072414   COMEB: X:=FUNCO
072415          IF X=12 OR X=14 THEN
072423            IF FCST(1) BIT 3 THEN
072427              21=:STXSTAT; GO STCEE
072432            FI
072432          FI
072432          A:=FUNCO/\7=:X
072435          *BZRS0
072436          A:=SPMAP(X)/\17; *BONS0
072441          A=:COCOD
072442          IF DIAMO=0 THEN
072444             A:=20; T:=DEVTL+DCONT; *EXR ST  % CLEAR INTERFACE
072450          FI; *BZRS0
072451          A:=SPMAP(X)/\7400; *BONS0
072454          A+DENSI+SELUN   % SET COMMAND REGISTER
072456          IF X:=DIAMO><0 THEN A+DIACO FI  % IN DIAGNOSTIC MODE
072461          T:=DEVTL+5; *EXR ST
072464          A:=7; T-2; *EXR ST              % ACTIVATE AND ENABLE INTERRUPTS
072467          0=:XRG; GO BURET           % BUSY EXIT
072471   RBUS
072477
072477   %============================================================================
072477   % 50.6       C O M E C
072477   %
072477   SUBR COMEC
072477   COMEC: X:=FUNCO
072500          IF X=26 OR X=27 THEN
072506            CXRG+1 SHZ-1=:CXRG            % CHANGE BYTE COUNTER TO WORD
072512            IF X=26 THEN 2=:FUNCO         % CHANGE FUNCTION CODE
072517            ELSE 1=:FUNCO FI
072522            GO FAR COMEA                  % GOTO READ/WRITE ROUTINE
072523          FI
072523
072523          4=:COCOD
072525          IF X=20 THEN                    % READ STATUS
072530            CALL STACH
072531            0/\0; 0/\0
072533            GO FAR FINET                  % FINISHED EXIT
072534          FI
072534          GO FAR FUNIL                    % REST ARE ILLEGAL
072535   RBUS
072541
072541   %============================================================================
072541   % 50.7       C O M E D
072541   %
072541   SUBR COMED
072541   SYMBOL ILL=-1
072541   SYMBOL CLR=4004
072541   SYMBOL DMS=2004
072541   SYMBOL NOP=4
072541   SYMBOL SNS=6004
072541   SYMBOL COMW=5
072541   INTEGER ARRAY REMAP:=(ILL,ILL,ILL,ILL,DMS,NOP,ILL,SNS)
072551
072551   COMED: X:=FUNCO
072552          4=:COCOD
072554          IF X=33 THEN                    % CLEAR SELECTED DRIVE
072557            0=:DIAMO
072560            A:=CLR+SELUN+DENSI; T:=DEVTL+COMW; *EXR ST
072566            A:=7; T-2; *EXR ST
072571            0=:XRG; GO BURET
072573          FI
072573          IF X=34 THEN
072576             1=:DIAMO; CXRG=:DIACO        % SET DIAGNOSTIC MODE
072602             RTRES=:DIAOWNER              % RT-PROGR USING THIS CONTROLLER IN DIAGNOSTIC MODE
072604          FI; X-30; *BZRS0
072606          A:=REMAP(X); *BONS0
072610          IF A+1=0 THEN GO FAR FUNIL FI   % ILLEGAL FUNCTION CODE
072613          *BZRS0
072614          A:=REMAP(X)/\7400; *BONS0
072617          A+SELUN+DENSI
072621          T:=DEVTL+COMW; *EXR ST          % SET COMMAND REGISTER
072624          A:=7; T-2; *EXR ST              % ACTIVATE AND ENABLE INTERRUPTS
072627          0=:XRG; GO BURET                % BUSY EXIT
072631   RBUS
072636
072636   %============================================================================
072636   % 50.8       C O M E X
072636   %
072636   SUBR COMEX
072636
072636   COMEX: A:=FUNCO/\70 SHZ -3             % GO TO ROUTINE FOR PROPER COMMAND TYPE
072641          GOSW FAR COMEA,COMEB,COMEC,COMED,FUNIL,FUNIL,FUNIL,FUNIL
072652   RBUS
072660
072660   %============================================================================
072660   % 50.9       S T A R E
072660   %
072660   SUBR STARE
072660   %      READS STATUS OF INTERFACE INTO FIRST 4 LOCATIONS OF ARRAY FCST(15)
072660   %      IN THE DATA FIELD POINTED TO BY B-REG
072660
072660   INTEGER SAVL
072661
072661   SYMBOL COMW=5
072661
072661   STARE: A:=L=:SAVL
072663          T:=DEVTL; *EXR ST               % GET ENDING CORE ADDRESS
072665          A=:CMAD2
072666          *EXR ST
072667          A=:CMAD1
072670          T+DST; *EXR ST                % READ STATUS
072672          A=:FCST(0)
072674          T+2; *EXR ST                    % READ SENSE 1
072676          A=:FCST(1)
072700          T+1; A:=FCST(0)/\177400; *EXR ST
072705          T+1; *EXR ST                    % READ SENSE 2
072707          A/\1777=:FCST(2)
072712          A:=FCST(0)/\177400+1; T-1; *EXR ST
072720          T+1; *EXR ST                    % READ SENSE 3
072722          A/\1777=:FCST(3)
072725          A:=FCST(0)/\177400=:D+3; T-1; *EXR ST; AAT 1; EXR ST
072736          A/\1777=:FCST(4)
072741          FOR X:=5 TO 14 DO               % READ MUX BUS (8 BYTES)
072745             A:=D+X+3; T:=DEVTL+COMW; *EXR ST
072753             T+1; *EXR ST
072755             A/\1777=:FCST(X)
072757          OD
072761          A:=SAVL=:P
072763   RBUS
072765
072765   %============================================================================
072765   % 50.10      S T A K O
072765   %
072765   SUBR STAKO
072765   %      ASSEMBLES THE STATUS WANTED RETURNED IN THE X-REGISTER
072765   %      STATUS,SENSE 1 AND SENSE 2 ARE USED
072765   %      X-STATUS IS RETURNED IN STXSTAT AND T-REGISTER
072765
072765   INTEGER SAVL
072766
072766   STAKO: A:=L=:SAVL
072770          A:=FCST(0)/\20=:T               % ERROR
072774          A:=FCST(0)
072776          IF A BIT 6 THEN T BONE 10 FI    % ODD BYTES READ
073001          IF A NBIT 4 AND A NBIT 3 THEN   % NOT ERROR AND NOT READY FOR TRANSFER
073005             T BONE 13 FI                 % CONTROLLER BUSY
073006          A:=FCST(1)
073010          IF A BIT 4 THEN T BONE 15 FI    % SET REWINDING STATUS
073013          IF A BIT 1 THEN T BONE 11 FI    % END OF TAPE STATUS
073016          IF A NBIT 3 THEN T BONE 1 FI    % WRITE ENABLE RING PRESENT
073021          IF A BIT 14 AND A BIT 12 THEN T BONE "0" FI  % DRIVE READY STATUS
073026          A/\204; T\/A                    % EOF/BOT STATUS SET
073030          A:=FCST(2)
073032          IF A BIT 3 THEN T BONE 6 FI     % DATA ERROR
073035          IF A BIT "0" OR A BIT 1 THEN    % FATAL ERROR; I.E.
073041             T BONE 3                      % OPERATION INCOMPLETE/REJECTED (CHANGED BY TP 14/6-82)
073042          FI
073042          IF X:=DIAMO><0 THEN A/\204 ELSE A/\344  FI % GIVES DATA ERROR
073047          IF A><0 THEN T BONE 12 FI       % TRANSFER ERROR(OR OF 4 BITS)
073051          A:=SAVL=:P
073053   RBUS
073056
073056   %============================================================================
073056   % 50.11      S T A C H
073056   %
073056   SUBR STACH
073056   %      CHECKS STATUS OF TAPE SUBSYSTEM WHEN BUSY ENTRY.
073056   %      IF STILL NOT READY FOR TRANSFER IT EXITS BUSY AGAIN
073056   %      OTHERWISE IT EXITS EITHER FINISHED OR ERROR
073056
073056   INTEGER POINTER SAVL
073057   OUT2:  MIN "SAVL"
073060   OUT1:  MIN "SAVL"
073061   OUT:   GO SAVL
073062
073062   INTEGER CORP1=?,CORP2=?
073062   STACH: A:=L=:"SAVL"
073064          CALL STARE
073065          CALL STAKO; T=:STXSTAT
073067
073067   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% RETURN ACTUAL DENSITY WHEN STARTING FROM BOT.
073067
073067          IF COCOD BIT 3 AND ADNSTY(UNINO) BIT 17 THEN
073076            IF FCST(1) BIT 13 THEN 1=:ADNSTY(UNINO); GO STACI FI
073106            IF FCST(1) BIT 11 THEN 2=:ADNSTY(UNINO); GO STACI FI
073116            0=:ADNSTY(UNINO)
073120          FI
073120   STACI: IF FCST(1) BIT 17 GO OUT1     % STILL BUSY EXIT
073124          IF T BIT 7 AND COCOD/\7=1 THEN  % CHECK FOR EOF WHEN READING
073133            STXSTAT BONE 4=:STXSTAT
073136          FI
073136          IF T BIT 11 AND COCOD BIT 3 THEN % EOT REACHED WHEN A FORWARD
073143            STXSTAT BONE 4=:STXSTAT           % MOVING COMMAND IS TRIED.
073146          FI
073146          IF FUNCO=0 OR A=4 THEN
073153            IF STXSTAT BIT 10 THEN
073156              STXSTAT BONE 4=:STXSTAT         % ODD NUMBER OF BYTES IN RECORD WITH
073161            FI
073161          FI
073161
073161          GO CONT1
073162
073162   *)FILL
073165
073165   %%% READ AND CHECK ENDING MEMORY ADRESS
073165
073165   INTEGER CORP1,CORP2
073167
073167   CONT1: IF DIAMO><0 GO FAR OUT2
073172          IF CTRG/\77=4 GO CONT2            % READ BACKWARDS
073177          IF COCOD/\7=2 OR =1 THEN          % IF DMA,CHECK ENDING MEM.ADRESS.
073207            MEMA2+CXRG=:CORP2               % CALCULATE EXPECTED ENDING MEMORY
073212            MEMA1; *RADD ADC DA             % ADDRESS.
073214            A+DWONO=:CORP1
073216            IF COCOD/\7 =1 THEN             % IF READ-TYPE COMMAND AND
073223              IF STXSTAT NBIT 7 THEN          % IF NOT EOF STATUS
073226                IF CMAD1>>CORP1 THEN        % CHECK IF ENDING MEMORY ADR. TOO
073232                  STXSTAT\/4020=:STXSTAT        % LARGE
073235                ELSE
073236                  IF CMAD2>>CORP2 AND CMAD1=CORP1 THEN
073246                    STXSTAT\/4020=:STXSTAT
073251                  FI
073251                FI
073251              FI
073251            ELSE
073252              IF STXSTAT NBIT 6 THEN                    % IF OUTPUT AND NOT BAD TAPE
073255                IF CORP2><CMAD2 OR CORP1><CMAD1 THEN  % CHECK FOR MEMORY ADDRESS NOT
073265                  STXSTAT\/4020=:STXSTAT                  % EQUAL TO EXPECTED.
073270                FI
073270              FI
073270            FI
073270          FI
073270
073270   CONT2: IF COCOD/\7=1 THEN              % OVERFLOW IN READ TEST
073275            IF FCST(3) NBIT 7 THEN
073301              STXSTAT\/10020/\177377=:STXSTAT
073305            FI
073305          FI
073305          IF FUNCO=13 THEN                % SIMULATE CORRECT LOAD-POINT STATUS
073311            STXSTAT/\20007\/5=:STXSTAT        % AFTER REWIND COMMAND IS ISSUED.
073315          FI
073315          IF FUNCO=17 THEN                % LEGAL TO BE NOT READY AFTER THESE
073321            STXSTAT/\2100
073323            IF A=0 GO FAR OUT2
073325          FI
073325          IF STXSTAT BIT 4 THEN
073330            GO FAR OUT                    % OTHER ERRORS
073331          FI
073331          GO FAR OUT2                     % NO ERRORS,ACCEPTABLE STATUS.HURRA!
073332   RBUS
073344   *)KILL BZRS0 BONS0
073344   *"
"073344   *)9SCLC

073344  %
073344  % @DEV 1
073344  % @EOF
073344  %
073344  )LINE

073344  % SUBR WIDIS,ZWDIS
073344  %
073344  % *"8WDIS+8WDIM+8ZWDI
073344  "8WDIS+8WDIM+8ZWDI
073344  %

073344  % *)9SLPL
073344  )9SLPL
073344   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
073344   %                                                                                 %
073344   %   FILE NAME   : WINCHESTER:NPL                                                  %
073344   %   PROGRAM NO. : HUT-2475 A.6                                                    %
073344   %   ISSUED      : 82.02.18        BY: DG AND TP                                   %
073344   %                                                                                 %
073344   %   LAST CHANGED: 83.10.03        BY: MJH                                         %
073344   %   LAST CHANGED: 85.09.04        BY: KGT USE AD-REG FOR SECTOR ADDRESS           %
073344   %   LAST CHANGED: 86.01.29        BY: KGT CLEAR CACHE AFTER  SPARE TRACK IS READ  %
073344   %                                                                                 %
073344   % T R A N S F E R   R O U T I N E   F O R    8"   W I N C H E S T E R    D I S K  %
073344   %                                                                                 %
073344   % INCLUDING BAD TRACK REALLOCATION, BUT NO ERROR CORRECTION                       %
073344   %                                                                                 %
073344   %                                                                                 %
073344   %                                                                                 %
073344   % CALLING SEQUENCE:                                                               %
073344   %      JPL I (WIDIS          % OR  JPL I (ZWDIS  IF SWAP DRIVER                   %
073344   %      JMP   ERROR           % ERROR    EXIT                                      %
073344   %      JMP   BUSY            % BUSY     EXIT                                      %
073344   %      JMP   FINIS           % FINISHED EXIT                                      %
073344   %                                                                                 %
073344   % CALLING PARAMETERS:                                                             %
073344   %      X-REG = NUMBER OF SECTORS TO TRANSFER                                      %
073344   %      T-REG (BIT 0-5)  = FUNCTION CODE:                                          %
073344   %                          0 - READ                                               %
073344   %                          1 - WRITE                                              %
073344   %                          2 - READ PARITY                                        %
073344   %                          3 - COMPARE                                            %
073344   %                         20 - READ STATUS                                        %
073344   %                         42 - DUMMY
073344   %             BIT  6-7  = UNIT NUMBER                                             %
073344   %             BIT     8 = TRACK TEST                                              %
073344   %             BIT     9 = NOT USED                                                %
073344   %             BIT    10 = LATE DATA STROBE                                        %
073344   %             BIT 11-13 = NOT USED                                                %
073344   %             BIT    14 = EARLY DATA STROBE                                       %
073344   %             BIT    15 = BAD TRACK                                               %
073344   %      AD-REG = SECTOR ADDRESS (LOGICAL)                                          %
073344   %                                                                                 %
073344   %      THE MEMORY ADDRESS (24 BITS) IS FOUND IN THE DATAFIELD DOUBLE WORD CMAD1   %
073344   %                                                                     AND CMAD2   %
073344   %                                                                                 %
073344   %                                                                                 %
073344   % RETURN INFORMATION:                                                             %
073344   %      ERROR    EXIT: X = HARDWARE STATUS                                         %
073344   %      BUSY     EXIT: THE ROUTINE MUST BE CALLED AFTER INTERRUPT                  %
073344   %      FINISHED EXIT: X = HARDWARE STATUS                                         %
073344   %                                                                                 %
073344   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
073344
073344   *"8ZWDI -8WDIS
"073344
073344   WIDIS: *JMP WISTA
073345
073345   *"8WDIS+8WDIM+8ZWDI
"073345
073345   SYMBOL ACTIV=2 , ICERR=4 , ADDMI=10 , ONCYL=16 , TEST=10
073345   SYMBOL STREARLY=16, STRLATE=12         % BIT IN CONTR. WORD TO SET READ STROBE
073345   @LIB 8WDIM
073345   % DATA FIELD VARIABLES USED BY THE DRIVER:
073345   % WNLBA -I   MEMORY ADDRESS USES TO READ REALOCATED TRACK POINTER
073345   % WNLBB -I   CONTAIN NORMALLY ADDRESS TO ALTPO
073345   % ADMIA      SAVED ADDR MISMATCH BLOCK ADDR
073345   % ADMIS      SAVED ADDR MISMATCH STATUS
073345   % ALTPO      ADDRESS OF ALTERNATIVE TRACK POINTER
073345   % BADDR      BAD ADDR
073345   % BADIP      BAD ADDR IN PROCESS (EXTRA ADDRESS BIT)
073345   % BADTR      BAD TRACK FLAG
073345   % BUSFL      BUSY FLAG
073345   % CMAD1      MEM ADDR
073345   % CMAD2       "   "
073345   % ERRC1      RETRY COUNTER
073345   % HDEV       DEVICE NUMBER (0500,0510)
073345   % HTABL(2)   DISK DESCRIPTOR TABLE
073345   % LCYLI(2)   LAST CYLINDER
073345   % NOSEC      NO. OF SECTORS IN TRANSFER
073345   % RTZFL      RETURN-TO-ZERO FLAG
073345   % SEEKF      SEEK FLAG
073345   % SHEAD      HEAD NO.
073345   % SSEC       NO. OF SECTORS IN LAST TRANSFER
073345   % SSTEP      SAVED LAST STEP COUNT
073345   % SVLBB      SAVED DISK ADDR (CYLINDER AND SECTOR)
073345   % SVLCA      SAVED LEAST MEM ADDR
073345   % SVLCO      SAVED CONTROL WORD
073345   % SVLWC      SAVED WORD COUNT
073345   % TRTZ       RETURN-TO-ZERO FLAG
073345   % WANKN      SAVED MOST MEM ADDR
073345   % DEDFA
073345   %
073345   % THIS DISPLACEMENT IS THE LAST BEFORE A 11-WORD FIELD (13B) WHICH IS USED
073345   % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
073345   % DEDFA+1. THE 11-WORD FIELD GOES FROM DEDFA+1 TO DEDFA+13.
073345

073345   INTEGER STAT1=?
073345   INTEGER STAT3=?
073345
073345   *"8WDIS+8WDIM+8ZWDI
"073345
073345   % DRIVER INITIALIZE ------------------------------------------------
073345
073345
073345   % IOX DISPLACEMENTS:
073345
073345   @LIB CXCPU-,
073345   SYMBOL RSEE=2       % READ SEEK CONDITION
073345   SYMBOL LDAD=3       % LOAD DISK   ADDRESS REGISTER
073345   SYMBOL RSTA=4       % READ HARDWARE STATUS
073345   SYMBOL LCON=5       % LOAD CONTROL WORD
073345   SYMBOL RDAD=6       % READ DISK ADDRESS REGISTER
073345   SYMBOL LWOR=7       % LOAD WORDCOUNT
073345   SYMBOL IOXIN=164500 % IOX 500 DISC SYSTEM 1
073345   SYMBOL IOXRR=164004 % IOX READ STATUS (WITHOUT DEV. NO)
073345
073345   %  @LIB 8WDIM-,
073345   % DEFINITION OF EXTENSION TO DISK DATA FIELD
073345
073345   DISP 0
073345     INTEGER WSECW=DED01                % WORDS/SECTOR
073345     INTEGER WSECT=DED02                % SECTORS/TRACK
073345     INTEGER WSECY=DED03                % SECTORS/CYLINDER
073345     TRIPLE DISDE=WSECW
073345     INTEGER WMXCY=DED04                % MAX CYLINDER VALUE
073345     INTEGER IRETR=DED05                % DRIVER RETRY COUNTER
073345     INTEGER SSTAT=DED06                % TEMP. HARDW. STATUS
073345     INTEGER ELCOU=DED07                % DRIVER RETRY COUNTER
073345     INTEGER NOCOU=DED10                % DRIVER RETRY COUNTER
073345   PSID
073345
073345   %  @ELIB
073345
073345   DISP 0 ; TRIPLE CDISD ; INTEGER CMAXC ; PSID   % DISC LAYOUT TABLE
073345
073345   *"8WDIM
"073345

073345   %        WDISC:
073345   %  >>>>>>>>>>>>V
073345   %              V
073345   %              V
073345   %   -----------V----------------- YES
073345   %   * IS IOX STAT1 OR IOX CONT4 >>>>>>>>>>>>>>>>>>>V
073345   %   * WRONG                     *                  V
073345   %   -----------V-----------------          --------V------------
073345   %              V NO                        * GENERATE AL IOX'S *
073345   %              V                           --------V------------
073345   %              V                                   V
073345   %              V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
073345   %              V
073345   %   -----------V---------------------
073345   %   * READ STATUS. SAVE IT IN SSTAT *
073345   %   -----------V---------------------
073345   %              V
073345   %         -----V---- YES
073345   %         * BUSY ? >>>>>>>> WBUSY:
073345   %         -----V----
073345   %              V NO
073345   %         -----V--------- YES
073345   %         * ON CYLINDER ? >>>>>>>> RETZ:
073345   %         -----V---------
073345   %              V NO
073345   %     NO  -----V-------- YES
073345   %    <<<<<< BUSFL><0 ? >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
073345   %    V    --------------                                  V
073345   %    V                                                    V
073345   %  --V-------------------------------------   ------------V------------
073345   %  * SELECT UNIT AND READ STATUS AND SAVE *   * INCLUSIVE OR OF ERROR * YES
073345   %  * RESET SEEKF, BADTR, RTZFL AND TRTZ   *   * IN STATUS ?           >>>>>>>> IERR:
073345   %  --V-------------------------------------   ------------V------------
073345   %    V                                                    V NO
073345   %    V                                             -------V----- YES
073345   %  --V-------------                                * TRTZ><0 ? >>>>>>>> DSEEK:
073345   %  * IS OPERATION *                                -------V-----
073345   %  * READ STATUS  * YES                                   V NO
073345   %  * (20) ?       >>>>>>>>>> DFIN:                 -------V------ YES
073345   %  --V-------------                                * SEEKF><O ? >>>>>>> RWDIS:
073345   %    V NO                                          -------V------
073345   %  --V-------------                                       V NO
073345   %  * IS OPERATION * YES                         ----------V-------------- NO
073345   %  * >=4 ?        >>>>>>> DILLC:                * MAR=OLDMAR+OLDWORDC ? >>>>>>> MEMER:
073345   %  --V-------------                             ----------V--------------
073345   %    V NO                                                 V YES
073345   %    V                                                ----V--------- YES
073345   %    V                                                * BADTR><0 ? >>>>>>>> DBAD:
073345   %    V                                                ----V---------
073345   %    V                                                    V NO
073345   %    V>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<V
073345   %                     V
073345   %                 ----V---- YES
073345   %                 * X=0 ? >>>>>>> DFIN:
073345   %                 ----V----
073345   %                     V NO
073345   %                     V>>>>>>>>>> DSEEK:
073345

073345   WISTA: TAD=:TADRG ; X=:XRG             % SAVE T,A,D,X
073347
073347   *"8WDIS+8WDIM
"073347
073347          T SHZ 10 SHZ -16=:X             % UNIT NO IN X
073352          X:=HTABL(X)                     % POINTER TO DESCRIPTOR FIELD IN X
073353          TAD:=X.CDISD=:DISDE             % PUT WORDS/SECTOR, SECTORS/TRACK AND SECTORS/CYLINDER
073355          X:=X.CMAXC=:WMXCY               % PUT MAX CYL. VALUE
073357          X:=XRG
073360
073360   *"8WDIS+8WDIM+8ZWDI
"073360          A:=HDEV=:T                      % SAVE HDEV IN T-REGISTER
073362          *1BANK
073363          IF A+IOXRR-STAT1><0 THEN  % TEST FIRST IOX, IF NOT INITIALIZED THEN DO SO
073366               A:=T   +IOXRR  ; * STA    STAT1; STA    STAT2;  STA I (STAT3
073373               A+"LDAD-RSTA"  ; * STA I (DAD1 ; STA I (DAD3
073376               A+"RDAD-LDAD"  ; * STA I (DAD2
073400               A+"LOMAR-RDAD" ; * STA I (LMAR1; STA I (LMAR2; STA I (LMAR3; STA I (LMAR4
073405               A+"LCON-LOMAR" ; * STA    CONT1; STA    CONT2; STA I (CONT3; STA    CONT4; STA I (CONT5; STA I (CONT6
073414               A+"LWOR-LCON"  ; * STA I (WORD1; STA I (WORD2; STA I (WORD3; STA I (WORD4
073421               A+"REMAR-LWOR" ; * STA    RMAR1; STA    RMAR2
073424          FI
073424          *2BANK
073425
073425   % DRIVER MAIN ENTRY -----------------------------------------------
073425
073425   INTEGER STAT1:= IOXIN+RSTA                               % READ STATUS
073426           A=:SSTAT
073427           IF A BIT ACTIV  GO FAR WBUSY             % GO IF CONTROLLER BUSY
073431           IF A NBIT ONCYL GO FAR RETZ              % IF NOT ON CYLINDER, ERROR, RECALIBRATE
073433           IF T:=BUSFL><0                           % IF LAST LEAVE WAS A BUSY RETURN
073434              THEN                                  % THEN  OLD TRANSFER IS TO BE CHECKED
073436                IF A BIT ICERR GO     IERR          % GO IF INCLUSIVE OR OF ERRORS SET
073440                IF A:=TRTZ><0  GO FAR DSEEK         % NEW SEEK IF LAST COMMAND WAS RECALIBRATE
073443                IF A:=SEEKF><0 GO FAR RWDIS         % GO TO READ/WRITE ROUTINE IF SEEK FLAG SET
073446   *RMAR1,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. LOWER 16 BITS
073447                T:=A
073450   *RMAR2,      IOXIN REMAR                          % READ MEMORY ADDRESS REG. UPPER 8 BITS
073451                A/\377:=:T-SVLCA
073454                T:=T+C-1
073456                A-SVLWC
073457                T:=T+C-1
073461                A:=:T-WANKN
073463                IF A><0 OR T><0 GO FAR MEMER        % MEMORY ADDRESS ERROR
073466                IF A:=BADTR><0  GO FAR DBAD         % GO TO BAD TRACK ROUTINE
073471              ELSE                                  % ELSE NEW TRANSFER
073472                A:=TRG/\300 SHZ 3 BONE 4
073476   *CONT1,      IOXIN LCON                          % SELECT UNIT, CLEAR DISC UNIT
073477   *CONT2,      IOXIN LCON                          % CLEAR DISC INTERFACE
073500   *STAT2,      IOXIN RSTA                          % READ STATUS
073501                A=:SSTAT
073502                0=:SEEKF=:BADTR
073504                0=:RTZFL=:TRTZ=:NOSEC
073507                IF A:=77/\ TRG-20=0 OR A+"20-42"=0 GO FAR DFIN     % GO IF READ STATUS COMMAND
073516                IF A+"42-3" > 0      GO FAR DILLC   % GO IF ILLEGAL COMMAND
073521          FI
073521          IF X=0 GO FAR DFIN                        % GO IF ALL WORDS TRANSFERRED, FINISHED  !!!!!!!!
073523          0=:BADIP
073524          GO FAR DSEEK                              % EXECUTE SEEK
073525
073525   *)FILL
073557

073557   % ROUTINE TO HANDLE DISK STATUS ERROR -------------------------------
073557   %
073557   %      >>>>>>>>>>>>>>>>V
073557   %                IERR: V
073557   %            ----------V----------
073557   %            * CLEAR DEVICE      *
073557   %            ----------V----------
073557   %                      V
073557   %            ----------V---------- YES
073557   %            * TRG BIT TEST      >>>>>>>> HDERR:
073557   %            ----------V----------
073557   %                      V NO
073557   %            ----------V---------- YES
073557   %            * SEEKF><0 ?        >>>>>>>> RETZ:
073557   %            ----------V----------
073557   %                      V NO
073557   %            ----------V---------- YES
073557   %            * TRTZ><0 ?         >>>>>>>> HDERR:
073557   %            ----------V----------
073557   %                      V NO
073557   %         NO ----------V---------- YES
073557   %       V<<<<< BADTR><0 ?        >>>>>>>>>>>>>>>>>>
073557   %       V    ---------------------                V
073557   %       V                                         V
073557   %  -----V-----------------   ---------------------V--------------------
073557   %  * CALCULATE THE VALUE *   * STEP THE BLOCK ADDRESS TO POINT TO THE *
073557   %  * OF XRG PRIOR TO     *   * NEXT SECTOR ON THE BAD TRACK. DID THAT * YES
073557   %  * LAST TRANSFER       *   * GIVE A TO BIG SECTOR NO. ?             >>>>>>>V
073557   %  -----V-----------------   ---------------------V--------------------      V
073557   %       V                                         V NO                       V
073557   %  -----V--------------                           V           ---------------V----------------
073557   %  * HAS AL RETRYS    * NO                        V           * RESTORE BLOCK ADD AND STATUS *
073557   %  * BEEN DONE (ERRC1)>>>>>>> RWDIS:              V           * OF THE ORIGINAL ERROR        *
073557   %  -----V--------------                           V           ---------------V----------------
073557   %       V YES                                     V                          V
073557   %  -----V------------                             V                          V
073557   %  * RESET RETRIES  *                             V                          V>>>>>> RETZ:
073557   %  * (IRETR=:ERRC1) *                             V
073557   %  -----V------------                             V
073557   %       V                                         V
073557   %  -----V----------------                         V
073557   %  * WAS THE ERROR      * NO                      V
073557   %  * ADDRESS MISMATCH ? >>>>> RETZ:               V
073557   %  -----V----------------                         V
073557   %       V YES                                     V
073557   %  -----V-----------------------------------      V
073557   %  * SSTAT=:ADMIS. READ FAILING BLOCK ADD. *      V
073557   %  * FROM THE INTERFACE. SAVE IT IN ADMIA. *      V
073557   %  * CALCULATE BLOCK ADDRESS FOR THE FIRST.*      V
073557   %  * SECTOR ON THAT TRACK.                 *      V
073557   %  * SET AND BADIP BADTR><0.               *      V
073557   %  -----V-----------------------------------      V
073557   %       V                                         V
073557   %       >>>>>>>>>>>>>>>>>>>V<<<<<<<<<<<<<<<<<<<<<<<
073557   %                          V
073557   %               -----------V----------------------
073557   %               * LOAD BLOCK ADDRESS             *
073557   %               * LOAD MAR WITH ADDRESS OF ALTPO *
073557   %               * PHYS ADDR IN WNLBA AND WNLBB   *
073557   %               * LOAD WORDC WITH 1.             *
073557   %               * SET BIT 15 IN T (SEEK)         >>>>>>> WDACT:
073557   %               ----------------------------------
073557

073557
073557   IERR:   A:=20
073560   *CONT4, IOXIN LCON                            % DEVICE CLEAR
073561           IF A:=TRG BIT TEST GO FAR HDERR       % IF TEST SPECIFIED, NO ERROR HANDLING
073564           IF A:=SEEKF><0       GO RETZ          % IF THE ERROR OCCURED DURING SEEK DO RETURN TO ZERO ZEEK
073566           IF A:=TRTZ ><0       GO FAR HDERR     % IF RETURN TO ZERO SEEK ALREADY HAS BEEN DONE, ERROR RETURN
073571           IF A:=BADTR><0                        % IF BAD TRACK FLAG SET THEN
073572              THEN                               % TRY NEXT SECTOR ON THE TRACK
073573                T:=BADDR+1                       % ERROR IN ALTERNATIVE ADDRESS FETCH INCR. SECT. ADDR. TO FIND A GOOD SECTOR
073575                IF A:=37/\T-WSECT>=0             % TEST LEGAL SEC. COUNT
073600                   THEN                          % THEN ALL SECTORS ON THE TRACK TRIED
073601                     A:=ADMIA=:SVLBB             % REPORT THE ORIGINAL ERROR
073603                     A:=ADMIS=:SSTAT
073605                     GO RETZ
073606                FI
073606                A:=T                             % BLOCK ADDRESS OF NEXT SECTOR IN A
073607              ELSE
073610                A:=XRG+NOSEC=:XRG=:X             % RESTORE X AND XRG
073614                MIN ERRC1 ; GO FAR ELTE          % DO ALL RETRIES FIRST
073616                TRG BZERO STREARLY BZERO STRLATE=:TRG  % CLEAR STROBE BITS
073622                IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESTORE RETRY COUNTER
073626                IF A:=SSTAT NBIT ADDMI GO RETZ   % NOT ADDRESS MISMATCH,  RECALIBRATE  !
073631                A=:ADMIS                         % SAVE ADDRESS MISMATCH STATUS IN CASE OF REAL ADDRESS MISMATCH
073632                A:=100000=:BADTR=:BADIP          % SET BAD TRACK FLAG
073635   *DAD2,       IOXIN RDAD                       % READ LAST DISK ADDRESS
073636                A-1=:ADMIA                       % SAVE FAILING BLOCK ADDRESS REG IN CASE OF REAL ADDRESS MISMATCH
073640                A/\177740                        % BACK TO FIRST SECTOR ON THE TRACK
073641                                                 % IT IS AN ADDRESS MISMATCH, TRY BAD TRACK BIT
073641           FI
073641   *DAD3,  IOXIN LDAD                            % LOAD FAILING ADDRESS
073642           A=:BADDR
073643           A:=WNLBA=:WANKN
073645   *LMAR3, IOXIN LOMAR                            % LOAD UPPER MEM. ADDR.
073646           A:=WNLBB=:SVLCA
073650   *LMAR4, IOXIN LOMAR                            % LOAD LOWER MEM. ADDR.
073651           A:=1=:SVLWC
073653   *WORD4, IOXIN LWOR                            % LOAD WORD COUNT = 1 (READ NEW SECTOR)
073654           T:=100000                             % SET BAD TRACK BIT IN COMMAND
073655           GO FAR WDACT                          % TRY TO READ FAILING SECTOR WITH BAD TRACK BIT SET
073656

073656   % ROUTINE TO DO RETURN TO ZERO SEEK       ------------------------------
073656
073656   RETZ:   IF A:=RTZFL><0 GO FAR HDERR      % RECALIBRATE ALREADY DONE ?
073661           0=:BADTR=:SEEKF=:SHEAD=:BADIP    % RESET BAD TRACK FLAG
073665           A:=TRG SHZ 10 SHZ -16 =:X        % UNIT INTO X
073671           0=:LCYLI(X)                      % CLEAR CYLINDER NO IN BASE FIELD
073672           IF IRETR >=0 THEN -5 FI;A=:ERRC1 % RESET RETRY COUNT
073676           T:=34000                         % RETURN TO ZERO SEEK, RECALIBRATE
073677           T=:RTZFL=:TRTZ                   % SET RECALIBRATE AND FLAG
073701           GO FAR WDACT                     % ACTIVATE
073702

073702   % ROUTINE TO GET ALTERNATIVE DISK ADDRESS ------------------------------
073702
073702   % ENTER HERE WHEN A SECTOR CONTAINING POINTERS TO THE ALTERNATIVE TRACK
073702   % IS READ CORRECT
073702   % PICK UP THE POINTER TO THE ALTERNATIVE TRACK FROM THE FIRST WORD IN THE MEMORY BUFFER
073702   % FIND THE CYLINDER PART OF THE POINTER. SUBTRACT IT FROM THE CURRENT CYLINDER (LCYLI)
073702   % THE DIFFERENCE (NO. CYLINDERS TO SEEK) IS WRITTEN OUT AS WORD COUNT.
073702   % STORE THE NEW CYLINDER NO. IN LCYLI.
073702   % FIND THE ALTERNATIVE TRACK'S HEAD NO., AND STORE IT IN SHEAD.
073702
073702   DBAD:   T:=2; X:=WNLBB; *LDATX         % TO ENSURE NOT HIT IN CACHE
073705           T:=WNLBA;       *LDATX
073707           T:=A                           % T <== ALTERNATIVE DISK CYL. ADDR.
073710           A:=TRG SHZ 10 SHZ -16=:X       % UNIT NO. IN X
073714           A:=T ; AD SHZ -5               % HEAD INTO UPPER 5 BITS OF D, CYLINDER IN A
073716           A-LCYLI(X)                     % A <== NO. OF CYL'S TO GO
073717   *WORD3, IOXIN LWOR
073720           T SHZ -5 =:LCYLI(X)            % NEW CYL. ADDR. AFTER THIS SEEK
073722           A:=0 ; AD SHZ 5 ; A=:SHEAD     % HEAD TO USE ON ALT TRACK
073725           A:=-1=:SEEKF                   % SET SEEK FLAG
073727           0=:BADTR                       % RESET BAD TRACK FLAG
073730           T:=60000                       % SEEK COMMAND
073731           GO FAR WDACT                   % ACTIVATE
073732
073732   *)FILL
073741

073741   % ROUTINE TO SEEK ON DISK ---------------------------------------------
073741
073741   INTEGER TEMPX
073742
073742   DSEEK:  0=:TRTZ                        % RESET RECALIBRATE FLAG
073743           A:=DRG=:D
073745           A:=TRG/\300 SHZ 3 BONE 4
073751   *CONT5, IOXIN LCON                     % DEVICE CLEAR
073752   *CONT6, IOXIN LCON                     % DEVICE CLEAR
073753           A:=ARG
073754           X-1;D+X;IF C THEN A+1;FI; X+1  % AD= LAST LOGICAL DISK ADDR.
073762           T:=WSECY ; * RDIV ST % A<= CYL. NO.    D<= NO. OF SEC'S IN LAST CYL
073764           IF A>>T:=WMXCY GO FAR LAOUR    % GO IF WANTED LOGICAL ADDRES>MAX LOGICAL ADDRESS
073767           X=:TEMPX
073770           T:=TRG SHZ 10 SHZ-16=:X        % UNIT NO. IN X
073774           T:=LCYLI(X)
073775           A=:LCYLI(X)
073776           X:=TEMPX
073777           A-T ; * BLDC 170 DA            % SAVE SEEK DIRECTION IN K
074001           IF A<0 THEN A:=A- FI           % NEGATIVE STEP COUNT
074003   *WORD1, IOXIN LWOR                     % LOAD WORD COUNT WITH TRACK DIFFERENCE
074004           A=:SSTEP
074005           A:=0 ; T:=WSECT ; * RDIV ST    % A<= HEAD NO.     D<= NO. OF SEC'S ON LAST TRACK
074010           A=:SHEAD
074011           A:=D+1=:SSEC
074013           IF A:=SSTEP><0
074014              THEN                        % IF NOT ON CORR. CYL
074015                A=:SEEKF                  % SET SEEK FLAG
074016                T:=20000 ; * BSTA 160 DT  % STEP COMMAND INCLUDE DIRECTION
074020                GO WDACT                  % ACTIVATE
074021          FI
074021          GO RWDIS
074022   *)FILL
074025

074025   % MOD. EARLY/LATE-STROBE BIT IN CONTR.REG
074025   ELTE:  T:=3; 0=:D
074027          IF ERRC1 /\ T = T THEN
074033             D BONE STREARLY
074034          ELSE IF T-1 = A   THEN
074040             D BONE STRLATE
074041          FI FI
074041          IF D BIT STREARLY OR BIT STRLATE THEN
074045            MIN ELCOU; A /\ A                   % COUNT SETTING EARLY/LATE STROBE
074047          ELSE
074050            MIN NOCOU; A /\ A                   % COUNT SETTING NOMINEL STROBE
074052          FI
074052          TRG BZERO STREARLY BZERO STRLATE \/D=:TRG
074057
074057   % ROUTINE TO READ OR WRITE ON DISK -----------------------------------
074057   RWDIS:  0=:SEEKF                                 % RESET SEEK FLAG
074060           T:=SSEC=:D
074062           IF X<<T THEN T:=X FI                     % IF WHOLE TRANSFER WITHIN THIS TRACK THEN T<= NO. OF SEC'S TO TRANSFER
074065           T=:NOSEC
074066           X-T=:XRG                                 % X<= REMAINING SECTORS
074070           D-T                                      % D<= FIRST SECTOR
074071           A:=TRG SHZ 10 SHZ -16=:X                 % UNIT NO. IN X
074075           A:=LCYLI(X) SHZ 5 \/D                    % SHIFT CYLINDER ADDR. TO CORR. POSITION COMBINE CYL. & SEC. ADDRESS
074100   *DAD1,  IOXIN LDAD
074101           A=:SVLBB
074102           A:=WSECW ; X:=XRG ; * RMPY SA DX         % AD<= REMAINING WORDCOUNT
074105           A:=:D+CMAD2:=:D
074110           A:=A+C+CMAD1
074112   *LMAR1, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, UPPER PART
074113           A=:WANKN
074114           IF A-400>=0 GO MORER                     % MEMORY OUT OF RANGE
074116           A:=D
074117   *LMAR2, IOXIN LOMAR                               % LOAD MEMORY ADDRESS, LOWER PART
074120           A=:SVLCA
074121           A:=T*WSECW                               % A<= WORDCOUNT
074123   *WORD2, IOXIN LWOR
074124           A=:SVLWC
074125           A:=3/\TRG SHZ 13 =:T                     % FUNCTION CODE IN T
074131
074131
074131   % ROUTINE TO CREATE CONTROLWORD FOR ACTIVATION -----------------------
074131
074131   WDACT:  A:=SHEAD SHZ 5   ; T\/A        % SHIFT HEAD NO. TO CORR. POSITION
074134           A:=TRG/\142000
074136           A\/BADIP ; T\/A
074140           A:=TRG SHZ 3/\3000\/T+5        % + UNIT NO. + ACTIVATE & INT. ENABLE
074145   *CONT3, IOXIN LCON
074146           A=:SVLCO
074147   INTEGER STAT3:=IOXIN+RSTA
074150           IF A NBIT ACTIV GO CNACT       % ERROR, NOT BUSY
074152           A=:BUSFL
074153   WBUSY:  TAD:=TADRG ; X:=XRG
074155           GO RETUR                       % BUSY EXIT
074156   *)FILL
074161

074161   % FINISHED & ERROR EXITS ----------------------------------------------
074161
074161   DFIN:   T:=TRG
074162           L+1 ; GO WFINI                       % FINISHED EXIT
074164
074164   MORER:  T:=1   ; GO DERR                     % ATTEMPT TO USE BANK NO. >>377.         BIT  8
074166   MEMER:  T:=4   ; GO DERR                     % CORE ADDRESS REGISTER NOT AS EXPECTED  BIT 10
074170   LAOUR:  T:=10  ; GO DERR                     % LOGICAL ADDRESS OUTSIDE DICE DEVICE    BIT 11
074172   DILLC:  T:=100 ; GO DERR                     % ILLEGAL CODE                           BIT 14
074174   CNACT:  T:=200 ; GO DERR                     % CONTROLLER NOT ACTIVE AFTER ACTIVATE   BIT 15
074176   HDERR:  T:=0                                 % HARDWARE ERROR NO ADDITIONAL STATUS
074177
074177   DERR:   L-1                                  % ERROR RETURN
074200           T SHZ 10                             % GET THE ADDITIONAL STATUS
074201           A:=TRG/\377 ; T\/A
074204   WFINI:  X:=SSTAT
074205           IF IRETR >=0 THEN -5 FI;A=:ERRC1
074211           0=:BUSFL
074212   RETUR:  EXITA                                % GENERAL EXIT
074213   RBUS
074215
074215   *)KILL LDAD  RSTA LCON LWOR
074215   *)KILL SATAD WSECW WSECY ACTIV ICERR ADDMI ONCYL TEST
074215   *)KILL WSECT WMXCY RMAR1 RMAR2 CONT1 STAT2 CONT4
074215   *)KILL DAD2  DAD3  LMAR3 LMAR4 WORD4 WORD3 WORD1 DAD1  LMAR1 LMAR2
074215   *)KILL WORD2 CONT3 DISDE CONT2
074215   *)KILL CONT5 CONT6
074215   *)KILL STREA STRLA
074215
074215   *"8ZWDI -8WDIS
"074215   *"8WDIM; 8WDIM=0
"074215
074215   @DEV 1
074215   @EOF
074215

074215  "8BDIS+8BDIM+8ZBDI
074215

074215
074215  %==============================================================================
074215  % 43.5       B D I S K                 VERSION A      26/11-81    CORR. BY TP
074215  %                                      VERSION B      30/12-81    CORR. BY TP
074215  %                                      VERSION C.6    16/ 4-82    CORR. BY TP
074215  %                                      VERSION D       6/10-82    CORR. BY TP
074215  %                                      VERSION E      10/11-82    CORR. BY TP
074215  %                                      VERSION E.1    29/ 3-83    CORR. BY TP
074215  %                                      VERSION E.2    31/ 8-83    CORR. BY TP
074215  %                                      VERSION E.3    26/ 9-83    CORR. BY TP
074215  %                                      VERSION E.4    19/ 3-84    CORR. BY TP
074215  %                                      VERSION F.0     2/ 4-84    CORR. BY TP
074215  %                                      VERSION F.1     3/ 5-84    CORR. BY TP
074215  %                                      VERSION F.2    26/ 6-84    CORR. BY TP
074215  %                                      VERSION F.3     7/ 8-84    CORR. BY TP
074215  %                                      VERSION F.4     3/ 9-84    CORR. BY TP
074215  %                                      VERSION F.5    19/ 9-84    CORR. BY TP
074215  %                                      VERSION F.6     6/11-84    CORR. BY TP
074215  %                                      VERSION F.7    15/11-84    CORR. BY TP
074215  %                                      VERSION G.0    20/ 3-85    CORR. BY TP
074215  %                                      VERSION G.1     8/ 5-85    CORR. BY TP
074215  %                                      VERSION G.2    21/ 5-85    CORR. BY TP
074215  %                                      VERSION G.3    17/ 6-85    CORR. BY TP
074215  %                                      VERSION G.4    16/ 9-85    CORR. BY TP
074215  %                                      VERSION G.5    12/12-85    CORR. BY TP
074215  %                                      VERSION G.6    28/ 4-86    CORR. BY TP
074215  %                                      VERSION G.7    23/ 6-86    CORR. BY TP
074215  %                                      VERSION G.8    19/ 8-86    CORR. BY TP
074215  %                                      VERSION G.9     4/11-86    CORR. BY TP
074215  %                                      VERSION G.A    20/ 5-87    CORR. BY TP
074215  %
074215  %   SUPER DISK (AND ECC CARTRIDGE DISKS) TRANSFER ROUTINE
074215  %
074215  %            THERE ARE 3 VERSIONS OF THE DRIVER, ACCORDING TO LIBRARY MARKS:
074215  %
074215  %                            8BDIS = NORMAL SINTRAN DRIVER
074215  %                            8BDIM = TEST PROGRAM DRIVER
074215  %                            8ZBDI = SWAP DRIVER (READ ONLY)
074215  %
074215  %      8BDIS AND 8BDIM
074215  %
074215  %            THE ARRAY ',B HTABL' MUST BE CORRECT (SEE BELOW).
074215  %
074215  %      8BDIS
074215  %
074215  %            THE DISC-DESCRIBING TABLES ARE EXTERNAL (SEE BELOW).
074215  %
074215  %      8ZBDI
074215  %
074215  %            THE CORRECT DEVICE DESCRIPTOR IS GENERATED AT ASSEMBLY TIME!!!
074215  %            PLDWO AND PSTWO WILL NOT WORK FOR N10.
074215  %
074215  %      FOR ALL:
074215  %
074215  %            IF THE ROUTINES 'PLDWO' AND 'PSTWO' ARE UNDEFINED, THEY WILL
074215  %            BE INCLUDED AFTER THE DRIVER!!!
074215  %            FOR N10, PAGING MUST BE OFF WHEN PLDWO AND PSTWO ARE ENTERED
074215  %            (USED BY ERROR CORRECTION). NOT FOR 8ZBDI. SEE 8ZBDI ABOVE.
074215  %            ERROR CORRECTION ASSUMES THAT THE CPU CAN REACH ALL THE MEMORY
074215  %            ACCESSIBLE TO THE DISK.
074215  %
074215  %
074215  "8BDIS+8BDIM
074215  %
074215  %     CALL:
074215  %     JPL I (BDISK
074215  %     JMP   ERROR           %ERROR EXIT
074215  %     JMP   BUSY            % BUSY EXIT
074215  %     JMP   FINIS           %FINISHED EXIT
074215  %
074215  "8ZBDI+8BDIS+8BDIM
074215  %
074215  %     REGISTER CONTENTS WHEN ROUTINE IS CALLED
074215  %
074215  %     T-  BIT 0-5:  DEVICE OPERATION  (FOR 8ZBDI, READ ONLY)
074215  %                    0 READ TRANSFER
074215  %                    1 WRITE TRANSFER
074215  %                    2 READ PARITY TRANSFER
074215  %                    3 COMPARE TRANSFER
074215  %                   20 READ LAST STATUS
074215  %                   35 RELEASE              (NOT FOR THE SWAP DRIVER)
074215  %                    6 PRIORITY-SELECT      (NOT FOR THE SWAP DRIVER)
074215  %                   37 THIS FUNCTION BELONGS TO FUNCTION 42 AND IS STARTED
074215  %                      BY THE DRIVER. IT SHOULD NOT BE USED IN A CALL.
074215  %                   42 TEST IF SPARE TRACKS AND IF SPARE SECTOR FORMAT.
074215  %                      (NOT FOR THE SWAP DRIVER).
074215  %                      IT IS ASSUMED THAT NO OF SECTORS IN X IS 1 AND THAT
074215  %                      SECTOR NUMBER (LOGICAL DISK ADDR) IN AD IS 0 (EXCEPT
074215  %                      THE FIXED BIT IN D 017) WHEN THIS FUNCTION CALLS THE
074215  %                      DRIVER THE FIRST TIME.
074215  %                   43 READ  FORMAT TABLE (NOT FOR THE SWAP DRIVER)
074215  %                   44 WRITE FORMAT TABLE (NOT FOR THE SWAP DRIVER)
074215  %        BIT 6-8:   UNIT SELECT
074215  %        BIT 9-11:          SURFACE NUMBER FOR PHOENIX DISK
074215  %        BIT 12-13: CORE ADDRESS BITS 16-17 (N10)
074215  %        BIT 14:    DEVICE TYPE
074215  %                           1= 30/60/90 MBYTE
074215  %                           0= ANY OTHER TYPE
074215  %
074215  %        BIT 15:    0: NORMAL TRANSFER
074215  %                   1: BIT 6 IS ADDED TO THE SECTOR NUMBER
074215  %                      (USED TO READ SPARE TRACKS. ONLY POSSIBLE FOR
074215  %                      THE LIBRARY MARK 8BDIM).
074215  %
074215  %     A- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 16-31
074215  %
074215  %     D- LOGICAL ADDRESS (DISK SECTOR NUMBER ) BITS 0-15
074215  %                           LOGICAL ADDRESS BIT 15 MEANS ANY FIXED
074215  %                           SURFACE FOR CARTRIDGE DISK
074215  %
074215  %     X- NUMBER OF SECTORS TO BE TRANSFERED
074215  %
074215  %       ****  ,B MEMAD CONTAINS THE 24-BIT MEMORY ADRESS
074215  %                      IN A DOUBLE WORD.
074215  %       ****  ,B HDEV  CONTAINS HARDWARE DEVICE NUMBER
074215  %
074215  "8BDIS+8BDIM
074215  %
074215  %       ****  ,B HTABL IS A 4 ENTRY INTEGER ARRAY OF POINTERS TO
074215  %                      DISC ADRESS LAYOUT FOR UNITS 0,1,2 AND 3.
074215  %
074215  "8ZBDI+8BDIS+8BDIM
074215  %
074215  %      DISC LAYOUT DEFINITION:
074215  %
074215  %                             WORD 0 (BSECW) = WORDS/SECTOR
074215  %                                  1 (BSECT) = SECTORS/TRACK
074215  %                                  2 (BSECY) = SECTORS/CYLINDER
074215  %                                  3 (BMXCY) = MAXIMUM VALUE OF CYLINDER
074215  %                                  4           FIRST CYL OF SPARE TRACK AREA
074215  %                                  5           FORMAT IN ECC CONTROL WORD
074215  %                                  6           FIRST CYL OF EXTRA AREA
074215  %                                  7           POINTER TO RELATED LAYOUT
074215  %
074215  %     EXIT INFORMATION:
074215  %
074215  %     ERROR EXIT: X- HARDWARE STATUS REG.
074215  %                 T- BIT  9: SEEK ERROR. RETURN TO ZERO SEEK HAS BEEN DONE.
074215  %                    BIT 10: CORE ADDR. REG NOT AS EXPECTED
074215  %                    BIT 11: LOG. BLOCK ADDR. OUT OF RANGE, OR
074215  %                            TRANSFER BIGGER THAN 63.5K
074215  %                    BIT 12: DATA CORRECTION INFORMATION ERROR
074215  %                    BIT 13: DRIVE TYPE DEFINITION ERROR
074215  %                    BIT 14: ILL. DEVICE OP. CODE
074215  %                    BIT 15: CONTROLLER NOT ACTIVE AFTER ACTIVATE
074215  %     EVERY TIME THE DRIVER ERROR EXITS, IT STORES 11 WORDS AT THE END OF
074215  %     THE CODE. THESE WORDS, THEREFORE, WILL CONTAIN SIGNIFICANT INFORMATION
074215  %     ABOUT THE LAST ERROR THAT OCCURED. THE ADDRESS OF THIS FIELD CAN BE
074215  %     FOUND IN BDISK+2.
074215  %
074215  %     BUSY EXIT:     THE ROUTINE MUST BE CALLED AGAIN AT ONCE, OR
074215  %                    AFTER INTERRUPT. THE NEW CALL IS DONE WITH T,A,D AND
074215  %                    X-REG. UNCHANGED.
074215  %
074215  %     FINISHED EXIT: X-HARDWARE STATUS REG.
074215  %                    WITH FUNCTION 042, X WILL BE:
074215  %                    0: NOT SPARE TRACKS, NOT SPARE SECTOR FORMAT
074215  %                    1:     SPARE TRACKS, NOT SPARE SECTOR FORMAT
074215  %                    2: NOT SPARE TRACKS,     SPARE SECTOR FORMAT
074215  %                    3:     SPARE TRACKS,     SPARE SECTOR FORMAT
074215  %
074215  %     B-REG. IS NOT CHANGED BY THE ROUTINE
074215  %
074215  %       THE ROUTINE CONVERTS LOGICAL (SECTOR NUMBER) ADDR. (LA)
074215  %       TO HARDWARE (CYLINDER/HEAD/SECTOR) ADDR. (HA)
074215  %       ACCORDING TO TABLE HTABL FOR THE CORRESPONDING UNIT.
074215  %
074215  %     **** THE NUMBER OF SECTORS FOR THE VARIOUS DISK PACKS, AND THE ACTUAL TABLE NAMES:
074215  %
074215  %          37 MB =  110176                    : DT037
074215  %          70 MB =  220526                    : DT070
074215  %          75 MB =  220526                    : DT075
074215  %         135 MB =  421206                    : DT135   SPARE SECTOR FORMAT
074215  %         140 MB =  441254                    : DT140
074215  %         160 MB =  441254                    : DT160
074215  %         288 MB = 1045572                    : DT288
074215  %         285 MB = 1066450                    : DT285   SPARE SECTOR FORMAT
074215  %         300 MB = 1127720                    : DT300
074215  %         450 MB = 1542420                    : DT450   SPARE SECTOR FORMAT
074215  %         460 MB = 1603760                    : DT460
074215  %
074215  %          30 MB = 0034736 FOR EACH SURFACE   : DT030
074215  %          60 MB = 0034736 FOR EACH SURFACE   : DT030
074215  %          90 MB = 0034736 FOR EACH SURFACE   : DT030
074215  %
074215  %
074215  %        WHEN CALLING, THE LOGICAL ADDR. IN AD MUST
074215  %        BE REPRESENTED AS AN UNSIGNED MAGNITUDE NUMBER.
074215  %
074215  %
074215  %        THE SECTORS WITHIN THE LAST CYLINDER ARE TRANSFERED
074215  %        FIRST, THEN THE SECTORS WITHIN THE PREVIOUS CYLINDER ETC....
074215  %        FOR THE OLD INTERFACE (10 KHZ), WITHIN ONE CYLINDER,
074215  %        THE GREATEST SINGLE TRANSFER IS  64K-BSECW, WHERE BSECW IS NUMBER
074215  %        OF WORDS PER SECTOR (THE WORD COUNT REGISTER HAS ONLY 16 BITS).
074215  %        FOR THE NEW INTERFACE (15KHZ), STILL WITHIN ONE CYLINDER,
074215  %        THE GREATEST SINGLE TRANSFER CAN BE A WHOLE CYLINDER, SINCE
074215  %        THE WORD COUNT REGISTER HAS 24 BITS.
074215  %
074215  %     DISPLACEMENTS FOR IOX INSTRUCTIONS:
074215  %
074215         RCA=0                 % READ CORE ADDRESS
074215         LCA=1                 % LOAD CORE ADDRESS
074215         RSC=2                 % READ SEEK CONDITION / ECC COUNT
074215         LBA=3                 % LOAD BLOCK ADDRESS  I/II
074215         RSR=4                 % READ STATUS REG / ECC PATTERN
074215         LCO=5                 % LOAD CONTROL WORD
074215         LWC=7                 % LOAD WORD COUNT / ECC CONTROL
074215       INIOX=165540            % INITIAL IOX INSTRUCTION
074215
074215  % THE DISK DRIVER MAY BE CALLED WITH 11 DIFFERENT DEVICE OPERATIONS.
074215  % IN THE FOLLOWING, READ, READ PARITY, AND COMPARE, ARE CALLED NON-WRITE.
074215  % THE WRITE OPERATION IS CALLED WRITE. THE READ-STATUS OPERATION IS QUITE
074215  % SPECIAL. IT IS REALLY A READ-LAST-STATUS OPERATION, AS IT WILL READ
074215  % LAST STATUS FROM THE VARIABLE SSTAT. IT WILL ALSO INITIATE THE DISK DATA
074215  % FIELD VARIABLES BUSFL, ECCFL, MARGC, AND SMARG BY STORING ZERO INTO THEM,
074215  % AND BY SETTING ERRC1 TO -4 AND ERRC2 TO -28.
074215  % THE TEST-IF-SPARE-TRACK OPERATION WILL BE EXECUTED FIRST AS A PARITY READ
074215  % FROM THE LAST POSSIBLE SECTOR ON THE FIRST TRACK, AND THEN AS A PARITY READ
074215  % FROM THE FIRST SECTOR IN THE SPARE TRACK AREA. IT IS NOT FOR THE SWAP DRIVER.
074215  % RELEASE AND PRIORITY-SELECT ARE NOT FOR THE SWAP DRIVER EITHER. THEY ARE
074215  % USED WHEN MORE THAN ONE CPU USE THE DISK.
074215  %
074215  % ***** THE READ-STATUS OPERATION SHOULD NOT BE USED WHEN BUSFL IS NONZERO.****
074215  %
074215  % IF THE DISK DRIVER IS CALLED WITH READ-ZERO-SECTORS, THE STATUS REGISTER
074215  % WILL BE READ AND PUT IN THE X REGISTER, AND THE DISK DRIVER WILL EXIT
074215  % AT THE FINISHED EXIT. IF NOT-ON-CYLINDER (STATUS BIT 14),
074215  % THE DISK DRIVER WILL EXIT AT THE ERROR EXIT.
074215  %
074215  %
074215  % THE VARIABLES IN THE DISK DATA FIELD USED BY THE DISK DRIVER:
074215  %
074215  % ARG
074215  %
074215  % USED TO SAVE THE VALUE OF THE A-REGISTER AT ENTRY.
074215  %
074215  % BMXCY
074215  %
074215  % (BMXCY=BSECW+3)
074215  % MAX CYLINDER NUMBER. THIS IS THE LAST (PHYSICAL) CYLINDER NUMBER ON THE DISK.
074215  %
074215  % BSECT
074215  %
074215  % (BSECT=BSECW+1)
074215  % NUMBER OF SECTORS PER TRACK.
074215  %
074215  % BSECW
074215  %
074215  % NUMBER OF WORDS PER SECTOR.
074215  %
074215  % BSECY
074215  %
074215  % (BSECY=BSECW+2)
074215  % NUMBER OF SECTORS PER CYLINDER.
074215  %
074215  % BTSTA
074215  %
074215  % THE MAIN PART OF THE DISK CONTROL WORD.
074215  %
074215  % BUSFL
074215  %
074215  % BUSY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
074215  % MUST BE ZERO THE FIRST TIME THE DISK DRIVER IS CALLED. THE DISK DRIVER
074215  % WILL SET BUSFL TO NONZERO WHEN A TRANSFER IS STARTED, AND WILL SET IT BACK
074215  % TO ZERO WHEN A TRANSFER IS FINISHED, OR WHEN IT ERROR EXITS.
074215  % NEW (15/11-84, VERSION F.7):
074215  % WHEN THE DISK DRIVER WANTS TO ERROR EXIT UNDER SINTRAN, IT FIRST DOES A BUSY
074215  % EXIT AFTER THE RETURN-TO-ZERO SEEK HAS BEEN STARTED, WITH BUSFL:=STATUS.
074215  % WHEN THE INTERRUPT OCCURS, STATUS IS RESET (STATUS:=BUSFL), AND ERROR EXIT.
074215  %
074215  % CDISP
074215  %
074215  % USED FOR ECC COUNT AND SECTOR WORD NUMBER.
074215  % WHEN THE DISK DRIVER TRIES TO DO ERROR CORRECTION ON A SECTOR, IT READS
074215  % THE ECC COUNT AND STORES IT IN CDISP. IF 1 < CDISP < 8204, IT IS CHANGED
074215  % INTO A SECTOR WORD NUMBER IN THE RANGE 0-0777, POINTING TO A DOUBLE WORD
074215  % IN THE SECTOR THAT MAY BE CHANGED, DEPENDING ON THE ECC PATTERN (SEE
074215  % CPAT1 AND CPAT2). IF ERROR CORRECTION HAS TAKEN PLACE (SEE CORCU), THEN
074215  % IT IS POSSIBLE FOR THE CALLING PROGRAM TO KNOW WHERE THE CORRECTION TOOK
074215  % PLACE, BY INSPECTING CDISP.
074215  %
074215  % CMAD1
074215  %
074215  % POINTS TO THE FIRST WORD OF A DOUBLE WORD CONTAINING CURRENT MEMORY ADDRESS.
074215  % THE CURRENT MEMORY ADDRESS IS THE MEMORY ADDRESS USED BY THE DRIVER
074215  % WHEN IT STARTS A TRANSFER. IT IS NOT NECESSARILY EQUAL TO THE MEMORY
074215  % ADDRESS SUPPLIED IN THE CALL (SEE MEMA1, MEMA2).
074215  % IF THE DISK DRIVER BREAKS A TRANSFER INTO SMALLER TRANSFERS, FOR INSTANCE,
074215  % IT HAS TO CALCULATE A NEW MEMORY ADDRESS AND STORE IT IN CMAD1 AND CMAD2.
074215  %
074215  % CMAD2
074215  %
074215  % POINTS TO THE SECOND WORD OF A DOUBLE MEMORY ADDRESS. SEE CMAD1.
074215  %
074215  % CORCU
074215  %
074215  % CORRECTION COUNTER. EVERY TIME THAT ERROR CORRECTION OCCURS,
074215  % CORCU IS INCREMENTED BY 1. ERROR CORRECTION IS ALWAYS DONE ON SINGLE SECTORS.
074215  % THE NOT-WRITE RETRY COUNTER (SEE SRTRY) IS USUALLY ALSO INCREMENTED (ONCE
074215  % FOR EACH SECTOR IN THE TRANSFER) WHEN CORCU IS INCREMENTED.
074215  % CORCU IS INCREMENTED ON READ AND PARITY-CHECK OPERATIONS.
074215  % THE FAILING BITS CAN BE IN THE DATA PART AND/OR IN THE ECC POLYNOMIAL.
074215  %
074215  % CPAT1
074215  %
074215  % WHEN THE DISK DRIVER WANTS TO DO ERROR CORRECTION, IT READS THE ELEVEN BITS
074215  % OF THE ECC PATTERN, INVERTS THE BIT ORDER (SWAPS BIT 0 AND 10, BIT 1 AND 9,
074215  % ETC.), AND STORES IT TEMPORARILY IN CPAT1. CPAT1 SHOULD NOT BE ZERO.
074215  % THEN CPAT1 IS SHIFTED ACCORDING TO THE LEAST SIGNIFICANT BITS OF THE ECC
074215  % COUNT IN CDISP. THE RESULT IS STORED IN CPAT1 AND CPAT2, READY TO BE
074215  % EXCLUSIVE OR'ED INTO THE SECTOR JUST READ.
074215  %
074215  % CPAT2
074215  %
074215  % SEE CPAT1.
074215  % ALSO USED TO SAVE TRG WHILE WAITING FOR ON-CYL AFTER RETURN-TO-ZERO SEEK.
074215  %
074215  %
074215  % DED01 ==> DED13
074215  % IS USED
074215  % BY THE DRIVER FOR SOME LOCAL VARIABLES. THE FIRST, BSECW, IS EQUAL TO
074215  % DED01  THE 11-WORD FIELD GOES FROM DED01 TO DED13.
074215  %
074215  % DRG
074215  %
074215  % USED TO SAVE THE VALUE OF THE D-REGISTER AT ENTRY.
074215  %
074215  % ECCFL
074215  %
074215  % RUN-ECC OPERATION FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
074215  % THIS FLAG IS USUALLY ZERO, BUT WHEN THE DISK DRIVER WANTS TO DO ERROR
074215  % CORRECTION, IT SETS ECCFL TO NONZERO AND STARTS THE RUN-ECC OPERATION.
074215  % WHEN RUN-ECC IS FINISHED, ECCFL IS SET BACK TO ZERO.
074215  % ECCFL IS SET TO ZERO AT THE ERROR EXIT AND THE FINISHED EXIT.
074215  %
074215  % ERRC1
074215  %
074215  % ERROR COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK DRIVER IS CALLED
074215  % THE FIRST TIME, ERRC1 USUALLY SHOULD HAVE THE VALUE -4. A FAILING WRITE
074215  % TRANSFER WILL THEN BE RETRIED THREE TIMES. IF THE CALLING PROGRAM WANTS
074215  % NOT TO HAVE WRITE RETRIES, IT SHOULD STORE -1 IN ERRC1 BEFORE CALLING
074215  % THE DISK DRIVER. FOR FAILING NOT-WRITE TRANSFERS, ERRC1 SHOULD BE HANDLED
074215  % IN THE SAME WAY, BUT THEN ERRC2 MUST ALSO BE TAKEN INTO ACCOUNT.
074215  % ERRC1 IS SET TO -4 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS
074215  % IN ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
074215  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
074215  %
074215  % ERRC2
074215  %
074215  % MARGINAL RECOVERY COUNTER. SHOULD HAVE A NEGATIVE VALUE. BEFORE THE DISK
074215  % DRIVER IS CALLED THE FIRST TIME, ERRC2 USUALLY SHOULD HAVE THE VALUE -28.
074215  % A FAILING NOT-WRITE TRANSFER WILL FIRST DO SOME RETRIES ACCORDING TO THE
074215  % VALUE OF ERRC1. WHEN ERRC1 HAS BEEN COUNTED UP TO ZERO, THERE WILL BE NO
074215  % MORE ORDINARY RETRIES. INSTEAD, THE DISK DRIVER WILL TRY TO DO MARGINAL
074215  % RECOVERY CYCLES, ACCORDING TO THE VALUE OF ERRC2. IT WILL FIRST SET MARGC
074215  % NONZERO. USUALLY, THE DISK DRIVER WILL DO 27 MARGINAL RECOVERIES (THREE
074215  % FULL CYCLES). BUT IF THE CALLING PROGRAM SETS BOTH ERRC1 AND ERRC2 TO -1,
074215  % THE DISK DRIVER WILL DO NO ORDINARY RETRIES AND NO MARGINAL RECOVERY CYCLES.
074215  % ERRC2 IS SET TO -28 WHEN A TRANSFER IS FINISHED, WHEN THE DISK DRIVER IS IN
074215  % ERROR-RECOVERY MODE (SEE SMARG), WHEN ALL WRITE-RETRIES HAVE BEEN DONE,
074215  % OR WHEN ALL NOT-WRITE MARGINAL RECOVERIES HAVE BEEN DONE (SEE MARGC).
074215  %
074215  % HDEV
074215  %
074215  % CONTAINS HARDWARE DEVICE NUMBER (01540 OR 01550).
074215  %
074215  % HTABL
074215  %
074215  % THERE ARE FOUR WORDS IN THE DATAFIELD (ONE FOR EACH UNIT), EACH POINTING TO
074215  % AN EIGHT-WORD DISK LAYOUT VECTOR. HTABL POINTS TO THE FIRST OF THE FOUR DATA
074215  % FIELD WORDS.
074215  %
074215  % MARGC
074215  %
074215  % MARGINAL RECOVERY FLAG. CAN HAVE THE VALUES ZERO AND NONZERO.
074215  % WHEN ALL THE ORDINARY NOT-WRITE RETRIES HAVE BEEN DONE (IF A TRANSFER FAILS),
074215  % THE MARGINAL RECOVERY BIT IN THE CONTROL WORD IS TURNED ON, MARGC IS SET
074215  % TO NONZERO, AND TYPEC IS INCREMENTED IN BIT 9.
074215  % MARGC IS SET TO ZERO WHEN THE DISK DRIVER IS IN ERROR RECOVERY
074215  % MODE (SEE SMARG), AND WHEN A TRANSFER IS FINISHED (BOTH OK EXIT AND ERROR
074215  % EXIT).
074215  %
074215  % MEMA1
074215  %
074215  % THE MOST SIGNIFICANT PART OF A DOUBLE WORD CONTAINING MEMORY ADDRESS.
074215  %
074215  % MEMA2
074215  %
074215  % THE LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS (SEE MEMA1).
074215  %
074215  % NWLBA
074215  %
074215  % LEAST SIGNIFICANT PART OF THE MEMORY ADDRESS OF NEW CYLINDER NUMBER, AND
074215  % NEW SURFACE AND SECTOR. USED WHEN SPARE TRACK ALLOCATION IS ACTIVE.
074215  % A TRACK THAT IS FLAGGED AS A BAD TRACK, CONTAINS THE ADDRESS OF THE
074215  % RESERVE TRACK IN EVERY DOUBLE WORD. THE FIRST PART OF THE DOUBLE WORD
074215  % CONTAINS THE NEW CYLINDER NUMBER, AND THE SECOND PART CONTAINS THE NEW
074215  % SURFACE NUMBER IN THE LEFTMOST 8 BITS, AND THE SECTOR NUMBER IN THE
074215  % RIGHTMOST 8 BITS. THIS SECTOR NUMBER IS IRRELEVANT, AS THE OLD SECTOR
074215  % NUMBER (THE SECTOR NUMBER IN THE ORIGINAL DISK TRANSFER) IS USED INSTEAD.
074215  % NWLBA MUST BE NWLBB+1. (*****)
074215  %
074215  % NWLBB
074215  %
074215  % MOST SIGNIFICANT PART OF THE MEMORY ADDRESS OF
074215  % NEW CYLINDER NUMBER. SEE NWLBA. MUST BE NWLBA-1 !!
074215  %
074215  % OCMD1
074215  %
074215  % OLD COMPUTED MEMORY ADDRESS, BITS 23-16. USED TO SAVE THE MEMORY ADDRESS
074215  % OF A DISK TRANSFER DURING SPARE TRACK ALLOCATION.
074215  %
074215  % OCMD2
074215  %
074215  % OLD COMPUTED MEMORY ADDRESS, BITS 15-0. SEE OCMD1.
074215  %
074215  % OSVBA
074215  %
074215  % OLD SURFACE AND SECTOR. USED TO SAVE THE OLD VALUES OF THE DISK ADDRESS
074215  % DURING SPARE TRACK ALLOCATION.
074215  %
074215  % OSVBB
074215  %
074215  % OLD CYLINDER. SEE OSVBA.
074215  %
074215  % OSVCO
074215  %
074215  % OLD CONTROL WORD. USED TO SAVE THE OLD CONTROL WORD DURING SPARE TRACK
074215  % ALLOCATION.
074215  %
074215  % OSVWC
074215  %
074215  % OLD WORD COUNT, LEAST SIGNIFICANT 16 BITS.
074215  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
074215  %
074215  % OSVWK
074215  %
074215  % OLD WORD COUNT, MOST SIGNIFICANT 8 BITS.
074215  % USED TO SAVE THE OLD WORD COUNT DURING SPARE TRACK ALLOCATION.
074215  %
074215  % SCADR
074215  %
074215  % THE LEAST SIGNIFICANT PART OF THE EXPECTED CORE ADDRESS REGISTER WHEN
074215  % A TRANSFER HAS FINISHED. IT IS COMPUTED BY THE DISK DRIVER (CMAD2+SVLWC).
074215  %
074215  % SLONG
074215  %
074215  % COUNTER FOR ERROR-RECOVERY (SEE SMARG). WHEN THE DISK DRIVER INITIATES
074215  % ERROR-RECOVERY MODE, SLONG IS SET TO 1-N, WHERE N IS THE NUMBER OF SECTORS
074215  % IN THE TRANSFER.
074215  %
074215  % SMARG
074215  %
074215  % ERROR-RECOVERY FLAG. CAN HAVE THE VALUES ZERO OR NONZERO.
074215  % WHEN A NOT-WRITE TRANSFER FAILS, OR A WRITE GIVES DMA-ERROR,
074215  % THE DISK DRIVER INITIATES ERROR-RECOVERY BY SETTING SMARG TO NONZERO.
074215  % ERROR-RECOVERY MEANS THAT THE TRANSFER IS BROKEN INTO SINGLE-SECTOR TRANSFERS.
074215  % EACH OF THESE TRANSFERS IS THEN DONE AND CHECKED FOR ERRORS.
074215  % IF THE TRANSFER IS READ, AND IT FAILS, ERROR CORRECTION IS TRIED.
074215  % IF THIS FAILS, OR IF THE TRANSFER IS PARITY CHECK OR COMPARE,
074215  % THE USUAL RETRIES AND MARGINAL RECOVERIES ARE DONE.
074215  % SMARG IS SET TO ZERO WHEN A NEW TRANSFER IS STARTED, AND WHEN A TRANSFER
074215  % IS FINISHED (BOTH OK EXIT AND ERROR EXIT).
074215  %
074215  % SPACO
074215  %
074215  % SPARE TRACK ALLOCATION COUNTER. EVERY TIME A DISK TRANSFER HAS SUCCESSFULLY
074215  % USED A RESERVE TRACK, THIS COUNTER IS INCREMENTED BY ONE.
074215  %
074215  % SPAFL
074215  %
074215  % SPARE TRACK ALLOCATION FLAG.
074215  % 0:  NORMAL TRANSFER (NO SPARE TRACKS INVOLVED).
074215  % 1:  ADDRESS MISMATCH HAS OCCURED. SPARE TRACK ADDRESS-READ HAS BEEN STARTED.
074215  % 2:  TRANSFER IN THE SPARE TRACK AREA HAS BEEN STARTED.
074215  %
074215  % SRTRY
074215  %
074215  % NOT-WRITE RETRY COUNTER. IT IS INCREMENTED EVERY TIME AN ORDINARY NOT-WRITE
074215  % RETRY IS STARTED. MARGINAL RECOVERY CYCLE RETRIES ARE COUNTED IN TYPEC,
074215  % BITS 15-9, EVERY TIME MARGC IS SET NONZERO.
074215  %
074215  % SSTAT
074215  %
074215  % CURRENT DISK STATUS.
074215  %
074215  % SVLBA
074215  %
074215  % SAVED DISK ADDRESS (SURFACE AND SECTOR).
074215  %
074215  % SVLBB
074215  %
074215  % SAVED DISK ADDRESS (CYLINDER NUMBER).
074215  %
074215  % SVLCA
074215  %
074215  % SAVED LEAST SIGNIFICANT PART OF THE CURRENT MEMORY ADDRESS (EQUAL TO CMAD2).
074215  %
074215  % SVLCO
074215  %
074215  % SAVED CONTROL WORD, EXCEPT WHEN RUN-ECC OPERATION IS STARTED.
074215  %
074215  % SVLWC
074215  %
074215  % SAVED WORD COUNT, LEAST SIGNIFICANT 16 BITS (NUMBER OF SECTORS * BSECW).
074215  %
074215  % SVLWK
074215  %
074215  % SAVED WORD COUNT, MOST SIGNIFICANT 8 BITS (NUMBER OF SECTORS * BSECW).
074215  %
074215  % SWTRY
074215  %
074215  % WRITE RETRY COUNTER. SWTRY IS INCREMENTED BY ONE EACH TIME A WRITE TRANSFER
074215  % FAILS.
074215  %
074215  % TRG
074215  %
074215  % USED TO SAVE THE VALUE OF THE T-REGISTER AT ENTRY.
074215  %
074215  % TYPEC
074215  %
074215  % BIT   0:   1: ECC INTERFACE                 0: 33/66MB INTERFACE
074215  %       1:   1: HEAD ADVANCE                      0: NOT HEAD ADVANCE
074215  %       2:   1: ERROR CORRECTION NOT ALLOWED      0: ERROR CORRECTION ALLOWED
074215  %       3:   1: MARGINAL RECOVERY NOT ALLOWED     0: MARGINAL RECOVERY ALLOWED
074215  %       4:   1: HEAD ADVANCE NOT ALLOWED, UNIT 0  0: HEAD ADVANCE ALLOWED, UNIT 0
074215  %               (SPARE TRACK ALLOC. ALLOWED)         (NO SPARE TRACK ALLOCATION)
074215  %       5:   1: DITTO FOR UNIT 1                  0: DITTO FOR UNIT 1
074215  %       6:   1: DITTO FOR UNIT 2                  0: DITTO FOR UNIT 2
074215  %       7:   1: DITTO FOR UNIT 3                  0: DITTO FOR UNIT 3
074215  %       8:   1: AUTOMATIC RELEASE NOT ALLOWED     0: ALLOWED
074215  %       9:   1: NEW (15 KHZ) INTERFACE            0: OLD (10 KHZ) INTERFACE
074215  %   15-10:   MARG. REC. COUNTER (INCREMENTED EACH TIME MARGC IS SET NONZERO)
074215  %
074215  %    BITS 0 AND 1 ARE SET INSIDE THE DISK DRIVER.
074215  %    BITS 2, 3, AND 4-7 ARE SET BY THE CALLING PROGRAM.
074215  %           BITS 4-7 CAN ALSO BE SET BY THE FUNCTION TEST-IF-SPARE-TRACK (042)
074215  %    BIT  8 IS SET BY THE FUNCTION PRIORITY-SELECT, AND RESET BY THE FUNCTION
074215  %           RELEASE. IT MAY ALSO BE SET/RESET BY THE CALLING PROGRAM.
074215  %    BIT  9 IS SET INSIDE THE DISK DRIVER.
074215  %
074215  % XRG
074215  %
074215  % USED TO SAVE THE VALUE OF THE X-REGISTER AT ENTRY.
074215  %
074215  % 9LREG
074215  %
074215  % USED TO SAVE THE VALUE OF THE L-REGISTER.
074215  %
074215
074215  "8BDIS+8BDIM
074215
074215  BDISK=*
074215         JMP   MORE9
074216         #GA                   % VERSION LETTER AND NUMBER
074217         DRIAR                 % ADDRESS OF ERROR FIELD
074220
074220  "8BDIM+8BDIS+8ZBDI
074220
074220  % DEFINITION OF EXTENSION TO DISK DATA FIELD
074220
074220  BSECW=DED01                  % WORDS/SECTOR
074220  BSECT=DED02                  % SECTORS/TRACK
074220  BSECY=DED03                  % SECTORS/CYLINDER
074220  BMXCY=DED04                  % MAX CYLINDER VALUE
074220                               % FIRST CYL NO OF THE SPARE TRACK AREA
074220                               % FORMAT (0 OR 020)
074220                               % FIRST CYLINDER OF EXTRA AREA
074220                               % POINTER TO RELATED LAYOUT
074220  9LREG=DED11                  % SAVED L-REG
074220  SSTAT=DED12                  % CURRENT DISK ADDRESS
074220  BTSTA=DED13                  % MAIN PART OF CURRENT DISK CONTROL WORD
074220
074220  "8BDIS+8BDIM
074220
074220  MORE9, STF   TRG ,B
074221         STX   XRG ,B
074222         SHT   SHR 6
074223         SAX   7               % MASK FOR UNIT
074224         RAND  ST DX           % X = UNIT NO.
074225         AAX   HTABL
074226         RADD  SB DX
074227         LDX   ,X              % X => DISC DEFINITION
074230         LDF   ,X 0            % GET DEFINITION
074231         STF   BSECW ,B        % TO CURRENT COPY
074232         LDF   ,X 3
074233         STF   BSECW+3 ,B
074234         LDD   6 ,X
074235         STD   BSECW+6 ,B
074236         LDF   TRG ,B
074237         LDX   XRG ,B
074240         LDA   HDEV,B          % HARDWARE DEVICE NUMBER
074241         ADD   (IOX  LCO       % CONSTRUCT FIRST IOX
074242         BSET                  % NOT APT
074243         SUB I (BLCOG          % TEST FIRST IOX IF INITIALIZED
074244         JAF   NOIOX           % BRANCH IF NOT INITIALIZED
074245         ADD I (BLCOG
074246         SUB I (BLCO4          % TEST LAST IOX
074247         JAF   NOIOX           % NONZERO: NOT INITIALISED
074250         BSET  ONE             % APT
074251         JMP   BRCHK
074252  NOIOX, ADD I (BLCO4          % INITIALIZE ALL IOX
074253         AAA   -5
074254         STA I (BRCA
074255         STA I (BRCA2
074256         AAA   2
074257         STA I (BRSC1
074260         STA I (BRSC2
074261         STA I (BRSC3
074262         STA I (BRSC4
074263         STA I (BRSC5
074264         STA I (BRSC6
074265         STA I (BRSC7
074266         STA I (BRSC8
074267         AAA   2
074270         STA I (BRSR1
074271         STA I (BRSR2
074272         STA I (BRSR3
074273         STA I (BRSR4
074274         STA I (BRSR5
074275         STA I (BRSR6
074276         STA I (BRSR8
074277         AAA   -3
074300         STA I (BLCA1
074301         STA I (BLCA3
074302         AAA   2
074303         STA I (BLBA1
074304         STA I (BLBA3
074305         AAA   2
074306         STA I (BLCO1
074307         STA I (BLCO3
074310         STA I (BLCO4
074311         STA I (BLCO8
074312         STA I (BLCOF
074313         STA I (BLCOG
074314         STA I (BLCOH
074315         AAA   2
074316         STA I (BLWC1
074317         STA I (BLWC2
074320         STA I (BLWC3
074321         BSET  ONE             % APT
074322
074322  "8ZBDI+8BDIS+8BDIM
074322
074322         JMP   BRCHK
074323
074323  )FILL
074363
074363  BRCHK, COPY  SL DA           % SAVE L
074364         STA   9LREG ,B
074365
074365  "8BDIS
074365
074365         LDA   BUSFL ,B
074366         JAZ   L43
074367         AAA   1
074370         JAZ   L43
074371         AAA   -1              % BUSFL CONTAINS STATUS.  LAST OP. WAS RET-TO-ZER
074372         STA   SSTAT ,B        % RESET STATUS
074373         LDT   CPAT2 ,B        % UNSAVE TRG
074374         JMP I (ERREK          % ERROR EXIT
074375  L43=*
074375
074375  "8ZBDI+8BDIS+8BDIM
074375
074375         SAA   77
074376         AND   TRG ,B
074377
074377  "8BDIS+8BDIM
074377
074377         AAA   -042
074400         JAZ   L41             % ZERO: TEST-IF-SPARE-TRACK
074401         AAA   042-043
074402         JAZ   L41             % ZERO: READ-FORMAT-TABLE
074403         AAA   043-044
074404         JAZ   L41             % ZERO: WRITE-FORMAT-TABLE
074405         AAA   044-037
074406         JAZ   L41             % ZERO: PART OF TEST-IF-SPARE-TRACK
074407         AAA   037-035
074410         JAZ   L47             % ZERO: RELEASE
074411         AAA   035-6
074412         JAF   L48
074413         JMP I (L49            % PRIORITY-SELECT
074414  L47,   JMP I (L50
074415  L48,   AAA   6-020
074416         JAF   L25
074417         LDA   BUSFL ,B        % OPERATION IS READ LAST STATUS
074420         JAF   L39             % NONZERO: BUSY. DONT READ LAST STATUS
074421         JMP I (FINEX
074422  L25,   AAA   14
074423         SKP   IF DA LST 0
074424
074424  "8BDIS+8BDIM+8ZBDI
074424
074424         JMP I (ILCOD          % ILL. DEVICE OP. CODE
074425  L41,   LDA   TRG ,B
074426         AND   (0700           % MASK FOR UNIT ADDRESS BITS.
074427         SHA   ZIN  1          % SHIFT TO POSITION FOR CWR.
074430         STA   BTSTA ,B        % STORE VALUE
074431         LDA   SVLCO,B         % GET LAST COMMAND
074432         AND   (16000          % MASK FOR WRITE AND COMPARE BIT, AND MARG.REC. BIT
074433         ADD   BTSTA ,B        % ADD TO NEW COMMAND IN ORDER NOT TO
074434         STA   BTSTA ,B        % REVERSE THE FIFO DIRECTION IN BLCOG
074435         LDA   BUSFL,B         % PREVIOUS X-FER TO BE CHECKED?
074436         JAF   BRSR1           % NO - ,CONTINUE
074437         STZ   SPAFL ,B        % RESET SPARE TRACK ALLOCATION FLAG
074440         LDA   BTSTA ,B
074441  BLCOG, INIOX LCO             % SET CWR15=0
074442  BRSR1, INIOX RSR             % READ STATUS
074443         BSKP  ZRO 20 DA       % CONTROLLER ACTIV?
074444  L39,   JMP I (EXBUS          % YES, BUSY EXIT
074445         LDA   BUSFL,B         % PREVIOUS TRANSFER TO BE CHECKED?
074446         JAF   BRSR2           % YES. SKIP UNIT SELECT
074447         LDA   TRG ,B
074450         AND   (0700
074451         SHA   ZIN 1
074452         JMP *+1               % BSET  ONE 30 DA (TEST MODE)
074453         JPL   BLCO1           % SELECT UNIT
074454  "8BDIS+8BDIM+8ZBDI
074454  BRSR2, INIOX RSR             % READ STATUS
074455         STA   SSTAT ,B        % SAVE IT
074456         BSKP  ONE 160 DA      % ON CYLINDER?
074457         JPL   ERKYL           % NO. PERHAPS ERROR
074460         LDA   BUSFL,B
074461         JAZ   L18             % ZERO: NO PREVIOUS TRANSFER. JUMP TO BCONT
074462         JMP   I *+1           % JUMP TO SPARE TRACK ALLOCATION HANDLER
074463         SPHAN
074464  L33,   LDA   SMARG,B         % ERROR RECOVERY CYCLE ?
074465         JAF   SECPR           % NONZERO: YES. JUMP TO SECTOR PROCESSING
074466         LDA   SSTAT ,B        % TEST STATUS
074467         AND   (037760
074470         JAF   BREX            % NONZERO: ERRORS IN THE PREVIOUS TRANSFER
074471         JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
074472         JMP I (ECADR
074473  L18,   JMP I (BCONT          % NO ERRORS, CONTINUE
074474
074474  BREX=*
074474
074474  "8BDIS+8BDIM
074474
074474         LDA   SVLCO,B         % PREVIOUS CONTROL WORD
074475         SHA   SHR 13
074476         AAA   -1
074477         JAZ   BWTRY           % ZERO: PREVIOUS DEVICE OP. WAS WRITE
074500
074500  "8BDIS+8BDIM+8ZBDI
074500
074500         LDA   TYPEC ,B        % IS ERROR CORRECTION ALLOWED ?
074501         BSKP  ZRO 020 DA
074502         JMP I (BRTRY          % NO
074503
074503  % PREPARE ERROR RECOVERY BY INITIATING SECTOR-BY-SECTOR PROCESSING
074503
074503  L45,   SAA   -1
074504         STA   SMARG,B         % SET SECTOR RECOVERY FLAG
074505         LDD   SVLWC-1 ,B      % GET LEAST WORD COUNT TO D-REG
074506         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
074507         LDX   BSECW ,B
074510         RDIV  SX              % CONVERT TO NUMBER OF SECTORS
074511         LDX   XRG ,B
074512         COPY  SA DA CM2
074513         COPY  SA DA AD1
074514         STA   SLONG,B         % STORE SECTOR CONTROL NUMBER
074515         LDA   BSECW ,B
074516         STA   SVLWC,B         % SET WORD COUNT TO ONE SECTOR
074517         STZ   SVLWK ,B
074520
074520  "8BDIS+8BDIM
074520
074520         LDA   SVLCO ,B
074521         SHA   SHR 013
074522         AAA   -1
074523         JAZ   L44             % OPERATION WAS WRITE
074524
074524  "8BDIS+8BDIM+8ZBDI
074524
074524         JMP I (BRTRY
074525
074525  "8BDIM+8BDIS
074525
074525  % WRITE-RETRY AFTER ERROR
074525
074525  BWTRY, LDA   SSTAT ,B
074526         BSKP  ONE 0130 DA
074527         JMP   L44             % NOT DMA-ERROR
074530         LDA   SVLWK ,B
074531         JAF   L45             % WORD COUNT > 64K
074532         LDD   SVLWC-1 ,B
074533         LDA   BSECW ,B
074534         AAA   1
074535         SKP   DD MLST SA
074536         JMP   L45             % WORD COUNT > ONE SECTOR
074537  L44,   MIN   ERRC1,B
074540         JMP   L8
074541         JMP I (ERR            % NO MORE RETRIES ALLOWED
074542  L8,    MIN   SWTRY,B         % COUNT ONE RETRY
074543         0
074544         JMP I (BOM
074545
074545  "8BDIM+8BDIS+8ZBDI
074545
074545  ERKYL, LDA   BUSFL ,B
074546         JAZ   L22             % ZERO: NO PREVIOUS TRANSFER
074547         LDA   SVLCO ,B
074550         BSKP  ONE 0120 DA
074551         JMP   L22             % NOT MARGINAL RECOVERY
074552         LDA   SSTAT ,B        % A MARG. REC. TRANSFER FINISHED. IGNORE NOT-ON-CYL
074553         BSET  ONE 0160 DA
074554         STA   SSTAT ,B
074555         EXIT
074556  L22,   JMP   I (ERCYL
074557
074557  )FILL
074577
074577  BLCO1, INIOX LCO             % LOAD CONTROL WORD
074600         EXIT
074601

074601  % ERROR RECOVERY (SECTOR-BY-SECTOR PROCESSING)
074601  %
074601  SECPR, LDA   SSTAT ,B        % GET STATUS
074602         AND   (037760
074603         JAF   ERRAN           % NONZERO: ERROR DURING PREVIOUS TRANSFER
074604  L4,    JPL I (BRSR6          % READ AND CHECK THE CORE ADDR REG
074605         JMP I (ECADR
074606         LDA   SLONG,B         % TEST SECTOR RETRY NUMBER
074607         JAP   L18             % POS: SECTOR RETRY COMPLETED. JUMP TO BCONT
074610         SAA   037
074611         AND   SVLBA ,B        % MASK OUT SECTOR BITS
074612         SUB   BSECT ,B        % SECTORS/TRACK
074613         AAA   1               % FIRST=0 NOT 1!!
074614         JAF   L10             % JUMP IF NOT LAST SECTOR ON TRACK
074615         LDA   SVLBA,B
074616         AND   (17400          % MASK FOR HEAD BITS
074617         ADD   (400            % INCR. HEAD ADDR.
074620         STA   SVLBA,B
074621         JMP   L11
074622  L10,   MIN   SVLBA,B         % INCREMENT SECTOR ADDRESS
074623  L11,   MIN   SLONG,B         % INCREMENT SECTOR CONTROL NUMBER
074624         0
074625         LDA   CMAD2,B
074626         ADD   BSECW ,B        % ADD ONE SECTOR
074627         STA   SVLCA,B         % NEW CORE ADDR.    (16 LOWER)
074630         STA   CMAD2,B
074631         LDA   CMAD1,B
074632         COPY  SA DA ADC
074633         STA   CMAD1,B         % NEW CORE ADDR.   (BANK BITS)
074634         JPL I (BQERR          % SUCCESSFULL SECTOR RETRY. RESET ERROR COUNTERS
074635         STZ   MARGC,B         % RESET MARGINAL CYCLE FLAG
074636         LDA   SVLCO,B
074637         BSET  ZRO 120 DA
074640         STA   SVLCO,B         % RESET COMMAND WORD
074641         AND   (017600
074642         STA   BTSTA ,B
074643
074643  "8BDIS+8BDIM
074643
074643         SHA   SHR 013
074644         AAA   -1
074645         JAZ   L8              % ZERO: OPERATION WAS WRITE
074646
074646  "8BDIS+8BDIM+8ZBDI
074646
074646         JMP I (BRTRY
074647

074647  % PREPARE FOR ERROR CORRECTION (CHECK IF CONDITIONS ARE FAVORABLE)
074647  %
074647  ERRAN=*
074647
074647  "8BDIS+8BDIM
074647
074647         LDA   SVLCO,B
074650         SHA   SHR 13
074651         AAA   -3
074652         JAZ   RETRY           % JUMP IF COMPARE COMMAND
074653         AAA   2
074654         JAZ   L44             % ZERO: OPERATION WAS WRITE
074655         BSKP  ZRO 0140
074656         JMP   L24             % N100
074657         LDA   CMAD1,B         % TEST FOR CORE ADDR. > 256K
074660         SHA   ZIN SHR 2
074661         JAF   RETRY           % CORE ADDR. TOO BIG FOR ECC
074662
074662  "8BDIS+8BDIM+8ZBDI
074662
074662  L24,   LDA   SSTAT ,B        % GET STATUS
074663         BSKP  ONE 110 DA      % SKIP IF DATA ERROR
074664         JMP   RETRY           % IF NOT --RETRY.
074665         AND   (036740         % MASK FOR ALL ERRORS (OTHERS)
074666         JAF   RETRY           % JUMP TO RETRY IF ANY ERRORS
074667  BRSC5, INIOX RSC             % READ SEEK CONDITION
074670         BSKP  ZRO 170 DA      % SKIP IF NOT ADDRESS FIELD
074671         JMP   RETRY           % ADDRESS FIELD,-GO TO RETRY
074672         COPY  SA DT           % SAVE SEEK CONDITION
074673         LDA   ECCFL,B         % IS ECC OP. FLAG SET?
074674         JAZ   RECOP           % JUMP IF FLAG NOT SET
074675         BSKP  ZRO 150 DT      % SKIP IF MAX ECC COUNT
074676         JMP   ECCOP           % CORRECTABLE !
074677         STZ   ECCFL,B         % PREPARE FOR RETRY
074700         LDA   BTSTA ,B
074701         BSET  ONE 170 DA
074702         JPL   BLCO1           % SET CWR15=1.
074703  BRSC3, INIOX RSC             % READ ECC COUNT
074704         SUB   (20071          % COUNT SHOULD BE =8249
074705         JAF   ERREC
074706  RETRY, JPL I (RESEC          % RESET ECC
074707         JMP I (BRTRY          % MARGINAL RECOVERY CYCLE EXIT
074710  RECOP, SAA   -1
074711         STA   ECCFL,B
074712         LDA   BTSTA ,B
074713         BSET  ZRO 0140 DA     % REMOVE BIT 12 IF PARITY CHECK
074714         ADD   (40005          % SET CWR14=0,ACTIVATE,ENBL.INTRPT.
074715         JPL   BLCO1           % START ECC-OP.
074716         JMP I (EXBUS
074717
074717  )FILL
074734

074734  % ERROR CORRECTION
074734  %
074734  ECCOP, STZ   ECCFL,B         % ECCFL:=0
074735         LDA   BTSTA ,B
074736         BSET  ONE 170 DA
074737         JPL   BLCO1           % SET CWR15=1.
074740  BRSR4, INIOX RSR             % READ ECC PATTERN
074741         SAT   -13
074742         STT   CDISP ,B
074743         SAT   0
074744         JMP   L2              % START PATTERN MIRRORING
074745  L1,    SHA   SHR 1
074746         SHT   ZIN 1
074747  L2,    BSKP  ZRO 0 DA
074750         BSET  ONE 0 DT
074751         MIN   CDISP ,B
074752         JMP   L1
074753         COPY  ST DA
074754         STA   CPAT1,B         % STORE PATTERN TEMPORARILY
074755         JAZ   ERREC
074756  BRSC4, INIOX RSC             % READ ECC COUNT ( 2-020001 FOR BIT IN SECTOR)
074757         JAN   ERREC
074760         STA   CDISP ,B        % SAVE ECC COUNT
074761         AAA   -2
074762         JAN   ERREC           % NEG: COUNT < 2
074763         SUB   K8191
074764         AAA   -071
074765         JAP   ERREC           % POS: COUNT > 8249
074766         AAA   056
074767         JAP   AYPAS           % POS: COUNT > 8203.  DATA ALREADY OK
074770         LDA   BTSTA ,B
074771         JPL   BLCO1           % SET CWR15=0.
074772         LDA   CDISP ,B        % ECC COUNT
074773         AAA   -014
074774         RCLR  DL              % L:=0
074775         JAP   L6
074776         RINC  DL              % L:=1
074777         AAA   012             % WORDNO MUST NOT BE NEGATIVE
075000  L6,    SAD   SHR 4
075001         STA   CDISP ,B        % WORDNO IN SECTOR
075002         SAA   0
075003         SAD   4
075004         COPY  SA DD
075005         SAA   0105
075006         SKP   DL EQL 0
075007         AAA   012             % BECAUSE OF WORDNO COMPENSATION ABOVE
075010         RSUB  SD DA
075011         ADD   SADIN           % SAD 0
075012         COPY  SA DX
075013         LDA   CPAT1 ,B        % ECC PATTERN
075014         RCLR  DD
075015         EXR   SX              % SHIFT PATTERN
075016         STA   CPAT1 ,B        % SAVE CORRECTION PATTERNS
075017         COPY  SD DA
075020         STA   CPAT2 ,B
075021
075021  "8BDIM+8BDIS
075021
075021         LDA   BTSTA ,B
075022         BSKP  ZRO 0140 DA     % TEST IF PARITY COMMAND
075023         JMP   AYPAS           % BYPASS CORRECTION ON PARITY COMMAND
075024
075024  "8BDIM+8BDIS+8ZBDI
075024
075024         LDD   CMAD1-1 ,B      % CMAD1 TO D
075025         LDA   CDISP ,B        % WORDNO IN SECTOR
075026         ADD   CMAD2 ,B
075027         SWAP  SA DD
075030         COPY  SA ADC DA
075031         STD   ADSAV           % SAVE CORRECTION ADDR
075032         LDX   CPAT1 ,B        % PATTERN 1
075033         JXZ   L5
075034
075034  "8BDIM+8BDIS
075034
075034         JPL I (L46            % GET DATA
075035
075035  "8BDIM+8BDIS+8ZBDI
075035
075035         REXO  SX DT           % CORRECT DATA
075036
075036  "8BDIM+8BDIS
075036
075036         LDD   ADSAV           % 24-BIT ADRESS
075037         JPL I (L57            % STORE CORRECTED DATA
075040
075040  "8BDIM+8BDIS+8ZBDI
075040
075040  L5,    LDD   ADSAV           % 24-BIT ADRESS
075041         RINC  DD
075042         COPY  ADC SA DA
075043         STD   ADSAV           % SAVE NEXT 24 BIT ADRESS
075044         LDX   CDISP ,B        % WORDNO IN SECTOR
075045         AAX   1
075046         BSKP  ZRO 0110 DX
075047         JMP   AYPAS           % WORDNO IS 01000.  DONT CORRECT
075050         LDX   CPAT2 ,B        % PATTERN 2
075051         JXZ   AYPAS
075052
075052  "8BDIM+8BDIS
075052
075052         JPL I (L46            % NEXT DATA WORD
075053
075053  "8BDIM+8BDIS+8ZBDI
075053
075053         REXO  SX DT           % CORRECT DATA
075054
075054  "8BDIM+8BDIS
075054
075054         LDD   ADSAV           % 24-BIT ADRESS
075055         JPL I (L57            % STORE CORRECTED DATA
075056
075056  "8BDIM+8BDIS+8ZBDI
075056
075056  AYPAS, MIN   CORCU ,B        % INCREASE CORRECTION COUNTER
075057         0
075060         LDA   SSTAT ,B        % REMOVE DATA ERROR BIT FROM STATUS
075061         AND   (176757
075062         STA   SSTAT ,B
075063         LDD   ARG ,B          % RESET AD
075064         LDX   XRG ,B
075065         JPL I (RESEC          % RESET ECC
075066         JMP I (L4
075067
075067  ERREC, JMP I (ERREB          % JUMP-HELP
075070
075070  K8191, 017777
075071  SADIN, SAD   0
075072  ADSAV, 0; 0
075074
075074  )FILL
075102

075102  % TRY AGAIN AFTER ERROR (NOT WRITE)
075102  %
075102  BRTRY, LDA   MARGC,B         % MARC. REC. CYCLE FLAG ALREADY SET?
075103         JAF   BMARG           % NONZERO: YES
075104         STZ   ECCFL,B         % RESET ECC PROCESSING FLAG
075105         MIN   ERRC1,B         % ORDINARY RETRIES DONE?
075106         JMP   L12             % NO. TRY ONCE MORE
075107         LDA   TYPEC ,B        % MARG REC ALLOWED ?
075110         BSKP  ZRO 030 DA
075111         JMP I (ERR            % NO
075112         ADD   (02000          % INCREMENT MARG REC COUNTER (BITS 15-10)
075113         STA   TYPEC ,B
075114         SAA   -1
075115         STA   MARGC,B         % SET MARG REC. CYCLE FLAG
075116         LDA   SVLCO,B
075117         BSET  ONE 120 DA      % SET BIT 10 IN CONTROL WORD(MARG. REC.)
075120         STA   SVLCO ,B
075121         AND   (017600
075122         STA   BTSTA ,B
075123  BMARG, MIN   ERRC2,B         % ALL MARG. REC.'S DONE?
075124         JMP   BOM
075125         JMP I (ERR            % 3 MARG. REC. CYCLES DONE. ERROR
075126  L12,   MIN   SRTRY ,B
075127         0
075130  %
075130  % TRANSFER ROUTINE
075130  %
075130  BOM,   LDA   BTSTA ,B
075131  "8BDIM+8BDIS+8ZBDI
075131         JPL   BLCOF           % CWR 15:=0
075132         SAA   -0100
075133         SHA   3
075134         STA   CPAT1 ,B        % TEMPORARILY USED FOR TIMEOUT
075135  BRSR8, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
075136         BSKP  ZRO 0160 DA
075137         JMP   L58             % ON-CYL
075140         MIN   CPAT1 ,B
075141         JMP   BRSR8
075142  L58,   LDA   SVLBA,B         % HEAD AND SECTOR
075143
075143  "8BDIS+8BDIM+8ZBDI
075143
075143  BLBA1, INIOX LBA             % LOAD HEAD AND SECTOR
075144         LDA   BTSTA ,B
075145         BSET  ONE 170 DA
075146         JPL   BLCOF           % CWR 15:=1
075147         LDA   SVLBB,B
075150
075150  "8BDIS+8BDIM
075150
075150         SAA   077
075151         AND   TRG ,B
075152         AAA   -043
075153         JAZ   L13
075154         AAA   043-044
075155         JAZ   L13
075156         SAA   0
075157         BSET  ONE 0170 DA
075160  L13,   BSET  BCM 0170 DA
075161         ADD   SVLBB ,B
075162
075162  "8BDIS+8BDIM+8ZBDI
075162
075162  BLBA3, INIOX LBA             % LOAD CYLINDER ADDRESS
075163         JPL I (RESEC          % RESET ECC.  SET CWR15:=0
075164         LDA   CMAD1,B
075165  BLCA1, INIOX LCA             % LOAD BANK NO
075166         LDA   CMAD2,B
075167  BLCA3, INIOX LCA             % LOAD MEMORY ADDR WITHIN BANK
075170         LDA   SVLWK ,B        % MOST SIGN WORD COUNT
075171  BLWC2, INIOX LWC
075172         LDA   SVLWC,B
075173  BLWC1, INIOX LWC             % LOAD WORD COUNT
075174         LDA   SVLCO,B
075175         JPL   BLCOF           % START TRANSFER
075176  BRSR3, INIOX RSR             % READ STATUS
075177         STA   SSTAT ,B
075200         BSKP  ONE 20 DA       % CONTROLLER ACTIVE ?
075201         JMP I (ERACT          % NO
075202         LDA   SVLWC ,B        % WORD COUNT
075203         ADD   CMAD2 ,B        % LEAST SIGN. PART OF MEMORY ADDR
075204         STA   SCADR ,B        % EXP. LEAST SIGN. PART OF THE CORE ADDR REG
075205  EXBUS, SAA   -1
075206  EXBU2, STA   BUSFL,B         % SET BUSY FLAG
075207         LDA   9LREG ,B
075210         COPY  SA DL
075211         LDF   TRG ,B
075212         EXIT  AD1             % BUSY EXIT!!!
075213
075213  )FILL
075220

075220  % START A NEW TRANSFER WHEN X IS NONZERO
075220  %
075220  BCONT, SKP   IF DX UEQ 0
075221         JMP I (FINEX          % ALL BLOCKS TRANSFERED
075222         STZ   SMARG,B
075223  BRSC6, INIOX RSC             % READ SEEK COND.
075224         COPY  SA DT
075225         LDA   BTSTA ,B
075226         BSET  ONE 170 DA
075227         JPL   BLCOF           % SET CWR 15 =1.
075230         LDA   TYPEC ,B
075231         COPY  SA DL
075232         BSET  ONE 0110 DL     % BIT FOR 15KHZ INTERFACE
075233  BRSR5, INIOX RSR             % READ ECC PATTERN
075234         AND   (174000         % MASK FOR BITS 11-15 OF A-REG.
075235         SUB   (134000
075236         JAZ   NEWIE           % ZERO: 15KHZ INTERFACE
075237         BSET  ZRO 0110 DL
075240         BSET  ZRO 0160 DA
075241         JAZ   NEWIE           % ZERO: 10 KHZ INTERFACE
075242         JMP I (ERTYP          % ERROR.
075243  %
075243  % DECIDE IF HEAD-ADVANCE SHOULD BE USED
075243  %
075243  NEWIE, COPY  SL DA
075244         STA   TYPEC ,B
075245         COPY  AD1 DL          % L:=1
075246
075246  "8BDIS+8BDIM
075246
075246         LDA   TRG ,B
075247         BSKP  ZRO 0160 DA
075250         JMP   L19             % PHOENIX
075251         SHA   075
075252         AND   (030            % UNIT NUMBER IN BITS 4-3
075253         ADD   (BSKP  ZRO 040 DA
075254         STA   *+2
075255         LDA   TYPEC ,B        % IS HEAD ADVANCE ALLOWED ?
075256         0                     % BSKP  ZRO 040 DA   FOR UNIT 0
075257         JMP   L19             % NO
075260         BSKP  ZRO 0140 DT
075261         BSET  ONE 010 DL      % HEAD ADVANCE. L:=3
075262
075262  "8BDIS+8BDIM+8ZBDI
075262
075262  L19,   SAA   -4
075263         AND   TYPEC ,B        % REMOVE BITS 1-0 FROM TYPEC
075264         RADD  SL DA
075265         STA   TYPEC ,B        % 1 OR 3 IN BITS 1-0
075266  %
075266  % COMPUTE THE BLOCK ADDRESS OF THE LAST BLOCK (SECTOR) IN THE TRANSFER
075266  %
075266         LDA   ARG ,B          % MOST SIGN. OF LOG. DISK ADDR
075267         LDT   TRG ,B
075270         BSKP  ONE 0160 DT     % PHOENIX DISK ?
075271         JMP   XY              % NO
075272         BLDA  170 DD          % SAVE FIXED/REMOV INDICATOR IN K
075273         BSET  ZRO 170 DD
075274         SAT   0
075275         BSET  BAC 140 DT      % SURFACE ALWAYS 20+N FOR FIXED DISK
075276         STT   SAVT
075277         JMP   XY
075300
075300  SAVT,  0
075301
075301  )FILL
075307  K7000, 07000
075310
075310  BLCOF, INIOX LCO             % LOAD CONTROL WORD
075311         EXIT
075312
075312  XY,    AAX   -1
075313         RADD  SX DD
075314         COPY  SA ADC DA       % ADDR OF LAST SECTOR NOW IN AD
075315         AAX   1
075316         LDT   BSECY ,B        % SECTORS/CYL
075317         SKP   DA MLST ST
075320         JMP   L40             % CYL > MAX CYL
075321         RDIV  ST
075322         LDT   BMXCY ,B
075323         SKP   DT MGRE SA
075324  L40,   JMP I (ILAD           % CYLINDER > MAX CYLINDER
075325         STA   SVLBB,B         % SAVE CYLINDER ARGUMENT
075326         COPY  SD DA AD1
075327         STA   HESEC           % 0 < HESEC <= BSECY
075330         SKP   DX GRE SA       % CHECK IF TRANSFER IS GREATER THAN 63.5K
075331         COPY  SX DA
075332         LDT   BSECW ,B        % A IS NO. OF SECTORS IN TRANSFER
075333         RMPY  ST DA
075334         JAZ   L20             % ZERO: LESS THAN 64K
075335         SWAP  SA DD
075336         RADD  ST DA
075337         RADD  ADC CM1 DD
075340         SWAP  SA DD
075341         RDIV  ST              % AFTER THIS, A HOLDS NUMBER OF SURPLUS SECTORS
075342         LDT   TYPEC ,B
075343         BSKP  ZRO 0110 DT
075344         SAA   0               % 15 KHZ INTERFACE. ALLOW MORE THAN 63.5K
075345  L20,   COPY  SA DL           % SAVE IT IN L FOR A LITTLE WHILE
075346         LDA   HESEC
075347         COPY  SA DD
075350  %
075350  % COMPUTE SURFACE AND SECTOR NUMBER
075350  %
075350         LDA   TYPEC,B
075351         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
075352         JMP   L14
075353         COPY  SX DA
075354         SKP   IF DA LST SD    % SKIP IF WHOLE TRANSFER WITHIN CYLINDER
075355         COPY  SD DA
075356         RSUB  SA DD
075357         RADD  SL DD           % SURPLUS SECTORS
075360         JMP   L23
075361  L14,   RDCR  DD
075362  L23,   SAA   0
075363         LDT   BSECT ,B        % GET SECTORS/TRACK
075364         RDIV  ST              % A:=SURFACE NO.
075365         COPY  SD DT           % D&T=NUMBER OF SECTORS IN LAST CYLINDER
075366         SHA   ZIN  10         % SURFACE IN LEFT BYTE
075367         RADD  SA DD           % MERGE SURFACE AND SECTOR
075370         AAT   1               % NO. OF SECTORS IN LAST CYLINDER
075371         LDA   TRG ,B
075372         BSKP  ONE 160 DA      % IF CARTRIDGE DISK
075373         JMP   NOTPH
075374         AND   K7000           % MASK FOR SURFACE (LA BIT 16-18)
075375         SHA   ZIN SHR 1       % MOVE TO BIT 8-10
075376         ADD   SAVT            % ADD SECTOR AND FIXED/REMOVABLE SURFACE FLAG
075377         ADD   HESEC
075400         AAA   -1
075401         COPY  SA DD
075402         AND   (03400
075403         JAZ   NOTPH           % ZERO: SURFACE 0 OR 020
075404         BSKP  ONE 0140 DD
075405         JMP   L40             % REMOVABLE, AND SURFACE # 0 !!
075406  NOTPH, LDA   TYPEC,B
075407         BSKP  ONE 10 DA       % SKIP IF HEAD ADVANCE
075410         JMP   L15
075411         COPY  SD DA
075412         JMP   L3
075413  L15,   SKP   IF DX GRE ST
075414         COPY  SX DT           % T: NO. OF SECTORS TO TRANSFER
075415         COPY  SD DA AD1
075416         RSUB  ST DA           % A: HARDWARE BLOCK ADR.
075417  L3,    STA   SVLBA,B         % SAVE HEAD AND SECTOR
075420  %
075420  % DECREMENT X
075420  %
075420         LDA   TYPEC,B
075421         BSKP  ONE 10 DA
075422         JMP   L7              % JUMP IF NOT HEAD ADVANCE
075423         LDT   HESEC           % LOAD HEAD + SECTOR
075424         SKP   IF DX GRE ST
075425         COPY  SX DT
075426         RSUB  SL DT           % SURPLUS SECTORS
075427  L7,    RSUB  ST DX           % X: NO. OF BLOCKS LEFT TO THE NEXT TRANSFER
075430         STX   XRG ,B
075431  %
075431  % X IS NOW NO. OF BLOCKS TO BE TRANSFERRED NEXT TIME.
075431  % T IS NOW NO. OF BLOCKS TO TRANSFER THIS TIME.
075431  % COMPUTE SVLCA, CMAD1, CMAD2, SVLWC.
075431  %
075431         LDA   BSECW ,B
075432         RMPY  SX DA           % AD: X*BSECW=NO. OF WORDS LEFT
075433         SWAP  SA DD
075434         ADD   MEMA2 ,B
075435         COPY  SD ADC DD
075436         STA   SVLCA ,B
075437         SWAP  SA DD
075440         ADD   MEMA1 ,B
075441         STD   CMAD1 ,B
075442         LDA   BSECW ,B
075443         RMPY  ST DA           % AD: T*BSECW=NO. OF WORDS TO TRANSFER
075444         STA   SVLWK ,B        % SAVE MOST SIGN WORD COUNT
075445         COPY  SD DA
075446         STA   SVLWC,B         % SAVE WORD COUNT
075447  %
075447  % PREPARE BTSTA AND THE CONTROL WORD (SVLCO)
075447  %
075447  "8BDIS+8BDIM
075447
075447         SAA   3
075450         AND   CMAD1 ,B
075451         SHA   5               % CORE ADDR BITS 17-16
075452         COPY  SA DT
075453
075453  "8BDIS+8BDIM+8ZBDI
075453
075453         LDA   TRG ,B
075454         AND   K0700
075455         SHA   ZIN 1           % UNIT NO
075456
075456  "8BDIS+8BDIM
075456
075456         RADD  SA DT
075457         SAA   077
075460         AND   TRG ,B
075461         AAA   -042
075462         JAZ   L54             % FUNCTION 042
075463         AAA   042-043
075464         JAZ   L56             % FUNCTION 043
075465         AAA   043-044
075466         JAZ   L55             % FUNCTION 044
075467         AAA   044
075470         JMP   L56
075471  L54,   AAA   1
075472  L55,   AAA   1
075473  L56,   SHA   013             % DEVICE OPERATION
075474         RADD  ST DA
075475
075475  "8BDIS+8BDIM+8ZBDI
075475
075475         STA   BTSTA ,B
075476         AAA   5               % ACTIVATE & ENABLE INTERRUPT
075477         STA   SVLCO,B         % SAVE CONTROL WORD
075500
075500  "8BDIS+8BDIM
075500
075500         SAA   077             % CHECK FOR FUNCTION 042 (TEST IF SPARE-SECTOR FORMAT)
075501         AND   TRG ,B
075502         AAA   -042
075503         JAF   L42
075504         JMP I (L60            % YES, FUNCTION 042
075505
075505  % THE CODE BELOW IS FOR FUNCTION 037, WHICH IS A SUBFUNCTION OF FUNCTION 042.
075505  % IT WILL START A PARITY CHECK ON THE SPARE TRACK AREA.
075505
075505  L65,   LDA   BMXCY+1 ,B      % FIRST CYL IN SPARE TRACK AREA
075506         STA   SVLBB ,B
075507         JAF   L42
075510         JMP I (L64            % NO SPARE TRACKS
075511
075511  "8BDIS+8BDIM+8ZBDI
075511
075511  L42,   JMP I (BOM            % JUMP TO TRANSFER ROUTINE
075512
075512  )FILL
075517  K0700, 0700
075520  HESEC, 0
075521

075521  % THIS IS THE FINISHED-AND-OK EXIT
075521  %
075521  FINEX, LDX   SSTAT ,B
075522         JPL   BQERR           % RESET ERROR COUNTERS
075523         STZ   ECCFL,B
075524         STZ   SMARG,B
075525         STZ   MARGC,B
075526         STZ   BUSFL,B
075527         STZ   SPAFL ,B
075530
075530  "8BDIS+8BDIM
075530
075530         JPL I (L52            % AUTOMATIC RELEASE
075531
075531  "8BDIS+8BDIM+8ZBDI
075531
075531         LDA   9LREG ,B
075532         COPY  SA AD1 DL
075533         LDF   TRG ,B
075534         EXIT  AD1             % FINISHED EXIT
075535  %
075535  % RESET-ECC SUBROUTINE
075535  %
075535  RESEC, LDA   BTSTA ,B
075536         BSET  ONE 170 DA
075537  BLCOH, INIOX LCO             % SET CWR15 = 1
075540         SAA   1
075541         ADD   BMXCY+2 ,B
075542  BLWC3, INIOX LWC             % RESET ECC
075543         LDA   BTSTA ,B
075544  BLCO8, INIOX LCO             % SET CWR15=0.
075545         EXIT
075546  %
075546  % READ-AND-CHECK THE CORE ADDR REG
075546  %
075546  BRSR6, INIOX RSR             % CLEAR UPPER/LOWER CORE ADDR. FLIP-FLOP
075547
075547  "8BDIS+8BDIM
075547
075547         SAA   077
075550         AND   TRG ,B
075551         AAA   -2
075552         JAZ   L38             % ZERO: PARITY CHECK
075553
075553  "8BDIS+8BDIM+8ZBDI
075553
075553  BRCA,  INIOX RCA             % READ CORE ADDR. REG
075554         STA   DRIAR
075555         SUB   SCADR,B
075556         JAF   L37             % NONZERO: CORE ADDR. REG NOT AS EXPECTED
075557         LDA   SVLWC ,B        % WORD COUNT
075560         ADD   CMAD2 ,B        % LEAST MEM ADDR
075561         LDA   CMAD1 ,B        % BANK NO
075562         COPY  SA ADC DA       % EXP. BANK NO
075563         ADD   SVLWK ,B        % MOST SIGN WORD COUNT
075564         STA   SAVBN
075565  BRCA2, INIOX RCA             % READ BANK NO
075566         AND   K0377
075567         SUB   SAVBN
075570         STA   SAVBN           % SAVE RESULT TEMP.
075571  BRSC1, INIOX RSC
075572         BSKP  ONE 0140 DA
075573  L38,   EXIT  AD1             % N10 INTERFACE, OR OK
075574         LDA   SAVBN
075575         JAZ   L38
075576  L37,   EXIT                  % BANK NO, OR ADDR, NOT AS EXPECTED
075577
075577  SAVBN, 0
075600  K0377, 0377
075601
075601  )FILL
075602
075602  % RESET ERROR COUNTERS
075602
075602  BQERR, SAA   -4
075603         STA   ERRC1 ,B
075604         SAA   -034
075605         STA   ERRC2 ,B
075606         EXIT
075607

075607  % BELOW FOLLOW THE DIFFERENT ERROR EXITS
075607  %
075607  ERACT, SAT   0100            % NOT ACTIVE AFTER ACTIVATE
075610         JMP   L9              % SET BIT 017 IN T
075611
075611  ILCOD, SAT   040             % ILLEGAL DEVICE OPERATION
075612         JMP   L9              % SET BIT 016 IN T
075613
075613  ERTYP, SAT   020             % CONTROLLER DEFINITION PROBLEM
075614         JMP   L9              % SET BIT 015 IN T
075615
075615  ERREB, SAT   010             % ECC PROBLEM
075616         JMP   L9              % SET BIT 014 IN T
075617
075617  ILAD, SAT   4                % LOGICAL DISK ADDR IS TOO BIG
075620         JMP   L9              % SET BIT 013 IN T
075621
075621  ECADR, SAT   2               % CORE ADDR REG ERROR. SET BIT 012 IN T
075622
075622  L9,    SHT   011             % SHIFT ERROR BIT TO CORRECT PLACE
075623         LDA   TRG ,B
075624         AND   BMASK
075625         RADD  SA DT
075626         SAA   0
075627         JPL   BLCO8           % CWR15:=0
075630  BRSC7, INIOX RSC
075631         STA   RSCON
075632         JPL   BQERR           % RESET ERROR COUNTERS
075633         JMP   ERREK
075634
075634  ERCYL, SAX   0               % NOT ON-CYLINDER
075635         JMP   L36             % CONTINUE WITH X=0
075636
075636  ERR,   SAX   -1              % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS
075637  L36,   JPL   BQERR           % ALL ERRC1 (WRITE) OR ERRC2 (NON-WRITE) TRANSFERS ARE DONE
075640         LDA   TRG ,B
075641         AND   BMASK
075642         COPY  SA DT
075643  BRSC2, INIOX RSC
075644         STA   RSCON
075645         BSKP  ZRO 130 DA
075646         BSET  ONE 110 DT      % SEEK ERROR
075647         BSKP  ONE 130 DA
075650         JXZ   ERREK           % JUMP TO ERREK IF X=0 AND NOT SEEK ERROR
075651         LDA   TRG ,B
075652         AND   K0700
075653         SHA   ZIN 1
075654         AAA   20
075655  BLCO3, INIOX LCO             % DEVICE CLEAR
075656         ADD   (033775         % RETURN-TO-ZERO SEEK (TEST MODE)
075657         LDX   RSCON
075660         BSKP  ONE 0140 DX
075661         BSET  ZRO 030 DA      % N-10.  REMOVE TEST MODE
075662  BLCO4, INIOX LCO
075663
075663  "8BDIS
075663
075663         STT   TRG ,B          % SAVE ERROR INFORMATION
075664         STT   CPAT2 ,B        % SAVE TRG UNTIL ERROR EXIT
075665         LDA   SSTAT ,B        % SAVE STATUS IN BUSY FLAG, AND BUSY-EXIT
075666         JMP I (EXBU2
075667
075667  "8BDIS+8BDIM+8ZBDI
075667
075667  ERREK, LDA   BTSTA ,B
075670         AAA   20
075671         JPL I (BLCOF          % CLEAR DEVICE
075672         STZ   BUSFL,B
075673         STZ   ECCFL,B
075674         STZ   SMARG,B
075675         STZ   MARGC,B
075676         STZ   SPAFL ,B
075677
075677  "8BDIS+8BDIM
075677
075677         JPL I (L52            % AUTOMATIC RELEASE
075700
075700  "8BDIS+8BDIM+8ZBDI
075700
075700         LDX   SSTAT ,B
075701
075701  "8BDIS+8BDIM
075701
075701         STX   QQQST           % DISK STATUS
075702         STT   TREGI           % ERROR INFORMATION
075703         LDA   SVLCO ,B
075704         STA   CONTR           % CONTROL WORD
075705         LDA   HDEV ,B
075706         STA   DEVNO           % DEVICE NUMBER
075707         LDA   CMAD1 ,B
075710         STA   BANKN           % BANK NUMBER
075711         LDA   CMAD2 ,B
075712         STA   ADRES           % MEMORY ADDRESS
075713         LDA   SVLBB ,B
075714         STA   QQQCY           % DISK CYLINDER
075715         LDA   SVLBA ,B
075716         STA   SRFSC           % DISK SURFACE AND SECTOR
075717         LDA   SVLWC ,B
075720         STA   WORDC           % WORD COUNT
075721
075721  "8BDIS+8BDIM+8ZBDI
075721
075721         LDA   ARG ,B
075722         JMP I 9LREG ,B        % EXIT
075723
075723  )FILL
075727
075727  BMASK, 0777
075730
075730  % BELOW FOLLOW 11 WORDS THAT CONTAIN ERROR INFORMATION ABOUT THE LAST ERROR.
075730  % THEY ARE STORED THERE WHEN THE DRIVER ERROR EXITS. PLEASE NOTE THAT THE
075730  % LOWER PART OF THE CORE ADDRESS REGISTER IS STORED IN DRIAR EVERY TIME THAT
075730  % REGISTER IS CHECKED, AND THIS IMPLIES THAT THE STATUS REGISTER MUST BE OK.
075730
075730  DRIAR, 0     % LOWER 16 BITS OF CORE ADDR REG AFTER TRANSFER (STATUS IS OK)
075731
075731  "8BDIM+8BDIS
075731
075731  QQQST, 0     % STATUS REGISTER
075732
075732  "8BDIM+8BDIS+8ZBDI
075732
075732  RSCON, 0     % SEEK CONDITION
075733
075733  "8BDIM+8BDIS
075733
075733  TREGI, 0     % BITS 017-011 ARE ERROR INDICATORS, 010-6 UNIT, 5-0 DEV. OP.
075734  CONTR, 0     % CONTROL WORD
075735  DEVNO, 0     % DEVICE NUMBER (01540 OR 01550)
075736  BANKN, 0     %  8 MOST  SIGNIFICANT BITS OF THE MEMORY ADDRESS
075737  ADRES, 0     % 16 LEAST SIGNIFICANT BITS OF THE MEMORY ADDRESS
075740  QQQCY, 0     % CYLINDER           PART OF THE DISK ADDRESS
075741  SRFSC, 0     % SURFACE AND SECTOR PART OF THE DISK ADDRESS
075742  WORDC, 0     % WORD COUNT
075743
075743  "8BDIS+8BDIM+8ZBDI
075743

075743  % SPARE TRACK ALLOCATION HANDLER.
075743  % ACTIVATED WHEN A TRANSFER GIVES ADDRESS MISMATCH STATUS ERROR.
075743  % CHECKS BIT 4 IN TYPEC ,B TO SEE IF SPARE TRACK ALLOCATION IS ALLOWED.
075743  % THE SPARE TRACK ALLOCATION PARAMETERS (I.E. THE NEW CYLINDER AND SURFACE)
075743  % ARE READ FROM THE BAD TRACK, BY READING WITH THE SAME CYLINDER AND SURFACE
075743  % AS IN THE ORIGINAL ACCESS, BUT WITH SECTOR 0100, 0101, AND SO ON, UNTIL
075743  % TWO WORDS ARE READ CORRECTLY. THOSE TWO WORDS (CYLINDER AND SURFACE) ARE THEN
075743  % USED, TOGETHER WITH THE ORIGINAL SECTOR INCREMENTED BY 0100, TO ACCESS THE
075743  % SPARE TRACK.
075743
075743  SPHAN=*
075743
075743  "8BDIS+8BDIM
075743
075743         SAA   077
075744         AND   TRG ,B
075745         AAA   -042
075746         JAF   *+2
075747         JMP I (L62            % FUNCTION IS TEST-IF-SPARE-TRACK
075750         AAA   042-037
075751         JAF   *+2
075752         JMP I (L66
075753
075753  "8BDIS+8BDIM+8ZBDI
075753
075753         LDA   SPAFL ,B        % THE SPARE TRACK ALLOCATION FLAG CAN BE 0/1/2
075754         JAF   L27
075755
075755  "8BDIS+8BDIM
075755
075755         LDA   TRG ,B
075756         SHA   075
075757         AND   (030            % UNIT NO NOW IN BITS 4-3
075760         ADD   (BSKP  ONE 040 DA
075761         STA   *+2
075762         LDA   TYPEC ,B        % SPARE TRACK ALLOCATION ALLOWED ?
075763         0                     % BSKP  ONE 040 DA   FOR UNIT 0
075764         JMP I (L33            % NO
075765
075765  "8BDIS+8BDIM+8ZBDI
075765
075765         LDA   SSTAT ,B        % ADDRESS MISMATCH ?
075766         BSKP  ONE 0100 DA
075767         JMP I (L33            % NO
075770  BRSC8, INIOX RSC             % READ SEEK CONDITION
075771         BSKP  ZRO 0130 DA
075772         JMP   ERR             % SEEK ERROR
075773         SAA   1               % FLAG:=1
075774         STA   SPAFL ,B
075775         LDA   CMAD1 ,B        % SAVE PART OF THE DATA FIELD
075776         STA   OCMD1 ,B
075777         LDA   CMAD2 ,B
076000         STA   OCMD2 ,B
076001         LDA   SVLBA ,B
076002         STA   OSVBA ,B
076003         LDA   SVLBB ,B
076004         STA   OSVBB ,B
076005         LDA   SVLCO ,B
076006         STA   OSVCO ,B
076007         LDA   SVLWC ,B
076010         STA   OSVWC ,B
076011         LDA   SVLWK ,B
076012         STA   OSVWK ,B
076013         LDA   SVLBA ,B        % SET SECTOR 0100
076014         AND   (177400
076015         BSET  ONE 060 DA
076016         STA   SVLBA ,B
076017         LDA   SVLCO ,B        % PUT READ-OP IN CONTROL WORD
076020         AND   (163777
076021         STA   SVLCO ,B
076022         AND   (177740         % AND IN BTSTA
076023         STA   BTSTA ,B
076024  L26,   SAA   2
076025         STA   SVLWC ,B        % WORD COUNT := 2
076026         STZ   SVLWK ,B
076027         LDA   NWLBB ,B        % DMA-ADDR OF EXTRA PAGE
076030         STA   CMAD1 ,B        % MEMORY ADDR IN DATA FIELD
076031         LDA   NWLBA ,B
076032         STA   CMAD2 ,B        % NWLBB AND NWLBA
076033         JMP I (BOM            % TRANSFER
076034  L27,   AAA   -1
076035         JAF   L31             % NONZERO: SPAFL IS NOT 1
076036         LDA   SSTAT ,B        % STATUS ERROR ?
076037         AND   (017760
076040         JAF   L30             % NONZERO: YES. TRY NEXT SECTOR
076041         JPL I (BRSR6          % NO. CHECK THE CORE ADDR REG
076042         JMP   L30             % CORE ADDR REG ERROR
076043         STF   BQTAD           % SAVE T AND D
076044         LDD   NWLBB ,B
076045
076045  "8BDIS+8BDIM
076045
076045         JPL I (L46            % FETCH WORD
076046         STT   BQTAD+3         % NEW CYL
076047         JPL I (L46            % FETCH WORD
076050
076050  "8BDIS+8BDIM+8ZBDI
076050
076050         STT   BQTAD+4         % NEW SURF/SECT
076051         LDF   BQTAD           % RESET T AND D
076052
076052  "8BDIS+8ZBDI
076052
076052         LDA   BQTAD+3         % CHECK THE NEW CYLINDER NUMBER
076053         JAN   L30             % NEG: ILLEGAL
076054
076054  "8BDIS+8BDIM+8ZBDI
076054
076054         SUB   BMXCY ,B
076055         AAA   -1
076056         JAP   L30             % POS: ILLEGAL
076057         LDA   TRG ,B
076060         BSKP  ZRO 0160 DA
076061         JMP   L28             % PHOENIX
076062         LDA   BQTAD+4         % CHECK THE NEW SURFACE
076063         JAN   L30             % NEG: ILLEGAL
076064         SHA   070
076065         AAA   1
076066         MPY   BSECT ,B
076067         SUB   BSECY ,B
076070         AAA   -1
076071         JAP   L30             % POS: ILLEGAL
076072         JMP   L29             % THE NEW CYL AND SURFACE OK (NOT PHOENIX)
076073
076073  )FILL
076107
076107  BQTAD, 0; 0; 0               % SAVED REGS
076112         0; 0                  % NEW DISK ADDR
076114
076114  L28,   LDA   BQTAD+4         % CHECK PHOENIX SURFACE
076115         JAN   L30             % NEG: ILLEGAL
076116         SHA   070
076117         JAZ   L29             % ZERO: OK
076120         AAA   -020
076121         JAN   L30             % NEG: ILLEGAL
076122         AAA   -5
076123         JAP   L30             % POS: ILLEGAL
076124  L29,   SAA   2               % FLAG:=2
076125         STA   SPAFL ,B
076126         LDA   OCMD1 ,B        % RESET DATA FIELD
076127         STA   CMAD1 ,B
076130         LDA   OCMD2 ,B
076131         STA   CMAD2 ,B
076132         LDA   OSVCO ,B
076133         STA   SVLCO ,B
076134         AND   (177740
076135         STA   BTSTA ,B
076136         LDA   OSVWC ,B
076137         STA   SVLWC ,B
076140         LDA   OSVWK ,B
076141         STA   SVLWK ,B
076142         LDA   BQTAD+3
076143         STA   SVLBB ,B        % NEW CYL
076144         LDA   BQTAD+4
076145         AND   (177400
076146         STA   BQTAD+4
076147         SAA   077
076150         AND   OSVBA ,B        % OLD SECTOR (+0100, OF COURSE)
076151         AAA   0100
076152         ADD   BQTAD+4         % NEW SURFACE
076153         STA   SVLBA ,B
076154         JMP I (BOM            % TRANSFER
076155  L30,   LDA   SVLBA ,B        % TRY NEXT SECTOR, IF POSSIBLE
076156         AAA   1
076157         STA   SVLBA ,B
076160         AND   (0377
076161         SUB   BSECT ,B
076162         AAA   -0100
076163         JAN   L26             % NEG: TRY NEXT
076164         LDA   OCMD1 ,B        % RESET DATA FIELD
076165         STA   CMAD1 ,B
076166         LDA   OCMD2 ,B
076167         STA   CMAD2 ,B
076170         LDA   OSVBA ,B
076171         STA   SVLBA ,B
076172         LDA   OSVBB ,B
076173         STA   SVLBB ,B
076174         LDA   OSVCO ,B
076175         STA   SVLCO ,B
076176         LDA   OSVWC ,B
076177         STA   SVLWC ,B
076200         LDA   OSVWK ,B
076201         STA   SVLWK ,B
076202         JMP I (ERR
076203  L31,   AAA   -1
076204         SKP   DA EQL 0
076205         JMP I (ERR            % SPAFL IS NOT 2
076206         LDA   SSTAT ,B
076207         AND   (017760
076210         JAF   L32             % NONZERO: STATUS ERROR
076211         JPL I (BRSR6          % CHECK THE CORE ADDR REG
076212         JMP I (ECADR          % ERROR
076213         LDA   OSVBA ,B        % RESET DISK ADDRS
076214         STA   SVLBA ,B
076215         LDA   OSVBB ,B
076216         STA   SVLBB ,B
076217         STZ   SPAFL ,B        % FLAG:=0
076220         MIN   SPACO ,B        % INCREMENT COUNTER
076221         0
076222  L32,   JMP I (L33            % BACK TO DRIVER
076223
076223  )FILL
076234
076234  "8BDIS+8BDIM
076234
076234  % PRIORITY-SELECT AND RELEASE IS HANDLED HERE
076234
076234  L49,   LDA   BUSFL ,B        % PRIORITY-SELECT. CHECK IF DRIVER IS BUSY
076235         SKP   DA EQL 0
076236         JMP I (EXBUS
076237         LDA   TRG ,B          % GET UNIT NO
076240         AND   (0700
076241         SHA   1
076242         ADD   (044010
076243         JPL I (BLCO8
076244         ADD   (134010         % GIVING 020 + UNIT NO
076245         JPL I (BLCO8
076246         LDA   TYPEC ,B        % SET RELEASE-NOT-ALLOWED BIT
076247         BSET  ONE 0100 DA
076250         STA   TYPEC ,B
076251         JMP   L51
076252  L50,   LDA   BUSFL ,B        % RELEASE. CHECK IF DRIVER IS BUSY
076253         SKP   DA EQL 0
076254         JMP I (EXBUS
076255         JPL I (BLCO8          % SELECT. A IS ZERO
076256         LDA   (044020
076257         JPL I (BLCO8          % RELEASE
076260         LDA   (002010
076261         JPL I (BLCO8          % DESELECT
076262         LDA   TYPEC ,B        % RESET RELEASE-NOT-ALLOWED BIT
076263         BSET  ZRO 0100 DA
076264         STA   TYPEC ,B
076265  L51,   LDX   (040011
076266         STX   SSTAT ,B
076267         JMP I (FINEX
076270
076270  % AUTOMATIC RELEASE IS HANDLED HERE. IT IS CALLED FROM FINEX AND ERREK
076270
076270  L52,   LDA   TYPEC ,B
076271         0                     % BSKP  ZRO 0100 DA  (175105)     **************
076272         EXIT                  % AUTOMATIC RELEASE IS NOT ALLOWED
076273         COPY  SL DA
076274         STA   L53             % SAVE L-REG
076275         SAA   0
076276         JPL I (BLCO8
076277         LDA   (044020
076300         JPL I (BLCO8
076301         LDA   (002010
076302         JPL I (BLCO8
076303         JMP I L53
076304
076304  L53,   0
076305
076305  )FILL
076316
076316  % FUNCTION 042 WILL BE STARTED HERE
076316
076316  L60,   LDA   BMXCY+4 ,B      % POINTER TO RELATED LAYOUT
076317         JAZ   L63             % ZERO: NO RELATED LAYOUT
076320         COPY  SA DX
076321         LDA   1 ,X            % SECTORS/TRACK FOR RELATED LAYOUT
076322         SUB   BSECT ,B        % SECTORS/TRACK FOR ACTUAL LAYOUT
076323         JAN   L61             % NEG: ACTUAL LAYOUT ALREADY NON-S-S
076324         LDT   TRG ,B          % CHANGE LAYOUT TO NON-S-S FORMAT
076325         SHT   072
076326         SAA   7
076327         RAND  ST DA           % UNIT NO
076330         AAA   HTABL
076331         RADD  SB DA
076332         SWAP  SA DX
076333         STA   ,X              % STORE RELATED POINTER IN DATA FIELD
076334         COPY  SA DX
076335         LDF   ,X              % CHANGE LAYOUT
076336         STF   BSECW ,B
076337         LDF   3 ,X
076340         STF   BSECW+3 ,B
076341         LDD   6 ,X
076342         STD   BSECW+6 ,B
076343  L61,   LDX   XRG ,B
076344         LDA   TYPEC ,B
076345         BSKP  ONE 0110 DA
076346         JMP   L63             % 10MHZ INTERFACE
076347         LDA   BMXCY+4 ,B
076350         JAZ   L63             % ZERO: NO RELATED POINTER
076351         LDA   BSECT ,B
076352         AAA   -1
076353         STA   SVLBA ,B        % LAST SECTOR
076354         JMP I (BOM
076355
076355  % PARITY CHECK ON LAST SECTOR, CYLINDER 0, SURFACE 0, JUST FINISHED.
076355
076355  L62,   LDA   SSTAT ,B
076356         BSKP  ONE 0100 DA
076357         JMP   L63             % NOT ADDR MISM.  USE NON-S-S FORMAT
076360         LDT   TRG ,B
076361         SHT   072
076362         SAX   7
076363         RAND  ST DX           % UNIT NO
076364         AAX   HTABL
076365         RADD  SB DX
076366         LDA   BMXCY+4 ,B      % POINTER TO RELATED LAYOUT
076367         STA   ,X              % CHANGE POINTER IN DATA FIELD
076370         COPY  SA DX
076371         LDF   ,X              % CHANGE LAYOUT
076372         STF   BSECW ,B
076373         LDF   3 ,X
076374         STF   BSECW+3 ,B
076375         LDD   6 ,X
076376         STD   BSECW+6 ,B
076377         LDX   XRG ,B
076400  L63,   LDA   TRG ,B
076401         SHA   075
076402         AND   (030
076403         ADD   (BSET ONE 040 DA
076404         STA   *+2
076405         LDA   TYPEC ,B
076406         0                     % SET BIT IN TYPEC
076407         STA   TYPEC ,B
076410         LDA   TRG ,B
076411         BSKP  ZRO 0160 DA
076412         JMP   L64             % PHOENIX
076413         SAA   -0100
076414         AND   TRG ,B          % REMOVE FUNCTION 042
076415         AAA   037             % INSERT FUNCTION 037
076416         STA   TRG ,B
076417         STZ   SVLBA ,B        % SURFACE 0, SECTOR 0
076420         LDA   SVLCO ,B
076421         BSET  ZRO 0120 DA
076422         STA   SVLCO ,B
076423         LDA   BTSTA ,B
076424         BSET  ZRO 0120 DA
076425         STA   BTSTA ,B
076426         JMP I (L65
076427
076427  % PARITY CHECK ON SPARE TRACK AREA JUST FINISHED
076427
076427  L66,   LDA   SSTAT ,B
076430         BSKP  ZRO 0100 DA
076431         JMP   L64             % ADDR MISM
076432         LDA   TRG ,B
076433         SHA   075
076434         AND   (030
076435         ADD   (BSET ZRO 040 DA
076436         STA   *+2
076437         LDA   TYPEC ,B
076440         0                     % RESET BIT IN TYPEC
076441         STA   TYPEC ,B
076442  L64,   SAA   -0100           % RESET FUNCTION 042
076443         AND   TRG ,B
076444         AAA   042
076445         STA   TRG ,B
076446         SAX   0
076447         LDA   TRG ,B
076450         SHA   075
076451         AND   (030
076452         ADD   (BSKP ZRO 040 DA
076453         STA   *+2
076454         LDA   TYPEC ,B
076455         0
076456         AAX   1               % MEANS SPARE TRACKS
076457         LDA   BMXCY+2 ,B      % FORMAT (0 OR 020)
076460         JAZ   L67
076461         AAX   2               % MEANS SPARE SECTOR FORMAT
076462  L67,   STX   SSTAT ,B
076463         JMP I (FINEX
076464
076464  )FILL
076473  )PCL MORE9
076473  )KILL RCA RSC LBA RSR LCO LWC LCA INIOX MORE9
076473
076473  "8BDIS+8BDIM
076473  )KILL BSECW BSECT BSECY BMXCY 9LREG SSTAT BTSTA
076473
076473  "8BDIS
076473
076473  L57,   DEPO                  % STORE DATA (OLD PSTWO)
076474         JMP   L71
076475  L46,   STA   L68             % SAVE A. PREPARE IMITATION OF CACHE CLEAR
076476         JAF   L69
076477         SAA   1
076500         JMP   L70
076501  L69,   SAA   0
076502  L70,   EXAM
076503         LDA   L68             % RESET A
076504         EXAM                  % FETCH DATA (OLD PLDWO)
076505  L71,   RINC  DD
076506         COPY  ADC SA DA
076507         EXIT
076510
076510  L68,   0
076511
076511  )PCL L57
076511  )KILL L57
076511
076511  "8BDIS; 8BDIS=0
076511  "
076511  )LINE

076511  %=============================================================================
076511  %      M 1 D R I V E R S
076511  %=============================================================================
076511
076511  %============================================================================
076511  % 43.0       N O R D   1 0 0   D R I V E R S   F O R   D M A   D E V I C E S
076511
076511  "99TM1+99TM2
076511  %==============================================================================
076511  % 43.2       T M A G T
076511  %
076511  % D R I V E R   2
076511  %
076511  % M A G . T A P E   T R A N S F E R   R O U T I N E ( T A N D B E R G )
076511  %
076511  % CALLING SEQUENCE:
076511  %      JPL I (TMAGT
076511  %      JMP   ERROR           % ERROR EXIT
076511  %      JMP   BUSY            % BUSY EXIT
076511  %      JMP   FINIS           % FINISHED EXIT
076511  %
076511  % CALLED WITH:
076511  %  X - NUMBER OF WORDS OR NUMBER  OF SPACE TO PERFORM
076511  %  T - BIT 0-5: FUNCTION CODE:
076511  %      0-READ ONE RECORD
076511  %      1-WRITE ONE RECORD
076511  %      2-READ ONE RECORD, ODD NUMBER OF BYTES
076511  %      4-READ CONSECUTIVE
076511  %      5-WRITE CONSECUTIVE
076511  %     10-ADVANCE TO EOF
076511  %     11-REVERSE TO EOF
076511  %     12-WRITE EOF
076511  %     13-REWIND
076511  %     14-WRITE SKIP
076511  %     15-BACKSPACE ONE RECORD
076511  %     16-FORWARD SPACE ONE RECORD
076511  %     17-REWIND AND UNLOAD
076511  %     20-READ STATUS
076511  %     21-CLEAR DEVICE
076511  %     22-CLEAR DEVICE WITH ERROR EXIT, USED BY SYSTEM
076511  %     23-READ ONE RECORD WITH TRESHOLD MODUS
076511  %     24-READ ONE RECORD, ODD NUMBER OF BYTES, WITH TRESHOLD MODUS
076511  %     26-READ-BYTE-RECORD ( X = NUMBER OF BYTES, NOT WORDS)
076511  %     27-WRITE-BYTE-RECORD ( X = NUMBER OF BYTES, NOT WORDS)
076511  %
076511  %      BIT 6-8: UNIT NUMBER
076511  %      BIT 12-13: CORE ADDRESS BIT 16-17
076511  %  D - BIT 0-1: DENSITY:
076511  %      0-800 BPI
076511  %      1-556 BPI
076511  %      2-200 BPI
076511  %      BIT 2: EVEN PARITY
076511  %
076511  % THE MEMORY ADDRESS (24 BITS) IS FOUND IN THE
076511  % DATAFIELD DOUBLE WORD CMADR (CMAD1;CMAD2)
076511  %
076511  % RETURN INFORMATION:
076511  %   ERROR EXIT: X -HARDWARE STATUS
076511  %   BUSY EXIT: THE ROUTINE MUST BE CALLED AGAIN AT ONCE OR AFTER
076511  %              INTERRUPT WITH X,T,A AND D UNCHANGED
076511  %   FINISHED EXIT: X-HARDWARE STATUS   A-CORE ADDRESS
076511
076511  % "HARDWARE STATUS" IS A COMBINATION OF THE STATUS AND MODUS
076511  % REGISTER
076511  % BIT 0-4: BIT 0-4 OF MODUS
076511  % BIT 5-15: BIT 5-15 OF STATUS
076511  %
076511  %   B IS NOT USED BY THE ROUTINE
076511  %
076511  % MAG. TAPE INSTRUCTION DISPLACEMENTS:
076511
076511  RCA=0        % READ CORE ADDRESS
076511  LCA=1        % LOAD CORE ADDRESS
076511  RMR=2        % READ MODUS
076511  LMR=3        % LOAD MODUS
076511  RSR=4        % READ STATUS
076511  LCR=5        % LOAD CONTROL
076511  LWC=7        % LOAD WORD COUNT
076511
076511  % HDEV,B MUST HOLD THE HARDWARE DEV. NUMBER (THE SNI DEV. NUMBER)
076511  "99TM1+99TM2 CXCPU
076511  BZRS0=BSET ZRO 00
076511  BONS0=BSET ONE 00
076511  "99TM1+99TM2
076511
076511  TMAGT=*
076511         COPY ST DA
076512         AND   (77             % MASK OUT FUNCTION
076513         AAA   -26
076514         JAN   BYPA1           % FUNCTION < 26
076515         AAA   -2
076516         JAP   BYPA1           % FUNCTION > 27
076517         AAT   -26             % 26 => 0; 27 => 1
076520         BSKP  ZRO 00 DT       % TEST FOR 0 OR 2
076521         JMP   BYPA0
076522         BSKP  ZRO 00 DX       % ODD NUMBER OF BYTES TO READ?
076523         AAT   2               % YES; 26 => 2 !!!
076524  BYPA0, AAX   1               % FOR ROUNDING
076525         COPY  SX DA           % GET BYTE-COUNT
076526         SHA   ZIN SHR 1       % BYTE-COUNT => WORD-COUNT
076527         COPY  SA DX           % WORD COUNT
076530  BYPA1, BZRS0
076531         STT I (MTREG
076532         STX I (MXREG
076533         BONS0
076534         LDA   HDEV,B          % A: HARDWARE DEV. NUMBER
076535         ADD   (IOX RSR
076536         SUB   MTRS1
076537         JAZ   BYPAS
076540         ADD   MTRS1
076541         STA   MTRS1           % GENERATE NEW IOX INSTRUCTIONS
076542         STA   MTRS2
076543         AAA   LWC-RSR
076544         STA   MTLWC
076545         AAA   RCA-LWC
076546         BZRS0
076547         STA I (MTRCA
076550         STA I (MTRC2
076551         BONS0
076552         AAA   LCA-RCA
076553         STA   MTLCA
076554         STA   MTLCX
076555         AAA   LMR-LCA
076556         STA   MTLM1
076557         STA   MTLM2
076560         AAA   LCR-LMR
076561         STA   MTLC1
076562         STA   MTLC2
076563         BZRS0
076564         STA I (MTLC3
076565         BONS0
076566         AAA   RMR-LCR
076567         STA   MTRM1
076570         BZRS0
076571         STA I (MTRM2
076572         SAA   -1
076573         STA   I MDRG        % NO UNIT SELECTED
076574         BONS0
076575  BYPAS, SAA 77
076576         RAND ST DA            % DEVICE CLEAR
076577         AAA -21
076600         JAF MTF22
076601         RINC DL
076602         RINC DL
076603         JMP MTRM2
076604  MDRG,  MDREG
076605  )FILL
076615  MTF22, AAA 21-22             % FUNCTION 22, CLEAR WITH ERROR EXIT
076616         JAZ MTRM2
076617  MTRS1, IOX   RSR
076620         BSKP  ZRO 20 DA       % LAST TRANSFER FINISHED ?
076621         JMP   MTEST           % NO, POSSIBLE ERROR
076622         JXZ   MROK            % YES, NEW TRANSFER ?
076623         LDA   (700            % YES, TEST FOR NEW UNIT
076624         RAND  ST DA           % A: UNIT
076625         BZRS0
076626         SUB   I MDRG
076627         JAZ   XMTRM
076630         ADD   I MDRG          % YES, SAVE NEW UNIT
076631         STA   I MDRG
076632         BONS0
076633         SHA   6               % UNIT TO CORRECT PART OF MODUS WORD
076634  MTLM1, IOX   LMR             % SELECT UNIT
076635         SAA   20
076636  MTLC1, IOX   LCR             % DEVICE CLEAR
076637         SAX   -20
076640         JNC   *               % WAIT 20 MICROSEC.
076641  MTRS2, IOX   RSR             % READ STATUS
076642         STA ZCSTA
076643         JMP MTRM1
076644  MROK,  STA   ZCSTA
076645         BSKP  ONE 40 DA       % INCL. OR OF ERRORS
076646         JMP   MTRM1
076647         AND   (5100
076650         JAF   MTRM2           % ERROR
076651         SAA 77
076652         AND MTREG
076653         AAA   -4
076654         JAN   MTRM2
076655         AAA   -7
076656         JAP   *4
076657         LDA   ZCSTA
076660         BSKP  ONE 70 DA       % EOF ?
076661         JMP   MTRM2           % NO
076662  XMTRM, BONS0
076663  MTRM1, IOX   RMR             % READ MODUS
076664         STA   MMODU
076665         LDA   MTREG
076666         AND   (17
076667         AAA   -17
076670         JAZ   MTRMX
076671         LDA   MMODU
076672         BSKP  ONE 00 DA       % ONLINE ?
076673         JMP   MTERR           % NO, ERROR
076674  MTRMX, SAA   77
076675         RAND  ST DA           % A: FUNCTION
076676         AAA   -20
076677         JAZ   MMSTA           % READ STATUS IF T=20
076700         AAA   20-25
076701         JAP   MILLC           % ILLEGAL FUNCTION IF T>24
076702         LDA   MXREG
076703         JAZ   MMSTA           % FINISHED ?
076704         LDA   CMAD1,B         % NO
076705  MTLCA, IOX   LCA             % LOAD CORE ADDRESS
076706         LDA   CMAD2,B
076707  MTLCX, IOX   LCA
076710         LDA   MXREG
076711  MTLWC, IOX   LWC             % LOAD WORD COUNT
076712         SAA   3
076713         BLDA  20 DD           % SAVE PARITY BIT
076714         RAND  SA DD           % D: DENSITY
076715         LDA   (700
076716         RAND  ST DA           % A: UNIT NUMBER
076717         SHA   6
076720         RADD  SD DA           % A: UNIT AND DENSITY
076721         BSTA  20 DD
076722         BSKP  ZRO 20 DD
076723         BSET  ONE 70 DA       % PARITY
076724         SAX   77
076725         RAND  ST DX
076726         BZRS0
076727         LDX I ,X (MMOD        % X: TRANSFER MODUS
076730         BONS0
076731         AAX   1
076732         JXZ   MILLC
076733         AAX   -1
076734         LDT   (776
076735         RAND  SX DT           % MASK OUT MODUS PART
076736         RADD  ST DA           % AD UNIT,PARITY AND DENSITY
076737         BLDA 00 DX
076740         BSTA 170 DA           % READ ODD
076741  MTLM2, IOX LMR
076742         LDA MTREG
076743         SHA ZIN SHR 7
076744         SAT 140
076745         RAND SA DT            % ADDRESS BITS 16&17
076746         LDA   (174000
076747         RAND  SX DA           % A: CONTROL PART
076750         RORA ST DA
076751         AAA   5               % ADD ACTIVATE AND ENABLE INTERRUPT
076752  MTLC2, IOX   LCR
076753         LDX MXREG
076754         LDT MTREG
076755         AAX -1
076756         SAA 77
076757         AND MTREG
076760         AAA -23
076761         JAP   REWRI
076762         AAA   23-10
076763         JAP   MTEST
076764  REWRI, SAX 0                 % READ OR WRITE
076765  MTEST, EXIT  AD1
076766
076766
076766         )FILL
076774
076774  MTRM2, IOX   RMR             % READ MODUS
076775         STA   MMODU
076776  MTERR, AND   (37             % MASK OUT MODUS
076777         COPY  SA DX
077000         LDA   ZCSTA
077001         AND   (177740         % MASK OUT STATUS
077002         RADD  SX DA
077003         STA   ZCSTA
077004         SAA   20
077005  MTLC3, IOX   LCR             % DEVICE CLEAR
077006         SAX   -20
077007         JNC   *               % WAIT 20 MICROSEC.
077010  MTRC2, IOX RCA               % READ CORE ADDRESS
077011         LDX   ZCSTA           % ERROR STATUS IN X
077012         BLDA 40 DX
077013         BSTA 160 DX
077014         EXIT                  % ERROR EXIT WITH HARDWARE STATUS IN X
077015
077015  % ILLEGAL CODE
077015
077015  MILLC, SAX   -1
077016         EXIT                  % ERROR EXIT WITH X=-1
077017
077017  % TRANSFER FINISHED. READ CORE ADDRESS. X: HARDWARE STATUS
077017
077017  MMSTA, LDA   MMODU
077020         AND   (37
077021         COPY  SA DX
077022         LDA   ZCSTA
077023         AND   (177740
077024         RADD  SA DX
077025         BLDA 40 DX
077026         BSTA 160 DX
077027  MTRCA, IOX   RCA             % READ CORE ADDRESS
077030         RINC  DL
077031         EXIT  AD1             % FINISHED EXIT
077032
077032
077032
077032  MTREG, 0
077033  MXREG, 0
077034  MDREG, 0
077035
077035  ZCSTA, 0                     % LAST STATUS REGISTER
077036  MMODU, 0                     % LAST MODUS REGISTER
077037
077037         )FILL
077041  % TABLE WITH HARWARE FUNCTIONS
077041
077041  MMOD,  0                     % 0-READ
077042         10                    % 1- WRITE
077043         1                     % 2- READ ODD
077044         -1                    % 3
077045         100000                % 4- READ CONSECUTIVE
077046         100010                % 5- WRITE CONSECUTIVE
077047         -1                    % 6
077050         -1                    % 7
077051         60                    % 10-ADV. TO EOF
077052         64                    % 11-REV. TO EOF
077053         50                    % 12-WRITE EOF
077054         10000                 % 13-REWIND
077055         30                    % 14-WRITE SKIP (ERASE)
077056         24                    % 15-BACKSPACE
077057         20                    % 16- FORWARD SPACE
077060         14000                 % 17- REWIND AND UNLOAD
077061         -1
077062         -1
077063         -1
077064         400                   % 23- READ WITH TRESHOLD
077065         401                   % 24- READ ODD NUMBER OF BYTES WITH TRESHOLD MODUS
077066
077066         )WRITE TMAGT
077066         )PCL TMAGT
077066         )KILL RCA LCA RMR LMR RSR LCR LWC
077066         )KILL BZRS0 BONS0
077066

077066  "
077066
077066  )LINE

077066  %=============================================================================
077066  %      M 2 D R I V E R S
077066  %=============================================================================
077066
077066  "8DMVC+8NLP1+8NLP2+8NLP3+8NLP4
077066  %==============================================================================
077066  % 43.6       V E R D R
077066  %
077066
077066  % VERSATEC DRIVER FOR DMA
077066  % CALLING SEQUENCE: JPL I (VERDR
077066  %                   JMP  ERROR
077066  %                   JMP  BUSY
077066  %                   JMP  FINISH
077066  %
077066  % INPUT ARGUMENTS: X=NO.OF WORDS
077066  %                      T=FUNCTION      20 = READ STATUS
077066  %                                      21 = CLEAR VERSATEC
077066  %                                      24 = READ LAST STATUS
077066  %                                      30 = SET ALPHANUMERIC MODE
077066  %                                      31 = SET GRAPHIC MODE
077066  %                                      32 = GIVE FORM FEED
077066  %
077066  % THE MEMORY ADDRESS (24 BITS) IS FOUND IN
077066  % THE DATAFIELD DOUBLE WORD DCMAD
077066  %
077066  % ERROR EXIT:
077066  %            X= ERROR CODE
077066  %                            X=1 NO MORE PAPER
077066  %                            X=2 NOT ONLINE
077066  %                            X=3 NOT READY
077066  %
077066  % BUSY EXIT:
077066  %            X MUST BE UNCHANGED IN NEXT CALL
077066  %
077066
077066  RCA=0        % READ MEMORY ADDRESS REGISTER
077066  LCA=1        % LOAD MEMORY ADDRESS REGISTER
077066  LBA=3        % LOAD MODUS REGISTER
077066  RST=4        % READ STATUS
077066  LCR=5        % LOAD CONTROL REGISTER
077066  LWC=7        % LOAD WORD COUNT
077066
077066  VERDR, COPY ST DD                      % FUNCTION TO D-REG.
077067  VIOOK, LDA   BUSFL,B
077070         JAF   VIO24
077071         RDCR  DD
077072         SKP   DD EQL 0
077073         JMP   SETFU                     % NOT WRITE FUNCTION
077074
077074  % WRITE FUNCTION
077074  VIO04, LDT HDEV,B; AAT RST; IOXT       % READ STATUS
077077         STA   VSTAT
077100         BSKP  ZRO 40 DA                 % CHECK FOR ERRORS
077101         JMP   VNRED
077102         BSKP  ONE 30 DA
077103         JMP   VNRED                     % VERSATEC NOT READY
077104  VERD1, LDA   CMAD1,B
077105  VIO01, LDT HDEV,B; AAT LCA; IOXT       % LOAD MEMORY ADDRESS REGISTER
077110         LDA   CMAD2,B; IOXT
077112         COPY  SX DA
077113  VIO07, LDT HDEV,B; AAT LWC; IOXT       % LOAD WORD COUNTER
077116         LDA I PVEFU,B                   % GET MODUS
077117  VIO03, LDT HDEV,B; AAT LBA; IOXT       % LOAD MODUS
077122         LDA   CMAD1,B
077123         AND   (3
077124         SHA   5
077125         AAA   5
077126  VIO15, LDT HDEV,B; AAT LCR; IOXT       % LOAD CONTROL WORD
077131         MIN   BUSFL,B
077132         EXIT  AD1                       % BUSY RETURN
077133
077133  VIO24, LDT HDEV,B; AAT RST; IOXT
077136         STA   VSTAT
077137         COPY SA DX
077140         BSKP  ZRO 40 DA                 % ERROR?
077141         JMP   VERR
077142         BSKP ONE 30 DA                  % READY FOR TRANSFER?
077143         EXIT AD1
077144  FERD,  STZ   BUSFL,B
077145         LDX   VSTAT
077146         RINC  DL
077147         EXIT  AD1                       % FINISH EXIT
077150
077150  VSTAT, 0
077151  VERR,  EXIT AD1
077152
077152  VNRED, SAA   20
077153  VIO55, LDT HDEV,B; AAT LCR; IOXT
077156  VIO54, LDT HDEV,B; AAT RST; IOXT
077161         STA   VSTAT
077162         BSKP  ONE 40 DA
077163         JMP   VERD1
077164         EXIT  AD1                       % BUSY EXIT
077165
077165  SETFU=*
077165  VIO44, LDT HDEV,B; AAT RST; IOXT
077170         STA   VSTAT
077171         COPY  SD DA
077172         AAA   -17
077173         JAN   ILLFU
077174         JAF   NFU20
077175  VIO34, LDT HDEV,B; AAT RST; IOXT
077200         STA   VSTAT
077201         JMP   FERD
077202  NFU20, AAA   -1
077203         JAF   NFU21
077204         SAA   20
077205  VIO45, LDT HDEV,B; AAT LCR; IOXT
077210         JMP   FERD
077211  NFU21, AAA   -30+21
077212         JAN   ILLFU
077213         JAZ   SA11
077214         AAA   -1
077215         JAZ   SA10
077216         AAA   -1
077217         JAZ   VRFF
077220  ILLFU, LDA   (201
077221         LDX   VSTAT
077222         EXIT                            % ERROR EXIT
077223
077223  VRFF,  LDD   VCODF,B
077224         STD   CMAD1,B
077225         SAX   1
077226         STX   CXRG,B
077227         SAT   1
077230         STT   CTRG,B
077231         JMP   VERDR
077232  SA10,  SAA   10
077233         JMP   *+2
077234  SA11,  SAA   11
077235         STA I PVEFU,B
077236         JMP   FERD
077237
077237  )FILL
077241  )PCL VERDR
077241  )KILL RCA LCA LBA RST LCR LWC
077241

077241  "8FDI1+8FDI2+8BFD1+8BFD2
077241
077241  )KILL RDAT  RSR1 RSR2 WCWD WDAD WSCT INTEN BBUSY
077241  )KILL ENINT DVCL BCLBU WRDAT WRDEL RDID FREAD SEEK
077241  )KILL RECAL
077241  )KILL 9TREG 9AREG 9DREG 9XREG 9LREG
077241  )KILL 9LREG CFUNC
077241
077241  "
077241  %

077241
077241  )LINE
%==============================================================================
077241  % 42.14      I T B 1 1
077241  %
077241  ITB11=*
077241  "8WD1+8MD1
077241  ITB11/WIGDI
077242  "99TM1
077242  ITB11+2/TMMT1
077244  "99SM1
077244  ITB11+2/STMT1
077244  %%"8DMVC
077244  %%ITB11+3/VEFIE
077244  "99TM2
077244  ITB11+6/TMMT2
077250  "99SM2
077250  ITB11+6/STMT2
077250  "8BD1
077250  ITB11+16/BIGDI
077260  "8BD2
077260  ITB11+17/BIGD2
077261  "8FDI1+8BFD1
077261  ITB11+20/FDID1
077262  "8FDI2+8BFD2
077262  ITB11+21/FDID2
077263  "
077263
077263  MAX11=*-ITB11
077263
077263
077263
077263  %==============================================================================
077263  % 42.17      I T E 1 1
077263  %
077263  ITE11=*
077263  "8SCS1; 140440;SCSI1         % SCSI HOST ADAPTER 1
077265  "8SCS2; 140441;SCSI2         % SCSI HOST ADAPTER 2
077267  "8SCS3; 140442;SCSI3         % SCSI HOST ADAPTER 3
077271  "8NLP1; 140230;DMPR1         % DMA LINEPRINTER #1
077273  "8NLP2; 140231;DMPR2         % DMA LINEPRINTER #2
077275  "8UD01; 140010;UDI01;        % UNIVERAL DMA INTERFACE #1
077277  "8UD02; 140011;UDI02;        % UNIVERAL DMA INTERFACE #2
077301  "8GPI0; 140000; DTGP0        % GPIB INTERFACE # 0
077303  "
077303
077303  *+XID11/
077315  -1;-1
077317
077317  )LINE
176000   %$--:5PIT                      % FOR SPLITTING AV LISTING.
176000   *PITST/
026000   @DEV (S-S-L)5P-P2-MON60:NPL
026000

026000   %==========================================================================
026000   %
026000   %       ( 5 )    N 5 0 0 M   ( MON 60)
026000   %
026000   %==========================================================================
026000
026000   *"8N500
"026000   %==========================================================================
026000   %       ( 5 )    P R E D E C L A R A T I O N S
026000   %
026000   INTEGER 5SPASSTYPE=?
026000   INTEGER 5CSTCK=?
026000   INTEGER 5BCHFLAG=?
026000   INTEGER 5PASSTYPE=?
026000   INTEGER 5TTIFIELD=?
026000
026000   INTEGER ENDBUFFER=?
026000   INTEGER 5LREG=?
026000   INTEGER 5RPRONO=?
026000   INTEGER 55DBFLAG=?
026000   INTEGER SGBRKADR=?
026000
026000   SUBR FROMESC,5OKRET,EEILPAR,INZERET
026000   RBUS
026000
026000
026000   %========================================================
026000   % PREDECLARATIONS:
026000   %
026000   INTEGER ARRAY FUNCS=?
026000   INTEGER ARRAY 5IFUNCS=?
026000
026000
026000
026000          SYMBOL ENAUTHORISED=  25        % YOU ARE NOT AUTHORIZED TO DO THIS
026000   %%     SYMBOL EC174=        174        % ILLEGAL PARAMETER
026000   %%     SYMBOL N5TIMOUT=      2000      % N500 TIME-OUT
026000   %%     SYMBOL ILMICFUNC=     2001      % ILLEGAL MICRO FUNCTION
026000   %%     SYMBOL ILN5STATUS=    2002      % ILLEGAL STATUS IN MESSAGE TO N-500
026000   %%     SYMBOL N5DMAERROR=    2003      % NORD-500 DMA ERROR
026000          SYMBOL ILSTOP=        2004      % ILLEGAL STOP REASON
026000   %%     SYMBOL ILTRAP=        2005      % UNKNOWN TRAP
026000          SYMBOL SPCTRAP=       2006      % MOR/PF/PN/HE/ME/CP/MSR TRAP
026000          SYMBOL EILREG=        2007      % ILLEGAL REGISTER NUMBER
026000
026000          SYMBOL EILFUNC=       2011      % ILLEGAL FUNCTION CODE IN MON 60
026000          SYMBOL EILSEG=        2012      % ILLEGAL SEGMENT NUMBER IN LOAD
026000          SYMBOL EILFILN=       2013      % ILLEGAL FILE NUMBER IN LOAD
026000          SYMBOL EFATAL=        2014      % FATAL ERROR FROM PIT-0
026000          SYMBOL ESPRES=        2015      % N500 RESERVED FOR SPECIAL USE
026000          SYMBOL ENOPROC=       2016      % NO N500 PROCESS AVAILABLE
026000          SYMBOL ENODBUF=       2017      % NO BUFFER AVAILABLE FOR DATA TRANSFER
026000          SYMBOL EBIGBUF=       2020      % TOO BIG BYTE COUNT IN DATA TRANSFER
026000          SYMBOL ETMSHARED=     2021      % TOO MANY SHARED AREA
026000          SYMBOL ENORTC=        2022      % NO RT-COMMON DEFINED
026000          SYMBOL ESGFNCONT=     2023      % SHARED SEGMENT FIXED, BUT NOT CONTIGUOUSLY
026000          SYMBOL ESGWRADD=      2024      % SHARED SEGMENT FIXED IN WRONG ADDRESS
026000          SYMBOL ESHOUTSIDE=    2025      % SHARED AREA OUTSIDE N500 MEMORY
026000          SYMBOL EPSGBIG=       2026      % TOO BIG PROGRAM SEGMENT
026000          SYMBOL EDSGBIG=       2027      % TOO BIG DATA SEGMENT
026000          SYMBOL ENOPCOMMU=     2030      % NO PROCESS TO COMMUNICATE WITH
026000          SYMBOL ENOMEMORY=     2031      % NO MEMORY AVAILABLE FOR NORD 500
026000          SYMBOL ECSLOAD=       2032      % CONTROL STORE MUST BE LOADED
026000          SYMBOL EMDFCOM=       2033      % DEFINE-MEMORY-CONFIG. COMMAND IS REQUIRED
026000          SYMBOL EUSRON=        2034      % OTHER USER(S) ALREADY LOGGED ON N500
026000          SYMBOL ENSPRES=       2035      % N500 NOT RESERVED FOR SPECIAL USE
026000
026000
026000          SYMBOL SWADEF=        2040      % SWAP FILE ALREADY DEFINED
026000          SYMBOL NOCMASFILE=    2041      % SWAP FILE IS NOT CONTIGUOUS MASS STORAGE FILE
026000          SYMBOL SWFINUSE=      2042      % SWAP FILE IS IN USE
026000          SYMBOL SWFNFOUND=     2043      % SWAP FILE NOT FOUND
026000
026000          SYMBOL NSWFENTRY=     2045      % NO FREE SWAP FILE ENTRY
026000          SYMBOL NOMASSFILE=    2046      % NOT MASS STORAGE FILE
026000   %%     SYMBOL SWPFATAL=      2047      % FATAL ERROR FROM SWAPPER
026000          SYMBOL MEMNAVAILABLE= 2050      % MEMORY NOT AVAILABLE
026000          SYMBOL MICFATAL=      2051      % FATAL ERROR FROM MICRO-PROGRAM
026000          SYMBOL ENOCPU=        2052      % NO ND-500(0) CPU FOUND
026000          SYMBOL EZADNAVA=      2053      % N500 PAGE ZERO NOT AVAILABLE
026000          SYMBOL EIMDCONF=      2054      % ERROR IN MEMORY CONFIGURATION
026000          SYMBOL EHIUSED=       2055      % HISTOGRAM ALREADY IN USE
026000          SYMBOL EHNRESERVED=   2056      % HISTOGRAM NOT RESERVED BY YOU
026000          SYMBOL POWER=         2057      % POWER FAIL DETECTED IN NORD-500
026000   %%     SYMBOL N5IERROR=      2060      % NORD-500 INTERFACE ERROR
026000   %%     SYMBOL N5STOPPED=     2061      % NORD-500 STOPPED
026000          SYMBOL EPFDETECT=     2062      % POWER FAIL DETECTED IN LOADING CS.
026000          SYMBOL PFECSLOAD=     2063      % LOAD CS. AFTER POWER FAIL
026000          SYMBOL EPOWUP=        2064      % POWER UP
026000          SYMBOL EILSTYPE=      2065      % ILLEGAL LOGICAL SEGMENT TYPE IN PLACE
026000          SYMBOL ESWLOAD=       2066      % SWAPPER MUST BE PLACED
026000          SYMBOL EILPHSNO=      2067      % ILLEGAL PHYSICAL SEGMENT NUMBER
026000   %%     SYMBOL EPFINSWP=      2070      % PAGE FAULT IN SWAPPER
026000   %%     SYMBOL ESPTIMOUT=     2071      % TIMOUT, INPOSSIBLE TO TERMINATE N500
026000          SYMBOL EMPBREAK=      2072      % MICRO-PROGRAM BREAK REACHED
026000          SYMBOL ELOGNRESERVED= 2073      % LOGGING FACILITY NOT RESERVED BY YOU
026000          SYMBOL ELOGINUSE=     2074      % LOGGING FACILITY ALREADY RESERVED
026000          SYMBOL EN5BUFFR=      2075      % NO MEMORY AVAILABLE FOR N500 BUFFERS
026000
026000
026000          SYMBOL ENRACCESS=     2100      % NOT REQUIRED ACCESS TO THE SEGMENT
026000          SYMBOL ENIMPLEMENT=   2101      % FUNCTION NOT IMPLEMENTED
026000          SYMBOL ENAUSED=       2102      % NAME ALREADY USED
026000          SYMBOL EILOCS=        2103      % ERROR IN LOADING CONTROL STORE
026000          SYMBOL ETMFIXED=      2104      % TOO MANY FIXED MEMORY PARTS
026000          SYMBOL EDESWAP=       2105      % MASS STORAGE TRANSFER ERROR IN SWAPPING
026000          SYMBOL ETMS3FIXED=    2106      % TOO MANY SHARED SEGMENTS TO FIX
026000          SYMBOL EFUNRTP=       2136      % FUNCTION NOT ALLOWED FROM RT-PROGR.
026000   %%     SYMBOL EIRESPL=       2140      % ILLEGAL IN RESIDENT PLACE
026000   %%     SYMBOL ESCSTOP=       2142      % ESCAPE/BREAK TYPED
026000   %      SYMBOL ERCFIL=        2143      % NOT ALLOWED ON REMOTE OPENED FILE
026000
026000
026000   %      ERROR NUMBERS FOR ERRORS THAT PROGRAMS MAY GET
026000          SYMBOL E5NOPART=       1050      % NO SWAP-FILE PART AVAILABLE
026000          SYMBOL ENOSWSPACE=    1051      % SWAPPING SPACE NOT AVAILABLE
026000          SYMBOL NOPHSEG=       1052      % NO FREE PHYSICAL SEGMENT
026000          SYMBOL EROSEGMENT=    1053      % SEGMENT NOT MODIFYABLE
026000   %%     SYMBOL EILPROC=       1054      % ILLEGAL PROCESS NUMBER
026000   %%     SYMBOL SWDERR=        1055      % SWAP DEVICE ERROR
026000   %%     SYMBOL EPRMC=         1056      % PRIVILGED MONITOR CALL
026000          SYMBOL EILLSNO=       1057      % ILLEGAL LOGICAL SEGMENT NUMBER
026000          SYMBOL EPRNFOUND=     1060      % NO SUCH PROCESS
026000          SYMBOL EILADDR=       1061      % ILLEGAL ADDRESS
026000
026000
026000
026000   DISP 25; INTEGER S25; PSID
026000
026000   SYMBOL 5DFSIZE=50            % SIZE OF N500 DATAFIELD TO WRITE ONTO DATA SEG.
026000   SYMBOL COMAUTO=17            % COMMAND IN AUTO-MODE
026000   % SYMBOL BNSYVARIABLES=NSYVARIABLES+NSYVARIABLES              % REMOVED 880405 BTT
026000   SYMBOL NREGS=65              % NUMBER OF N500 REGISTERS
026000   SYMBOL PRSELSIZE=142         % PROCESS TABLE ELEMENT SIZE
026000   SYMBOL PHSELSIZE=61          % PHYSICAL SEGMENT TABLE ELEMENT SIZE
026000   SYMBOL 5PRSELSIZE=227        % N500 PROCESS TABLE ELEMENT SIZE
026000   SYMBOL 55SEGSIZE=44          % N500 SEGMENT TABLE SIZE
026000   SYMBOL DASEGSTART=166000     % START OF ND-500 DATASEGMENT
026000   SYMBOL DSEGSIZE=12000        % SIZE OF DATA SEGMENT
026000   %SYMBOL DSSYVARIABLES=176000+400-NSYVARIABLES % ST ADDR. OF "SYS-DEP"
026000                                               % REMOVED 880405 BTT
026000   SYMBOL FT500=DASEGSTART+2    % FLAG-WORD TO N500
026000   SYMBOL FF500=FT500+2         % FLAG-WORD FROM N500
026000   SYMBOL S500DF=FF500+2        % ADDRESS OF DATAFIELD-COPY ON DATA SEGMENT
026000   SYMBOL SBUFFER=S500DF+5DFSIZE % ADDR OF GENERAL DATA BUFFER
026000   SYMBOL 5COMPRIOR=            71        % ND-500 COMMUNICATION PRIORITY
026000   SYMBOL DFIX5DSPAGE=          177776    % ADDR OF "IOF-EXIT" ROUTINE TO EXECUTE WHEN FIXING THE SYS.MON'S STACK-WINDOW
026000   SYMBOL MXMPARTS=             16        % MAXIMUM MEMORY PARTS
026000
026000
026000   * 5LREG=DASEG
026000   * 5AREG=5LREG
026000   * FPT2E=40000+3              % ENTRY POINT AFTER STANDARD SEGMENT HEADER
026000   * SGBRK=DASEG+1
026000
026000
026000   %*******************************************************************************
026000   %
026000   %       ( 5 )    F U N C T I O N S  I N  M O N I T O R  C A L L  6 0
026000   %
026000   %*******************************************************************************
026000   SYMBOL RREG=                 0         % READ REGISTER
026000   SYMBOL WREG=                 1         % WRITE REGISTER
026000   SYMBOL PMREAD=               2         % READ PROGRAM MEMORY
026000   SYMBOL D5MREAD=              3         % READ DATA MEMORY
026000   SYMBOL PMWRITE=              4         % WRITE PROGRAM MEMORY
026000   SYMBOL DMWRITE=              5         % WRITE DATA MEMORY
026000   SYMBOL SEGLOAD=              6         % LOAD SEGMENT
026000   SYMBOL PLSWAPPER=            7         % PLACE SWAPPER
026000   SYMBOL RREGS=                10        % READ REGISTERS
026000   SYMBOL WREGS=                11        % WRITE REGISTERS
026000   SYMBOL PRSTART=              12        % START PROGRAM
026000   SYMBOL FILCON=               13        % CONNECT FILE
026000   SYMBOL FILCLO=               14        % CLOSE FILE
026000   SYMBOL N5RES=                15        % ALLOCATE NORD 500 PROCESS
026000   SYMBOL N5REL=                16        % RELEASE NORD 500 PROCESS
026000   SYMBOL FLIOP=                17        % LIST OPEN FILES
026000   SYMBOL TIMEUS=               20        % TIME USED
026000   SYMBOL WISON=                21        % WHO IS ON
026000   SYMBOL ERRFSET=              22        % SET ERRFLAG
026000   SYMBOL RCNTS=                23        % READ CONTROL STORE
026000   SYMBOL WCNTS=                24        % WRITE CONTROL STORE
026000   SYMBOL MICPSTART=            25        % MICRO PROGRAM START
026000   SYMBOL DMEXA=                26        % DATA MEMORY EXAMINE
026000   SYMBOL DMDEP=                27        % DATA MEMORY DEPOSIT
026000   SYMBOL PMEXA=                30        % PROGRAM MEMORY EXAMINE
026000   SYMBOL PMDEP=                31        % PROGRAM MEMORY DEPOSIT
026000   SYMBOL DAMR=                 32        % ABSOLUTE DATA MEMORY READ
026000   SYMBOL DAMW=                 33        % ABSOLUTE DATA MEMORY WRITE
026000   SYMBOL STOPMIC=              34        % STOP MICRO PROGRAM
026000   SYMBOL FMCLEAR=              35        % MASTER CLEAR
026000   SYMBOL ALLPSEG=              36        % ALLOCATE PROGRAM SEGMENT
026000   SYMBOL CSLOAD=               37        % LOAD CONTROL STORE
026000   SYMBOL MEMDEF=               40        % DEFINE MEMORY CONFIGURATION
026000   SYMBOL RSTATU=               41        % READ N500 AND N100 COMMUNICATION STATUS
026000   SYMBOL ABREL=                42        % ABORT CURRENT PROCESS AND ND-100 PROGR.
026000   SYMBOL N5SRS=                43        % RESERVE N500 FOR SPECIAL USE
026000   SYMBOL N5SRL=                44        % RELEASE N500 FROM SPECIAL USE
026000   SYMBOL SCPLOOP=              45        % SCOPE-LOOP
026000   SYMBOL DEFSWAP=              46        % DEFINE-SWAP-FILE
026000   SYMBOL DELSWAP=              47        % DELETE-SWAP-FILE
026000   SYMBOL TSTFUNC=              50        % TEST-FUNCTION
026000   SYMBOL RIREG=                51        % READ INTERFACE (COMMUNICATION) IODATUT REG.
026000   SYMBOL GIVPAGES=             52        % GIVE N500 SWAPPING PAGES
026000   SYMBOL TAKPAGES=             53        % TAKE N500 SWAPPING PAGES
026000   SYMBOL STSWAPPER=            54        % START SWAPPER PROCESS
026000   SYMBOL SPLACE=               55        % START PLACE
026000   SYMBOL EPLACE=               56        % END PLACE
026000   SYMBOL RMVERS=               57        % READ MICROPROGRAM VERSION
026000   SYMBOL LIMEM=                60        % LIST MEMORY CONFIGURATION
026000   SYMBOL MRESSPES=             61        % RESERVE N500 MEMORY FOR SPECIAL USE
026000   SYMBOL 5DEFHIST=             62        % DEFINE HISTOGRAM
026000   SYMBOL 5STAHIST=             63        % START HISTOGRAM
026000   SYMBOL 5STOHIST=             64        % STOP HISTOGRAM
026000   SYMBOL REAHIST=              65        % READ HISTOGRAM
026000   SYMBOL RELHIST=              66        % RELEASE HISTOGRAM
026000   SYMBOL SPRTE=                67        % SEARCH FOR PROCESS ENTRY ON NAME SEG
026000   SYMBOL GPRTE=                70        % READ PROCESS ENTRY FROM NAME SEG
026000   SYMBOL SSGTE=                71        % SEARCH FOR PH. SEG. ENTRY ON NAME SEG
026000   SYMBOL GSGTE=                72        % READ PH. SEG. ENTRY FROM NAME SEG
026000   SYMBOL RPHSG=                73        % READ PHYSICAL SEGMENT
026000   SYMBOL SPRNM=                74        % SET PROCESS NAME OF CURRENT PROCESS
026000   SYMBOL TSTUSER=              75        % TEST FOR USER SYSTEM
026000   SYMBOL TOSWP=                76        % SEND MESSAGE TO SWAPPER
026000   SYMBOL RMESSAGE=             77        % READ LAST MESSAGE
026000   SYMBOL 5RFLAG=               100       % READ FLAG-INFO FROM N500
026000   SYMBOL 5WFLAG=               101       % WRITE FLAG-INFO TO N500
026000   SYMBOL FORGET=               102       % RELEASE N500 SYSTEM FROM SINTRAN III
026000   SYMBOL RSYSP=                103       % READ SYSTEM PARAMETERS
026000   SYMBOL WSYSP=                104       % WRITE SYSTEM PARAMETERS
026000   SYMBOL S1PRIOR=              105       % SET PRIORITY OF BACKGROUND PROGRAM
026000   SYMBOL LINKTO=               106       % LINK TO PROCESS
026000   SYMBOL MICBRK=               107       % MICRO PROGRAM BREAK
026000   SYMBOL WPHSG=                110       % WRITE INTO PHYSICAL SEGMENT
026000   SYMBOL 5STALOG=              111       % START PROCESS LOG
026000   SYMBOL 5STOLOG=              112       % STOP LOGGING
026000   SYMBOL PRILOG=               113       % PRINT LOGG-INFO
026000   SYMBOL RELLOG=               114       % RELEASE LOGGING
026000   SYMBOL STLAPROC=             115       % START LOGG ALL ACTIVE PROCESSES
026000   SYMBOL XN5REL=               116       % LOGOUT OWN PROCESS
026000   SYMBOL PRSTOP=               117       % ABORT PROCESS
026000   SYMBOL SOUTFIL=              120       % SET PRINT DEVICE
026000   SYMBOL RSWPDATA=             121       % READ FROM SWAPPER'S DATA MEMORY
026000   SYMBOL LOGOFF=               122       % LOGG OFF PROCESS
026000   SYMBOL MRELSPES=             123       % RELEASE ND-500 MEMORY
026000   SYMBOL STAMLOG=              124       % RESERVE AND START MONCALL LOGG
026000   SYMBOL PRIMLOG=              125       % PRINT MONCALL LOGG
026000   SYMBOL STOMLOG=              126       % STOP AND RELEASE MONCALL LOGG
026000   SYMBOL DFSYDOM=              127       % DEFINE SYSTEM-DOMAIN
026000   SYMBOL SFSYDOM=              130       % SEARCH FOR SYSTEM-DOMAIN
026000   SYMBOL DLSYDOM=              131       % DELETE SYSTEM-DOMAIN
026000   SYMBOL LISYDOM=              132       % LIST "SYSTEM-DOMAINS"
026000   SYMBOL LI5EXQU=              133       % LIST ND-500 EXECUTION QUEUE
026000   SYMBOL PLDEB=                134       % PLACE DEBUGGER
026000   SYMBOL ABLOG=                135       % LOGG OFF PROCESS AND ABORT PROGRAM
026000   SYMBOL PRACTIVATE=           136       % ACTIVATE STOPPED PROCESS
026000   SYMBOL STENPLACE=            140       % START RESIDENT-PLACE
026000   SYMBOL S5BLSIZE=             141       % SET BLOCK SIZE OF A FILE
026000   SYMBOL S3CPNT=               142       % VALUE OF BYTE POINTER IN COMMAND BUFFER
026000   SYMBOL MO5RT=                143       % ACTIVATE ND-500 PROC. OR ND-100 PROG.
026000   SYMBOL CHACPU=               144       % CHANGE CPU
026000   SYMBOL SSTDOM=               145       % START STANDARD DOMAIN FROM COMMAND SEG.
026000   % FUNCTION CODE 146 IS USED IN DRIVER/SYSTEM MONITOR
026000   SYMBOL N5S3REL=              147       % ESCAPE TYPED WHEN MONITOR STARTED FROM S3.OPCOM.
026000   SYMBOL LI5TMQ=               150       % LIST ND-500 TIME-QUEUE
026000   SYMBOL 5DBUGSW=              154       % DEBUG SWAPPER <ON/OFF>
026000   %SYMBOL STSELFTST=           155       % START SAMSON SELFTEST
026000   %SYMBOL WRSYSINFO=           156       % NEW 'VERSION'
026000   %SYMBOL MONACCP=             157       % ACCP-INTERFACE
026000   %SYMBOL NSGLOAD=             160       % PLACE SEGMENT WITH NEW DOMAIN FORMAT
026000   %SYMBOL 5NDFSYDOM=           161       % DEFINE STANDARD DOMSIN WITH NEW DOMAIN FORMAT
026000   %SYMBOL INITRACE=            162       % TRACE MICROPROGRAM FUNCTION: INITIALIZE TRACE BUFFER
026000   %SYMBOL CLRTRACE=            163       % TRACE MICROPROGRAM FUNCTION: CLEAR TRACE BUFFER
026000   %SYMBOL ARMTRACE=            164       % TRACE MICROPROGRAM FUNCTION: ARM TRACE
026000   %SYMBOL DISARMTRACE=         165       % TRACE MICROPROGRAM FUNCTION: DISARM TRACE
026000   %SYMBOL DUMPTRACE=           166       % TRACE MICROPROGRAM FUNCTION: DUMP TRACE BUFFER
026000   %SYMBOL CLRADR=              167       % TRACE MICROPROGRAM FUNCTION: CLEAR TRACE ADDRESS
026000   %SYMBOL RCPUTYPE=            170       % READ CPU TYPE AND VERSION (CONTROL STORE IS NOT LOADED)
026000   %SYMBOL SCACHEMODE=          171       % SET CACHE MODE (SAMSON ONLY)
026000   %SYMBOL RSRF=                172       % READ HW SCRATCH REGISTERS (SAMSON ONLY)
026000   %SYMBOL SCPUSTATUS=          173       % SET CPU STATUS (AVAILABLE/UNAVAILABLE/AUTOMATIC/NON AUTOMATIC ALLOCATION)
026000   %SYMBOL SETDIT=              177       % SET CURRENT DOMAIN NUMBER
026000
026000   SYMBOL FUNCMAX=177                     % FREE FOR PATCHING FUNC.CODE 155-167
026000
026000
026000   %======================================================================
026000   %       ( 5 )    P A R A N T
026000   %
026000   % MON60 FUNCTION DESCRIPTION.
026000   % (1 BYTE FOR EACH FUNCTION; FUNCTION CODE IS INDEX IN PARANT)
026000   %
026000   %----------------------------------------------------------------------
026000   %  CHARACTERISTICS OF MON-60 FUNCTIONS  (BITS IN PARANT)
026000   %      BIT 0-2 ARE NUMBER OF PARAMETERS OF EACH FUNCTION
026000   SYMBOL RTPLEGAL=4            % COMMAND ALLOWED FROM RT-PROGRAMS
026000   SYMBOL BSPRES=5              % SYSTEM MUST BE RESERVED FOR SPECIAL USE
026000   SYMBOL COMPROT=6             % COMMAND ONLY ALLOWED
026000                                % WHEN SYSTEM RESERVED FOR SPECIAL USE BY YOU
026000                                % WHEN USER SYSTEM CALLS
026000                                % WHEN AUTO-COMMAND MODE
026000   SYMBOL COMSPEC=7             % FUNCTION LEGAL WITHOUT ANY PROCESS DESCR. RESERVED
026000   %----------------------------------------------------------------------
026000
026000   @ICR
026000   INTEGER ARRAY PARANT:=(
026000   % 0   1    2   3   4   5   6   7   0   1   2   3   4   5   6   7
026000     22\22,   24\24,  23\23,  35\171, 21\21,  23\25,  21\32,  20\1,   % 000 - 017
026010     11\12,    2\173,173\171, 22\22,  22\22, 124\123,170\170,170\173, % 020 - 037
026020    173\33,    0\121,120\152,131\131, 14\131,131\131,170\30,  31\31,  % 040 - 057
026030     31\132,  23\20,  20\21,  20\132, 23\133, 33\135, 31\10,  31\22,  % 060 - 077
026040     22\22,  130\131,131\34, 111\112,134\101,100\102,100\101, 20\121, % 100 - 117
026050     11\124, 121\130, 21\21,  21\111, 32\111, 10\1,   32\331,131\0,   % 120 - 137
026060    171\22,   11\321, 21\31,   0\0,    1\0,    0\0,  101\160, 21\173, % 140 - 157
026070     34\111, 124\120,120\120,122\122, 22\122, 23\324,  0\0,    0\021);% 160 - 177
026100   @CR;
026100
026100   %========================================================================
026100   %       ( 5 )    5 T O E R S
026100   %
026100   % SUBROUTINE TO CALL ERROR LOGGER ROUTINE 9FLER
026100   %
026100   % ENTRY:     A=MESSAGE SIZE IN NUMBER OF WORDS
026100   %            X=ADDRESS OF PARAMTER LIST
026100   % EXIT:      OK
026100   %
026100   SUBR 5TOERS
026100   INTEGER POINTER LREG
026101   INTEGER 9FLRMSG=?,9FLRSIZE=?
026101
026101   5TOERS: *IOF
026102         A=:9FLRSIZE; X=:9FLRMSG
026104         A:=L=:"LREG"
026106         CALL 9FLER
026107   INTEGER 9FLRMSG
026110   INTEGER 9FLRSIZE
026111         *ION
026112         GO LREG
026113   RBUS
026114
026114
026114
026114   %========================================================================
026114   %       ( 5 )    D O H O L D
026114   %
026114   % SUBROUTINE TO EXECUTE HOLD
026114   %
026114   % ENTRY:     L.S0=NUMBER OF TIME UNITS
026114   %            L.S1=TIME UNIT
026114   % EXIT:      OK
026114   %
026114   SUBR DOHOLD
026114   INTEGER 5TM,5TMUNIT
026116   INTEGER ARRAY PM104:=(5TM,5TMUNIT)
026120   INTEGER LREG,XREG
026122
026122   DOHOLD:  A:=L=:LREG; X=:XREG
026125            "A5PIT"=:D; CALL DALTON
026130            0=:5TM=:5TMUNIT; "PM104"; *MON 2HOLD
026134            LREG.S0=:5TM; X.S1=:5TMUNIT; "PM104"; *MON 2HOLD
026143            CALL ALTOFF
026144            X:=XREG; LREG+2=:L; EXIT
026151   RBUS
026155
026155
026155   %========================================================================
026155   %       ( 5 )    5 R E S W O R K A      5 R E L W O R K A
026155   %
026155   % SUBROUTINE TO RESERVE/RELEASE WORKING AREA ON SYSTEM SEGMENT IF
026155   % FOREGROUND PROGRAM
026155   %
026155   % ENTRY:     NONE
026155   % EXIT:      ERROR RETURN
026155   % EXIT AD1:  OK RETURN
026155   %
026155   SUBR 5RESWORKA,5RELWORKA
026155
026155   INTEGER POINTER 5RLREG
026156   5RESWORKA:
026156          IF BACKGROUND=0 THEN
026160             A:=L=:"5RLREG"
026162             XSEMS(7)
026164             A=:B
026165   NYTRY:    MLEV; *MCL PIE
026167             X:=RTREF; CALL BRESERVE
026171             IF A<0 THEN
026172                CALL FREXQU; CALL TOWQU; CALL ANTIJAMMER
026175                "STUPR"; *IRW MLEVB DP
026177                MLEV; *MST PIE; MST PID
026202                GO NYTRY
026203             FI; MLEV; *MST PIE
026205             "N500DF"=:B; GO 5RLREG
026210          FI; EXIT
026211
026211   5RELWORKA:
026211          IF BACKGROUND=0 THEN
026213             A:=L=:"5RLREG"
026215             XSEMS(7)
026217             A=:B
026220             IF X:=RTREF=RTRES THEN
026224                *IOF
026225                CALL BRELEASE
026226                *ION
026227             FI
026227             "N500DF"=:B; GO 5RLREG
026232          FI; EXIT
026233   RBUS
026245
026245
026245   %==============================================================================
026245   %       ( 5 )    I N 5 F U D M A
026245   %
026245   % LOCAL SUBROUTINE TO INITIALIZE THE FAST-UDMA-OPTION
026245   %
026245   SUBR IN5FUDMA
026245   INTEGER INZRTP,C5FUDMA
026247   INTEGER 5FUDLREG
026250   IN5FUDMA:
026250   *"8N500 8F5UD -8MTRA
"026250             A:=L=:5FUDLREG
026252             X:="9FPUD"; 5FUDMA-=:C5FUDMA
026256             DO WHILE X<<="9LPUD"-5RTSIZE AND C5FUDMA><0
026264                X.STATUS BZERO 5RTOFF=:X.STATUS
026267                "A5PIT"=:D; CALL DALTON            % SET 5PIT AS ALT.PIT
026272                X=:INZRTP; A:="INZPRT"; *MON 2RT   % START UDMA-TRANSFER PROGRAM
026275                CALL ALTOFF                        % SET DPIT AS ALT.PIT
026276                X+5RTSIZE; MIN C5FUDMA; 0/\0
026301             OD
026302             5FUDLREG=:L
026304   *"8N500 8F5UD -8MTRA
"026304           EXIT
026305   RBUS
026314
026314   @LIB FALSE
026314   %============================================================
026314   %       ( 5 )    R L M B P A G E S
026314   %
026314   % LOCAL SUBROUTINE TO LINK BUFFER PAGES TO FREELIST
026314   %
026314   % ENTRY:     B=N500DF
026314   %            A=FIRST PAGE IN LINKED LIST
026314   % EXIT:      ERROR RETURN
026314   % EXIT+1:    A=NUMBER OF PAGES RELEASED
026314   %
026314   SUBR RLMBPAGES
026314   INTEGER IZPAGLINK,CURSGSTAT,NPG
026317   INTEGER POINTER RLMBLREG
026320
026320   RLMBPAGES:
026320          IF A=0 THEN EXITA FI
026322          A=:T; MLEV; *MCL PIE                                %%%%
026325          A:=L=:"RLMBLREG"
026327          T SH 2=:IZPAGLINK; 0=:NPG                           %%%% USES 5PGLINK AS SAVE AREA
026332          X:=SEGSTART+5SEGSIZE; T:=SEGTBANK; *SGSTA@3 LDATX   %%%% GETS SEGMENT STATUS WORD OF SEGMENT NO.1
026336          A=:CURSGSTAT; X:=IZPAGLINK; T:=CORMBANK             %%%%
026341          7=:D                                                %%%%
026343          DO                                                  %%%% BUILDS PREVIOUS LINK
026343             A:=D; *PREVI@3 STATX                             %%%% PREVIOUS IN FIRST ELEMENT IS SET TO INDICATE SEGMENT NO.1
026345             CURSGSTAT; *PROTE@3 STATX                        %%%% PROTECT WORD IS SET TO SEGMENT STATUS OF SEGMENT NO.1
026347             A:=X SHZ -2=:D; CALL ENPCACHE; 0/\0              %%%%
026354             X=:D; *PAGLI@3 LDXTX                             %%%% D-REG POINTS TO LAST ELEMENT ON EXIT FROM LOOP
026356             MIN NPG; 0/\0                                    %%%%
026360          WHILE X><0                                          %%%% END OF PAGELINK?
026361          OD                                                  %%%%
026362          X:=SEGSTART+5SEGSIZE; T:=SEGTBANK; *BPAGL@3 LDXTX   %%%% GETS FIRST PAGE IN PAGELINK OF SEGMENT NO.1
026366          T:=CORMBANK; A:=D                                   %%%%
026370          IF X><0 THEN                                        %%%% IF PAGES ALREADY LINKED TO SEGMENT NO.1
026371            *PREVI@3 STATX                                    %%%%    SET FIRST PAGE IN EXISTING LIST TO POINT BACK
026372          FI                                                  %%%%    ON LAST PAGE IN LIST TO BE INSERTED
026372          A:=:X; *PAGLI@3 STATX                               %%%% LET LAST PAGE IN LIST TO BE INSERTED TO POINT
026374          IZPAGLINK; X:=SEGSTART+5SEGSIZE                     %%%%    PAGE IN EXISTING LIST
026377          T:=SEGTBANK; *BPAGL@3 STATX                         %%%% LET PAGELINK OF SEGMENT NO.1 POINT TO FIRST ELEMENT
026401          *SEGLI@3 LDATX                                      %%%%
026402          IF A=0 THEN                                         %%%% IF SEGMENT NO.1 IS NOT IN SEGMENT LINK
026403             "1INSEGLINK"; *IOF; IRW SLEVB DP                 %%%%    CALL SEGMENT ADM.ROUTINE TO INSERT IT
026406             SLEV; *MST PID; ION                              %%%%
026411          FI; MLEV; *MST PIE                                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
026413          NPG; MIN "RLMBLREG"; GO RLMBLREG
026416   RBUS
026423
026423
026423
026423   %============================================================
026423   %       ( 5 )    R E L M B P A G E S
026423   %
026423   % LOCAL SUBROUTINE TO RELEASE BOTH ALL BUFFERS
026423   %
026423   % ENTRY:     B=N500DF
026423   % EXIT:      ERROR RETURN
026423   % EXIT+1:    OK RETURN
026423   %
026423   SUBR RELMBPAGES
026423
026423   INTEGER POINTER RLMBLREG
026424
026424   RELMBPAGES: A:=L=:"RLMBLREG"
026426          5FPMAILBOX; CALL RLMBPAGES; 0/\0
026431          A-+5NPAGES=:5NPAGES; 0=:5FPMAILBOX
026435          5FBUM60; CALL RLMBPAGES; 0/\0
026440          A-+5NPAGES=:5NPAGES; 0=:5FBUM60=:5BUBANK=:5BUSTART
026446          5FPACCPBUFF; CALL RLMBPAGES; 0/\0
026451          A-+5NPAGES=:5NPAGES; 0=:5FPACCPBUFF
026455          5FPHWBUFF; CALL RLMBPAGES; 0/\0
026460          A-+5NPAGES=:5NPAGES; 0=:5FPHWBUFF
026464          5FPFUDMA; CALL RLMBPAGES; 0/\0
026467          A-+5NPAGES=:5NPAGES; 0=:5FPFUDMA
026473          MIN "RLMBLREG"; GO RLMBLREG
026475   RBUS
026502
026502
026502   %============================================================
026502   %       ( 5 )    C H M E M D E F
026502   %
026502   % LOCAL SUBROUTINE TO SET UP MEMORY CONFIGURATION
026502   %
026502   % ENTRY:     B=N500DF
026502   % EXIT:      ERROR IN SETTING UP MEMORY CONFIGURATION
026502   % EXIT+1:    MEMORY CONFIGURATION SET UP
026502   %
026502   SUBR CHMEMDEF
026502
026502   INTEGER POINTER CHMLREG=?
026502
026502   CHMEMDEF:
026502          A:=L=:"CHMLREG"
026504          IF 5FUNCTION><MEMDEF THEN
026510             IF ADRZERO=-1 THEN
026514                IF 5FUNCTION=N5RES THEN
026520                   CALL 5RESWORKA
026521                   IF BACKGROUND=0 THEN T:="RTPWORKA" ELSE T:="WORKA" FI
026526                   "VERSION"=:D; 5=:L; *MOVNA
026533                   T:=5P2; X:=5; A=:D; OLDPAG; K:=1; CALL MOVUS
026541                   CALL 5RELWORKA
026542                ELSE IF A=N5REL THEN
026546                   GO 5OKRET
026547                FI FI
026547                EMDFCOM; GO CHMLREG
026551             FI
026551             EXITA
026552          FI; GO CHM1; *)FILL
026564
026564   INTEGER MPARTS               % NUMBER OF MEMORY PARTS
026565   INTEGER CINDX
026566   INTEGER ARRAY POINTER PAMEMTABLE
026567   DOUBLE  ARRAY POINTER DPWORKA
026570   INTEGER TYPADDR
026571   INTEGER CMSTART
026572   INTEGER MXADDR
026573   INTEGER POINTER CHMLREG
026574
026574   CHM1:  CALL XTUSON; GO CHM2
026576          CALL ESCOFF
026577          *IOF
026600          "RS5CPU"; *IRW LV12B DP
026602          LV12;     *MST PID
026604          *ION
026605          X:="S5CPUDF"
026606          DO WHILE X<<="E5CPUDF"
026611             A:=-1=:X.MAIL1LINK=:X.MAILINK
026614             X+5CPUDFSZ
026615          OD
026616          "5D11"+B=:D; X:=ZAREG; OLDPAGE; X+1=:B; T:=3; CALL GND5PAR
026627          "N500DF"=:B
026631          IF 5D22>MXMPARTS GO CHMEEILPAR
026635          A=:MPARTS
026636          CALL 5RESWORKA
026637          IF BACKGROUND=0 THEN T:="RTPWORKA" ELSE T:="WORKA" FI
026644          T=:"DPWORKA"
026645          5P3=:D; 5D22 SH 1=:X; OLDPAG; K:="0"; CALL MOVUS
026655          "AMEMTABLE"+B=:"PAMEMTABLE"; A+"TYPMTAB-AMEMTABLE"=:TYPADDR
026662          0=:CINDX=:CMSTART
026664          FOR CINDX DO WHILE CINDX<MPARTS SH 1
026671             A=:T SHZ -1 =:X; CMSTART=:PAMEMTABLE(X)
026676             X:=:T; DPWORKA(X); A+CMSTART=:CMSTART
026702             T=:X:=TYPADDR; A:=D; *SBYT
026706             MIN CINDX
026707          OD; X+1; CMSTART=:PAMEMTABLE(X)
026714          T:=TYPADDR; A:=0; *SBYT
026717          X+1
026720          FOR X TO MXMPARTS-1 DO
026724             0=:PAMEMTABLE(X); T:=TYPADDR; A:=0; *SBYT
026730          OD
026732          CALL 5RELWORKA
026733          5D12=:ADRZERO
026735          CCPUDF.5INITFLAG BZERO BMDEFOK=:X.5INITFLAG
026741          SYSINITFLAG BZERO BMDEFOK=:SYSINITFLAG
026744          CALL RELMBPAGES; 0/\0
026746          5MSINIT BZERO 5ALBUF BZERO 5INBUF=:5MSINIT
026752          MIN "CHMLREG"
026753   CHM2:  CALL ESCON
026754          GO CHMLREG
026755   CHMEEIPAR:
026755          CALL ESCON; GO EEILPAR
026757   RBUS
027004
027004
027004   %============================================================
027004   %            I N Z 5 0 0
027004   %
027004   % LOCAL SUBROUTINE TO INITIALIZE THE ND-500 SYSTEM.
027004   % CALLED WITH MLEV DISABLED AND RETURN WITH MLEV DISABLED, BUT
027004   % MLEV IS ENABLED IN THIS SUBROUTINE TO EXECUTE MONITOR CALLS.
027004   %
027004   % ENTRY:     B=N500DF
027004   % EXIT:      ERROR IN INITIALIZING ND-500
027004   % EXIT+1:    ND-500 INITIALIZED
027004   %
027004   SUBR INZ500,INZERET
027004
027004   INTEGER CNP=?
027004   INTEGER POINTER INZ5LREG=?
027004
027004   INZ500:
027004           A:=L=:"INZ5LREG"
027006           MLEV; *MST PIE
027010           IF 5MSINIT NBIT 5CHALIVE THEN
027013              CALL 5CONOMD                            % On return A-reg is number of Samson CPUs
027014              5MSINIT BONE 5CHALIVE=:5MSINIT
027017           FI
027017           IF N5CPU=0 THEN ENOCPU; GO FAR INZRET FI
027023           CALL CHMEMDEF; GO FAR INZRET
027025           IF 5MSINIT BIT 5ALBUF GO FAR INZ2
027030           IF NSAMSON><0 THEN
027032              MAXOCTBUF+1 SH -1 + MAXACCPBUFF+2000 SH -12
027040              A*NCPU; CALL 5GBUFF; GO FAR 0INZERET
027043              A=:5FPACCPBUF
027044              2*NCPU; CALL 5GBUFF; GO FAR 0INZERET
027050              A=:5FPHWBUF
027051           FI
027051           % - Allocate buffer for Nd500 message blocks
027051           X:=NCPU+1                                          % One cpu df per cpu + one global df
027053           MX5PROCS SH 1+177 SHZ -7; X+A+A                    %   + Comm. + Swap-wait fifo buffers
027061           2000=:D; A:=0; T:=55MESSIZE; *RDIV ST              % Number of messages per page
027066           A=:T; MX5PROCS+NCPU+X+5=:D; A:=0; *RDIV ST         % Number of pages for all messages
027076           IF D><0 THEN A+1 FI; A=:5NPMAILBOX                 %   + Mailboxes
027102           CALL 5GBUFF; GO FAR 0INZERET
027104           A=:5FPMAILBOX
027105           % - Allocated Mon60-buffers
027105           MX5PROCS+1=:5NPM60BUF
027110           CALL 5XGBUFF; GO FAR 0INZERET
027112           A=:5FBUM60=:D; A:=0; AD SH 12=:DBUSTART
027117   *"8N500 8F5UD
"027117           % - Allocate buffers for Fast UDMA
027117           MX5PROCS*"MFANT*MFSIZE+MFNCP"                      % COMPUTE REQUIRED MEMORY AREA FOR ND-500 FAST UDMA OPTION TABLES
027121           D:=0; AD SHZ -12; IF D><0 THEN A+1 FI              % A=NUMBER OF PAGES REQUIRED
027126           A=:CNP; CALL 5GBUFF; GO INZERET
027131           A=:5FPFUDMA                                        % SAVE FIRST PAGE REF. IN ALLOCATED PAGE LIST
027132           A=:D:=CNP+5NPAGES=:5NPAGES
027136           A:=0; AD SH 12=:D5FXBNK                            % ADDR OF FIX-INFO TABLE.
027141           MX5PROCS*"MFANT*MFSIZE"+D=:5DSPS                   % ADDR OF CAPABILITY TABLE.
027145   *"8N500
"027145           GO INZ1; *)FILL
027201
027201   INTEGER POINTER INZ5LREG
027202   INTEGER INZRTP,CNP
027204   INTEGER INZPRT:=INZRTP
027205
027205   INZ1:
027205           5MSINIT BONE 5ALBUF=:5MSINIT
027210           IF NPHSEGS>>5000 THEN                              % 5000B PHYS.SEGS ARE MAX FOR SYS.MON.
027214              IF MX5PROCS*12>>T THEN A:=T FI                  % DEFAULT MAX IS 10 SEGS PER PROC.
027221              A=:NPHSEGS
027222           FI
027222   INZ2:   IF 5MSINIT NBIT 5INBUF THEN
027225              CALL MSINIT; 5MSINIT BONE 5INBUF=:5MSINIT       % SETUP THE ND-500 MESSAGE BUFFERS
027231              "S5CPUDF"=:NCCPUDF                                 % Initialize "last CPU logged in on"
027233           FI
027233           IF 5MSINIT NBIT 5RTSTART THEN
027236              CALL IN5FUDMA                                   % INITIALIZE FAST-UDMA-OPTION
027237              "A5PIT"=:D; CALL DALTON
027242              "5SWAP"=:INZRTP; A:="INZPRT"; *MON 2RT
027246              CALL ALTOFF
027247              5MSINIT BONE 5RTSTART=:5MSINIT
027252           FI
027252           MIN "INZ5LREG"                                     % OK, SKIP RETURN
027253   INZRET: A=:T; MLEV; *MCL PIE
027256           A:=T; GO INZ5LREG
027260
027260   INZERET: CALL RELMBPAGES; 0/\0                             % RELEASE ALL MEMORY RESERVED FOR ND-500 BUFFERS
027262            5MSINIT BZERO 5ALBUF BZERO 5INBUF=:5MSINIT
027266   0INZERET: EN5BUFFR; GO INZRET
027270   RBUS
027306
027306   %=====================================================================
027306   %      ( 5 )     R E S C P U
027306   %
027306   % SUBROUTINE TO RESERVE CPU FOR SPECIAL USE
027306   % MUST BE CALLED IN IOF WITH GENERAL N5000 SEMAPHORE LOCKED!!!
027306   %
027306   % ENTRY:     B=N500DF
027306   %            X=CPU DF
027306   % EXIT:      ERROR
027306   % EXIT+1:    OK
027306   %
027306   SUBR RESCPU
027306
027306   RESCPU: X=:D
027307           RTREF=:D.SPREF
027312           X:=X.MAILINK; T:=5MBBANK; A:=0 BONE CPRES; *AAX X5CPF; STATX
027320           D.CPUNO; T:=5MBBANK; X:=5PRDESCR.MESSBUF
027325           *AAX 5CPUN; STATX; AAX 5MSFL-5CPUN; LDATX
027331           *5CPUB@3 BLDA DA; 5SCPU@3 BSTA DA
027333           A BONE 5CPUBOUND; *STATX
027335           EXITA
027336   RBUS
027340
027340
027340   %=====================================================================
027340   %      ( 5 )     R E L C P U
027340   %
027340   % SUBROUTINE TO RELEASE CPU FOR SPECIAL USE
027340   %
027340   % ENTRY:     B=N500DF
027340   %            X=CPU DF
027340   % EXIT:      OK
027340   %
027340   SUBR RELCPU
027340   RELCPU: 0=:X.SPREF; X=:D
027342           IF X.CPUAVAILABLE NBIT 5EXCLUDE THEN
027345              X:=X.MAILINK; T:=5MBBANK; *AAX X5CPF; LDATX
027351              A BZERO CPRES; *STATX
027353           FI
027353           *IOF
027354           T:=D.5INITFLAG BZERO BRESPLACE=:X.5INITFLAG
027360           T:=5MBBANK; X:=5PRDESCR.MESSBUF
027363           *AAX 5MSFL; LDATX; 5SCPU@3 BLDA DA; 5CPUB@3 BSTA DA
027367           A BZERO 5SCPUBOUND; *STATX
027371           *ION
027372           EXIT
027373   RBUS
027374
027374   %=====================================================================
027374   %      ( 5 )     R L H I L O G
027374   %
027374   % RELEASE HISTOGRAM LOG
027374   %
027374   % ENTRY:     NONE
027374   % EXIT:      OK
027374   %
027374   SUBR RLHILOG
027374   INTEGER POINTER RLHLREG
027375
027375   RLHILOG:
027375          A:=L=:"RLHLREG"
027377          *IOF
027400          0=:5HIFLAG                                       % YES, MARK THAT IT IS STOPPED
027401          CALL HIMFEXQUEUE; GO RLHI1                       % REMOVE HISTOGRAM MESSAGE FROM EX-QUEUE
027403          CALL SLOCK; 0/\0
027405          X:=HIMESS; CALL GCPUDF; GO RLHI1
027410          X:=A.MAILINK; T:=5MBBANK; *AAX WANTP; LDATX
027415          A-5SWPROC*5PRDSIZE+"S500S"
027420          X:=A.MESSBUFF; *AAX 5MSFL; LDATX
027424          *5SCPU@3 BLDA DA
027425          A BZERO 5CPUBOUND BZERO 5SCPUBOUND
027427          *5CPUB@3 BSTA DA; STATX
027431          CALL SUNLOCK
027432   RLHI1: *ION
027433          GO RLHLREG
027434   RBUS
027446
027446
027446   %=====================================================================
027446   %      ( 5 )     C H F O R G E T
027446   %
027446   %  SUBROUTINE TO CHECK AND WAIT UTILK ALL PROCESSES IS LOGGED OUT OF
027446   %  THE ND-500 SYSTEM.
027446   %
027446   % ENTRY:     NONE
027446   % EXIT:      OK
027446   %
027446   SUBR CFORGET
027446   INTEGER CHFPROCNO
027447   INTEGER POINTER LREG
027450
027450   CFORGET:  A:=L=:"LREG"
027452          DO
027452             5SWPROC+1=:CHFPROCNO; X:="S500S"+5PRDSIZE
027457             FOR CHFPROCNO DO WHILE CHFPROCNO<<=MX5PROCS
027463                IF X.RTRES><0 AND A><RTREF THEN                  % OTHER USING ND-500?
027470                   CALL DOHOLD(2,2); GO ECHF
027474                FI; X+5PRDSIZE
027475             OD
027477             GO LREG
027500   ECHF:  OD
027501   RBUS
027506
027506
027506   %=====================================================================
027506   %      ( 5 )     X T U S O N     T U S O N
027506   %  XTUSON: CHECK IF OTHER USERS ARE LOGGED ON THE 500 SYSTEM
027506   %  TUSON:  CHECK IF OTHER USERS ARE LOGGED ON THE ACTUAL 500 CPU
027506   %
027506   %          IF NONE ARE LOGGED ON THEN RESERVE THE ACTUAL ND-500 FOR
027506   %          SPECIAL USE FOR THE CALLING PROGRAM
027506   %
027506   % ENTRY:     B=N500DF
027506   % EXIT:      OTHER USERS ARE LOGGED ON
027506   % EXIT AD1:  XTUSON: THE ND-500 SYSTEM IS RESERVED FOR SPECIAL USE
027506   %            TUSON:  THE ACTUAL ND-500 IS RESERVED FOR SPECIAL USE
027506   %
027506   SUBR XTUSON,TUSON
027506   INTEGER TUSOPROCNO,TUSOFLG
027510   INTEGER POINTER LREG
027511
027511   XTUSON: A:=1; GO FELLS
027513   TUSON:  A:=0
027514   FELLS: A=:TUSOFLG; A:=L=:"LREG"
027517          *IOF
027520          CALL SLOCK; 0/\0
027522          5SWPROC+1=:TUSOPROCNO; X:="S500S"+5PRDSIZE
027527          FOR TUSOPROCNO DO WHILE TUSOPROCNO<<=MX5PROCS
027533             IF X.RTRES><0 AND A><RTREF THEN                  % OTHER USING ND-500?
027540                IF TUSOFLG><0 GO TUSERET
027542                X=:D
027543                X:=X.MESSBUF;  CALL GCPUDF; CALL ERRFATAL     % YES, USING THIS ND-500 CPU?
027546                IF A=CCPUDF GO TUSERET
027551                X:=D
027552             FI; X+5PRDSIZE
027553          OD
027555          IF TUSOFLG><0 THEN
027557             RTREF=:NSPREF
027561          ELSE
027562             X:=CCPUDF; CALL RESCPU; GO TUSERET
027565          FI
027565          MIN "LREG"
027566   TUSRET: CALL SUNLOCK
027567          *ION
027570          GO LREG
027571
027571   TUSERET:  EUSRON; GO TUSRET
027573   RBUS
027605
027605
027605   %===============================================================
027605   %       ( 5 )    F R U S M O V E   -   X F R U S M O V E
027605   %
027605   % LOCAL SUBROUTINE TO COPY WORDS FROM THE USER'S AREA
027605   % TO THE MON60 BUFFER. THE MON60 BUFFER IS SETUP IN THE DATA-BUFFER
027605   % WINDOW IN RT-DESCRIPTION AND THE LOGICAL ADDR IS FOUND IN LOGBADR
027605   % IN N500DF DATAFIELD.
027605   %
027605   % ENTRY:     T=NUMBER OF BYTES
027605   %            A=SOURCE ADDRESS
027605   % IF XFRUSMOVE: X=DISP IN DATA-BUFFER TO MOVE INTO
027605   %
027605   % EXIT:      ALL REGISTERS, EXCEPT B, ARE DESTROYED
027605   %
027605   SUBR FRUSMOVE,XFRUSMOVE
027605   INTEGER POINTER FRUSLREG
027606   XFRUSMOVE: T+1 SHZ -1:=:X                        % X=NUMBER OF BYTES
027611          A=:D:=LOGBADR; T+A                        % T=DESTINATION ADDR; D=SOURCE ADDR
027614          A:=L=:"FRUSLREG"
027616          GO FRUSFELLS
027617   FRUSMOVE: T+1 SHZ -1=:X                          % NUMBER OF WORDS TO COPY
027622          T:=L=:"FRUSLREG"
027624          T:=LOGBADR; A=:D                          % T=DESTINATION ADDR; D=SOURCE ADDR
027626   FRUSFELLS:
027626          A:=OLDPAGE; K:="0"; CALL MOVUS            % COPY FROM USER TO DPIT
027631          GO FRUSLREG
027632   RBUS
027633
027633
027633   %===========================================================================
027633   %       ( 5 )    T O U S M O V E
027633   %
027633   % LOCAL SUBROUTINE TO COPY WORDS TO THE USER'S AREA
027633   % FROM THE MON60 BUFFER. THE MON60 BUFFER IS SETUP IN THE DATA-BUFFER
027633   % WINDOW IN RT-DESCRIPTION AND THE LOGICAL ADDR IS FOUND IN LOGBADR
027633   % IN N500DF DATAFIELD.
027633   %
027633   % ENTRY:     A=NUMBER OF BYTES
027633   %            T=DESTINATION ADDRESS
027633   %
027633   SUBR TOUSMOVE
027633   INTEGER POINTER TOUSLREG
027634   TOUSMOVE: A+1 SHZ -1=:X                          % X=NUMBER OF WORDS
027637          A:=L=:"TOUSLREG"; LOGBADR=:D              % D=SOURCE ADDR
027643          A:=OLDPAGE; K:=1; CALL MOVUS              % COPY FROM DPIT TO USER'S ALT.PIT
027646          GO TOUSLREG
027647   RBUS
027650
027650
027650   %=======================================================================
027650   %       ( 5 )    S T D S 0
027650   %
027650   % LOCAL SUBROUTINE TO STORE A DOUBLE WORD IN USER'S AREA
027650   %
027650   % ENTRY:     AD=DOUBLE WORD TO STORE
027650   %            X=ADDRESS IN USER AREA
027650   %            B=N500DF
027650   %
027650   SUBR STDS0
027650   INTEGER POINTER STDSLREG
027651   STDS0: T:=L=:"STDSLREG"; X=:L
027654          A=:T:=OLDPAGE/\3600\/"N5PIT+ALEVB+ERNG2"; *IOF
027661          A=:RTREF.ACTPRI; *TRR PCR; ION
027665          A:=T; AD=:L.DS0
027670          "N5PIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
027673          A=:RTREF.ACTPRI; *ION
027676          GO STDSLREG
027677   RBUS
027703
027703
027703   %=====================================================
027703   %       ( 5 )    G O O D R T
027703   %
027703   % LOCAL SUBROUTINE TO CHECK FOR LEGAL RT-DESCRIPTION ADDRESS
027703   % ENTRY:     X=RT-DESCRIPTION ADDRESS
027703   % EXIT:      ERROR
027703   % EXIT+1:    OK, LEGAL RT-DESCRIPTION ADDRESS
027703   %
027703   SUBR GOODRT
027703   GOODRT: IF X>>=RTEND OR X<<RTSTART GO NGOOD
027711           A:=X-RTSTART; A=:D:=0; T:=5RTSIZE; *RDIV ST
027717           IF D><0 GO NGOOD; EXITA
027722   NGOOD:  EXIT
027723   RBUS
027725
027725
027725   %============================================================================
027725   %       ( 5 )    H I M F E X Q U E U E
027725   %
027725   % LOCAL SUBROUTINE TO REMOVE THE HISTOGRAM MESSAGE FROM
027725   % THE ND-500 EX-QUEUE.
027725   %
027725   % ENTRY:     B=N500DF DATAFIELD
027725   %            INTERRUPT IS OFF
027725   %
027725   %            ALL REGISTERS EXCEPT B ARE DESTROYED
027725   %            INTERRUPT IS OFF
027725   % EXIT:      NOT IN EXECUTION QUEUE
027725   % EXIT+1:    REMOVED FROM EXECUTION QUEUE
027725   %
027725   %
027725
027725   SUBR HIMFEXQUEUE
027725   INTEGER POINTER HIMFLREG
027726   HIMFEXQUEUE:
027726          X:=HIMESS; T:=5MBBANK; *AAX 5MSFL; LDATX
027732          IF A BIT 5IEXQUEUE THEN                       % IS HISTOGRAM MESSAGE IN EX-QUEUE?
027734             A:=L=:"HIMFLREG"
027736             CALL SLOCK; 0/\0
027740             X:=HIMESS; CALL GCPUDF; CALL ERRFATAL
027743             A=:B
027744   *NNT40=*
027744             CALL TER500; 0/\0
027746             CALL IFM500XQ                              % REMOVE HIMESS FROM EX-QUEUE AND RESTART ND-500
027747             CALL SUNLOCK
027750             CALL LOWACT500
027751             "N500DF"=:B
027753             "HIMFLREG"+1=:L
027756          FI; EXIT
027757   RBUS
027771
027771
027771   %======================================================================
027771   %       ( 5 )    F R Q U E S
027771   %
027771   % LOCAL SUBROUTINE TO REMOVE A MESSAGE FROM THE EXECUTION QUEUE
027771   % AND FROM THE TIME QUEUE
027771   % ENTRY:     B=ND-500 CPU DATAFIELD
027771   %            X=ND-500 MESSAGE
027771   %            INTERRUPT IS OFF
027771   %
027771   % EXIT:      ALL REGISTER EXCEPT B ARE DESTROYED
027771   %            INTERRUPT IS OFF
027771   %
027771   SUBR FRQUES
027771   INTEGER POINTER FRQRET
027772   INTEGER BREG
027773
027773   FRQUES: A:=L=:"FRQRET"; A:=B=:BREG
027777          CALL SLOCK; 0/\0
030001          CALL GCPUDF; GO EFRQUE; A=:B
030004          T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
030010          IF A BIT 5ITMQUEUE THEN
030012             CALL FR5TMQ                                % REMOVE MESSAGE FROM ND-500 TIME QUEUE
030013             A:=MFREE; CALL WN5STATUS
030015             CALL SUNLOCK
030016          ELSE IF A BIT 5IEXQUEUE THEN                  % IS MESSAGE IN ND-500 EX-QUEUE?
030021             CALL GETC5PROC; A=:D                       % CHECK IF IT IS NECESSARY TO TERMINATE ND-500(0)
030023             T:=5MBBANK; *SENDE@3 LDATX
030025             IF A=D OR MIFLAG NBIT MUDOM THEN
030032                CALL TER500; 0/\0
030034             FI
030034             CALL IFM500XQ                              % REMOVE MESSAGE FROM EX-QUEUE
030035             A:=MFREE; CALL WN5STATUS
030037             CALL SUNLOCK
030040             IF 5CPUSTOPPED><0 THEN
030042                N100KICK; CALL KICK500
030044                CALL LOWACT500
030045             FI
030045          ELSE
030046   EFRQUE:   CALL SUNLOCK
030047          FI FI
030047          T:=5MBBANK; X=:D; *AAX XADPR; LDXTX
030053          X.PSTAT BZERO 5REWA=:X.PSTAT; X:=D
030057          BREG=:B; GO FRQRET
030062   RBUS
030075
030075
030075   %=============================================================================
030075   %       ( 5 )    R E L R E F S
030075   %
030075   % LOCAL SUBROUTINE TO
030075   %      1. RELEASE THE ND-500 CPU FROM SPECIAL USE IF RESERVED FOR SPECIAL USE
030075   %         BY THE CALLING PROGRAM.
030075   %      2. RELEASE ALL LOGGING FACILITIES RESERVED BY THE CALLING PROGRAM
030075   %
030075   % ENTRY:     B=N500DF DATAFIELD
030075   %
030075   % EXIT:      ALL REGISTERS EXCEPT B ARE DESTROYED
030075   %
030075   SUBR RELREFS
030075   INTEGER RELRLREG
030076   RELREFS: *IOF
030077          A:=L=:RELRLREG
030101          IF NSPREF=RTREF THEN 0=:NSPREF FI
030106          IF CCPUDF.SPREF=RTREF THEN CALL RELCPU FI             % RELEASE ND-500 CPU RESERVED FOR SPECIAL USE
030114          IF 5HRTP=RTREF THEN CALL RLHILOG; 0=:5HRTP FI         % HISTOGRAM RESERVED BY THE CALLER?
030122          IF 5MLOG=RTREF THEN 0=:5MLOG=:5MLOPROC FI             % IF MONCALL LOG RESERVED BY THE CALLER THEN RELEASE IT
030130          RELRLREG=:L
030132          *ION
030133          EXIT
030134   RBUS
030142
030142
030142   %===============================================================
030142   %       ( 5 )    S M L V R O U T I N E
030142   %
030142   % START MONITOR LEVEL.
030142   % A=MONITOR ROUTINE ENTRY ADDR. INTERRUPT IS OFF
030142   % B=ND500DF DATAFIELD
030142   %
030142   SUBR SMLVROUTINE
030142   SMLVROUTINE:
030142          *IRW MLEVB DP
030143          X:=RTREF; CALL BRELEASE                % RELEASE N500DF DATAFIELD
030145          MLEV; *MST PID; MST PIE; ION           % START MONITOR LEVEL ROUTINE
030151          CALL ERRFATAL                          % SHOULD NOT CONTINUE HERE ON LEVEL 1
030152   RBUS
030155
030155
030155   %============================================================================
030155   %       ( 5 )    A L L R E L E A S E
030155   %
030155   % RELEASE ALL ND-500 SEMAPHORES
030155   %
030155   SUBR ALLRELEASE
030155   INTEGER RLRG,RRXRG,RTRG,RBRG,RSTS
030162   ALLRELEASE: MLEV; *MCL PIE
030164          A:=L=:RLRG; X=:RRXRG:=B=:RBRG
030171          CALL CLEAN
030172          FOR X:=0 TO 11 DO                                    % RELEASE ALL ND-500 LOCKS
030176             X=:RTRG:=XSEMS(X)
030200             IF X.RTRES=RTREF THEN X=:B:=A; CALL BRELEASE FI
030207             X:=RTRG
030210          OD
030212   ALLR1: RTREF.BRESLINK
030214          DO WHILE A><RTREF
030217             IF A>>="9SFIS" AND A<<"9EFIS" THEN               % RELEASE ALL FILESYS. LOCKS IF
030225   ALLR2:       X:=RTREF; A=:B; CALL BRELEASE; GO ALLR1       % IF RESERVED BY THE CALLER
030231             ELSE
030232                IF A>>="DEVBU" AND A<<ENDBU GO ALLR2          % RELEASE ALL DEVICE BUFFERS RESERVED
030240                IF A>>="9FDFD" AND A<<"9EDFD" GO ALLR2
030246                IF T:="MXSIBAS"><0 THEN
030251                   IF A>>="DSI0" AND A<<"EDSIBAS" GO ALLR2    % RELEASE ALL SIBAS MONCALL WORKING FIELDS RESERVED
030257                FI
030257             FI; A.RESLINK
030261          OD
030262          X:=RBRG=:B:=RRXRG
030265          *TRA STS; IOF
030267          A=:RSTS; CALL CLINONMSG
030271          T:=RLRG; X:=RRXRG
030273          MLEV; *MST PIE
030275          IF RSTS BIT 17 THEN
030300             *ION
030301          FI
030301          T=:P
030302   RBUS
030320
030320
030320   %==================================================================
030320   %       ( 5 )    S U P D W I N D O W   -   X S U P D W I N D O W
030320   %
030320   % LOCAL SUBROUTINE TO SETUP WINDOW TO MON60 BUFFER.
030320   %
030320   % ENTRY:     B=N500DF
030320   % IF XSUPDWINDOW: AD=PHYS. ADDR TO SET WINDOW TO
030320   %
030320   % EXIT:      BUFFER PAGE IN PIT, LOGICAL ADDR IN LOGBADR
030320   %            ALL REGISTERS EXCEPT B ARE DESTROYED
030320   SUBR SUPDWINDOW,XSUPDWINDOW
030320   XSUPDWINDOW:
030320          T:=1777/\D; GO INSUPWINDOW
030323   SUPDWINDOW:
030323          T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX ABUFA; LDDTX  % AD=PHYS ADDR OF MON60 BUFFER
030330          T:=0
030331   INSUPWINDOW:
030331          AD SHZ 6; A=:CURPROG.BUFWINDOW                       % PHYS.PAGE OF MON60 BUFFER TO RT-DESCR
030334          A=:D:="WNDBF*2000"+T=:LOGBADR
030340          X:="WNDBF+WNDBF+174000"; T:=0; A:=142000; *STDTX     % SET PIT ENTRY
030344          EXIT
030345   RBUS
030353
030353
030353   %==============================================================================
030353   %       ( 5 )    C L I N O N M S G
030353   %
030353   % SUBROUTINE TO CLEAR ALL IN5MSG/ON5MSG IN ALL TERMINAL/TAD DATAFIELD
030353   % RESERVED BY THE CALLING PROCESS
030353   %
030353   % ENTRY:     INTERRUPT MUST BE OFF
030353   %
030353   SUBR CLINONMSG
030353   INTEGER POINTER CLIOLREG
030354   CLINONMSG: A:=L=:"CLIOLREG"
030356          RTREF+"BRESLINK"=:X
030361          DO WHILE X:=X.RESLINK><RTREF
030365             IF X.TYPRING BIT 5TERM THEN
030370                A:=X-"DT01R"=:D:=0; T:="5TTSZ"; *RDIV ST
030376                IF D=0 THEN
030400                   T:="IN5MSG"                   % INPUT
030401                ELSE
030402                   T:="ON5MSG"                   % OUTPUT
030403                FI; A:=0; CALL XSTDFADDR         % CLEAR IN5MSG/ON5MSG
030405             FI
030405          OD; GO CLIOLREG
030407   RBUS
030416
030416
030416   % *****************************************************************************
030416   %       ( 5 )    N 5 0 0 M
030416   %
030416   % ENTRY POINT OF MONITOR CALL 60
030416   %
030416   % *****************************************************************************
030416
030416   SUBR N500M,TOSYMON,5OKRET,EEILPAR
030416   N500M: CALL GET1                                           % GET THE FUNCTION PARAMETER
030417          IF X:=5FUNCTION BZERO COMAUTO>>FUNCMAX GO FAR ILLFUNC  % TOO LARGE FUNCTION CODE
030424          *1BANK;
030425          5IFUNC(X); *2BANK
030427          IF A=0 OR A="ILLFUNC" GO FAR ILLFUNC                % UNDEFINED FUNCTION
030433          IF RTREF><NSPREF AND T><0 THEN
030441             A=:D; CALL FSEMA; GO FAR EESPRES
030444          FI
030444          IF BACKGROUND><0 THEN
030446             5ND5US=:5TTIFIELD.BSTATE                         % SET ND500 STATUS IN BSTATE
030451             CALL ESCOF
030452          FI
030452          CALL INZ500; GO FAR ERET                            % INITIALIZE ND-500 SYSTEM IF NOT DONE
030454          -1=:N5FUNCTION
030456          RTREF=:D; CALL FSEMA; GO N5PDRES                    % FIND PROCESS DESC IF RESERVED
030462          X=:5PRDESCR                                         % 5PDRES EXPECTS MSG IN X
030463          IF 5FUNCTION BZERO COMAUTO=MEMDEF GO FAR CLRMS
030470          IF A=N5RES OR A=MRESSPES OR A=SSTDOM THEN           % NECESSARY TO RELEASE PROCESS BEFORE NEW RESERVE?
030501             N5REL=:N5FUNCTION
030503          FI
030503          X:=X.MESSBUFF
030504          GO FAR 5PDRES
030505   N5PDRES:                                                   % NO PROCESS DESCRIPTION RESERVED
030505          IF X:=5FUNCTION BZERO COMAUTO=N5REL GO FAR 5OKRET   % NOT NECESSARY TO RESERVE WHEN FUNCTION IS RELEASE
030512          IF X><N5RES AND X><MRESSPES AND X><SSTDOM THEN      % MAY BE ILL.FUNC. WHEN PROC.DESCR NOT RESERVED
030523             T:="PARANT"; *1BANK; LBYT; 2BANK
030527             IF A BIT COMSPEC THEN A/\7=:T; GO FAR 5PDR2 FI   % T=NUMBER OF PARAMTERS IN MON60 FUNCTION
030534             N5RES=:N5FUNCTION
030536          FI
030536          IF BACKGROUND><0 AND 5BCHFLAG=1 THEN
030544             MX5PROCS*5PRDSIZE+"S500S"=:X                     % IF BATCH TRY TO RESERVE LAST PROC.DESCR.
030550             IF X.RTRES=0 THEN
030552                A:=MX5PROCS=:5D32                             % RESERVE LAST PROC IF NOT
030554                GO PRFOUND; *)FILL                            % ALREADY RESERVED BY ANOTHER BATCH
030602             FI
030602          FI
030602          5SWPROC+1=:5D32; X:="S500S"+5PRDSIZE
030607   LOOP:  IF 5D32>>=MX5PROCS GO FAR EENPROC
030613            X=:D:=X.MESSBUFF; T:=5MBBANK; *AAX 5MSFL; LDATX
030620            IF A BIT 5SYSRES OR D.RTRES><0 GO FAR EFI         % FREE PROC.DESC?
030626   PRFOUND:    X=:B:=RTREF; CALL BRESERVE                     % RESERVE THE PROCESS DESC.
030631               *IOF
030632               ENOCPU=:"N500DF".N5SERROR
030635               X:=X.NCCPUDF; -1=:L; D:=0
030641               DO WHILE X><0                                  % FIND A CPU (WITH SHORTEST EXEC. QUEUE )
030642                  IF X.CPUAVAILABLE BIT 5ALIVE THEN
030645                     IF X.FERROR=0 OR A=N5STOPPED THEN
030652                        IF X.CPUAVAILABLE NBIT 5EXCLUD THEN
030655                           IF X.SPREF=0 THEN
030657                              IF X.MIFLAG NBIT MUDOM THEN
030662                                 IF X.LEXQUEUE<<L THEN A=:L; X=:D FI
030667                              ELSE
030670                                 X=:D; GO PRF1
030672                              FI
030672                           ELSE
030673                              X=:T; ESPRES=:"N500DF".N5SERROR; X:=T
030700                           FI
030700                        ELSE
030701                           IF D=0 THEN X=:D FI
030704                        FI
030704                     ELSE
030705                        IF D=0 THEN X=:D FI
030710                     FI
030710                  FI
030710                  IF X+5CPUDFSZ>>"E5CPUDF" THEN X:="S5CPUDF" FI
030715                  X=:T
030716                  WHILE T><X:="N500DF".NCCPUDF
030722                  T=:X
030723               OD
030724   PRF1:       *ION
030725               IF X:=D=0 THEN
030730                  X:=RTREF; CALL BRELEASE
030732                  "N500DF".N5SERROR; GO FAR ERET              % NO ND-500 CPU AVAILABLE
030735               FI
030735               A:="N500DF":=:B; X=:CCPUDF
030740               IF X+5CPUDFSZ>>"E5CPUDF" THEN X:="S5CPUDF" FI  % NEXT CPU
030745               X=:NCCPUDF
030746               A=:5PRDESCR                                    % CURRENT PROCESS DESCRIPTION ADDR
030747               A:=0 BONE 55BRKPRIOR BONE SLICE=:5PRDESCR.PSTAT % ALL PROCS ARE DEFAULT TIMESLICED
030754   % - CLEAR MESSAGE
030754   CLRMS:      T:=5MBBANK; X:=X.MESSBUFF; *AAX -55MSN         % MESSAGE START
030757               A:=X+55MESSIZE-1=:L; A:=0; D:=0                % MESSAGE END
030765               DO WHILE X<<L
030767                   *STDTX; AAX 2                              % CLEAR MESSAGE
030771               OD
030772               GO BYPASS; *)FILL
031014
031014
031014   % - INITIALIZE MESSAGE
031014   BYPASS:     X:=5PRDESCR.MESSBUFF=:L
031017               5PRDESCR; *AAX XADPR; STATX                   % SET ADDR OF PROC.DESCR IN MESSAGE
031022               5BRKPRIOR; *AAX 5PRIO-XADPR; STATX            % SET START PRIORITY
031025               A:=-1; *AAX 5TSLC-5PRIO; STATX                % TIMESLICER "COUNTER"
031030               CCPUDF.CPUNO; X:=L; *AAX 5CPUN; STATX         % SET THE CPU USED BY CURRENT PROC.
031035               A:=5FBUM60+5D32=:D:=0; AD SH 12
031042               *AAX ABUFA-5CPUN; STDTX; AAX -ABUFA           % ADDR OF PROC'S DATA BUFFER.
031045               5D32; *SENDE@3 STATX; AAX 5MSFL; LDATX
031051               IF T:=BACKGROUND=0 OR T:=5PASSTYPE><0 THEN    % BACGROUND USER RT AND SYSTEM OR RT-PROGR?
031057                  A BONE SPROK                               % YES, SPRIO MONCALL ALLOWED
031060               FI
031060               A/\154000; T:=5MBBANK; *STATX
031063               T SH 6; 5PRDESCR.MESSBUFF SHZ -12+T
031070               A=:RTREF.N5WINDOW                             % SET WINDOW TO MESSAGE
031072               IF BACKGROUND><0 AND 5BCHFLAG=0
031075               AND 5TTIFIELD.TYPRING BIT 5TERM OR A BIT 5BAD THEN
031104                  X.DFOPP.TDRADDR
031106               ELSE
031107                  A:=0
031110               FI; T:=5MBBANK; X:=5PRDESCR.MESSBUFF
031113               *AAX OUTDF; STATX; AAX -OUTDF                  % SET ADDR OF TERMINAL OUTPUT DF. WHEN TTIFIELD IS TERMINAL
031116               GO 5PDRES
031117   EFI:     MIN 5D32; 0/\0; X:=D+5PRDSIZE
031123          GO FAR LOOP
031124   *)FILL
031134
031134   INTEGER XPARANT                                               % CURRENT FUNCTION DECRIPTION
031135   5PDRES:                                                       % PROC.DESC IS RESERVED, X=MSG
031135          CALL GCPUDF; CALL ERRFATAL                             % X=CURRENT ND-500 CPU TO USE
031137          A=:CCPUDF; A.SPREF=:D
031143          IF D><0 AND D><RTREF AND 5FUNCTION><N5REL AND A><ABLOG AND A><MO5RT THEN
031162             CALL FSEMA; GO 5PDR1                                % ND-500 CPU IS RESERVED FOR SPECIAL USE
031164             GO FAR EESPRES                                      % AND THE RESERVING PROGR IS STILL ACTIVE
031165   5PDR1:    X:=CCPUDF; CALL RELCPU                              % THE RESERVING PROGR IS NO LONGER ACTIVE
031167          FI
031167          CALL SUPDWINDOW                                        % SET WINDOW ADDR TO MON60 BUFFER
031170          MLEV; *MST PIE
031172          X:=5FUNCTION BZERO COMAUTO; T:="PARANT"
031175          *1BANK; LBYT; 2BANK                                 % FETCH MON60 FUNCTION DESCR.
031200          A=:D/\7=:XPARANT
031203          IF BACKGROUND=0 AND D NBIT RTPLEGAL GO FAR EEFUNRTP % FUNCTION NOT LEGAL FROM RT-PROGR.
031207          IF D BIT COMPROT THEN                               % PROTECTED COMMAND
031211             IF BACKGROUND><0 AND 5PASSTYPE><2 AND 5FUNCTION NBIT COMAUTO GO FAR EENAUTHORIZED
031222             IF D BIT BSPRES THEN                             % FUNCT. REQUIRE ND500 CPU RESERVED FOR SPECIAL USE
031224                CALL TUSON; GO FAR ERET                       % TEST IF OTHER USES THIS ND-500 CPU
031226             FI
031226          FI; 5FUNCTION BZERO COMAUTO=:5FUNCTION
031231          IF BACKGROUND><0 THEN
031233             CALL ESCOFF; *IOF                                % SET ESCAPE OFF
031235             RTREF.STATUS BZERO 5REP=:X.STATUS; *ION          % CLEAR 5REP BIT
031242          FI; T:=XPARANT
031243   5PDR2: GO SKPLG
031244          T=:XPARANT
031245          A:=B+"FSYVARIABLES"=:X=:T                        % LOG MON 60 CALLS
031251          IF X.S0 << X OR A >>= T+70 THEN                  % POINTER OUTSIDE RING BUFFER ?
031257             A:=X+1=:X.S0                                  % RESET POINTER
031261          FI                                               % LOG : 2 WORDS
031261          X=:D; T:=5PRDESCR=:A.S0; 5FUNCTION=:X.S1         % 1. PROCESS DESCR.
031267          A:=X+2=:D.S0                                     % 2. M60 FUNCTION
031273          T:=XPARANT
031274   SKPLG :"5D11"+B=:D; X:=ZAREG
031300          A:=OLDPAGE; X+1=:B; CALL GND5PAR                    % FETCH MON-60 PARAMETERS
031304          "N500DF"=:B; X:=5FUNCTION; *1BANK
031310          A:=5IFUNC(X); *2BANK           % ADDR OF FUNCTION DEPENDANT "ROUTINE"
031312          A=:P                           % GO TO ENTRY POINT ACCORDING TO FUNCTION CODE
031313   *)FILL
031340
031340   EENIMPLEMENT: ENIMPLEMENT; GO ERET
031342   EEFUNRTP: EFUNRTP; GO ERET
031344   EENPROC:  ENOPROC; GO ERET
031346   EENPCOMMU: ENOPCOMMU; GO ERET
031350   EENAUTHORIZED: ENAUTHORISED; GO ERET
031352   EESPRES: ESPRES; GO ERET
031354   EEILPAR: EC174; GO ERET
031356   ILLFUNC: EILFUNC
031357   ERET:    T:="N500DF"=:B; A=:ZAREG; MLEV; *MST PIE          % SET B=N500DF AND SAVE ERROR CODE
031364            IF 5FUNCTION=N5REL AND SYSINITFLAG NBIT BFIRSTACCESS GO FAR 5OKRET  % WM476: Leave?
031373            GO FAR RET5
031374   *)FILL
031405
031405
031405   %================================================================
031405   %      ( 5 )     5 I F U N C
031405   %
031405   % TABLE OF ENTRY POINTS TO GOTO BEFORE CALLING THE SYSTEM MONITOR
031405   % THE FUNCTION CODE IS INDEX IN THE TABLE
031405   @ICR
031405   INTEGER ARRAY 5IFUNC:=(
031405          5NOPAR,5NOPAR,5NOPAR,5NOPAR,IPMWRITE,IDMWRITE,ISEGLOAD,IPLSWAPPER,    % 000 - 007
031415          5NOPAR,IWRGS,5NOPAR,ICONNFI,5NOPAR,5NOPAR,5NOPAR,5NOPAR,              % 010 - 017
031425          5NOPAR,5NOPAR,5NOPAR,5NOPAR,IWCNT,5NOPAR,5NOPAR,5NOPAR,               % 020 - 027
031435          5NOPAR,5NOPAR,5NOPAR,IDAMW,5NOPAR,5NOPAR,5NOPAR,ICSLOAD,              % 030 - 037
031445          5NOPAR,5NOPAR,5NOPAR,ISRES,ISREL,5NOPAR,IDEFSWAP,IDELSWAP,            % 040 - 047
031455          5NOPAR,5NOPAR,5NOPAR,5NOPAR,5NOPAR,ISPLACE,IEPLACE,5NOPAR,            % 050 - 057
031465          5NOPAR,IMRESSPES,IDEFHIST,ISTAHIST,ISTOHIAT,IREAHIST,IRELHIST,ISPRTE, % 060 - 067
031475          5NOPAR,ISSGTE,5NOPAR,5NOPAR,ISPRNM,ITSTUSER,ITOSWP,IRMESS,            % 070 - 077
031505          RRFLAG,WWFLAG,IFORGET,IRSYSP,IWSYSP,5NOPAR,5NOPAR,5NOPAR,             % 100 - 107
031515          IWPHSG,ISTAPRLOG,ISTOLOG,IPRILOG,IRELLOG,ISTLAPR,5NOPAR,IPRABORT,     % 110 - 117
031525          5NOPAR,5NOPAR,ILOGOFF,IMRELSPES,ISTAMLOG,IPRIMLOG,ISTOMLOG,IDFSYDOM,  % 120 - 127
031535          ISFSYDOM,IDLSYDOM,5NOPAR,ILI5EXQ,IPLDEB,IABLOG,IPRACTIVE,0,           % 130 - 137
031545          5NOPAR,5NOPAR,5NOPAR,IMO5RT,ICHACPU,ISSTDOM,ILLFUNC,ILLFUNC,          % 140 - 147
031555          ILI5TQU,ILLFUNC,ILLFUNC,ILLFUNC,5NOPAR,5NOPAR,5NOPAR,IWCNT,           % 150 - 157
031565          IN5SEGLOAD,INDFSYDOM,5NOPAR,5NOPAR,5NOPAR,5NOPAR,5NOPAR,5NOPAR,       % 160 - 167
031575          5NOPAR,5NOPAR,5NOPAR,ICPUSTAT,ILLFUNC,ILLFUNC,ILLFUNC,5NOPAR);        % 170 - 177
031605   @CR;
031605
031605   %-------------------------------------------------------------------------------
031605   IPMWRITE:    % FUNCTION=004: LOGICAL PROGREAM MEMORY WRITE
031605   IDMWRITE:    % FUNCTION=005: LOGICAL DATA MEMORY WRITE
031605   IDAMW:       % FUNCTION=033: PHYSICAL DATA MEMORY WRITE
031605          AD:=5DD1
031606          IF A><0 OR D>>4000 THEN
031612             EBIGBUF; GO FAR ERET                   % 4000B BYTES ARE MAX DUE TO BUFFER SIZE
031614          FI
031614          T:=5D12; A:=5P3; CALL FRUSMOVE            % COPY DATA FROM USER TO MON60 BUFFER
031617          GO FAR 5NOPAR; *)FILL
031625
031625   %-------------------------------------------------------------------------------
031625   ISEGLOAD:    % FUNCTION=006: LOAD (PLACE), ONE SEGMENT
031625          A:=5P1; T:=200; CALL FRUSMOVE             % COPY SEGMENT NAME FROM USER TO MON60 BUFFER
031630          IF 5D51><0 THEN                           % ANY ND-100/ND-500 SHARED PARTS?
031632             A:=5P5; T:=40; X:=100; CALL XFRUSMOVE  % YES, COPY SHARD-INFO FROM USER TO MON60 BUFFER
031636          FI; GO FAR 5NOPAR; *)FILL
031643
031643   %-------------------------------------------------------------------------------
031643   IPLSWAPPER:  % FUNCTION=007: PLACE SWAPPER
031643   IDEFSWAP:    % FUNCTION=046: DEFINE SWAP FILE
031643   IDELSWAP:    % FUNCTION=047: DELETE SWAP FILE
031643   ISPRTE:      % FUNCTION=067: READ PROCESS ENTRY FROM NAME SEGMENT
031643   ISSGTE:      % FUNCTION=071: READ PHYS.SEGMENT ENTRY FROM NAME SEGMENT
031643   ISFSYDOM:    % FUNCTION=130: START STANDARD DOMAIN
031643   IDLSYDOM:    % FUNCTION=131: DELETE STANDARD DOMAIN
031643   ICOPF: A:=5P1; T:=200; CALL FRUSMOVE             % COPY FILE NAME TO MON60 BUFFER
031646          GO FAR 5NOPAR; *)FILL
031652
031652   %-------------------------------------------------------------------------------
031652   ICONNFI:     % FUNCTION=013: CONNECT FILE
031652          T:=200; A:=5P1; CALL FRUSMOVE             % COPY FILE NAME TO MON60 BUFFER
031655          T:=4; A:=5P3; X:=100; CALL XFRUSMOVE      % COPY FILE TYPE TO MON60 BUFFER
031661          GO FAR 5NOPAR; *)FILL
031666
031666   %-------------------------------------------------------------------------------
031666   IWCNTS:      % FUNCTION=024 : WRITE CONTROL STORE (equal for func=157)
031666          IF 5D22>>2000 GO FAR ERET                    % 2000B CS-WORDS ARE MAX.
031672          T:=5D22 SH 1; A:=5P3; CALL FRUSMOVE       % COPY CONTROL STORE DATA FROM USER TO MON60 BUFFER
031676          GO FAR 5NOPAR; *)FILL
031703
031703   %-------------------------------------------------------------------------------
031703   ICSLOAD:     % FUNCTION=037: LOAD CONTROL STORE (LOAD A FILE INTO CS)
031703            A:=5P3; T:=200; CALL FRUSMOVE           % COPY FILE NAME TO MON60 BUFFER
031706            GO FAR 5NOPAR; *)FILL
031712
031712   %-------------------------------------------------------------------------------
031712   ISRES:            % FUNCTION=043: RESERVE ND-500 CPU/SYSTEM FOR SPECIAL USE
031712          IF 5D11=0 AND 5D12=0 THEN
031716             IF CCPUDF.SPREF=RTREF GO FAR 5OKRET                    % ALREADY RESERVED FOR SPECIAL USE BY CALLER?
031723             CALL TUSON; GO FAR ERET                                % IF ANYONE ELSE USING THIS ND-500 CPU NOW ?
031725          ELSE
031726             IF RTREF=NSPREF GO FAR 5OKRET                          % ALREADY RESERVED FOR SPECIAL USE BY CALLER?
031732             A=:NSPREF; CALL XTUSON; GO FAR ERET                    % SET UNAVAILABLE AND CHECK FOR OTHER USERS ALREADY LOGGED ON
031735          FI
031735          GO FAR 5OKRET
031736
031736   %-------------------------------------------------------------------------------
031736   ISREL:       % FUNCTION=044: RELEASE ND-500 CPU/SYSTEM FROM SPECIAL USE
031736          IF CCPUDF.SPREF=RTREF THEN CALL RELCPU FI             % RESERVED FOR SPECIAL USE BY THE CALLER?
031744          IF NSPREF=RTREF THEN 0=:NSPREF FI
031751          GO FAR 5OKRET; *)FILL
031760
031760   %-------------------------------------------------------------------------------
031760   ISPLACE:     % FUNCTION=055: START-PLACE
031760          T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX 5MSFL; IOF; LDATX
031766          A BZERO 55REP; *STATX; ION                % CLEAR 55REP BIT
031771          GO FAR 5NOPAR; *)FILL
031774
031774   %-------------------------------------------------------------------------------
031774   IEPLACE:     % FUNCTION=056: END-PLACE
031774   IWRGS:       % FUNCTION=011: WRITE REGISTERS
031774          T:=NREGS SH 2; A:=5P1; CALL FRUSMOVE  % COPY REGISTER CONTENTD FROM USER TO MON60 BUFFER
032000          GO FAR 5NOPAR; *)FILL
032003
032003   %-------------------------------------------------------------------------------
032003   IMRESSPES:   % FUNCTION=061: RESERVE MEORY FOR THE ND-500 TEST-MONITOR
032003          IF 5D11 = -1 AND 5D12 >< -1 THEN
032013             IF A-1>>NCPU-1 GO FAR EEILPAR             % CHECK IF ND-500 CPU SPECIFIED?
032020             A*5CPUDFSZ+"S5CPUDF"=:X=:CCPUDF           % CCPUDF=CURRENT ND-500 CPU DF.
032024             IF X.SPREF><0 AND A><RTREF GO FAR EESPRES % ERROR IF THIS CPU IS ALREADY RESERVED FOR SPECIAL USE BY ANOTHER
032031          FI
032031   OUT:   CALL TUSON; GO FAR ERET                      % ANY OTHER USING THIS CPU NOW?
032033          GO FAR 5NOPAR; *)FILL                        % NO, RESERVED FOR SPECIAL USE BY THE CALLER
032044
032044   %-------------------------------------------------------------------------------
032044   IDEFHIST:    % FUNCTION=062: DEFINE HISTOGRAM
032044          IF 5HRTP><0 AND A><RTREF THEN EHIUSED; GO FAR ERET FI  % HISTOGRAM ALREADY IN USE BY ANOTHER
032053          RTREF=:5HRTP; 0=:5HIFLAG                            % SET ND-500 CPU AND SPECIFY PROC TO RUN HISTOGRAM ON
032056          AD:=5DD3                                            % AD=NUMBER OF INTERVALS
032057          IF A><0 OR D>>100 OR D=0 GO FAR EEILPAR             % 100B INTERVAL IS MAX
032065          A:=D=:5HICHANNELS
032067          AD:=5DD2                                            % AD=INTERVAL SIZE
032070          IF A><0 OR D=0 GO FAR EEILPAR
032073          A:=D=:5HINTERVAL; AD:=5DD1=:5HISTART                % 5HISTART=START OF FIRST INTERVAL
032077          X:="5HIDATA"
032100          DO WHILE X<<="5HIOUTSIDE"+1; 0=:X.S0; X+1; OD       % CLEAR HISTOGRAM SAMPLING BUFFER
032107          GO FAR 5OKRET; *)FILL
032124
032124   %-------------------------------------------------------------------------------
032124   ISTAHIST:    % FUNCTION=063: START HISTOGRAM
032124          IF RTREF><5HRTP THEN EHNRESERVED; GO FAR ERET FI    % HISTOGRAM RESERVED BY CALLER?
032132          IF 5HIFLAG><0 GO FAR 5OKRET
032135          5PRDESCR-"S500S"; A=:D:=0; T:=5PRDSIZE; *RDIV ST    % COMPUTE PROC.NO OF CALLER
032143          A-1*2+"F5DSG"=:T; X:="5RPRONO"
032150          CALL GET1L; CALL ERRFATAL; A=:5D12
032153          IF 5HIFLAG=0 THEN
032155             *IOF                                             % YES
032156             CALL HIMFEXQUEUE; 0/\0                           % MAKE SURE HISTOGRAM MESS IS NOT IN EX-QUEUE
032160             CALL SLOCK; 0/\0;
032162             5D12-5SWPROC*5PRDSIZE+"S500S"; X:=A.MESSBUFF
032170             T:=5MBBANK; *AAX 5MSFL; LDATX; 5CPUB@3 BLDA DA
032174             A BONE 5CPUBOUND; *5SCPU@3 BSTA DA; STATX
032177             *AAX 5CPUN-5MSFL; LDATX
032201             X:=HIMESS; *AAX 5CPUN; STATX
032204             5D12; *AAX WANTP-5CPUN; STATX; AAX -WANTP        % PROC.NO. INTO HISTOGRAM MESSAGE
032210             CALL GCPUDF; CALL ERRFATAL; A=:B
032213             CALL ITO500XQ                                    % INSERT HISTOGRAM MESS IN EX-QUEUE
032214             CALL SUNLOCK
032215             1=:5HIFLAG                                       % MARK THAT HISTOGRAM SAMPLING IS STARTED
032217             *ION
032220             "N500DF"=:B
032222          FI
032222          GO FAR 5OKRET; *)FILL
032251
032251   %-------------------------------------------------------------------------------
032251   ISTOHIST:    % FUNCTION=064: STOP HISTOGRAM
032251          IF RTREF><5HRTP THEN EHNRESERVED; GO FAR ERET FI    % ERROR WHEN HISTOGRAM NOT RESERVED BY CALLER
032257          IF 5HIFLAG=1 THEN CALL RLHILOG FI; 0=:5HRTP         % IS HISTOGRAM STARTED?
032265          GO FAR 5OKRET; *)FILL
032275
032275   %-------------------------------------------------------------------------------
032275   IREAHIST:    % FUNCTION=065: READ HISTOGRAM
032275          IF RTREF><5HRTP THEN EHNRESERVED; GO FAR ERET FI    % ERROR WHEN HISTOGRAM NOT RESERVED BY CALLER
032303          T:=5P1; A:="5HIDATA"=:D; X:=200; A:=OLDPAGE         % COPY HISTOGRAM DATA TO USER FROM "5HIDATA"
032310          K:=1; CALL MOVUS                                    %   SIZE EQUALS 2 WORDS PER CHANNEL (=64)
032312          5P1+200=:X; AD:=5HIOUTSIDE; CALL STDS0              % COPY SAMPLING OF 'OUSIDE CHANNELS' SEPARATELY
032317          GO FAR 5OKRET; *)FILL
032332
032332   %-------------------------------------------------------------------------------
032332   IRELHIST:    % FUNCTION=066: STOP AND RELEASE HISTOGRAM
032332          IF RTREF><5HRTP THEN EHNRESERVED; GO FAR ERET FI    % ERROR WHEN HISTOGRAM NOT RESERVED BY CALLER
032340          IF 5HIFLAG><0 THEN CALL RLHILOG FI; 0=:5HRTP
032344          GO FAR 5OKRET; *)FILL
032354
032354   %-------------------------------------------------------------------------------
032354   ISPRNM:      % FUNCTION=074: SET NAME ON CURRENT PROCESS
032354   IPRACTIVE:   % FUNCTION=136: ACTIVATE STOPPED PROCESS
032354          A:=5P1; T:=50; CALL FRUSMOVE          % COPY PROCESS NAME TO MON60 BUFFER
032357          GO FAR 5NOPAR; *)FILL
032362
032362   %-------------------------------------------------------------------------------
032362   ITSTUSER:    % FUNCTION=075: CHECK IF CURRENT USER IS USER SYSTEM
032362          IF 5PASSTYPE=2 GO FAR 5OKRET              % PASSTYPE=2 MEANS USER SYSTEM
032366          GO FAR EENAUTORISED; *)FILL               % ERROR, NOT USER SYSTEM
032372
032372   %-------------------------------------------------------------------------------
032372   ITOSWP:      % FUNCTION=076: MESSAGE TO SWAPPER
032372          A:=5P1+7; T:=55MESSIZE-7 SH 1; CALL FRUSMOVE % COPY MESSAGE TO MON60 BUFFER
032400          GO FAR 5NOPAR; *)FILL
032404
032404   %-------------------------------------------------------------------------------
032404   IRMESS:      % FUNCTION=077: READ MESSAGE
032404          IF 5D11=0 AND 5D12>>=5SWPROC THEN         % READ ONE SPECIFIC MESSAGE?
032412              IF A=-1 THEN                          % YES, -1= OWN PROCES
032415                 X:=5PRDESCR
032416              ELSE
032417                 IF A>>MX5PROCS GO FAR EEILPAR      % LEGAL PROC. NO?
032422                 A-5SWPROC*5PRDSIZE+"S500S"=:X      % X=ADDR OF ACTUAL PROC.DESCR.
032426              FI; X.MESSBUFF
032427           ELSE
032430              GO FAR ILLFUNC                        % NOT IMPLEMENTED (ILLEGAL FUNCTION CODE)
032431           FI; A=:D; A:=5MBBANK; CALL XSUPDWINDOW   % SETUP WINDOW TO MESSAGE
032434           A:="55MESSIZE-55MSNEGSIZE-3" SH 1; T:=5P2
032437           CALL TOUSMOVE                            % COPY MESSAGE TO USER'S BUFFER
032440           GO FAR 5OKRET; *)FILL
032453
032453   %-------------------------------------------------------------------------------
032453   RRFLAG:      % FUNCTION=100: READ FLAGS FROM ND-500 DATA SEGMENT
032453   WWFLAG:      % FUNCTION=101: WRITE FLAGS INTO ND-500 DATA SEGMENT
032453          IF 5D12=-1 THEN                                     % 5D12 = PROCESS NUMBER
032457             X:=5PRDESCR                                      % -1 MEANS OWN PROCESS
032460          ELSE
032461             IF A<<=5SWPROC OR A>>MX5PROCS GO FAR EEILPAR     % LEGAL PROCESS NUMBER ?
032467             A-5SWPROC*5PRDSIZE+"S500S"=:X                    % X=ACTUAL PROCESS DESCR
032473             IF X.RTRES=0 GO FAR EEILPAR                      % ERROR IF PROC. NOT IN USE
032476          FI; X=:5D32
032477   %      A:=X-"S500S"=:D:=0; T:=5PRDSIZE; *RDIV ST           % COMPUTE PROCESS NUMBER
032477   %      A-1*2+"F5DSG"=:T; CALL M1MEXY; T=:5OLDSEG           % GET ACTUAL ND-500 DATA SEGMENT
032477          X:=X.MESSBUFF; T:=5MBBANK; *SENDE@3 LDATX
032502          A-5SWPROC*2+"F5DSG"=:T; CALL M1MEXY; T=:5OLDSEG           % GET ACTUAL ND-500 DATA SEGMENT
032510          IF 5FUNCTION=5RFLAG THEN                            % WHICH FUNCTION?
032514             AD:="FF500".DS0=:5DD2                            % READ FLAGS
032517          ELSE
032520             IF 5D32><5PRDESCR THEN                           % WRITE TO OWN PROC?
032524                IF BACKGROUND><0 AND 5PASSTYPE=0 GO FAR EENAUTHORISED % ONLY ALLOWED FROM RT-PROGR OR USER SYSTEM
032531             FI; AD:=5DD2=:"FT500".DS0                        % WRITE FLAGS
032534          FI; T:=5OLDSEG; CALL M1MEXY                         % GET CALLER'S ORIGINAL SEGMENTS
032536          IF 5FUNCTION=5RFLAG THEN
032542             X:=5P2; AD:=5DD2; CALL STDS0                     % COPY FLAGS TO USER
032545          FI; GO FAR 5OKRET; *)FILL
032566
032566   INTEGER FORGPRNO
032567   %-------------------------------------------------------------------------------
032567   IFORGET:     % FUNCTION=102: STOP ND-500 SYSTEM (ABORT ALL ACTIVE PROCS, AND RELEASE MON60 BUFFERS)
032567          *IOF
032570          RTREF=:NSPREF                                       % ND-500 CPU RESERVED FOR SPECIAL USE
032572          SYSINITFLAG BONE B5STOP=:SYSINITFLAG                % MARK SYSTEM IN STOP-ND-500 MODE
032575          CCPUDF=:B; N5STOPPED; CALL RSTARTALL                % REMOVE ALL PROCS. FROM EX-QUEUE
032601          *ION
032602          "N500DF"=:B; 5SWPROC+1=:FORGPRNO
032607          X:="S500S"+5PRDSIZE
032611          FOR FORGPRNO DO WHILE FORGPRNO<<=MX5PROCS           % ABORT ALL ACTIVE PROCS.
032615             IF X.RTRES><0 AND A><RTREF THEN                  % PROC USED AND NOT USED BY CALLER?
032622                *IOF                                          % YES
032623                X=:D
032624                IF A.STATUS BIT 5BACKGROUND THEN              % BACKGROUND PROCESS?
032630                   A BONE 5ESCF=:X.STATUS                     % YES, SET ESCAPE PRIORITY OF SHADOW PROCESS
032632                FI
032632                D.PSTAT BONE 5SYSABORT=:X.PSTAT               % MARK THAT PROC SHOULD BE ABORTED
032636                CALL SLOCK; 0/\0
032640                T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
032644                A BONE 5IBRK BONE 52ESCSET; *STATX            % MARK THAT PROC SHOULD BE ABORTED
032647                *AAX XADPR-5MSFL; LDXTX
032651                CALL SUNLOCK
032652                X.RTRES; *IRW MLEVB DX
032654                "SYSABORT"; *IRW MLEVB DP
032656                MLEV; *MST PIE; MST PID; ION
032662             FI; X+5PRDSIZE
032663          OD; GO FAR 5NOPAR; *)FILL
032702
032702   %-------------------------------------------------------------------------------
032702   IRSYSP:      % FUNCTION=103: READ SYSTEM VARIABLES
032702          "N500DF+SYSPAR"=:D; T:=5P1; X:=16
032706          A:=OLDPAGE; K:=1; CALL MOVUS              % COPY SYSTEM PARAMETERS TO USER
032711          GO FAR 5OKRET; *)FILL
032715
032715   %-------------------------------------------------------------------------------
032715   IWSYSP:      % FUNCTION=104: WRITE SYSTEM PARAMETERS
032715          T:="N500DF+SYSPAR"; X:=16; 5P1=:D; A:=OLDPAGE
032722          K:="0"; CALL MOVUS                        % COPY SYSTEM PARAMETERS TO N500DF
032724          GO FAR 5NOPAR; *)FILL
032730
032730   %-------------------------------------------------------------------------------
032730   IWPHSG:      % FUNCTION=110: WRITE INTO A PHYSICAL SEGMENT
032730          AD:=5DD3
032731          IF A><0 OR D>>4000 THEN              % 4000B BYTES ARE MAX TO WRITE
032735             EBIGBUFF; GO FAR ERET
032737          FI
032737          T:=5D32; A:=5P4; CALL FRUSMOV        % COPY FROM USER TO MON60 BUFFER
032742          GO FAR 5NOPAR; *)FILL
032750
032750   %-------------------------------------------------------------------------------
032750   ISTAPRLOG:   % FUNCTION=111: START PROCESS LOG ONE
032750          IF 5HRTP><0 AND A><RTREF THEN ELOGINUSE; GO FAR ERET FI % LOGGING FACILITY RESERVED BY ANOTHER?
032757          IF 5HIFLAG><0 AND A><2 THEN ELOGINUSE; GO FAR ERET FI   % ANOTHER LOGGING FUCTION ALREADY DEFINED BY CALLER
032766          AD:=5DD1; IF A><0 OR D>>MX5PROCS GO FAR EEILPAR         % LEGAL PROC.NO. TO LOG?
032773          A:=D=:5LOGPROC; RTREF=:5HRTP                            % SPECIFY PROC.NO. TO LOG,
032777                                                                  %   WHO IS LOGGING AND ON WHICH CPU
032777          2=:5HIFLAG; X:="5HIDATA"                                % MARK THAT LOGGING IS STARTED
033002          DO WHILE X<<="5HIOUTSIDE"+1; 0=:X.S0; X+1; OD           % CLEAR HISTOGRAM SAMPLING BUFFER
033011          GO FAR 5OKRET; *)FILL
033025
033025   %-------------------------------------------------------------------------------
033025   ISTOLOG:     % FUNCTION=112: STOP LOGGING
033025          IF 5HRTP><RTREF THEN ELOGNRESERVED; GO FAR ERET FI  % LOGGING FACILITY RESERVED BY CALLER?
033033          0=:5HIFLAG; GO FAR 5OKRET; *)FILL                    % YES, MARK THAT LOGGING IS STOPPED
033043
033043   %-------------------------------------------------------------------------------
033043   IPRILOG:     % FUNCTION=113: READ LOG DATA (PRINT LOG INFO)
033043          IF 5HRTP><RTREF THEN ELOGNRESERVED; GO FAR ERET FI  % LOGGING FACILITY RESERVED BY THE CALLER?
033051          IF 5HIFLAG=2 THEN                                   % YES, WHICH LOG FUNCTION?
033055             T:=16                                            % PROCESS-LOG-ONE
033056          ELSE                                                % PROCESS-LOG-ALL
033057             0=:"5HIDATA".S2; T:=MX5PROCS+1=:X.S3+3 SH 1
033066          FI; X:=T; "5HIDATA"=:D; T:=5P2; A:=OLDPAGE
033073          K:=1; CALL MOVUS                                    % COPY SAMPLED DATA TO USER FROM "5HIDATA"
033075          AD:=5DD1
033076          IF A=0 AND D=0 THEN                                 % SHOULD LOGGING-DATA-BUFFER BE CLEARED?
033101             X:="5HIDATA"                                     % YES, CLEAR LOGGING-DATA-BUFFER
033102             DO WHILE X<<="5HIOUTSIDE"+1; 0=:X.S0; X+1; OD    % YES, CLEAR LOGGING-DATA-BUFFER
033111          FI; GO FAR 5OKRET; *)FILL
033124
033124   %-------------------------------------------------------------------------------
033124   IRELLOG:     % FUNCTION=114: STOP LOGGING AND RELEASE LOGGING FACILITY
033124          IF 5HRTP><RTREF THEN ELOGNRESERVED; GO FAR ERET FI  % LOGGING FACILITY RESERVED BY THE CALLER?
033132          0=:5HIFLAG=:5HRTP; GO FAR 5OKRET; *)FILL             % YES, STOP LOGGING AND RELEASE LOGGING FACILITY
033143
033143   %-------------------------------------------------------------------------------
033143   ISTLAPR:     % FUNCTION=115: START PROCESS-LOG-ALL.
033143          IF 5HRTP><0 AND A><RTREF THEN ELOGINUSE; GO FAR ERET FI % LOGGING FACILITY RESERVED BY ANOTHER PROC?
033152          IF 5HIFLAG><0 AND A><3 GO FAR ILLFUNC      % NO, ALREADY USED BY THE CALLER FOR OTHER LOGGING FUNC.?
033157          RTREF=:5HRTP                               % NO, SPECIFY PROC. USING LOGGING FACILITY AN ON WHICH CPU
033161          X:="5HIDATA"
033162          DO WHILE X<<="5HIOUTSIDE"+1; 0=:X.S0; X+1; OD       % YES, CLEAR LOGGING-DATA-BUFFER
033171          3=:5HIFLAG                                          % MARK THAT PROCESS-LOG-ALL IS STARTED
033173          GO FAR 5OKRET; *)FILL
033205
033205   %-------------------------------------------------------------------------------
033205   IPRABORT:    % FUNCTION=117: ABORT PROCESS
033205   ILOGOFF:     % FUNCTION=122: LOGOFF PROCESS
033205          IF 5D11><0 OR 5D12<<=5SWPROC OR A>>MX5PROCS GO FAR EEILPAR  % LEGAL PROCESS NUMBER?
033216          A-5SWPROC*5PRDSIZE+"S500S"
033221          IF A.RTRES=0 GO FAR 5OKRET                          % YES, IS THIS PROC. RESERVED BY ANYONE?
033225          A=:D                                                % D=RT-DESCR. OF ACTUAL PROCS. OWNER.
033226          IF 5FUNCTION=PRSTOP THEN                            % IS FUNCTION ABORT-PROCESS?
033232             IF D=RTREF THEN                                  % ABORT CALLER?
033235                ABREL=:5FUNCTION; GO FAR 5NOPAR               % YES, CHANGE FUNCTION TO "ABREL"
033240             FI; *IOF
033241             X.PSTAT BONE 5SYSABORT BZERO SOFFLOGG            % MARK THAT PROC. SHOULD BE ABORTED
033244          ELSE                                                % LOGOFF PROC.
033245             IF D=RTREF THEN                                  % LOGOFF CALLER?
033250                *IOF
033251                X.PSTAT BONE SOFFLOGG BZERO 5SYSABORT=:X.PSTAT % MARK THAT PROC SHOULD BE LOGGED OFF
033255                *ION
033256                XN5REL=:5FUNCTION; GO FAR 5NOPAR              % YES, CHANGE FUNCTION TO "XN5REL"
033261             FI; *IOF
033262             X.PSTAT BONE SOFFLOGG BZERO 5SYSABORT            % MARK THAT PROC SHOULD BE LOGGED OFF
033265          FI
033265   INPRABORT:                                                 % A=PSTAT; INTERRUPT OFF
033265          A=:X.PSTAT                                          % MARK THAT PROC IS "IN-BREAK" STATUS
033266          CALL SLOCK; 0/\0
033270          T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
033274          A BONE 5IBRK BONE 52ESCSET; *STATX                  % MARK THAT PROC IS "IN-BREAK" STATUS
033277          *AAX XADPR-5MSFL; LDXTX
033301          CALL SUNLOCK
033302          X.RTRES; *IRW MLEVB DX
033304          "SYSABORT"; *IRW MLEVB DP
033306          MLEV; *MST PIE; MST PID; ION
033312          GO FAR 5OKRET; *)FILL
033327
033327   %-------------------------------------------------------------------------------
033327   IMRELSPES:   % FUNCTION=123: RELEASE ND-500 AND MEMORY FROM THE TEST-MONITOR
033327          IF CCPUDF.SPREF><RTREF GO FAR 5OKRET       % RESERVED FOR SPECIAL USE BY THE CALLER?
033334          GO FAR 5NOPAR; *)FILL                      % YES, CONTINUE TO RELEASE MEMORY
033340
033340   %-------------------------------------------------------------------------------
033340   ISTAMLOG:    % FUNCTION=124: START MONITOR CALL LOG
033340          IF 5MLOG><RTREF AND A><0 THEN ELOGINUSE; GO FAR ERET FI % MONCALL LOG IN USE BY ANOTHER PROC?
033347          AD:=5DD1                                            % NO, ITS FREE
033350          IF A><0 OR D><0 THEN                                % LOG MONCALLS FOR ALL PROCS OR FOR OWN?
033353             IF BACKGROUND><0 AND 5PASSTYPE><2 GO FAR EENAUTORISED % LOG FOR ALL, ALLOWED FOR USER SYSTEM ONLY
033361             A:= -1                                           % 5LOGPROC=-1 MEANS LOG MONCALLS FOR ALL PROCS
033362          ELSE                                                % LOG MONCALLS FOR OWN PROCESS ONLY
033363             5PRDESCR-"S500S"; A=:D:=0; T:=5PRDSIZE; *RDIV ST % COMPUTE PROC.NO OF CALLER
033371             A-1*2+"F5DSG"=:T; X:="5RPRONO"
033376             CALL GET1L; CALL ERRFATAL
033400          FI; A=:5MLOPROC; RTREF=:5MLOG                       % SPECIFY WHICH PROC TO LOG AND WHO IS USING MONCALL LOG
033403          A:=5FBUM60=:D:=0; AD SH 12; T:=A; X:=D              % FIRST MON60 BUFFER IS USED FOR MONCALL LOGGING
033411          A:=1776+X=:L                                        % L=END OF MON60 BUFFER -2
033414          A:=0; D:=0
033416          DO
033416             *STDTX                                           % CLEAR MONCALL LOG BUFFER
033417          WHILE X><L
033421             X+2
033422          OD; GO FAR 5OKRET; *)FILL
033444
033444   %-------------------------------------------------------------------------------
033444   IPRIMLOG:    % FUNCTION=125: READ MONCALL LOG DATA (PRINT MONCALL LOG)
033444          IF 5MLOG><RTREF THEN ELOGNRESERVED; GO FAR ERET FI  % MONCALL LOG RESERVED BY THE CALLER?
033452          A:=5FBUM60=:D:=0; AD SH 12; CALL XSUPDWINDOW    % YES, SETUP WINDOW TO MONCALL LOG DATA BUFFER
033457          A:=3000; T:=5P1; CALL TOUSMOVE                  % COPY MONCALL LOG DATA TO USER FROM MONCALL LOG DATA BUFFER
033462          GO FAR 5OKRET; *)FILL
033473
033473   %-------------------------------------------------------------------------------
033473   ISTOMLOG:    % FUNCTION=126: STOP AND RELEASE MONCALL LOG
033473          IF 5MLOG><RTREF THEN ELOGNRESERVED; GO FAR ERET FI  % MONCALL LOG RESERVED BY THE CALLER?
033501          0=:5MLOG=:5MLOPROC; GO FAR 5OKRET; *)FILL            % STOP AND RELEASE MONCALL LOG.
033512
033512   %-------------------------------------------------------------------------------
033512   INDFSYDOM:   % FUNCTION=161: DEFINE STANDARD DOMAIN (NEW DOMAIN FORMAT)
033512   IDFSYDOM:    % FUNCTION=127: DEFINE STANDARD DOMAIN
033512          A:=5P1; T:=4000; CALL FRUSMOVE        % COPY STANDARD-DOMAIN INFO TO MON60 BUFFER
033515          GO FAR 5NOPAR; *)FILL
033521
033521   %-------------------------------------------------------------------------------
033521   ILI5EXQ:     % FUNCTION=133: LIST ND-500 EX-QUEUE
033521          K:="0"; GO FAR ILI5F; *)FILL                  % K=ROUTINE SWITCH
033524
033524   %-------------------------------------------------------------------------------
033524   IPLDEB:      % FUNCTION=134: PLACE DEBUGGER
033524          A:=5P2; T:=200; CALL FRUSMOVE         % COPY DEBUGGER NAME TO MON60 BUFFER
033527          GO FAR 5NOPAR; *)FILL
033533
033533   %-------------------------------------------------------------------------------
033533   IABLOG:      % FUNCTION=135: LOGG OFF PROCESS AND ABORT RT-PROGRAM.
033533           IF 5D11><0 GO FAR EEILPAR                % 5DD1=RT-DESCR ADDR
033536           IF X:=5D12=0 THEN X:=RTREF FI            % RT-DESCR=0 MEANS CALLING PROGR
033542           IF X.STATUS BIT 5BACKGR GO FAR EEILPAR   % ONLY RT-PROGR. CAN BE ABORTED
033545           CALL GOODRT; GO FAR EEILPAR          % LEGAL RT-DESCR ADDR?
033547           *IOF
033550           5DD1; CALL FSEMA; GO FAR 5ABPROG         % YES, HAS IT RESERVED A ND-500 PROC?
033553           X.PSTAT BONE 5SYSABORT BONE SOFFLOG      % 5SYSABORT=1 AND SOFFLOG=1 MEANS LOGG OFF ND-500 PROC
033556           GO FAR INPRABORT; *)FILL                 % A=PSTAT; INTERRUPT OFF
033565
033565   %-------------------------------------------------------------------------------
033565   FPRACTIVE:   % FUNCTION=136: ACTIVATE STOPPED PROCESS
033565          ZPREG-1=:ZPREG                            % SKIP-RETURN ALREADY GIVEN BY SYS.MON??????????
033570          IF 5D12<<=5SWPROC OR A>>MX5PROCS GO FAR EEILPAR   % LEGAL PROCESS NUMBER?
033577          A-5SWPROC*5PRDSIZE+"S500S"=:X                     % X=ACTUAL PROC'S PROC.DESCR
033603          IF T:=X.RTRES=0 GO FAR EEILPAR            % ACTUAL PROCESS IN USE?
033606          T:=5MBBANK; X:=X.MESSBUFF; *AAX MAGNO; LDXTX
033612          IF X><5D11 GO FAR EEILPAR                 % CORRECT MAGNO?
033615          *IOF
033616          X:=A; CALL 5PRACTIVATE; 0/\0              % ACTIVATE ND-500 PROC (OR SET 55REP BIT)
033621          *ION
033622          GO FAR 5OKRET; *)FILL
033633
033633
033633   IIM5RT:  A:=153100; GO 5ABFELL
033635   5ABPROG: A:=153105
033636   5ABFELL: A=:D; MLEV; *MST PIE; ION
033642            "5D12"+B=:5D11
033645            A:="5D11"+B; *EXR SD               % EXECUTE MON RT/MON ABORT
033650            GO FAR 5OKRET; *)FILL
033656
033656   %-------------------------------------------------------------------------------
033656   IMO5RT:      % FUNCTION=143: ACTIVATE PROGRAM EITHER IN ND-500 OR IN ND-100
033656           AD:=5DD1; IF A><0 GO FAR EEILPAR         % AD=RT-DESCR ADDR
033661           IF D=0 THEN T:=RTREF=:D FI; AD=:5DD1     % RT-DESCR=0 MEANS CALLING PROGR
033666           X:=D; CALL GOODRT; GO FAR EEILPAR    % LEGAL RT-DESCR ADDR.?
033671           *IOF
033672           5DD1; CALL FSEMA; GO FAR IIM5RT          % YES, HAS IT RESERVED A ND-500 PROC.?
033675           CALL 5PRACTIVATE; 0/\0                   % YES, ACTIVATE ND-500 PROC.
033677           GO FAR IIM5RT; *)FILL
033706
033706   %-------------------------------------------------------------------------------
033706   ICHACPU:     % FUNCTION=144: CHANGE CPU
033706          IF 5D12-1>>NCPU-1 GO FAR EEILPAR
033714          A*5CPUDFSZ+"S5CPUDF"=:X                   % YES
033717          IF X.CPUAVAILABLE NBIT 5ALIVE THEN ENOCPU; GO FAR ERET FI
033724          IF T:=BACKGROUND><0 AND T:=5PASSTYPE=0 THEN % PUBLIC USER?
033732             IF A BIT 5EXCLUDE THEN ENAUTHORISED; GO FAR ERET FI
033736          FI
033736          IF X.SPREF><0 AND A><RTREF GO FAR EESPRES % RESERVED FOR SPECIAL USE BY ANYONE ELSE?
033743          X=:D:=5PRDESCR.MESSBUFF
033746          CALL GCPUDF; CALL ERRFATAL
033750          IF A.SPREF=RTREF AND X><D THEN            % CPU CHANGED AND OLD CPU-DF RESERVED FOR SPECIAL USE BY THE CALLER?
033757             CALL RELCPU                            % RELEASE OLD CPU-DF FROM SPECIAL USE
033760          FI
033760          5D12-1*5CPUDFSZ+"S5CPUDF"=:X
033765          A:=X.CPUNO; T:=5MBBANK; X:=5PRDESCR.MESSBUFF
033771          *IOF
033772          *AAX 5CPUN; STATX                         % SAVE ADDR OF NEW CPU-DF IN MESSAGE
033774          *AAX 5MSFL-5CPUN; LDATX                   % SET CPU-BOUND PROCESS
033776          A BONE 5CPUBOUND; *STATX
034000          *ION
034001          GO FAR 5OKRET; *)FILL
034020
034020   %-------------------------------------------------------------------------------
034020   ISSTDOM:          % FUNCTION=145: START SYSTEM DOMAIN FROM SIN3 COMMAND
034020          0=:5P1; GO FAR 5NOPAR; *)FILL              % MARK THAT RETURN TO SIN3 OPCOM ON ESCAPE
034023
034023   %-------------------------------------------------------------------------------
034023   ILI5TQU:     % FUNCTION=150: LIST ND-500 TIME-QUEUE
034023          K:=1; GO ILI5F; *)FILL                    % K=ROUTINE SWITCH
034025
034025   % ILI5EXQ:     K=0 -> FUNCTION=133: LIST ND-500 EX-QUEUE
034025   % ILI5TQU:     K=1 -> FUNCTION=150: LIST ND-500 TIME-QUEUE
034025   % Must both access X5PROC instead of C5PROC
034025   % and do so using "fool cache" ...
034025   %
034025   %
034025   ILI5F: *IOF                                                % THESE ROUTINES MUST BE EXECUTED IN IOF!
034026          CURPROG.BUFWINDOW=:D; A:=142000                     % PHYS.PAGE OF MON60 BUFFER TO RT-DESCR
034032          X:="WNDBF+WNDBF+174000"; T:=0; *STDTX               % SET PIT ENTRY
034035          IF K THEN
034037             AD:=5ATIME=:LOGBADR.DS0; X+2=:L                  % SAVE 5ATIME FIRST IN BUFFER
034044             X:=X500DF; *AAX X5BTI
034046          ELSE
034047             CCPUDF=:B; CALL GETC5PROC
034052             A=:"N500DF".LOGBADR.S0; X+1=:L                   % SAVE CURRENT ACTIVE PROC FIRST IN BUFFER
034057             X:=MAILINK; *AAX X5BEX                           % D=FIRST FREE ADDR IN BUFFER; X=START OF EX-QUEUE
034061          FI
034061          DO
034061             T:=5MBBANK; *LDDTX
034063          WHILE D><-1                                         % -1 IS END OF EX-QUEUE AND TIME-QUEUE
034066   *NNC40,   CNVBYADR
034071             IF X:=D><DUMMESS THEN
034075                T:=A; *SENDE@3 LDATX
034077                IF A=:D><-1 THEN                                 % PROC.NO=-1 IS HISTOGRAM OR WATCHDOG MESS
034103                   IF K THEN                                     % LIST-TIME-QUEUE
034105                      X:=:L; A=:X.S0; X+1:=:L                    % PROCESS NUMBER
034111                      T:=5MBBANK; *AAX D5TIM; LDDTX; AAX -D5TIM  % START-TIME OF PROC
034115                   ELSE                                          % LIST-EXEC-QUEUE
034116                      T:=5MBBANK; *AAX 5PRIO; LDATX; AAX -5PRIO
034122                      A:=:D
034123                   FI
034123                   X:=:L; AD=:X.DS0; X+2:=:L
034127                FI
034127             FI
034127   ILIEOD:OD
034130          -1=:L.S0                                            % -1 IN BUFFER IS END OF DATA
034133          "N500DF"=:B
034135          *ION
034136          A:=X-LOGBADR SH 1 + 2                               % NUMBER OF BYTES TO MOVE
034142          T:=5P1; CALL TOUSMOVE                               % COPY DATA (EX-QOUE OR TIME-QUEUE), TO USER
034144          GO FAR 5OKRET; *)FILL
034157
034157   %-------------------------------------------------------------------------------
034157   IDBUGSW:     % FUNCTION=154: DEBUG SWAPPER <ON/OFF>
034157          IF 5D12=1 THEN CALL XTUSON; GO FAR ERET FI
034165          GO FAR 5NOPAR; *)FILL
034171
034171   %-------------------------------------------------------------------------------
034171   IN5SEGLOAD:  % FUNCTION=160: LOAD (PLACE), ONE SEGMENT (NEW DOMAIN FORMAT)
034171          A:=5P1; T:=12; CALL FRUSMOVE              % COPY SEGMENT NAME FROM USER TO MON60 BUFFER
034174          IF 5D41><0 THEN                           % ANY ND-100/ND-500 SHARED PARTS?
034176             A:=5P4; T:=300; X:=5; CALL XFRUSMOVE   % YES, COPY SHARD-INFO FROM USER TO MON60 BUFFER
034202          FI; GO FAR 5NOPAR; *)FILL
034207
034207   %-------------------------------------------------------------------------------
034207   INTEGER IP1
034210   INTEGER ARRAY PIP:=(IP1)
034211
034211   ICPUSTAT:    % FUNCTION=173: SET CPU STATUS
034211          IF 5D11><0 GO FAR EEILPAR
034214          IF 5D12-1>>NCPU-1 GO FAR EEILPAR
034222          IF 5D41><0 OR 5D42>>3 GO FAR EEILPAR
034230          5D12-1*5CPUDFSZ+"S5CPUDF"+"CPUAVAILABLE"=:X
034236          IF 5D22><0 THEN
034240             T:=5IDPIT; CALL GET1L; CALL ERRFATAL; A=:T
034244             5D42; AD SHZ -1; *BLDA 170 DD
034247             IF A=0 THEN
034250                *5NOTP@3 BSTA DT
034251             ELSE
034252                *5EXCL@3 BSTA DT
034253             FI
034253             T=:A:=5IDPIT; CALL PUT1L; CALL ERRFATAL
034257             "A5PIT"=:D; CALL DALTON                      % SET 5PIT AS ALT.PIT
034262             5IDPIT=:IP1; "PIP"; *MON 2WSEG
034266             CALL ALTOFF
034267          FI
034267          IF 5D32><0 THEN
034271             T:=5SDPIT; CALL GET1L; CALL ERRFATAL; A=:T
034275             5D42; AD SHZ -1; *BLDA 170 DD
034300             IF A=0 THEN
034301                *5NOTP@3 BSTA DT
034302             ELSE
034303                *5EXCL@3 BSTA DT
034304             FI
034304             T=:A:=5SDPIT; CALL PUT1L; CALL ERRFATAL
034310             "A5PIT"=:D; CALL DALTON                      % SET 5PIT AS ALT.PIT
034313             5SDPIT=:IP1; "PIP"; *MON 2WSEG
034317             CALL ALTOFF
034320          FI
034320          GO FAR 5OKRET; *)FILL
034335
034335   %-------------------------------------------------------------------------------
034335   DOUBLE IOFEXIT(0); *IOF; EXIT
034337   % COMMON POINT TO GO THROUGH BEFORE CALLING THE SYSTEM MONITOR
034337   5NOPAR: A:=5PRDESCR-"S500S"=:D:=0; T:=5PRDSZIE; *RDIV ST   % COMPUTE PROCESS NUMBER
034345          T:=RTREF.RSEGM=:5RSEGM; 0=:X.RSEGM                  % SAVE USER'S RSEGM AND SET RSEGM=0
034351          A-1*2+"F5DSG"=:T; CALL M1MEXY; T=:5OLDSEG           % GET IN ND-500 DATA SEGMENT
034357          IF N5FUNCTION><N5REL THEN
034363             IF A=N5RES OR 5FUNCTION=N5RES OR A=MRESSPES OR A=SSTDOM THEN
034400                "DASEGSTART+DSEGSIZE-2"=:L; A:=0=:D
034404                X:="DASEGSTART"; DO AD=:X.DS0; WHILE X<<L; X+2; OD % CLEAR ND500 DATA SEGMENT
034412                X:="DFIX5DSPAGE"; AD:=IOFEXIT=:X.DS0               % SET UP IOF;EXIT
034415             FI
034415          FI
034415          IF 5FUNCTION=N5RES THEN 5P1=:SGBRKADR FI
034423   NOPA1: IF 5FUNCTION=WISON OR A=TSTFUNC THEN
034432             SBUFFR=:B; D:=0; X:="S500S"
034436             DO WHILE D<<=MX5PROCS
034441                X.RTRES=:S1; B+1; D+1; X+5PRDSIZE             % COPY RTRES OF ALL PROCS TO SBUFFR ON ND-500 DATA SEGM
034446             OD; A:=D=:SBUFFER.S0                             % NUMBER OF ND-500 PROCS IN THIS SYSTEM
034452             "N500DF"=:B
034454          FI
034454          N5FUNCTION SH 10\/5FUNCTION=:5FUNCTION
034460          T:="S500DF"; A:="N500DF+ZPREG"=:D; A:=5DFSIZE=:L
034465          *MOVAA                                              % SAVE MONCALL INFO ON ND-500 DATA SEGM.
034466   TOSYMON: *IOF
034467          X:=RTREF; CALL BRELEASE; *ION                       % RELEASE N500DF DATAFIELD
034472          IF "S500DF-ZPREG".5FUNCTION/\377=FORGET THEN        % STOP-ND-500?
034500             CALL CFORGET
034501          FI
034501          IF BACKGROUND><0 THEN CALL ESCON FI                 % SET ESCAPE ON.
034504          CALL FPT2ENTRY                                      % ENTER ND-500 SYSTEM MONITOR
034505          GO FAR 5PT2RET                                      % NORMAL RETURN (ERROR AND OK)
034506          GO FAR SYMNLOAD                                     % ERROR, SYSTEM MONITOR NOT LOADED
034507   *)FILL
034534
034534   %==========================================================================
034534   %      ( 5 )    F U N C S
034534   %
034534   % TABLE OF ENTRY POINTS TO GO TO AFTER RETURNING FROM THE SYSTEM MONITOR
034534   % THE "MON 60" FUNCTION CODE IS INDEX IN THIS TABLE.
034534   @ICR
034534   INTEGER ARRAY FUNCS:=(
034534          FRREG,RET5,FPMREAD,FDMREAD,RET5,RET5,RET5,RET5,     % 000 - 007
034544          FRRGS,RET5,FPRSTART,FCONNFI,RET5,FRES5,FREL5,RET5,  % 010 - 017
034554          RET5,RET5,RET5,FRCNT,RET5,RET5,FDMEXA,RET5,         % 020 - 027
034564          FPMEXA,RET5,FDAMR,RET5,RET5,RET5,RET5,RET5,         % 030 - 037
034574          RET5,FRSTATU,FABRELS,RET5,RET5,RET5,RET5,RET5,      % 040 - 047
034604          RET5,FRIREG,RET5,RET5,RET5,RET5,RET5,FRMICV,        % 050 - 057
034614          FLIMEM,RET5,RET5,RET5,RET5,RET5,RET5,FSPRTE,        % 060 - 067
034624          FGPRTE,FSSGTE,FGSGTE,FRPHSG,RET5,RET5,RET5,RET5,    % 070 - 077
034634          RET5,RET5,FFORGET,RET5,RET5,FSPRIOR,RET5,0,         % 100 - 107
034644          RET5,RET5,RET5,RET5,RET5,RET5,FXN5REL,RET5,         % 110 - 117
034654          RET5,FRSWPDATA,RET5,RET5,RET5,RET5,RET5,RET5,       % 120 - 127
034664          FSFSYDOM,RET5,RET5,RET5,RET5,FABLOG,FPRACTIVE,0,    % 130 - 137
034674          RET5,RET5,RET5,RET5,RET5,FSSTDOM,RET5,FREL3,        % 140 - 147
034704          RET5,RET5,RET5,RET5,RET5,RET5,FNRMICV,FRCNT,        % 150 - 157
034714          RET5,RET5,RET5,RET5,RET5,RET5,FRDTRACE,RET5,        % 160 - 167
034724          FGCPUTYPE,RET5,FRSCRREG,RET5,RET5,RET5,RET5,RET5);  % 170 - 177
034734   @CR;
034734
034734   %-------------------------------------------------------------------------------
034734   % RETURN FROM REENTRAN SYSTEM MONITOR HERE.
034734   SYMNLOAD: ENOCPU=:"S500DF-ZPREG".ZAREG                     % ERROR, SYSTEM MONITOR NOT INITIALIZED
034737   5PT2RET: "N500DF"=:B; *IOF
034742   RESAGAIN: X:=RTREF; CALL BRESERVE                          % TRY TO RESERVE N500DF
034744          IF A<0 THEN                                         % ALREADY RESERVED?
034745             CALL FREXQU; CALL TOWQU; CALL ANTIJAMMER         % YES, WAIT FOR IT
034750             "STUPR"; *IRW MLEVB DP
034752             MLEV; *MST PID; ION
034755             GO 5PT2RET                                       % TRY TO RESERVE IT AGAIN (SHOULD HAVE IT NOW!)
034756          FI; *ION
034757          T:="ZPREG"+B; A:=5DFSIZE=:L; "S500DF"=:D
034765          *MOVAA                                              % COPY SAVED MONCALL INFO TO N500DF
034766          CALL SUPDWINDOW                                     % SET WINDOW ADDR TO MON60 BUFFER
034767          X:=5PRDESCR.MESSBUFF
034771          CALL GCPUDF; CALL ERRFATAL; A=:CCPUDF               % ACTUAL ND-500 CPU DF.
034774          5RSEGM=:RTREF.RSEGM; T:=5OLDSEG; CALL M1MEXY        % GET USER'S ORIGINAL SEGMENTS
035001          IF 5FUNCTION=SSTDOM THEN                            % START STANDARD-DOMAIN FROM S3 OPCOM
035005             IF ZAREG=ESCSTOP GO FAR FROMESC                  % ESCAPE WHILE USING SWAPPER
035011             CALL ESCOFF; CALL ALLRELEASE                     % SET ESCOFF AND RELEASE ALL ND-500 RESOURCES
035013             A:=5PRDESCR; CALL X5DCN                          % DISCONNECT XMSG
035015             X:=5TTIFIELD; *IOF
035017             CALL CHDFPAGE; X.FLAGB BZERO 5ESC2SET=:X.FLAGB   % CLEAR DELAYED ESCAPE INFO
035023             5BCOM=:X.BSTATE                                  % SET S3 OPCOM MODE
035025             CALL CLINONMSG                               % CLEAR IN5MSG/ON5MSG
035026             X:=RTREF; 5PRDESCR=:B; CALL BRELEASE             % RELEASE ND-500 PROC.
035032             "N500DF"=:B; GO MXRET                            % RETURN TO S3 OP.COM AFTER MON60
035035          FI
035035          IF ZAREG><0 THEN                                    % ERROR RETURN?
035037             IF A=ESCSTOP GO FAR FROMESC                      % YES, IS IT ESCAPE WHILE USING SWAPPER?
035042             IF 5FUNCTION><N5REL AND A><N5RES AND A><XN5REL AND A><ABREL GO FAR RET5
035057          FI; X:=5FUNCTION; *1BANK
035061          FUNCS(X); *2BANK
035063          A=:P                                                % GO TO ROUTINE ACCORDING TO
035064                                                              % "MON 60" FUNCTION CODE
035064   *)FILL
035117
035117
035117
035117   %-------------------------------------------------------------------------------
035117   FRREG:       % FUNCTION=000: READ A REGISTER
035117          X:=5P2; AD:=5DD2; CALL STDS0                    % COPY REGISTER VALUE TO USER
035122          GO FAR RET5
035123
035123   %-------------------------------------------------------------------------------
035123   FRSWPDATA:   % FUNCTION=121: READ FROM SWAPPERS DATA MEMORY (LOGICAL ADDRS)
035123   FPMREAD:     % FUNCTION=002: LOGICAL PROGRAM MEMORY READ
035123   FDMREAD:     % FUNCTION=003: LOGICAL DATA MEMORY READ
035123   FDAMR:       % FUNCTION=032: PHYSICAL DATA MEMORY READ
035123          X:=5P4; AD:=5DD4; CALL STDS0                    % COPY NO. OF BYTES READ TO USER
035126          T:=5P3; A:=5D42; CALL TOUSMOVE                  % COPY THE READ DATA TO USER
035131          GO FAR RET5
035132
035132   %-------------------------------------------------------------------------------
035132   FRRGS:       % FUNCTION=010: READ ALL REGISTERS
035132          A:=NREGS SHZ 2; T:=5P1; CALL TOUSMOVE           % COPY REGISTER CONTETNTS TO USER
035136          GO FAR RET5
035137
035137   %-------------------------------------------------------------------------------
035137   FPRSTART:    % FUNCTION=012: START ND-500 PROGRAM
035137   IFPRSTART:
035137          X:=5P1; AD:=5DD1; CALL STDS0                    % COPY STOP-REASON TO USER
035142          T:=5P2; A:=200; CALL TOUSMOVE                   % COPY "STOP (TRAP) INFO" TO USER
035145          GO FAR RET5
035146
035146   %-------------------------------------------------------------------------------
035146   FCONNFI:     % FUNCTION=013: CONNECT FILE
035146          X:=5P5; AD:=5DD5; CALL STDS0                    % COPY OPEN-FILE NUMBER TO USER
035151          GO FAR RET5
035152
035152
035152   %-------------------------------------------------------------------------------
035152   FRES5:       % FUNCTION=015: RESERVE ND-500 PROCESS
035152          T:=5P2; A:=11; CALL TOUSMOVE
035155          GO FAR RET5
035156
035156   %-------------------------------------------------------------------------------
035156   FXN5REL:     % FUNCTION=116: LOG OFF OWN PROCESS
035156   FREL5:       % FUNCTION=016: RELEASE ND-500 PROCESS
035156          A:=5PRDESCR; CALL X5DCN                             % CLOSE XMSG PORTS
035160          T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX 5MSFL; LDATX
035165          IF A BIT 5IBRK AND 5PRDESCR.PSTAT/\5RUNSTATUS><5USRBRK THEN
035175             % --- IN "BREAK" STATUS AND NOT RETURN TO S3 OP.COM
035175             IF A=5IDLE GO FAR RET5                           % YES, IS PROCESS IDLE?
035200             *IOF                                             % NO
035201             X.PSTAT/\5CLRUSTATUS+5IDLE=:X.PSTAT              % SET PROC. IDLE
035205             *ION
035206             GO FAR IFPRSTART                                 % COPY STOP-REASON AND STOP-REASON INFO TO USER
035207          FI
035207          GO IFABREL; *)FILL
035221
035221   INTEGER CTTIFIELD
035222
035222   %-------------------------------------------------------------------------------
035222   FRCNTS:      % FUNCTION=023: READ CONTROL STORE (equal for func=157)
035222          T:=5P3; A:=5D22 SH 1; CALL TOUSMOVE                % COPY CONTROL STORE DATA TO USER
035226          GO FAR RET5
035227
035227   %-------------------------------------------------------------------------------
035227   FSFSYDOM:    % FUNCTION=130: START STANDARD DOMAIN
035227   FSPRTE:      % FUNCTION=067: READ PROCESS ENTRY FROM SYS.MON
035227   FDMEXA:      % FUNCTION=026: DATA MEMORY EXAMINE (4 BYTES)
035227   FPMEXA:      % FUNCTION=030: PROGRAM MEMORY EXAMINE (4BYTES)
035227          X:=5P2; AD:=5DD2; CALL STDS0
035232          GO FAR RET5
035233
035233   %-------------------------------------------------------------------------------
035233   FRSTATU:     % FUNCTION=041: READ ND-500 INTERFACE STATUS
035233          X:=5P1; AD:=5DD1; CALL STDS0
035236          X:=5P2; AD:=5DD2; CALL STDS0
035241          X:=5P3; AD:=5DD3; CALL STDS0
035244          GO FAR RET5
035245
035245   %-------------------------------------------------------------------------------
035245   FABREL:      % FUNCTION=042: LOG OFF PROC. AND TERMINATE ND-100 PROGR.
035245   IFABREL:
035245          IF BACKGROUND><0 THEN CALL ESCOFF FI                % DISABLE ESCAPE
035250          CALL ALLRELEASE                                     % RELEASE ALL ND-500 LOCS.
035251          CALL RELREFS                                        % RELEASE ALL LOGGING FACILITIES.
035252          IF 5FUNCTION><FORGET THEN
035256             *IOF
035257             X:=5PRDESCR.MESSBUFF; CALL FRQUES                % REMOVE MESS FROM ANY QUEUE
035262             "N500DF"=:B
035264             *ION
035265          FI
035265          IF BACKGROUND><0 THEN
035267             X:=5TTIFIELD; *IOF
035271             CALL CHDFPAGE                                    % MAKE SURE THAT TERM.WINDOW PAGE IS IN PIT
035272             X.FLAGB BZERO 5ESC2SET BONE 5ESCON=:X.FLAGB      % CLEAR DELAYED ESCAPE AND SET ESCAPE ON
035276             X=:CTTIFIELD
035277          FI; X:=RTREF; 5PRDESCR=:B
035302          MLEV; *MCL PIE; ION
035305          CALL BRELEASE                                       % RELEASE PROCESS DESCR.
035306          "N500DF"=:B
035310          IF 5FUNCTION><FORGET THEN
035314             IF A><XN5REL AND A><ABREL THEN
035322                T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX 5MSFL; LDATX
035327                IF A NBIT 5IBRK GO FAR RET5
035331             FI
035331             T:=5MBBANK; X:=5PRDESCR.MESSBUFF
035334             *AAX 5ERRF; LDATX                                % ABORT-BATCH ABORT-JOB?
035336             IF A=1 THEN                                      % YES
035341                X:=RTREF; CALL BRELEASE                       % RELEASE N500DF
035343                T:=5MBBANK; X:=5PRDESCR.MESSBUFF
035346                *AAX 5BRG; LDATX; COPY SA DB                  % SET B-REG
035351                *AAX LRET-5BRG; LDXTX                         % X=ROUTINE ADDR TO ENTER
035353                "M5BABORT"; *IRW MLEVB DP
035355                MLEV; *MST PID; MST PIE
035360             FI
035360          FI
035360          IF 5FUNCTION=FORGET OR A=XN5REL
035365          OR 5PRDESCR.PSTAT BIT 5SYSABORT OR A BIT SOFFLOGG THEN
035375             T:=5BUSER
035376          ELSE
035377             IF 5FUNCTION=N5S3REL THEN T:=5ND5ESC ELSE T:="5BUSER+1" FI
035406          FI
035406          IF BACKGROUND><0 THEN
035410             *IOF
035411             T=:CTTIFIELD.BSTATE                              % SET BSTATE IN DATAFIEL
035413             "YBRTWT"; GO FAR SMLVROUTINE                     % START ROUTINE ON MONITOR LEVEL
035415          FI; MLEV; *MST PIE
035417          GO FAR RET5
035420   *)FILL
035441
035441   %-------------------------------------------------------------------------------
035441   FRIREG:      % FUNCTION=051: READ INTERFACE (COMMUNICATION), IODATUT REGISTER
035441   FRMICV:      % FUNCTION=057: READ MICRO PROGRAM VERSION
035441          X:=5P1; AD:=5DD1; CALL STDS0
035444          GO FAR RET5
035445
035445   %-------------------------------------------------------------------------------
035445   FLIMEM:      % FUNCTION=060: LIST MEMORY CONFIGURATION
035445          T:=5P1; A:=74; CALL TOUSMOVE                    % COPY MEMORY CONF. TABLE TO USER
035450          GO FAR RET5
035451   %-------------------------------------------------------------------------------
035451   FGPRTE:      % FUNCTION=070: READ A PROCESS TABLE ENTRY FROM THE SYS.MON
035451          A:=250; T:=5P2; CALL TOUSMOVE; GO FAR RET5
035455
035455
035455   %-------------------------------------------------------------------------------
035455   FSSGTE:      % FUNCTION=071: SEARCH FOR AND READ A PHYS.SEGMENT TABLE ENTRY FROM SYS.MON.
035455          A:=154; T:=5P2; CALL TOUSMOVE; GO FAR RET5
035461
035461   %-------------------------------------------------------------------------------
035461   FGSGTE:      % FUNCTION=072: READ A PHYS.SEGMENT TABLE ENTRY FROM SYS.MON
035461          A:=154; T:=5P2; CALL TOUSMOVE; GO FAR RET5
035465
035465   %-------------------------------------------------------------------------------
035465   FRPHSG:      % FUNCTION=073: READ FROM A PHYSICAL SEGMENT
035465          X:=5P5; AD:=5DD5; CALL STDS0
035470          A:=5D32; T:=5P4; CALL TOUSMOVE; GO FAR RET5
035474
035474   %-------------------------------------------------------------------------------
035474   FFORGET:     % FUNCTION=102: STOP-ND-50
035474          5MSINIT BZERO 5INBUF=:5MSINIT
035477   %      CALL RELMBPAGES; 0/\0
035477   %      XN5REL=:5FUNCTION
035477          GO FAR IFABREL
035500
035500   %-------------------------------------------------------------------------------
035500   FSPRIOR:     % FUNCTION=105: SET PRIORITY
035500          *IOF
035501          5DD2
035502          IF A=-1 AND D=T THEN
035507             X:=5PRDESCR
035510          ELSE
035511             A:=D-5SWPROC*5PRDSIZE+"S500S"=:X
035516          FI
035516          T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX; AAX -5MSFL
035523          IF A BIT 5IEXQUEUE THEN
035525             CALL SLOCK; GO FSPERR
035527             CALL GCPUDF; CALL ERRFATAL; A=:B
035532   *NNT41=*
035532             CALL TER500; GO FSPERR
035534             CALL IFM500XQ; CALL ITO500XQ
035536             CALL SUNLOCK
035537             CALL ACTRDY
035540             CALL LOWACT500
035541             "N500DF"=:B
035543          FI
035543          *ION
035544   FSPOUT:GO RET5
035545   FSPERR:CALL RSTARTALL; GO FSPOUT; *)FILL
035574
035574
035574   %-------------------------------------------------------------------------------
035574   %%FMRELSPES:   % FUNCTION=123: RELEASE ND-500 AND MEMORY USED BY THE ND-500 TEST SYSTEM (HAREM)
035574   %%      XN5REL=:5FUNCTION; GO FAR IFABREL
035574
035574   %-------------------------------------------------------------------------------
035574   FABLOG:      % FUNCTION=135: LOG OFF PROCESS AND ABORT ND-100 PROGRAM
035574          CALL RELREFS                                    % RELEASE LOGGING FACILITIES
035575          A:=5PRDESCR; CALL X5DCN                             % CLOSE XMSG PORTS
035577          T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX PDCFL; LDATX
035604          IF A><0 THEN                                        % SINTRAN "SYSTEM DETECTED ERROR"?
035605             *IOF
035606             X:=RTREF; 5PRDESCR=:B; CALL BRELEASE             % YES, RELEASE PROC.DESCR
035612             "N500DF"=:B
035614             T:=5MBBANK; X:=5PRDESCR.MESSBUFF; *AAX PDCFL; LDATX % A=MONITOR LEVEL ROUTINE TO START
035621             GO FAR SMLVROUTINE                               % START MLEV ROUTINE
035622          FI; X:=RTREF; CALL FRWQU; CALL FTIMQU               % ABORT ND-100 PROGRAM (SIMULATE ABORT)
035625          GO ABRETXIT
035626   *)FILL
035640
035640   %-------------------------------------------------------------------------------
035640   FSSTDOM:     % FUNCTION=145: START STANDARD DOMAIN FROM S3 OP.COM.
035640          A:=5PRDESCR; CALL X5DCN         % DISCONNECT FROM XMSG
035642          GO FAR RET5
035643   *)FILL
035645
035645   %-------------------------------------------------------------------------------
035645   FREL3:       % FUNCTION=147: ESCAPE TYPED WHILE RUNNING STANDARD DOMAIN STARTED FROM S3 OP.COM.
035645          A:=5PRDESCR; CALL X5DCN; GO FAR IFABREL
035650
035650   %-------------------------------------------------------------------------------
035650   FDBUGSW:     % FUNCTION=154: DEBUG SWAPPER <ON/OFF>
035650          IF 5D12=1 THEN X:=CCPUDF; CALL RELCPU FI
035656          GO FAR RET5
035657
035657   %-------------------------------------------------------------------------------
035657   FNRMICV:     % FUNCTION=156: READ SYSTEM INFO
035657          T:=5P1; A:=134; CALL TOUSMOVE
035662          GO FAR RET5
035663
035663   %-------------------------------------------------------------------------------
035663   FRDTRACE:    % FUNCTION=166: DUMP-TRACE-MEMORY
035663          T:=5P2; A:=5D12 * 24; CALL FAR TOUSMOVE; % 160D bits per trace-word
035667          GO FAR RET5
035670
035670   %-------------------------------------------------------------------------------
035670   FGCPUTYPE:   % FUNCTION=170: READ ND-500 CPU-TYPE AND MIC.VERSION
035670          X:=5P1; AD:=5DD1; CALL STDS0
035673          X:=5P2; AD:=5DD2; CALL STDS0
035676          GO FAR RET5
035677
035677   %-------------------------------------------------------------------------------
035677   FRSCRREG:    % FUNCTION=172: READ HW SCRATCH REGISTER FILE
035677          T:=5P3; A:=5D22*4; CALL FAR TOUSMOVE; % 4 Byte per register
035703          GO FAR RET5
035704
035704   %-------------------------------------------------------------------------------
035704   % COMMON POINT FOR RETURNING TO USER
035704   RET5:  *IOF
035705          IF BACKGROUND><0 THEN
035707             *ION
035710             X:=5TTIFIELD; *IOF
035712             CALL CHDFPAGE
035713             IF 5FUNCTION=SSTDOM THEN 5BCOM ELSE 5BUSER FI
035722             A=:X.BSTATE                                      % SET USER MODE
035723             X.FLAGB BZERO 5ESC2SET=:X.FLAGB                  % CLEAR ESCAPE TYPED WHILE IN ESCOFF
035726          FI
035726          IF 5FUNCTION><FORGET THEN
035732             T:=5MBBANK; X:=5PRDESCR.MESSBUFF
035735             *AAX 5MSFL; LDATX
035737             A BZERO 5IBRK; *STATX                            % CLEAR PSTAT BITS
035741             X:=5PRDESCR; CALL CLINONMSG                      % CLEAR IN5MSG/ON5MSG
035743          FI
035743          GO MXRET
035744
035744   %-------------------------------------------------------------------------------
035744   % OK-RETUR FOR FUNCTIONS NOT USING SYS.MON
035744   5OKRET: MLEV; *MST PIE
035746          0=:"N500DF".ZAREG; B:=X; MIN ZPREG; 0/\0; GO RET5
035754   RBUS
035777
035777
035777   %===================================================
035777   %       ( 5 )    5 A T R A N S
035777   %
035777   % SUBROUTINE TO SET WINDOW TO PHYS.ADDR IN AD-REGS.
035777   % THE DATA-BUFFER WINDOW IS USED.
035777   %
035777   % ENTRY: AD=PHYS.ADDR TO SET WINDOW TO
035777   %
035777   % EXIT:  A= LOGICAL ADDRESS OF BUFFER
035777   %
035777   SUBR 5ATRANS
035777   INTEGER SVT,SVA,SVD,SVX; TRIPLE SVTAD=SVT
036003   5ATRANS: *IOF
036004          TAD=:SVTAD; X=:SVX; AD SHZ 6                        % A=PHYS PAGE
036007          A=:RTREF.BUFWINDOW                                  % SETUP IN RT-DESCR
036011          X:="WNDBF+WNDBF+174000"; T:=0; A=:D:=142000; *STDTX % SET PIT ENTRY
036016          SVD/\1777+"WNDBF*2000"=:SVA                         % A=LOGICAL ADDR.
036022          TAD:=SVTAD; X:=SVX
036024          *ION
036025          EXIT
036026   RBUS
036033
036033
036033   %=====================================================================
036033   %       ( 5 )    5 S G A L T O N
036033   %
036033   % SET THE PAGE TABLE OF SEGMENT IN B-REG AS CURRENT ALTERNATIVE PAGE TABLE
036033   %
036033   SUBR 5SGALTON
036033   INTEGER SVT,SVA,SVD,SVX; TRIPLE SVTAD=SVT
036037   5SGALTON: *IOF
036040          TAD=:SVTAD; X=:SVX
036042          A:=B*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *LOGAD@3 LDATX
036050          A SH 1/\3600+"N5PIT+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR
036056          TAD:=SVTAD; X:=SVX
036060          *ION
036061          EXIT
036062   RBUS
036070
036070
036070   %==========================================================================
036070   %       ( 5 )    S E G M O N C   -   R S G M O N C
036070   %
036070   % EXECUTES MONITOR CALLS NEEDING A SEGMENT TO TRANSFER DATA TO/FROM
036070   %
036070   % SEGMONC:   THE MONITOR CALL REQUIRE STANDARD PARAMETER LISTE
036070   % RSGMONC:   THE MONITOR CALL REQUIRE PARAMETERS IN THE REGISTERS
036070   %
036070   % ENTRY:     X=LOGICAL ADDR OF ND-500 MESSAGE
036070   %            T=SEGMENT NUMBER TO TRANSFER DATA TO/FROM
036070   %            THE MONITOR CALL NUMBER IS FOUND IN L-REG+1 (CALL SEGMONC(XX) FOR EXECUTING MON XX)
036070   %            THE PARAMETERS ARE FOUND IN THE ND-500 MESSAGE (5TADRG+5XRG)
036070   %
036070   SUBR SEGMONC,RSGMONC,5EXMRET
036070   INTEGER CMONINSTR(0); *MON
036071
036071   SEGMONC: X=:B:=L=:5LREG
036074          *1BANK
036075          X.S0; *2BANK
036077          A+CMONINSTR; CALL M1MEXY; T=:SEG5; A=:L             % CHANGE SEGMENT; L=MON.INSTRUCTION TO EXECUTE
036103          A:=B+"5PLIST"                                       % A=PARAMTER LISTE
036105          GO FELLS
036106
036106   RSGMONC: X=:B:=L=:5LREG
036111          *1BANK
036112          X.S0; *2BANK
036114          A+CMONINSTR; CALL M1MEXY; T=:SEG5; A=:L             % CHANGE SEGMENT; L=MON.INSTRUCTION TO EXECUTE
036120          TAD:=5TADRG; X:=5XRG                                % T,A,D,X REGISTERS ARE MONITOR CALL PARAMETERS
036122   FELLS: GO 5EXMONC                                          % IN MICRCO COMMON
036123   5EXMRET:                                                   % RETURN FROM MICRO COMMON HERE
036123          TAD=:5TADRG; X=:5XRG                                % SAVE RETURN VALUES FROM MON.CALL
036125          T:=SEG5; CALL M1MEXY                                % GET IN ND-500 DATA SEGMENT AGAIN
036127          5LREG=:L; IF K NBIT THEN L+1 FI                     % SKIP-RETURN
036134          TAD:=5TADRG
036135          A=:B:=DBASE:=:B                                     % RESET B, AND RETURN WITH REG.VALUES AS FROM FILSYS.
036140          EXITA
036141   RBUS
036146
036146
036146   %=============================================================================
036146   %       ( 5 )    5 P U T L
036146   %
036146   % INSERT VALUE IN ONE LOCATION OF A SEGMENT
036146   %
036146   % ENTRY:     A=VALUE
036146   %            X=ADDRESS IN SEGMENT
036146   %            T=SEGMENT NUMBER
036146   %
036146   % EXIT:      ERROR
036146   %
036146   % EXIT+1:    OK
036146   %
036146   SUBR 5PUTL,1PUGT
036146   5PUTL: X:=:L; X=:5LREG; A=:B
036151          CURPROG.ACT2SEG=:D; 0=:X.ACT2SEG; A:=B; T=:B
036157          X:=L; CALL M1MEXY; CALL 5SGALTON      % CANGE SEGMENT AND SET NEW SEGM'S PIT AS APT
036162          A=:B=:X.S0
036164   1PUGT: CALL ALTOFF; X=:L; A:=D=:CURPROG.ACT2SEG; X:=L
036172          CALL M1MEXY; 5LREG=:L; DBASE; A:=:B; EXITA
036200   RBUS
036206
036206
036206   %============================================================================
036206   %       ( 5 )    5 G E T L
036206   %
036206   % GET ONE LOCATIOIN FROM A SEGMENT
036206   %
036206   % ENTRY:     X=ADDRESS
036206   %            T=SEGMENT
036206   %
036206   % EXIT:      ERROR
036206   %
036206   % EXIT+1:    A=VALUE OF LOCATION
036206   %
036206   SUBR 5GETL
036206   5GETL: A:=L=:5LREG
036210          X=:L; CURPROG.ACT2SEG=:D; 0=:X.ACT2SEG; X:=L
036216          T=:B; CALL M1MEXY; CALL 5SGALTON      % CHANGE SEGM, AND SET NEW SEGM'S PT AS APT
036221          X.S0=:B; GO 1PUGT                         % GET IN ND-500 DATA SEGM AGAIN
036224   RBUS
036231
036231
036231   %====================================================================
036231   %       ( 5 )    G E T C A P A B I L I T Y
036231   %
036231   % ROUTINE TO READ A CAPABILITY TABLE FROM A ND-500 NDATA SEGMENT
036231   %
036231   % ENTRY:     D=SOURCE ADDRESS
036231   %            T=ND-500 SEGMENT NUMBER TO COPY FROM
036231   %            X=LOGICAL ADDRESS OF ND-500 MESSAGE
036231   %            A=NUMBER OF WORDS TO READ
036231   %            THE MON60 BUFFER SHOULD BE IN THE WINDOW WNDBF
036231   %
036231   % EXIT:      T,A,D REGISTERS ARE DESTROYED
036231   %            THE CAPABILITY TABLE ARE IN THE MON60 BUFFER
036231   %
036231   SUBR GETCAPABILITY
036231   GETCAPABILITY:
036231          A=:B:=L=:X."LRET"
036234          CALL M1MEXY; T=:X.SEG5; X=:L              % SWITCH SEGMENT; SAVE OLD SEG
036237          A:=RTREF.ACT1SEG*5SEGSIZE+SEGSTART=:X
036244          T:=SEGTBANK; *LOGAD@3 LDATX
036246          A SH 1; T:="WNDBF*2000"; X:=B; L=:B       % A=NEW.SEG'S PIT IN ALT.PIT POSITION
036252          K:="0"; CALL MOVUS
036254          T:=SEG5; CALL M1MEXY                      % GET ORIGINAL ND-500 DATA SEGM.
036256          "LRET"=:L; X:=B; DBASE=:B
036263          EXIT
036264   RBUS
036274
036274
036274   %========================================================================
036274   %       ( 5 )    5 G N S E G   -   5 G S Y D S G
036274   %
036274   % REMOVE THE DATA SEGMENT, GET THE NAME SEGMENT/STANDARD DOMAIN SEGMENT
036274   % SETS PT0 AS ALTERNATIVE PAGE TABLE
036274   %
036274   % ENTRY:     X=ADDRESS OF PROCESS DESCRIPTION
036274   %
036274   % EXIT:      APIT=0
036274   %            T,A,D,X REGISTERS ARE DESTROYED
036274   %
036274   SUBR 5GNSEG,5GSYDSG
036274   TRIPLE 5GSTADRG; INTEGER 5GSXRG
036300   INTEGER CSS5PIT(0); *S5DPT@7+174000+176          % LAST PIT-ENTRY ON S5DPT PIT
036301   5GSYDSG: T:=55SDS
036302          L=:D; CALL FIX5DSPAGE                     % FIX LAST PAGE IN ND-500 DATASEG
036304          TAD=:5GSTADRG; X=:5GSXRG                  % FIX5DSPAGE RETURNS IN IOF
036306          X:=175776; T:=0; *LDDTX; STZTX            % GET PIT ENTRY FOR LAST PAGE IN DATASEG, AND CLEAR PIT ENTRY
036312          X:=CSS5PIT; *STDTX                        % COPY PIT.ENTRY TO STANDARD DOMAIN SEG PIT.TAB ENTRY
036314          D SH 2=:X; T:=CORMBANK
036317          A BONE 5FIX; *PROTE@3 STATX               % FIX PAGE
036321          TAD:=5GSTADRG
036322          CALL M1MEXY                               % SWITCH SEGMENT
036323          "N5PIT+AS5DP+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR  % SET ALT.PIT=14
036327          X:=5GSXRG
036330          D=:P                                      % EXIT
036331
036331   INTEGER CNS5PIT(0); *X5DPT@7+174000+176          % LAST PIT-ENTRY ON X5DPT PIT
036332   5GNSEG: T:=55NSG
036333          L=:D; CALL FIX5DSPAGE                     % FIX LAST PAGE IN ND-500 DATASEG
036335          TAD=:5GSTADRG; X=:5GSXRG                  % FIX5DSPAGE RETURNS IN IOF
036337          X:=175776; T:=0; *LDDTX; STZTX            % GET PIT ENTRY FOR LAST PAGE IN DATASEG, AND CLEAR PIT ENTRY
036343          X:=CNS5PIT; *STDTX                        % COPY PIT.ENTRY TO NAME.SEG
036345          D SH 2=:X; T:=CORMBANK
036350          A BONE 5FIX; *PROTE@3 STATX               % FIX PAGE
036352          TAD:=5GSTADRG
036353          CALL M1MEXY                               % SWITCH SEGMENT
036354          "N5PIT+AX5DP+ALEVB+ERNG2"=:RTREF.ACTPRI; *TRR PCR  % SET ALT.PIT=13
036360          X:=5GSXRG
036361          D=:P                                      % EXIT
036362   RBUS
036371
036371
036371   %===========================================================================
036371   %       ( 5 )    5 G D S E G
036371   %
036371   % REMOVE THE NAME SEGMENT/STANDARD DOMAIN SEGMENT, GET THE DATA SEGMENT
036371   % RESET THE ALTERNATIVE PAGE TABLE TO DPIT
036371   %
036371   % ENTRY:     X=D= ADDRESS OF PROCESS DESCRIPTION
036371   %
036371   % EXIT:      T,A,D,X REGISTERS ARE DESTROYED
036371   %
036371   SUBR 5GDSEG
036371   INTEGER 5GDXRG
036372   5GDSEG: "N5PIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR  % RESET ALT.PIT TO DPIT
036375          X=:5GDXRG; A=:RTREF.ACTPRI
036400          IF X.ACT1SEG=55NSG THEN "X5DPT*200+176" ELSE "S5DPT*200+176" FI
036407          X:=174000+A; T:=0; *LDDTX; STZTX          % A=PIT ENTRY; D=PHYS PAGE
036414          A BZERO 5FIX                              % RESET FIX BIT (PAGE NO LONGER FIXED)
036415          D SH 2=:X; T:=CORMBANK; *PROTE@3 STATX
036421          A:=5GDXRG-"S500S"=:D:=0; T:=5PRDSIZE; *RDIV ST
036427          A-1*2+"F5DSG"=:T; GO M1MEXY               % SWITCH SEGMENT AND RETURN AFTER CALL TO 5GDSEG!
036434   RBUS
036446
036446
036446   %============================================================================
036446   %       ( 5 )    R E S N A M S E G
036446   %
036446   % SUBROUTINE TO RESERVE A ND-500 LOCK.
036446   %
036446   % ENTRY:     T=0 : NAME SEGMENT
036446   %            T=1 : LOAD CONTROL STORE FUNCTION
036446   %            T=2 : PLACE SWAPPER FUNCTION
036446   %            T=3 : WAIT FOR FIX-PAGES
036446   %            T=4 : RESERVE CONTROL STORE
036446   %                  RETURN:     CONTROL STORE ALREADY RESERVED
036446   %                  SKIPRETURN: CONTROL STORE IS RESERVED BY CALLER
036446   %            T=5 : RESERVE "PLACE-SWAPPER"
036446   %                  RETURN:     "PLACE-SWAPPER" ALREADY RESERVED
036446   %                  SKIPRETURN: "PLACE-SWAPPER" IS RESERVED BY CALLER
036446   %            T=6 : RESERVE THE SYSTEM-DOMAIN SEGMENT
036446   %            T=7 : RESERVE RTPWORKA FOR RT-PROGRAMS
036446   %            T=10: WRITE ERROR MESSAGE TO SINTRAN ERROR DEVICE
036446   %            T=11: General free lock
036446   %                  RETURN:     LOCK ALREADY RESERVED
036446   %                  SKIPRETURN: LOCK IS RESERVED BY CALLER
036446   %            T=12-21: RESERVE ADDITIONAL CPU DF (WHEN USING ACCP BUFFERS)
036446   %
036446   %
036446   SUBR RESNAMSEG
036446   INTEGER RXRG,RRTRG
036450   RESNAMSEG: A:=L=:5LREG
036452   RESN1: MLEV; *MCL PIE
036454          X=:RXRG; T=:RRTRG
036456          XSEMS(T)=:B                                    % B=ADDRESS OF LOCK DF.
036461          X:=RTREF; CALL BRESERVE
036463          IF A<0 THEN                                    % LOCK OCCUPIED?
036464             IF 4=RRTRG OR 5=T OR 11=T THEN              % YES, SHOULD NOT CALLER WAIT FOR IT?
036476                X:=RXRG; MLEV; *MST PIE                  % LOCK OCCUPIED, BUT CALLER SHOULD NOT WAIT FOR IT
036501                5LREG=:L; GO RESRET                      % NO SKIP RETURN
036504             ELSE
036505                CALL FREXQU; CALL TOWQU; CALL ANTIJAMMER % YES, SET IN WAITING-QUEUE FOR THE LOCK
036510                "STUPR"; *IRW MLEVB DP
036512                X:=RXRG; T:=RRTRG; MLEV; *MST PID; MST PIE
036517                GO RESN1
036520             FI
036520          FI; T:=RRTRG; X:=RXRG                          % LOCK IS RESERVED BY CALLER
036522          MLEV; *MST PIE
036524          5LREG+1=:L                                     % SKIP RETURN
036527   RESRET: DBASE=:B; EXIT
036532   RBUS
036543
036543
036543   %========================================================================
036543   %       ( 5 )    R E L N A M S E G
036543   %
036543   % RELEASE A ND-500 LOCK.
036543   %
036543   % ENTRY:     SAME AS FOR RESNAMSEG
036543   %
036543   SUBR RELNAMSEG
036543   INTEGER RXRG,RRTRG
036545   RELNAMSEG: A:=L=:5LREG
036547          MLEV; *MCL PIE
036551          X=:RXRG
036552          XSEMS(T)=:B                               % B=LOCK DATAFIELD ADDR
036555          IF X:=RTRES=RTREF THEN CALL BRELEASE FI   % RELEASE LOCK IF RESERVED BY THE CALLER
036562          X:=RXRG
036563          MLEV; *MST PIE
036565          5LREG=:L; DBASE=:B; EXITA                  % SKIP RETURN
036572   RBUS
036577
036577
036577
036577   %=========================================================================
036577   %       ( 5 )    A C T D R I V E R
036577   %
036577   % ACTIVATE THE N500 HANDLER  N 5 0 0 M R  ON MONITOR LEVEL
036577   %
036577   % ENTRY:     A=0 MEANS STOP PROCESS; X=PROCESS DESCRIPTION ADDRESS
036577   %            A=ADDRESS OF PROCESS DESCRIPTION
036577   %
036577   SUBR ACTDRIVER
036577   INTEGER CXX, CLL
036601   ACTDRIVER: *IOF
036602          IF A=0 THEN
036603             X=:CXX; A:=L=:CLL                      % STOP-PROCESS (I.E. REMOVE MESS FROM ANY QUEUE)
036606             X:=X.MESSBUFF; CALL FRQUES             % REMOVE MESSAGE FROM ANY QUEUE
036610             X:=CXX; CLL=:L; DBASE=:B
036615             *ION
036616             EXIT
036617          FI; *IRW MLEVB DX                         % SET X-REG ON MLEV=PROCESS DESCR
036620          "N500C"; *IRW MLEVB DP                    % N500C IS ENTRY ON MONITOR LEVE
036622          MLEV; *MST PIE; MST PID; ION
036626          EXIT
036627   RBUS
036632
036632
036632   *"8N500 8F5UD
"036632   %============================================================================
036632   %       ( 5 )    5 D T U P
036632   %
036632   % ROUTINE CALLED FROM THE SYSTEM MONITOR TO UPDATE A COPY
036632   % OF THE DATA-CAPABILITY TABLE AND THE FIXED-INFO TABLE
036632   % THESE TABLES ARE USED IN THE FAST MON UDMA INTERFACE
036632   %
036632   % ENTRY:     X=ND-500 PROCESS NUMBER
036632   %            A=ADDRESS OF FIX-INFO TABLE OR DATA-CAPABILITY TABLE ON THE
036632   %              SYSTEM MONITOR'S DATA SEGMENT
036632   %            T=FLAG; =1: COPY FIX-INFO TABLE
036632   %                    =2: COPY DATA CAPABILITY TABLE
036632   %
036632   % EXIT:      ONLY B-REGISTER IS SAVED
036632   %
036632   SUBR 5DTUP
036632   INTEGER 5DMPY
036633   *"8N500
"036633   5DTUP:
036633   *"8N500 8F5UD
"036633          A=:D
036634   *"8N500 8F5UD -8MTRA
"036634          A:=D
036635          *IOF
036636          IF T-1=0 THEN T:="MFSIZE*MFANT"=:5DMPY:=5FXTBL; GO LABLZ FI  % FIX-INFO TABLE
036645          IF T-1=0 THEN T:=MFNCP=:5DMPY:=5DSPS; GO LABLZ FI            % DATA CAPABILITY
036654          *ION
036655          GO 5DTU9                                  % ERROR
036656   LABLZ: A=:D:=X-1*5DMPY; T+A                      % T=DESTINATION ADDR
036663          X:=5FXBNK; A:=5DMPY:=:L; *ION; MOVAP      % COPY TABLE
036670          A=:L
036671   *"8N500
"036671   5DTU9: EXIT
036672   RBUS
036676
036676
036676   %==============================================================================
036676   %       ( 5 )    E R A B O R T
036676   %
036676   % LOGGOUT PROCESS AFTER ERROR DETECTED BY SINTRAN III MONITOR
036676   % (ERROR IN MONITOR CALL ETC...)
036676   %
036676   % LEVEL 1
036676   %
036676   % ENTRY: B=SINTRAN III MONITOR ROUTINE TO RETURN TO AFTER
036676   %          TERMINATED THE ND-500 PROCESS
036676   %
036676   SUBR ERABORT
036676   ERABORT: *IOF; 2BANK
036700            RTREF=:D; CALL FSEMA; CALL ERRFATAL     % FIND PROCESS DESCRIPTION
036704            CALL SLOCK; 0/\0
036706            T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
036712            A BONE 5IBRK BONE 52ESCSET; *STATX      % MARK THAT PROC IS IN "CLEANING UP" STATUS
036715            A:=B; *AAX PDCFL-5MSFL; STATX           % SAVE MON.LEVEL ADDRESS TO ENTER AFTER CLEANING UP
036720            A:=ABLOG; *AAX SV5FU-PDCFL; STATX       % USE FUNC=ABLOG TO TERMINATE PROCESS
036723            CALL SUNLOCK
036724            *ION
036725            IF BACKGROUND><0 THEN
036727               UEFLG BZERO 5UECM=:UEFLG             % CLEAR UEFLAG BIT 5UECOM
036732            FI; GO FROMESC; *)FILL
036744   RBUS
036744
036744
036744   %=============================================================================
036744   %       ( 5 )    F R O M E S C
036744   %
036744   % ENTRY POINT IN PROGRAMS AFTER ESCAPE OR CLEANING-UP SEQUENCES
036744   %
036744   SUBR FROMESC,FESC1
036744   INTEGER POINTER P3STPNT:=STPNT
036745   INTEGER CCDFSA,CCODE,CCTYPR
036750   FROMESC: *2BANK
036751          *IOF
036752          RTREF=:D; CALL FSEMA; CALL ERRFATAL
036756          X:=X.MESSBUFF; CALL FRQUES
036760          IF BACKGROUND><0 THEN
036762             *IOF
036763             RTREF.DSEGM=:X.DACTSEG                           % CONTINUE WITH ORIGINAL SEGMENTS
036766             "STUPR"; *IRW MLEVB DP
036770             MLEV; *MST PIE; MST PID; ION
036774             X:=5TTIFIELD; *IOF
036776             CALL CHDFPAGE
036777             X.FLAGB BZERO 5ESC2SET=:X.FLAGB; *ION            % CLEAR DELAYED ESCAPE
037003             "STBEG"=:P3STPNT                                 % RESET STPNT IN BFIELD ON SYSTEM SEGMENT
037005             IF 5BCHFLAG><1 THEN                              % IF NOT BATCH
037011                *IOF
037012                CALL CHDFPAGE
037013                IF X.TYPRING NBIT 5BAD AND A BIT M144B THEN T:=-2 ELSE T:=-1 FI
037023                IF A BIT 5SPLITDF THEN
037025                   X=:CCDFSA; T=:CCODE; 0=:X.IN5MSG; X.KSETDV; X:=X.TDRADDR
037032                   T:=CCODE; CALL 5CSETDV                  % CALL SETDV FROM COMMON (RPIT)
037034                   X:=CCDFSA.DFOPP; 0=:X.ON5MSG; X.KSETDV; X:=X.TDRADDR
037041                   T:=CCODE; CALL 5CSETDV                  % CALL SETDV
037043                   GO FESCX; *)FILL
037057                FI; *JMP *
037060   FESCX:       *ION
037061             FI
037061          FI; *IOF
037062          CALL CLINONMSG                   % CLEAR ON5MSG AND IN5MSG
037063          *ION; IOF
037065          RTREF=:D; CALL FSEMA; CALL ERRFATAL
037071          X=:D                                       % X&D=PROCESS DESCRIPTION
037072          *ION
037073          IF BACKGROUND><0 THEN
037075             IF 5TTIFIELD.FLAGB BIT 5LOGOUT THEN     % LOGOUT FROM SINTRAN?
037101                *IOF
037102                D.PSTAT BONE SOFFLOG=:X.PSTAT        % YES, MARK THAT ND-500 PROC SHOULD BE LOGGED OFF
037106                *ION
037107             FI
037107             T:=5MBBANK; X:=D:=X.MESSBUFF
037112             *AAX PDCFL; LDATX
037114             X:=D                                    % X=PROCESS DESCRIPTION
037115             IF A=0 AND UEFLG BIT 5UECM THEN         % ESCAPE WHEN IN UECOM?
037121                 A BZERO 5UECM =: UEFLG
037123                 5SPASSTYPE=:5PASSTYPE
037125                 "STACK"=:5CSTCK
037127                 CALL ALLRELEASE
037130                 *IOF
037131                 CALL SLOCK; 0/\0
037133                 T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
037137                 A BZERO 5IBRK BZERO 52ESCSET; *STATX
037142                 *AAX XADPR-5MSFL; LDXTX
037144                 CALL SUNLOCK
037145                 GO 5RETUECOM
037146             FI
037146          FI
037146          A:=0; GO FESC1; *)FILL                    % NOT ABORT-BATCH/ABORT-JOB
037171
037171   INTEGER CCSEMAPHORE
037172   FESC1:                                           % A=ABORT FLAG (1 IF ABORT-JOB/ABORT-BATCH)
037172          T:=5MBBANK; X:=X.MESSBUFF; *AAX 5ERRF; STATX; AAX -5ERRF
037177          *IOF
037200          CALL FRQUES; CALL ALLRELEASE
037202          *ION; IOF
037204          CALL SLOCK; 0/\0
037206          T:=5MBBANK; *AAX 5MSFL; LDATX             % X=PROCESS DESCR
037211          A BZERO 52ESCSET BONE 5IBRK; *STATX
037214          *AAX XADPR-5MSFL; LDXTX
037216          X=:CCSEMAPHORE
037217          CALL SUNLOCK
037220          MLEV; *MCL PIE; ION
037223          "N500DF"=:B; X:=RTREF; CALL BRESERVE                % RESERVE N500DF
037227          IF A<0 THEN                                         % OCCUPIED?
037230             CALL FREXQU; CALL TOWQU; CALL ANTIJAMMER         % YES, WAIT FOR IT
037233             "STUPR"; *IOF; IRW MLEVB DP
037236             MLEV; *MST PIE; MST PID
037241             X:=CCSEMAPHORE
037242             *ION
037243             GO FESC2; *)FILL
037260          ELSE
037261             X:=CCSEMAPHORE
037262   FESC2: FI; X=:5PRDESCR                                     % SAVE ADDR OF PROC. IN N500DF
037263          MLEV; *MST PIE
037265          A:=5PRDESCR-"S500S"=:D:=0; T:=5PRDSIZE; *RDIV ST
037273          A-1*2+"F5DSG"                                       % A=ND500 DATA SEGM FOR PROCESS
037276          IF A><RTREF.ACT1SEG THEN                            % IS THIS SEGM. THE CURRENT ONE?
037302             0=:X.RSEGM; T:=A; CALL M1MEXY                    % NO, GET IN AS ONE OF THE ACTIVE SEGMS
037305          FI; T:=5MBBANK; X:=5PRDESCR.MESSBUFF
037310          *AAX PDCFL; LDATX
037312          IF A><0 THEN
037313             *AAX SV5FU-PDCFL; LDATX
037315          ELSE
037316             T:="S500DF-ZPREG".5FUNCTION
037320             IF SSTDOM=T THEN N5S3REL ELSE N5REL FI
037326          FI; A=:"S500DF-ZPREG".5FUNCTION=:5FUNCTION          % SET NEW FUNCTION CODE
037331          CALL SUPDWIDOW                                      % SET WINDOW TO MON60 BUFFER
037332          GO FAR TOSYMON
037333   RBUS
037344
037344
037344   %==============================================================================
037344   %       ( 5 )    S 5 T S L T Y P E
037344   %
037344   % SET ND-500 TIMESLICE TYPE FOR ND-500 PROCESS
037344   %
037344   % ENTRY:     A=TIMESLICE TYPE
037344   %            X=PROCESS NUMBER
037344   %
037344   % EXIT:      ALL REGISTERS EXCEPT B ARE USED
037344   %
037344   SUBR S5TSLTYPE
037344   S5TSLTYPE:
037344          *IOF
037345          A/\17 SH 7CUTY=:D
037350          A:=X*5PRDSIZE+"S500S"=:X
037354          IF X.PSTAT BIT SLICE THEN
037357             A BONE 55BRKPRIOR=:X.PSTAT
037361             T:=5MBBANK; X:=X.MESSBUFF; *AAX 5TSLS; LDATX    % A=5TSLSTATUS
037365             A/\170377\/D; *STATX                             % SET NEW TIMESLICE TYPE
037370             *AAX 5PRIO-5TSLS; STZTX                          % SET PRIORITY=0 SO TIMELICER WILL CHANGE PRIORITY
037372          FI; *ION
037373          EXIT
037374   RBUS
037401
037401
037401   %=============================================================================
037401   %       ( 5 )    5 S 1 T S L T Y P E   -   5 R 1 T S L T Y P E
037401   %
037401   % SUBROUTIEN TO SET AND RESET TIMESLICE TYPE
037401   %
037401   % ENTRY:     X=RT-DESCRIPTION ADDRESS
037401   %            A=NEW SLICE TYPE (0-17)
037401   %
037401   % EXIT:      A=0: NO CHANGE DONE
037401   %            A><0 CHANGE IS DONE (NEW OR SAVED CLASS IS SET)
037401   % REGISTER USED:             T,D,L
037401   %
037401   SUBR 5S1TSLTYPE,5R1TSLTYPE
037401
037401   INTEGER POINTER L2RG
037402   INTEGER CTYP,PROG,3SLICE
037405
037405   5S1TSLTYPE: K:="0"; GO FELLX
037407   5R1TSLTYPE: K:=1
037410   FELLX: *IOF
037411          0=:3SLICE
037412          IF T:=X.STATUS BIT 5TSLICED THEN                    % PROGRAM TIMESLICED?
037415             A/\17 SH 7CUTY=:CTYP:=L=:"L2RG"; X=:PROG         % YES, CTYP=NEW TIMESLICE CLASS
037423             CALL GTSLPINDEX; GO UT                           % GET TIMESLICE-PROGRAM INDEX
037425             1=:3SLICE
037427             A:=X*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; *TSLST@3 LDATX
037435             IF K THEN
037437                A=:T SHZ -4/\7400:=:T/\170377\/T              % SET CURRENT CLASS=SAVED CLASS
037445             ELSE
037446                A SH 4/\170000\/CTYP                          % SET NEW ND-100 TIMESLICE CLASS
037451             FI; T:=GLTMBANK; *TSLST@3 STATX
037453             PROG.STATUS BONE 5ESCF=:X.STATUS
037457   UT:       X:="L2RG"=:L:=PROG
037462          FI; A:=3SLICE
037463          *ION
037464          EXIT
037465   RBUS
037475
037475
037475   *)KILL E5PIT; E5PIT=*
037475
037475   *5SPAS=SPAST
037475   *5CSTC=CSTCK
037475   *5BCHF=BCHFL
037475   *5PASS=PASST
037475   *5TTIF=TTIFI
037475   *"
"037475
037475   @DEV 1
037475   @EOF
037475
037475
037475   File : (SAMSON)KILL-MACROS:DUMY

000000  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
000000  % MACRO FOR SINTRAN SAVE  TABLE
000000  )MCDEF MSSLE $PAG,$LEN,$SGLE
$PAG =SGMAD;$LEN =$SGLE ;)KILL SGMAD;SGMAD=$PAG +$LEN ;]
000000
000000  % MACRO FOR SINTRAN IMAGE TABLE
000000  )MCDEF MISLE $PAG,$LEN
$PAG =SGMAD;)KILL SGMAD;SGMAD=$PAG +$LEN ;]
000000
000000  % MACRO FOR SEGMENT TABLE INITIAL SET-UP.
000000
000000  )MCDEF MSGLE $SGLE
       XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
       )KILL SGLEN CSGLE; SGLEN=$SGLE ; CSGLE=SGLEN
]
000000
000000  % MACRO FOR SYSTEM SEGMENTS
000000
000000  )MCDEF GSYS
       0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
GSSEG=GBSEG+5SSSZ;)KILL GBSEG
XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
]
000000
000000  % MACRO FOR USER SEGMENTS
000000
000000  )MCDEF GUSE
       0;0;FLBPA;LOADR;GSSEG;113;160000;0
GBSEG=GSSEG+LOADR;)KILL GSSEG
]
000000
000000
000000  %      MACRO FOR SPOOLING QUEUE SEGMENT
000000  )MCDEF SPOOS
9GBSG=SPSGL@10
0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
)KILL 9GBSG

]
000000
000000
000000
000000  % MACRO FOR DEBUGGER DATA SEGMENT
000000  )MCDEF GDEBU
       0;0;UPITN@6+64;14;GBSEG;111;140000;0
       GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
]
000000
000000  "8N500
000000  % MACRO FOR ALLOCATING TWO SEGMENTS FOR EACH ND500 PROCESS
000000
000000  )MCDEF M5SGS
0;0;DPIT@6+73;5;GBSEG;111;162000;0
0;0;0;0;0;10;0;0
GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
]
000000
000000  "8RFAC
000000  % ***  MACRO TO ALLOCATE DATA SEGMENTS FOR REMOTE FILE ACCESS ***
000000  )MCDEF RFDSG
       0;0;DPIT@6+72;4;GBSEG;111;162000;0
GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
]
000000  "
000000
000000  "8ADP
000000  %                MACRO FOR EXTRA DATA SEGMENTS FOR MON ADP.
000000  )MCDEF ADPSG
0;0;200;CSGLE;SGMAD;113;140000;0
]
000000  "
000000  )LINE

000000  %$--:DPIT  % FOR SPLITTING LISTING.
000000  %==============================================================================
000000  % 29.6       S E G M E N T  T A B L E
000000  %
000000  % CALCULATE VALUES FOR ALLOCATING (LOGICAL AND PHYSICAL ADDRESSES) SEGMENTS
000000
000000  % SYMBOLS DEFINING DISK LAYOUT OF FIRST PART OF SEGFIL0:DATA
000000
000000  SGMAD=0
000000  MSSLE MIMAG,LIMAG,77;
000000  MIMAG=SGMAD;LIMAG=77;)KILL SGMAD;SGMAD=MIMAG+LIMAG; MIMAG:000000   % IMAGE OF COMMON/START/RESTART CODE
000000  MSSLE DUM1,DUM2,1;
000000  DUM1=SGMAD;DUM2=1;)KILL SGMAD;SGMAD=DUM1+DUM2; )KILL DUM1 DUM2
000000  MSSLE MSDPT,LSDPT,55;
000000  MSDPT=SGMAD;LSDPT=55;)KILL SGMAD;SGMAD=MSDPT+LSDPT; MSDPT:000100   % SAVE OF DPIT
000000  MSSLE MSSYS,LSSYS,3;
000000  MSSYS=SGMAD;LSSYS=3;)KILL SGMAD;SGMAD=MSSYS+LSSYS;  MSSYS:000155   % SAVE OF SYSTEM SEGMENT
000000  MSSLE MSPDF,LSPDF,1;
000000  MSPDF=SGMAD;LSPDF=1;)KILL SGMAD;SGMAD=MSPDF+LSPDF;  MSPDF:000160   % SAVE OF SPOOLING DATAFIELD/QUEUE  SEGMENT
000000  MSSLE MSECO,LSECO,2;
000000  MSECO=SGMAD;LSECO=2;)KILL SGMAD;SGMAD=MSECO+LSECO;  MSECO:000161   % SAVE AREA OF EXT. COMMON
000000  MSSLE MSRPT,LSRPT,63;
000000  MSRPT=SGMAD;LSRPT=63;)KILL SGMAD;SGMAD=MSRPT+LSRPT; MSRPT:000163   % SAVE AREA OF RPIT
000000  MSSLE MSMPT,LSMPT,63;
000000  MSMPT=SGMAD;LSMPT=63;)KILL SGMAD;SGMAD=MSMPT+LSMPT; MSMPT:000246   % SAVE AREA OF MPIT
000000  MSSLE MSIPT,LSIPT,63;
000000  MSIPT=SGMAD;LSIPT=63;)KILL SGMAD;SGMAD=MSIPT+LSIPT; MSIPT:000331   % SAVE AREA OF IPIT
000000  MSSLE MS5PT,LS5PT,5;
000000  MS5PT=SGMAD;LS5PT=5;)KILL SGMAD;SGMAD=MS5PT+LS5PT;  MS5PT:000414   % SAVE AREA OF 5PIT
000000  MSSLE MN5MO,LN5MO,60;
000000  MN5MO=SGMAD;LN5MO=60;)KILL SGMAD;SGMAD=MN5MO+LN5MO; MN5MO:000421   % SAVE AREA OF ND500 MONITOR
000000  MSSLE MSSGT,LSSGT,20;
000000  MSSGT=SGMAD;LSSGT=20;)KILL SGMAD;SGMAD=MSSGT+LSSGT; MSSGT:000501   % SAVE AREA OF SEGMENT TABLE
000000  MSSLE MSUC1,LSUC1,40;
000000  MSUC1=SGMAD;LSUC1=40;)KILL SGMAD;SGMAD=MSUC1+LSUC1; MSUC1:000521   % SAVE AREA OF 110 MICRO CODE
000000  MSSLE MSUC2,LSUC2,40;
000000  MSUC2=SGMAD;LSUC2=40;)KILL SGMAD;SGMAD=MSUC2+LSUC2; MSUC2:000561   % SAVE AREA OF 120 MICRO CODE
000000  MSSLE MFILS,LFILS,65;
000000  MFILS=SGMAD;LFILS=65;)KILL SGMAD;SGMAD=MFILS+LFILS; MFILS:000621   % SAVE AREA OF FILE SYSTEM
000000  MSSLE MSCOM,LOPCO,65;
000000  MSCOM=SGMAD;LOPCO=65;)KILL SGMAD;SGMAD=MSCOM+LOPCO; MSCOM:000706   % SAVE AREA OF COMMAND SEGMENT
000000  MSSLE MSSMS,LSSMS,44;
000000  MSSMS=SGMAD;LSSMS=44;)KILL SGMAD;SGMAD=MSSMS+LSSMS; MSSMS:000773   % SAVE AREA OF SINTRAN-SERVICE/MAIL SEGMENT
000000  MSSLE MSXMK,LSXMK,30;
000000  MSXMK=SGMAD;LSXMK=30;)KILL SGMAD;SGMAD=MSXMK+LSXMK; MSXMK:001037   % SAVE AREA OF XMSG KERNEL
000000  MSSLE MSXRO,LSXRO,50;
000000  MSXRO=SGMAD;LSXRO=50;)KILL SGMAD;SGMAD=MSXRO+LSXRO; MSXRO:001067   % SAVE AREA OF XMSG (XROUT)
000000  MSSLE MSFID,LSFID,66;
000000  MSFID=SGMAD;LSFID=66;)KILL SGMAD;SGMAD=MSFID+LSFID; MSFID:001137   % SAVE AREA OF XMSG WATCHDOG (XMFIDO)
000000  MSSLE MSNMT,LSNMT,6;
000000  MSNMT=SGMAD;LSNMT=6;)KILL SGMAD;SGMAD=MSNMT+LSNMT;  MSNMT:001225   % SAVE AREA OF DEVICE NAME TABLE
000000  MSSLE MSDMW,LDDMW,4;
000000  MSDMW=SGMAD;LDDMW=4;)KILL SGMAD;SGMAD=MSDMW+LDDMW;  MSDMW:001233   % SAVE AREA OF DIMIR WD
000000  MSSLE MSNKS,LSNKS,64;
000000  MSNKS=SGMAD;LSNKS=64;)KILL SGMAD;SGMAD=MSNKS+LSNKS; MSNKS:001237   % SAVE AREA OF NUCLEUS SERVER
000000  MSSLE MSNKN,LSNKN,100;
000000  MSNKN=SGMAD;LSNKN=100;)KILL SGMAD;SGMAD=MSNKN+LSNKN;MSNKN:001323   % SAVE AREA OF NUCLEUS NAME SERVER
000000  MSSLE MSERC,LSERC,20;
000000  MSERC=SGMAD;LSERC=20;)KILL SGMAD;SGMAD=MSERC+LSERC; MSERC:001423   % SAVE AREA OF ERSWD CODE
000000  MSSLE MSERD,LSERD,70;
000000  MSERD=SGMAD;LSERD=70;)KILL SGMAD;SGMAD=MSERD+LSERD; MSERD:001443   % SAVE AREA OF ERSWD DATA
000000  MSSLE MSPRM,LSPRM,64;
000000  MSPRM=SGMAD;LSPRM=64;)KILL SGMAD;SGMAD=MSPRM+LSPRM; MSPRM:001533   % SAVE AREA OF PROCESSOR MANAGER SERVER
000000  MSSLE MSEMG,LSEMG,64;
000000  MSEMG=SGMAD;LSEMG=64;)KILL SGMAD;SGMAD=MSEMG+LSEMG; MSEMG:001617   % SAVE AREA OF EVENT MESSAGE SERVER
000000  MSSLE MSBOP,LSBOP,64;
000000  MSBOP=SGMAD;LSBOP=64;)KILL SGMAD;SGMAD=MSBOP+LSBOP; MSBOP:001703   % SAVE AREA OF BOPCOM SERVER
000000  MSSLE MSMTS,LSMTS,04;
000000  MSMTS=SGMAD;LSMTS=04;)KILL SGMAD;SGMAD=MSMTS+LSMTS; MSMTS:001767   % SAVE AREA OF MTSERV
000000
000000  MISLE MIDPT,LSDPT;
000000  MIDPT=SGMAD;)KILL SGMAD;SGMAD=MIDPT+LSDPT;    MIDPT:001773   % IMAGE OF DPIT
000000  MISLE MISYS,LSSYS;
000000  MISYS=SGMAD;)KILL SGMAD;SGMAD=MISYS+LSSYS;    MISYS:002050   % IMAGE AREA OF SYSTEM SEGMENT
000000  MISLE MIECO,LSECO;
000000  MIECO=SGMAD;)KILL SGMAD;SGMAD=MIECO+LSECO;    MIECO:002053   % IMAGE OF EXT. COMMON
000000  MISLE MIRPT,LSRPT;
000000  MIRPT=SGMAD;)KILL SGMAD;SGMAD=MIRPT+LSRPT;    MIRPT:002055   % IMAGE OF RPIT
000000  MISLE MIMPT,LSMPT;
000000  MIMPT=SGMAD;)KILL SGMAD;SGMAD=MIMPT+LSMPT;    MIMPT:002140   % IMAGE OF MPIT
000000  MISLE MIIPT,LSIPT;
000000  MIIPT=SGMAD;)KILL SGMAD;SGMAD=MIIPT+LSIPT;    MIIPT:002223   % IMAGE OF IPIT
000000  MISLE MI5PT,LS5PT;
000000  MI5PT=SGMAD;)KILL SGMAD;SGMAD=MI5PT+LS5PT;    MI5PT:002306   % IMAGE OF 5PIT
000000  MISLE MI5MO,LN5MO;
000000  MI5MO=SGMAD;)KILL SGMAD;SGMAD=MI5MO+LN5MO;    MI5MO:002313   % IMAGE OF ND500 MONITOR
000000  MISLE MISGT,LSSGT;
000000  MISGT=SGMAD;)KILL SGMAD;SGMAD=MISGT+LSSGT;    MISGT:002373   % IMAGE OF SEGMENT TABLE
000000  MISLE MIUC1,LSUC1;
000000  MIUC1=SGMAD;)KILL SGMAD;SGMAD=MIUC1+LSUC1;    MIUC1:002413   % IMAGE OF 110 MICRO CODE
000000  MISLE MIUC2,LSUC2;
000000  MIUC2=SGMAD;)KILL SGMAD;SGMAD=MIUC2+LSUC2;    MIUC2:002453   % IMAGE OF 120 MICRO CODE
000000
000000  MISLE MIFIL,LFILS;
000000  MIFIL=SGMAD;)KILL SGMAD;SGMAD=MIFIL+LFILS;    MIFIL:002513   % MEMORY/IMAGE OF FILE SYSTEM
000000  MISLE MICOM,LOPCO-1;
000000  MICOM=SGMAD;)KILL SGMAD;SGMAD=MICOM+LOPCO-1;  MICOM:002600   % MEMORY/IMAGE OF COMMAND SEGMENT
000000  MISLE MISMS,LSSMS;
000000  MISMS=SGMAD;)KILL SGMAD;SGMAD=MISMS+LSSMS;    MISMS:002664   % MEMORY/IMAGE OF SINTRAN-SERVICE/MAIL SEGMENT
000000  MISLE MIXMK,LSXMK;
000000  MIXMK=SGMAD;)KILL SGMAD;SGMAD=MIXMK+LSXMK;    MIXMK:002730   % MEMORY/IMAGE OF XMSG KERNEL
000000  MISLE MIXRO,LSXRO;
000000  MIXRO=SGMAD;)KILL SGMAD;SGMAD=MIXRO+LSXRO;    MIXRO:002760   % MEMORY/IMAGE OF XMSG (XROUT)
000000  MISLE MIFID,LSFID;
000000  MIFID=SGMAD;)KILL SGMAD;SGMAD=MIFID+LSFID;    MIFID:003030   % MEMORY/IMAGE OF XMSG WATCHDOG (XMFIDO)
000000  MISLE MINMT,LSNMT;
000000  MINMT=SGMAD;)KILL SGMAD;SGMAD=MINMT+LSNMT;    MINMT:003116   % MEMORY/IMAGE OF DEVICE NAME TABLE
000000  MISLE MIDMW,LDDMW;
000000  MIDMW=SGMAD;)KILL SGMAD;SGMAD=MIDMW+LDDMW;    MIDMW:003124   % MEMORY/IMAGE OF DIMIR WD
000000  MISLE MINKS,LSNKS;
000000  MINKS=SGMAD;)KILL SGMAD;SGMAD=MINKS+LSNKS;    MINKS:003130   % MEMORY/IMAGE OF NUCLEUS SERVER
000000  MISLE MINKN,LSNKN;
000000  MINKN=SGMAD;)KILL SGMAD;SGMAD=MINKN+LSNKN;    MINKN:003214   % MEMORY/IMAGE OF NUCLEUS NAME SERVER
000000  MISLE MIERC,LSERC;
000000  MIERC=SGMAD;)KILL SGMAD;SGMAD=MIERC+LSERC;    MIERC:003314   % MEMORY/IMAGE OF ERSWD CODE
000000  MISLE MIERD,LSERD;
000000  MIERD=SGMAD;)KILL SGMAD;SGMAD=MIERD+LSERD;    MIERD:003334   % MEMORY/IMAGE OF ERSWD DATA
000000  MISLE MIPRM,LSPRM;
000000  MIPRM=SGMAD;)KILL SGMAD;SGMAD=MIPRM+LSPRM;    MIPRM:003424   % MEMORY/IMAGE OF PROCESSOR MANAGER SERVER
000000  MISLE MIEMG,LSEMG;
000000  MIEMG=SGMAD;)KILL SGMAD;SGMAD=MIEMG+LSEMG;    MIEMG:003510   % MEMORY/IMAGE OF EVENT MESSAGE SERVER
000000  MISLE MIBOP,LSBOP;
000000  MIBOP=SGMAD;)KILL SGMAD;SGMAD=MIBOP+LSBOP;    MIBOP:003574   % MEMORY/IMAGE OF BOPCOM SERVER
000000  MISLE MIMTS,LSMTS;
000000  MIMTS=SGMAD;)KILL SGMAD;SGMAD=MIMTS+LSMTS;    MIMTS:003660   % MEMORY/IMAGE OF MTSERV
000000                        SGMAD:003664   % FIRST FREE PAGE ON SEGFIL0:DATA
000000
000000
000000  MERRP=100;          LERRP=20; MERRP:000100    % SAVE AREA OF ERROR PROGRAM.
000000  MRTLO=137;                    MRTLO:000137    % SAVE AREA OF RT-LOADER (CODE+DATA)
000000
000000  % SYSTEM SEGMENT
000000  SYSST=BGSYS@-12;              SYSST:000062    % LOGICAL START OF SYSTEM SEGMENT
000000  SYSSZ=5SSSZ;                  SYSSZ:000005    % SIZE OF SYSTEM SEGMENT
000000
000000  5NBSG=2      % NUMBER OF SEGMENTS FOR EACH BACKGROUND PROCESS
000000  "8RFAC
000000  5FDSZ=4      % SIZE OF FILE USER DATA SEGMENT
000000  FRSSZ=62     % SIZE OF FILE USER SEGMENT
000000  FDSTR=72     % START PAGE OF FILE USER DATA SEGMENT
000000  "
000000  5ESSZ=1      % SIZE OF ERROR SEGMENT
000000  SGLEN=0      % SEGMENT LENGTH IN PAGES
000000  NNBRT=0      % NUMBER OF BACKGROUND PROGRAMS
000000  SGFI4=100000 % SEGMENT FILE #4 (DIVERSE SAVE AREAS)
000000
000000  %==========================================================================
000000  %      S E G M E N T  T A B L E
000000
000000  XSEGS=*
000000         0;0;0;0;0;0;0;0                      % RESIDENT
000010  % XSGRT
000010         -1;-1;0;376;0;0;161000;
000017  BPAG1, XCORM                                % DUMMY SEGMENT
000020
000020  SG2,   0;0;100;LIMAG;MIMAG;111;162000;0     % MEMORY IMAGE
000030     SG02S=00@12 LIMAG:000077  MIMAG:000000
000030
000030  SG3,   0;0;SPIT@6+14;LOPCO-1;MICOM;111;162000;0        % COMMAND SEGMENT
000040         SG03S=14@12;  LOPCO-1:000064  MICOM:002600
000040
000040         MSGLE 36

000040
000040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000040         )KILL SGLEN CSGLE; SGLEN=36; CSGLE=SGLEN
000040
000040  SG4,   0;0;SPIT@6+14;CSGLE;SGMAD;111;62000;0         % REENTRAN RT-LOADER SEGMENT
000050         SGLEN:000036     SGMAD:003664
000050         SG04S=14@12; S04MA=SGMAD
000050
000050         MSGLE 5ESSZ

000050
000050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000050         )KILL SGLEN CSGLE; SGLEN=5ESSZ; CSGLE=SGLEN
000050
000050  SG5,   0;0;DPIT@6+SYSST;CSGLE;SGMAD;111;162000;0     % ERROR PROGRAM SYSTEM SEGMENT (2 PAGES)
000060         SGLEN:000001     SGMAD:003722
000060         SG05S=SYSST@12; S05MA=SGMAD
000060
000060  SG6,   0;0;FPIT@6+13;LFILS;MIFIL;111; 62001;0        % FILE-SYSTEM SEGMENT
000070         SG06S=13@12;  LFILS:000065  MIFIL:002513  ; S06MA=MIFIL
000070
000070         MSGLE 34

000070
000070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000070         )KILL SGLEN CSGLE; SGLEN=34; CSGLE=SGLEN
000070
000070  SG7,   0;0;SPIT@6+32;CSGLE;SGMAD;111;162000;0        % DMAC SEGMENT
000100         SGLEN:000034     SGMAD:003723
000100         SG07S=32@12
000100
000100         MSGLE 100

000100
000100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000100         )KILL SGLEN CSGLE; SGLEN=100; CSGLE=SGLEN
000100
000100  SG10,  0;0;UPITA@6+00;CSGLE;SGMAD;111;162000;0       % RTFIL SEGMENT
000110         SGLEN:000100     SGMAD:003757
000110         SG10S=00@12
000110
000110         MSGLE 10

000110
000110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000110         )KILL SGLEN CSGLE; SGLEN=10; CSGLE=SGLEN
000110
000110  SG11,  0;0;UPITN@6+00;CSGLE;SGMAD;111;162000;0       % ERROR LOG SEGMENT
000120         SGLEN:000010     SGMAD:004057
000120         SG11S=00@12
000120
000120  SG12,  0;0;UPITN@6+13;LFILS;MFILS;111;162000;0       % INITIAL FILE SYS. SEGMENT
000130         SG12S=13@12;   LFILS:000065  MFILS:000621
000130
000130  SG13,  0;0;UPITN@6+13;LOPCO;MSCOM;111;162000;0       % INITIAL COMMAND SEGMENT
000140         SG13S=13@12;   LOPCO:000065  MSCOM:000706
000140
000140         MSGLE LERRP

000140
000140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000140         )KILL SGLEN CSGLE; SGLEN=LERRP; CSGLE=SGLEN
000140
000140  SG14,  0;0;SPIT@6+14;CSGLE;SGMAD;111;162000;0        % ERROR PROGRAM SEGMENT
000150         SGLEN:000020     SGMAD:004067
000150         SG14S=14@12;  S14MA=SGMAD
000150
000150  SG15,  0;0;FUPIT@6+13;0;0;111;162000;0               % RESERVED FOR BUTTERFLY
000160
000160
000160  SG16,  0;0;UPITN@6+15;LSRPT;MSRPT;111;162000;0       % INITIAL RPIT
000170         SG16S=15@12;   LSRPT:000063  MSRPT:000163
000170
000170  SG17,  0;0;UPITN@6+15;LSMPT;MSMPT;111;162000;0       % INITIAL MPIT
000200         SG17S=15@12;   LSMPT:000063  MSMPT:000246
000200
000200
000200  "8N500;MSGLE 77

000200
000200         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000200         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
000200
000200  "
000200  SG20,  0;0;S5DPT@6+0;CSGLE;SGMAD;111;162000;0       % ND-500 STANDARD DOMAIN SEGMENT
000210         SGLEN:000077     SGMAD:004107
000210         SG20S=00@12
000210
000210  "8N500;MSGLE 77

000210
000210         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000210         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
000210
000210  "
000210  SG21,  0;0;X5DPT@6+0;CSGLE;SGMAD;111;162000;0       % ND-500 NAME TABLES SEGMENT
000220         SGLEN:000077     SGMAD:004206
000220         SG21S=00@12
000220
000220  "8RFAC;MSGLE 62;
000220
000220         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000220         )KILL SGLEN CSGLE; SGLEN=62; CSGLE=SGLEN
000220   SG22S=13@12;"
000220
000220  SG22,  0;0;FUPIT@6+13;CSGLE;SGMAD;111;62001;0       % REMOTE FILE ACCESS SEGMENT
000230         SGLEN:000062     SGMAD:004305
000230
000230  SG23,  0;0;DPIT@6+2;0;0;111;162010;0                % SEGMENT FOR DPIT
000240
000240  SG24,  0;0;UPITN@6+0;LSSGT;MSSGT;111;162000;0       % INITIAL SEGMENT TABLE
000250         SG24S=00@12;  LSSGT:000020  MSSGT:000501
000250
000250  SG25,  0;0;UPITN@6+15;LSRPT;MIRPT;111;162000;0      % IMAGE OF RPIT
000260         SG25S=15@12;   LSRPT:000063  MIRPT:002055
000260
000260  SG26,  0;0;UPITN@6+15;LSMPT;MIMPT;111;162000;0      % IMAGE OF MPIT
000270         SG26S=15@12;   LSMPT:000063  MIMPT:002140
000270
000270  SG27,  0;0;UPITN@6+0;LSSGT;MISGT;111;162000;0       % IMAGE OF SEGMENT TABLE
000300         SG27S=00@12;  LSSGT:000020  MISGT:002373
000300
000300  SG30,  0;0;5PIT@6+20;LN5MO;MI5MO;111;062001;0      % ND-500 REENTRANT SYSTEM MONITOR #1
000310         SG30S=20@12;  LN5MO:000060  MI5MO:002313
000310
000310  SG31,  0;0;DPIT@6+72;LSPDF;MSPDF;111;162000;0      % SAVE AREA OF SPOOLING DATAFIELDS
000320         SG31S=72@12;  LSPDF:000001  MSPDF:000160
000320
000320  SG32,  0;0;0;0;0;0;0;0                             % SEGMENT 32, TEMPORARILY FREE.
000330
000330  SG33,  0;0;0;0;0;0;0;0                             % SEGMENT 33, TEMPORARILY FREE.
000340
000340  SG34,  0;0;0;0;0;0;0;0                             % SEGMENT 34, TEMPORARILY FREE.
000350
000350  SG35,  0;0;MPIT@6+15;LIMPT;0;111;162010;0          % SEGMENT FOR MPIT
000360
000360
000360  "BADAD;MSGLE 12;
000360
000360         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000360         )KILL SGLEN CSGLE; SGLEN=12; CSGLE=SGLEN
000360   SG36S=44@12;"
000360
000360  SG36,  0;0;SPIT@6+44;CSGLE;SGMAD;111;162000;0      % TADADM SEGMENT
000370         SGLEN:000012     SGMAD:004367
000370
000370         MSGLE 100

000370
000370         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000370         )KILL SGLEN CSGLE; SGLEN=100; CSGLE=SGLEN
000370
000370  SG37,  0;0;UPITN@6+00;CSGLE;SGMAD;111;162000;0     % RT-LOADER DATA SEGMENT
000400         SGLEN:000100     SGMAD:004401
000400         SG37S=00@12;  S37MA=SGMAD
000400
000400  "8RFAC;MSGLE 4;
000400
000400         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000400         )KILL SGLEN CSGLE; SGLEN=4; CSGLE=SGLEN
000400   SG40S=64@12;"
000400
000400  SG40,  0;0;DPIT@6+072;CSGLE;SGMAD;111;162000;0     % FILE USER DATA SEGMENT FOR RT.
000410         SGLEN:000004     SGMAD:004501
000410
000410         MSGLE 1

000410
000410         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000410         )KILL SGLEN CSGLE; SGLEN=1; CSGLE=SGLEN
000410
000410  SG41,  0;0;UPITN@6+13;CSGLE;SGMAD;111;162000;0     % IMAGE OF THE "EDIT-ROUTINES" SEGMENT
000420         SGLEN:000001     SGMAD:004505
000420         SG41S=13@12;  S41MA=SGMAD
000420
000420  SG42,  0;0;SPIT@6+13;1;0;111;162010;0              % THE "EDIT-ROUTINES" SEGMENT
000430
000430         MSGLE 2

000430
000430         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
000430         )KILL SGLEN CSGLE; SGLEN=2; CSGLE=SGLEN
000430
000430  SG43,  0;0;UPITA@6+76;CSGLE;SGMAD;111;162000;0     % S3PATCH (FOR RUNNING PATCH-FILE)
000440         SGLEN:000002     SGMAD:004506
000440         SG43S=64@12;  S43MA=SGMAD
000440
000440  SG44,  0;0;UPITN@6+02;LSDPT;MIDPT;111;162000;0     % IMAGE OF DPIT
000450                        LSDPT:000055  MIDPT:001773
000450
000450  SG45,  0;0;UPITN@6+SYSST;LSSYS;MISYS;111;162000;0  % MEMORY IMAGE OF SYSTEM SEGMENT
000460                           LSSYS:000003  MISYS:002050
000460
000460  SG46,  0;0;UPITN@6+13;LS5PT;MS5PT;111;162000;0     % INITIAL 5PIT
000470         SG46S=13@12;   LS5PT:000005  MS5PT:000414
000470
000470  SG47,  0;0;RPIT@6+15;LIRPT;0;111;162010;0           % SEGMENT FOR RPIT
000500
000500
000500  SG50,  0;0;UPITN@6+13;LS5PT;MI5PT;111;162000;0      % IMAGE OF 5PIT
000510         SG50S=13@12; MI5PT:002306
000510
000510  SG51,  0;0;5PIT@6+13;LI5PT;0;111;162010;0                 % SEGMENT FOR 5PIT
000520
000520  SG52,  0;0;UPITN@6+0;LIMAG;MIMAG;SGFI4+111;162000;0       % SAVE OF COMMON AND RE/START
000530
000530  SG53,  0;0;UPITN@6+2;LSDPT;MSDPT;111;162000;0             % SAVE OF DPIT
000540
000540  SG54,  0;0;UPITN@6+SYSST;LSSYS;MSSYS;111;162000;0         % SAVE OF SYSTEM SEGMENT
000550
000550  SG55,  0;0;UPITN@6+14;LERRP;MERRP-1;SGFI4+111;162000;0    % SAVE OF ERROR PROGRAM
000560         SG55S=14@12
000560
000560  SG56,  0;0;UPITN@6+14;20;MRTLO-1;SGFI4+111;162000;0       % SAVE OF RT-LOADER CODE
000570         SG56S=14@12
000570
000570  SG57,  0;0;UPITN@6+0;13;MRTLO+20-1;SGFI4+111;162000;0     % SAVE OF RT-LOADER DATA
000600         SG57S=0
000600
000600  SG60,  0;0;UPITN@6+13;LSECO;MSECO;111;162000;0            % INITIAL EXT. COMMON
000610         SG60S=13@12; MSECO:000161
000610
000610  SG61,  0;0;UPITN@6+13;LSECO;MIECO;111;162000;0            % IMAGE OF EXT. COMMON
000620         SG61S=13@12; MIECO:002053
000620
000620  SG62,  0;0;UPITN@6+20;LN5MO;MN5MO;111;162000;0            % SAVE OF ND500 MONITOR
000630         SG62S=20@12
000630
000630  SG63,  0;0;UPITN@6+75;LSMTF;MSMTF-1;SGFI4+111;162000;0    % MEMTOF
000640
000640  SG64,  0;0;RPIT@6+13;LIECO;0;111;162010;0                 % SEGMENT FOR EXT. COMMON
000650
000650  SG65,  0;0;UPITN@6+15;LSIPT;MSIPT;111;162000;0            % INITIAL IPIT
000660         SG65S=15@12; MSIPT:000331
000660
000660  SG66,  0;0;UPITN@6+15;LSIPT;MIIPT;111;162000;0            % IMAGE OF IPIT
000670         SG66S=13@12; MIIPT:002223
000670
000670  SG67,  0;0;IPIT@6+15;LIIPT;0;111;162010;0                 % SEGMENT FOR IPIT
000700
000700  SG70,  0;0;UPITN@6+14;LSSMS;MSSMS;111;162000;0            % INITIAL SM SEGMENT
000710         LSSMS:000044     MSSMS:000773
000710
000710  SG71,  0;0;SPIT@6+14;LSSMS;MISMS;111;162000;0             % SM SEGMENT
000720         SG71S=14@12;  S71MA=MISMS; S71MA:002664
000720
000720  SG72,  0;0;UPITN@6+1;LDDMW;MSDMW;10;162000;0             % SAVE OF DIM WD SEGMENT
000730         SG72S=1@12; LDDMW:000004   MSDMW:001233
000730
000730  SG73,  0;0;UPITN@6+1;LDDMW;MIDMW;10;162000;0             % IMAGE OF DIM WD SEGMENT
000740         SG73S=1@12; LDDMW:000004   MIDMW:003124
000740
000740  SG74,  0;0;UPITN@6+050;LSXMK;MSXMK;111;162000;0          % SAVE OF X-MESSAGE (KERNEL)
000750         LSXMK:000030   MSXMK:001037
000750
000750  SG75,  0;0;UPITN@6+0;LSXRO;MSXRO;111;162000;0            % SAVE OF X-MESSAGE (XROUT)
000760         LSXRO:000050   MSXRO:001067
000760
000760  SG76,  0;0;UPITA@6+050;LSXMK;MIXMK;10;162000;0           % X-MESSAGE (KERNEL)
000770
000770  SG77,  0;0;UPITA@6+0;LSXRO;MIXRO;10;162000;0             % X-MESSAGE (XROUT)
001000
001000  SG100, 0;0;UPITN@6+072;LSNMT;MSNMT;111;162000;0          % SAVE OF NAME TABLE
001010         LSNMT:000006     MSNMT:001225
001010         S100S=72@12; S100M=MSNMT
001010
001010  SG101, 0;0;DPIT@6+072;LSNMT;MINMT;111;62000;0           % NAME TABLE
001020         S101S=72@12; S101M=SGMAD
001020
001020  SG102, 0;0;UPITN@6;LSFID;MSFID;111;162000;0     % SAVE OF XMSG WATCHDOG (XMFIDO)
001030         LSFID:000066   MSFID:001137
001030
001030  SG103, 0;0;UPITN@6;LSFID;MIFID;10;160000;0      % XMSG WATCHDOG (XMFIDO)
001040
001040  SG104, 0;0;SPIT@6+14;LSNKS;MSNKS;111;162000;0   % SAVE OF NUCLEUS SERVER
001050  SG105, 0;0;SPIT@6+14;LSNKS;MINKS; 10;162000;0   % IMAGE OF NUCLEUS SERVER
001060
001060  SG106, 0;0;UPITN@6;LSNKN;MSNKN;111;162000;0     % SAVE OF NUCLEUS NAME SERVER
001070  SG107, 0;0;UPITN@6;LSNKN;MINKN;111;161000;0     % IMAGE OF NUCLEUS NAME SERVER
001100
001100  SG110, 0;0;UPITN@6;LSUC1;MSUC1;111;162000;0     % SAVE OF ND 110 MICRO CODE
001110  SG111, 0;0;UPITN@6;LSUC1;MIUC1;111;162000;0     % IMAGE OF ND 110 MICRO CODE
001120  SG112, 0;0;UPITN@6;LSUC2;MSUC2;111;162000;0     % SAVE OF ND 120 MICRO CODE
001130  SG113, 0;0;UPITN@6;LSUC2;MIUC2;111;162000;0     % IMAGE OF ND 120 MICRO CODE
001140
001140  SG114, 0;0;UPITN@6;LSERC;MSERC;111;162000;0     % SAVE OF  ERSWD CODE
001150  SG115, 0;0;UPITN@6;LSERC;MIERC;111;160000;0     % IMAGE OF ERDWD CODE
001160  SG116, 0;0;UPITN@6;LSERD;MSERD;111;162000;0     % SAVE OF  ERSWD DATA
001170  SG117, 0;0;UPITA@6;LSERD;MIERD;111;160000;0     % IMAGE OF ERSWD DATA
001200
001200  SG120, 0;0;SPIT@6+14;LSPRM;MSPRM;111;162000;0   % SAVE OF  PROCESSOR MANAGER SERVER
001210  SG121, 0;0;SPIT@6+14;LSPRM;MIPRM;111;162000;0   % IMAGE OF PROCESSOR MANAGER SERVER
001220
001220  SG122, 0;0;SPIT@6+14;LSEMG;MSEMG;111;162000;0   % SAVE OF   EVENT MESSAGE SERVER
001230  SG123, 0;0;SPIT@6+14;LSEMG;MIEMG;111;162000;0   % IMAGE OF  EVENT MESSAGE SERVER
001240
001240  SG124, 0;0;SPIT@6+14;LSBOP;MSBOP;111;162000;0   % SAVE OF    BOPCOM SERVER
001250  SG125, 0;0;SPIT@6+14;LSBOP;MIBOP;111;162000;0   % IMAGE OF   BOPCOM SERVER
001260
001260  SG126, 0;0;SPIT@6+14;LSMTS;MSMTS;111;162000;0   % SAVE OF    MTSERV
001270  SG127, 0;0;SPIT@6+14;LSMTS;MIMTS;111;162000;0   % IMAGE OF   MTSERV
001300
001300         MSGLE 0

001300
001300         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
001300         )KILL SGLEN CSGLE; SGLEN=0; CSGLE=SGLEN
001300
001300         SGMAD:004510
001300
001300  SSSEG=400    % FIRST CONFIGURATION DEPENDANT SEGMENT
001300  GBSEG=SGMAD  % NEXT FREE MASS STORAGE ADDRESS ON SEGFIL0
001300
001300  1STFS=*      % FIRST FREE SEGMENT (ADDRESS RELATIVE TO SEGSTART)
001300  0USSG=3770-1STFS@-3+8SGN
001300
001300  XXYY=SSSEG@3
001300  XSEGS+XXYY/
004000  *:004000
004000  )KILL XXYY
004000
004000  "8DILG
004000  DILGS=SSSEG;)KILL SSSEG; SSSEG=DILGS+1
004000  0;0;UPIT@6;2;GBSEG;10;162000;0            % DISK LOG SEGMENT
004010  GSSEG=GBSEG+2;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
004010  "
004010
004010  %=============================================================================
004010  9FSSG=*     % USED BY SINTR.
004010  9FSMA=GBSEG % MASS.ADDR OF FIRST CONFIGURATION DEPENDANT SEGMENT (USED BY SINTR)
004010  %==============================================================================
004010
004010  "SLP1
004010  SPSG1=SSSEG;)KILL SSSEG;SSSEG=SPSG1+1
004010  SPOOS

004010  9GBSG=SPSGL@10
004010  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004020  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004020  )KILL 9GBSG
004020
004020  "SLP2
004020  SPSG2=SSSEG;)KILL SSSEG;SSSEG=SPSG2+1
004020  SPOOS

004020  9GBSG=SPSGL@10
004020  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004030  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004030  )KILL 9GBSG
004030
004030  "SLP3
004030  SPSG3=SSSEG;)KILL SSSEG;SSSEG=SPSG3+1
004030  SPOOS

004030  9GBSG=SPSGL@10
004030  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004040  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004040  )KILL 9GBSG
004040
004040  "SLP4
004040  SPSG4=SSSEG;)KILL SSSEG;SSSEG=SPSG4+1
004040  SPOOS

004040  9GBSG=SPSGL@10
004040  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004050  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004050  )KILL 9GBSG
004050
004050  "SLP5
004050  SPSG5=SSSEG;)KILL SSSEG;SSSEG=SPSG5+1
004050  SPOOS

004050  9GBSG=SPSGL@10
004050  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004060  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004060  )KILL 9GBSG
004060
004060  "SLP6
004060  SPSG6=SSSEG;)KILL SSSEG;SSSEG=SPSG6+1
004060  SPOOS

004060  9GBSG=SPSGL@10
004060  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004070  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004070  )KILL 9GBSG
004070
004070  "SLP7
004070  SPSG7=SSSEG;)KILL SSSEG;SSSEG=SPSG7+1
004070  SPOOS

004070  9GBSG=SPSGL@10
004070  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004100  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004100  )KILL 9GBSG
004100
004100  "SLP8
004100  SPSG8=SSSEG;)KILL SSSEG;SSSEG=SPSG8+1
004100  SPOOS

004100  9GBSG=SPSGL@10
004100  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004110  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004110  )KILL 9GBSG
004110
004110  "SLP9
004110  SPSG9=SSSEG;)KILL SSSEG;SSSEG=SPSG9+1
004110  SPOOS

004110  9GBSG=SPSGL@10
004110  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004120  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004120  )KILL 9GBSG
004120
004120  "SLP10
004120  SPS10=SSSEG;)KILL SSSEG;SSSEG=SPS10+1
004120  SPOOS

004120  9GBSG=SPSGL@10
004120  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004130  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004130  )KILL 9GBSG
004130
004130  "SLP11
004130  SPS11=SSSEG;)KILL SSSEG;SSSEG=SPS11+1
004130  SPOOS

004130  9GBSG=SPSGL@10
004130  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004140  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004140  )KILL 9GBSG
004140
004140  "SLP12
004140  SPS12=SSSEG;)KILL SSSEG;SSSEG=SPS12+1
004140  SPOOS

004140  9GBSG=SPSGL@10
004140  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004150  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004150  )KILL 9GBSG
004150
004150  "SLP13
004150  SPS13=SSSEG;)KILL SSSEG;SSSEG=SPS13+1
004150  SPOOS

004150  9GBSG=SPSGL@10
004150  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004160  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004160  )KILL 9GBSG
004160
004160  "SLP14
004160  SPS14=SSSEG;)KILL SSSEG;SSSEG=SPS14+1
004160  SPOOS

004160  9GBSG=SPSGL@10
004160  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004170  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004170  )KILL 9GBSG
004170
004170  "SLP15
004170  SPS15=SSSEG;)KILL SSSEG;SSSEG=SPS15+1
004170  SPOOS

004170  9GBSG=SPSGL@10
004170  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004200  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004200  )KILL 9GBSG
004200
004200  "SLP16
004200  SPS16=SSSEG;)KILL SSSEG;SSSEG=SPS16+1
004200  SPOOS

004200  9GBSG=SPSGL@10
004200  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004210  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004210  )KILL 9GBSG
004210
004210  "SLP17
004210  SPS17=SSSEG;)KILL SSSEG;SSSEG=SPS17+1
004210  SPOOS

004210  9GBSG=SPSGL@10
004210  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004220  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004220  )KILL 9GBSG
004220
004220  "SLP18
004220  SPS18=SSSEG;)KILL SSSEG;SSSEG=SPS18+1
004220  SPOOS

004220  9GBSG=SPSGL@10
004220  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004230  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004230  )KILL 9GBSG
004230
004230  "SLP19
004230  SPS19=SSSEG;)KILL SSSEG;SSSEG=SPS19+1
004230  SPOOS

004230  9GBSG=SPSGL@10
004230  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004240  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004240  )KILL 9GBSG
004240
004240  "SLP20
004240  SPS20=SSSEG;)KILL SSSEG;SSSEG=SPS20+1
004240  SPOOS

004240  9GBSG=SPSGL@10
004240  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004250  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004250  )KILL 9GBSG
004250
004250  "SLP21
004250  SPS21=SSSEG;)KILL SSSEG;SSSEG=SPS21+1
004250  SPOOS

004250  9GBSG=SPSGL@10
004250  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004260  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004260  )KILL 9GBSG
004260
004260  "SLP22
004260  SPS22=SSSEG;)KILL SSSEG;SSSEG=SPS22+1
004260  SPOOS

004260  9GBSG=SPSGL@10
004260  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004270  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004270  )KILL 9GBSG
004270
004270  "8COSP
004270  COSEG=SSSEG;)KILL SSSEG;SSSEG=COSEG+1
004270  SPOOS

004270  9GBSG=SPSGL@10
004270  0;0;DPIT@6+72;SPSGL;GBSEG;111;162000;0      %     SPOOLING QUEUE SEGMENT
004300  GSSEG=GBSEG+SPSGL; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004300  )KILL 9GBSG
004300
004300  "
004300  %==========================================================================
004300  9ESSG=*          % USED BY THE START PROGRAM
004300  9F5SG=*          % USED BY THE START PROGRAM
004300  %==========================================================================
004300
004300
004300  "8PR01
004300  % SEGMENTS FOR ND500 MONITOR
004300  %
004300  % 2 SEGMENTS FOR EACH PROCESS, DATA SEGMENT AND FILE-TRANSFER SEGMENT
004300  %
004300
004300  N5DSG= SSSEG-2
004300  F5DSG= SSSEG
004300  M5SGS

004300  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004310  0;0;0;0;0;10;0;0
004320  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004320  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004320  "8PR02
004320  M5SGS

004320  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004330  0;0;0;0;0;10;0;0
004340  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004340  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004340  "8PR03
004340  M5SGS

004340  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004350  0;0;0;0;0;10;0;0
004360  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004360  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004360  "8PR04
004360  M5SGS

004360  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004370  0;0;0;0;0;10;0;0
004400  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004400  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004400  "8PR05
004400  M5SGS

004400  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004410  0;0;0;0;0;10;0;0
004420  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004420  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004420  "8PR06
004420  M5SGS

004420  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004430  0;0;0;0;0;10;0;0
004440  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004440  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004440  "8PR07
004440  M5SGS

004440  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004450  0;0;0;0;0;10;0;0
004460  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004460  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004460  "8PR08
004460  M5SGS

004460  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004470  0;0;0;0;0;10;0;0
004500  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004500  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004500  "8PR09
004500  M5SGS

004500  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004510  0;0;0;0;0;10;0;0
004520  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004520  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004520  "8PR10
004520  M5SGS

004520  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004530  0;0;0;0;0;10;0;0
004540  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004540  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004540  "8PR11
004540  M5SGS

004540  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004550  0;0;0;0;0;10;0;0
004560  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004560  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004560  "8PR12
004560  M5SGS

004560  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004570  0;0;0;0;0;10;0;0
004600  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004600  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004600  "8PR13
004600  M5SGS

004600  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004610  0;0;0;0;0;10;0;0
004620  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004620  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004620  "8PR14
004620  M5SGS

004620  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004630  0;0;0;0;0;10;0;0
004640  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004640  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004640  "8PR15
004640  M5SGS

004640  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004650  0;0;0;0;0;10;0;0
004660  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004660  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004660  "8PR16
004660  M5SGS

004660  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004670  0;0;0;0;0;10;0;0
004700  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004700  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004700  "8PR17
004700  M5SGS

004700  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004710  0;0;0;0;0;10;0;0
004720  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004720  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004720  "8PR18
004720  M5SGS

004720  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004730  0;0;0;0;0;10;0;0
004740  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004740  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004740  "8PR19
004740  M5SGS

004740  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004750  0;0;0;0;0;10;0;0
004760  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
004760  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
004760  "8PR20
004760  M5SGS

004760  0;0;DPIT@6+73;5;GBSEG;111;162000;0
004770  0;0;0;0;0;10;0;0
005000  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005000  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005000  "8PR21
005000  M5SGS

005000  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005010  0;0;0;0;0;10;0;0
005020  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005020  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005020  "8PR22
005020  M5SGS

005020  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005030  0;0;0;0;0;10;0;0
005040  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005040  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005040  "8PR23
005040  M5SGS

005040  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005050  0;0;0;0;0;10;0;0
005060  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005060  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005060  "8PR24
005060  M5SGS

005060  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005070  0;0;0;0;0;10;0;0
005100  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005100  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005100  "8PR25
005100  M5SGS

005100  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005110  0;0;0;0;0;10;0;0
005120  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005120  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005120  "8PR26
005120  M5SGS

005120  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005130  0;0;0;0;0;10;0;0
005140  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005140  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005140  "8PR27
005140  M5SGS

005140  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005150  0;0;0;0;0;10;0;0
005160  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005160  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005160  "8PR28
005160  M5SGS

005160  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005170  0;0;0;0;0;10;0;0
005200  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005200  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005200  "8PR29
005200  M5SGS

005200  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005210  0;0;0;0;0;10;0;0
005220  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005220  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005220  "8PR30
005220  M5SGS

005220  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005230  0;0;0;0;0;10;0;0
005240  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005240  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005240  "8PR31
005240  M5SGS

005240  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005250  0;0;0;0;0;10;0;0
005260  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005260  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005260  "8PR32
005260  M5SGS

005260  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005270  0;0;0;0;0;10;0;0
005300  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005300  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005300  "8PR33
005300  M5SGS

005300  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005310  0;0;0;0;0;10;0;0
005320  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005320  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005320  "8PR34
005320  M5SGS

005320  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005330  0;0;0;0;0;10;0;0
005340  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005340  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005340  "8PR35
005340  M5SGS

005340  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005350  0;0;0;0;0;10;0;0
005360  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005360  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005360  "8PR36
005360  M5SGS

005360  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005370  0;0;0;0;0;10;0;0
005400  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005400  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005400  "8PR37
005400  M5SGS

005400  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005410  0;0;0;0;0;10;0;0
005420  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005420  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005420  "8PR38
005420  M5SGS

005420  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005430  0;0;0;0;0;10;0;0
005440  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005440  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005440  "8PR39
005440  M5SGS

005440  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005450  0;0;0;0;0;10;0;0
005460  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005460  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005460  "8PR40
005460  M5SGS

005460  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005470  0;0;0;0;0;10;0;0
005500  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005500  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005500  "8PR41
005500  M5SGS

005500  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005510  0;0;0;0;0;10;0;0
005520  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005520  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005520  "8PR42
005520  M5SGS

005520  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005530  0;0;0;0;0;10;0;0
005540  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005540  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005540  "8PR43
005540  M5SGS

005540  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005550  0;0;0;0;0;10;0;0
005560  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005560  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005560  "8PR44
005560  M5SGS

005560  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005570  0;0;0;0;0;10;0;0
005600  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005600  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005600  "8PR45
005600  M5SGS

005600  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005610  0;0;0;0;0;10;0;0
005620  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005620  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005620  "8PR46
005620  M5SGS

005620  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005630  0;0;0;0;0;10;0;0
005640  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005640  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005640  "8PR47
005640  M5SGS

005640  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005650  0;0;0;0;0;10;0;0
005660  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005660  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005660  "8PR48
005660  M5SGS

005660  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005670  0;0;0;0;0;10;0;0
005700  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005700  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005700  "8PR49
005700  M5SGS

005700  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005710  0;0;0;0;0;10;0;0
005720  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005720  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005720  "8PR50
005720  M5SGS

005720  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005730  0;0;0;0;0;10;0;0
005740  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005740  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005740  "8PR51
005740  M5SGS

005740  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005750  0;0;0;0;0;10;0;0
005760  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
005760  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
005760  "8PR52
005760  M5SGS

005760  0;0;DPIT@6+73;5;GBSEG;111;162000;0
005770  0;0;0;0;0;10;0;0
006000  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006000  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006000  "8PR53
006000  M5SGS

006000  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006010  0;0;0;0;0;10;0;0
006020  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006020  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006020  "8PR54
006020  M5SGS

006020  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006030  0;0;0;0;0;10;0;0
006040  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006040  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006040  "8PR55
006040  M5SGS

006040  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006050  0;0;0;0;0;10;0;0
006060  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006060  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006060  "8PR56
006060  M5SGS

006060  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006070  0;0;0;0;0;10;0;0
006100  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006100  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006100  "8PR57
006100  M5SGS

006100  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006110  0;0;0;0;0;10;0;0
006120  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006120  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006120  "8PR58
006120  M5SGS

006120  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006130  0;0;0;0;0;10;0;0
006140  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006140  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006140  "8PR59
006140  M5SGS

006140  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006150  0;0;0;0;0;10;0;0
006160  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006160  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006160  "8PR60
006160  M5SGS

006160  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006170  0;0;0;0;0;10;0;0
006200  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006200  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006200  "8PR61
006200  M5SGS

006200  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006210  0;0;0;0;0;10;0;0
006220  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006220  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006220  "8PR62
006220  M5SGS

006220  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006230  0;0;0;0;0;10;0;0
006240  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006240  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006240  "8PR63
006240  M5SGS

006240  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006250  0;0;0;0;0;10;0;0
006260  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006260  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006260  "8PR64
006260  M5SGS

006260  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006270  0;0;0;0;0;10;0;0
006300  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006300  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006300  "8PR65
006300  M5SGS

006300  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006310  0;0;0;0;0;10;0;0
006320  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006320  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006320  "8PR66
006320  M5SGS

006320  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006330  0;0;0;0;0;10;0;0
006340  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006340  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006340  "8PR67
006340  M5SGS

006340  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006350  0;0;0;0;0;10;0;0
006360  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006360  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006360  "8PR68
006360  M5SGS

006360  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006370  0;0;0;0;0;10;0;0
006400  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006400  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006400  "8PR69
006400  M5SGS

006400  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006410  0;0;0;0;0;10;0;0
006420  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006420  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006420  "8PR70
006420  M5SGS

006420  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006430  0;0;0;0;0;10;0;0
006440  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006440  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006440  "8PR71
006440  M5SGS

006440  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006450  0;0;0;0;0;10;0;0
006460  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006460  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006460  "8PR72
006460  M5SGS

006460  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006470  0;0;0;0;0;10;0;0
006500  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006500  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006500  "8PR73
006500  M5SGS

006500  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006510  0;0;0;0;0;10;0;0
006520  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006520  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006520  "8PR74
006520  M5SGS

006520  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006530  0;0;0;0;0;10;0;0
006540  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006540  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006540  "8PR75
006540  M5SGS

006540  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006550  0;0;0;0;0;10;0;0
006560  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006560  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006560  "8PR76
006560  M5SGS

006560  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006570  0;0;0;0;0;10;0;0
006600  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006600  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006600  "8PR77
006600  M5SGS

006600  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006610  0;0;0;0;0;10;0;0
006620  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006620  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006620  "8PR78
006620  M5SGS

006620  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006630  0;0;0;0;0;10;0;0
006640  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006640  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006640  "8PR79
006640  M5SGS

006640  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006650  0;0;0;0;0;10;0;0
006660  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006660  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006660  "8PR80
006660  M5SGS

006660  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006670  0;0;0;0;0;10;0;0
006700  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006700  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006700  "8PR81
006700  M5SGS

006700  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006710  0;0;0;0;0;10;0;0
006720  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006720  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006720  "8PR82
006720  M5SGS

006720  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006730  0;0;0;0;0;10;0;0
006740  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006740  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006740  "8PR83
006740  M5SGS

006740  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006750  0;0;0;0;0;10;0;0
006760  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
006760  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
006760  "8PR84
006760  M5SGS

006760  0;0;DPIT@6+73;5;GBSEG;111;162000;0
006770  0;0;0;0;0;10;0;0
007000  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007000  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007000  "8PR85
007000  M5SGS

007000  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007010  0;0;0;0;0;10;0;0
007020  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007020  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007020  "8PR86
007020  M5SGS

007020  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007030  0;0;0;0;0;10;0;0
007040  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007040  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007040  "8PR87
007040  M5SGS

007040  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007050  0;0;0;0;0;10;0;0
007060  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007060  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007060  "8PR88
007060  M5SGS

007060  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007070  0;0;0;0;0;10;0;0
007100  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007100  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007100  "8PR89
007100  M5SGS

007100  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007110  0;0;0;0;0;10;0;0
007120  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007120  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007120  "8PR90
007120  M5SGS

007120  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007130  0;0;0;0;0;10;0;0
007140  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007140  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007140  "8PR91
007140  M5SGS

007140  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007150  0;0;0;0;0;10;0;0
007160  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007160  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007160  "8PR92
007160  M5SGS

007160  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007170  0;0;0;0;0;10;0;0
007200  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007200  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007200  "8PR93
007200  M5SGS

007200  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007210  0;0;0;0;0;10;0;0
007220  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007220  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007220  "8PR94
007220  M5SGS

007220  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007230  0;0;0;0;0;10;0;0
007240  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007240  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007240  "8PR95
007240  M5SGS

007240  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007250  0;0;0;0;0;10;0;0
007260  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007260  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007260  "8PR96
007260  M5SGS

007260  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007270  0;0;0;0;0;10;0;0
007300  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007300  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007300  "8PR97
007300  M5SGS

007300  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007310  0;0;0;0;0;10;0;0
007320  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007320  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007320  "8PR98
007320  M5SGS

007320  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007330  0;0;0;0;0;10;0;0
007340  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007340  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007340  "8PR99
007340  M5SGS

007340  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007350  0;0;0;0;0;10;0;0
007360  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007360  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007360  "8P100
007360  M5SGS

007360  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007370  0;0;0;0;0;10;0;0
007400  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007400  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007400  "8P101
007400  M5SGS

007400  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007410  0;0;0;0;0;10;0;0
007420  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007420  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007420  "8P102
007420  M5SGS

007420  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007430  0;0;0;0;0;10;0;0
007440  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007440  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007440  "8P103
007440  M5SGS

007440  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007450  0;0;0;0;0;10;0;0
007460  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007460  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007460  "8P104
007460  M5SGS

007460  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007470  0;0;0;0;0;10;0;0
007500  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007500  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007500  "8P105
007500  M5SGS

007500  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007510  0;0;0;0;0;10;0;0
007520  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007520  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007520  "8P106
007520  M5SGS

007520  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007530  0;0;0;0;0;10;0;0
007540  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007540  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007540  "8P107
007540  M5SGS

007540  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007550  0;0;0;0;0;10;0;0
007560  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007560  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007560  "8P108
007560  M5SGS

007560  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007570  0;0;0;0;0;10;0;0
007600  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007600  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007600  "8P109
007600  M5SGS

007600  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007610  0;0;0;0;0;10;0;0
007620  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007620  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007620  "8P110
007620  M5SGS

007620  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007630  0;0;0;0;0;10;0;0
007640  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007640  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007640  "8P111
007640  M5SGS

007640  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007650  0;0;0;0;0;10;0;0
007660  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007660  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007660  "8P112
007660  M5SGS

007660  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007670  0;0;0;0;0;10;0;0
007700  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007700  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007700  "8P113
007700  M5SGS

007700  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007710  0;0;0;0;0;10;0;0
007720  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007720  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007720  "8P114
007720  M5SGS

007720  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007730  0;0;0;0;0;10;0;0
007740  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007740  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007740  "8P115
007740  M5SGS

007740  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007750  0;0;0;0;0;10;0;0
007760  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
007760  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
007760  "8P116
007760  M5SGS

007760  0;0;DPIT@6+73;5;GBSEG;111;162000;0
007770  0;0;0;0;0;10;0;0
010000  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010000  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010000  "8P117
010000  M5SGS

010000  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010010  0;0;0;0;0;10;0;0
010020  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010020  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010020  "8P118
010020  M5SGS

010020  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010030  0;0;0;0;0;10;0;0
010040  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010040  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010040  "8P119
010040  M5SGS

010040  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010050  0;0;0;0;0;10;0;0
010060  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010060  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010060  "8P120
010060  M5SGS

010060  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010070  0;0;0;0;0;10;0;0
010100  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010100  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010100  "8P121
010100  M5SGS

010100  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010110  0;0;0;0;0;10;0;0
010120  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010120  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010120  "8P122
010120  M5SGS

010120  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010130  0;0;0;0;0;10;0;0
010140  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010140  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010140  "8P123
010140  M5SGS

010140  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010150  0;0;0;0;0;10;0;0
010160  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010160  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010160  "8P124
010160  M5SGS

010160  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010170  0;0;0;0;0;10;0;0
010200  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010200  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010200  "8P125
010200  M5SGS

010200  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010210  0;0;0;0;0;10;0;0
010220  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010220  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010220  "8P126
010220  M5SGS

010220  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010230  0;0;0;0;0;10;0;0
010240  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010240  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010240  "8P127
010240  M5SGS

010240  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010250  0;0;0;0;0;10;0;0
010260  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010260  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010260  "8P128
010260  M5SGS

010260  0;0;DPIT@6+73;5;GBSEG;111;162000;0
010270  0;0;0;0;0;10;0;0
010300  GSSEG=GBSEG+5; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010300  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+2; )KILL TEMP
010300  "8N500
010300  L5DSG=SSSEG
010300  "
010300  %=============================================================================
010300  9E5SG=*          % USED BY THE START PROGRAM
010300  9SRFS=*          % USED BY THE START PROGRAM
010300  %==============================================================================
010300
010300  "8RFAC
010300  %  ***************  DATA SEGMENTS FOR REMOTE FILE ACCESS:   ******************
010300  DSSNM=SSSEG     % SEGMENT NUMBER OF FIRST DATA SEGMENT FOR REMOTE FILE ACCESS
010300  "8SG50; RFDSG;

010300         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010310  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010310  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010310
010310  "8SG49; RFDSG;

010310         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010320  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010320  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010320
010320  "8SG48; RFDSG;

010320         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010330  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010330  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010330
010330  "8SG47; RFDSG;

010330         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010340  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010340  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010340
010340  "8SG46; RFDSG;

010340         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010350  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010350  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010350
010350  "8SG45; RFDSG;

010350         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010360  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010360  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010360
010360  "8SG44; RFDSG;

010360         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010370  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010370  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010370
010370  "8SG43; RFDSG;

010370         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010400  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010400  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010400
010400  "8SG42; RFDSG;

010400         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010410  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010410  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010410
010410  "8SG41; RFDSG;

010410         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010420  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010420  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010420
010420  "8SG40; RFDSG;

010420         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010430  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010430  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010430
010430  "8SG39; RFDSG;

010430         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010440  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010440  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010440
010440  "8SG38; RFDSG;

010440         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010450  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010450  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010450
010450  "8SG37; RFDSG;

010450         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010460  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010460  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010460
010460  "8SG36; RFDSG;

010460         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010470  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010470  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010470
010470  "8SG35; RFDSG;

010470         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010500  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010500  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010500
010500  "8SG34; RFDSG;

010500         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010510  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010510  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010510
010510  "8SG33; RFDSG;

010510         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010520  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010520  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010520
010520  "8SG32; RFDSG;

010520         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010530  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010530  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010530
010530  "8SG31; RFDSG;

010530         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010540  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010540  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010540
010540  "8SG30; RFDSG;

010540         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010550  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010550  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010550
010550  "8SG29; RFDSG;

010550         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010560  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010560  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010560
010560  "8SG28; RFDSG;

010560         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010570  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010570  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010570
010570  "8SG27; RFDSG;

010570         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010600  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010600  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010600
010600  "8SG26; RFDSG;

010600         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010610  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010610  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010610
010610  "8SG25; RFDSG;

010610         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010620  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010620  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010620
010620  "8SG24; RFDSG;

010620         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010630  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010630  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010630
010630  "8SG23; RFDSG;

010630         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010640  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010640  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010640
010640  "8SG22; RFDSG;

010640         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010650  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010650  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010650
010650  "8SG21; RFDSG;

010650         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010660  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010660  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010660
010660  "8SG20; RFDSG;

010660         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010670  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010670  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010670
010670  "8SG19; RFDSG;

010670         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010700  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010700  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010700
010700  "8SG18; RFDSG;

010700         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010710  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010710  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010710
010710  "8SG17; RFDSG;

010710         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010720  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010720  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010720
010720  "8SG16; RFDSG;

010720         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010730  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010730  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010730
010730  "8SG15; RFDSG;

010730         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010740  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010740  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010740
010740  "8SG14; RFDSG;

010740         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010750  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010750  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010750
010750  "8SG13; RFDSG;

010750         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010760  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010760  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010760
010760  "8SG12; RFDSG;

010760         0;0;DPIT@6+72;4;GBSEG;111;162000;0
010770  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
010770  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
010770
010770  "8SG11; RFDSG;

010770         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011000  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011000  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011000
011000  "8SG10; RFDSG;

011000         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011010  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011010  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011010
011010  "8SG09; RFDSG;

011010         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011020  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011020  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011020
011020  "8SG08; RFDSG;

011020         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011030  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011030  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011030
011030  "8SG07; RFDSG;

011030         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011040  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011040  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011040
011040  "8SG06; RFDSG;

011040         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011050  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011050  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011050
011050  "8SG05; RFDSG;

011050         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011060  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011060  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011060
011060  "8SG04; RFDSG;

011060         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011070  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011070  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011070
011070  "8SG03; RFDSG;

011070         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011100  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011100  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011100
011100  "8SG02; RFDSG;

011100         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011110  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011110  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011110
011110  "8RFAC; RFDSG;

011110         0;0;DPIT@6+72;4;GBSEG;111;162000;0
011120  GSSEG=GBSEG+4; )KILL GBSEG; GBSEG=GSSEG; )KILL GSSEG
011120  TEMP=SSSEG; )KILL SSSEG; SSSEG=TEMP+1; )KILL TEMP
011120
011120  "
011120  %===========================================================================
011120  9ERFS=*          % USED BY THE START PROGRAM
011120  9SSBS=*          % USED BY THE START PROGRAM
011120  %===========================================================================
011120
011120  SGNUM=SSSEG                  % FIRST SEGMENT NO. FOR SYMBOLIC DEBUGGER
011120  "8DB30+8DB40+8DB50+8DB60
011120  GDEBU

011120         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011130         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011130  GDEBU

011130         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011140         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011140  GDEBU

011140         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011150         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011150  GDEBU

011150         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011160         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011160  GDEBU

011160         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011170         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011170  GDEBU

011170         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011200         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011200  GDEBU

011200         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011210         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011210  GDEBU

011210         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011220         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011220  GDEBU

011220         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011230         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011230  GDEBU

011230         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011240         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011240  "8DB20+8DB30+8DB40+8DB50+8DB60
011240  GDEBU

011240         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011250         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011250  GDEBU

011250         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011260         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011260  GDEBU

011260         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011270         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011270  GDEBU

011270         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011300         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011300  GDEBU

011300         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011310         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011310  GDEBU

011310         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011320         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011320  GDEBU

011320         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011330         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011330  GDEBU

011330         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011340         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011340  GDEBU

011340         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011350         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011350  GDEBU

011350         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011360         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011360  "8DB10+8DB20+8DB30+8DB40+8DB50+8DB60
011360  GDEBU

011360         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011370         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011370  GDEBU

011370         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011400         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011400  GDEBU

011400         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011410         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011410  GDEBU

011410         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011420         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011420  GDEBU

011420         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011430         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011430  GDEBU

011430         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011440         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011440  GDEBU

011440         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011450         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011450  GDEBU

011450         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011460         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011460  GDEBU

011460         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011470         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011470  GDEBU

011470         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011500         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011500  "8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
011500  GDEBU

011500         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011510         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011510  "8DB01+8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
011510  GDEBU

011510         0;0;UPITN@6+64;14;GBSEG;111;140000;0
011520         GSSEG=GBSEG+14;)KILL GBSEG;GBSEG=GSSEG;)KILL GSSEG
011520  "
011520  %=========================================================================
011520  9SGNU=*                            % END OF SYMBOLIC DEBUGGER SEGMENTS
011520  0DBNU=9SGNU@-3-SGNUM               % NUMBER OF GENERATED SYMBOLIC DEBUGGER SEGMENTS
011520  %===============================================================================
011520
011520  % SYSTEM SEGMENT 1:
011520  1SYSS=*
011520  GSYS

011520
011520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011530  % BACKGROUND SEGMENT 1:
011530  GUSE

011530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011540  GBSEG=GSSEG+LOADR;)KILL GSSEG
011540
011540  "8BP2
011540  GSYS

011540
011540         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011550  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011550  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011550  GUSE

011550         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011560  GBSEG=GSSEG+LOADR;)KILL GSSEG
011560  "8BP3
011560  GSYS

011560
011560         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011570  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011570  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011570  GUSE

011570         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011600  GBSEG=GSSEG+LOADR;)KILL GSSEG
011600  "8BP4
011600  GSYS

011600
011600         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011610  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011610  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011610  GUSE

011610         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011620  GBSEG=GSSEG+LOADR;)KILL GSSEG
011620  "8BP5 8BACS
011620  GSYS

011620
011620         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011630  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011630  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011630  GUSE

011630         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011640  GBSEG=GSSEG+LOADR;)KILL GSSEG
011640  "8BP6
011640  GSYS

011640
011640         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011650  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011650  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011650  GUSE

011650         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011660  GBSEG=GSSEG+LOADR;)KILL GSSEG
011660  "8BP7
011660  GSYS

011660
011660         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011670  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011670  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011670  GUSE

011670         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011700  GBSEG=GSSEG+LOADR;)KILL GSSEG
011700  "8BP8
011700  GSYS

011700
011700         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011710  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011710  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011710  GUSE

011710         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011720  GBSEG=GSSEG+LOADR;)KILL GSSEG
011720  "8BP9 8BACS
011720  GSYS

011720
011720         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011730  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011730  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011730  GUSE

011730         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011740  GBSEG=GSSEG+LOADR;)KILL GSSEG
011740  "8BP10
011740  GSYS

011740
011740         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011750  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011750  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011750  GUSE

011750         0;0;FLBPA;LOADR;GSSEG;113;160000;0
011760  GBSEG=GSSEG+LOADR;)KILL GSSEG
011760  "8BP11
011760  GSYS

011760
011760         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
011770  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
011770  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
011770  GUSE

011770         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012000  GBSEG=GSSEG+LOADR;)KILL GSSEG
012000  "8BP12
012000  GSYS

012000
012000         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012010  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012010  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012010  GUSE

012010         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012020  GBSEG=GSSEG+LOADR;)KILL GSSEG
012020  "8BP13 8BACS
012020  GSYS

012020
012020         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012030  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012030  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012030  GUSE

012030         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012040  GBSEG=GSSEG+LOADR;)KILL GSSEG
012040  "8BP14
012040  GSYS

012040
012040         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012050  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012050  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012050  GUSE

012050         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012060  GBSEG=GSSEG+LOADR;)KILL GSSEG
012060  "8BP15
012060  GSYS

012060
012060         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012070  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012070  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012070  GUSE

012070         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012100  GBSEG=GSSEG+LOADR;)KILL GSSEG
012100  "8BP16
012100  GSYS

012100
012100         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012110  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012110  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012110  GUSE

012110         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012120  GBSEG=GSSEG+LOADR;)KILL GSSEG
012120  "8BP17 8BACS
012120  GSYS

012120
012120         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012130  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012130  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012130  GUSE

012130         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012140  GBSEG=GSSEG+LOADR;)KILL GSSEG
012140  "8BP18
012140  GSYS

012140
012140         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012150  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012150  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012150  GUSE

012150         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012160  GBSEG=GSSEG+LOADR;)KILL GSSEG
012160  "8BP19
012160  GSYS

012160
012160         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012170  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012170  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012170  GUSE

012170         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012200  GBSEG=GSSEG+LOADR;)KILL GSSEG
012200  "8BP20
012200  GSYS

012200
012200         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012210  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012210  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012210  GUSE

012210         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012220  GBSEG=GSSEG+LOADR;)KILL GSSEG
012220  "8BP21 8BACS
012220  GSYS

012220
012220         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012230  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012230  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012230  GUSE

012230         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012240  GBSEG=GSSEG+LOADR;)KILL GSSEG
012240  "8BP22
012240  GSYS

012240
012240         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012250  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012250  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012250  GUSE

012250         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012260  GBSEG=GSSEG+LOADR;)KILL GSSEG
012260  "8BP23
012260  GSYS

012260
012260         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012270  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012270  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012270  GUSE

012270         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012300  GBSEG=GSSEG+LOADR;)KILL GSSEG
012300  "8BP24
012300  GSYS

012300
012300         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012310  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012310  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012310  GUSE

012310         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012320  GBSEG=GSSEG+LOADR;)KILL GSSEG
012320  "8BP25 8BACS
012320  GSYS

012320
012320         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012330  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012330  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012330  GUSE

012330         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012340  GBSEG=GSSEG+LOADR;)KILL GSSEG
012340  "8BP26
012340  GSYS

012340
012340         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012350  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012350  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012350  GUSE

012350         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012360  GBSEG=GSSEG+LOADR;)KILL GSSEG
012360  "8BP27
012360  GSYS

012360
012360         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012370  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012370  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012370  GUSE

012370         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012400  GBSEG=GSSEG+LOADR;)KILL GSSEG
012400  "8BP28
012400  GSYS

012400
012400         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012410  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012410  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012410  GUSE

012410         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012420  GBSEG=GSSEG+LOADR;)KILL GSSEG
012420  "8BP29 8BACS
012420  GSYS

012420
012420         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012430  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012430  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012430  GUSE

012430         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012440  GBSEG=GSSEG+LOADR;)KILL GSSEG
012440  "8BP30 8BACS
012440  GSYS

012440
012440         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012450  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012450  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012450  GUSE

012450         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012460  GBSEG=GSSEG+LOADR;)KILL GSSEG
012460  "8BP31
012460  GSYS

012460
012460         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012470  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012470  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012470  GUSE

012470         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012500  GBSEG=GSSEG+LOADR;)KILL GSSEG
012500  "8BP32
012500  GSYS

012500
012500         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012510  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012510  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012510  GUSE

012510         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012520  GBSEG=GSSEG+LOADR;)KILL GSSEG
012520  "8BP33
012520  GSYS

012520
012520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012530  GUSE

012530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012540  GBSEG=GSSEG+LOADR;)KILL GSSEG
012540  "8BP34
012540  GSYS

012540
012540         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012550  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012550  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012550  GUSE

012550         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012560  GBSEG=GSSEG+LOADR;)KILL GSSEG
012560  "8BP35 8BACS
012560  GSYS

012560
012560         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012570  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012570  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012570  GUSE

012570         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012600  GBSEG=GSSEG+LOADR;)KILL GSSEG
012600  "8BP36 8BACS
012600  GSYS

012600
012600         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012610  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012610  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012610  GUSE

012610         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012620  GBSEG=GSSEG+LOADR;)KILL GSSEG
012620  "8BP37 8BACS
012620  GSYS

012620
012620         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012630  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012630  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012630  GUSE

012630         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012640  GBSEG=GSSEG+LOADR;)KILL GSSEG
012640  "8BP38 8BACS
012640  GSYS

012640
012640         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012650  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012650  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012650  GUSE

012650         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012660  GBSEG=GSSEG+LOADR;)KILL GSSEG
012660  "8BP39 8BACS
012660  GSYS

012660
012660         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012670  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012670  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012670  GUSE

012670         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012700  GBSEG=GSSEG+LOADR;)KILL GSSEG
012700  "8BP40 8BACS
012700  GSYS

012700
012700         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012710  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012710  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012710  GUSE

012710         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012720  GBSEG=GSSEG+LOADR;)KILL GSSEG
012720  "8BP41 8BACS
012720  GSYS

012720
012720         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012730  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012730  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012730  GUSE

012730         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012740  GBSEG=GSSEG+LOADR;)KILL GSSEG
012740  "8BP42 8BACS
012740  GSYS

012740
012740         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012750  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012750  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012750  GUSE

012750         0;0;FLBPA;LOADR;GSSEG;113;160000;0
012760  GBSEG=GSSEG+LOADR;)KILL GSSEG
012760  "8BP43 8BACS
012760  GSYS

012760
012760         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
012770  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
012770  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
012770  GUSE

012770         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013000  GBSEG=GSSEG+LOADR;)KILL GSSEG
013000  "8BP44 8BACS
013000  GSYS

013000
013000         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013010  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013010  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013010  GUSE

013010         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013020  GBSEG=GSSEG+LOADR;)KILL GSSEG
013020  "8BP45
013020  GSYS

013020
013020         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013030  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013030  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013030  GUSE

013030         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013040  GBSEG=GSSEG+LOADR;)KILL GSSEG
013040  "8BP46
013040  GSYS

013040
013040         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013050  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013050  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013050  GUSE

013050         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013060  GBSEG=GSSEG+LOADR;)KILL GSSEG
013060  "8BP47
013060  GSYS

013060
013060         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013070  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013070  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013070  GUSE

013070         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013100  GBSEG=GSSEG+LOADR;)KILL GSSEG
013100  "8BP48
013100  GSYS

013100
013100         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013110  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013110  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013110  GUSE

013110         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013120  GBSEG=GSSEG+LOADR;)KILL GSSEG
013120  "8BP49
013120  GSYS

013120
013120         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013130  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013130  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013130  GUSE

013130         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013140  GBSEG=GSSEG+LOADR;)KILL GSSEG
013140  "8BP50
013140  GSYS

013140
013140         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013150  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013150  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013150  GUSE

013150         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013160  GBSEG=GSSEG+LOADR;)KILL GSSEG
013160  "8BP51
013160  GSYS

013160
013160         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013170  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013170  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013170  GUSE

013170         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013200  GBSEG=GSSEG+LOADR;)KILL GSSEG
013200  "8BP52
013200  GSYS

013200
013200         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013210  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013210  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013210  GUSE

013210         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013220  GBSEG=GSSEG+LOADR;)KILL GSSEG
013220  "8BP53 8BACS
013220  GSYS

013220
013220         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013230  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013230  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013230  GUSE

013230         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013240  GBSEG=GSSEG+LOADR;)KILL GSSEG
013240  "8BP54 8BACS
013240  GSYS

013240
013240         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013250  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013250  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013250  GUSE

013250         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013260  GBSEG=GSSEG+LOADR;)KILL GSSEG
013260  "8BP55 8BACS
013260  GSYS

013260
013260         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013270  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013270  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013270  GUSE

013270         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013300  GBSEG=GSSEG+LOADR;)KILL GSSEG
013300  "8BP56 8BACS
013300  GSYS

013300
013300         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013310  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013310  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013310  GUSE

013310         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013320  GBSEG=GSSEG+LOADR;)KILL GSSEG
013320  "8BP57 8BACS
013320  GSYS

013320
013320         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013330  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013330  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013330  GUSE

013330         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013340  GBSEG=GSSEG+LOADR;)KILL GSSEG
013340  "8BP58 8BACS
013340  GSYS

013340
013340         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013350  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013350  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013350  GUSE

013350         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013360  GBSEG=GSSEG+LOADR;)KILL GSSEG
013360  "8BP59 8BACS
013360  GSYS

013360
013360         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013370  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013370  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013370  GUSE

013370         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013400  GBSEG=GSSEG+LOADR;)KILL GSSEG
013400  "8BP60 8BACS
013400  GSYS

013400
013400         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013410  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013410  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013410  GUSE

013410         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013420  GBSEG=GSSEG+LOADR;)KILL GSSEG
013420  "8BP61 8BACS
013420  GSYS

013420
013420         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013430  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013430  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013430  GUSE

013430         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013440  GBSEG=GSSEG+LOADR;)KILL GSSEG
013440  "8BP62 8BACS
013440  GSYS

013440
013440         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013450  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013450  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013450  GUSE

013450         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013460  GBSEG=GSSEG+LOADR;)KILL GSSEG
013460  "8BP63 8BACS
013460  GSYS

013460
013460         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013470  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013470  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013470  GUSE

013470         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013500  GBSEG=GSSEG+LOADR;)KILL GSSEG
013500  "8BP64 8BACS
013500  GSYS

013500
013500         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013510  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013510  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013510  GUSE

013510         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013520  GBSEG=GSSEG+LOADR;)KILL GSSEG
013520  "8BP65
013520  GSYS

013520
013520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013530  GUSE

013530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013540  GBSEG=GSSEG+LOADR;)KILL GSSEG
013540  "8BP66
013540  GSYS

013540
013540         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013550  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013550  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013550  GUSE

013550         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013560  GBSEG=GSSEG+LOADR;)KILL GSSEG
013560  "8BP67
013560  GSYS

013560
013560         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013570  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013570  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013570  GUSE

013570         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013600  GBSEG=GSSEG+LOADR;)KILL GSSEG
013600  "8BP68
013600  GSYS

013600
013600         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013610  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013610  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013610  GUSE

013610         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013620  GBSEG=GSSEG+LOADR;)KILL GSSEG
013620  "8BP69
013620  GSYS

013620
013620         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013630  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013630  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013630  GUSE

013630         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013640  GBSEG=GSSEG+LOADR;)KILL GSSEG
013640  "8BP70
013640  GSYS

013640
013640         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013650  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013650  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013650  GUSE

013650         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013660  GBSEG=GSSEG+LOADR;)KILL GSSEG
013660  "8BP71
013660  GSYS

013660
013660         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013670  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013670  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013670  GUSE

013670         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013700  GBSEG=GSSEG+LOADR;)KILL GSSEG
013700  "8BP72
013700  GSYS

013700
013700         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013710  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013710  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013710  GUSE

013710         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013720  GBSEG=GSSEG+LOADR;)KILL GSSEG
013720  "8BP73
013720  GSYS

013720
013720         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013730  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013730  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013730  GUSE

013730         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013740  GBSEG=GSSEG+LOADR;)KILL GSSEG
013740  "8BP74
013740  GSYS

013740
013740         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013750  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013750  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013750  GUSE

013750         0;0;FLBPA;LOADR;GSSEG;113;160000;0
013760  GBSEG=GSSEG+LOADR;)KILL GSSEG
013760  "8BP75
013760  GSYS

013760
013760         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
013770  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
013770  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
013770  GUSE

013770         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014000  GBSEG=GSSEG+LOADR;)KILL GSSEG
014000  "8BP76
014000  GSYS

014000
014000         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014010  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014010  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014010  GUSE

014010         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014020  GBSEG=GSSEG+LOADR;)KILL GSSEG
014020  "8BP77
014020  GSYS

014020
014020         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014030  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014030  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014030  GUSE

014030         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014040  GBSEG=GSSEG+LOADR;)KILL GSSEG
014040  "8BP78
014040  GSYS

014040
014040         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014050  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014050  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014050  GUSE

014050         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014060  GBSEG=GSSEG+LOADR;)KILL GSSEG
014060  "8BP79
014060  GSYS

014060
014060         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014070  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014070  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014070  GUSE

014070         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014100  GBSEG=GSSEG+LOADR;)KILL GSSEG
014100  "8BP80
014100  GSYS

014100
014100         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014110  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014110  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014110  GUSE

014110         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014120  GBSEG=GSSEG+LOADR;)KILL GSSEG
014120  "8BP81
014120  GSYS

014120
014120         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014130  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014130  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014130  GUSE

014130         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014140  GBSEG=GSSEG+LOADR;)KILL GSSEG
014140  "8BP82
014140  GSYS

014140
014140         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014150  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014150  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014150  GUSE

014150         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014160  GBSEG=GSSEG+LOADR;)KILL GSSEG
014160  "8BP83
014160  GSYS

014160
014160         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014170  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014170  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014170  GUSE

014170         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014200  GBSEG=GSSEG+LOADR;)KILL GSSEG
014200  "8BP84
014200  GSYS

014200
014200         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014210  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014210  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014210  GUSE

014210         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014220  GBSEG=GSSEG+LOADR;)KILL GSSEG
014220  "8BP85
014220  GSYS

014220
014220         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014230  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014230  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014230  GUSE

014230         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014240  GBSEG=GSSEG+LOADR;)KILL GSSEG
014240  "8BP86
014240  GSYS

014240
014240         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014250  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014250  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014250  GUSE

014250         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014260  GBSEG=GSSEG+LOADR;)KILL GSSEG
014260  "8BP87
014260  GSYS

014260
014260         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014270  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014270  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014270  GUSE

014270         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014300  GBSEG=GSSEG+LOADR;)KILL GSSEG
014300  "8BP88
014300  GSYS

014300
014300         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014310  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014310  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014310  GUSE

014310         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014320  GBSEG=GSSEG+LOADR;)KILL GSSEG
014320  "8BP89
014320  GSYS

014320
014320         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014330  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014330  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014330  GUSE

014330         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014340  GBSEG=GSSEG+LOADR;)KILL GSSEG
014340  "8BP90
014340  GSYS

014340
014340         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014350  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014350  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014350  GUSE

014350         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014360  GBSEG=GSSEG+LOADR;)KILL GSSEG
014360  "8BP91
014360  GSYS

014360
014360         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014370  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014370  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014370  GUSE

014370         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014400  GBSEG=GSSEG+LOADR;)KILL GSSEG
014400  "8BP92
014400  GSYS

014400
014400         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014410  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014410  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014410  GUSE

014410         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014420  GBSEG=GSSEG+LOADR;)KILL GSSEG
014420  "8BP93
014420  GSYS

014420
014420         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014430  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014430  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014430  GUSE

014430         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014440  GBSEG=GSSEG+LOADR;)KILL GSSEG
014440  "8BP94
014440  GSYS

014440
014440         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014450  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014450  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014450  GUSE

014450         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014460  GBSEG=GSSEG+LOADR;)KILL GSSEG
014460  "8BP95
014460  GSYS

014460
014460         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014470  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014470  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014470  GUSE

014470         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014500  GBSEG=GSSEG+LOADR;)KILL GSSEG
014500  "8BP96
014500  GSYS

014500
014500         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014510  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014510  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014510  GUSE

014510         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014520  GBSEG=GSSEG+LOADR;)KILL GSSEG
014520  "8BP97
014520  GSYS

014520
014520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014530  GUSE

014530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014540  GBSEG=GSSEG+LOADR;)KILL GSSEG
014540  "8BP98
014540  GSYS

014540
014540         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014550  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014550  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014550  GUSE

014550         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014560  GBSEG=GSSEG+LOADR;)KILL GSSEG
014560  "8BP99
014560  GSYS

014560
014560         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014570  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014570  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014570  GUSE

014570         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014600  GBSEG=GSSEG+LOADR;)KILL GSSEG
014600  "9BP00
014600  GSYS

014600
014600         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014610  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014610  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014610  GUSE

014610         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014620  GBSEG=GSSEG+LOADR;)KILL GSSEG
014620  "9BP01
014620  GSYS

014620
014620         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014630  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014630  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014630  GUSE

014630         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014640  GBSEG=GSSEG+LOADR;)KILL GSSEG
014640  "9BP02
014640  GSYS

014640
014640         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014650  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014650  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014650  GUSE

014650         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014660  GBSEG=GSSEG+LOADR;)KILL GSSEG
014660  "9BP03
014660  GSYS

014660
014660         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014670  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014670  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014670  GUSE

014670         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014700  GBSEG=GSSEG+LOADR;)KILL GSSEG
014700  "9BP04
014700  GSYS

014700
014700         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014710  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014710  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014710  GUSE

014710         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014720  GBSEG=GSSEG+LOADR;)KILL GSSEG
014720  "9BP05
014720  GSYS

014720
014720         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014730  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014730  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014730  GUSE

014730         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014740  GBSEG=GSSEG+LOADR;)KILL GSSEG
014740  "9BP06
014740  GSYS

014740
014740         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014750  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014750  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014750  GUSE

014750         0;0;FLBPA;LOADR;GSSEG;113;160000;0
014760  GBSEG=GSSEG+LOADR;)KILL GSSEG
014760  "9BP07
014760  GSYS

014760
014760         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
014770  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
014770  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
014770  GUSE

014770         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015000  GBSEG=GSSEG+LOADR;)KILL GSSEG
015000  "9BP08
015000  GSYS

015000
015000         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015010  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015010  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015010  GUSE

015010         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015020  GBSEG=GSSEG+LOADR;)KILL GSSEG
015020  "9BP09
015020  GSYS

015020
015020         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015030  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015030  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015030  GUSE

015030         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015040  GBSEG=GSSEG+LOADR;)KILL GSSEG
015040  "9BP10
015040  GSYS

015040
015040         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015050  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015050  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015050  GUSE

015050         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015060  GBSEG=GSSEG+LOADR;)KILL GSSEG
015060  "9BP11
015060  GSYS

015060
015060         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015070  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015070  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015070  GUSE

015070         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015100  GBSEG=GSSEG+LOADR;)KILL GSSEG
015100  "9BP12
015100  GSYS

015100
015100         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015110  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015110  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015110  GUSE

015110         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015120  GBSEG=GSSEG+LOADR;)KILL GSSEG
015120  "9BP13
015120  GSYS

015120
015120         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015130  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015130  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015130  GUSE

015130         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015140  GBSEG=GSSEG+LOADR;)KILL GSSEG
015140  "9BP14
015140  GSYS

015140
015140         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015150  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015150  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015150  GUSE

015150         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015160  GBSEG=GSSEG+LOADR;)KILL GSSEG
015160  "9BP15
015160  GSYS

015160
015160         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015170  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015170  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015170  GUSE

015170         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015200  GBSEG=GSSEG+LOADR;)KILL GSSEG
015200  "9BP16
015200  GSYS

015200
015200         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015210  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015210  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015210  GUSE

015210         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015220  GBSEG=GSSEG+LOADR;)KILL GSSEG
015220  "9BP17
015220  GSYS

015220
015220         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015230  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015230  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015230  GUSE

015230         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015240  GBSEG=GSSEG+LOADR;)KILL GSSEG
015240  "9BP18
015240  GSYS

015240
015240         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015250  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015250  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015250  GUSE

015250         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015260  GBSEG=GSSEG+LOADR;)KILL GSSEG
015260  "9BP19
015260  GSYS

015260
015260         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015270  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015270  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015270  GUSE

015270         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015300  GBSEG=GSSEG+LOADR;)KILL GSSEG
015300  "9BP20
015300  GSYS

015300
015300         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015310  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015310  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015310  GUSE

015310         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015320  GBSEG=GSSEG+LOADR;)KILL GSSEG
015320  "9BP21
015320  GSYS

015320
015320         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015330  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015330  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015330  GUSE

015330         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015340  GBSEG=GSSEG+LOADR;)KILL GSSEG
015340  "9BP22
015340  GSYS

015340
015340         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015350  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015350  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015350  GUSE

015350         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015360  GBSEG=GSSEG+LOADR;)KILL GSSEG
015360  "9BP23
015360  GSYS

015360
015360         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015370  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015370  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015370  GUSE

015370         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015400  GBSEG=GSSEG+LOADR;)KILL GSSEG
015400  "9BP24
015400  GSYS

015400
015400         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015410  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015410  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015410  GUSE

015410         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015420  GBSEG=GSSEG+LOADR;)KILL GSSEG
015420  "9BP25
015420  GSYS

015420
015420         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015430  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015430  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015430  GUSE

015430         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015440  GBSEG=GSSEG+LOADR;)KILL GSSEG
015440  "9BP26
015440  GSYS

015440
015440         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015450  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015450  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015450  GUSE

015450         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015460  GBSEG=GSSEG+LOADR;)KILL GSSEG
015460  "9BP27
015460  GSYS

015460
015460         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015470  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015470  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015470  GUSE

015470         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015500  GBSEG=GSSEG+LOADR;)KILL GSSEG
015500  "9BP28
015500  GSYS

015500
015500         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015510  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015510  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015510  GUSE

015510         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015520  GBSEG=GSSEG+LOADR;)KILL GSSEG
015520  "9BP29
015520  GSYS

015520
015520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015530  GUSE

015530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015540  GBSEG=GSSEG+LOADR;)KILL GSSEG
015540  "9BP30
015540  GSYS

015540
015540         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015550  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015550  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015550  GUSE

015550         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015560  GBSEG=GSSEG+LOADR;)KILL GSSEG
015560  "9BP31
015560  GSYS

015560
015560         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015570  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015570  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015570  GUSE

015570         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015600  GBSEG=GSSEG+LOADR;)KILL GSSEG
015600  "9BP32
015600  GSYS

015600
015600         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015610  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015610  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015610  GUSE

015610         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015620  GBSEG=GSSEG+LOADR;)KILL GSSEG
015620  "9BP33
015620  GSYS

015620
015620         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015630  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015630  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015630  GUSE

015630         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015640  GBSEG=GSSEG+LOADR;)KILL GSSEG
015640  "9BP34
015640  GSYS

015640
015640         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015650  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015650  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015650  GUSE

015650         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015660  GBSEG=GSSEG+LOADR;)KILL GSSEG
015660  "9BP35
015660  GSYS

015660
015660         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015670  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015670  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015670  GUSE

015670         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015700  GBSEG=GSSEG+LOADR;)KILL GSSEG
015700  "9BP36
015700  GSYS

015700
015700         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015710  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015710  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015710  GUSE

015710         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015720  GBSEG=GSSEG+LOADR;)KILL GSSEG
015720  "9BP37
015720  GSYS

015720
015720         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015730  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015730  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015730  GUSE

015730         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015740  GBSEG=GSSEG+LOADR;)KILL GSSEG
015740  "9BP38
015740  GSYS

015740
015740         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015750  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015750  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015750  GUSE

015750         0;0;FLBPA;LOADR;GSSEG;113;160000;0
015760  GBSEG=GSSEG+LOADR;)KILL GSSEG
015760  "9BP39
015760  GSYS

015760
015760         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
015770  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
015770  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
015770  GUSE

015770         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016000  GBSEG=GSSEG+LOADR;)KILL GSSEG
016000  "9BP40
016000  GSYS

016000
016000         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016010  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016010  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016010  GUSE

016010         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016020  GBSEG=GSSEG+LOADR;)KILL GSSEG
016020  "9BP41
016020  GSYS

016020
016020         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016030  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016030  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016030  GUSE

016030         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016040  GBSEG=GSSEG+LOADR;)KILL GSSEG
016040  "9BP42
016040  GSYS

016040
016040         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016050  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016050  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016050  GUSE

016050         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016060  GBSEG=GSSEG+LOADR;)KILL GSSEG
016060  "9BP43
016060  GSYS

016060
016060         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016070  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016070  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016070  GUSE

016070         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016100  GBSEG=GSSEG+LOADR;)KILL GSSEG
016100  "9BP44
016100  GSYS

016100
016100         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016110  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016110  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016110  GUSE

016110         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016120  GBSEG=GSSEG+LOADR;)KILL GSSEG
016120  "9BP45
016120  GSYS

016120
016120         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016130  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016130  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016130  GUSE

016130         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016140  GBSEG=GSSEG+LOADR;)KILL GSSEG
016140  "9BP46
016140  GSYS

016140
016140         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016150  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016150  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016150  GUSE

016150         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016160  GBSEG=GSSEG+LOADR;)KILL GSSEG
016160  "9BP47
016160  GSYS

016160
016160         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016170  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016170  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016170  GUSE

016170         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016200  GBSEG=GSSEG+LOADR;)KILL GSSEG
016200  "9BP48
016200  GSYS

016200
016200         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016210  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016210  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016210  GUSE

016210         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016220  GBSEG=GSSEG+LOADR;)KILL GSSEG
016220  "9BP49
016220  GSYS

016220
016220         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016230  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016230  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016230  GUSE

016230         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016240  GBSEG=GSSEG+LOADR;)KILL GSSEG
016240  "9BP50
016240  GSYS

016240
016240         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016250  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016250  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016250  GUSE

016250         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016260  GBSEG=GSSEG+LOADR;)KILL GSSEG
016260  "9BP51
016260  GSYS

016260
016260         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016270  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016270  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016270  GUSE

016270         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016300  GBSEG=GSSEG+LOADR;)KILL GSSEG
016300  "8BCH1
016300  GSYS

016300
016300         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016310  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016310  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016310  GUSE

016310         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016320  GBSEG=GSSEG+LOADR;)KILL GSSEG
016320  "8BCH2
016320  GSYS

016320
016320         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016330  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016330  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016330  GUSE

016330         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016340  GBSEG=GSSEG+LOADR;)KILL GSSEG
016340  "8BCH3
016340  GSYS

016340
016340         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016350  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016350  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016350  GUSE

016350         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016360  GBSEG=GSSEG+LOADR;)KILL GSSEG
016360  "8BCH4
016360  GSYS

016360
016360         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016370  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016370  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016370  GUSE

016370         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016400  GBSEG=GSSEG+LOADR;)KILL GSSEG
016400  "8BCH5
016400  GSYS

016400
016400         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016410  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016410  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016410  GUSE

016410         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016420  GBSEG=GSSEG+LOADR;)KILL GSSEG
016420  "8BCH6
016420  GSYS

016420
016420         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016430  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016430  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016430  GUSE

016430         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016440  GBSEG=GSSEG+LOADR;)KILL GSSEG
016440  "8BCH7
016440  GSYS

016440
016440         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016450  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016450  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016450  GUSE

016450         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016460  GBSEG=GSSEG+LOADR;)KILL GSSEG
016460  "8BCH8
016460  GSYS

016460
016460         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016470  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016470  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016470  GUSE

016470         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016500  GBSEG=GSSEG+LOADR;)KILL GSSEG
016500  "8BCH9
016500  GSYS

016500
016500         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016510  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016510  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016510  GUSE

016510         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016520  GBSEG=GSSEG+LOADR;)KILL GSSEG
016520  "8BC10
016520  GSYS

016520
016520         0;0;DPIT@6+SYSST;5SSSZ;GBSEG;117;162000;0
016530  GSSEG=GBSEG+5SSSZ;)KILL GBSEG
016530  XY=NNBRT; )KILL NNBRT; NNBRT=XY+1; )KILL XY
016530  GUSE

016530         0;0;FLBPA;LOADR;GSSEG;113;160000;0
016540  GBSEG=GSSEG+LOADR;)KILL GSSEG
016540  "
016540  9SYSS=*                                % END OF SYS/BACKGR SEGMENTS
016540
016540  "8ADP
016540  %=======================================================================
016540  %       EXTRA DATA SEGMENTS FOR MON ADP.
016540  %
016540  FREDS=*@-3       % FIRST EXTRA DATA SEGMENT
016540
016540  MSGLE 77

016540
016540         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016540         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016540
016540  ADPSG

016540  0;0;200;CSGLE;SGMAD;113;140000;0
016550  "8BP2 8ADP
016550  MSGLE 77

016550
016550         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016550         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016550
016550  ADPSG

016550  0;0;200;CSGLE;SGMAD;113;140000;0
016560  "8BP3 8ADP
016560  MSGLE 77

016560
016560         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016560         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016560
016560  ADPSG

016560  0;0;200;CSGLE;SGMAD;113;140000;0
016570  "8BP4 8ADP
016570  MSGLE 77

016570
016570         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016570         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016570
016570  ADPSG

016570  0;0;200;CSGLE;SGMAD;113;140000;0
016600  "8BP5 8ADP
016600  MSGLE 77

016600
016600         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016600         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016600
016600  ADPSG

016600  0;0;200;CSGLE;SGMAD;113;140000;0
016610  "8BP6 8ADP
016610  MSGLE 77

016610
016610         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016610         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016610
016610  ADPSG

016610  0;0;200;CSGLE;SGMAD;113;140000;0
016620  "8BP7 8ADP
016620  MSGLE 77

016620
016620         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016620         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016620
016620  ADPSG

016620  0;0;200;CSGLE;SGMAD;113;140000;0
016630  "8BP8 8ADP
016630  MSGLE 77

016630
016630         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016630         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016630
016630  ADPSG

016630  0;0;200;CSGLE;SGMAD;113;140000;0
016640  "8BP9 8ADP
016640  MSGLE 77

016640
016640         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016640         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016640
016640  ADPSG

016640  0;0;200;CSGLE;SGMAD;113;140000;0
016650  "8BP10 8ADP
016650  MSGLE 77

016650
016650         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016650         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016650
016650  ADPSG

016650  0;0;200;CSGLE;SGMAD;113;140000;0
016660  "8BP11 8ADP
016660  MSGLE 77

016660
016660         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016660         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016660
016660  ADPSG

016660  0;0;200;CSGLE;SGMAD;113;140000;0
016670  "8BP12 8ADP
016670  MSGLE 77

016670
016670         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016670         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016670
016670  ADPSG

016670  0;0;200;CSGLE;SGMAD;113;140000;0
016700  "8BP13 8ADP
016700  MSGLE 77

016700
016700         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016700         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016700
016700  ADPSG

016700  0;0;200;CSGLE;SGMAD;113;140000;0
016710  "8BP14 8ADP
016710  MSGLE 77

016710
016710         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016710         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016710
016710  ADPSG

016710  0;0;200;CSGLE;SGMAD;113;140000;0
016720  "8BP15 8ADP
016720  MSGLE 77

016720
016720         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016720         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016720
016720  ADPSG

016720  0;0;200;CSGLE;SGMAD;113;140000;0
016730  "8BP16 8ADP
016730  MSGLE 77

016730
016730         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016730         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016730
016730  ADPSG

016730  0;0;200;CSGLE;SGMAD;113;140000;0
016740  "8BP17 8ADP
016740  MSGLE 77

016740
016740         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016740         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016740
016740  ADPSG

016740  0;0;200;CSGLE;SGMAD;113;140000;0
016750  "8BP18 8ADP
016750  MSGLE 77

016750
016750         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016750         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016750
016750  ADPSG

016750  0;0;200;CSGLE;SGMAD;113;140000;0
016760  "8BP19 8ADP
016760  MSGLE 77

016760
016760         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016760         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016760
016760  ADPSG

016760  0;0;200;CSGLE;SGMAD;113;140000;0
016770  "8BP20 8ADP
016770  MSGLE 77

016770
016770         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
016770         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
016770
016770  ADPSG

016770  0;0;200;CSGLE;SGMAD;113;140000;0
017000  "8BP21 8ADP
017000  MSGLE 77

017000
017000         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017000         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017000
017000  ADPSG

017000  0;0;200;CSGLE;SGMAD;113;140000;0
017010  "8BP22 8ADP
017010  MSGLE 77

017010
017010         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017010         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017010
017010  ADPSG

017010  0;0;200;CSGLE;SGMAD;113;140000;0
017020  "8BP23 8ADP
017020  MSGLE 77

017020
017020         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017020         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017020
017020  ADPSG

017020  0;0;200;CSGLE;SGMAD;113;140000;0
017030  "8BP24 8ADP
017030  MSGLE 77

017030
017030         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017030         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017030
017030  ADPSG

017030  0;0;200;CSGLE;SGMAD;113;140000;0
017040  "8BP25 8ADP
017040  MSGLE 77

017040
017040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017040         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017040
017040  ADPSG

017040  0;0;200;CSGLE;SGMAD;113;140000;0
017050  "8BP26 8ADP
017050  MSGLE 77

017050
017050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017050         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017050
017050  ADPSG

017050  0;0;200;CSGLE;SGMAD;113;140000;0
017060  "8BP27 8ADP
017060  MSGLE 77

017060
017060         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017060         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017060
017060  ADPSG

017060  0;0;200;CSGLE;SGMAD;113;140000;0
017070  "8BP28 8ADP
017070  MSGLE 77

017070
017070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017070         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017070
017070  ADPSG

017070  0;0;200;CSGLE;SGMAD;113;140000;0
017100  "8BP29 8ADP
017100  MSGLE 77

017100
017100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017100         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017100
017100  ADPSG

017100  0;0;200;CSGLE;SGMAD;113;140000;0
017110  "8BP30 8ADP
017110  MSGLE 77

017110
017110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017110         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017110
017110  ADPSG

017110  0;0;200;CSGLE;SGMAD;113;140000;0
017120  "8BP31 8ADP
017120  MSGLE 77

017120
017120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017120
017120  ADPSG

017120  0;0;200;CSGLE;SGMAD;113;140000;0
017130  "8BP32 8ADP
017130  MSGLE 77

017130
017130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017130
017130  ADPSG

017130  0;0;200;CSGLE;SGMAD;113;140000;0
017140  "8BP33 8ADP
017140  MSGLE 77

017140
017140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017140
017140  ADPSG

017140  0;0;200;CSGLE;SGMAD;113;140000;0
017150  "8BP34 8ADP
017150  MSGLE 77

017150
017150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017150
017150  ADPSG

017150  0;0;200;CSGLE;SGMAD;113;140000;0
017160  "8BP35 8ADP
017160  MSGLE 77

017160
017160         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017160         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017160
017160  ADPSG

017160  0;0;200;CSGLE;SGMAD;113;140000;0
017170  "8BP36 8ADP
017170  MSGLE 77

017170
017170         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017170         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017170
017170  ADPSG

017170  0;0;200;CSGLE;SGMAD;113;140000;0
017200  "8BP37 8ADP
017200  MSGLE 77

017200
017200         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017200         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017200
017200  ADPSG

017200  0;0;200;CSGLE;SGMAD;113;140000;0
017210  "8BP38 8ADP
017210  MSGLE 77

017210
017210         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017210         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017210
017210  ADPSG

017210  0;0;200;CSGLE;SGMAD;113;140000;0
017220  "8BP39 8ADP
017220  MSGLE 77

017220
017220         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017220         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017220
017220  ADPSG

017220  0;0;200;CSGLE;SGMAD;113;140000;0
017230  "8BP40 8ADP
017230  MSGLE 77

017230
017230         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017230         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017230
017230  ADPSG

017230  0;0;200;CSGLE;SGMAD;113;140000;0
017240  "8BP41 8ADP
017240  MSGLE 77

017240
017240         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017240         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017240
017240  ADPSG

017240  0;0;200;CSGLE;SGMAD;113;140000;0
017250  "8BP42 8ADP
017250  MSGLE 77

017250
017250         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017250         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017250
017250  ADPSG

017250  0;0;200;CSGLE;SGMAD;113;140000;0
017260  "8BP43 8ADP
017260  MSGLE 77

017260
017260         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017260         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017260
017260  ADPSG

017260  0;0;200;CSGLE;SGMAD;113;140000;0
017270  "8BP44 8ADP
017270  MSGLE 77

017270
017270         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017270         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017270
017270  ADPSG

017270  0;0;200;CSGLE;SGMAD;113;140000;0
017300  "8BP45 8ADP
017300  MSGLE 77

017300
017300         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017300         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017300
017300  ADPSG

017300  0;0;200;CSGLE;SGMAD;113;140000;0
017310  "8BP46 8ADP
017310  MSGLE 77

017310
017310         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017310         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017310
017310  ADPSG

017310  0;0;200;CSGLE;SGMAD;113;140000;0
017320  "8BP47 8ADP
017320  MSGLE 77

017320
017320         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017320         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017320
017320  ADPSG

017320  0;0;200;CSGLE;SGMAD;113;140000;0
017330  "8BP48 8ADP
017330  MSGLE 77

017330
017330         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017330         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017330
017330  ADPSG

017330  0;0;200;CSGLE;SGMAD;113;140000;0
017340  "8BP49 8ADP
017340  MSGLE 77

017340
017340         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017340         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017340
017340  ADPSG

017340  0;0;200;CSGLE;SGMAD;113;140000;0
017350  "8BP50 8ADP
017350  MSGLE 77

017350
017350         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017350         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017350
017350  ADPSG

017350  0;0;200;CSGLE;SGMAD;113;140000;0
017360  "8BP51 8ADP
017360  MSGLE 77

017360
017360         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017360         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017360
017360  ADPSG

017360  0;0;200;CSGLE;SGMAD;113;140000;0
017370  "8BP52 8ADP
017370  MSGLE 77

017370
017370         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017370         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017370
017370  ADPSG

017370  0;0;200;CSGLE;SGMAD;113;140000;0
017400  "8BP53 8ADP
017400  MSGLE 77

017400
017400         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017400         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017400
017400  ADPSG

017400  0;0;200;CSGLE;SGMAD;113;140000;0
017410  "8BP54 8ADP
017410  MSGLE 77

017410
017410         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017410         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017410
017410  ADPSG

017410  0;0;200;CSGLE;SGMAD;113;140000;0
017420  "8BP55 8ADP
017420  MSGLE 77

017420
017420         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017420         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017420
017420  ADPSG

017420  0;0;200;CSGLE;SGMAD;113;140000;0
017430  "8BP56 8ADP
017430  MSGLE 77

017430
017430         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017430         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017430
017430  ADPSG

017430  0;0;200;CSGLE;SGMAD;113;140000;0
017440  "8BP57 8ADP
017440  MSGLE 77

017440
017440         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017440         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017440
017440  ADPSG

017440  0;0;200;CSGLE;SGMAD;113;140000;0
017450  "8BP58 8ADP
017450  MSGLE 77

017450
017450         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017450         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017450
017450  ADPSG

017450  0;0;200;CSGLE;SGMAD;113;140000;0
017460  "8BP59 8ADP
017460  MSGLE 77

017460
017460         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017460         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017460
017460  ADPSG

017460  0;0;200;CSGLE;SGMAD;113;140000;0
017470  "8BP60 8ADP
017470  MSGLE 77

017470
017470         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017470         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017470
017470  ADPSG

017470  0;0;200;CSGLE;SGMAD;113;140000;0
017500  "8BP61 8ADP
017500  MSGLE 77

017500
017500         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017500         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017500
017500  ADPSG

017500  0;0;200;CSGLE;SGMAD;113;140000;0
017510  "8BP62 8ADP
017510  MSGLE 77

017510
017510         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017510         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017510
017510  ADPSG

017510  0;0;200;CSGLE;SGMAD;113;140000;0
017520  "8BP63 8ADP
017520  MSGLE 77

017520
017520         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017520         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017520
017520  ADPSG

017520  0;0;200;CSGLE;SGMAD;113;140000;0
017530  "8BP64 8ADP
017530  MSGLE 77

017530
017530         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017530         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017530
017530  ADPSG

017530  0;0;200;CSGLE;SGMAD;113;140000;0
017540  "8BP65 8ADP
017540  MSGLE 77

017540
017540         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017540         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017540
017540  ADPSG

017540  0;0;200;CSGLE;SGMAD;113;140000;0
017550  "8BP66 8ADP
017550  MSGLE 77

017550
017550         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017550         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017550
017550  ADPSG

017550  0;0;200;CSGLE;SGMAD;113;140000;0
017560  "8BP67 8ADP
017560  MSGLE 77

017560
017560         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017560         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017560
017560  ADPSG

017560  0;0;200;CSGLE;SGMAD;113;140000;0
017570  "8BP68 8ADP
017570  MSGLE 77

017570
017570         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017570         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017570
017570  ADPSG

017570  0;0;200;CSGLE;SGMAD;113;140000;0
017600  "8BP69 8ADP
017600  MSGLE 77

017600
017600         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017600         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017600
017600  ADPSG

017600  0;0;200;CSGLE;SGMAD;113;140000;0
017610  "8BP70 8ADP
017610  MSGLE 77

017610
017610         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017610         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017610
017610  ADPSG

017610  0;0;200;CSGLE;SGMAD;113;140000;0
017620  "8BP71 8ADP
017620  MSGLE 77

017620
017620         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017620         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017620
017620  ADPSG

017620  0;0;200;CSGLE;SGMAD;113;140000;0
017630  "8BP72 8ADP
017630  MSGLE 77

017630
017630         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017630         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017630
017630  ADPSG

017630  0;0;200;CSGLE;SGMAD;113;140000;0
017640  "8BP73 8ADP
017640  MSGLE 77

017640
017640         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017640         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017640
017640  ADPSG

017640  0;0;200;CSGLE;SGMAD;113;140000;0
017650  "8BP74 8ADP
017650  MSGLE 77

017650
017650         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017650         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017650
017650  ADPSG

017650  0;0;200;CSGLE;SGMAD;113;140000;0
017660  "8BP75 8ADP
017660  MSGLE 77

017660
017660         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017660         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017660
017660  ADPSG

017660  0;0;200;CSGLE;SGMAD;113;140000;0
017670  "8BP76 8ADP
017670  MSGLE 77

017670
017670         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017670         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017670
017670  ADPSG

017670  0;0;200;CSGLE;SGMAD;113;140000;0
017700  "8BP77 8ADP
017700  MSGLE 77

017700
017700         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017700         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017700
017700  ADPSG

017700  0;0;200;CSGLE;SGMAD;113;140000;0
017710  "8BP78 8ADP
017710  MSGLE 77

017710
017710         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017710         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017710
017710  ADPSG

017710  0;0;200;CSGLE;SGMAD;113;140000;0
017720  "8BP79 8ADP
017720  MSGLE 77

017720
017720         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017720         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017720
017720  ADPSG

017720  0;0;200;CSGLE;SGMAD;113;140000;0
017730  "8BP80 8ADP
017730  MSGLE 77

017730
017730         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017730         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017730
017730  ADPSG

017730  0;0;200;CSGLE;SGMAD;113;140000;0
017740  "8BP81 8ADP
017740  MSGLE 77

017740
017740         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017740         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017740
017740  ADPSG

017740  0;0;200;CSGLE;SGMAD;113;140000;0
017750  "8BP82 8ADP
017750  MSGLE 77

017750
017750         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017750         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017750
017750  ADPSG

017750  0;0;200;CSGLE;SGMAD;113;140000;0
017760  "8BP83 8ADP
017760  MSGLE 77

017760
017760         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017760         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017760
017760  ADPSG

017760  0;0;200;CSGLE;SGMAD;113;140000;0
017770  "8BP84 8ADP
017770  MSGLE 77

017770
017770         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
017770         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
017770
017770  ADPSG

017770  0;0;200;CSGLE;SGMAD;113;140000;0
020000  "8BP85 8ADP
020000  MSGLE 77

020000
020000         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020000         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020000
020000  ADPSG

020000  0;0;200;CSGLE;SGMAD;113;140000;0
020010  "8BP86 8ADP
020010  MSGLE 77

020010
020010         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020010         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020010
020010  ADPSG

020010  0;0;200;CSGLE;SGMAD;113;140000;0
020020  "8BP87 8ADP
020020  MSGLE 77

020020
020020         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020020         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020020
020020  ADPSG

020020  0;0;200;CSGLE;SGMAD;113;140000;0
020030  "8BP88 8ADP
020030  MSGLE 77

020030
020030         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020030         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020030
020030  ADPSG

020030  0;0;200;CSGLE;SGMAD;113;140000;0
020040  "8BP89 8ADP
020040  MSGLE 77

020040
020040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020040         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020040
020040  ADPSG

020040  0;0;200;CSGLE;SGMAD;113;140000;0
020050  "8BP90 8ADP
020050  MSGLE 77

020050
020050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020050         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020050
020050  ADPSG

020050  0;0;200;CSGLE;SGMAD;113;140000;0
020060  "8BP91 8ADP
020060  MSGLE 77

020060
020060         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020060         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020060
020060  ADPSG

020060  0;0;200;CSGLE;SGMAD;113;140000;0
020070  "8BP92 8ADP
020070  MSGLE 77

020070
020070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020070         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020070
020070  ADPSG

020070  0;0;200;CSGLE;SGMAD;113;140000;0
020100  "8BP93 8ADP
020100  MSGLE 77

020100
020100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020100         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020100
020100  ADPSG

020100  0;0;200;CSGLE;SGMAD;113;140000;0
020110  "8BP94 8ADP
020110  MSGLE 77

020110
020110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020110         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020110
020110  ADPSG

020110  0;0;200;CSGLE;SGMAD;113;140000;0
020120  "8BP95 8ADP
020120  MSGLE 77

020120
020120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020120
020120  ADPSG

020120  0;0;200;CSGLE;SGMAD;113;140000;0
020130  "8BP96 8ADP
020130  MSGLE 77

020130
020130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020130
020130  ADPSG

020130  0;0;200;CSGLE;SGMAD;113;140000;0
020140  "8BP97 8ADP
020140  MSGLE 77

020140
020140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020140
020140  ADPSG

020140  0;0;200;CSGLE;SGMAD;113;140000;0
020150  "8BP98 8ADP
020150  MSGLE 77

020150
020150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020150
020150  ADPSG

020150  0;0;200;CSGLE;SGMAD;113;140000;0
020160  "8BP99 8ADP
020160  MSGLE 77

020160
020160         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020160         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020160
020160  ADPSG

020160  0;0;200;CSGLE;SGMAD;113;140000;0
020170  "9BP00 8ADP
020170  MSGLE 77

020170
020170         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020170         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020170
020170  ADPSG

020170  0;0;200;CSGLE;SGMAD;113;140000;0
020200  "9BP01 8ADP
020200  MSGLE 77

020200
020200         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020200         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020200
020200  ADPSG

020200  0;0;200;CSGLE;SGMAD;113;140000;0
020210  "9BP02 8ADP
020210  MSGLE 77

020210
020210         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020210         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020210
020210  ADPSG

020210  0;0;200;CSGLE;SGMAD;113;140000;0
020220  "9BP03 8ADP
020220  MSGLE 77

020220
020220         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020220         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020220
020220  ADPSG

020220  0;0;200;CSGLE;SGMAD;113;140000;0
020230  "9BP04 8ADP
020230  MSGLE 77

020230
020230         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020230         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020230
020230  ADPSG

020230  0;0;200;CSGLE;SGMAD;113;140000;0
020240  "9BP05 8ADP
020240  MSGLE 77

020240
020240         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020240         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020240
020240  ADPSG

020240  0;0;200;CSGLE;SGMAD;113;140000;0
020250  "9BP06 8ADP
020250  MSGLE 77

020250
020250         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020250         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020250
020250  ADPSG

020250  0;0;200;CSGLE;SGMAD;113;140000;0
020260  "9BP07 8ADP
020260  MSGLE 77

020260
020260         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020260         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020260
020260  ADPSG

020260  0;0;200;CSGLE;SGMAD;113;140000;0
020270  "9BP08 8ADP
020270  MSGLE 77

020270
020270         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020270         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020270
020270  ADPSG

020270  0;0;200;CSGLE;SGMAD;113;140000;0
020300  "9BP09 8ADP
020300  MSGLE 77

020300
020300         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020300         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020300
020300  ADPSG

020300  0;0;200;CSGLE;SGMAD;113;140000;0
020310  "9BP10 8ADP
020310  MSGLE 77

020310
020310         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020310         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020310
020310  ADPSG

020310  0;0;200;CSGLE;SGMAD;113;140000;0
020320  "9BP11 8ADP
020320  MSGLE 77

020320
020320         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020320         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020320
020320  ADPSG

020320  0;0;200;CSGLE;SGMAD;113;140000;0
020330  "9BP12 8ADP
020330  MSGLE 77

020330
020330         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020330         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020330
020330  ADPSG

020330  0;0;200;CSGLE;SGMAD;113;140000;0
020340  "9BP13 8ADP
020340  MSGLE 77

020340
020340         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020340         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020340
020340  ADPSG

020340  0;0;200;CSGLE;SGMAD;113;140000;0
020350  "9BP14 8ADP
020350  MSGLE 77

020350
020350         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020350         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020350
020350  ADPSG

020350  0;0;200;CSGLE;SGMAD;113;140000;0
020360  "9BP15 8ADP
020360  MSGLE 77

020360
020360         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020360         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020360
020360  ADPSG

020360  0;0;200;CSGLE;SGMAD;113;140000;0
020370  "9BP16 8ADP
020370  MSGLE 77

020370
020370         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020370         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020370
020370  ADPSG

020370  0;0;200;CSGLE;SGMAD;113;140000;0
020400  "9BP17 8ADP
020400  MSGLE 77

020400
020400         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020400         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020400
020400  ADPSG

020400  0;0;200;CSGLE;SGMAD;113;140000;0
020410  "9BP18 8ADP
020410  MSGLE 77

020410
020410         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020410         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020410
020410  ADPSG

020410  0;0;200;CSGLE;SGMAD;113;140000;0
020420  "9BP19 8ADP
020420  MSGLE 77

020420
020420         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020420         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020420
020420  ADPSG

020420  0;0;200;CSGLE;SGMAD;113;140000;0
020430  "9BP20 8ADP
020430  MSGLE 77

020430
020430         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020430         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020430
020430  ADPSG

020430  0;0;200;CSGLE;SGMAD;113;140000;0
020440  "9BP21 8ADP
020440  MSGLE 77

020440
020440         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020440         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020440
020440  ADPSG

020440  0;0;200;CSGLE;SGMAD;113;140000;0
020450  "9BP22 8ADP
020450  MSGLE 77

020450
020450         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020450         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020450
020450  ADPSG

020450  0;0;200;CSGLE;SGMAD;113;140000;0
020460  "9BP23 8ADP
020460  MSGLE 77

020460
020460         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020460         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020460
020460  ADPSG

020460  0;0;200;CSGLE;SGMAD;113;140000;0
020470  "9BP24 8ADP
020470  MSGLE 77

020470
020470         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020470         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020470
020470  ADPSG

020470  0;0;200;CSGLE;SGMAD;113;140000;0
020500  "9BP25 8ADP
020500  MSGLE 77

020500
020500         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020500         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020500
020500  ADPSG

020500  0;0;200;CSGLE;SGMAD;113;140000;0
020510  "9BP26 8ADP
020510  MSGLE 77

020510
020510         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020510         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020510
020510  ADPSG

020510  0;0;200;CSGLE;SGMAD;113;140000;0
020520  "9BP27 8ADP
020520  MSGLE 77

020520
020520         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020520         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020520
020520  ADPSG

020520  0;0;200;CSGLE;SGMAD;113;140000;0
020530  "9BP28 8ADP
020530  MSGLE 77

020530
020530         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020530         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020530
020530  ADPSG

020530  0;0;200;CSGLE;SGMAD;113;140000;0
020540  "9BP29 8ADP
020540  MSGLE 77

020540
020540         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020540         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020540
020540  ADPSG

020540  0;0;200;CSGLE;SGMAD;113;140000;0
020550  "9BP30 8ADP
020550  MSGLE 77

020550
020550         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020550         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020550
020550  ADPSG

020550  0;0;200;CSGLE;SGMAD;113;140000;0
020560  "9BP31 8ADP
020560  MSGLE 77

020560
020560         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020560         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020560
020560  ADPSG

020560  0;0;200;CSGLE;SGMAD;113;140000;0
020570  "9BP32 8ADP
020570  MSGLE 77

020570
020570         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020570         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020570
020570  ADPSG

020570  0;0;200;CSGLE;SGMAD;113;140000;0
020600  "9BP33 8ADP
020600  MSGLE 77

020600
020600         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020600         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020600
020600  ADPSG

020600  0;0;200;CSGLE;SGMAD;113;140000;0
020610  "9BP34 8ADP
020610  MSGLE 77

020610
020610         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020610         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020610
020610  ADPSG

020610  0;0;200;CSGLE;SGMAD;113;140000;0
020620  "9BP35 8ADP
020620  MSGLE 77

020620
020620         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020620         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020620
020620  ADPSG

020620  0;0;200;CSGLE;SGMAD;113;140000;0
020630  "9BP36 8ADP
020630  MSGLE 77

020630
020630         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020630         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020630
020630  ADPSG

020630  0;0;200;CSGLE;SGMAD;113;140000;0
020640  "9BP37 8ADP
020640  MSGLE 77

020640
020640         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020640         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020640
020640  ADPSG

020640  0;0;200;CSGLE;SGMAD;113;140000;0
020650  "9BP38 8ADP
020650  MSGLE 77

020650
020650         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020650         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020650
020650  ADPSG

020650  0;0;200;CSGLE;SGMAD;113;140000;0
020660  "9BP39 8ADP
020660  MSGLE 77

020660
020660         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020660         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020660
020660  ADPSG

020660  0;0;200;CSGLE;SGMAD;113;140000;0
020670  "9BP40 8ADP
020670  MSGLE 77

020670
020670         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020670         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020670
020670  ADPSG

020670  0;0;200;CSGLE;SGMAD;113;140000;0
020700  "9BP41 8ADP
020700  MSGLE 77

020700
020700         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020700         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020700
020700  ADPSG

020700  0;0;200;CSGLE;SGMAD;113;140000;0
020710  "9BP42 8ADP
020710  MSGLE 77

020710
020710         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020710         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020710
020710  ADPSG

020710  0;0;200;CSGLE;SGMAD;113;140000;0
020720  "9BP43 8ADP
020720  MSGLE 77

020720
020720         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020720         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020720
020720  ADPSG

020720  0;0;200;CSGLE;SGMAD;113;140000;0
020730  "9BP44 8ADP
020730  MSGLE 77

020730
020730         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020730         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020730
020730  ADPSG

020730  0;0;200;CSGLE;SGMAD;113;140000;0
020740  "9BP45 8ADP
020740  MSGLE 77

020740
020740         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020740         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020740
020740  ADPSG

020740  0;0;200;CSGLE;SGMAD;113;140000;0
020750  "9BP46 8ADP
020750  MSGLE 77

020750
020750         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020750         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020750
020750  ADPSG

020750  0;0;200;CSGLE;SGMAD;113;140000;0
020760  "9BP47 8ADP
020760  MSGLE 77

020760
020760         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020760         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020760
020760  ADPSG

020760  0;0;200;CSGLE;SGMAD;113;140000;0
020770  "9BP48 8ADP
020770  MSGLE 77

020770
020770         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020770         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020770
020770  ADPSG

020770  0;0;200;CSGLE;SGMAD;113;140000;0
021000  "9BP49 8ADP
021000  MSGLE 77

021000
021000         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021000         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021000
021000  ADPSG

021000  0;0;200;CSGLE;SGMAD;113;140000;0
021010  "9BP50 8ADP
021010  MSGLE 77

021010
021010         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021010         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021010
021010  ADPSG

021010  0;0;200;CSGLE;SGMAD;113;140000;0
021020  "9BP51 8ADP
021020  MSGLE 77

021020
021020         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021020         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021020
021020  ADPSG

021020  0;0;200;CSGLE;SGMAD;113;140000;0
021030  "TEFX1 8ADP
021030  MSGLE 77

021030
021030         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021030         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021030
021030  ADPSG

021030  0;0;200;CSGLE;SGMAD;113;140000;0
021040  "8BCH1 8ADP
021040  MSGLE 77

021040
021040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021040         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021040
021040  ADPSG

021040  0;0;200;CSGLE;SGMAD;113;140000;0
021050  "8BCH2 8ADP
021050  MSGLE 77

021050
021050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021050         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021050
021050  ADPSG

021050  0;0;200;CSGLE;SGMAD;113;140000;0
021060  "8BCH3 8ADP
021060  MSGLE 77

021060
021060         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021060         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021060
021060  ADPSG

021060  0;0;200;CSGLE;SGMAD;113;140000;0
021070  "8BCH4 8ADP
021070  MSGLE 77

021070
021070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021070         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021070
021070  ADPSG

021070  0;0;200;CSGLE;SGMAD;113;140000;0
021100  "8BCH5 8ADP
021100  MSGLE 77

021100
021100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021100         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021100
021100  ADPSG

021100  0;0;200;CSGLE;SGMAD;113;140000;0
021110  "8BCH6 8ADP
021110  MSGLE 77

021110
021110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021110         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021110
021110  ADPSG

021110  0;0;200;CSGLE;SGMAD;113;140000;0
021120  "8BCH7 8ADP
021120  MSGLE 77

021120
021120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021120
021120  ADPSG

021120  0;0;200;CSGLE;SGMAD;113;140000;0
021130  "8BCH8 8ADP
021130  MSGLE 77

021130
021130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021130
021130  ADPSG

021130  0;0;200;CSGLE;SGMAD;113;140000;0
021140  "8BCH9 8ADP
021140  MSGLE 77

021140
021140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021140
021140  ADPSG

021140  0;0;200;CSGLE;SGMAD;113;140000;0
021150  "8BC10 8ADP
021150  MSGLE 77

021150
021150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021150
021150  ADPSG

021150  0;0;200;CSGLE;SGMAD;113;140000;0
021160  "
021160
021160  SEGTX=*
021160  *8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN/
031020  9ESGT=*
031020
031020
031020  )LINE
; CSGLE=SGLEN
020640
020640  ADPSG

020640  0;0;200;CSGLE;SGMAD;113;140000;0
020650  "9BP38 8ADP
020650  MSGLE 77

020650
020650         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020650         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020650
020650  ADPSG

020650  0;0;200;CSGLE;SGMAD;113;140000;0
020660  "9BP39 8ADP
020660  MSGLE 77

020660
020660         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020660         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020660
020660  ADPSG

020660  0;0;200;CSGLE;SGMAD;113;140000;0
020670  "9BP40 8ADP
020670  MSGLE 77

020670
020670         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020670         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020670
020670  ADPSG

020670  0;0;200;CSGLE;SGMAD;113;140000;0
020700  "9BP41 8ADP
020700  MSGLE 77

020700
020700         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020700         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020700
020700  ADPSG

020700  0;0;200;CSGLE;SGMAD;113;140000;0
020710  "9BP42 8ADP
020710  MSGLE 77

020710
020710         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020710         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020710
020710  ADPSG

020710  0;0;200;CSGLE;SGMAD;113;140000;0
020720  "9BP43 8ADP
020720  MSGLE 77

020720
020720         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020720         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020720
020720  ADPSG

020720  0;0;200;CSGLE;SGMAD;113;140000;0
020730  "9BP44 8ADP
020730  MSGLE 77

020730
020730         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020730         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020730
020730  ADPSG

020730  0;0;200;CSGLE;SGMAD;113;140000;0
020740  "9BP45 8ADP
020740  MSGLE 77

020740
020740         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020740         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020740
020740  ADPSG

020740  0;0;200;CSGLE;SGMAD;113;140000;0
020750  "9BP46 8ADP
020750  MSGLE 77

020750
020750         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020750         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020750
020750  ADPSG

020750  0;0;200;CSGLE;SGMAD;113;140000;0
020760  "9BP47 8ADP
020760  MSGLE 77

020760
020760         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020760         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020760
020760  ADPSG

020760  0;0;200;CSGLE;SGMAD;113;140000;0
020770  "9BP48 8ADP
020770  MSGLE 77

020770
020770         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020770         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020770
020770  ADPSG

020770  0;0;200;CSGLE;SGMAD;113;140000;0
021000  "9BP49 8ADP
021000  MSGLE 77

021000
021000         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021000         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021000
021000  ADPSG

021000  0;0;200;CSGLE;SGMAD;113;140000;0
021010  "9BP50 8ADP
021010  MSGLE 77

021010
021010         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021010         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021010
021010  ADPSG

021010  0;0;200;CSGLE;SGMAD;113;140000;0
021020  "9BP51 8ADP
021020  MSGLE 77

021020
021020         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021020         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021020
021020  ADPSG

021020  0;0;200;CSGLE;SGMAD;113;140000;0
021030  "TEFX1 8ADP
021030  MSGLE 77

021030
021030         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021030         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021030
021030  ADPSG

021030  0;0;200;CSGLE;SGMAD;113;140000;0
021040  "8BCH1 8ADP
021040  MSGLE 77

021040
021040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021040         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021040
021040  ADPSG

021040  0;0;200;CSGLE;SGMAD;113;140000;0
021050  "8BCH2 8ADP
021050  MSGLE 77

021050
021050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021050         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021050
021050  ADPSG

021050  0;0;200;CSGLE;SGMAD;113;140000;0
021060  "8BCH3 8ADP
021060  MSGLE 77

021060
021060         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021060         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021060
021060  ADPSG

021060  0;0;200;CSGLE;SGMAD;113;140000;0
021070  "8BCH4 8ADP
021070  MSGLE 77

021070
021070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021070         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021070
021070  ADPSG

021070  0;0;200;CSGLE;SGMAD;113;140000;0
021100  "8BCH5 8ADP
021100  MSGLE 77

021100
021100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021100         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021100
021100  ADPSG

021100  0;0;200;CSGLE;SGMAD;113;140000;0
021110  "8BCH6 8ADP
021110  MSGLE 77

021110
021110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021110         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021110
021110  ADPSG

021110  0;0;200;CSGLE;SGMAD;113;140000;0
021120  "8BCH7 8ADP
021120  MSGLE 77

021120
021120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021120
021120  ADPSG

021120  0;0;200;CSGLE;SGMAD;113;140000;0
021130  "8BCH8 8ADP
021130  MSGLE 77

021130
021130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021130
021130  ADPSG

021130  0;0;200;CSGLE;SGMAD;113;140000;0
021140  "8BCH9 8ADP
021140  MSGLE 77

021140
021140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021140
021140  ADPSG

021140  0;0;200;CSGLE;SGMAD;113;140000;0
021150  "8BC10 8ADP
021150  MSGLE 77

021150
021150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021150
021150  ADPSG

021150  0;0;200;CSGLE;SGMAD;113;140000;0
021160  "
021160
021160  SEGTX=*
021160  *8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN/
031020  9ESGT=*
031020
031020
031020  )LINE
ILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020540
020540  ADPSG

020540  0;0;200;CSGLE;SGMAD;113;140000;0
020550  "9BP30 8ADP
020550  MSGLE 77

020550
020550         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020550         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020550
020550  ADPSG

020550  0;0;200;CSGLE;SGMAD;113;140000;0
020560  "9BP31 8ADP
020560  MSGLE 77

020560
020560         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020560         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020560
020560  ADPSG

020560  0;0;200;CSGLE;SGMAD;113;140000;0
020570  "9BP32 8ADP
020570  MSGLE 77

020570
020570         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020570         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020570
020570  ADPSG

020570  0;0;200;CSGLE;SGMAD;113;140000;0
020600  "9BP33 8ADP
020600  MSGLE 77

020600
020600         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020600         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020600
020600  ADPSG

020600  0;0;200;CSGLE;SGMAD;113;140000;0
020610  "9BP34 8ADP
020610  MSGLE 77

020610
020610         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020610         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020610
020610  ADPSG

020610  0;0;200;CSGLE;SGMAD;113;140000;0
020620  "9BP35 8ADP
020620  MSGLE 77

020620
020620         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020620         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020620
020620  ADPSG

020620  0;0;200;CSGLE;SGMAD;113;140000;0
020630  "9BP36 8ADP
020630  MSGLE 77

020630
020630         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020630         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020630
020630  ADPSG

020630  0;0;200;CSGLE;SGMAD;113;140000;0
020640  "9BP37 8ADP
020640  MSGLE 77

020640
020640         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020640         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020640
020640  ADPSG

020640  0;0;200;CSGLE;SGMAD;113;140000;0
020650  "9BP38 8ADP
020650  MSGLE 77

020650
020650         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020650         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020650
020650  ADPSG

020650  0;0;200;CSGLE;SGMAD;113;140000;0
020660  "9BP39 8ADP
020660  MSGLE 77

020660
020660         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020660         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020660
020660  ADPSG

020660  0;0;200;CSGLE;SGMAD;113;140000;0
020670  "9BP40 8ADP
020670  MSGLE 77

020670
020670         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020670         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020670
020670  ADPSG

020670  0;0;200;CSGLE;SGMAD;113;140000;0
020700  "9BP41 8ADP
020700  MSGLE 77

020700
020700         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020700         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020700
020700  ADPSG

020700  0;0;200;CSGLE;SGMAD;113;140000;0
020710  "9BP42 8ADP
020710  MSGLE 77

020710
020710         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020710         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020710
020710  ADPSG

020710  0;0;200;CSGLE;SGMAD;113;140000;0
020720  "9BP43 8ADP
020720  MSGLE 77

020720
020720         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020720         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020720
020720  ADPSG

020720  0;0;200;CSGLE;SGMAD;113;140000;0
020730  "9BP44 8ADP
020730  MSGLE 77

020730
020730         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020730         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020730
020730  ADPSG

020730  0;0;200;CSGLE;SGMAD;113;140000;0
020740  "9BP45 8ADP
020740  MSGLE 77

020740
020740         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020740         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020740
020740  ADPSG

020740  0;0;200;CSGLE;SGMAD;113;140000;0
020750  "9BP46 8ADP
020750  MSGLE 77

020750
020750         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020750         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020750
020750  ADPSG

020750  0;0;200;CSGLE;SGMAD;113;140000;0
020760  "9BP47 8ADP
020760  MSGLE 77

020760
020760         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020760         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020760
020760  ADPSG

020760  0;0;200;CSGLE;SGMAD;113;140000;0
020770  "9BP48 8ADP
020770  MSGLE 77

020770
020770         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
020770         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
020770
020770  ADPSG

020770  0;0;200;CSGLE;SGMAD;113;140000;0
021000  "9BP49 8ADP
021000  MSGLE 77

021000
021000         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021000         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021000
021000  ADPSG

021000  0;0;200;CSGLE;SGMAD;113;140000;0
021010  "9BP50 8ADP
021010  MSGLE 77

021010
021010         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021010         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021010
021010  ADPSG

021010  0;0;200;CSGLE;SGMAD;113;140000;0
021020  "9BP51 8ADP
021020  MSGLE 77

021020
021020         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021020         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021020
021020  ADPSG

021020  0;0;200;CSGLE;SGMAD;113;140000;0
021030  "TEFX1 8ADP
021030  MSGLE 77

021030
021030         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021030         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021030
021030  ADPSG

021030  0;0;200;CSGLE;SGMAD;113;140000;0
021040  "TEFX2 8ADP
021040  MSGLE 77

021040
021040         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021040         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021040
021040  ADPSG

021040  0;0;200;CSGLE;SGMAD;113;140000;0
021050  "TEFX3 8ADP
021050  MSGLE 77

021050
021050         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021050         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021050
021050  ADPSG

021050  0;0;200;CSGLE;SGMAD;113;140000;0
021060  "TEFX4 8ADP
021060  MSGLE 77

021060
021060         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021060         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021060
021060  ADPSG

021060  0;0;200;CSGLE;SGMAD;113;140000;0
021070  "TEFX5 8ADP
021070  MSGLE 77

021070
021070         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021070         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021070
021070  ADPSG

021070  0;0;200;CSGLE;SGMAD;113;140000;0
021100  "TEFX6 8ADP
021100  MSGLE 77

021100
021100         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021100         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021100
021100  ADPSG

021100  0;0;200;CSGLE;SGMAD;113;140000;0
021110  "TEFX7 8ADP
021110  MSGLE 77

021110
021110         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021110         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021110
021110  ADPSG

021110  0;0;200;CSGLE;SGMAD;113;140000;0
021120  "TEFX8 8ADP
021120  MSGLE 77

021120
021120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021120
021120  ADPSG

021120  0;0;200;CSGLE;SGMAD;113;140000;0
021130  "TEFX9 8ADP
021130  MSGLE 77

021130
021130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021130
021130  ADPSG

021130  0;0;200;CSGLE;SGMAD;113;140000;0
021140  "TFX10 8ADP
021140  MSGLE 77

021140
021140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021140
021140  ADPSG

021140  0;0;200;CSGLE;SGMAD;113;140000;0
021150  "TFX11 8ADP
021150  MSGLE 77

021150
021150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021150
021150  ADPSG

021150  0;0;200;CSGLE;SGMAD;113;140000;0
021160  "TFX12 8ADP
021160  MSGLE 77

021160
021160         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021160         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021160
021160  ADPSG

021160  0;0;200;CSGLE;SGMAD;113;140000;0
021170  "TFX13 8ADP
021170  MSGLE 77

021170
021170         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021170         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021170
021170  ADPSG

021170  0;0;200;CSGLE;SGMAD;113;140000;0
021200  "TFX14 8ADP
021200  MSGLE 77

021200
021200         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021200         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021200
021200  ADPSG

021200  0;0;200;CSGLE;SGMAD;113;140000;0
021210  "TFX15 8ADP
021210  MSGLE 77

021210
021210         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021210         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021210
021210  ADPSG

021210  0;0;200;CSGLE;SGMAD;113;140000;0
021220  "TFX16 8ADP
021220  MSGLE 77

021220
021220         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021220         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021220
021220  ADPSG

021220  0;0;200;CSGLE;SGMAD;113;140000;0
021230  "8BCH1 8ADP
021230  MSGLE 77

021230
021230         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021230         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021230
021230  ADPSG

021230  0;0;200;CSGLE;SGMAD;113;140000;0
021240  "8BCH2 8ADP
021240  MSGLE 77

021240
021240         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021240         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021240
021240  ADPSG

021240  0;0;200;CSGLE;SGMAD;113;140000;0
021250  "8BCH3 8ADP
021250  MSGLE 77

021250
021250         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021250         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021250
021250  ADPSG

021250  0;0;200;CSGLE;SGMAD;113;140000;0
021260  "8BCH4 8ADP
021260  MSGLE 77

021260
021260         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021260         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021260
021260  ADPSG

021260  0;0;200;CSGLE;SGMAD;113;140000;0
021270  "8BCH5 8ADP
021270  MSGLE 77

021270
021270         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021270         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021270
021270  ADPSG

021270  0;0;200;CSGLE;SGMAD;113;140000;0
021300  "8BCH6 8ADP
021300  MSGLE 77

021300
021300         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021300         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021300
021300  ADPSG

021300  0;0;200;CSGLE;SGMAD;113;140000;0
021310  "8BCH7 8ADP
021310  MSGLE 77

021310
021310         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021310         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021310
021310  ADPSG

021310  0;0;200;CSGLE;SGMAD;113;140000;0
021320  "8BCH8 8ADP
021320  MSGLE 77

021320
021320         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021320         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021320
021320  ADPSG

021320  0;0;200;CSGLE;SGMAD;113;140000;0
021330  "8BCH9 8ADP
021330  MSGLE 77

021330
021330         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021330         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021330
021330  ADPSG

021330  0;0;200;CSGLE;SGMAD;113;140000;0
021340  "8BC10 8ADP
021340  MSGLE 77

021340
021340         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021340         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021340
021340  ADPSG

021340  0;0;200;CSGLE;SGMAD;113;140000;0
021350  "
021350
021350  SEGTX=*
021350  *8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN/
031210  9ESGT=*
031210
031210
031210  )LINE
EOF1S3VS-4'          SYMB' 0003000100EN1' 89088       000536SINTRAN III K       Y
021330         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021330
021330  ADPSG

021330  0;0;200;CSGLE;SGMAD;113;140000;0
021340  "8BC10 8ADP
021340  MSGLE 77

021340
021340         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021340         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021340
021340  ADPSG

021340  0;0;200;CSGLE;SGMAD;113;140000;0
021350  "
021350
021350  SEGTX=*
021350  *8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN 8SGN/
031210  9ESGT=*
031210
031210
031210  )LINE
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvSGMAD;113;140000;0
021120  "TEFX8 8ADP
021120  MSGLE 77

021120
021120         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021120         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021120
021120  ADPSG

021120  0;0;200;CSGLE;SGMAD;113;140000;0
021130  "TEFX9 8ADP
021130  MSGLE 77

021130
021130         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021130         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021130
021130  ADPSG

021130  0;0;200;CSGLE;SGMAD;113;140000;0
021140  "TFX10 8ADP
021140  MSGLE 77

021140
021140         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021140         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021140
021140  ADPSG

021140  0;0;200;CSGLE;SGMAD;113;140000;0
021150  "TFX11 8ADP
021150  MSGLE 77

021150
021150         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021150         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021150
021150  ADPSG

021150  0;0;200;CSGLE;SGMAD;113;140000;0
021160  "TFX12 8ADP
021160  MSGLE 77

021160
021160         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021160         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021160
021160  ADPSG

021160  0;0;200;CSGLE;SGMAD;113;140000;0
021170  "TFX13 8ADP
021170  MSGLE 77

021170
021170         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021170         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021170
021170  ADPSG

021170  0;0;200;CSGLE;SGMAD;113;140000;0
021200  "TFX14 8ADP
021200  MSGLE 77

021200
021200         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021200         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021200
021200  ADPSG

021200  0;0;200;CSGLE;SGMAD;113;140000;0
021210  "TFX15 8ADP
021210  MSGLE 77

021210
021210         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021210         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021210
021210  ADPSG

021210  0;0;200;CSGLE;SGMAD;113;140000;0
021220  "TFX16 8ADP
021220  MSGLE 77

021220
021220         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021220         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021220
021220  ADPSG

021220  0;0;200;CSGLE;SGMAD;113;140000;0
021230  "8BCH1 8ADP
021230  MSGLE 77

021230
021230         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021230         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021230
021230  ADPSG

021230  0;0;200;CSGLE;SGMAD;113;140000;0
021240  "8BCH2 8ADP
021240  MSGLE 77

021240
021240         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021240         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021240
021240  ADPSG

021240  0;0;200;CSGLE;SGMAD;113;140000;0
021250  "8BCH3 8ADP
021250  MSGLE 77

021250
021250         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021250         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021250
021250  ADPSG

021250  0;0;200;CSGLE;SGMAD;113;140000;0
021260  "8BCH4 8ADP
021260  MSGLE 77

021260
021260         XY=SGMAD; )KILL SGMAD; SGMAD=XY+SGLEN; )KILL XY
021260         )KILL SGLEN CSGLE; SGLEN=77; CSGLE=SGLEN
021260
021260  ADPSG

vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvA=:ALOP                 % ABS. NUMBER OF LOGICAL PAGES -1
140014          T:=3777
140015          AD:=DBUA; D/\T=:X
140020          AD:=IPAR1
140021          IF D/\T+X > 4000 THEN            % IF BUFFER ADDRESS+LENGTH CROSS
140026              MIN ALOP; 0/\0               % + A PAGE BOUNDARY
140030          FI
140030          AD:=DBUA                         % ND-500 BUFFER ADDRESS
140031          IF D BIT "0" GO UERR             % ODD BYTE ADDRESS?
140033
140033          AD SHZ -13;  A=:D                % D = LOGICAL SEG NO
140035          A:=N5SE-1*MFANT+5DSPS+D=:X
140043          T:=5FXBNK; *LDATX                % A = CAPABILITY
140045          A=:CCAP                          % DATA SEGMENT CAPABILITY
140046          A /\ 1777 =: CPYS                % CURRENT PHYSICAL SEGMENT
140050          AD:=DBUA SHZ 5;                  % A= PAGE NO
140052          D SHZ -6                         % D = DIP (ND-100)
140053          A=:FLP + ALOP =:LLP              % 1. AND LAST LOG PAG
140056          A:=D=:CDIS                       % ND-100 DISPLACEMENT WITHIN PAGE
140060
140060          A:=N5SE-1*"MFSIZE*MFANT"+5FXTBL=:X+"MFSIZE*MFANT"=:MXTA
140067          DO
140067             T:=5FXBNK; *LDDTX             % AD = MFDESCR
140071             IF A BIT FIXABS OR A BIT FIXCONT THEN
140075             IF D = CPYS THEN
140100                T:=5FXBNK; *XFFPA@3 LDDTX         % A=FIRST FIXED LOG PAGE, D = LAST
140102                IF D >= LLP AND A <= FLP THEN     %  FIXED AREA FOUND
140110                   T-A=:D                         %  FLP-A IS DISP IN 5FXTBL
140112                   T:=5FXBNK; *XFPHP@3 LDATX      %  ND-100 PHYS PAGE
140114                   A+D                            %  ADD DISP IN 5FXTBL
140115                   AD SHZ -20; AD SHZ 12;         %  A:=D; A=0; AD=PAGE ADDR
140117                   T:=CDIS; D+T; A:=A+C           %  ND 100 PHYS ADDR IN AD
140122                   EXIT
140123                FI
140123             FI;FI
140123             X:=X+MFSIZE
140124          WHILE X<< MXTA
140127          OD
140130          GO FAR UERR; *)FILL
140142
140142   % MONITOR FUNCTION, REMOVING RT-PROG FROM I/O WAIT
140142   RIOWA: X=:B; IF X:=RTRES=0 GO MONEN
140146          X.STATUS BZERO 5WAIT=:X.STATUS
140151          GO STUPR
140152   *)FILL
140154   *"8N500 -8F5UD
"140154   RBUS
140154
140154
140154   %=============================================================================
140154   %       S T A P R O C     S W I T P R O C
140154   %
140154   % Entry: X=current message (=MESSAGE)
140154   %        B=nd-500 cpu datafield
140154   %
140154   SUBR NSTOPROC,STAPROC,SWITPROC
140154   SYMBOL PRSWITCH=502                                        % PROCESS SWITCH MONITOR CALL
140154
140154   % Entry: X=current message (=MESSAGE)
140154   %        B=nd-500 cpu datafield
140154   %
140154   INTEGER CN5STATUS,BREG
140156
140156   STAPROC:                                                   % Start process
140156   SWITPROC:                                                  % Switch process (stop current and restart another one)
140156          T:=5MBBANK; *AAX NPROC; LDDTX                       % A=proc.no, D=magno
140161          IF A<=5SWPROC OR A >> MX5PROCS GO ILPROC            % Legal process number?
140167          A-5SWPROC*5PRDSIZE+"S500S"; X:=A.MESSBUFF
140174          T:=5MBBANK; *AAX MAGNO; LDATX                       % A=magno
140177          *AAX XADPR-MAGNO; LDXTX                             % X=process descr.
140201          IF A><D OR X.RTRES = 0 THEN                         % Illegal magno or process not in use?
140205   ILPROC:   A:=EILPROC; X:=N5MESSAGE; CALL EMONICO           %
140210             CALL XACTRDY
140211             GO NXTMSG
140212          FI
140212          % - If process stopped (by stoppr etc.) then restart it
140212          X.PSTAT=:D; X:=X.MESSBUFF
140215          CALL RN5STATUS
140216          IF D BIT T5BUFF AND A=STOPPED OR A=I5TMQ THEN
140226             A=:D; CALL GCPUDF; CALL ERRFATAL; A:=:B=:BREG
140233             IF D=STOPPED THEN
140236                IF BREG><B THEN
140241   *NNT09=*
140241                   CALL XTER500; 0/\0
140243                FI
140243                CALL OKMONICO
140244             ELSE                                             % Restart process
140245                CALL FR5TMQU
140246                CALL SLOCK; 0/\0
140250   *NNT10=*
140250                CALL XTER500; 0/\0
140252                A:=1; CALL SPITMQ
140254                CALL ITO500XQ
140255                CALL SUNLOCK
140256             FI
140256             CALL XACTRDY
140257             IF BREG><B THEN
140262   *NNA05=*
140262                CALL XACT500
140263             FI
140263             BREG=:B
140265          ELSE
140266             CALL SLOCK; 0/\0
140270             T:=5MBBANK; *AAX 5MSFL; LDATX
140273             A BONE 55REP; *STATX
140275             CALL SUNLOCK
140276          FI
140276          X:=N5MESSAGE; T:=5MBBANK; *AAX MCNO; LDATX; AAX -MCNO
140303          IF A><PRSWITCH THEN
140306             CALL OKMONICO                                    % If mon switch-process then stop current
140307             CALL XACTRDY
140310             GO NXTMSG
140311          FI                                                  % ..else continue in stoppr
140311
140311
140311   NSTOPROC:                                                  % STOP PROCESS
140311          CALL SLOCK; 0/\0
140313          T:=5MBBANK; *AAX 5MSFL; LDATX
140316          IF A BIT 55REP THEN                                 % REP BIT SET?
140320             A BZERO 55REP; *STATX; AAX -5MSFL                % YES, RESET REP BIT
140323             CALL SUNLOCK
140324             CALL OKMONICO                                    % AND RESTART ND-500 PROC.
140325             CALL XACTRDY
140326          ELSE
140327             CALL SUNLOCK
140330             STOPPED; X:=N5MESSAGE; CALL WN5STATUS             % MARK PROC. IS STOPPED BY MON STOPR
140333          FI
140333          GO NXTMSG
140334   RBUS
140363
140363
140363   %===============================================================================
140363   %       Monitor call   M 5 T M O U T
140363   %
140363   % ENTRY: X=current message (=MESSAGE)
140363   %        B=nd-500 cpu datafield
140363   %
140363   SUBR M5TMOUT
140363   INTEGER CTM1=?,CTM2=?; DOUBLE CC5ATM=?
140363   INTEGER CRREASON=?
140363
140363   M5TMOUT: CALL SLOCK; 0/\0
140365            T:=5MBBANK; *AAX 5MSFL; LDATX                     % A=message flag
140370            IF A BIT 55REP THEN                               % Rep bit set?
140372                A BZERO 55REP; *STATX                         % Yes, reset rep bit
140374                CALL SUNLOCK
140375                A:=-1
140376   N5TMF:       A=:CRREASON; X:=N5MESSAGE                     % Reason for restarting after mon 5tmout
140400   *NNT11=*
140400                CALL XTER500; 0/\0
140402                A:=CRREASON; CALL SPITMQ
140404                CALL XACTRDY
140405                GO NXTMSG
140406            FI
140406            CALL SUNLOCK
140407            X:=N5MESSAGE; T:=5MBBANK; *AAX 5ADP1; LDDTX       % AD=no. of time units
140413            IF A><0 THEN
140414   LILP1:      X:=N5MESSAGE; A:=EC174
140416               CALL EMONICO
140417               CALL XACTRDY
140420               GO NXTMSG                                      % Restart nd-500 proc with error code
140421            FI
140421            IF D=0 GO N5TMF                                   % Restart with restart reason=0 when zero number of time units
140423            D=:L; *AAX 5ADP2-5ADP1; LDDTX                     % AD=time unit
140426            IF A><0 OR D-1>>3 GO LILP1                        % Time unit 1-4 is legal
140433            A:=D SH 1; 8CLCN(A)
140437            T:=L; 0=:X=:L
140442            DO WHILE T><0                                     % Compute time in basic time units
140444                IF T BIT 0 THEN L+D; X+A+C FI
140450                T SHZ -1; AD SH 1
140452            OD; D:=X; A:=L; A+"N500DF".5ATM2; A:=:D; A:=A+C+X.5ATM1
140462            AD=:CC5ATM                                        % Time when the proc. should be restarted
140463            X:=N5MESSAGE; T:=5MBBANK; *AAX D5TM1; STDTX; AAX -D5TM1
140470            CALL SLOCK; 0/\0
140472            CALL IFM500XQ
140473            I5TMQU; CALL WN5STATUS
140475            AD:=CC5ATM; D-; *COPY CM1 ADC SA DA
140500            AD=:CC5ATM
140501            X:="N500DF".X500DF; *AAX X5BTI
140504            DO
140504               X=:L; T:=5MBBANK; *LINK@3 LDDTX
140507            WHILE D><-1
140512   *NNC16,     CNVBYADR
140515               X:=D; T:=5MBBANK; *AAX D5TIM; LDDTX; AAX -D5TIM
140522               A:=:D; A+CTM2; A:=:D; A:=A+C+CTM1
140527            WHILE A<0
140530            OD; GO INSERT
140532   *)FILL
140550   INTEGER CTM1,CTM2; DOUBLE CC5ATM=CTM1
140552   INTEGER CRREASON
140553
140553   INSERT:  X:=L; T:=5MBBANK; *LINK@3 LDDTX
140556            X:=N5MESSAGE; *LINK@3 STDTX
140560            IF D><-1 THEN
140563   *NNC17,     CNVBYADR
140566               T:=A; X=:A:=D; *AAX PLINK; STATX
140573            FI
140573            T:=5MBBANK; X:=N5MESSAGE; *AAX PLINK; LDATX
140577            A=:N5MESSAGE:=L; *STATX; AAX -PLINK
140603            A:=T; D:=X
140605   *NNC18,  CNVWADR
140610            X:=:L; *LINK@3 STDTX
140612            T:=5MBBANK; X:=L; *AAX 5MSFL; LDATX
140616            A BONE 5ITMQUEUE; *STATX
140620            CALL SUNLOCK
140621            GO NXTMSG
140622   RBUS
140627
140627   SUBR NINSTR,XNINSTR
140627   RBUS
140627   %===============================================================================
140627   %       D V I O           N O U T S T R
140627   %
140627   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
140627   %        B=ND-500 CPU DATAFIELD
140627   %
140627   SUBR DVIO,NOUTSTR,OSTRS,PT5RST
140627   DVIO:
140627   NOUTSTR:
140627          CALL 5GTDF; GO NORMMC                               % IF TERMINAL GET ADDR OF DATAFIELD
140631          A:=D; X:=N5MESSAGE; T:=5MBBANK; *AAX TODF; STATX    % TODF=OUTPUT DATAFIELD
140636          *AAX DNOBY-TODF; LDDTX; AAX -DNOBY
140641          IF A><0 OR D>>4000 THEN                             % 4000B BYTES IS MAX BECAUSE OF "COM.BUFFER SIZE"
140645             A:=EC174; CALL EMONICO                           % RESTART ND-500 PROC WITH ERROR CODE
140647             CALL XACTRDY
140650             GO NXTMSG
140651          ELSE IF D=0 THEN                                    % ZERO BYTES?
140654             CALL OSTRS; GO NXTMSG                            % RESTART PROCESS
140656          FI; FI
140656          IF MIFLAG NBIT WSMC THEN                            % IS DATA-BUFFER IN COM-BUFFER? (BY MIC.PROG)
140661             T:=5MBBANK; 3RMED; *STATX XMICF                  % NO, MIC.FUNC=READ DATA MEMORY
140664             A:=D; *AAX NRBYT; STATX                          % NUMBER OF BYTES TO READ
140667             *AAX 5DITN-NRBYT; STZTX
140671             *AAX OSTRA-5DITN; LDDTX; AAX N500A-OSTRA; STDTX  % ND-500 LOGICAL DATA ADDR
140675             *AAX ABUFA-N500A; LDDTX; AAX N100A-ABUFA; STDTX  % ND-100 PHYSICAL ADDR
140701             "STTDRIV"; *AAX SPFLA-N100A; STATX; AAX -SPFLA   % RESTART IN STTDRIV
140705             MSGN500; CALL WN5STATUS
140707             CALL XACTRDY
140710             GO NXTMSG
140711          FI
140711          GO STTDRIV
140712   *)FILL
140725
140725
140725   %      S T T D R I V
140725   %
140725   %      START TERMINAL DRIVER.    CALLED WHEN THE LOGICAL DATA READ
140725   %      IS FINISHED IN DIRECT OUTSTRING TO TERMINAL
140725   %      ND-500 DRIVER LEVEL
140725   %
140725   %      X=ND-500 MESSAGE ADDR
140725   %
140725   INTEGER CCMESS
140726   STTDRIV: X=:CCMESS
140727          T:=5MBBANK; *AAX TODF; LDATX; COPY SA DB            % B=TERMINAL OUTPUT DATAFIELD
140733          *AAX LBUFA-TODF; LDATX; AAX 5HENT-LBUFA; STATX      %
140737          *AAX SPFLA-5HENT; STZTX; AAX -SPFLA                 % 0=:MESSAGE.SPFLAG
140742          X=:A:=:B; T:="ON5MSG"; CALL XSTDFADDR
140746          IF X.TYPRING BIT 5BAD THEN
140751             "L12STDV"
140752          ELSE
140753   %         T:="BHOLD"; CALL XGTDFADDR
140753   %         T:="SBHOLD"; CALL XSTDFADDR
140753             T:="XNOCHAR"; A:=0; CALL XSTDFADDR
140756             "L3STDV"
140757          FI
140757          X:=:B; A=:MFUNC
140761          N5IOWAIT; CALL WN5STATUS                            % MARK PROC. IN I/O WAIT
140763          CALL GCPUDF; CALL ERRFATAL; A=:X                    % X=ND-500 CPU DF.
140766          CALL RTACT                                          % START TERMINAL OUTPUT DRIVER FROM MONITOR LEVEL
140767          X=:B; GO NXTMSG                                     % B=ND-500 CPU DF.
140771   *)FILL
141004
141004
141004   %      O S T R S
141004   % OUTSTRING RESTART - ND-500 DRIVER LEVEL (LEVEL 12)
141004   % ENTRY:     X=ND-500 MESSAGE ADDR
141004   INTEGER POINTER O INCREMENT  -
137035                   D+1; A:=A+C; *STDTX                        % MONITOR CALL COUNT
137040                   X:=N5MESSAGE
137041                FI
137041             FI
137041          FI
137041          CALL PML50                                          % PERFORMANCE LOGGING
137042          T:=5MBBANK; *AAX XADPR; LDATX
137045          A=:PROCAD                                           % PROCESS DESCR. OF CURRENT PROC.
137046          *AAX MCNO-XADPR; LDATX; AAX SMCNO-MCNO; STATX       % SAVE MON.CALL NUMBER IN SMCNO
137052          IF A=2TUSED THEN                                    % MON TIME-USED?
137055             CALL MBSUSPROC
137056             T:=5MBBANK; X:=N5MESSAGE; *AAX 500TU; LDDTX      % AD=ND-500 CPU-TIME USED (500TUSED)
137062             T:=0; X:=N5MESSAGE; CALL MONICO                  % RESTART ND-500 PROC
137065             CALL XACTRDY
137066             GO NXTMSG; *)FILL                                % HANDLE NEXT PROC. IN ND-500 EX-QUEUE
137102    STLREG
141005
141005   OSTRS: A:=L=:"OSTLREG"
141007          CALL GCPUDF; CALL ERRFATAL; A=:B
141012          T:=5MBBANK; *AAX SMCNO; LDATX; AAX -SMCNO   % A=monitorcall number
141016          IF A=511 THEN                               % DVIO
141021             T:=5MBBANK
141022             *AAX 11DMA; LDDTX                        % Load max number of bytes and coninue
141024             *AAX -11DMA                              % In instring
141025             X=:N5MESSAGE; CALL XNINSTR               % XNINSTR in NINSTR routine (mon DVINST)
141027          FI
141027          CALL OKMONICO
141030          CALL XACT500                                % Restart ND-500(0) proc. after mon DVOUTST
141031          GO OSTLREG                                  %
141032   *)FILL
141042
141042
141042   %      L 1 2 S T D V
141042   % Special stdev routine to start TAD output driver
141042   %
141042   L12STDV: *IOF
141043          A:=X;     *IRW  LV10B DB
141045          "BDROUT"; *IRW  LV10B DP
141047          LV10;     * MST  PID
141051          *ION
141052          GO MONEN
141053   *)FILL
141056
141056
141056   %      P T 5 R S T
141056   %      RESTART ND-500 FROM THE TERMINAL OUTPUT DRIVER  (LEVEL 10)
141056   %      MUST BE CALLED WITH INTERRUPT OFF
141056   %
141056   %      ENTRY:    X = ND-500 PROCESS MESSAGE
141056   PT5RST: A:=X; *IRW LV12B DX
141060           "CALLID12"; *IRW LV12B DL
141062           "OSTRS"; *IRW LV12B DP
141064           LV12; *MST PID
141066           EXIT
141067   RBUS
141072
141072
141072   %============================================================================
141072   %      N I N S T R
141072   %      X N I N S T R
141072   %
141072   % MONITOR CALL DVIO AND DVINST
141072   % LEVEL 12.
141072   %
141072   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141072   %        B=ND-500 CPU DATAFIELD
141072   %
141072   SUBR NINSTR,XNINSTR
141072   INTEGER CCMESS=?,CWNDMESS=?,BREG=?
141072
141072   NINSTR:  T:=5MBBANK; X:=N5MESSAGE
141074            *AAX DMAXB; LDDTX; AAX -DMAXB        % AD=MAX. BYTECOUNT
141077   XNINSTR:
141077          IF A><0 OR D>>4000 THEN                % 4000B BYTES IS THE MAX. DUE TO THE SIZE OF "COMM.BUFFERS"
141103            X:=N5MESSAGE; A:=EC174
141105            CALL EMONICO
141106            CALL XACTRDY
141107            GO NXTMSG                            % RESTART ND-500 PROC WITH ERROR CODE
141110          FI
141110          A:=B=:BREG
141112          CALL 5GTDF; GO NORMMC                  % NOT TERMINAL OR TAD
141114          IF A.TYPRING BIT 5BAD THEN
141120             X:=N5MESSAGE; GO NORMMC
141122          FI
141122          X=:B; N5MESSAGE=:CCMESS                % SAVE CURRENT MESSAGE ADDR IN CCMESS
141125          CALL SET12WINDOW                       % SET UP TERMINAL WINDOW
141126          IF FLAGB BIT 5LSTA THEN                % HAVE WE LOST OUR TERMINAL?
141131             X:=CCMESS; 0=:IN5MSG
141133             CALL GCPUDF; CALL ERRFATAL; A=:B
141136             A:=316; CALL EMONICO                % TERMINAL LINE IS NOT CONNECTED
141140             CALL XACTRDY
141141             GO FAR XCLPITS                      % CLEAR PIT ENTRIES
141142          FI
141142          A:=CCMESS/\1777+"WNDN5*2000"=:CWNDMESS % LOGICAL ADDR OF ND-500 MESSAGE
141146          T:=5MBBANK SH 6; A:=CCMESS SHZ -12
141152          A+T=:D:=142000
141155          T:=0; X:="WNDN5+WNDN5+174000"; *STDTX  % SET PITENTRY
141160          A:=CWNDMESS.5BRST                      % A=BREAK STRATEGY
141162          IF A=-1 THEN 0=:BRKTAB; GO NOBRK FI    % NO BREAK
141167          IF A<<11 THEN
141172             IF A = 7 THEN                       % USER SUPPLIED BREAK STRATEGY
141175                A:="5BRKTAB"; T:="PBRK7"         % DISPLACEMENT IN MSG AND DF
141177                CALL FAR MOVTAB                  % COPY BREAK TABLE FROM MESS TO DF
141200                A:="PBRK7"+B=:BRKTAB             % SET ADDR OF BRKTAB IN INPUT DF.
141203                GO NOBRK
141204             FI
141204             IF A=10 THEN                        % USE PREVIOUS USER SUPPLIED BREAK STRATEGY
141207                A:="PBRK7"+B=:BRKTAB
141212                GO NOBRK
141213             FI
141213             A:=BRKTB(A)=:BRKTAB                 % USE ONE OF THE SYSTEM INCLUDED BREAK TABLES
141216             X:=CWNDMESS
141217          FI; GO NOBRK; *)FILL
141245
141245   INTEGER CCMESS,CWNDMESS
141247   INTEGER BREG
141250
141250   NOBRK: A:=X.5ECHS                             % ECHO STRATEGY
141251          IF A=-1 THEN 0=:ECHOTAB; GO NECHO FI   % NO ECHO
141256          IF A<<11 THEN
141261             IF A = 7 THEN                       % USER SUPPLIED ECHO STRATEGY
141264                A:="5ECHTAB"; T:="PECH7"         % A=DISP IN MESS; T=DISP IN TERM INPUT DF.
141266                CALL FAR MOVTAB                  % COPY FROM ND-500 MESS TO TERM.INPUT DF.
141267                A:="PECH7"+B=:ECHOTAB            % SET ADDR OF ECHO TABLE IN TERM.INPUT DF.
141272                GO NECHO
141273             FI
141273             IF A=10 THEN
141276                A:="PECH7"+B=:ECHOTAB            % USE PREVIOUS USER SUPPLIED ECHO TABLE
141301                GO NECHO
141302             FI
141302             ECHTB(A)=:ECHOTAB                   % USE ONE OF THE 8 SYSTEM INCLUDED ECHO TABLES
141305             X:=CWNDMESS
141306          FI; GO NECHO; *)FILL
141313
141313   NECHO: X:=CCMESS; N5IOWAIT; CALL WN5STATUS    % MARK PROCESS IS IN I/O-WAIT
141316          0=:CWNDMESS.5FYLLE                     % CLEAR SOME FLAGS
141320          0=:X.MLFLAG=:X.SPFLAG
141322          IF X.SMCNO=511 THEN                    % WHICH MONITOR CALL IS IT
141326             X.11MXBRK                           % MON DVIO
141327          ELSE
141330             X.MAXBYT                            % MON DVINST
141331          FI; A=:BRKMAX                          % SET MAX. CHAR BEFORE BREAK
141332          CCMESS=:IN5MSG                         % IN5MSG=ADDR OF ND-500 MESSAGE (USED BY TERM.INPUT DRIVER)
141334          IF BHOLD><0 THEN                       % ANY CHARACTERS IN TERMINAL INPUT BUFFER?
141336             1=:X.MLFLAG                         % YES, MARK THAT MONITOR LEVEL IS STARTED.
141340             "IBMOVE"=:TDRADDR.MFUNC; CALL CXRTACT
141344          ELSE
141345             IF TDRADDR.ISTAT = -1 OR = -2 THEN  % IS IT NOWAIT?
141355                0=:IN5MSG                        % YES, GIVE END-OF-FILE ERROR MESSAGE
141356                IF CWNDMESS.SMCNO=511 THEN       % WHICH MONITOR CALL IS IT?
141363                   A:=0=:D; AD=:X.11NOCHRET      % MON DVIO; SET NUMBER OF RETURNED BYTES
141366                   100000=:X.NUMPAR              % SET MONITOR CALL WRITE-BACK MASKE
141370                ELSE
141371                   A:=0=:D; AD=:X.NOCHRET        % MON DVINST; SET NUMBER OF RETURNED BYTES.
141374                   4=:X.NUMPAR                   % SET MONITOR CALL WRITE-BACK MASKE
141376                FI
141376                X:=CCMESS; A:=3; CALL EMONICO    % GIVE END-OF-FILE ERROR RETURN
141401                CALL XACTRDY
141402             FI; DFLAG BONE 5ECHO=:DFLAG         % GIVE ECHO CONTROL TO TERMINAL DRIVER
141405          FI
141405   CLPITS:
141405   XCLPIT: T:=0; X:="WNDN5+WNDN5+174000"; *STZTX % CLEAR USED PIT ENTRY (TERM. WINDOW WILL BE RESET IN WT12)
141410           BREG=:B
141412           GO NXTMSG
141413   *)FILL
141424
141424   %      M O V T A B
141424   % MOVE BREAK/ECHO TABLE FROM THE ND-500 MESSAGE TO THE TERMINAL DATAFEIELD
141424   % LEVEL 12.
141424   %
141424   % ENTRY:     X=LOGICAL ADDR OF ND-500 MESSAGE
141424   %            B=LOGICAL ADDR OF TERMINAL INPUT DATAFIELD
141424   %            T=DISPLACEMENT IN THE DATAFIELD TO MOVE INTO
141424   %            A=DISPLACEMENT IN THE ND-500 MESSAGE TO MOVE FROM
141424   %
141424   MOVTAB: A+X=:D                                % D=LOGICAL ADDR. IN MESSAGE
141426          T+B; A:=10:=:L; *MOVAA                 % MOVE FROM MESAGE TO TERM.DF.
141432          A=:P                                   % EXIT
141433
141433   RBUS
141433
141433
141433   %============================================================================
141433   %      G E R R C
141433   %      GET ERROR CODE.  USED AFTER A PROGRAMMED TRAP.
141433   %      DRIVER LEVEL
141433   %
141433   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141433   %        B=ND-500 CPU DATAFIELD
141433   %
141433   SUBR GERRC
141433   GERRC: T:=5MBBANK; *5RECE@3 LDATX
141435          A-5SWPROC+1*REGBSZ+"ERREG"=:T
141442          "N500DF".CNTXPAGE+X.ADRZERO=:D:=0
141447          AD SHZ 12; D+T; A:=A+C; X:=D; T:=A; *LDDTX
141455          *STZTX; AAX 1; STZTX
141460          X:=N5MESSAGE; T:=5MBBANK; *AAX M505E; STDTX
141464          A:=1; *AAX NUMPA-M505E; STATX
141467          A:=0=:D; *AAX FUNCV-NUMPA; STDTX
141473          *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
141476          3MONCO; *MICFU@3 STATX
141500          CALL MCCO
141501          CALL XACTRDY
141502          GO NXTMSG
141503   RBUS
141514
141514
141514   %============================================================================
141514   %      5 S I B M O
141514   %      SPECIAL MONITOR CALL FROM SIBAS SERVER IN ND-500
141514   %      DRIVER LEVEL
141514   %
141514   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141514   %        B=ND-500 CPU DATAFIELD
141514   %
141514   SUBR 5SIBMO
141514   INTEGER CSIBNO,CSIBDF
141516   5SIBMO: T:=5MBBANK; *AAX SIBNO; LDDTX
141521          IF A><0 OR D>>MXSIBAS OR T=0 THEN            % ILLEGAL SIBAS NUMBER
141527            X:=N5MESSAGE; A:=EC174
141531            CALL EMONICO                               % RESTART ND-500 PROC WITH ERROR CODE
141532            CALL XACTRDY
141533            GO NXTMSG
141534          FI
141534          X:=D=:CSIBNO:=SIBBDEVS(X)=:D=:CSIBDF
141541          IF X.RTRES><PROCAD.RTRES THEN                % IS THE ACTUAL SIBAS DF. RESERVED BY ANOTHER?
141546             X:=N5MESSAGE; 5; CALL EMONICO             % YES, GIVE ERROR RETURN
141551             CALL XACTRDY
141552             GO NXTMSG
141553          FI; 1=:D.SIB500                              % MARK THAT THIS SIBAS IS RUNNING IN ND-500
141556          X:=SIBAPDEVS(CSIBNO)=:D; 0=:X.SRTCSTAT       % MARK THAT SIBAS IS WAITNG FOR A REQUEST?
141562          X=:CSIBNO                                    % ADDR OF MON MAPSIB WORKING FIELD
141563          IF X:=X.RTRES><0 AND X.STATUS BIT 5WAIT THEN % ANY PROGRAMS WAITNG TO BE RESTARTED BY SIBAS?
141570             D:=:B; CALL RTACT; B:=D                   % YES, RESTART IT
141573          FI; A:=CSIBDF.TTMR=:X.TMR                    % START TIMER
141576          X:=N5MESSAGE; T:=5MBBANK; *AAX SIBST; LDDTX; AAX -SIBST
141603          IF A=0 AND D=0 GO FAR NSTOPROC               % SIBAS SHOULD BE SET IN STOPPED STATUS
141606          1=:CSIBNO.SRTCSTAT; 0=:CSIBDF.TMR            % MARK SIBAS IS ACTIVE
141613          X:=N5MESSAGE; CALL OKMONICO                  % REACTIVATE SIBAS
141615          CALL XACTRDY
141616          GO NXTMSG
141617   RBUS
141633
141633
141633   %============================================================================
141633   %      S P R I O
141633   %      SET PRIORITY
141633   %      DRIVER LEVEL.
141633   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141633   %        B=ND-500 CPU DATAFIELD
141633   %
141633   SUBR SPRIO
141633   SPRIO: T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL % A=MESSAGE FLAG
141637          IF A BIT SPROK THEN                       % SET PRIORITY ALLOWED FOR THIS PROC?
141641             T:=5MBBANK; *AAX 100; LDDTX; AAX -100  % YES, GET NEW PRIORITY
141645             IF A><0 THEN EC174R; GO SPERET FI      %
141650             D=:A
141651             IF A=0 THEN                            % IF=0 THEN PROC. SHOULD BE TIMESLICED
141652                *AAX XADPR;  LDXTX                  % X=ADDR OF PROC.DESCR
141654                X.PSTAT BONE 55BRKPRIOR BONE SLICE=:X.PSTAT % MARK PROCESS IS TIMESLICED
141660                5BRKPRIOR; X:=N5MESSAGE; *AAX 5PRIO; STATX  % SET NEW PRIORITY
141664                CALL OKMONICO                       % RESTART PROCESS
141665             ELSE
141666                IF A >>= 300 THEN                   % PRIORITY WITHIN LEGAL RANGE?
141671                   A:=EC174R; GO SPERET             % NO, GIVE ERROR RETURN
141673                FI
141673                T:=5MBBANK; *AAX 5PRIO; STATX       % SET NEW PRIORITY
141676                *AAX XADPR-5PRIO; LDXTX             % X=ADDR OF PROC.DESCR.
141700                X.PSTAT BZERO SLICE=:X.PSTAT        % MARK PROC. NOT TIMESLICED
141703                X:=N5MESSAGE
141704                CALL SLOCK; GO N500ERR
141706   *NNT12=*
141706                CALL XTER500; GO FAR N500ERR
141710                CALL OKMONICO                       % RESTART PROCESS
141711                CALL IFM500XQ
141712                T:=5MBBANK; *AAX PLINK; LDATX; AAX -PLINK
141716                A=:N5MESSAGE
141717                CALL ITO500XQ                       % REORGANIZE EX-QUEUE ACCORDING TO PRIORITY
141720                CALL SUNLOCK
141721                CALL XACTRDY
141722             FI
141722          ELSE
141723             A:=EPRMC                               % SPRIO NOT ALLOWED
141724   SPERET:   T:=5MBBANK; X:=N5MESSAGE; CALL EMONICO % GIVE ERROR RETURN
141727             CALL XACTRDY
141730          FI; GO NXTMSG
141731   N500ERR: CALL XRSTARTALL; GO CALLID12             % RESTART ALL PROCS.
141733
141733   RBUS
141753
141753
141753   %============================================================================
141753   %      S W M C
141753   %      MONITOR CALL TO THE SWAPPER
141753   %      DRIVER LEVEL
141753   % ENTRY: X=CURRENT MESSAGE (=MESSAGE)
141753   %        B=ND-500 CPU DATAFIELD
141753   SUBR SWMC
141753   SWMC:  MSM510 SHZ 10=:D; T:=5MBBANK; *AAX TRAPN; LDATX
141761          A/\377+D; *STATX; AAX -TRAPN
141765          CALL 5ACTSWAPPER; GO NXTMSG
141767   RBUS
141773
141773
141773   SUBR XMWK; RBUS
141773   %=============================================================================%
141773   %                                                                             %
141773   %      A 5 X M S G        B 5 X M S G                                         %
141773   %                                                                             %
141773   %      XMSG interface routines.  Executed on level 12                         %
141773   %                                                                             %
141773   %
141773   SUBR A5XMSG,B5XMSG
141773
141773   @ICR; % - Writeback masks for the different xmsg functions
141773         % - Bit number corresponds to parameter number in xmsg call
141773   INTEGER ARRAY XMRETMASK:=(
141773          16, 0, 4, 0,34, 0,20,20, 0,14, 2, 0, 0,74,34, 4,
142013           0, 0, 0, 0, 0, 0,34, 4, 0, 0, 0, 0, 0, 0, 0, 0,
142033          34, 0, 0, 0, 0, 0, 0, 4,70,360,14,0, 0, 0, 0,16);
142053   @CR;
142053   SYMBOL X5MASK=77             % mask for obtaining xmsg function number
142053   SYMBOL X5MAX=57              % max xmsg function number
142053   INTEGER XREG=?
142053   INTEGER AREG=?
142053
142053   A5XMSG:
142053   B5XMSG:
142053          X=:B; T:=5MBBANK; *AAX N5XFU; LDATX
142057          A/\X5MASK=:D                                  % Save xmsg-function in D-reg
142061          IF A-X5MAXF>0 GO X5EILF                      % Illegal function value?
142064          *AAX XTBLK-N5XFU; LDATX
142066          IF A=0 THEN                                   % Any xtblock allocated?
142067             IF XFDCT=D GO FAR X5LEAVE                  % Ignore call if xmsg-function=disconnect
142072             X:=B; *AAX HBUFA; LDATX                    % No, get one
142075             T:=XFDBK; L:=0; *MON 2XMSG                 % Allocate xtblock
142100             GO FAR X5LEAVE                             % Level 14 part finished
142101             IF T<0 GO FAR X5ERET                       % Check for error
142103             L=:A; X:=B; T:=5MBBANK                     % L=xtblock address obtained from xmsg
142106             *AAX XTBLK; STATX                          % Save it
142110             T:=XFWDF; "XMWK"; *MON 2XMSG               % Define wakeup routine
142113             GO FAR X5LEAVE                             % Level 14 finished
142114          FI
142114          X:=B; T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
142121   @ICR;
142121          A/\X5MASK GOSW
142121          FAR LFDUM, FAR LFDCT, LFGET, LFREL, LFRHD, LFWHD, LFREA, LFWRI,
142133          LFSCM, LFMST, FAR LFOPN, LFCLS, FAR LFSND, LFRCV, LFPST, LFGST,
142143          X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, FAR LFM2P, LFP2M,
142153          X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, X5EILF, LFPRV, LFRTN,
142163          LFRRH, X5EILF, X5EILF, X5EILF, X5EILF, LFDMM, LFALM, FAR LFFRM,
142173          LFLMP, FAR LFRRE, LFCPV, LFWRT, X5EILF, X5EILF, X5EILF, FAR LFGSM;
142203   @CR;
142203   *)FILL
142220
142220   %      Illegal function codes;  not implemented
142220   %
142220   %      LFSIN:    % 20 - Initialize for system functions
142220   %      LFSRL:    % 21 - Service release function (obsolete)
142220   %      LFABR:    % 22 - Absolute read from pof
142220   %      LFABW:    % 23 - Absolute write block to pof area (obsolete)
142220   %      LFMLK:    % 24 - Lock message system (obsolete)
142220   %      LFMUL:    % 25 - Unlock message system (obsolete)
142220   %      LFRIN:    % 30 - Routing initialize (obsolete)
142220   %      LFCRD:    % 31 - Create driver
142220   %      LFSTD:    % 32 - Start driver
142220   %      LFDIB:    % 33 - Define indirect buffer
142220   %      LFRIB:    % 34 - Read from indirect buffer
142220   %      LFWIB:    % 35 - Write to indirect buffer
142220   %      LFDUB:    % 41 - Define user buffer area for current message
142220   %      LFWDF:    % 42 - Define wakeup context (drivers only)
142220   %      LFDBK:    % 43 - Define bank number (drivers lnly)
142220   %      LFSMC:    % 44 - Start multi-call
142220
142220   X5EILF:   XEILF
142221   X5ILP:    AD SH -20; T:=1; X:=B; CALL MONICO
142225             CALL XACTRDY
142226   XNXTMSG:  X:=B; CALL GCPUDF; CALL ERRFATAL; A=:B; GO NXTMSG
142233   *)FILL
142240
142240   % input:         A:=2nd parameter
142240   %                D:=3rd parameter
142240   %                X:=4th parameter
142240   %
142240   LFPRV:           % 36 - Request privliges
142240           *AAX 5MSFL; LDATX; AAX -5MSFL
142243           IF A NBIT 5XMPRIV GO X5EILF
142245
142245   LFGET:           %  2 - Get a message buffer
142245   LFREL:           %  3 - Release a message buffer
142245   LFRHD:           %  4 - Read from header of message buffer
142245   LFWHD:           %  5 - Write to header of current message buffer
142245   LFSCM:           % 10 - Set current message
142245   LFMST:           % 11 - Message status
142245   LFCLS:           % 13 - Close a port
142245   LFRCV:           % 15 - Receive next message
142245   LFPST:           % 16 - Port status
142245   LFGST:           % 17 - General status
142245   LFP2M:           % 27 - Convert port number to magic number
142245   LFRTN:           % 37 - Return a message
142245   LFRRH:           % 40 - Receive and read header
142245   LFDMM:           % 45 - Dynamic definition of max task space
142245   LFCPV:           % 52 - Check system and user privileges
142245          *AAX 5ADP3; LDDTX; AAX 5DP2-5ADP3; LDATX; AAX 5DP4-5DP2; LDXTX
142253          GO MONXM
142254
142254   % input:         D:=2nd parameter
142254   %                X:=4th parameter
142254   %                A:=LBUFA
142254   %
142254   LFREA:           %  6 - Read from current message buffer      use B5XMSG
142254   LFWRI:           %  7 - Write to current message buffer       use B5XMSG
142254   LFWRT:           % 53 - Write and return message
142254          *AAX 5ADP2; LDDTX
142256          IF A><0 OR 4000<<D THEN XEITL; GO FAR X5ILP FI
142264          *AAX N5XFU-5ADP2; LDATX; AAX -N5XFU
142267          IF A/\X5MASK=7 OR A=53 THEN
142276             CALL GCPUDF; CALL ERRFATAL; A=:B
142301             IF MIFLAG NBIT WSMC THEN
142304                A:=D; T:=5MBBANK; *AAX NRBYT; STATX
142310                *AAX 5DITN-NRBYT; STZTX
142312                *AAX X5BUF-5DITN; LDDTX; AAX N500A-X5BUF; STDTX
142316                *AAX ABUFA-N500A; LDDTX
142320   *NNC19,      CNVWADR
142323                T:=5MBBANK; *AAX N100A-ABUFA; STDTX
142326                "INFWRIT"; *AAX SPFLA-N100A; STATX; AAX -SPFLA
142332                3RMED; *STATX XMICF
142334                MSGN500; CALL WN5STATUS
142336                CALL XACTRDY
142337                GO NXTMSG
142340   INFWRIT:     T:=5MBBANK; *AAX SPFLA; STZTX; AAX -SPFLA
142344             FI; X=:B
142345          FI
142345          T:=5MBBANK; *AAX 5ADP2; LDDTX
142350          *AAX LBUFA-5ADP2; LDATX; AAX 5DP4-LBUFA; LDXTX
142354          GO MONXM
142355
142355   % input:         AD:=2nd parameter
142355   %                 X:=3rd parameter
142355   %
142355   LFSND:           % 14 - Send current message
142355   LFM2P:           % 26 - Convert magic number to port and system number
142355          *AAX 5ADP2; LDDTX; AAX 5DP3-5ADP2; LDXTX
142361          GO MONXM
142362
142362   % input:         A:=2nd parameter
142362   %                X:=3rd parameter
142362   %
142362   LFALM:           % 46 - Allocate messages to a task
142362   LFLMP:           % 50 - List messages and ports
142362          *AAX 5DP2; LDATX; AAX 5DP3-5DP2; LDXTX
142366          GO MONXM
142367
142367   % input:         X:=2nd parameter
142367   %                A:=3rd parameter
142367   %
142367   LFFRM:           % 47 - Freeing allocated message buffers
142367          *AAX 5DP3; LDATX; AAX 5DP2-5DP3; LDXTX
142373          GO MONXM
142374
142374   % input:         A:=2nd parameter
142374   %                D:=3rd parameter
142374   %                X:=lbufa
142374   %
142374   LFRRE:           % 51 - Receive and read message
142374          *AAX 5ADP3; LDDTX
142376          IF A><0 OR 4000<<D THEN XEITL; GO FAR X5ILP FI
142404          *AAX 5DP2-5ADP3; LDATX
142406          *AAX LBUFA-5DP2; LDXTX
142410          GO MONXM
142411
142411   % input:         none
142411   %
142411   LFDUM:           %  0 - Dummy xmsg call
142411   LFDCT:           %  1 - Disconnect from xmsg
142411   LFOPN:           % 12 - Open a port
142411   LFGSM:           % 47 - General status multiple
142411   MONXM: T:=5MBBANK; X=:XREG:=B; A=:AREG; *AAX XTBLK; LDATX
142417          A=:L; *AAX N5XFU-XTBLK; LDATX
142422          A=:T:=AREG; X:=XREG; *MON 2XMSG                      % Starts an xmsg function
142426          GO X5LEAVE; GO X5RET
142430
142430   *)FILL
142443
142443
142443   %-------------------------------------------------------------
142443   %
142443   %      Level 14 part of xmsg finished.
142443   %
142443
142443   X5LEAVE: X:=B; T:=5MBBANK; *AAX N5XFU; LDATX
142447            IF A/\X5MASK-XFDCT=0 THEN                   % Disconnect function?
142452                 X:=B; *AAX XTBLK; STZTX
142455                 A:=1; AD SHZ -20; T:=0; X:=B
142461                 CALL MONICO                            % Return to user imediately
142462                 CALL XACTRDY
142463            ELSE                                        % Function was disconnect
142464                 N5XMWAIT; X:=B; CALL WN5STATUS
142467            FI; GO FAR XNXTMSG
142470
142470   *)FILL
142476
142476
142476   %-------------------------------------------------------------
142476   %
142476   %      XMSG function finished and level 12 restarted here
142476   %
142476
142476   INTEGER TREG,AREG,DREG,XREG
142502   TRIPLE  TADREG=TREG; DOUBLE ADREG=AREG
142502
142502   X5RET:
142502          TAD=:TADREG; X=:XREG
142504          IF "N500DF".SYSINITFLAG BIT B5STOP GO WT12
142510          X:=B; CALL RN5STATUS
142512          IF A><N5XMWAIT THEN                           % Process should be waiting for xmsg kick. yes?
142515             T:=5MBBANK; *AAX XTBLK; LDATX; STZTX       % No, forget xmsg call and disconnect xmsg port
142521             IF A><0 THEN
142522                A=:L; T:=XFDCT; *MON 2XMSG; RAND
142526             FI
142526             X:=B; CALL GCPUDF; GO WT12; A=:B; GO CALLID12
142533          FI
142533          T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
142537          A/\X5MASK=:L
142541          IF T:=TREG<0 GO FAR X5ERET
142544          IF T=0 AND 6=L OR 51=L GO FAR X5ERET
142554          T=:A:=5MBBANK; AD SH -20; *AAX FUNCV; STDTX
142561          *AAX KFLIP-FUNCV; STZTX
142563          AD:=ADREG; X:=XREG:=:B
142566   @ICR
142566          L GOSW
142566          RFDUM, X5FATAL, RFGET, FAR RFREL, RFRHD, FAR RFWHD, RFREA, RFWRI,
142577          FAR RFSCM, RFMST, RFOPN, FAR RFCLS, FAR RFSND, RFRCV, RFPST, RFGST,
142607          X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, RFM2P, RFP2M,
142617          X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, X5FATAL, FAR RFPRV, FAR RFRTN,
142627          RFRRH, X5FATAL, X5FATAL, X5FATAL, X5FATAL, FAR RFDMM, FAR RFALM, RFFRM,
142637          RFLMP, RFRRE, RFCPV, FAR RFWRT, X5FATAL, X5FATAL, X5FATAL, FAR RFGSM;
142647   @CR;
142647   *)FILL
142672
142672   %      Fatal error  (illegal function codes)
142672   %
142672   X5FATAL:
142672          CALL ERRFATAL
142673
142673   % output:        A=:2nd parameter
142673   %                D=:3rd parameter  /  AD=:3rd parameter
142673   %                X=:4th parameter
142673   %
142673   RFDUM:; RFOPN:; RFGSM:
142673          *AAX 5AP2; STZTX; AAX 5DP2-5AP2; STATX; AAX -5DP2
142700          A:=0
142701   RFP2M:; RFMST:
142701          *AAX 5ADP3; STDTX
142703          A:=0; B=:D; *AAX 5ADP4-5ADP3; STDTX; AAX -5ADP4
142710          GO FAR X5L1
142711
142711   % output:        A=:3rd parameter
142711   %                D=:4th parameter
142711   %                X=:5th parameter
142711   %                T=:6th parameter
142711   %
142711   RFRCV:; RFRRH:; RFRHD:; RFPST:; RFM2P:
142711   RFCPV:; RFGET:; RFGST:; RFFRM:
142711          *AAX 5AP3; STZTX; AAX 5DP3-5AP3; STATX
142715          A:=0; *AAX 5ADP4-5DP3; STDTX
142720          A:=B; AD SH -20; *AAX 5ADP5-5ADP4; STDTX
142724          *AAX FUNCV-5ADP5; LDDTX
142726          *AAX 5ADP6-FUNCV; STDTX; AAX -5ADP6
142731          GO FAR X5L1
142732
142732   % output:        A=:4th parameter
142732   %                D=:5th parameter
142732   %                X=:6th parameter
142732   RFWRI:; RFLMP:
142732          *AAX 5AP4; STZTX; AAX 5DP4-5AP4; STATX
142736          A:=0; *AAX 5ADP5-5DP4; STDTX
142741          B=:D; *AAX 5ADP6-5ADP5; STDTX; AAX -5ADP6
142745          GO X5L1
142746   *)FILL
142750
142750   % output:        D=:5th parameter=:26nrb
142750   %                x5buf=:26add
142750   %
142750   RFREA:
142750          A:=0; *AAX 5ADP5; STDTX; AAX -5ADP5
142754          GO INRFRRE
142755
142755   % output:        A=:5th parameter
142755   %                D=:6th parameter
142755   %                X=:7th parameter=:26nrb
142755   %                T=:8th parameter
142755   %                x5buf=:26add
142755   %
142755   RFRRE:
142755          *AAX 5AP5; STZTX; AAX 5DP5-5AP5; STATX
142761          A:=0; *AAX 5ADP6-5DP5; STDTX
142764          *AAX FUNCV-5ADP6; LDDTX; AAX 5ADP8-FUNCV; STDTX
142770          A:=B; AD SH -20; *AAX 5ADP7-5ADP8; STDTX
142774          *AAX FUNCD-5ADP7; LDATX; AAX -FUNCD
142777          IF A=4 THEN
143002             T:=5MBBANK; *AAX 26NRB; STZTX; AAX -26NRB
143006             GO X5L1
143007          FI
143007   INRFRRE:
143007          CALL GCPUDF; CALL ERRFATAL; A=:B
143012          T:=5MBBANK; *AAX N5XFU; LDATX; AAX -N5XFU
143016          A/\X5MASK=:L
143020          IF MIFLAG BIT WSMC THEN
143023             A:=D; *AAX 26NRB; STATX; AAX SM26N-26NRB; STATX
143030             IF 51=L THEN
143033                *AAX X5BUF+2-SM26N; LDDTX; AAX 26ADD-X5BUF-2
143036             ELSE
143037                *AAX X5BUF-SM26N; LDDTX; AAX 26ADD-X5BUF
143042             FI; *STDTX; AAX SM26A-26ADD; STDTX; AAX -SM26A
143046          ELSE
143047             D=:L; *AAX FUNCV; LDDTX; AAX 134-FUNCV; STDTX
143054             A:=L; *AAX NRBYT-134; STATX
143057             *AAX 5DITN-NRBYT; STZTX; AAX -5DITN
143062             IF 51=L THEN
143065                *AAX X5BUF+2; LDDTX; AAX N500A-X5BUF-2
143070             ELSE
143071                *AAX X5BUF; LDDTX; AAX N500A-X5BUF
143074             FI; *STDTX
143075             *AAX ABUFA-N500A; LDDTX; AAX N100A-ABUFA; STDTX
143101             "INFRRE"; *AAX SPFLA-N100A; STATX; AAX -SPFLA
143105             3WMED; *STATX XMICF
143107             MSGN500; CALL WN5STATUS
143111             CALL XACT500
143112             GO CALLID12
143113   INFRRE:   T:=5MBBANK; *AAX SPFLA; STZTX
143116             *AAX 134-SPFLA; LDDTX; AAX FUNCV-134; STDTX
143122             *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
143125          FI; GO X5L1
143126   *)FILL
143136
143136   % output:        none
143136   %
143136   RFREL:; RFWHD:; RFSCM:; RFCLS:; RFSND:
143136   RFPRV:; RFRTN:; RFDMM:; RFALM:; RFWRT:
143136   X5L1:  X=:B; T:=5MBBANK; *AAX N5XFU; LDATX
143142          A/\X5MASK=:X=:L
143145          *1BANK
143146          XMRETMASK(X)
143147          *2BANK
143150          A=:D; X:=B; *AAX NUMPA; LDATX
143154          IF L=0 AND A-1=0 THEN D:=0; FI       % Dummy function with 1 param.?
143161          A:=D; *STATX
143163          *AAX N5XFU-NUMPA; LDATX; AAX -N5XFU
143166          A/\X5MASK=:D
143170          CALL GCPUDF; CALL ERRFATAL; A=:B
143173          IF MIFLAG BIT WSMC AND D=6 OR D=51 THEN 3WMONCO ELSE 3MONCO FI
143207   XX5RET: T:=5MBBANK; *MICFU@3 STATX
143211          CALL MCCO
143212          CALL XACT500
143213          GO CALLID12
143214
143214   X5ERET: 5MBBANK; A:=:T; X:=B
143217          AD SH -20; *AAX FUNCV; STDTX
143222          A:=1; *AAX KFLIP-FUNCV; STATX
143225          *AAX NUMPA-KFLIP; STZTX
143227          X:=B; CALL GCPUDF; CALL ERRFATAL; A=:B
143233          3MONCO; GO XX5RET
143235
143235   RBUS
143245
143245
143245
143245   %=============================================================================
143245   %      (M  )     5 M T R A N S
143245   %
143245   % Monitor call executed on driver level
143245   %
143245   % Entry:    X= current message
143245   %           B= nd-500 cpu datafield
143245   %
143245   %  Functions:
143245   %  1.   disk transfer, return immediately with status: OK, request received
143245   %  2.   disk transfer, wait  until transfer finished,
143245   %                      then return status: transfer finished
143245   %  3.   disk transfer, check event, return immediately with status:
143245   %                      transfer completed/restarted by other/ no event ready
143245   %  4.   disk transfer, check event, wait until event occurs,
143245   %                      then returnstatus: transfer completed/restarted by other
143245   %  5.   check event, nowait return status: no event ready/restarted by other
143245   %  6.   check event, wait, return status: transfer completed/ restarted by other
143245   %  7.   start process, return immediately  with status: OK, request received
143245   %  8.   start process and wait (will be restarted by other process)
143245   %
143245   SUBR 5MRDTRANS; RBUS
143245   SUBR 5MTRANS
143245   5MTRANS:
143245   *"8N500 8MTRA
"143245          X=:CMSGA
143246          0=:CUREL; A:=B=:XC5CPUDF
143251          T:=5MBBANK; *AAX 5MNWA; LDDTX; AAX -5MNWA
143255          AD=:NWFUNC
143256          IF 5MFNC NBIT 5DTRANS GO FAR CHEVENT
143261          % Disk transfer,  check device number:
143261          *AAX 5MLGN; LDATX
143263          CALL LOGPH; A=:X
143265          % Must have hard disk with disk optimizition:
143265          IF X>>="9BBHD" AND X<<"9EEHD" THEN
143273             IF X>>="9EDFD" THEN A:=1 ELSE A:=0; FI; A=:5DSKC    % Set disk type code
143302             IF X>>="9FSTR" AND X<<"9ESTR" AND X.STREN=0 GO 3XERR
143312             GO DIST1
143313          FI
143313   3XERR: A:=6; GO FAR XRXX                                      % No disk opti for this device
143315
143315   DIST1: X=:DDFADDR                                             % Disc controller datafield
143316          % Are there any free disk queue elements:
143316          X:="QP100"
143317          IF X.5MQCU=0 THEN
143321             % Wait until free disk queue element is available:
143321             X:=CMSGA
143322             CALL SLOCK; 0/\0
143324   *NNT13=*
143324             CALL XTER500; 0/\0
143326             CALL IFM500XQ; CALL SUNLOCK
143330             T:=5MBBANK; *AAX PLINK; LDATX; AAX -PLINK
143334             A=:N5MESSAGE
143335             % Link message into driver level wait queue
143335             AD:=5MWQU; T:=5MBBANK; *LINK@3 STDTX
143340             A:=T; D:=X
143342   *NNC20,   CNVWADR
143345             AD=:5MWQU
143346             GO NXTMSG                                          % old: GO 5STDR
143347          FI
143347          % Get a disk access queue element:
143347          X=:B; *AAX QPFRH
143351          CALL GETOUT; 5MQCU-1=:5MQCU; T=:CUREL=:B
143357          % Set up parameters in disk access queue element
143357          X:=CMSGA; T:=5MBBANK; *AAX 5MDIS; LDATX
143363          A=:DISID
143364          IF A/\77=0 THEN
143366             T:=60                             % Read from disk, clear cache
143367          ELSE
143370             IF A=1 OR A=7 THEN                % Func 7: write without 'dump dirty'
143376                T:=61                          % Write to disk, microprog checks on func 7.
143377             ELSE
143400                IF A=6 THEN
143403                   T:=66                       % Read, do not clear cache
143404                ELSE
143405                   A:=7; GO FAR XRXX; *)FILL   % Illegal parameter (illegal read/write function code)
143443                FI
143443             FI
143443          FI
143443          DISID/\300+T=:ABFUN; T:=5MBBANK
143450          *AAX 5MEMA-5MDIS; LDDTX
143452          AD=:MEMAD;  *AAX 5DSEC-5MEMA; LDDTX
143455          AD=:ABPA2;  *AAX 5MNOS-5DSEC; LDDTX
143460          A=:ABP31;  *AAX 5MREQ-5MNOS; LDATX
143463          A=:REQID; NWAIT=:5MNOWAIT;
143466          IF 5MFNC/\6><0 THEN 1=:5MNOWAIT; FI
143473          CMSGA=:ADMESS
143475          IF 5DSKC=0 THEN                                        % SMD or SCSI-100
143477             DISID SHZ -6/\7+"HTABL"; X:=DDFADDR
143504             X:=X+A:=X.S0
143506             IF X.S10=20 THEN                                    % Phoenix disk
143512                ABP21 /\7 SHZ 11+ABFUN=:ABFUN
143517                0=:ABP21
143520             FI
143520             CALL FAR CHDISCADDR
143521             X.SECWO*ABP31=:D                                    % Number of words to transfer
143524          ELSE
143525             CALL FAR CHDISCADDR                                 % Domino disk
143526             A:=2000*ABP31=:D                                    % No or words pr sector=2000
143531          FI
143531          T:=5MBBANK; X:=CMSGA; *LDXTX X5SND
143534          D=:T; AD:=MEMAD; CALL CHFIX; GO FAR FERR               % Check if area fixed
143540          % Parameters are now ok, put element into queue:
143540          A:=X-5SWPROC*5PRDSIZE+"S500S"=:X; X.RTRES=:RTRES
143547          X:=:B
143550          DDFADDR=:B; CALL M5TRANS; GO BUSR;   % CALLED WITH: B=CONTR. DF, X=QUEUE DF
143554          X:=:B; GO 5MRDTRANS
143556   BUSR:  0=:CUREL
143557          IF 5MFNC/\6 = 0 THEN
143562             IF NWAIT><0 THEN 1; GO FAR FIN FI
143566             X:=CMSGA; 5MWAIT; CALL WN5STATUS
143571             GO FAR OUT
143572             *)FILL
143621          FI
143621
143621   CHEVENT: X:=XC5CPUDF=:B:=CMSGA                                % X=current message, B=500 cpu datafield
143624          IF T:=5MFNC NBIT 5CHEVENT GO FAR SPROCESS              % Check event
143627          % Search ready queue to see if the request is finished
143627          X=:B; T:=5MBBANK; *AAX 5MHRE; LDDTX
143633          IF 5MFNC BIT 0 THEN
143636             A:=-1=:D; *STDTX
143641          FI
143641          X:="READYQ-NLINK"
143642          DO
143642             X=:T
143643          WHILE X:=X.NLINK><0
143645             % Is the specified request finished
143645             IF X.ADMESS=B THEN
143650                IF D+1=0 GO FOUND; D-1                           % Any request
143654                IF X.REQID=D GO FOUND
143657             FI
143657          OD
143660          % The specified request is not finished
143660          XC5CPUDF=:B; CALL SLOCK; 0/\0
143664          T:=5MBBANK; X:=CMSGA; *AAX 5MSFL; LDATX; AAX -5MSFL
143671          IF A BIT 55REP THEN
143673             A BZERO 55REP; *AAX 5MSFL; STATX; AAX -5MSFL
143677             CALL SUNLOCK
143700             4; GO FAR FIN
143702          FI
143702          CALL SUNLOCK
143703          IF NWAIT><0 THEN
143705             2; GO FAR FIN
143707          ELSE
143710             5MWAIT; CALL WN5STATUS
143712             GO FAR OUT
143713          FI
143713          *)FILL
143727
143727   INTEGER CCUREL
143730   FOUND: % X=found queue element, T=previous element
143730          X=:D=:CCUREL; A:=T+"NLINK"=:X; CALL GETOUT; CALL PTFREE
143737          D=:B; 0=:RTRES=:ADMESS=:5MNOWAIT
143743          T:=5MBBANK; X:=CMSGA; SSSTAT=:D; A:=0; *AAX 5MHIO; STDTX;
143752          A:=REQID=:D; A:=0; *AAX 5MHRE-5MHIO; STDTX; AAX -5MHRE
143760          XC5CPUDF=:B; CALL SLOCK; 0/\0
143764          T:=5MBBANK; *AAX 5MSFL; LDATX
143767          A=:NWAIT                                               % Temporary storage of 5msfl containing 55rep bit
143770          A BZERO 55REP; *STATX; AAX -5MSFL                      % Reset repeat bit
143773          CALL SUNLOCK; CCUREL=:B
143776          % If read, function 0: set clear cache bit mask:
143776          IF ABFUN=60 THEN T:=7400 ELSE T:=0; FI
144005          6=:D;                                                  % Parameter write back mask
144007          IF SSSTAT BIT 4 THEN
144012             A:=11; CALL 5EMONICO
144014          ELSE
144015             IF NWAIT NBIT 55REP THEN
144020                A:=3                                             % Transfer completed
144021             ELSE
144022                A:=13                                            % Transfer completed and restarted by other
144023             FI; CALL 5MONICO
144024          FI
144024          CALL XACTRDY
144025          AD:=5MWQU
144026          IF D><0 THEN                                           % Process waiting for disk access queue element
144030   *NNC21,   CNVBYADR
144033             % Restart first process waiting for a free disk datafield
144033             X:=D; T:=5MBBANK; *LINK@3 LDDTX
144036             AD=:5MWQU
144037             CALL SLOCK; 0/\0
144041             CALL GCPUDF; CALL ERRFATAL; A=:B
144044   *NNT14=*
144044             CALL XTER500; 0/\0
144046             CALL ITO500XQ
144047             CALL ITOFIFOQ                                        % new code
144050             CALL SUNLOCK
144051             TTMR=:TMR
144053          FI
144053          GO FAR OUT
144054          *)FILL
144101
144101   SPROCESS:                                                     % Start process
144101          IF T:=5MFNC NBIT 5STAPRO GO FAR GETMAGNO
144104          T:=5MBBANK; *AAX  5MPRO; LDDTX
144107          IF A=0 OR A>>MX5PROCS GO ILPROC
144113          A-5SWPROC*5PRDSIZE+"S500S"=:X; X:=X.MESSBUFF
144120          T:=5MBBANK; *AAX MAGNO; LDATX; AAX XADPR-MAGNO; LDXTX
144125          IF A><D OR X.RTRES=0 THEN
144131   ILPROC:   % A:=EILPROC=:D; X:=N5MESSAGE; A:=0; *AAX 5MHIO; STDTX; AAX -5MHIO
144131             A:=5; GO FAR XRXX
144133          FI
144133          X=:D
144134          IF X.PSTAT BIT T5BUFF THEN
144137             X:=X.MESSBUFF; CALL RN5STATUS
144141             IF A=STOPPED OR A=I5TMQ THEN                        % new code
144147                A=:D; CALL GCPUDF; CALL ERRFATAL; A=:B           % new code
144153                IF D=STOPPED THEN
144156                   CALL OKMONICO                                 % Start requested process
144157                ELSE
144160                                                                 % old: IF A=I5TMQ THEN
144160                   CALL FR5TMQU
144161                   CALL SLOCK; 0/\0
144163   *NNT15=*
144163                   CALL XTER500; 0/\0
144165                   A:=1; CALL SPITMQ
144167                   CALL ITO500Q
144170                   CALL SUNLOCK
144171               FI
144171               CALL XACTRDY                                      % new code
144172               IF XC5CPUDF><B THEN                              % new code
144175   *NNA06=*
144175                  CALL XACT500                                  % new code
144176               FI                                               % new code
144176               XC5CPUDF=:B                                      % new code
144200             FI
144200          ELSE
144201             CALL SLOCK; 0/\0
144203             D=:X; T:=5MBBANK; X:=X.MESSBUFF; *AAX 5MSFL; LDATX
144210             A BONE 55REP; *STATX
144212             CALL SUNLOCK
144213          FI
144213          IF NWAIT=0 THEN
144215             CALL SLOCK; 0/\0
144217             T:=5MBBANK; X:=CMSGA; *AAX 5MSFL; LDATX
144223             IF A NBIT 55REP THEN
144225                *AAX -5MSFL
144226                STOPPED; CALL WN5STATUS
144230                CALL SUNLOCK
144231                GO FAR OUT
144232             FI
144232             A BZERO 55REP; *STATX
144234             CALL SUNLOCK
144235             4
144236          ELSE
144237             1
144240          FI
144240          GO FAR FIN
144241   *)FILL
144273
144273   INTEGER FCONNO
144274   GETMAGNO:                                                     % Get magic number
144274         IF T:=5MFNC BIT 5GMAGNO THEN
144277              T:=5MBBANK; *AAX 5FILN; LDATX
144302              A=:FCONNO; *AAX -5FILN; LDATX X5SND
144305              A=:T; 40*5CNSIZE; A:=:T; *RMPY SA DT;
144312              A:=D+CNSTART=:X; T+X=:D
144317              T:=CNBANK
144320              DO WHILE X<<D
144322                 *LDATX
144323                 IF A><0 AND A-FCONNO=0 THEN
144326                    % Found, return magic number to caller:
144326                    X=:A; A-CNSTART=:D:=0; T:=5CNSIZE; *RDIV ST
144334                    A=:D:=0; T:=5MBBANK; X:=CMSGA; *AAX 5MAGN; STDTX; AAX -5MAGN
144343                    T:=0; 4=:D; A:=1; CALL 5MONICO
144350                    CALL XACTRDY                                   % new code
144351                    GO FAR OUT
144352                 FI
144352                 X+5CNSIZE
144353              OD
144354              A:=16; GO XRXX                                     % File not opened for direct transfer
144356          FI
144356          A:=12; GO XRXX                                         % Illegal function code
144360   FERR:  % Memory area is not fixed:
144360          A:=10
144361   XRXX:  X:=CMSGA; D:=0; CALL 5EMONICO
144364          CALL XACTRDY                                            % new code
144365          IF T:=CUREL><0 THEN
144370             CALL PTFREE
144371          FI
144371          GO OUT
144372
144372   FIN:   X:=XC5CPUDF=:B:=CMSGA
144375          D:=0; T:=0; CALL 5MONICO
144400          CALL XACTRDY                                            % new code
144401   OUT:   XC5CPUDF=:B; GO NXTMSG
144404   *)FILL
144422
144422   %================================================================================
144422   %      C H D I S K A D D R
144422   % Subroutine to check if disk address is within file
144422   %
144422   % Entry: B-reg: pointer to disk access queue element
144422   %
144422   INTEGER POINTER LREG               % Return address
144423   INTEGER XREG
144424   INTEGER LSEC1,LSEC2                % Last sector no + 1 in transfer
144426   DOUBLE LSECT=LSEC1
144426   CHDISKADDR:
144426           A:=L=:"LREG"; X=:XREG
144431           T:=5MBBANK; X:=CMSGA; *AAX 5MAGN; LDATX; AAX -5MAGN
144436           A=:D; A SHZ -5; *LDXTX X5SND
144441           IF A><X THEN A:=15; GO FAR XRXX; FI                   % Illegal magic number
144445           T:=CNBANK; A:=D*5CNSIZE+CNSTART=:X                    % X= open file entry
144452           *LDATX 10                                             % Access flag
144453           IF A BIT RACCFLAG THEN                                % Read only
144455              IF DISID BIT 0 THEN                                % Check read function
144460                 A:=17; GO FAR XRXX                              % Not write access
144462           FI;FI
144462           *LDDTX 20                                             % Disk datafield and unit
144463           IF A-DDFADDR=0 THEN                                   % Correct disk
144465              DISID SHZ -6;
144467              IF A=D THEN                                        % Correct unit
144471                 *LDDTX 40                                       % Start sector on disk
144472                 A=:T; D=:L
144474                 AD:=ABPA2; D-L; A:=A+C-1-T
144501                 IF A>=0 THEN
144502                    AD:=ABPA2; T:=ABP31; D+T; A:=A+C
144506                    AD=:LSECT; T:=CNBANK; *LDDTX 60              % Last sector
144511                    A:=:D; A-LSEC2; A:=:D; A:=A+C-1-LSEC1
144517                    IF A>=0 THEN                                 % Transfer within file
144520                       X:=XREG; GO LREG
144522                 FI;FI
144522                 A:=20; GO FAR XRXX
144524              FI; A:=21; GO FAR XRXX
144526           FI
144526           A:=22; GO FAR XRXX
144530   *"8N500 -8MTRA
"144530   RBUS
144540
144540
144540   *"8N500 8MTRA
"144540
144540
144540   %============================================================================
144540   %        ( M )     5 M R D T R A N S
144540   %
144540   % Driver level routine activated after transfer is finished
144540   %
144540   % Entry:  B= disk access queue element (removed from acc queue)
144540   %
144540   %
144540   SUBR 5MRDTRANS
144540
144540   5MRDTRANS:
144540           IF "N500DF".SYSINITFLAG BIT B5STOP GO WT12
144544           % First: check if process has terminated:
144544           IF RTRES=0 THEN
144546              B=:T; 0=:REQID; CALL PTFREE
144551              AD:=5MWQU
144552              IF D><0 THEN
144554   *NNC22,       CNVBYADR
144557                 % Restart first process waiting for a free datafield
144557                 X:=D; T:=5MBBANK; *LINK@3 LDDTX
144562                 AD=:5MWQU
144563                 CALL SLOCK; 0/\0
144565                 CALL GCPUDF; CALL ERRFATAL; A=:B
144570   *NNT16=*
144570                 CALL XTER500; 0/\0
144572                 CALL ITO500XQ
144573                 CALL ITOFIFOQ                                    % new code
144574                 CALL SUNLOCK
144575                 GO N500
144576              FI
144576              GO WT12
144577           FI
144577           % Is 500 process waiting until transfer is finished?
144577           IF 5MNOWAIT><0 THEN
144601              % Has the process later gone into wait
144601              X:=ADMESS; CALL RN5STATUS
144603              IF A-5MWAIT=0 THEN
144605                 *AAX 5MREQ; LDATX
144607                 IF A=-1 GO 5RMSTART                             % Waiting for any request
144612                 IF A=REQID GO 5RMSTART                          % Waiting for this request
144615              FI
144615              % The process is not waiting for this request
144615              % Put datafield into ready queue
144615              X:="READYQ-NLINK"
144616              DO
144616                X=:T
144617              WHILE X:=X.NLINK><0
144621              OD
144622              A:=T+"NLINK"=:X; B=:T; CALL PUTIN
144627              GO WT12
144630           FI
144630   5RMSTART: % Process should be restarted
144630           B=:T; CALL PTFREE
144632           T:=5MBBANK; X:=ADMESS; SSSTAT=:D; A:=0; *AAX 5MHIO; STDTX
144641           A:=REQID=:D; 0=:REQID; A:=0;  *AAX 5MHRE-5MHIO; STDTX; AAX -5MHRE
144650           % If read,function 0: set clear cache bit mask:
144650           IF ABFUN=60 THEN T:=7400 ELSE T:=0; FI
144657           6=:D;                                                 % Parameter write back mask
144661           IF SSSTAT BIT 4 THEN
144664              A:=11; CALL 5EMONICO
144666           ELSE
144667              A:=3; CALL 5MONICO
144671           FI
144671           0=:RTRES=:ADMESS=:5MNOWAIT=:SSSTAT
144675           CALL GCPUDF; CALL ERRFATAL; A=:B
144700           CALL XACT500                                  % new code
144701           AD:=5MWQU
144702           IF D><0 THEN
144704   *NNC23,    CNVBYADR
144707              % Restart first process waiting for a free datafield
144707              X:=D; T:=5MBBANK; *LINK@3 LDDTX
144712              AD=:5MWQU
144713              CALL SLOCK; 0/\0
144715              CALL GCPUDF; CALL ERRFATAL; A=:B
144720   *NNT17=*
144720              CALL XTER500; 0/\0
144722              CALL ITO500XQ
144723              CALL ITOFIFOQ                              % new code
144724              CALL SUNLOCK
144725              GO N500
144726           FI
144726           GO WT12                                       % old: go n500
144727   RBUS
144755
144755   *"8N500
"144755
144755

144755   %============================================================================
144755   %      ( M )      5 A C T S W A P P E R
144755   %
144755   % Subroutine to activate the n500 swapper process
144755   %
144755   % When called from other levels than the driver level
144755   % then 5ACTSWAPPER must be called in "iof"
144755   %
144755   % Entry:     X=message requireing service from swapper
144755   %
144755   % exit:      T,A,D regs are destroyed
144755   %
144755   SUBR 5ACTSWAPPER
144755   INTEGER POINTER LREG
144756   INTEGER MSGTOSW
144757   DOUBLE  CMSGTOSW
144761   INTEGER BREG
144762
144762   5ACTSWAPPER: A:=L=:"LREG"
144764          CALL SLOCK; 0/\0
144766          X=:D=:MSGTOSW; A:=5MBBANK
144771   *NNC24,CNVWADR
144774          AD=:CMSGTOSW
144775          SWPWAIT; CALL WN5STATUS                    % Mark that proc. is waiting for swapper
144777          X:=SWMSG; CALL RN5STATUS
145001          IF A=PSWWAIT THEN                          % Swapper free?
145004             T:=5MBBANK; X:=SWMSG
145006             AD:=CMSGTOSW; *AAX HSWPI; STDTX
145011             SWACTIVE; *AAX SWPFU-HSWPI; STATX
145014             X:="N500DF".X500DF; *AAX X5SWO
145017             CMSGTOSW; T:=5MBBANK; *STDTX
145022             X:=MSGTOSW; SWPPING; CALL WN5STATUS    % Mark that process is using the swapper
145025             T:=5MBBANK; *AAX 5MSFL; LDATX          % Disable escape while using swapper
145030             *5IBRK@3 BLDA DA                       % K:=PSTAT.5IBRK
145031             A BONE 5IBRK; *S5IBR@3 BSTA DA; STATX  % K=:PSTAT.S5IBRK
145034             X:=MSGTOSW
145035             T:=5MBBANK; *MICFU@3 LDATX; COPY SA DD % D:=X.MICFUNC
145040             IF 3SWMESS=D THEN                      % Message to swapper?
145043                *SWFUN@3 LDATX                      % Yes
145044             ELSE
145045                *AAX TRAPN; LDATX                   % No, trap (pagefault)
145047                A=:D/\377; *STATX
145052                A:=D SHZ -10
145054             FI
145054             X:=SWMSG; *AAX SWPST; STATX            % Save reason for activating swapper
145057             A:=6; *AAX NUMPA-SWPST; STATX          % Par #2 & par #3 will be written into
145062             A:=0=:D; *AAX FUNCV-NUMPA; STDTX
145066             *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
145071             3MONCO; *MICFU@3 STATX
145073             CALL MCCO                              % Yes, restart swapper after mon.call
145074             CALL SUNLOCK
145075             CALL XACTRDY
145076   *NNJ11=*
145076             GO OUT
145077             CALL XTER500; 0/\0
145101             CALL ITO500XQ
145102             T:=5MBBANK; *AAX 5CPUN; LDATX
145105             A/\177400\/CPUNO; *STATX; AAX -5CPUN
145111          ELSE
145112             % - Insert in Swap-wait-fifo
145112             T:=5MBBANK; X:="N500DF".X500DF; *AAX X5MXF; LDATX
145117             A=:L; *AAX X5SWF-X5MXF; LDATX
145122             IF A=:D+1>=L THEN A:=0 FI; *STATX      % Max Swap-wait-fifo Fylle-pointer?
145130             D SH 1=:L; *AAX X5SWB-X5SWF; LDDTX     % Compute Swap-wait-fifo address
145134   *NNC25,   CNVBYADR                               %
145137             X:=D+L; T:=A+C; CMSGTOSW; *STDTX       % Insert new message
145144             CALL SUNLOCK
145145          FI
145145   OUT:   X:=MSGTOSW; GO LREG
145147   RBUS
145165
145165
145165   %===============================================================================
145165   %       ( M )    X T E R 5 0 0
145165   %
145165   % Routine to terminate (stop) nd-500
145165   %
145165   % Entry:     X=-1 then no actual message
145165   %            X><-1 then x=actual message
145165   %
145165   % Exit:      error, nd-500 not terminated
145165   %
145165   % Exit+1:    ok, nd-500 stopped
145165   %
145165   SUBR XTER500
145165   INTEGER DREG,XREG,LOOPCOUNTER,LOOP2COUNT
145171   INTEGER POINTER LREG
145172   INTEGER 500STATUS=LOOP2COUNT                  % Nd-500 status when entering XTER500
145172
145172   XTER500: IF 5CPUSTOPPED><0 THEN EXITA FI      % Already stopped?
145175          A:=D=:DREG:=L=:"LREG"; X=:XREG
145202          0=:LOOPCOUNTER
145203   *NNJ12=*
145203          GO TER51
145204          T:=HDEV+RSTA5; *IOXT
145207          A=:500STATUS
145210          IF A BIT 5ILOCK THEN                   % Nd-500 running, i/f locked
145212             T+"TERM5-RSTA5"; *IOXT
145214             T+"RSTA5-TERM5"
145215             FOR LOOPCOUNTER DO                  % Wait for nd-500 to unlock i/f
145215                FOR X:=-20 DO; OD
145217                *IOXT
145220                WHILE A BIT 5ILOCK
145222             OD
145224          FI
145224          IF A NBIT 5ILOCK GO OKRET             % Did nd-500 terminate ?
145226          CALL X5MCST                           % Time out; master clear it
145227          GO TER52
145230
145230   TER51:
145230          FOR LOOPCOUNTER DO
145230              IDLEKICK; CALL XKICK500
145232              CALL GETC5PROC
145233              IF A=-1 GO OKRET
145236          OD
145240
145240   TER52: ESPTIMOUT
145241          IF X:=XREG><-1 THEN CALL WN5STATUS FI
145246          A=:FERROR; GO ERR
145250
145250          % Return points
145250   OKRET: MIN 5CPUSTOPPED; 0/\0; MIN "LREG"
145253   ERR:   A=:D:=DREG:=:D; X:=XREG; GO LREG
145260   RBUS
145265
145265   %==========================================================================
145265   %        ( M )     X A C T R D Y
145265   %
145265   % Activate nd-500 with this message if any cpu is idle
145265   % or priority higher than the current running ones
145265   %
145265   % Entry:     X=message
145265   %
145265   % Exit:      ok
145265   %
145265   SUBR XACTRDY
145265   INTEGER SVX
145266   INTEGER DREG=?,XREG=?,BREG=?
145266   INTEGER POINTER LREG=?
145266   INTEGER C5CPU=?,CC5CPU=?,CC5PRIOR=?,CSWITCH=?
145266
145266   XACTRDY:
145266   *NNJ13=*
145266           P+1; EXIT                                   % Direct exit if old 500.
145270           T:=5MBBANK; *N5STA@3 LDATX
145272           IF A><MSGN500 AND A><WAITING THEN EXIT FI
145301           A:=L=:"LREG"; A:=D=:DREG; A:=B=:BREG; X=:XREG
145310           CALL GCPUDF; CALL ERRFATAL; A=:B=:C5CPU
145314           IF C5STAT BIT BHPFAIL GO FAR OUT            % If in power-fail
145317           CALL SLOCK; 0/\0
145321           CPUAVAILABLE; *5EXCL@3 BLDA DA
145323           T:=5MBBANK; X:=XREG; *MICFU@3 LDATX
145326           IF K NBIT AND A=3START OR A=3MONCO OR A=3TRACO OR A=3WMONCO OR A=3FITRNSF THEN
145347              T:=5MBBANK; X:=MAILINK; *AAX X5CCL; LDATX
145353              A=:D; X:=XREG; *AAX 5CCLR; LDATX
145357              A-D=:CSWITCH; *AAX 5MSFL-5CCLR; LDATX
145363              IF A BIT 5CPUBOUND THEN 0=:CSWITCH FI
145366           ELSE
145367              0=:CSWITCH
145370           FI
145370           T:=5MBBANK; X:=XREG; *AAX 5PRIO; LDATX
145374           A=:CC5PRIOR; GO ACT50
145376
145376   *)FILL
145403   INTEGER DREG,XREG,BREG
145406   INTEGER POINTER LREG
145407   INTEGER C5CPU,CC5CPU,CC5PRIOR,CSWITCH
145413
145413   ACT50:  IF CSWITCH><0 THEN
145415              "S5CPUDF"=:B; 0=:CC5CPU
145420              DO WHILE B<<="E5CPUDF"
145423                 IF CPUAVAILABLE BIT 5ALIVE AND C5STAT NBIT BHPFAIL THEN
145431                    T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
145435                    IF A=MPACTIVE THEN
145440                       CALL GETC5PROC
145441                       IF A=-1 GO ACT51; IF A<0 GO ACT52
145445                       A-5SWPROC*55MESSIZE+SWMSG=:X
145451                       T:=5MBBANK; *AAX 5PRIO; LDATX
145454                       IF A<CC5PRIOR THEN A=:CC5PRIOR; A:=B=:CC5CPU FI
145462                    FI
145462                 FI
145462                 B+5CPUDFSZ
145463              OD
145464              IF CC5CPU><0 THEN A=:B; GO ACT52 FI
145470              C5CPU=:B; GO ACT51
145473           ELSE
145474              CALL GETC5PROC
145475              IF A=-1 THEN
145500   ACT51:        T:=5MBBANK; X:=MAILINK; *AAX X5ACT; STZTX
145504              ELSE
145505                 IF A<0 GO ACT52
145506                 A-5SWPROC*55MESSIZE+SWMSG=:X; T:=5MBBANK; *AAX 5PRIO; LDATX
145515                 IF A<CC5PRIOR THEN
145520   ACT52:           N100KICK; CALL XKICK500
145522                 ELSE
145523                    GO ACT51
145524                 FI
145524              FI
145524           FI
145524           CALL SUNLOCK; 0=:5CPUSTOPPED
145526   OUT:    DREG=:D; X:=XREG; BREG=:B; GO LREG
145534   RBUS
145545
145545
145545   %==========================================================================
145545   %        ( M )     X A C T 5 0 0
145545   %
145545   % Activate the nd-500.
145545   %
145545   % Entry:     B=n500 cpu-datafield, X=message
145545   %
145545   % Exit:      T,A,D registers are destroyed
145545   %
145545   SUBR XACT500
145545   INTEGER DREG,XREG
145547   INTEGER POINTER LREG
145550   INTEGER 500STATUS
145551
145551   XACT500:
145551   *NNJ14=*
145551           GO XACTRDY                                    % Continue in XACTRDY if nd5000
145552           A:=D=:DREG; A:=L=:"LREG"; X=:XREG
145557           T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
145563           IF A=MPACTIVE AND C5STAT NBIT BHPFAIL THEN    % If not in power-fail
145571              T:=HDEV+RSTA5; *IOXT                       % Read interface status
145574              A=:500STATUS
145575              IF A NBIT 5CLOST THEN                      % If nd-500 not stopped (clock stopped)
145577                 IF A BIT 5ILOCK THEN                    % If nd-500 not terminated
145601                    CALL XTER500; 0/\0
145603                 FI
145603                 % Activate ND-500 with the first message waitng for ND-500 CPU.
145603                 % Status=msgn500 and status=waiting means waiting for ND-500 CPU.
145603                 X:=MAILINK
145604                 DO                                      % Search ex-queueu to see
145604                    T:=5MBBANK; *LINK@3 LDDTX            % Next message
145606                 WHILE D><-1                             % If any processes is waiting for nd-500 cpu.
145611                    IF X:=D><DUMMESS THEN
145615                       CALL RN5STATUS                    % Message.Status
145616                       IF A=MSGN500 OR A=WAITING GO ACT50% Msgn500 or Waiting?
145624                    FI
145624                 OD
145625                 % No processes waiting for nd-500 cpu.
145625                 T:=5MBBANK; X:=MAILINK; *LINK2@3 LDXTX
145630                 IF X><-1 AND 500STATUS NBIT 5ILOCK THEN % Has ND-500 been terminated?
145636                    % Reactivate it since an interrupt may have been lost
145636   ACT50:           5MBBANK; T:=HDEV+LMAR5; *IOXT
145642                    A:=X; *IOXT
145644                    A:=5; T+"LCON5-LMAR5"; *IOXT
145647                 ELSE
145650                    % Enabale for interrupt
145650                    A:=10; T:=HDEV+LCON5;   *IOXT
145654                    A:=0;  T+"LSTA5-LCON5"; *IOXT
145657                    A:=1;  T+"LCON5-LSTA5"; *IOXT
145662                           T+"SLOC5-LCON5"; *IOXT
145664                    TTMR=:TMR
145666                 FI
145666              FI
145666           FI
145666   OUT:    0=:5CPUSTOPPED
145667           DREG=:D; X:=XREG; GO LREG
145673   RBUS
145700
145700
145700   %============================================================================
145700   %      ( M )   X R S T A R T A L L                     (WM-400)
145700   %
145700   % Routine to restart all sintran iii programs with
145700   % Messages in the N500 execution queue with an error message
145700   %
145700   % Executed on lvl 12
145700   %
145700   % Entry:     A=error status
145700   %            B=cpu df
145700   %
145700   SUBR XRSTARTALL
145700   INTEGER ERRSTAT=?,DREG=?,BREG=?
145700   DOUBLE  ADREG=?
145700   INTEGER POINTER LREG=?
145700   INTEGER CCCLR=?
145700
145700   XRSTARTALL:
145700          AD=:ADREG; T:=L=:"LREG"; T:=B=:BREG
145705          IF A NBIT POWDOWN THEN                                  % Power-fail ?
145707             IF A=:FERROR=N5STOPPED GO RSTA2
145713             T:=5MBBANK; X:=MAILINK; MPFAIL; *AAX X5CPU; STATX
145720             CALL CHACTIVEQ; GO FAR RSTA2
145722          FI
145722          T:=5MBBANK; X:=MAILINK; *AAX X5CCL; LDATX
145726          A=:CCCLR
145727          X:=MAILINK
145730          DO
145730             T:=5MBBANK; *LINK@3 LDDTX
145732          WHILE D><-1                                             % Search the whole ex-queue
145735   *NNC26,    CNVBYADR
145740             IF X:=D><DUMMESS THEN
145744                T:=5MBBANK; *AAX 5CPUN; LDATX; AAX -5CPUN
145750                IF A/\377=CPUNO THEN
145754                   IF ERRSTAT NBIT POWDOWN THEN
145757                      IF X=SWMSG GO FAR RSTA2
145762                      IF MIFLAG BIT MUDOM THEN
145765                         T:=5MBBANK; *AAX 5CCLR; LDATX; AAX -5CCLR
145771                         IF A-CCCLR><0 THEN                       % Can process be moved to another CPU?
145773                            *AAX 5MSFL; LDATX; AAX -5MSFL
145776                            IF A BIT 5SYSRES GO RSTA1
146000                            IF A NBIT 5CPUBOUND THEN CALL XACTRDY; GO RSTA1 FI
146004                         FI
146004                      FI
146004                      CALL RN5STATUS
146005                      IF A=SWPPING THEN
146010                         CALL SLOCK; GO RSTA2
146012                         T:=5MBBANK; *AAX 5MSFL; LDATX
146015                         A BONE 52ESCSET; *STATX; AAX -5MSFL
146020                         ERRSTAT; CALL WN5STATUS
146022                         CALL SUNLOCK; GO RSTA1
146024                      FI
146024                   ELSE
146025                      IF X=SWMSG GO RSTA1
146030                      CALL RN5STATUS
146031                      A BONE POWDOWN
146032                      CALL SLOCK; GO RSTA2
146034                      CALL XTER500; 0/\0
146036                      CALL RN5STATUS
146037                      A BONE POWDOWN
146040                      GO F5XQ
146041                   FI
146041                   CALL SLOCK; GO RSTA2
146043                   CALL XTER500; 0/\0
146045                   ERRSTAT; GO F5XQ
146047
146047   INTEGER CCCLR
146050   INTEGER FTRRSTAT:=E5FATAL                                      % Error code for FTXEL error logger
146051   INTEGER ERRSTAT,DREG,BREG
146054   DOUBLE  ADREG=ERRSTAT
146054   INTEGER POINTER LREG
146055
146055   F5XQ:           CALL WN5STATUS
146056                   CALL IFM500XQ                                  % Remove from ex-queue
146057                   CALL SUNLOCK
146060                   T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
146064                   IF A NBIT 5SYSRES THEN
146066                      CALL 5XACTRT
146067                   FI
146067                FI
146067             FI
146067   RSTA1: OD
146070          GO OUT
146071   *)FILL
146111
146111   RSTA2:
146111          "S5CPUDF"=:B
146113          DO WHILE B<<="E5CPUDF"
146116             IF ERRSTAT NBIT POWDOWN THEN                         % Not power-fail ?
146121                A=:FERROR                                         % Set "global" error-code
146122                T:=5MBBANK; X:=MAILINK
146124                MPFAIL; *AAX X5CPU; STATX
146127             FI
146127             X:=MAILINK
146130             DO
146130                T:=5MBBANK; *LINK@3 LDDTX
146132             WHILE D><-1                                          % Search the whole ex-queue
146135   *NNC27,      CNVBYADR
146140                IF X:=D><DUMMESS THEN
146144                   T:=5MBBANK; *AAX 5CPUN; LDATX; AAX -5CPUN
146150                   IF A/\377=CPUNO THEN
146154                      IF ERRSTAT BIT POWDOWN THEN                 % Power-fail ?
146157                         IF SWMSG=X GO RSTA3                      % Yes, no restart of 5swap
146162                         CALL RN5STATUS
146163                         A BONE POWDOWN
146164                      FI
146164                      CALL WN5STATUS                              % Error-code in status of message
146165                      CALL IFM500XQ                               % Remove from ex-queue
146166                      T:=5MBBANK; *AAX 5MSFL; LDATX; AAX -5MSFL
146172                      IF A NBIT 5SYSRES THEN
146174                         CALL 5XACTRT                             % Restart nd-100 program
146175                      FI
146175                   FI
146175                FI
146175   RSTA3:    OD
146176             B+5CPUDFSZ
146177          OD; GO OUT
146201
146201
146201   OUT:
146201   *"8N500 8FTS5
"146201          *1BANK
146202          IF ERRSTAT BIT POWDOWN THEN                             % Anything with power?
146205             IF A BIT POWUP THEN EPWUP                            % - N500TMR
146210             ELSE IF A BIT POWDET THEN EPWDET
146214             ELSE EPWDOWN FI FI                                   % - N500C
146216             A=:ERRSTAT; CALL 9FLER(ERRSTAT,1)
146222          ELSE
146223             IF A=N5STOPPED THEN
146226                CALL 9FLER(ERRSTAT,1)
146231             ELSE
146232                CALL 9FLER(FTRRSTAT,2)
146235             FI
146235          FI
146235          *2BANK
146236   *"8N500
"146236          BREG=:B; ADREG; GO LREG
146242
146242   RBUS
146262
146262
146262   %============================================================================
146262   %      ( M )    C H A C T I V E Q
146262   %
146262   % Routine to check number of active CPUs in the system.
146262   %
146262   % Entry:  none
146262   % Exit:   none active cpu
146262   % Exit+1: one or more active cpu
146262   %
146262   SUBR CHACTIVEQ
146262   INTEGER XREG,CNCPU
146264
146264   CHACTIVEQ: X=:XREG; 0=:CNCPU
146266         X:="S5CPUDF"
146267         DO WHILE X<<="E5CPUDF"
146272            IF X.C5STAT NBIT BHPFAIL THEN
146275               T:=5MBBANK; X=:D:=X.MAILINK; *AAX X5CPU; LDATX
146302               X:=D; IF A=MPACTIVE THEN MIN CNCPU; 0/\0 FI
146310            FI
146310            X+5CPUDFSZ
146311         OD
146312         X:=XREG
146313         IF CNCPU><0 THEN L+1 FI
146316         EXIT
146317   RBUS
146322
146322
146322   %============================================================================
146322   %      ( M )    K I C K 5 0 0
146322   %
146322   % Kick the nd-500 via octobus
146322   % Called in IOF if called from other level than 12
146322   % Executed on level 12
146322   % Must be called in iof if called from other levels than the driver level
146322   %
146322   SUBR XKICK500
146322   INTEGER CKICKTYPE,CLVL,CPIE
146325   INTEGER POINTER LREG
146326   XKICK500: A=:CKICKTYPE; *TRA STS
146330          A SH -5/\170=:CLVL
146333          *IOF
146334          IF CLVL><LV12B THEN                      % Called from n500 driver level?
146340             A:=B; *IRW LV12B DB                   % No, switch to n500 driver level
146342             "WT12"; *IRW LV12B DL
146344             "LV12KICK";*IRW LV12B DP
146346             LV12; *MST PID
146350             *ION; IOF
146352             CPIE; *MST PIE
146354             EXIT
146355          FI
146355   LV12KICK:                                       % Entry point of "send-octobus-kick" routine on level 12
146355          *ION
146356          A:=L=:"LREG"
146360          T:=5STATION; X:=OCTORING; A:=CKICKTYPE   % Set up kick parameters
146363          CALL SKICK; GO ERR                       % Call octobus kick routine
146365   OUT:   IF CLVL><LV12B THEN                      % Called originally on n500 driver level?
146371             *IOF                                  % No, return to correct level via level 14
146372             "LV14KICK"; *IRW LV14B DP
146374             LV14; *MST PID; ION
146377          FI; GO LREG
146400
146400   ERR:   A=:T; CALL 9ERR(#99); GO OUT
146404
146404   % Level 14 routine to disable all lower levels than
146404   % the calling one to ensure a kind of "iof" sequence
146404   INTEGER CSHSHR(0); *SHD+SHR
146405   INTEGER CSH(0);    *SHD
146406   LV14KICK: *TRA PIE
146407          A=:CPIE:=37777=:D:=CLVL SHZ -3+1
146415          T:=CSHSHR-A; *EXR ST
146420          T:=CSH+A;    *EXR ST
146423          A:=D; *MCL PIE
146425          GO YWAIT
146426   RBUS
146440
146440
146440   %===============================================================================
146440   %      ( M )    X R S 5 C P U
146440   %
146440   % Routine to send Octobus "Reset CPU" multibyte message.
146440   %
146440   % Entry:        B=CPU df
146440   % Exit:         Error
146440   % Exit+1:       Ok
146440   %
146440   SUBR XRS5CPU
146440   INTEGER BREG
146441   INTEGER POINTER LREG
146442   XRS5CPU: A:=L=:"LREG":=B=:BREG
146446          % Build Octobus message
146446          5STATION=:"LMFIELD".MOCTSTATION                     % Station number
146451          OMDACCP =:        X.MOCTOMD                         % OMD number
146453          0       =:        X.MBROADCAST                      % Not broadcast
146454          1       =:        X.MMSGLENGTH                      % Message length = 1 byte
146456          CMCPURES SHZ 10=: X.MCOMMAND                        % Send "Reset CPU"
146461          "LMDF"=:B; T:=5OMDNO; X:=OCTORING
146465          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
146470          CALL MBSEND; 0/\0
146472          BREG=:B; GO LREG
146475
146475   RBUS
146500
146500
146500   %===============================================================================
146500   %      ( M )    R S 5 C P U
146500   %
146500   % Routine to reset all active CPUs.
146500   % Activated from level 1 (5pit).
146500   %
146500   SUBR RS5CPU
146500   RS5CPU: "S5CPUDF"=:B
146502          DO WHILE B<<="E5CPUDF"
146505             IF CPUAVAILABLE BIT 5ALIVE AND MAILINK><-1 THEN
146514                T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
146520                IF A><MPNACTIVE THEN
146523                   IF CPUAVAILABLE/\5CPUTYPE=SAMSON THEN
146530                      CALL XRS5CPU
146531                   ELSE
146532                      CALL XTER500; 0/\0
146534                      CALL X5MCST
146535                   FI
146535                FI
146535             FI
146535             B+5CPUDFSZ
146536          OD
146537          GO WT12
146540   RBUS
146550
146550
146550   %===============================================================================
146550   %      ( M )    5 O M B R E A D
146550   %
146550   % Routine to read Octobus message from  the ACCP
146550   % Activated if multi-byte message is received on reserved OMD number
146550   %-------------------------------------------------------------------------------
146550   % accp:         SEC code:
146550   %
146550   % 5000-mp:      SEC code:
146550   %
146550   % mf-contoller: SEC code: 14 +
146550   %     20b = Corrected memory error
146550   %     30b = Memory timeout
146550   %     31b = Unknown error
146550   %     50b = Memory write parity
146550   %     51b = Memory I/O-error
146550   %     77b = Fatal error in MF-controller
146550   %
146550   % accp:          error record
146550   %    type taccprec=record
146550   %        toctoheader: octoheader
146550   %        byte:        errcode               %
146550   %        byte:        errtype               %
146550   %    endrecord
146550   %    % errcode:
146550   %    constant  hwfault=200b                 % fatal hw fault
146550   %    % errtype:
146550   %    contstant accperr=  1                  % memory error reported from accp
146550   %
146550   % mp:            error record
146550   %    type taccprec=record
146550   %        toctoheader: octoheader
146550   %        byte:        errcode
146550   %        byte:        errtype
146550   %        integer2:    process_no
146550   %        integer4:    trapping_p
146550   %        integer4:    restart_p
146550   %        integer2:    trap_no
146550   %        integer4:    mms_sts
146550   %        integer4:    log_addr
146550   %        integer4:    phys_addr
146550   %        integer2:    Phys_seg
146550   %        integer4:    wr
146550   %        integer2:    asts
146550   %        integer2:    badap
146550   %    endrecord
146550   %    % errtype:
146550   %    constant mperr=2                     % error reported from micro-program
146550   %
146550   % mf-controller: error record
146550   %    type tmfrec=record
146550   %        tocthead: octheader
146550   %        integer2: etype     % error cycle & type
146550   %        integer2: emainstat % mf error event
146550   %        integer2: elog1     % errlog1
146550   %        integer2: elog2
146550   %        integer2: elog3
146550   %        integer2: elog4
146550   %        integer2: emaster
146550   %        integer2: eslave
146550   %        integer2: eaddress
146550   %        integer2: esyndrom
146550   %    endrecord
146550   %
146550   %    Error record sent to Layer Manager (9FLER):
146550   %    type terrec=record
146550   %        integer2: sec_code  % =etype: error cycle & type
146550   %        integer2: octsource % octobus station # of source (sender)
146550   %        integer2: omdsource % octobus omd # of source (sender)
146550   %        integer2: emainstat % mf error event
146550   %        integer2: elog1     % errlog1
146550   %        integer2: elog2
146550   %        integer2: elog3
146550   %        integer2: elog4
146550   %        integer2: emaster
146550   %        integer2: eslave
146550   %        integer2: eaddress
146550   %        integer2: esyndrom
146550   %    endrecord
146550   %
146550   %
146550   SUBR 5OMBREAD,I5OMBR
146550   % Fatal ErrorMessage indicator
146550   INTEGER ARRAY MPFATAL:=(1\0,0\1,0\0,0\0,0\1,1\0)
146556
146556   INTEGER CSTS=?,CMICP=?
146556   INTEGER LMREC=?,LMSIZE=?
146556   5OMBREAD:
146556   %      DO
146556             "LMFIELD"=:D; A:=DPITBANK
146561             X:=OCTORING; T:=5OMDNO; CALL OMBREAD; GO ERR
146565             IF "LMFIELD".MOCTSTATION>=FN5DEST AND A<=LN5DEST THEN
146575                X.ETYPE=:D SHZ -10=:CSTS; A:=D/\377=:CMICP
146604                % ErrorMessage or Ack/Nack from ACCP/Microproram?
146604                X.MOCTSTATION; CALL FAR GN5CPUDF; GO I5OMBR
146607                IF CSTS=MFACK OR A=MFNACK THEN
146616                   % Ack/Nack answer on 'WriteSysPar' message
146616                   % i.e. I'm present
146616                   CPUAVAILABLE BONE 5ALIVE=:CPUAVAILABLE
146621                   GO I5OMBR
146622                FI
146622                % ErrorMessage
146622                IF CSTS/\17<17 THEN
146627                   % Known ErrorMessage
146627                   A=:X; T:="MPFATAL"; *1BANK; LBYT; 2BANK
146634                   IF A><0 THEN
146635                      CSTS\/N5SECCODE; CALL XRSTARTALL
146640                   FI
146640                FI
146640                CPUNO=:"LMFIELD".MOCTSTATION
146643                % HW-fault/General trap reported by the microprogram?
146643                IF CMICP=1 AND CSTS=200 OR A=201 THEN
146656                   "LMFIELD".S5-5SWPROC*5PRDSIZE+"S500S"
146663                   A.RTRES=:"LMFIELD".S4                    % Add shadow process id
146667                   "LMFIELD+2"=:LMREC
146671                   X.MMSGLENGTH+4=:LMSIZE
146674                ELSE
146675                   "LMFIELD+3"=:LMREC
146677                   "LMFIELD".MMSGLENGTH+2=:LMSIZE
146703                FI
146703                CSTS\/N5SECCODE=:CSTS
146706             ELSE IF A>=FMFDEST AND A<=LMFDEST THEN
146715                % ErrorMessage or Ack/Nack from MF-controller
146715                IF X.ETYPE=MFACK GO I5OMBR
146721                A=:CSTS
146722                "LMFIELD+2"=:LMREC
146724                "LMFIELD".MMSGLENGTH+2=:LMSIZE
146730             ELSE
146731                GO I5OMBR
146732                % Octobus error
146732   ERR:         IF A><101410 THEN
146735                   A=:CSTS
146736                   0=:"LMFIELD".MOCTSTATION
146740                   "LMFIELD+2"=:LMREC
146742                   2=:LMSIZE
146744                ELSE
146745                   GO I5OMBR
146746                FI
146746             FI FI
146746             GO BYPASS
146747
146747   INTEGER CSTS,CMICP
146751   *)FILL
146772
146772   BYPASS:   "LMFIELD".MOCTSTATION=:LMREC.EOCTSOURCE
146776             CSTS=:X.ESECCODE
147000             LMSIZE+1 SH -1=:LMSIZE          % Convert # of bytes to # of 16-bits words
147004             CALL 9FLER                      % Parameters to 9FLER follow in the next to locations
147005   INTEGER      LMREC                        % 1st parameter; address of error information
147006   INTEGER      LMSIZE                       % 2nd parameter; size of error information
147007             % Mf-contoller requires ack message
147007             IF "LMFIELD".EOCTSOURCE>=FMFDEST AND A<=LMFDEST THEN
147017                A      =:"LMFIELD".MOCTSTATION     % Station number
147021                MFOMDNO=:        X.MOCTOMD         % OMD number
147023                0      =:        X.MBROADCAST      % Not broadcast
147024                1      =:        X.MMSGLENGTH      % Message length = 1 byte
147026                MFACK SH 10=:    X.MSTS
147031                X:=OCTORING; T:=5OMDNO
147033                "LMFIELD"=:D; A:=DPITBANK
147036                CALL MBSEND; 0/\0
147040             FI
147040   I5OMBR:   "LMDF"=:B; CALL ID12
147043   %      OD
147043          GO FAR 5OMBREAD
147044   *)FILL
147052
147052   % Local subroutine to get N5000 CPU df from
147052   % octobus source station number.
147052   %
147052   %  Entry:      A=octobus station number
147052   %  Exit:       Error; Cpu df not found
147052   %  Exit+1:     Ok; B=cpu df
147052   %
147052   GN5CPUDF: A=:D; "S5CPUDF"=:B
147055         DO WHILE B<<="E5CPUDF"
147060            IF 5STATION=D THEN EXITA FI
147064            B+5CPUDFSZ
147065         OD
147066         EXIT
147067   RBUS
147071
147071
147071   %============================================================================
147071   %      ( M )    C O N 5 O M D
147071   %
147071   % Connect octobus OMD
147071   % To be able to receive multi byte error messages from:
147071   %    - the MF controller
147071   %    - the accp
147071   %    - the 5000 microprogram
147071   %
147071   % Activated from level 1 (5pit)
147071   %
147071   % Entry:  B=working field
147071   %
147071   SUBR CON5OMD
147071   CON5OMD:
147071          X:=OCTORING; CALL CONOMD; GO WT12           % Connect Octobus OMD number to additional cpu df.
147074          A=:5OMDNO
147075          GO WT12
147076   RBUS
147100
147100
147100   %============================================================================
147100   %      ( M )    M F P R E P A R E
147100   %
147100   % Sends OMD numer to mf-controller on which N100 can receive messages
147100   % Activated from level 1 (5pit)
147100   %
147100   % Ack/Nack answer is handled by 5OMBREAD
147100   %
147100   % Entry:  B=working field
147100   %         A=destination octobus station number
147100   %
147100   SUBR MFPREPARE
147100   MFPREPARE:
147100          A       =:"LMFIELD".MOCTSTATION          % Station number
147102          MFOMDNO =:        X.MOCTOMD              % OMD number
147104          0       =:        X.MBROADCAST           % Not broadcast
147105          3       =:        X.MMSGLENGTH           % Message length = 2 bytes
147107          CMSYSPAR SHZ 10\/N100IDENT=:X.MCOMMAND   % Send OMD numer to mf-controller
147113          5OMDNO SH 10=:X.MDP1
147116          X:=OCTORING; T:=5OMDNO
147120          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
147123          CALL MBSEND; GO WT12
147125          GO I5OMBR
147126   RBUS
147133
147133
147133   %============================================================================
147133   %      ( M )    C O N 5 I D E N T
147133   %
147133   % Connect octobus Ident
147133   % (To be able to receive multi byte messages/kicks from the ACCP/Samson)
147133   % Send 'alive' message to the ACCP to verify that it's present
147133   % Activated from level 1 (5pit)
147133   %
147133   % Ack/Nack answer is handled by 5OMBREAD
147133   %
147133   % Entry:  B=CPU datafield
147133   %         X=working datafield
147133   %
147133   SUBR CON5IDENT
147133   INTEGER CWFIELD
147134
147134   CON5IDENT:
147134          X=:CWFIELD; T:=5STATION
147136          X:=OCTORING; N100IDENT=:D; LV12B SHZ -3
147143          CALL ECONID; GO WT12                                % Connect Octobus Ident no.
147145          % Build Octobus message
147145          5STATION=:"LMFIELD".MOCTSTATION                     % Station number
147150          OMDACCP =:        X.MOCTOMD                         % OMD number
147152          0       =:        X.MBROADCAST                      % Not broadcast
147153          7       =:        X.MMSGLENGTH                      % Message length = 1 byte
147155          CMSYSPAR SHZ 10\/N100IDENT=: X.MCOMMAND             % Send system par.
147161          CWFIELD=:B
147163          5OMDNO SHZ 10=:   X.S5
147166          0=:X.S6=:X.S7
147170          T:=5OMDNO; X:=OCTORING
147172          "LMFIELD+DPITPHYS"=:D; A:=DPITBANK
147175          CALL MBSEND; GO WT12
147177          GO I5OMBR
147200   RBUS
147206
147206
147206   %============================================================================
147206   %       M B S U S P R O C
147206   %
147206   % SUBROUTINE TO CHECK IF A PROCESS SHOULD BE SUSPENDED
147206   % BECAUSE THE SYSTEM SPENDS TOO MUCH TIME ON HIGHER INTERRUPT LEVELS
147206   % CALLED FROM MCHANDLE.
147206   % IF PROCESS IS SUSPENDED, THEN RETURN TO NXTMSG IN MAIN ND-500 DRIVER
147206   %
147206   % ENTRY:    B=ND-500 CPU DATAFIELD
147206   %           N5MESSAGE=ADDR OF ACTUAL MESSAGE
147206   %
147206   SUBR MBSUSPROC
147206   INTEGER CSUSPTIME:=10        % NUMBER OF TIMESLICE UNITS THE PROCESS WILL BE SUSPENDED
147207   MBSUSPROC:
147207          IF ATIM2-SUSPATIME>62 THEN                  % ND-500 TIMESLICER NOT ACTIVE FOR 1 SEC.
147214             SUSPSTAT; X:=N5MESSAGE; CALL WN5STATUS   % SUSPEND PROCESS
147217             CSUSPTIME; T:=5MBBANK; *AAX SUSPC; STATX; AAX -SUSPC
147224             1=:5SUSPFLAG                             % FLAG FOR TIMESLICER
147226             GO NXTMSG
147227          FI; EXIT
147230   RBUS
147237
147237
147237   %============================================================================
147237   %      G E T   T E R M I N A L    D A T A    F I E L D
147237   %
147237   % ENTRY:     X=ND-500 MESSAGE ADDR
147237   %
147237   % EXIT:      NOT TERMINAL OR TERMINAL NOT RESERVED BY CALLER.
147237   %
147237   % EXIT+1:    A=ADDR OF TERMINAL INPUT DATAFIELD
147237   %            D=ADDR OF TERMINAL OUTPUT DATAFIELD
147237   %
147237   SUBR 5GTDF
147237   INTEGER POINTER GTDFRET
147240   5GTDF:  A:=L=:"GTDFRET"
147242          T:=5MBBANK; *AAX DOUTD; LDDTX             % AD=LOGICAL DEVICE NUMBER
147245          IF A><0 GO NERET                          % ILL. LOG.DEV (MORE THAN 16 BITS)
147246          IF 1=D THEN
147251             *AAX OUTDF-DOUTD; LDXTX
147253             IF X><0 THEN
147254                T:="XDFOPP"; CALL XGTDFADDR         % A=INPUT DATAFIELD
147256                X=:D; MIN "GTDFRET"; GO GTDFRET     % D=OUTPUT DATAFIELD
147261             FI; X:=N5MESSAGE; T:=5MBBANK
147263             *AAX XADPR; LDXTX
147265             IF X:=X.RTRES><0 AND X.STATUS BIT 5BACKGR GO NERET
147272          FI; A:=D                                  % A=LOGICAL DEVICE NUMBER
147273          IF A>=100 AND A<=177 GO NERET             % ASSURE IT'S NOT A FILE WHEN CALLING LOGPH ON LEVEL 12
147301          CALL LOGPH; IF D=0 GO NERET               % NOT OUTPUTDEVICE
147304          A=:L                                      % L=INPUT DATAFIELD; D=OUTPUT DATAFIELD
147305          IF D.TYPRING NBIT 5SPLITDF GO NERET       % ERROR IF NOT TERMINAL
147311          X:=N5MESSAGE; T:=5MBBANK; *AAX XADPR; LDXTX % X=ND-100 PROGR USING ND-500 PROC
147315          IF X.RTRES><D.RTRES GO NERET              % NOT RESERVED BY ACTUAL PROCESS
147322          A:="GTDFRET":=:L                          % A=INPUT DATAFIELD; D=OUTPUT DATAFIELD
147324          EXITA                                     % SKIP RETURN
147325   NERET: X:=N5MESSAGE; GO GTDFRET
147327   RBUS
147334
147334
147334   %=============================================================================%
147334   %      I N S M O N C O
147334   %
147334   %      INSMONCO RESTARTS THE ND-500 PROCESS AFTER THE INPUT BYTES
147334   %      ARE WRITTEN TO THE DATA MEMORY IN THE QUICK INSTRING MONITOR CALL 504.
147334   %
147334   SUBR INSMONCO
147334   INSMONCO: T:=5MBBANK; *AAX SPFLA; STZTX          % CLEAR SPFLAG
147337          *AAX SMCNO-SPFLA; LDATX                   % MONITOR CALL NUMBER
147341          IF A-511=0 THEN A:=100000 ELSE A:=4 FI
147346          *AAX NUMPA-SMCNO; STATX                   % STORE WRITE BACK MASK
147350          A:=0=:D; *AAX FUNCV-NUMPA; STDTX
147354          *AAX KFLIP-FUNCV; STZTX; AAX -KFLIP
147357          3MONCO; *MICFU@3 STATX
147361          CALL MCCO
147362          CALL XACTRDY
147363          GO NXTMSG
147364   RBUS
147372
147372
147372   %============================================================================
147372   %       X M W K           N 5 W A K E
147372   % XMWK:
147372   % Started from xmsg when a message arrives on a port belonging
147372   % to nd-500 process.
147372   %
147372   % N5WAKE:
147372   % Started from monitor call handling on 5pit.
147372   %
147372   % Entry:     B = nd-500 message
147372   %
147372   SUBR XMWK,N5WAKE
147372   N5WAKE: K:=1; P+1
147374   XMWK:  K:="0"
147375          T:=5MBBANK; X:=B; *AAX XADPR; LDXTX
147401          X=:B
147402          IF K THEN
147404             CALL XNW5ST; 0/\0
147406          ELSE
147407             CALL NW5ST; P+1; CALL RTACT
147412          FI
147412          X:=MESSBUFF; CALL GCPUDF; CALL ERRFATAL; A=:B
147416          GO CALLID12
147417   RBUS
147426
147426
147426   %============================================================================
147426   %      ( M )   P 1 2 D C N
147426   %
147426   % - DRIVER LEVEL ROUTINE TO DO THE JOB
147426   SUBR P12DCN
147426   P12DCN: T:=XFDCT; * MON 2XMSG
147430          GO CALLID12; GO CALLID12
147432   RBUS
147433
147433
147433   %============================================================================
147433   %       ( M )    S T 0 P S Y S
147433   %
147433   % CONTINUATION ON MLEV OF COMMAND : STOP-SYSTEM
147433   %
147433   % TERMINATE ALL ND-500S (IF ANY) AND SIMULATE POWER FAILURE
147433   %
147433   SUBR ST0PSYS
147433   ST0PSYS: *IOF
147434           IF PN500D><0 AND 5MSINIT BIT 5INBUF THEN
147441             CALL SLOCK; GO BYPASS                        % Lock semaphore
147443             "S5CPUDF"=:B
147445             DO WHILE B<<="E5CPUDF"
147450                IF CPUAVAILABLE BIT 5ALIVE AND A/\5CPUTYPE=SAMSON THEN % CPU present?
147457                   T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
147463                   IF A><0 THEN                           % CPU active?
147464                      77; *AAX X5CLR-X5CPU; STATX         % Clear data tsb+cache+dump+forget process
147467                      CLRKICK; CALL XKICK500
147471                   FI
147471                FI
147471                B+5CPUDFSZ
147472             OD
147473             "S5CPUDF"=:B
147475             DO WHILE B<<="E5CPUDF"
147500                IF CPUAVAILABLE BIT 5ALIVE AND A/\5CPUTYPE=SAMSON THEN % CPU present?
147507                   T:=5MBBANK; X:=MAILINK; *AAX X5CPU; LDATX
147513                   IF A-MPACTIVE=0 THEN                           % CPU active?
147515                      1000-=:L
147520                      *AAX X5CLR-X5CPU
147521                      DO
147521                        *LDATX
147522                        WHILE A><0 AND L><0                 % Functions executed ?
147525                        L+1
147526                      OD
147527                      IF L=0 THEN CALL ERRFATAL FI
147532                   FI
147532                FI
147532                B+5CPUDFSZ
147533             OD
147534             FOR X:=0 TO 10000 DO D+1; A:=A+C; OD         % Delay reset-cpu
147544   BYPASS:   "RS5CPU"; *IRW LV12B DP                      % Send "reset cpu" to ACCP
147546             LV12;     *MST PID
147550             *ION
147551             FOR X:=0 TO 10000 DO D+1; A:=A+C; OD         % Delay stop-system
147561             CALL SUNLOCK
147562           FI
147562           "PPWFAIL"; *IRW LV14B DP                     % Continue in "power fail" on level 14
147564           LV14;      *MST PID
147566           *ION
147567           GO STUPR
147570   RBUS
147610
147610
147610   *"-8N500
"147610
147610   @DEV 1
147610   @DEV (S-S-L)MP-P2-DIMIR:NPL
147610   %======================================================================%
147610   %                                                                      %
147610   % ( M )   D I S K   M I R R O R I N G   C O D E                        %
147610   %                                                                      %
147610   %======================================================================%
147610
147610
147610   INTEGER ARRAY DMRMM=?        % READ ACCESS BITS
147610   INTEGER ARRAY DMWMM=?        % WRITE ACCESS BITS
147610   INTEGER ARRAY DMTYP=?        % OPERATIONS CONTROLL FLAGS
147610   INTEGER DHFLG=?              % CLUSTER HEADER FLAGS
147610   INTEGER DIMWA=?              % ADDRESS OF DIMIR WORK AREA
147610   INTEGER DMNRQ=?              % NUMBER OF UNRESERVED QUEUE ELEMENTS
147610   INTEGER DMWCP=?              % CURRENT CLUSTER UPDATE POINTER
147610   INTEGER DMWQP=?              % QUEUE POINTER FOR WRITE CLUSTER WAIT CONDITION
147610   INTEGER DMOFQ=?              % FREELIST POINTER FOR OPERATION DATAFIELDS
147610   INTEGER DMNFO=?              % NUMBER OF UNRESERVED OPERATION DATAFIELDS
147610   INTEGER DMDWQ=?              % POINTER FOR FREE DAQ WAITING QUEUE
147610   INTEGER ERMSA=?, SECNO=?, 9FLP1=?, 9FLP2=?, 9FLP3=?, 9FLP4=?
147610
147610   %====================================================================
147610   %          M T 4
147610   %
147610   % MT4 : MONITOR ENTRY ROUTINE FOR MON SYSU
147610   %
147610   SUBR DMCCU
147610
147610   INTEGER POINTER HOME
147611   DMCCU: A:=L=:"HOME"
147613   *"8DIMI
"147613          IF DMWCP><0 AND "SYUDF".RTRES=0 THEN
147620             0=:DMWCP                            % ABORT WRITE CLUSTER OPERATION
147621             "DMWQP-DLINK"; CALL DMSWQ           % START WAITING QUEUE
147623          FI
147623   *"
"147623          GO HOME
147624   RBUS
147630
147630
147630   *"8DIMI
"147630
147630   %====================================================================
147630   %     D I M I R    D I M S W    D I M S T    D I M R S    D I M E X
147630   %
147630   % DIMIR : MAIN ENTRY POINT FOR DISK MIRRORING
147630   %
147630   %    ENTRY : B = DISK DATAFIELD ADDRESS
147630   %            A = ABSTR PARAMETER LIST ADDRESS
147630   %
147630   %
147630   % DIMST : INITIALIZATION OF DIMIR AFTER WARM START
147630   %
147630   %    ENTRY : X = OPERATION DATAFIELD ADDRESS
147630   %
147630   %
147630   % DIMRS : RESTART FROM MONEN OF OPERATION AFTER WAIT CONDITION
147630   %
147630   %    ENTRY : X = OPERATION DATAFIELD ADDRESS
147630   %
147630   %
147630   % DIMEX : EXIT FROM DISK MIRRORING WHEN OPERATION FINSHED
147630   %
147630   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
147630   %
147630   %    EXIT  :
147630   %
147630   %
147630   SUBR DIMIR, DIMI2, DIMRS, DIMEX
147630
147630   DIMRS: X=:B; IF RTRES=0 GO DIMEX; GO DMRUT  % CONTINUE IF NOT ABORTED
147635
147635
147635   % INITILIAZE DIMIR
147635
147635   INTEGER POINTER DMACT:=DIMST
147636   INTEGER COUNT, CLUPN
147640
147640   DIMST: DHFLG BONE 4WSTA=:DHFLG              % INDICATE WARMSTART
147643          IF X:="DIMWD"><0 THEN CALL RTENTRY FI     % START DIMIR WATCHDOG
147646          "DMCLT-DMTL"=:CLUPN; "-NDMTE"=:COUNT % POINTER AND NUMBER OF CLUSTERS
147652          FOR COUNT DO
147652             CLUPN+"DMTL"=:CLUPN; CALL DMMST   % INITALIZE CLUSTER
147656          OD
147660          CALL DMBST                           % BUILD SEARCH TABLE
147661          "DMPOF"=:"DMACT"=:P                  % ACTIVATE MIRRORING
147664
147664
147664   INTEGER PARP, CTYP, RTPR
147667
147667   *DTRNS=*
147667   DIMIR: A=:PARP; T=:CTYP                     % SAVE PARAMETERS
147671          IF T=0 THEN
147673             L:=0; X:=RTREF=:RTPR              % FROM ABSTR
147676             IF X:=DMNFO-1<=0 THEN
147702                DIMWA=:B; X:="DUMMY"; CALL BRESERVE
147706                X:=RTPR; GO WT                 % WAIT FOR FREE OPERATION DATATFIELD
147710             FI
147710             X=:DMNFO:=DMOFQ; X.DLINK=:DMOFQ   % GET OPERATION DATAFIELD
147714             IF X=0 THEN CALL ERRFATAL FI      % GET OPERATION DATAFIELD
147717          ELSE
147720             X:=RTRES=:RTPR:="QP100".QPFSW     % FROM SWAPPER
147724          FI
147724          X:=:B=:DMCDF; A:=L=:"TRLREG"         % INITALIZE DATAFIELD
147730          0=:DMSTAT; X:=RTPR; CALL BRESERVE    % RESERVE OPERATION DATAFIELD
147733          IF A<0 THEN CALL ERRFATAL FI
147735          CALL WDATA; *IOF                     % SET CALLER TO IOWAIT
147737          X.STATUS BONE 5NOABORT=:X.STATUS; *ION
147743          IF CTYP=0 THEN
147745             PARP; CALL GAPFU                  % PARAMETERS FROM USER
147747          ELSE
147750             PARP; CALL GAPFD                  % PARAMETERS FROM DPIT
147752          FI
147752
147752   %
147752   DIMI2: 0=:DLINK=:HSTAT=:XSTAT=:DMTRG
147756          IF ABFUN=:DMORO/\74=0 THEN
147762             60\/ABFUN=:ABFUN SH -11/\7=:D     % CONVERT TO 32 BITS DISK ADDRESS
147770             ABP21:=:D; AD=:ABPA2
147773          FI
147773          ABFUN=:DMFUN; GO DMACT               % ACTIVATE MIRRORING
147776
147776   *)FILL
150025   %
150025   % COMES HERE WHEN TOTAL OPERATION IS FINISHED
150025   % ENTRY    B = OPERATION DATAFIELD ADDRESS
150025
150025   DIMEX: CALL DMEXC                           % EXIT CLUSTER
150026          IF DMSTAT BIT 6DL12 THEN
150031             *IOF                              % RETURN TO LEVEL 12
150032             DMCDF; *IRW LV12B DB              % DATAFIELD ADDRESS
150034             B=:A; *IRW LV12B DX               % QUEUE ELEMENT
150036             "TRLREG"+1; *IRW LV12B DP         % RETURN ADDRESS
150041             LV12; *MST PID                    % ENABLE LEVEL 12
150043             *ION
150044             GO MONEN
150045          FI
150045          IF X:=RTRES><0 THEN                  % IN CASE ABORTED
150047             CALL RDATA; CALL BRELEASE         % RELEASE OPERATION DATAFIELD
150051          FI
150051          IF "TRLREG"><0 THEN
150053             HSTAT; GO TRLREG                  % RETURN STATUS
150055          FI
150055          CALL DMRTF; IF X=0 GO MONEN          % RETURN OP DATAF TO FREELIST
150060          IF HSTAT BIT 4 THEN A BONE 17 ELSE A BZERO 17 FI
150066          IF X=CURPROG THEN
150071             *IRW ALEVB DA
150072          ELSE
150073             X:=X.RTDLGADDR; T:=0; *AAX DAREG; STATX
150077          FI
150077          GO STUPR
150100
150100   RBUS
150110
150110
150110   %====================================================================
150110   %              D M R T F
150110   %
150110   % DMRTF : RETURN OPERATION DATAFIELD TO FREELIST
150110   %
150110   %    ENTRY : B = OPERATION DATAFIELD
150110   %
150110   %    EXIT  : B = OPERATION DATAFIELD
150110   %
150110   %    USES T,A,D
150110   %
150110   SUBR DMRTF
150110   INTEGER POINTER HOME
150111   INTEGER SAVX
150112
150112   DMRTF: A:=L=:"HOME"; X=:SAVX
150115          DMOFQ=:DLINK; A:=B=:DMOFQ; MIN DMNFO % LINK INTO FREELIST
150122          IF DIMWA.RTRES><0 AND DMNFO>0 THEN
150130             B=:D; X=:B:=0
150133             CALL BRELEASE; D=:B               % RELEASE WAITING SEMAPHORE
150135          FI
150135          X:=SAVX; GO HOME
150137   RBUS
150143
150143
150143   %====================================================================
150143   %              D M E N C    D M E X C
150143   %
150143   % DMENC : ENTER A CLUSTER I.E. BAND UPDATE FROM MON SYSU
150143   %
150143   %    ENTRY : B = OPERATION DATAFIELD
150143   %
150143   %    EXIT  :
150143   %
150143   %    USES T,A,D,X
150143   %
150143   %
150143   % DMEXC : LEAVE A CLUSTER I.E. ALLOW UPDATE FROM MON SYSU
150143   %
150143   %    ENTRY : B = OPERATION DATAFIELD
150143   %
150143   %    EXIT  :
150143   %
150143   %    USES T,A,D,X
150143   %
150143   %
150143   SUBR DMENC, DMEXC
150143   INTEGER POINTER HOME
150144
150144   DMENC: IF X:=CLUPT=DMWCP THEN
150150             "DMWQP-DLINK"                     % MON SYSU WRITE CONDITION
150151             T:="DMCHK"; GO DMTWQ              % RESTART LATER
150153          FI
150153          MIN CLUPT.DMNOS                      % INCREASE COUNT
150155          DMSTAT BONE 6DMIR BONE 6DICL=:DMSTAT % INDICATE INSIDE
150161          EXIT
150162
150162   DMEXC: A:=L=:"HOME"
150164          IF DMSTAT BIT 6DMIR AND BIT 6DICL THEN
150171             A BZERO 6DICL=:DMSTAT             % INDICATE OUTSIDE
150173             IF CLUPT.DMCDP=B THEN
150177                0=:X.DMCDP                     % RESET CRW INDICATOR
150200                "DMCWQ-DLINK"+X; CALL DMSWQ    % RESTART WAITING QUEUE
150203             FI
150203             CLUPT.DMNOS-1=:X.DMNOS            % DECREASE COUNT
150207             IF A=0 AND X=DMWCP THEN
150213                CALL DMWCM                     % PERFORM MSYSU WRITE CLUSTER
150214             FI
150214          FI
150214          DMSTAT SHZ -16; CALL FTSRQ           % RELEASE RESERVED DAQ'S
150217          GO HOME
150220   RBUS
150230
150230
150230   %====================================================================
150230   %              F T S R Q
150230   %
150230   % FTSRQ : RELEASE RESERVED DAQ'S
150230   %
150230   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
150230   %            A = NUMBER OT RELEASE
150230   %
150230   %    USES T,A,D,X
150230   %
150230   SUBR FTSRQ
150230   INTEGER POINTER HOME
150231
150231   FTSRQ: T:=L=:"HOME"
150233          D:=A SHZ 16; T:=DMSTAT-D=:DMSTAT     % REDUCE NUMBER RESERVED
150240          IF C NBIT THEN CALL ERRFATAL FI
150243          A+DMNRQ=:DMNRQ                       % NUMBER OF UNRESERVED DAQ'S
150245          IF X:=DMDWQ><0 THEN                  % SOMEONE WAITING FOR DAQ'S
150247             IF A>=X.DMSTAT SHZ -16 THEN
150253                A-T=:DMNRQ                     % RESERVE NUMBER WANTED
150255                X:=:B; DLINK=:DMDWQ; 0=:DLINK  % REMOVE FROM QUEUE
150261                CALL RTACT; X=:B               % RESTART OPERATION
150263             FI
150263          FI
150263          GO HOME
150264   RBUS
150270
150270
150270   %====================================================================
150270   %              D M E X E
150270   %
150270   % DMEXE : START OPERATION
150270   %
150270   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
150270   %            A = MEMBER NUMBER (0=NOT CLUSTER)
150270   %
150270   %    USES T,A,D,X
150270   %
150270   SUBR DMEXE
150270
150270   DISP 14; TRIPLE PAR1,PAR2,PAR3; PSID
150270
150270   INTEGER POINTER HOME
150271   INTEGER MB, MBPT
150273   INTEGER SAVB=?
150273
150273   DMEXE: A=:MB:=L=:"HOME"; X:="QP100":=:B=:SAVB
150301          IF T:=DMDAQ=0 THEN
150304             X:=X.RTRES; *IOF                  % GET NEW DAQ
150306             CALL GETFREE; CALL ERRFATAL; *ION
150311          ELSE
150312             0=:DMDAQ                          % USE LAST DAQ
150313          FI
150313          B:=T; X:=SAVB.RTRES; CALL BRESERVE   % RESERVE QUEUE ELEMENT
150317          IF A<0 THEN CALL ERRFATAL FI
150321          X:=SAVB=:DMLINK; "CONTOP"=:"TRLREG"  % INITIALIZE QUEUE ELEMENT
150325          X.PAR1=:PAR1; X.PAR2=:PAR2; X.PAR3=:PAR3
150333          IF MB=:CLMNO><0 THEN
150336             A-1*DULEN+X.CLUPT=:MBPT           % POINTER TO CLUSTER MEMBER ENTRY
150342             A.PRDEV/\7 SHZ 6=:T               % GET UNIT
150347             ABFUN/\177077\/T=:ABFUN           % INSERT IN FUNCTION
150353             IF SAVB.DMSTAT BIT 6DADR AND MB><1 THEN
150363                X.CLUPT.PRLOE                  % BASE ADDRESS=LOWER BOUND OF EXTENSION
150365                *COPY CM2 SD DT                % 2'S COMPLEMENT
150366                *COPY ADC CM1 SA DL
150367                ABPA2                          % ABSOLUTE DISK ADDRESS
150370                *RADD SD DT                    % LT = RELATIVE DISK ADDRESS WITHIN EXTENT
150371                *RADD ADC SA DL
150372                MBPT.PRLOE                     % LOWER BOUND OF TARGET EXTENT
150374                *RADD ST DD                    % AD = NEW ABSOLUTE DISK ADDRESS
150375                *RADD ADC SL DA
150376                AD=:ABPA2                      % STORE IN COPY OF PARAM LIST
150377             FI
150377             MBPT.PRCDF                        % GET DATAFIELD ADDRESS
150401          ELSE
150402             X.DMCDF                           % USE ORIGINAL DISK DATAFIELD
150403          FI
150403          *IOF; IRW LV11B DB                   % DISK DATAFIELD
150405          A."STDRIV"; *IRW LV11B DT            % DRIVER START ADDRESS
150410          SAVB:=:B; *IRW LV11B DX              % QUEUE ELEMENT
150413          "SLV11"; *IRW LV11B DP               % LEVEL 11 START ADDRESS
150415          LV11; *MST PID; ION                  % ACTIVATE
150420          DMRWM+40000=:DMRWM                   % COUNT SUBOPERATIONS UP
150423          GO HOME
150424   *)FILL
150440
150440   % COME HERE WHEN A DISC ACCESS QUEUE ELEMENT HAS BEEN RETURNED FROM DRIVER
150440
150440   INTEGER SAVB
150441
150441   CONTOP: X=:DMDAQ                            % DAQ ADDRESS
150442          X.DMLINK=:SAVB:=:B=:X.DMLINK         % GET OPERATION DATAFIELD ADDRESS
150446          DMRWM-40000=:DMRWM                   % COUNT SUBOPERATIONS DOWN
150451          IF RTRES><0 THEN
150453             CALL DMECK; X:=DMDAQ              % CHECK FOR ERRORS
150455             IF T:=DMSTAT NBIT 6DMIR  THEN
150460                X.SSSTAT=:HSTAT                % NOT MIRRORED
150462                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
150466             ELSE
150467             IF T BIT 6DADR THEN
150471                IF 7/\T=1 THEN
150476                   CALL DMCRO                  % CONTINUE READ TYPE OPERATION
150477                ELSE
150500                IF A=2 THEN
150503                   CALL DMCWO                  % CONTINUE WRITE TYPE OPERATION
150504                ELSE
150505                   CALL DMCCO                  % CONCATENATED READ/WRITE OPERATION
150506                FI FI
150506             ELSE
150507                CALL DMCSO                     % CONTINUE SPECIAL OPERATION
150510             FI FI
150510          FI
150510          IF T:=DMDAQ><0 THEN
150513             0=:DMDAQ; "QP100"=:B; *IOF        % RELEASE QUEUE ELEMENT
150517             CALL PUTFREE; SAVB=:B; *ION
150523          FI
150523          GO DMCCK
150524   RBUS
150536
150536
150536   %====================================================================
150536   %              D M W C R     D M W C M
150536   %
150536   % DMWCA : CONTROLS WRITING OF CLUSTER ENTRY. CALLED FROM ALEV
150536   %
150536   % DMWCM : CONTROLS WRITING OF CLUSTER ENTRY. CALLED FROM MLEV
150536   %
150536   %    ENTRY :
150536   %
150536   %    EXIT  :
150536   %
150536   SUBR DMWCA, DMWCM
150536
150536   DISP SUWA=SYUWA
150536      INTEGER ARRAY DMTCOPY(0)
150536   PSID
150536
150536   INTEGER POINTER SAVL
150537
150537   DMWRC: A:=L=:"SAVL"; 0=:DMWCP
150542          IF "CLSEM".RTRES=RTRES AND CLUP.DMRFL NBIT 8DMSS THEN
150553             IF X.DMNOS=0 THEN
150555                FOR X:=0 TO "DMTLW-1" DO
150561                   DMTCOPY(X)=:CLUAP(X)        % COPY CLUSTER ENTRY BACK
150563                OD
150565                CLUP; CALL DMMST; CALL DMBST   % INITIALIZE CLUSTER
150570                0=:ZAREG                       % MARK WRITE PERFORMED
150571             ELSE
150572                X=:DMWCP                       % INDICATE WAIT CONDITION
150573             FI
150573          FI
150573          GO SAVL
150574
150574   DMWCA: "SYUDF"=:B; CLCNG=:ZAREG; CALL DMWRC % TRY TO WRITE
150601          IF DMWCP><0 THEN
150603             X:=RTRES; CALL WDATA; GO RWAIT    % SET IOWAIT
150606          FI
150606          GO MONEN
150607
150607   INTEGER SAVB
150610   INTEGER POINTER HOME
150611
150611   DMWCM: "SYUDF":=:B=:SAVB:=L=:"HOME"
150616          IF RTRES><0 THEN
150620             CALL DMWRC                        % TRY TO WRITE
150621             IF DMWCP=0 THEN
150623                X:=RTRES; CALL RDATA; 1=:MTOR  % REMOVE IOWAIT
150627             FI
150627          ELSE
150630             0=:DMWCP                          % ABORT WRITE
150631          FI
150631          IF DMWCP=0 THEN
150633             "DMWQP-DLINK"; CALL DMSWQ         % RESTART WAITING QUEUE
150635          FI
150635          A:=SAVB=:B; GO HOME
150640   RBUS
150655
150655
150655   %====================================================================
150655   %              D M S W Q
150655   %
150655   % DMSWQ : RESTART A WAITING QUEUE
150655   %
150655   %    ENTRY : A = QUEUE POINTER (OFFSET WITH "DLINK")
150655   %
150655   %    EXIT  :
150655   %
150655   SUBR DMSWQ
150655   INTEGER SAVB
150656   INTEGER POINTER HOME
150657
150657   DMSWQ: A=:X:=L=:"HOME":=B=:SAVB
150664          DO
150664             WHILE X.DLINK><0
150666             A=:B; DLINK=:X.DLINK; 0=:DLINK    % REMOVE FROM QUEUE
150672             CALL RTACT                        % RESTART OPERATION
150673          OD
150674          SAVB=:B; GO HOME
150677   RBUS
150700
150700
150700   %====================================================================
150700   %              C M P 2
150700   %
150700   % CMP2 : COMPARE TWO UNSIGNED DOUBLES
150700   %
150700   %    ENTRY : AD = DOUBLE 1
150700   %            T  = POINTER TO DOUBLE 2
150700   %
150700   %    EXIT  : A = -1 IF D1<D2
150700   %              =  0 IF D1=D2
150700   %              =  1 IF D1>D2
150700   %
150700   %    USES A,D
150700   %
150700   SUBR CMP2
150700   INTEGER SAVX
150701
150701   CMP2:  X=:SAVX:=T
150703          IF A>>X.S0 GO GT; IF A<<T GO LT      % CHECK FIRST WORD
150710          IF D>>X.S1 GO GT; IF D<<T GO LT      % CHECK SECOND WORD
150715          "0"; T:=SAVX:=:X; EXIT
150721   GT:    "1"; T:=SAVX:=:X; EXIT
150725   LT:    "-1"; T:=SAVX:=:X; EXIT
150731   RBUS
150731
150731
150731   %====================================================================
150731   %              C C L N O
150731   %
150731   % CCLNO : COMPUTE CLUSTER NUMBER GIVEN CLUSTER POINTER.
150731   %
150731   %    ENTRY : A = CLUSTER POINTER
150731   %
150731   %    EXIT  : A = CLUSTER NUMBER
150731   %
150731   %    USES T,A,D,X
150731   %
150731   SUBR CCLNO
150731   CCLNO: A-"DMCLT"=:D:=0; T:="DMTL"; *RDIV ST
150736          A+1; EXIT
150740   RBUS
150741
150741   %====================================================================
150741   %            D M C H K    D M R U N    D M C C K
150741   %
150741   %
150741   % DMPOF : ENTRY POINT TO MIRRORING
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   % DMCHK : CHECK IF REQUEST SHOULD BE MIRRORED
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %
150741   % DMRUN : RESTART POINT FROM DAQ WAITING QUEUE
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %
150741   % DMCCK : CONTINUE CHECK ON NEXT CLUSTER
150741   %
150741   %    ENTRY : B = OPERATION DATAFIELD
150741   %
150741   %    EXIT  : NO RETURN
150741   %
150741   %    USES T,A,D,X
150741   %
150741   SUBR DMPOF, DMCHK, DMRUN, DMCCK
150741
150741   INTEGER ACMSK=?
150741
150741   DMPOF: 77/\DMFUN=:X; T:="DMTYP"; *LBYT      % GET OPERATION TYPE
150746          X:=DMSTAT\/A BONE 6DMIR=:DMSTAT      % TO STATUS WORD
150752          IF X NBIT 6DMOP THEN GO NOMI FI      % NOT MIRRORED OPCODE
150755          IF 7/\X><3 AND DMFUN BIT 14 AND BIT 15 THEN
150767             ABFUN/\147777=:ABFUN              % REMOVE FORCE BITS
150772             X BONE 6DFNM=:DMSTAT; GO NOMI     % MARK FORCED NOT MIRRORED
150775          FI
150775          IF X BIT 6DADR THEN
150777             T:=ABP31-1; ABPA2                 % COMPUTE
151002             *RADD ST DD; RADD ADC DA          % HIGH ADDRESS OF DISK AREA
151004             AD=:APHDI                         % AND PLACE IN OP DATAF
151005          FI
151005          0=:DMRWM=:HSTAT
151007
151007   DMCHK: IF T:=DMSTAT BIT 6DADR THEN          % CHECK WITHIN EXTENSION
151012             DMFUN SHR -6/\7+DMCDF=:L; X:="DMFST"
151020             DO; X.DS0; WHILE A<<L; X+D; OD    % SEARCH FOR DATAFIELD/UNIT
151025             IF A>>L GO NOMI                   % NOT FOUND
151027             T:=X.S2; X+D; APHDI; CALL CMP2    % COMPARE WITH FIRST IN TABLE
151033             IF A < 0 GO NOMI                  % STRICTLY BELOW I.E. OUTSIDE
151034             DO
151034                X-1; T:=X.S0; APHDI; CALL CMP2 % COMPARE WITH LOW LIMIT OF AREA
151040                WHILE A<0                      % WHILE STRICLY BELOW
151041             OD
151042             ABPA2; T+2; CALL CMP2             % COMPARE WITH HIGH LIMIT OF AREA
151045             IF A>=0 GO NOMI                   % OUTSIDE
151046             "-DMCLT"+T=:D:=0; T=:X:=DMTL; *RDIV ST
151055             IF D>="DULEN" THEN
151060                IF DMSTAT NBIT 6DILS  GO NOMI  % LEGAL ACCESS TO SECONDARY
151063                GO ERREX                       % ILLEGAL ACCESS TO SECONDARY
151064             FI
151064             X-D=:CLUPT; *AAX DMSS0            % ACCESS TO PRIMARY
151067             DO
151067                377/\X.S0+CLUPT=:T             % ADDRESS OF NEXT AREA LOW BOUNDARY
151073                ABPA2; CALL CMP2               % COMPARE WITH ACCESS LOW BOUNDARY
151075                WHILE A>=0; X+1                % UNTIL BELOW A BOUNDARY
151077             OD
151100             APHDI; CALL CMP2                  % CHECK FOR PARTIAL OVERLAP
151102             IF A>=0 THEN                      % PARTIAL OVERLAP !!
151103   ERREX:       NOTAVAIL=:HSTAT                % ILLEGAL ACCESS TO SECONDARY
151105                ILADR; CALL DMEMS; GO DIMEX    % "ILLEGAL ACCESS TO MEMBER OR AREA"
151110             FI
151110             X.S0/\ACMSK=:DMRWM                % AREA ACCESS BITS
151113             CALL DMENC; GO MIROP              % ENTER CLUSTER
151115          FI
151115          GO DMRUN                             % SPECIAL OPERATION
151116          *)FILL
151132   NOMI:  DMSTAT BZERO 6DMIR=:DMSTAT; GO DMRUN % SET NOT MIRRORED
151136   *)FILL
151137
151137
151137   INTEGER ACMSK:=0
151140   * *-1/1@5DRM1+^; *-1/1@5DRM2+^; *-1/1@5DRM3+^    % READ BITMASK
151140   * *-1/1@5DWM1+^; *-1/1@5DWM2+^; *-1/1@5DWM3+^    % WRITE BITMASK
151140
151140   MIROP:  IF CLUPT.DMCDP><0 THEN
151143   % OPERATION MIRRORED, ADDRESS DEPENDENT AND CONCATENATED OPERATION IN PROGRESS
151143             IF 7/\DMSTAT=3 THEN
151150                "DMCWQ-DLINK"+X                % ONLY ONE A TIME
151152                T:="MIROP"; GO DMTWQ           % RESTART LATER
151154             FI
151154             X:=X.DMCDP; CALL CHKOL            % CHECK FOR OVERLAP
151156             X:=CLUPT.DMCWQ                    % START OF WATING QUEUE
151160             DO
151160                WHILE X><0                     % FOR ALL WAITING
151161                CALL CHKOL                     % CHECK FOR OVERLAP
151162                X:=X.DLINK                     % NEXT OPERATION
151163             OD
151164          FI
151164
151164   DMRUN: IF T:=DMSTAT NBIT 6DMIR THEN
151167             "1"; CALL FTSGQ                   % ENSURE THAT A DAQ IS AVAILABLE
151171             "0"; CALL DMEXE                   % NO MIRRORING NECESSARY
151173          ELSE
151174          IF T BIT 6DADR THEN
151176             IF 7/\T=1 THEN
151203                CALL DMSRO                     % START READ TYPE OPERATION
151204             ELSE
151205             IF A=2 THEN
151210                CALL DMSWO                     % START WRITE TYPE OPERATION
151211             ELSE
151212                CALL DMSCO                     % START CONCATENATED READ/WRITE
151213             FI FI
151213          ELSE
151214             CALL DMSSO                        % START SPECIAL OPERATION
151215          FI FI
151215
151215   DMCCK: IF DMRWM SHZ -16=0 THEN              % ALL SUBOPERATIONS FINISHED
151220             IF X:=RTRES><0 THEN
151222                IF DMSTAT BIT 6DMIR AND BIT 6DEMS THEN
151227                   IF HSTAT BIT 4 THEN
151232                      DTRER; CALL DMEMS        % OPERATION FAILED MESSAGE
151234                   FI
151234                FI
151234             FI
151234             GO DIMEX                          % FINSHED
151235          FI
151235          IF RTRES=RTREF GO RWAIT; GO MONEN
151242   *)FILL
151262
151262   % LOCAL ROUTINE TO CHECK FOR OVERLAPPING AREAS
151262   INTEGER POINTER LREG
151263   CHKOL: A:=L=:"LREG"
151265          T:="ABPA2"+B; X.APHDI
151270          CALL CMP2; IF A<0 GO LREG            % ABOVE AREA
151273          "ABPA2"+X=:T; APHDI
151277          CALL CMP2; IF A<0 GO LREG            % BELOW AREA
151302          "DMCWQ-DLINK"+CLUPT                  % OVERLAPPING AREAS
151304          T:="MIROP"; GO DMTWQ                 % RESTART LATER
151306   RBUS
151313
151313
151313   %====================================================================
151313   %              D M M S T
151313   %
151313   % DMMST : INITIALISE A CLUSTER AFTER STATUS CHANGE
151313   %
151313   %    ENTRY : A = POINTER TO CLUSTER ENTRY
151313   %
151313   %    EXIT  :
151313   %
151313   %    USES: T,A,D,X
151313   %
151313   SUBR DMMST
151313   INTEGER POINTER HOME
151314   INTEGER SAVB
151315
151315   DMMST: A:=:B=:SAVB:=L=:"HOME"
151321          IF DMFLG BIT 8DEUS AND BIT 8DMIR THEN
151326             A BONE 8DERR=:DMFLG; D:=0
151331
151331   % CHECK PRIMARY
151331             T:=PRFLG BZERO 9DREA BZERO 9DWRI  % ZERO READ AND WRITE FLAGS
151334             IF T NBIT 9DDIS THEN
151336                T BONE 9DWRI; D BONE 5DWM1     % CONNECTED
151340                IF PRVAL=0 THEN
151342                   T BONE 9DREA; D BONE 5DRM1  % VALID
151344                   DMFLG BZERO 8DERR=:DMFLG    % AT LEAST ONE VALID
151347                FI
151347             ELSE
151350                -1=:PRVAL                      % DISCONNECTED
151352                IF T BIT 9DCNG THEN
151354                   T BONE 9DWRI; D BONE 5DWM1  % DISCONNECT IN PROCESS
151356                FI
151356             FI
151356             T=:PRFLG
151357
151357   % CHECK SECONDARY-1
151357             T:=S1FLG BZERO 9DREA BZERO 9DWRI       % ZERO READ AND WRITE FLAGS
151362             IF S1CDF><0 THEN
151364                IF T NBIT 9DDIS THEN
151366                   T BONE 9DWRI; D BONE 5DWM2       % CONNECTED
151370                   IF S1VAL\/S1NUA=:S1VAL=0 THEN    % IN CASE ACTIVE NO UPDATE AREAS
151374                      T BONE 9DREA; D BONE 5DRM2    % VALID
151376                      DMFLG BZERO 8DERR=:DMFLG      % AT LEAST ONE VALID
151401                   FI
151401                ELSE
151402                   -1=:S1VAL                        % DISCONNECTED
151404                   IF T BIT 9DCNG THEN              % DISCONNECT IN PROCESS
151406                      T BONE 9DWRI; D BONE 5DWM2
151410                   FI
151410                FI
151410             FI
151410             T=:S1FLG
151411
151411   % CHECK SECONDARY-2
151411             T:=S2FLG BZERO 9DREA BZERO 9DWRI  % ZERO READ AND WRITE FLAGS
151414             IF S2CDF><0 THEN
151416                IF T NBIT 9DDIS THEN
151420                   T BONE 9DWRI; D BONE 5DWM3       % CONNECTED
151422                   IF S2VAL\/S2NUA=:S2VAL=0 THEN    % IN CASE ACTIVE NO UPDATE AREAS
151426                      T BONE 9DREA; D BONE 5DRM3    % VALID
151430                      DMFLG BZERO 8DERR=:DMFLG      % AT LEAST ONE VALID
151433                   FI
151433                ELSE
151434                   -1=:S2VAL                        % DISCONNECTED
151436                   IF T BIT 9DCNG THEN
151440                      T BONE 9DWRI; D BONE 5DWM3    % DISCONNECT IN PROCESS
151442                   FI
151442                FI
151442             FI
151442             T=:S2FLG
151443
151443
151443             IF DMFLG BIT 8DERR AND BIT 8DCOE THEN
151450                IF X:=3/\A >< 0 THEN
151453                   DMRMM(X)\/DMWMM(X); D\/A    % USE PASSTHROUGH
151456                FI
151456             ELSE
151457                A/\177770=:DMFLG               % NO PASSTHROUGH
151461             FI
151461
151461             CALL BUSST                        % BUILD SEARCH TABLE
151462          FI
151462          SAVB=:B; GO HOME
151465   *)FILL
151471
151471   % LOCAL ROUTINE TO BUILD CLUSTER SEARCH TABLE (D = ACCESSBITS)
151471
151471   INTEGER MAXEL, COUNT, NNUA, SAVD, ACCBT
151476   INTEGER POINTER SAVL1
151477
151477   BUSST: A:=D=:ACCBT:=L=:"SAVL1"
151503   %
151503   % INSERT PRIMARY EXTENT
151503          "PRLOE"\/D=:DMSST(0)                 % LOW EXTENT
151507          "PRHIE"\/D=:DMSST(1)                 % HIGH EXTENT
151513          1=:MAXEL                             % MAX ELEMENT
151515   %
151515   % INSERT EXTENT OF NO UPDATE AREAS
151515          "-NNUAC"=:COUNT; 0=:NNUA
151520          FOR COUNT DO
151520             ACCBT=:D                          % ORIGINAL BITMASK TO D
151522             NNUA SHZ 3; *ADD (BLDA 10 DT      % BIT LOAD INSTRUCTION
151525             T:=S1NUA; *EXR SA                 % SECONDARY-1 ENABLE BIT TO K
151527             IF K THEN D BZERO 5DRM2 BZERO 5DWM2 FI
151533             T:=S2NUA; *EXR SA                 % SECONDARY-2 ENABLE BIT TO K
151535             IF K THEN D BZERO 5DRM3 BZERO 5DWM3 FI
151541             IF T:=ACCBT><D THEN
151544                NNUA SHZ 2+"DMNUA"; T\/A; A+2\/D=:SAVD
151553                T=:A; CALL SORT1               % LOW BOUNDARY
151555                SAVD; CALL SORT2               % HIGH BOUNDARY
151557             FI
151557             MIN NNUA                          % NEXT AREA
151560          OD
151562          GO SAVL1
151563   *)FILL
151571
151571   % LOCAL ROUTINE TO SORT IN A BOUNDARY AND SET ACCESS BITS
151571
151571   INTEGER NEXT, SAVE
151573   INTEGER POINTER SAVL2
151574
151574   SORT1: 0=:NEXT
151575   SORT2: A=:SAVE:=L=:"SAVL2"
151600          X:=NEXT                              % START INDEX
151601          DO
151601             WHILE X<=MAXEL
151604             DMSST(X)/\377+B=:T                % CURRENT BOUNDARY
151610             377/\SAVE+B; X=:L; A.DS0; X:=L    % BOUNDARY TO SORT
151617             CALL CMP2; WHILE A>0              % GREATER THAN CURRENT
151622             SAVE\/377/\DMSST(X)=:DMSST(X)     % NEW ACCESS BITS
151626             X+1                               % NEXT ELEMENT
151627          OD
151630          X=:T+1=:NEXT
151633          IF X:=MAXEL>=T THEN
151636             IF A<0 THEN
151637                X:="2*NNUAC"; MIN MAXEL        % COPY TABLE ONE POSITION UP
151641                DO WHILE X>=T
151643                   DMSST(X); X+1               % COPY ENTRY
151645                   A=:DMSST(X); X-2            % ONE POSITION UP
151647                OD
151650             FI
151650             DMSST(T)\/377/\SAVE=:DMSST(X)     % NEW ACCESS BITS
151655          FI
151655          GO SAVL2
151656   RBUS
151660
151660
151660   %====================================================================
151660   %              D M B S T
151660   %
151660   % DMBST : BUILD FAST SEARCH TABLE
151660   %
151660   %    ENTRY :
151660   %
151660   %    EXIT  :
151660   %
151660   %    USES: T,A,D,X
151660   %
151660   SUBR DMBST
151660
151660   INTEGER POINTER HOME
151661   INTEGER LOOP, COUNT, SAVB
151664
151664   INTEGER NEXT=?
151664
151664   DMBST: "DMCLT":=:B=:SAVB:=L=:"HOME"
151671          X:="DMFST"=:NEXT; -1=:X.S0           % INITIALIZE TABLE
151675          "-NDMTE"=:LOOP
151677          FOR LOOP DO
151677             "NDMTE"+LOOP*DMTL+"DMCLT"=:B      % CLUSTER POINTER
151704             IF DMFLG BIT 8DMIR THEN
151707                17/\PRDEV+PRCDF; CALL NWEL     % MIRRORING ENABLED
151713                -2=:COUNT
151715                FOR COUNT DO
151715                   B+DULEN                     % NEXT MEMBER
151716                   IF PRFLG BIT 9DWRI THEN
151721                      17/\PRDEV+PRCDF; CALL NWEL
151725                   FI
151725                OD
151727             FI
151727          OD
151731          A:=SAVB=:B; GO HOME
151734
151734   INTEGER POINTER LREG
151735   INTEGER NEXT
151736   INTEGER SAVX
151737
151737   NWEL:  A=:T:=L=:"LREG"; X:="DMFST"
151743          DO; X.DS0; WHILE A<<T; X+D; OD       % SEARCH FOR DATAFIELD/UNIT
151750          IF A>>T THEN
151752             CALL INSW; X+1                    % NEW DATAFIELD/UNIT
151754             T:=3; CALL INSW; X+1              % NEW AREA COUNT
151757          ELSE
151760             MIN X.S1; X=:SAVX+D; *LDT ,X -1   % INCREASE AREA COUNT
151764             PRLOE; CALL CMP2
151766             IF A<0 THEN                       % NEW AREA BELOW LAST IN TABLE ?
151767                X:=SAVX+2                      % YES
151771                DO
151771                   PRLOE; T:=X.S0; CALL CMP2   % COMPARE WITH CURRENT
151774                   WHILE A>0; X+1              % WHILE ABOVE
151777                OD
152000             FI
152000          FI
152000          T:="PRLOE"+B; CALL INSW              % INSERT AREA
152003          GO LREG
152004
152004   % INSERT T IN TABLE, X=POSITION
152004   INSW:  X=:D:=NEXT+1=:NEXT                   % NEXT INDEX
152010          DO
152010             X-1; X.S0=:X.S1                   % MOVE ENTRY 1 POSITION UP
152013             WHILE X><D                        % UNTIL WANTED POSITION
152015          OD
152016          T=:X.S0; EXIT
152020   RBUS
152034
152034
152034   %====================================================================
152034   %                  D M T W Q
152034   %
152034   % DMTWQ : INSERT A DATAFIELD IN A WAITING QUEUE
152034   %
152034   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152034   %            A = QUEUE POINTER (OFFSET WITH "DLINK")
152034   %            T = RESTART ADDRESS
152034   %
152034   SUBR DMTWQ
152034
152034   DMTWQ: T=:"DMRUT"                           % SAVE RESTART ADDRESS
152035          DO; A=:X; WHILE X.DLINK><0; OD       % GET END OF QUEUE
152041          A:=B=:X.DLINK; 0=:DLINK              % INSERT AT END
152044          IF RTRES=RTREF GO RWAIT; GO MONEN
152051   RBUS
152054
152054
152054   %====================================================================
152054   %              F T S G Q
152054   %
152054   % FTSGQ : RESERVE A NUMBER DAQ'S
152054   %
152054   %    ENTRY : B = OPERATION DATAFIELD
152054   %            A = NUMBER OF DAQ'S WANTED
152054   %
152054   %    EXIT  : B = OPERATION DATAFIELD
152054   %            NO RETURN IF NOT ENOUGH DAQ'S
152054   %
152054   % USES T,A,D,X
152054   %
152054   SUBR FTSGQ
152054   INTEGER NODAQ
152055
152055   FTSGQ: A=:NODAQ
152056          IF T:=DMSTAT SHZ -16=0 THEN
152062             A SHZ 16\/DMSTAT=:DMSTAT          % INSERT NUMBER WANTED
152065             IF DMNRQ-NODAQ<0 OR T:=DMDWQ><0 THEN
152073                "DMDWQ-DLINK"
152074                T:="DMRUN"; GO DMTWQ           % RESTART LATER
152076             FI
152076             A=:DMNRQ                          % INDICATE RESERVED
152077          FI
152077          EXIT
152100   RBUS
152105
152105
152105   %====================================================================
152105   %              D M E M S
152105   %
152105   % DMEMS : GIVE ERRORMESSAGE
152105   %
152105   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152105   %            A = ERROR CODE
152105   %
152105   %    USES T,A,D,X
152105   %
152105   SUBR DMEMS
152105   INTEGER POINTER HOME
152106
152106   DMEMS: A=:SECNO:=L=:"HOME"                  % ERROR CODE
152111          CLUPT; CALL CCLNO; A=:9FLP1          % CLUSTER NUMBER
152114          DMORO=:9FLP2                         % ORIGINAL FUNCTION
152116          IF X:=RTRES="RWRT1" THEN
152122             X:="DF1".RTRES
152124          ELSE
152125          IF X="RWRT2" THEN
152130             X:="DF2".RTRES
152132          FI FI
152132          CALL 9FLEX(ERMSA,3)                  % SEND ERROR MESSAGE THROUGH 9FLEA
152135          GO HOME
152136   RBUS
152147
152147
152147   %====================================================================
152147   %              D M E C K
152147   %
152147   % DMECK : DO ERROR CHECKING FOR DISK MIRRORING
152147   %
152147   %    ENTRY : B = OPERATION DATAFIELD ADDRESS
152147   %            X = DAQ
152147   %
152147   %    EXIT  :
152147   %
152147   %    USES T,A,D,X
152147   %
152147   SUBR DMECK
152147   INTEGER POINTER HOME
152150   INTEGER MBPT, DAQ, VALFL
152153
152153   DMECK: A:=L=:"HOME"; X=:DAQ
152156          IF X.SSSTAT BIT 4 THEN
152161             IF DMSTAT BIT 6DDCN AND BIT 6DICL THEN
152166   %
152166   % DISCONNECT MEMBER
152166                X.CLMNO-1*DULEN+CLUPT=:MBPT         % POINTER TO MEMBER ENTRY
152173                IF MBPT.PRFLG NBIT 9DDIS THEN
152177                   X.PRFLG BONE 9DDIS BONE 9DCNG=:X.PRFLG
152203                   X.PRVAL=:VALFL                   % SAVE VALIDFLAG
152205                   CLUPT.DMRFL BONE 8DMSS=:X.DMRFL  % INDICATE CHANGED CLUSTER ENTRY
152211                   A:=X; CALL DMMST; CALL DMBST     % UPDATE CLUSTER ENTRY
152214                   MBDCN=:SECNO                     % "MEMBER DISCONNECTED"
152216                   CLUPT; CALL CCLNO; A=:9FLP1      % CLUSTER NUMBER
152221                   DAQ.CLMNO=:9FLP2                 % MEMBER NUMBER
152224                   X.SSSTAT=:9FLP3                  % HARDWARE STATUS
152226                   X.DMTRG=:9FLP4                   % DRIVER T-REGISTER
152230                   X:=0; CALL 9FLEX(ERMSA,5)
152234                   IF VALFL=0 THEN                  % CHECK IF BE LAST VALID
152236                      CLUPT.DMFLG/\177770\/DAQ.CLMNO=:CLUPT.DMFLG
152245                      IF X.PRFLG\/X.S1FLG\/X.S2FLG NBIT 9DREA THEN
152252                         NOVALMB=:SECNO             % "NO VALID MEMBER IN CLUSTER"
152254                         A:=X; CALL CCLNO; A=:9FLP1 % CLUSTER NUMBER
152257                         X:=0; CALL 9FLEX(ERMSA,2)
152263                      FI
152263                   FI
152263                   DHFLG BONE 4DISC=:DHFLG          % WARN DIMWD
152266                   IF X:="DIMWD"><0 THEN
152270                      CALL RTENTRY                  % START DIMIR WATCH DOG
152271                   ELSE
152272                      ILDWD=:SECNO                  % "DIMIR WATCH DOG NOT RUNNING"
152274                      CLUPT; CALL CCLNO; A=:9FLP1   % CLUSTER NUMBER
152277                      DAQ.CLMNO=:9FLP2              % MEMBER NUMBER
152302                      X:=0; CALL 9FLEX(ERMSA,3)
152306                   FI
152306                FI
152306             FI
152306          FI
152306          GO HOME
152307   RBUS
152330
152330
152330   %====================================================================
152330   %              D M S R O    D M C R O
152330   %
152330   % DMSRO : START A READ/READ PARITY/COMPARE OPERATION ON A CLUSTER
152330   %
152330   %    ENTRY : B = OPERATION DATAFIELD
152330   %
152330   %    EXIT  :
152330   %
152330   %
152330   % DMCRO : CONTINUE A READ/READ PARITY/COMPARE OPERATION ON A CLUSTER
152330   %
152330   %    ENTRY : B = OPERATION DATAFIELD
152330   %            X = DAQ OF LAST SUBOPERATION FINISHED
152330   %
152330   %    EXIT  :
152330   %
152330   %    USES T,A,D,X
152330   %
152330   SUBR DMSRO, DMCRO
152330
152330   %
152330   % AUXILLARY RUTINE TO DETERMINE WITCH MEMBER TO READ FROM
152330
152330   DISP 0
152330       INTEGER HTAB0=HTABL
152330   PSID
152330
152330   INTEGER POINTER SAVL
152331   INTEGER SAVX, SMBNO, SECPT, PUND1, PUND2, TEMP
152337
152337   DMREA: A:=L=:"SAVL"; 0=:X=:SMBNO
152343          IF T:=DMRWM BIT 5DRM1 THEN
152346             1=:SAVX
152350             IF CLUPT.DMFLG BIT 8DRDE THEN
152354                X+DULEN
152355                IF T BIT 5DRM2 THEN
152357                   2=:SMBNO
152361                ELSE
152362                IF T BIT 5DRM3 THEN
152364                   X+DULEN
152365                   3=:SMBNO
152367                FI FI
152367                X=:SECPT
152370             FI
152370
152370             IF SMBNO><0 THEN
152372   %
152372   % WE NOW HAVE A CHOICE WHETHER TO READ FROM PRIMARY OR SECONDARY 1
152372                IF CLUPT.DMFLG BIT 8DRDB THEN
152376                   T:="DMRDB"+X; ABPA2; CALL CMP2
152402                   IF A<0 THEN SMBNO=:SAVX FI  % DISK ADDRESS BELOW BOUNDARY
152405                ELSE
152406   %
152406   % WE NOW HAVE A CHOICE WHETHER TO READ FROM PRIMARY OR SECONDARY 1
152406                   17/\SECPT.PRDEV+X.PRCDF=:TEMP
152413                   T:=A.PUND0=:PUND2           % SECONDARY UNIT DATAFIELD
152416                   X:=CLUPT.DMDFU.PUND0=:PUND1 % PRIMARY UNIT DATAFIELD
152422                   IF X.SUNOP > T.SUNOP THEN
152427                      SMBNO=:SAVX              % USE SECONDARY
152431                   FI
152431                FI
152431             FI
152431             X:=SAVX
152432          ELSE
152433          IF T BIT 5DRM2 THEN
152435             X:=2                              % USE SECONDARY-1
152436          ELSE
152437          IF T BIT 5DRM3 THEN
152441             X:=3                              % USE SECONDARY-2
152442          FI FI FI
152442          DMRMM(X)-,/\DMRWM=:DMRWM             % RESET ACCESSABLE BIT
152446          GO SAVL
152447   *)FILL
152452
152452
152452   INTEGER MB
152453   INTEGER POINTER HOME
152454
152454   DMSRO: A:=L=:"HOME"
152456          CALL FAR DMREA                       % GET MEMBER
152457   %
152457   % START OPERATION IF POSSIBLE
152457          IF X=:MB><0 THEN
152461             "1"; CALL FTSGQ                   % ASSURE THAT A BUFFER IS PRESENT
152463             MB; CALL DMEXE                    % START OPERATION
152465          ELSE
152466             NOTAVAIL=:HSTAT                   % NO MEMBER AVAILABLE
152470          FI
152470          GO HOME
152471
152471
152471   INTEGER DAQ
152472
152472   DMCRO: A:=L=:"HOME"; X=:DAQ
152475          IF X.SSSTAT BIT 4 THEN
152500             IF HSTAT=0 OR X.CLMNO=1 THEN
152506                X.SSSTAT=:HSTAT                % SET STATUS
152510                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152514             FI
152514             CALL FAR DMREA                    % TRY AGAIN
152515             IF X><0 THEN A:=X; CALL DMEXE FI
152520          ELSE
152521             A=:HSTAT                          % OK STATUS
152522          FI
152522          GO HOME
152523   RBUS
152526
152526
152526   %====================================================================
152526   %              D M S W O    D M C W O
152526   %
152526   % DMSWO : START A WRITE OPERATION ON A CLUSTER
152526   %
152526   %    ENTRY : B = OPERATION DATAFIELD
152526   %
152526   %    EXIT  :
152526   %
152526   %
152526   % DMCWO : CONTINUE A WRITE OPERATION
152526   %
152526   %    ENTRY : B = OPERATION DATAFIELD
152526   %            X = DAQ OF LAST SUBOPERATION
152526   %
152526   %    EXIT  :
152526   %
152526   %    USES T,A,D,X
152526   %
152526   SUBR DMSWO, DMCWO
152526   INTEGER POINTER HOME
152527
152527   DMSWO: A:=L=:"HOME"
152531   %
152531   % FIRST CHECK ALL MEMBERS AND DETERMINE NUMBER OF DAQ'S REQUIRED
152531          D:=0
152532          IF DMRWM BIT 5DWM1 THEN D+1 FI       % CHECK IF WRITE TO MEMBER 1
152536          IF A BIT 5DWM2 THEN D+1 FI           % CHECK IF WRITE TO MEMBER 2
152541          IF A BIT 5DWM3 THEN D+1 FI           % CHECK WRITE TO MEMBER 3
152544          IF D > 0 THEN
152546             A:=D; CALL FTSGQ                  % MAKE SURE ENOUGH BUFFERS ARE PRESENT
152550             IF DMRWM BIT 5DWM1 THEN "1"; CALL DMEXE FI
152555             IF DMRWM BIT 5DWM2 THEN "2"; CALL DMEXE FI
152562             IF DMRWM BIT 5DWM3 THEN "3"; CALL DMEXE FI
152567          ELSE
152570             NOTAVAIL=:HSTAT                   % NO MEMBER AVAILABLE
152572          FI
152572          GO HOME
152573
152573
152573   DMCWO: A:=L=:"HOME"
152575          IF X.SSSTAT BIT 4 THEN
152600             IF HSTAT=0 THEN
152602                X.SSSTAT=:HSTAT                % SET STATUS
152604                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152610             ELSE
152611             IF HSTAT BIT 4 AND X.CLMNO=1 THEN
152620                X.SSSTAT=:HSTAT                % SET STATUS
152622                X.XSTAT=:XSTAT; X.DMTRG=:DMTRG
152626             FI FI
152626          ELSE
152627             A=:HSTAT
152630          FI
152630          1; CALL FTSRQ                        % RELEASE DAQ
152632          GO HOME
152633   RBUS
152636
152636   %====================================================================
152636   %              D M S C O    D M C C O
152636   %
152636   % DMSCO : START A CONCATENATED OPERATION
152636   %
152636   %    ENTRY : B = OPERATION DATAFIELD
152636   %
152636   %    EXIT  :
152636   %
152636   % DMCCO : CONTINUE A CONCATENATED OPERATION
152636   %
152636   %    ENTRY : B = OPERATION DATAFIELD
152636   %            X = DAQ OF LAST SUBOPERATION FINISHED
152636   %
152636   %    EXIT  :
152636   %
152636   %    USES T,A,D,X
152636   %
152636   SUBR DMSCO, DMCCO
152636   INTEGER POINTER HOME=?
152636   INTEGER FMASK=?
152636   INTEGER MB
152637
152637   DMSCO: A:=L=:"HOME"; X:=CLUPT
152642          A:=B=:X.DMCDP                        % INDICATE CONCATENATED OPERATION IN PROGRESS
152644          L:=0; A:="0" BONE 9DCRW; T:=DMFUN
152650          IF T BIT 7RWM1 THEN L+1; A/\X.PRFLG FI
152654          IF T BIT 7RWM2 THEN L+1; A/\X.S1FLG FI
152660          IF T BIT 7RWM3 THEN L+1; A/\X.S2FLG FI
152664          IF A=:D:=77/\T=64 THEN
152672             X.DMWFL                           % CONCATENATED READ MEMBER
152673             IF D NBIT 9DCRW THEN "0" FI       % NO WRITE MEMBER SPECIFIED
152676          ELSE
152677             DMFUN SHZ -14                     % COMPARE FROM MEMBER
152701          FI
152701          X:=3/\A                              % FROM MEMBER
152703          IF DMRMM(X)/\DMRWM><0 AND DMFUN/\FMASK><0 THEN
152711             X=:MB; A:=L; CALL FTSGQ           % RESERVE DAQ'S
152714             DMFUN/\140000+66=:ABFUN           % INDICATE READ, DON'T CLEAR CACHE
152720             MB; CALL DMEXE                    % START OPERATION
152722          ELSE
152723             NOTAVAIL=:HSTAT                   % MEMBER NOT AVAILABLE
152725          FI
152725          GO HOME
152726
152726
152726   INTEGER POINTER HOME
152727   INTEGER FMASK:=0; * *-1/1@7RWM1; *-1/1@7RWM2+^; *-1/1@7RWM3+^
152730
152730   DMCCO: A:=L=:"HOME"
152732          IF X.SSSTAT BIT 4 THEN
152735             IF HSTAT >< -1 THEN
152741                IF A NBIT 4 OR A/\7>X.CLMNO THEN
152747                   X.SSSTAT/\177770\/X.CLMNO=:HSTAT % SET MEMBER IN HSTAT
152753                FI
152753             FI
152753          FI
152753
152753          IF 77/\ABFUN=66 OR =60 THEN
152763             IF HSTAT NBIT 4 THEN
152766   %
152766   % SET NEW FUNCTION FOR ABSTR
152766                IF 77/\DMFUN=64 THEN
152773                   DMFUN/\140000+61=:ABFUN     % WRITE
152777                ELSE
153000                   DMFUN/\140000+63=:ABFUN     % COMPARE
153004                FI
153004   %
153004   % CHECK MEMBER 1
153004                IF DMFUN BIT 7RWM1 THEN
153007                   IF DMRWM BIT 5DWM1 THEN
153012                      DMFUN BZERO 7RWM1=:DMFUN % INDICATE STARTED
153015                      "1"; CALL DMEXE          % ON MEMBER 1
153017                   ELSE
153020                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153022                   FI
153022                FI
153022   %
153022   % CHECK MEMBER 2
153022                IF DMFUN BIT 7RWM2 THEN
153025                   IF DMRWM BIT 5DWM2 THEN
153030                      DMFUN BZERO 7RWM2=:DMFUN % INDICATE STARTED
153033                      "2"; CALL DMEXE          % ON MEMBER 2
153035                   ELSE
153036                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153040                   FI
153040                FI
153040   %
153040   % CHECK MEMBER 3
153040                IF DMFUN BIT 7RWM3 THEN
153043                   IF DMRWM BIT 5DWM3 THEN
153046                      DMFUN BZERO 7RWM3=:DMFUN % INDICATE STARTED
153051                      "3"; CALL DMEXE          % ON MEMBER 3
153053                   ELSE
153054                      NOTAVAIL=:HSTAT          % NOT AVAILABLE
153056                   FI
153056                FI
153056
153056                0=:CLUPT.DMCDP                 % ALLOW OTHER OPERATIONS
153060                "DMCWQ-DLINK"+X; CALL DMSWQ    % START WAIT QUEUE
153063             FI
153063          ELSE
153064             1; CALL FTSRQ                     % RELEASE DAQ
153066          FI
153066          GO HOME
153067   RBUS
153100
153100
153100   %====================================================================
153100   %              D M S S O    D M C S O
153100   %
153100   % DMSSO : START A SPECIAL OPERATION
153100   %
153100   %    ENTRY : B = OPERATION DATAFIELD
153100   %
153100   %    EXIT  :
153100   %
153100   % DMCSO : CONTINUE SPECIAL OPERATION
153100   %
153100   %    ENTRY : B = OPERATION DATAFIELD
153100   %            X = DAQ OF LAST SUBOPERATION FINISHED
153100   %
153100   %    EXIT  :
153100   %
153100   %    USES T,A,D,X
153100   %
153100   SUBR DMSSO, DMCSO
153100   INTEGER POINTER HOME
153101   INTEGER DMODU
153102
153102   DMSSO: A:=L=:"HOME"
153104          "1"; CALL FTSGQ                      % ENSURE ONE DAQ
153106          0=:DMLDU; GO FELLS
153110
153110   DMCSO: A:=L=:"HOME"
153112
153112   FELLS: IF -1><DMLDU THEN
153116             X:="DMFST"                        % POINTER TO SEARCH TABLE
153117             DO
153117                X.DS0; WHILE A<<=T; X+D        % SKIP PREVIOUS TREATED ELEMENTS
153123             OD
153124             DMFUN SHR -6/\7+DMCDF=:DMODU      % ORIGINAL DATAFIELD/UNIT
153131             DO
153131                X.DS0; WHILE A=:DMLDU<<-1
153136                IF A><DMODU THEN
153141                   D+X=:L; X+2
153144                   DO
153144                      "-DMCLT"+X.S0=:D:=0      % OFFSET WITHIN CLUSTER TABLE
153150                      T:="DMTL"; *RDIV ST      % OFFSET WITHIN CLUSTER ENTRY
153152                      IF D>=DULEN THEN
153155                         X.S0-D=:CLUPT         % CLUSTER POINTER
153160                         X:=:A:=X.DMDFU:=:A    % PRIMARY DATAFIELD/UNIT
153163                         IF A-DMODU=0 THEN
153165                            *RDIV ST           % CALCULATE MEMBER NUMBER
153166                            A+1; CALL DMEXE    % EXECUTE OPERATION
153170                            GO HOME
153171                         FI
153171                      FI
153171                      WHILE X+1><L
153174                   OD
153175                ELSE
153176                   X+D                         % THIS IS ORIGINAL, SKIP IT
153177                FI
153177             OD
153200             DMORO=:ABFUN; "0"; CALL DMEXE     % START ORIGINAL OPERATION
153204          ELSE
153205             0=:HSTAT                          % FINISHED, RETURN OK STATUS
153206          FI
153206          GO HOME
153207   RBUS
153214   *"
"153214   @DEV 1
153214   @EOF
153214
% MP-P2-DIGIO:MAC
153214  "
153214  )LINE

153214  %==============================================================================
153214  % IDENT CODE TABLES
153214
153214  %==============================================================================
153214  % 42.13      I T B 1 0
153214  %
153214  ITB10, DT01W
153215  "8PUN1
153215  ITB10+1/DPNCH
153216  "8LP1
153216  ITB10+2/DLPR
153217  "8DLP1+8DVE1;ITB10+2/DMLP1
153217  "8SMO1
153217  ITB10+3/UDMO1
153220  "8SMO2
153220  ITB10+13/UDMO2
153230  "8LP2
153230  ITB10+22/DLPR2
153237  "8DLP2+8DVE2
153237  ITB10+22/DMLP2
153237  "8TR5 -9SMO1
153237  ITB10+43/DT05W
153260  "8TR6
153260  ITB10+44/DT06W
153261  "8TR7
153261  ITB10+45/DT07W
153262  "8TR8
153262  ITB10+46/DT08W
153263  "8TR9 -9SMO2
153263  ITB10+47/DT09W
153264  "8TR10
153264  ITB10+50/DT10W
153265  "8TR11
153265  ITB10+51/DT11W
153266  "8TR12
153266  ITB10+52/DT12W
153267  "8TR13 -9SMO3
153267  ITB10+53/DT13W
153270  "8TR14
153270  ITB10+54/DT14W
153271  "8TR15
153271  ITB10+55/DT15W
153272  "8TR16
153272  ITB10+56/DT16W
153273  "8TR17 -9SMO4
153273  ITB10+57/DT17W
153274  "8TR18
153274  ITB10+60/DT18W
153275
153275  "8TR19
153275  ITB10+61/DT19W
153276  "8TR20
153276  ITB10+62/DT20W
153277  "8TR21 -9SMO5
153277  ITB10+63/DT21W
153300  "8TR22
153300  ITB10+64/DT22W
153301  "8TR23
153301  ITB10+65/DT23W
153302  "8TR24
153302  ITB10+66/DT24W
153303  "8TR25 -8SMO9
153303  ITB10+67/DT25W
153304  "8TR26
153304  ITB10+70/DT26W
153305  "8TR27
153305  ITB10+71/DT27W
153306  "8TR28
153306  ITB10+72/DT28W
153307  "8TR29 -9SMO6
153307  ITB10+73/DT29W
153310  "8TR30 -9SMO7
153310  ITB10+74/DT30W
153311  "8TR31
153311  ITB10+75/DT31W
153312  "8TR32
153312  ITB10+76/DT32W
153313  "
153313  ITB10+117/DT01W              % 120 - TERM. 1, FOR MULTITERM INTERF.
153334  "8TR33;ITB10+123/DT33W
153340  "8TR34;ITB10+124/DT34W
153341  "8TR35 -8SMO7;ITB10+125/DT35W
153342  "8TR36 -8SMO8;ITB10+126/DT36W
153343  "8TR37 -8SMO9;ITB10+127/DT37W
153344  "8TR38 -9SMO1;ITB10+130/DT38W
153345  "8TR39 -9SMO2;ITB10+131/DT39W
153346  "8TR40 -9SMO3;ITB10+132/DT40W
153347  "8TR41 -9SMO4;ITB10+133/DT41W
153350  "8TR42 -9SMO5;ITB10+134/DT42W
153351  "8TR43 -9SMO6;ITB10+135/DT43W
153352  "8TR44 -9SMO7;ITB10+136/DT44W
153353  "8TR45;ITB10+137/DT45W
153354  "8TR46;ITB10+140/DT46W
153355  "8TR47;ITB10+141/DT47W
153356  "8TR48;ITB10+142/DT48W
153357  "8TR49;ITB10+143/DT49W
153360  "8TR50;ITB10+144/DT50W
153361  "8TR51;ITB10+145/DT51W
153362  "8TR52;ITB10+146/DT52W
153363  "
153363  MAX10=*-ITB10
153363
153363
153363
153363  %==============================================================================
153363  % 42.15      I T B 1 2
153363  %
153363  ITB12, DT01R
153364  "8SMO1
153364  ITB12+3/IDMO1
153367  "8SMO2
153367  ITB12+13/IDMO2
153377  "8CP51
153377  ITB12+15/5CPU1
153401  "8CP53
153401  ITB12+35/5CPU3
153421  "8TR5 -9SMO1
153421  ITB12+43/DT05R
153427  "
153427  "8TR6
153427  ITB12+44/DT06R
153430  "8TR7
153430  ITB12+45/DT07R
153431  "8TR8
153431  ITB12+46/DT08R
153432  "8TR9 -9SMO2
153432  ITB12+47/DT09R
153433  "8TR10
153433  ITB12+50/DT10R
153434  "8TR11
153434  ITB12+51/DT11R
153435  "8TR12
153435  ITB12+52/DT12R
153436  "8TR13 -9SMO3
153436  ITB12+53/DT13R
153437  "8TR14
153437  ITB12+54/DT14R
153440  "8TR15
153440  ITB12+55/DT15R
153441  "8TR16
153441  ITB12+56/DT16R
153442  "8TR17 -9SMO4
153442  ITB12+57/DT17R
153443  "8TR18
153443  ITB12+60/DT18R
153444  "8TR19
153444  ITB12+61/DT19R
153445  "8TR20
153445  ITB12+62/DT20R
153446  "8TR21 -9SMO5
153446  ITB12+63/DT21R
153447  "8TR22
153447  ITB12+64/DT22R
153450  "8TR23
153450  ITB12+65/DT23R
153451  "8TR24
153451  ITB12+66/DT24R
153452  "8TR25 -8SMO9
153452  ITB12+67/DT25R
153453  "8TR26
153453  ITB12+70/DT26R
153454  "8TR27
153454  ITB12+71/DT27R
153455  "8TR28
153455  ITB12+72/DT28R
153456  "8TR29 -9SMO6
153456  ITB12+73/DT29R
153457  "8TR30 -9SMO7
153457  ITB12+74/DT30R
153460  "8TR31
153460  ITB12+75/DT31R
153461  "8TR32
153461  ITB12+76/DT32R
153462  "8CP54
153462  ITB12+113/5CPU4
153477  "8CP52
153477  ITB12+115/5CPU2
153501  "
153501  ITB12+117/DT01R
153503  "8TR33;ITB12+123/DT33R
153507  "8TR34;ITB12+124/DT34R
153510  "8TR35 -8SMO7;ITB12+125/DT35R
153511  "8TR36 -8SMO8;ITB12+126/DT36R
153512  "8TR37 -8SMO9;ITB12+127/DT37R
153513  "8TR38 -9SMO1;ITB12+130/DT38R
153514  "8TR39 -9SMO2;ITB12+131/DT39R
153515  "8TR40 -9SMO3;ITB12+132/DT40R
153516  "8TR41 -9SMO4;ITB12+133/DT41R
153517  "8TR42 -9SMO5;ITB12+134/DT42R
153520  "8TR43 -9SMO6;ITB12+135/DT43R
153521  "8TR44 -9SMO7;ITB12+136/DT44R
153522  "8TR45;ITB12+137/DT45R
153523  "8TR46;ITB12+140/DT46R
153524  "8TR47;ITB12+141/DT47R
153525  "8TR48;ITB12+142/DT48R
153526  "8TR49;ITB12+143/DT49R
153527  "8TR50;ITB12+144/DT50R
153530  "8TR51;ITB12+145/DT51R
153531  "8TR52;ITB12+146/DT52R
153532  "8C1HD;ITB12+147/HDOF1
153533  "8HMO1;ITB12+147/UDHM1
153533  "8C2HD;ITB12+150/HDOF2
153534  "8HMO2;ITB12+150/UDHM2
153534  "8C3HD;ITB12+151/HDOF3
153535  "8HMO3;ITB12+151/UDHM3
153535  "8C4HD;ITB12+152/HDOF4
153536  "8HMO4;ITB12+152/UDHM4
153536  "8C5HD;ITB12+153/HDOF5
153537  "8HMO5;ITB12+153/UDHM5
153537  "8C6HD;ITB12+154/HDOF6
153540  "8HMO6;ITB12+154/UDHM6
153540  "8HDM1;ITB12+155/HDMO1
153541  "
153541  MAX12=*-ITB12
153541
153541
153541  %==============================================================================
153541  % 42.16      I T E 1 0
153541  %
153541  ITE10=*
153541  "8NIU0;140444;MNDF0
153543  "8NIU1;140445;MNDF1
153545  "8NIU2;140446;MNDF2
153547  "
153547  *+XID10/
153561  -1;-1
153563  %==============================================================================
153563  % 42.18      I T E 1 2
153563  %
153563  ITE12=*
153563  "8CD01;*+2/
153565  "8CD02;*+2/
153567  "8PC01; 140002; PIO01
153571  "8PC02; 140003; PIO02
153573  "8PC03; 140004; PIO03
153575  "8PC04; 140005; PIO04
153577  "8ETR1; 140034; ETRN1
153601  "8ETR2; 140035; ETRN2
153603  "8ETR3; 140036; ETRN3
153605  "
153605  *+XID12/
153617  -1;-1
153621
153621  %==============================================================================
153621  % 42.19      I T E 1 3
153621  %
153621  ITE13=*;
153621  *+XID13/
153625  -1
153626  IT13E=*
153626  -1;-1
153630  %==============================================================================
153630  % 42.20      I T B 1 3
153630  %
153630  ITB13, CLCFI
153631  "8BEX1; ITB13+07/BEXDA
153640  "8BEX2; ITB13+10/BEXDA
153641  "8MPM4
153641         ITB13+17/ MPM4D
153650         ITB13+20/ MPM4D
153651         ITB13+21/ MPM4D
153652         ITB13+22/ MPM4D
153653         ITB13+23/ MPM4D
153654         ITB13+24/ MPM4D
153655         ITB13+25/ MPM4D
153656         ITB13+26/ MPM4D
153657         ITB13+27/ MPM4D
153660         ITB13+30/ MPM4D
153661         ITB13+31/ MPM4D
153662         ITB13+32/ MPM4D
153663         ITB13+33/ MPM4D
153664         ITB13+34/ MPM4D
153665         ITB13+35/ MPM4D
153666         ITB13+36/ MPM4D
153667  %%%%      ITB13+37/ MPM4D
153667         ITB13+37/IOCT0;OOCT0
153671  "8C1HD;ITB13+147/HDIF1
154000  "8HMO1;ITB13+147/IDHM1
154000  "8C2HD;ITB13+150/HDIF2
154001  "8HMO2;ITB13+150/IDHM2
154001  "8C3HD;ITB13+151/HDIF3
154002  "8HMO3;ITB13+151/IDHM3
154002  "8C4HD;ITB13+152/HDIF4
154003  "8HMO4;ITB13+152/IDHM4
154003  "8C5HD;ITB13+153/HDIF5
154004  "8HMO5;ITB13+153/IDHM5
154004  "8C6HD;ITB13+154/HDIF6
154005  "8HMO6;ITB13+154/IDHM6
154005  "8HDM1;ITB13+155/HDMI1
154006  "
154006
154006  MAX13=*-ITB13
154006
154006  %============================================================================
154006  %            I D 1 0 T
154006  %
154006  % IDENT CODE TABLE FOR TERMINAL 65-128 OUTPUT (LEVEL 10)
154006
154006  ID10T=*
154006  "8TR65;ID10T+00/DT65W
154007  "8TR66;ID10T+01/DT66W
154010  "8TR67;ID10T+02/DT67W
154011  "8TR68;ID10T+03/DT68W
154012  "8TR69;ID10T+04/DT69W
154013  "8TR70;ID10T+05/DT70W
154014  "8TR71;ID10T+06/DT71W
154015  "8TR72;ID10T+07/DT72W
154016  "8TR73;ID10T+10/DT73W
154017  "8TR74;ID10T+11/DT74W
154020  "8TR75;ID10T+12/DT75W
154021  "8TR76;ID10T+13/DT76W
154022  "8TR77;ID10T+14/DT77W
154023  "8TR78;ID10T+15/DT78W
154024  "8TR79;ID10T+16/DT79W
154025  "8TR80;ID10T+17/DT80W
154026  "8TR81;ID10T+20/DT81W
154027  "8TR82;ID10T+21/DT82W
154030  "8TR83;ID10T+22/DT83W
154031  "8TR84;ID10T+23/DT84W
154032  "8TR85;ID10T+24/DT85W
154033  "8TR86;ID10T+25/DT86W
154034  "8TR87;ID10T+26/DT87W
154035  "8TR88;ID10T+27/DT88W
154036  "8TR89;ID10T+30/DT89W
154037  "8TR90;ID10T+31/DT90W
154040  "8TR91;ID10T+32/DT91W
154041  "8TR92;ID10T+33/DT92W
154042  "8TR93;ID10T+34/DT93W
154043  "8TR94;ID10T+35/DT94W
154044  "8TR95;ID10T+36/DT95W
154045  "8TR96;ID10T+37/DT96W
154046  "8TR97;ID10T+40/DT97W
154047  "8TR98;ID10T+41/DT98W
154050  "8TR99;ID10T+42/DT99W
154051  "9TR00;ID10T+43/T100W
154052  "9TR01;ID10T+44/T101W
154053  "9TR02;ID10T+45/T102W
154054  "9TR03;ID10T+46/T103W
154055  "9TR04;ID10T+47/T104W
154056  "9TR05;ID10T+50/T105W
154057  "9TR06;ID10T+51/T106W
154060  "9TR07;ID10T+52/T107W
154061  "9TR08;ID10T+53/T108W
154062  "9TR09;ID10T+54/T109W
154063  "9TR10;ID10T+55/T110W
154064  "9TR11;ID10T+56/T111W
154065  "9TR12;ID10T+57/T112W
154066  "9TR13;ID10T+60/T113W
154067  "9TR14;ID10T+61/T114W
154070  "9TR15;ID10T+62/T115W
154071  "9TR16;ID10T+63/T116W
154072  "9TR17;ID10T+64/T117W
154073  "9TR18;ID10T+65/T118W
154074  "9TR19;ID10T+66/T119W
154075  "9TR20;ID10T+67/T120W
154076  "9TR21;ID10T+70/T121W
154077  "9TR22;ID10T+71/T122W
154100  "9TR23;ID10T+72/T123W
154101  "9TR24;ID10T+73/T124W
154102  "9TR25;ID10T+74/T125W
154103  "9TR26;ID10T+75/T126W
154104  "9TR27;ID10T+76/T127W
154105  "9TR28;ID10T+77/T128W
154106  "9TR29;  ID10T+200/T129W
154207  "9TR30;  ID10T+201/T130W
154210  "9TR31;  ID10T+202/T131W
154211  "9TR32;  ID10T+203/T132W
154212  "9TR33;  ID10T+204/T133W
154213  "9TR34;  ID10T+205/T134W
154214  "9TR35;  ID10T+206/T135W
154215  "9TR36;  ID10T+207/T136W
154216  "9TR37;  ID10T+210/T137W
154217  "9TR38;  ID10T+211/T138W
154220  "9TR39;  ID10T+212/T139W
154221  "9TR40;  ID10T+213/T140W
154222  "
154222  MXX10=*-ID10T
154222
154222  %============================================================================
154222  %            I D 1 2 T
154222  %
154222  % IDENT CODE TABLE FOR TERMINAL 65-128 INPUT (LEVEL 12)
154222
154222  ID12T=*
154222  "8TR65;ID12T+00/DT65R
154223  "8TR66;ID12T+01/DT66R
154224  "8TR67;ID12T+02/DT67R
154225  "8TR68;ID12T+03/DT68R
154226  "8TR69;ID12T+04/DT69R
154227  "8TR70;ID12T+05/DT70R
154230  "8TR71;ID12T+06/DT71R
154231  "8TR72;ID12T+07/DT72R
154232  "8TR73;ID12T+10/DT73R
154233  "8TR74;ID12T+11/DT74R
154234  "8TR75;ID12T+12/DT75R
154235  "8TR76;ID12T+13/DT76R
154236  "8TR77;ID12T+14/DT77R
154237  "8TR78;ID12T+15/DT78R
154240  "8TR79;ID12T+16/DT79R
154241  "8TR80;ID12T+17/DT80R
154242  "8TR81;ID12T+20/DT81R
154243  "8TR82;ID12T+21/DT82R
154244  "8TR83;ID12T+22/DT83R
154245  "8TR84;ID12T+23/DT84R
154246  "8TR85;ID12T+24/DT85R
154247  "8TR86;ID12T+25/DT86R
154250  "8TR87;ID12T+26/DT87R
154251  "8TR88;ID12T+27/DT88R
154252  "8TR89;ID12T+30/DT89R
154253  "8TR90;ID12T+31/DT90R
154254  "8TR91;ID12T+32/DT91R
154255  "8TR92;ID12T+33/DT92R
154256  "8TR93;ID12T+34/DT93R
154257  "8TR94;ID12T+35/DT94R
154260  "8TR95;ID12T+36/DT95R
154261  "8TR96;ID12T+37/DT96R
154262  "8TR97;ID12T+40/DT97R
154263  "8TR98;ID12T+41/DT98R
154264  "8TR99;ID12T+42/DT99R
154265  "9TR00;ID12T+43/T100R
154266  "9TR01;ID12T+44/T101R
154267  "9TR02;ID12T+45/T102R
154270  "9TR03;ID12T+46/T103R
154271  "9TR04;ID12T+47/T104R
154272  "9TR05;ID12T+50/T105R
154273  "9TR06;ID12T+51/T106R
154274  "9TR07;ID12T+52/T107R
154275  "9TR08;ID12T+53/T108R
154276  "9TR09;ID12T+54/T109R
154277  "9TR10;ID12T+55/T110R
154300  "9TR11;ID12T+56/T111R
154301  "9TR12;ID12T+57/T112R
154302  "9TR13;ID12T+60/T113R
154303  "9TR14;ID12T+61/T114R
154304  "9TR15;ID12T+62/T115R
154305  "9TR16;ID12T+63/T116R
154306  "9TR17;ID12T+64/T117R
154307  "9TR18;ID12T+65/T118R
154310  "9TR19;ID12T+66/T119R
154311  "9TR20;ID12T+67/T120R
154312  "9TR21;ID12T+70/T121R
154313  "9TR22;ID12T+71/T122R
154314  "9TR23;ID12T+72/T123R
154315  "9TR24;ID12T+73/T124R
154316  "9TR25;ID12T+74/T125R
154317  "9TR26;ID12T+75/T126R
154320  "9TR27;ID12T+76/T127R
154321  "9TR28;ID12T+77/T128R
154322  "9TR29;  ID12T+200/T129R
154423  "9TR30;  ID12T+201/T130R
154424  "9TR31;  ID12T+202/T131R
154425  "9TR32;  ID12T+203/T132R
154426  "9TR33;  ID12T+204/T133R
154427  "9TR34;  ID12T+205/T134R
154430  "9TR35;  ID12T+206/T135R
154431  "9TR36;  ID12T+207/T136R
154432  "9TR37;  ID12T+210/T137R
154433  "9TR38;  ID12T+211/T138R
154434  "9TR39;  ID12T+212/T139R
154435  "9TR40;  ID12T+213/T140R
154436  "
154436  MXX12=*-ID12T
154436
154436  )LINE
%
154436  % File : (SAMSON)KILL-MACROS:DUMY
154436
154436  )KILL CNVBYADR CNVWADR
154436  )LINE
032112   %$--:IPIT                     % FOR SPLITTING AV LISTING.
032112   *P2IPI/
032157   @DEV (S-S-L)IP-P2-SEGADM:NPL
032157   % TAB S8,4
032157   %

032157   %==============================================================================
032157   %==============================================================================
032157   %
032157   %   3 7 . 0      S E G M E N T    S U P E R V I S I N G
032157   %
032157   %           SSSSS    EEEEEEE    GGGGG     AAAAA    DDDDD     M     M
032157   %          S     S   E         G     G   A     A   D    D    MM   MM
032157   %          S         E         G         A     A   D     D   M M M M
032157   %          S         E         G         A     A   D     D   M  M  M
032157   %           SSSSS    EEEEEE    G  GGGG   AAAAAAA   D     D   M     M
032157   %                S   E         G     G   A     A   D     D   M     M
032157   %                S   E         G     G   A     A   D     D   M     M
032157   %          S     S   E         G     G   A     A   D    D    M     M
032157   %           SSSSS    EEEEEEE    GGGGG    A     A   DDDDD     M     M
032157   %
032157   %==============================================================================
032157   %==============================================================================
032157   %
032157   %      THIS PART OF SEGADM EXECUTES IN RING 3 AND IS RUN ON
032157   %      PROGRAM LEVEL SLEV. IT IS STARTED FROM MLEV BY SETTING THE
032157   %      SLEV P-REGISTER AND ENABLING THE LEVEL. RETURN TO MLEV
032157   %      AND CALLING RING 2 ROUTINES MUST BE DONE IN A SIMILAR WAY!
032157   %
032157   %==============================================================================
032157   %
032157   %
032157
032157   **-1@-12+1@12/
034000   *SRNG3=*           % START OF RING 3 CODE
034000   %=============================================================================
034000   %      G O M L E V                         C A L L M L E V
034000   %
034000   %      RETURN TO MONITOR LEVEL.            INTERFACE FOR CALLING ROUTINES
034000   %      A - ROUTINE ADDRESS.                ON MONITOR LEVEL.
034000   %                                          FOLLOWING CALL - ROUTINE ADDRESS.
034000   %                                          CALL CALLMLEV(ROUTINE)
034000   SUBR GOMLEV, CALLMLEV
034000   GOMLEV:
034000          *IRW MLEVB DP               % SET P-REGISTER ON MONITOR LEVEL.
034001          MLEV; *MST PIE; MST PID     % ENABLE AND START MONITOR LEVEL.
034004          *WAIT                       % STOP SEGADM LEVEL.
034005          CALL ERRFATAL
034006   INTEGER POINTER LREG
034007   CALLMLEV:
034007          A:=:L                       % GET RETURN ADDRESS, SAVE A IN L.
034010          *1BANK                      % ACCESS PROGRAM BANK
034011          A=:"LREG":=LREG             % SAVE RETURN ADDRESS AND GET DATA FOLLOWING CALL.
034013          *IRW MLEVB DP               % SET P-REGISTER ON MONITOR LEVEL.
034014          A:="LREG":=:L               % RESTORE L AND A.
034016          *2BANK
034017          *WAIT                       % GO DOWN TO MONITOR LEVEL.
034020          EXITA                       % SKIP RETURN OVER ADDRESS.
034021   RBUS
034022

034022   %=============================================================================
034022   % 37.1           S E G A D M
034022   %
034022   % SUBROUTINE TO CHECK IF SEGMENTS ARE OK, CALLED FROM STUPR
034022   % RETURN IF SEGMENTS OK, ELSE TO SEGIN
034022   % ENTRY:     MLEV.X = RTREF
034022
034022   SUBR SEGADM
034022   INTEGER POINTER LREG
034023   INTEGER BREG
034024
034024   SEGADM:*IRR MLEVB DX                   % GET NEW PROGRAM
034025          IF A=FIXCRT THEN                % IF IT IS THE PROGRAM DOING FIXC
034030              CALL XCSEGS; GO FAR OUT     % THEN CLEAR PAGE TABLES AND EXIT
034032          FI
034032          X:=A                            % X POINTS TO RT DESC OF NEW PROGRAM
034033          AD:=X.DACTSEG                   % A:=ACT1SEG, D:=ACT2SEG
034034          IF A           ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGB    % COMPUTE SEGMENT
034040          IF A:=D        ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGA    % TABLE ADDRESSES
034045          A:=X.RSEGM; IF ><0 THEN A*5SEGSIZE+SEGSTART FI; A=:NSEGC    % AND SET UP NEW SEGMENTS (NSEG A,B,C)
034052          NSEGA=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI          % CHECK WHETHER THE SEGMENTS ARE OK
034057          NSEGB=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI          % OR IF THEY MUST BE FETCHED BY SEGIN.
034064          NSEGC=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI
034071
034071          GO SKIP1
034072          RTREF; CALL GETXSEG                                         % PERFORM SEGCHECK ON SPECIAL SEGMENTS
034074          A=:B; CALL SEGCHECK; IF A<0 THEN CALL SEGIN FI              % IF IN USE BY THIS PROGRAM.
034100
034100   SKIP1:                         % ALL SEGMENTS ARE NOW OK.
034100          CALL XCSEGS             % CLEAR PAGETABLES (EXCEPT SPIT, FPIT, 5PIT AND FUPIT)
034101
034101          NSEGC=:B                % REENTRANT SEGMENT
034103          IF B >< 0 THEN          % IF PROGRAM HAS ONE THEN
034105              *LDASG LOGAD            % GET LOGICAL ADDRESS
034115              IF A SHZ -6=SPIT THEN            % SEGMENT IN SPIT?
034121                  IF S3SEG><B THEN             % SPIT SEGMENT CHANGED?
034124                      CALL CLSEG               % YES, CLEAR CURRENT SPIT SEGMENT
034125                      A:=B=:S3SEG; CALL STRSEG % SETUP NEW SPIT SEGMENT
034130                  FI
034130              ELSE                             % NOT IN SPIT:
034131                  NSEGC; CALL STRSEG           % SETUP REENTRANT SEGMENT
034133              FI
034133          FI
034133          NSEGC=:SEGMC            % NEW REENT. SEGMENT IS NOW CURRENT REENT. SEGMENT
034135          X:=RTREF
034136          CALL CLNREENT           % CLEAR NONREENTRANT PAGES WITHIN REENT SEGM.
034137
034137          0=:MBSYSEG              % USED FOR MARKING SYSTEM SEGMENT CURRENTLY USED OR NOT
034140          NSEGA=:B                % SEGMENT #2
034142          IF B >< 0 THEN          % IF PROGRAM HAS ONE
034144              *LDASG FLAG
034154              A=:MBSYSEG              % SAVE THE FLAG (FOR 5SYSEGM)
034155              *LDASG LOGAD            % GET LOGICAL ADDRESS
034165              IF A SHZ -6=SPIT THEN           % SEGMENT IN SPIT?
034171                  IF S3SEG><B THEN            % SPIT SEGMENT CHANGED?
034174                      CALL CLSEG              % YES, CLEAR CURRENT SPIT SEGMENT
034175                      A:=B=:S3SEG; CALL STSEG % SETUP NEW SPIT SEGMENT
034200                  FI
034200              ELSE                            % NOT IN SPIT:
034201                  NSEGA; CALL STSEG           % SETUP SEGMENT
034203              FI
034203          FI
034203          NSEGA=:SEGMA            % NEW SEGMENT A IS NOW CURRENT SEGMENT A
034205          GO L1; *)FILL
034233
034233   L1:    NSEGB=:B                % SEGMENT #1
034235          IF B >< 0 THEN          % IF PROGRAM HAS ONE
034237              *LDASG FLAG
034247              A\/MBSYSEG=:MBSYSEG     % "OR" FLAG WITH THE OTHER SEGMENTS' FLAG (FOR 5SYSEGM)
034251              *LDASG LOGAD            % GET LOGICAL ADDRESS
034261              IF A SHZ -6=SPIT THEN           % SEGMENT IN SPIT?
034265                  IF S3SEG><B THEN            % SPIT SEGMENT CHANGED?
034270                      CALL CLSEG              % YES, CLEAR CURRENT SPIT SEGMENT
034271                      A:=B=:S3SEG; CALL STSEG % SETUP NEW SPIT SEGMENT
034274                  FI
034274              ELSE                            % NOT IN SPIT:
034275                  NSEGB; CALL STSEG           % SETUP SEGMENT
034277              FI
034277          FI
034277          NSEGB=:SEGMB            % NEW SEGMENT B IS NOW CURRENT SEGMENT B
034301
034301          RTREF=:SEGPROG          % SET UP THE PROGRAM CURRENTLY USING SEGMENTS
034303          IF MBSYSEG NBIT 5SYSEG THEN % IF NEITHER SEGMENT A NOR B WAS A SYSTEM SEGMENT
034306              CALL SETRT              % THEN ENTER RT'S SYS.SEG
034307          FI
034307   *"8LAMU
"034307          CALL SLAMU              % SET UP LAMUS
034310   *"
"034310   OUT:   *WAIT   % RETURN DOWN TO MONITOR LEVEL
034311          CALL ERRFATAL
034312
034312   RBUS
034326

034326   SUBR XINSPG, XREMPG, YINSPG, YREMPG
034326   %
034326   %          ROUTINES TO EMULATE INSPG AND REMPG UNTIL THEY ARE MICROCODED
034326   %
034326   INTEGER FIRST, SEGMENT, XPAGENO, CME, SEGNO
034333   DOUBLE SAVAD=?
034333
034333   XINSPG:AD=:SAVAD
034334          A:=B=:SEGMENT
034336          T=:XPAGENO
034337          X=:D=:CME       % D:=CME
034341          T:=SEGTBANK
034342          X:=A            % X:=SEGMENT
034343          *BPAGL@3 LDATX  % A:=SEGMENT.BPAGLINK
034344          A=:FIRST
034345          A:=:D           % A:=CME; D:=FIRST
034346          *BPAGL@3 STATX  % A=:SEGMENT.BPAGLINK
034347          X:=A            % X:=CME
034350          A:=:D           % A:=FIRST; D:=CME
034351          T:=CORMBANK
034352          *PAGLI@3 STATX   % A=:CME.PAGLI
034353          IF A >< 0 THEN  % IF NONEMPTY PAGE LIST
034354              X:=A            % X:=FIRST
034355              *PREVI@3 LDATX  % A:=FIRST.PREVIOUS
034356              A=:SEGNO
034357              A:=:D           % A:=CME; D:=SEGNO
034360              *PREVI@3 STATX  % A=:FIRST.PREVIOUS
034361              X:=A            % X:=CME
034362              A:=D            % A:=SEGNO
034363          ELSE
034364              A:=B-SEGSTART=:D:=0
034370              T:=5SEGSIZE
034371              *RDIV ST
034372              A SH 2 + 3=:SEGNO
034375              T:=CORMBANK
034376          FI
034376          *PREVI@3 STATX  % SEGNO=:CME.PREVIOUS
034377          A:=XPAGENO
034400          *LOGPA@3 STATX  % A=:CME.LOGPAGE
034401          T:=A
034402          AD:=SAVAD
034403          EXIT
034404
034404   INTEGER CNEXT, CPREV
034406   TRIPLE SAVETAD
034411   DOUBLE SAVAD=SAVETAD
034411
034411   XREMPG:TAD=:SAVETAD
034412          X=:D
034413          T:=CORMBANK
034414          *PAGLI@3 LDATX   % A:=CME.PAGLI
034415          A=:CNEXT
034416          *PREVI@3 LDATX  % A:=CME.PREVIOUS
034417          A=:CPREV
034420          IF A NBIT 0 THEN% INSIDE PAGE LIST
034422              X:=A            % X:=CPREV
034423              A:=CNEXT
034424              *PAGLI@3 STATX   % A=:CPREV.PAGLI
034425          ELSE            % FIRST ELEMENT IN LIST
034426              A SHZ -2 SH 3 + SEGSTART=:X
034432              T:=SEGTBANK
034433              A:=CNEXT
034434              *BPAGL@3 STATX  % A=:SEGMENT.BPAGLINK
034435              T:=CORMBANK
034436          FI
034436          IF A >< 0 THEN  % IF NOT LAST ELEMENT IN LIST
034437              X:=A            % X:=CNEXT
034440              A:=CPREV
034441              *PREVI@3 STATX  % A=:CNEXT.PREVIOUS
034442          FI
034442          X:=D            % X:=CME
034443          *PAGLI@3 STZTX  % 0=:CME.PAGLI
034444          *PREVI@3 STZTX  % 0=:CME.PREVIOUS
034445          TAD:=SAVETAD
034446          EXIT
034447
034447   YINSPG:CALL XINSPG     % PROGRAMMED FROM MLEV OR ALEV
034450          *WAIT           % TO EXECUTE XINSPG
034451
034451   YREMPG:CALL XREMPG     % PROGRAMMED FROM MLEV OR ALEV
034452          *WAIT           % TO EXECUTE XREMPG
034453          CALL ERRFATAL
034454   RBUS
034462

034462   %==============================================================================
034462   %
034462   %           I N S E G L I N K   O U T S E G L I N K
034462   %
034462   %      INSERTION AND REMOVAL OF SEGMENTS TO/FROM THE SEGMENT LIST.
034462   %      (THE SEGMENT LIST IS A CIRCULAR DOUBLE LIST.)
034462   %      X POINTS TO SEGMENT
034462   SUBR INSEGLINK, OUTSEGLINK
034462
034462   INTEGER XRGGG,BRGGG
034464   TRIPLE TADRRG
034467   INSEGLINK:TAD=:TADRRG;X=:XRGGG;A:=B=:BRGGG  % SAVE REGISTERS
034473          T:=SEGTBANK
034474          A:=BSEGLINK=:B      % BSEGLINK
034476          *SEGLI@3 STATX      %         =:IN.SEGLINK
034477          X=:D:=A
034501          *PRESE@3 LDATX      % BSEGLINK.PRESEG
034502          X:=D
034503          *PRESE@3 STATX      %                =:IN.PRESEG
034504          X:=:A               % IN
034505          *SEGLI@3 STATX      %   =:BSEGLINK.PRESEG.SEGLINK
034506          X:=B
034507          *PRESE@3 STATX      % IN=:BSEGLINK.PRESEG
034510          A=:BSEGLINK         % IN=:BSEGLINK
034511          BRGGG=:B;X:=XRGGG;TAD:=TADRRG    % RESTORE REGISTERS
034515          EXIT
034516
034516   OUTSEGLINK:
034516          TAD=:TADRRG;X=:XRGGG;A:=B=:BRGGG  % SAVE REGISTERS
034522          X=:D
034523          T:=SEGTBANK
034524
034524                              % OUT.PRESEG=:OUT.SEGLINK.PRESEG
034524                              % OUT.SEGLINK=:OUT.PRESEG.SEGLINK
034524          *PRESE@3 LDATX      % A:=OUT.PRESEG
034525          *SEGLI@3 LDXTX      % X:=OUT.SEGLINK
034526          *PRESE@3 STATX      % A=:OUT.SEGLINK.PRESEG (OUT.PRESEG=:X.PRESEG)
034527          A:=:X
034530          *SEGLI@3 STATX      % A=:OUT.PRESEG.SEGLINK (OUT.SEGLINK=:X.SEGLINK)
034531          X:=D
034532          *SEGLI@3 STZTX      % 0=:OUT.SEGLINK
034533          *PRESE@3 STZTX      % 0=:OUT.PRESEG
034534          IF X=BSEGLINK THEN  % IF REMOVING THE FIRST SEGMENT THEN
034537              A=:BSEGLINK         % MAKE THE NEXT THE NEW FIRST
034540          FI
034540          BRGGG=:B;X:=XRGGG;TAD:=TADRRG    % RESTORE REGISTERS
034544          EXIT
034545   RBUS
034547
034547

034547   %==============================================================================
034547   % 37.2          P A G E F A U L T   P A G E 2 F A U L T   L I M C H E C K
034547   %
034547   %--MONITOR ENTRY FROM LEVEL 14 IF PAGE FAULT
034547   %  LOGICAL PAGE OF PAGE FAULT IS IN PNUMB
034547   %EXIT TO SEGIN
034547
034547   SUBR PAGEFAULT,PAGE2FAULT,LIMCHECK, SP01J
034547
034547   INTEGER DEMFLAG=?
034547   INTEGER SHAINSTR(0); *SHA
034550   INTEGER CINSTR(0); *BSKP ZRO DT
034551
034551   INTEGER SWLGF=?
034551
034551   PAGE2FAULT:                            % PAGEFAULT ON INBT/OUTBT LEVEL
034551   *"8SWLG
"034551               0=:SWLGF
034552   *"
"034552               CALL CALLMLEV(MLBLEVSET)   % SAVE STATUS FOR BLEV AND PREPARE FOR
034554                                          % RESTARTING IT AFTER PAGE FAULT HANDLING.
034554               GO PAGF
034555   PAGEFAULT:                             % PAGEFAULT ON APPLICATION LEVEL
034555   *"8SWLG
"034555               1=:SWLGF
034557   *"
"034557   PAGF:
034557          IF PNUMB>=WNDBF AND <=WND41 THEN % PNUMB IN WND41,WND12,WND10,WNDN5,WNDBF
034566              % PAGE FAULT IN WINDOWS SHOULD BE HANDLED ON LEVEL 14.
034566              CALL ERRFATAL
034567          FI
034567          A SH 1 \/ 174000=:X:=X.S0       % GET PAGE TABLE ENTRY FOR FAULTED PAGE
034573          IF A><0 THEN CALL ERRFATAL FI   % ENTRY WAS NOT 0
034575
034575          IF X:=SEGMC >< 0 THEN
034577              A:=0 BONE 5DEMAND=:DEMFLAG  % SET DEMAND.
034602              CALL LIMCHECK
034603          ELSE
034604              0=:DEMFLAG                  % SET NOT YET DEMAND.
034605              A:=-1
034606          FI
034606          IF A=0 THEN % PAGE FAULT POSSIBLY WITHIN REENTRANT SEGMENT
034607              B:=X                % FIND ENTRY IN BITMAP
034610              *LDASG LOGAD        % LOGICAL START ADDRESS(PIT) OF SEGMENT
034620              A/\1700=:D          % TO D REGISTER.
034622              A:=PNUMB/\1777-D    % A:=PNUMB-LOGAD
034625   SP01J:     GO SP01L
034626
034626                                          % BITMAP TEST FOR "NEW" CPU
034626              T:=0                        % BANK 0
034627              X:=RTREF.RTDLGADDR+5BITMAP  % BITMAP ADDRESS
034632              *LBITP                      % PHYSICAL LOAD BIT ( K:=TX(A) )
034633              IF K GO NOTREENT            % NOT IN REENTRANT SEGMENT
034635              X:=B   % SEGMC              % YES, IN REENTRANT SEGMENT
034636              GO SP01FI
034637                                          % BITMAP TEST FOR STANDARD CPU
034637   SP01L:     AD SHZ -4; D SHZ -14        % A:=WORD NO. IN BITMAP, D:=BIT NO. IN WORD
034641              X:=RTREF.RTDLGADDR+5BITMAP  % POINTER TO BITMAP
034644              X+A                         % POINTER BITMAP WORD OF THIS PAGE
034645              A:=SHAINSTR                 % "SHIFT" INSTRUCTION
034646              D+A                         % ADD "SHIFT" INSTR. TO SHIFT COUNT.
034647              A:=1; *EXR SD               % SET A ONE AT WANTED BIT POSITION IN WORD.
034651              T:=0                        % BANK 0
034652              *LDXTX                      % X:=BITMAP WORD
034653              IF A/\X><0 GO NOTREENT      % MASK OUT WANTED BIT AND TEST, IF SET NOT REENTRANT SEGMENT.
034655              X:=B  % SEGMC               % YES, IN REENTRANT SEGMENT.
034656
034656          ELSE                                    % PAGE FAULT IN SHADOW SEGMENT.
034657   NOTREENT:  X:=SEGMB; T:=SEGTBANK; *FLAG@3 LDATX
034662              A\/DEMFLAG=:DEMFLAG                 % INCLUDE 5DEMAND FOR SEGMENT B.
034664              X:=SEGMA; T:=SEGTBANK; *FLAG@3 LDATX
034667              A\/DEMFLAG=:DEMFLAG                 % INCLUDE 5DEMAND FOR SEGMENT A.
034671              CALL LIMCHECK                       % TEST FOR SEGMENT A.
034672              IF <0 THEN
034673                  X:=SEGMB
034674                  CALL LIMCHECK                   % IF NOT A, TEST FOR SEGMENT B.
034675                  IF <0 THEN CALL SINCHECK        % IF NOT B, TEST FOR SINTRAN.
034677                      IF <0 THEN                  % IF NOT SINTRAN, THEN
034700                          T:=PNUMB
034701                          IF DEMFLAG BIT 5DEMAND THEN "S14ERR"    % OUTSIDE SEGMENT BOUNDS.
034705                                                 ELSE "S13ERR";FI % PAGE FAULT FOR NON DEMAND.
034707                          CALL GOMLEV             % GO TO MONITOR LEVEL.
034710                      FI
034710                  ELSE
034711                      IF DEMFLAG NBIT 5DEMAND GO PFNDEM % PAGE FAULT FOR NON DEMAND.
034714                  FI
034714              ELSE
034715                  IF DEMFLAG NBIT 5DEMAND GO PFNDEM % PAGE FAULT FOR NON DEMAND.
034720          FI  FI
034720   SP01FI:                    % X POINTS TO PAGE FAULTED SEGMENT
034720          X=:B                % B POINTS TO PAGE FAULTED SEGMENT
034721          CALL SEGIN          % GET IN FAULTED PAGE FROM DISK.
034722
034722   PFNDEM:"S13ERR"; CALL GOMLEV   % PAGE FAULT FOR NON DEMAND.
034724
034724   INTEGER DEMFLAG
034725   *"8SWLG
"034725   INTEGER SWLGF
034726   *"
"034726   *)FILL
034751
034751   LIMCHECK:                              % CHECK WHETHER PNUMB IS WITHIN SEGMENT X OR NOT.
034751          IF X=0 THEN A:=-1 ; EXIT FI     % NO SEGMENT: NO.
034755          T:=SEGTBANK
034756          *LOGAD@3 LDDTX                  % A:=LOGADR, D:=SEGLENGTH
034757          IF A>PNUMB OR A+D<=T THEN       % IF OUTSIDE SEGMENT
034765                A:=-1                     % RETURN NO
034766          ELSE                            % INSIDE SEGMENT
034767   *"8SWLG
"034767                IF CSWLGF><0 THEN                             % SWAPPING-LOG?
034771                   IF T:=SWLGF=0 THEN                         % LEVEL 4
034774                      *MIN I (TPF42; SKP; MIN I (TPF41; JMP *+1
035000                      IF A=RTREF THEN                         % LOG FOR A SPESIFIC PROGRAM
035003                         *MIN I (CPF42; SKP; MIN I (CPF41; JMP *+1
035007                      FI
035007                   ELSE
035010                      *MIN I (TPF12; SKP; MIN I (TPF11; JMP *+1 % LEVEL 1
035014                      IF A=RTREF THEN                         % LOG FOR A SPESIFIC PROGRAM
035017                         *MIN I (CPF12; SKP; MIN I (CPF11; JMP *+1
035023                      FI
035023                   FI;
035023                FI
035023   *"
"035023              A:=0                        % RETURN WITH A=0 (YES)
035024          FI
035024          EXIT
035025
035025   SINCHECK:              % CHECK FOR PAGE FAULT IN SINTRAN SEGMENTS.
035025          L=:B
035026          X:=FILSEGM; CALL LIMCHECK   % IN FILE SYSTEM
035030          IF A=0 THEN B=:P FI
035032   *"8N500
"035032          X:=5NSEGM; CALL LIMCHECK    % IN ND500 SYSTEM MONITOR
035034          IF A=0 THEN B=:P FI
035036   *"8RFAC
"035036          X:=FUSEGM; CALL LIMCHECK    % IN REMOTE FILE ACCESS
035040          IF A=0 THEN B=:P FI
035042   *"
"035042          X:=SEGSTART; CALL LIMCHECK  % SEGMENT 0 IS RPIT.
035044          IF A=0 THEN CALL ERRFATAL FI% PF IN RESIDENT IS FATAL ERROR
035046          A:=-1                       % NOT IN SINTRAN.
035047          B=:P                        % RETURN
035050
035050   RBUS
035072

035072   %==============================================================================
035072   % 37.3       C L S E G   S T R S E G   S T S E G   X C L S E G   Y C L S E G
035072   %            C L P A G E   S T P A G E   S L A M U    C L A M U    C R S E G
035072   %            G E T W I P   1 C L A M
035072   %
035072   %  SUBROUTINES TO UPDATE THE HARDWARE PAGE TABLE
035072   % ENTRY:     A=SEGM. POINTER
035072
035072   @ICR;
035072   SUBR CLSEG, STRSEG, STSEG, CLPAGE, CLWINDOWS, 1CLAM,
035072        CLAMU, SLAMU, STPAGE, XCLSEG, GETWIP, CRSEG,
035072        SP02J, SP03J, SP04J, SP05J, SP10J, SP11J, SP13J, SP14J;
035072   @CR;
035072   *"8LAMU
"035072   DOUBLE ARRAY POINTER PTBG0:=174000     % PIT POINTERS
035073   INTEGER ARRAY POINTER IPTBG=PTBG0
035073   INTEGER POINTER LREG       % RETURN ADDRESS.
035074   INTEGER CL                 % CURRENT LAMU.
035075   INTEGER CACLE              % FIRST LAMU FOR THIS PROGRAM.
035076   INTEGER LAPRF:=0           % =0: PREVIOUS PROG HAS CLEARED LAMU PAGES
035077
035077   1CLAM: "1RCLA"=:"LREG"; K:=1; GO L1            % STARTED FROM MON LAMU
035103   SLAMU: K:="0"; GO LAMU                         % SET UP LAMU.
035105   CLAMU: IF LAPRF=0 THEN EXIT FI; K:=1           % CLEAR LAMU
035111   LAMU:  A:=L=:"LREG";
035113   L1:    IF SEGPROG = 0 GO LREG
035116          A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST   % RT PROGRAM NUMBER.
035123          A=:D+LAMIH=:X; T:=LAMBANK; *LDATX       % LAMU INHIBITED FOR THIS PROGRAM ?
035130          IF A >< 0 AND K NBIT GO LREG
035133          A:=D*GNLPRT*ALMSZ+LAMACT=:CACLE; 0=:CL
035141          FOR CL TO GNLPRT-1 DO
035146                A*ALMSZ+CACLE=:X; T:=LAMBANK; *LDDTX
035153                IF A >< 0 THEN                    % D=FIRST LOGICAL PAGE NO.
035154                   IF A > 0 THEN                  % USER LAMU OR SYSTEM-LAMU
035156                      A*LDTSZ+LAMDT               % ADDRESS IN LAMDT
035160                   ELSE
035161                      A- *SDTSZ+SYLDT             % ADDRESS IN SYLDT
035164                   FI
035164                   A=:X; *LDATX LMNP              % A:=NUMBER OF PAGES IN THIS LAMU.
035166                   L:=D+A-1+L                     % COMPUTE LAST PIT ENTRY FOR THIS LAMU.
035172                   *LDATX LMPP;  LDXTX LMPR       % A:=FIRST PHYS.PAGE OF THIS LAMU.
035174                   T:=X                           % T:=LAMU PROTECTION.
035175                   X:=D+X; D:=A; A:=T
035201                   IF K THEN
035203                      FOR X STEP 2 TO L DO 0=:IPTBG(X) OD        % CLEAR PIT FOR THIS LAMU.
035210                      0=:LAPRF                                   % MARK LAMU CLEARED
035211                   ELSE
035212                      FOR X STEP 2 TO L DO AD=:PTBG0(X); D+1 OD  % SET UP PIT FOR THIS LAMU.
035220                      1=:LAPRF                                   % MARK LAMU SET
035222                   FI
035222                FI
035222          OD
035226          GO LREG
035227   1RCLA: *WAIT
035230          CALL ERRFATAL
035231   *)FILL
035246   *"
"035246
035246   INTEGER PINDEX=?,BRG=?
035246
035246   INTEGER POINTER IWDN5:=WNDN5*2+174000  % POINTER TO N500 WINDOW
035247   INTEGER POINTER IWD41:=WND41*2+174000  % POINTER TO TERMINAL WINDOW
035250   INTEGER POINTER IWDBF:=WNDBF*2+174000  % POINTER TO DATA-BUFFER WINDOW
035251
035251   CLWINDOWS:
035251          0=:IWD41        % CLEAR TERMINAL WINDOW.
035252   *"8N500
"035252          0=:IWDN5        % CLEAR ND500 WINDOW.
035253   *"
"035253          EXIT
035254
035254   CLSEG:                         % CLEAR SEGMENT FROM PAGE INDEX TABLE
035254          IF A=0 THEN EXIT FI     % NO SEGMENT: NO CLEAR.
035256          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B.
035262          T:=SEGTBANK
035263          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035264          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO XOUT % THIS SEGMENT SHOULD NOT BE CLEARED OUT NOW.
035270          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035271   *XLX02, JMP * 2; 0             % FOR LOGGING FACILITY
035273
035273   SP02J: GO SP02L
035274
035274          A:=0                    % CLEAR REGULAR SEGMENT.
035275          *KCLEP                  % NEW CPU/RASK CPU
035276          GO OUT
035277
035277   SP02L: *XCLEP                  % OLD CPU
035313          GO OUT
035314
035314   CRSEG:                         % CLEAR REENTRANT SEGMENT FROM PIT.
035314   SP13J: GO CLSEG                % FOR STD AND CX CPU: USE CLSEG.
035315          IF A=0 THEN EXIT FI     % NO SEGMENT: NO CLEAR.
035317          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B.
035323          T:=SEGTBANK
035324          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035325          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO OUT % THIS SEGMENT SHOULD NOT BE CLEARED OUT NOW.
035331          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035332   *XLX03, JMP * 2; 0             % FOR LOGGING FACILITY
035334
035334   SP10J: GO SP10L
035335
035335          A:=-1                   % CLEAR REENTRANT SEGMENT.
035336          *KCLEP                  % RASK CPU
035337   XOUT:  GO OUT
035340
035340   SP10L: T:=CORMBANK             % PASS THROUGH PAGE LIST FOR THIS SEGMENT
035341          DO WHILE X >< 0         % TO THE END.
035342              *LOGPA@3 LDATX      % A:=LOGICAL PAGE NUMBER
035343              A SH 1\/174000=:B   % B:=PIT POINTER
035346              0=:PITPROTECT       % CLEAR PIT ENTRY.
035347              *PAGLI@3 LDXTX      % NEXT PAGE IN LIST.
035350          OD
035351          GO OUT
035352
035352
035352   STRSEG:                        % SET UP REENTRANT SEGMENT.
035352   SP14J: GO STSEG                % FOR STD AND CX CPU: USE STSEG.
035353          IF A=0 THEN EXIT FI     % NO SEGMENT: NO SETUP.
035355          X=:PINDEX:=B=:BRG:=A    % SAVE B AND X.
035361          T:=SEGTBANK
035362          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035363   *XLX04, JMP * 2; 0             % FOR LOGGING FACILITY
035365   SP03J: GO SP03L
035366
035366          *KSTRP                  % NEW CPU
035367          GO OUT
035370
035370   SP03L: *XSTRP                  % OLD CPU
035406          GO OUT
035407
035407   INTEGER PINDEX,BRG             % SAVED X AND B
035411   *)FILL
035416
035416   STSEG:                         % SET UP SEGMENT IN PAGE INDEX TABLE.
035416          IF A=0 THEN EXIT FI     % NO SEGMENT: NO SETUP.
035420          X=:PINDEX:=B=:BRG:=A    % SAVE X AND B..
035424          T:=SEGTBANK
035425          *SGSTA@3 LDATX          % A:=X.SGSTATUS
035426          IF A BIT 5NCLSEG OR A BIT 5SPTFIXED GO OUT  % SEGMENT FIXED IN PIT.
035432          *BPAGL@3 LDXTX          % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035433   *XLX05, JMP * 2; 0             % FOR LOGGING FACILITY
035435   SP04J: GO SP04L
035436
035436          *KSETP                  % NEW CPU
035437          GO OUT
035440
035440   SP04L: *XSETP                  % OLD CPU
035455
035455                                  % EXIT POINT
035455   OUT:   X:=BRG=:B:=PINDEX       % RESTORE X AND B
035460          EXIT                    % RETURN
035461
035461   CLPAGE:                        % REMOVE PAGE FROM PIT. (X=CORE MAP ELEMENT)
035461          T:=B=:BRG:=CORMBANK     % SAVE B
035464          *LOGPA@3 LDATX          % A:=X.LOGPAGE
035465          A SH 1 \/ 174000=:B     % MAKE PIT POINTER IN B.
035470          0=:S0                   % CLEAR PIT ENTRY.
035471          BRG=:B                  % RESTORE B.
035473          EXIT                    % RETURN
035474
035474   INTEGER DDDRG                          % SAVED D
035475                                          % ENTER PAGE INTO PIT. (X=CORE MAP ELEMENT)
035475   STPAGE:IF X=0 THEN EXIT FI             % NO PAGE: NO ENTER.
035500          T:=B=:BRG:=D=:DDDRG:=CORMBANK   % SAVE B AND D
035505          *LOGPA@3 LDATX                  % A:=X.LOGPAGE
035506          A SH 1 \/ 174000=:B             % MAKE PIT POINTER IN B.
035511          *PROTE@3 LDATX                  % GET PROTECT ENTRY FROM CORE MAP.
035512          D:=X SHZ -2                     % COMPUTE PAGE NUMBER.
035514          AD=:PITENTRY                    % STORE PIT ENTRY.
035515          T:=DDDRG=:D:=BRG=:B             % RESTORE D AND B.
035521          EXIT                            % RETURN
035522
035522                                          % CLEAR SEGMENT FROM PIT REGARDLESS OF SEGSTATUS
035522   XCLSEG:IF A=0 THEN EXIT FI             % NO SEGMENT: NO CLEAR.
035524          X=:PINDEX:=B=:BRG:=A            % SAVE X AND B.
035530          T:=SEGTBANK; *BPAGL@3 LDXTX     % BEGINNING OF PAGE LIST FOR THIS SEGMENT.
035532   SP05J: GO SP05L
035533          A:=0
035534          *KCLEP                          % NEW CPU
035535          GO OUT
035536   SP05L: *XCLEP                          % OLD CPU
035552          GO OUT
035553   *)FILL
035556   GETWIP:                                % MOVE WIP BITS FOR 5NCLSEG SEGMENTS TO CORE MAP.
035556                                          % CALLED WITH SEGMENT POINTER IN B.
035556          X=:PINDEX:=B=:BRG               % SAVE X AND B, X:=SEGMENT.
035561          T:=SEGTBANK;*BPAGL@3 LDXTX      % X:=SEGMENT.BPAGLINK
035563   SP11J: GO SP11L
035564
035564          A:=1                            % COPY WIP AND PGU FOR REENTRANT SEGMENTS.
035565          *KCLEP                          % RASK CPU
035566          GO FAR OUT
035567
035567   SP11L: T:=CORMBANK                     % PASS THROUGH THE PAGE LIST FOR THIS SEGMENT
035570          DO WHILE X><0                   % TO THE END.
035571              *LOGPA@3 LDATX              % A:=LOGICAL PAGE NO.
035572              A SH 1 \/ 174000=:B         % B:=PIT POINTER.
035575              A:=PITPROTECT               % GET PROTECT PART OF PIT ENTRY FOR THIS PAGE.
035576              *PROTE@3 STATX              % A=:PROTECT.
035577              *PAGLI@3 LDXTX              % NEXT ENTRY IN PAGE LIST.
035600          OD
035601          GO FAR OUT
035602   RBUS
035606

035606   %=======================================================================
035606   %  37.5           S E T R T    C L E R T
035606   %
035606   %  ROUTINES FOR SETTING/CLEARING RT'S SYSTEM SEGMENT PIT ENTRIES
035606
035606   SUBR CLERT,SETRT
035606
035606   INTEGER XREG
035607   INTEGER ARRAY POINTER CPITADDR:=DPIT*200+174000+SYSST+5ESSZ+SYSST+5ESSZ
035610   DOUBLE  ARRAY POINTER DCPITADDR=CPITADDR
035610   INTEGER ENDLOOP
035611
035611   CLERT: X=:XREG                     % SAVE X
035612          SISYSEG-"5ESSZ"-1 SH 1=:ENDLOOP
035617          FOR X:=0 STEP 2 TO ENDLOOP DO 0=:CPITADDR(X) OD % CLEAR PIT.
035626          T:=CCFPAGE SH 1             % FIRST RT-COMMON PAGE.
035630          A:="UPITN*200+174000"=:X    % POINTER TO USERS NORMAL PAGE INDEX TABLE.
035632          X+T                         % POINTER TO FIRST RT-COMMON PAGE IN PIT.
035633          A+200=:T                    % LAST RT-COMMON PAGE IN PIT.
035635          DO WHILE X<<T               % REMOVE RT-COMMON FROM PIT.
035637              0=:X.S0                 % CLEAR PIT ENTRY
035640              X+2                     % NEXT RT-COMMON PAGE.
035641          OD
035642          GO OUT
035643
035643   SETRT: X=:XREG                     % SAVE X
035644          SISYSEG-"5ESSZ"-1 SH 1=:ENDLOOP
035651          A:=RTSYSG=:D:=162000        % RTSYSG: RT SYSTEM SEGMENT FIRST PAGE.
035654          FOR X:=0 STEP 2 TO ENDLOOP DO   % SET UP PIT FOR RT SYSTEM SEGMENT.
035660              AD=:DCPITADDR(X)        % STORE PIT ENTRY.
035661              D+1                     % NEXT PHYSICAL PAGE.
035662          OD
035664   OUT:   X:=XREG                     % RESTORE X
035665          EXIT                        % RETURN
035666   RBUS
035675
035675

035675   %==============================================================================
035675   % 37.6         S E G C H E C K
035675   %
035675   % SUBROUTINE TO CHECK IF A SEGMENT IS OK
035675   % B=ADDR. IN SEGMENT TABLE; RETURN: A=0 IF OK,ELSE -1
035675   % IF OK THE SEGMENT IS PLACED IN START OF SEGMENT LIST
035675
035675   SUBR SEGCHECK
035675   INTEGER XREG
035676   INTEGER POINTER LREG
035677   SEGCHECK:
035677          IF A:=B=0 THEN EXIT FI              % NO SEGMENT IS OK TOO.
035702          A:=L=:"LREG"                        % SAVE RETURN ADDRESS
035704          *LDASG SGSTA                        % A:=B.SGSTATUS
035714          IF A BIT 5SPTFIXED THEN             % IF SEGMENT IS FIXED IN PIT
035716              A:=0                            % OK
035717              GO LREG                         % RETURN
035720          FI
035720          A=:D                                % D:=SGSTATUS
035721          *LDASG FLAG                         % A:=B.FLAG
035731          IF A BIT 5INHB OR D=0 THEN          % SEGMENT NOT LOADED
035735              A:=B-SEGSTART SHZ -3=:T         % SEGMENT NUMBER IN T
035741              "S16ERR"; CALL GOMLEV
035743          FI
035743          IF A BIT 5OK THEN
035745              *LDASG SEGLI                    % A:=B.SEGLINK
035755              IF A><0 AND B><BSEGLINK THEN    % IF SEGMENT HAS PAGES IN MEMORY AND IS NOT THE FIRST.
035761                  X:=:B
035762                  CALL OUTSEGLINK             % REMOVE SEGMENT.
035763                  CALL INSEGLINK              % INSERT SEGMENT FIRST IN LIST.
035764                  X:=:B
035765              FI
035765              A:=0                            % RETURN OK.
035766          ELSE
035767              A:=-1                           % SEGMENT NOT OK
035770          FI
035770          GO LREG                             % RETURN
035771   RBUS
036000

036000   %==============================================================================
036000   % 37.7       C L N R E E N T R
036000   %
036000   % SUBROUTINE TO RESET NONREENTRANT PAGES IN PAGE INDEX TABLE
036000   % A=SEGMENT ADDRESS,X=RT-DESCR
036000   SUBR CLNREENTR, SP06J
036000
036000   INTEGER ARRAY POINTER PTBLE,RTDSCR
036002   INTEGER SVX
036003
036003   CLNREENTR:
036003          IF A=0 GO OUT           % NO SEGMENT: NO CLNREENTR.
036004   SP06J: GO SP06L
036005                                  % NEW CPU
036005          X=:D                    % SAVE X IN D
036006          X:=X.RTDLGADDR+5BITMAP  % X POINTS TO BITMAP
036010          T:=0                    % BANK 0
036011          *CNREK                  % CLEAR NONREENTRANT PAGES ACCORDING TO BITMAP.
036012          X:=D                    % RESTORE X
036013          EXIT                    % RETURN
036014
036014   SP06L: X=:SVX:=X.RTDLGADDR             % SAVE X
036016          X=:"RTDSCR"                     % X POINTS TO REGISTER BLOCK AND BITMAP.
036017          B=:T:=A                         % SAVE B IN T AND SET TO SEGMENT
036021          *LDASG LOGAD                    % A:=B.LOGADR
036031          A/\1700 SH 1+174000=:"PTBLE"    % MAKE PIT POINTER FOR THIS SEGMENT.
036035          5BITMAP=:D; B:=T                % DISPLACEMENT OF BITMAP INTO D, RESTORE B.
036040          FOR D TO "5BITMAP+7" DO         % TEST ALL BITMAP WORDS.
036043             "PTBLE"+40=:"PTBLE"          % POINTER TO END OF PIT FOR THIS WORD
036046             T:=0; X:="RTDSCR"+D; *LDATX  % GET BITMAP WORD
036052             IF A><0 THEN                 % IF ANY BIT SET IN THIS WORD THEN
036053                FOR X:=-20 DO             % TEST ALL BITS IN THIS WORD
036054                   A SHR -1               % MOVE BIT TO THE SIGN POSITION
036055                   IF A<0 THEN            % IF THIS BIT IS SET THEN
036056                       X=:T+X             % SAVE X IN T AND DOUBLE
036060                       0=:PTBLE(X)        % CLEAR PIT FOR THIS PAGE
036061                       X:=T               % RESTORE X
036062                   FI                     % ENDIF BIT
036062                OD                        % ENDDO BITS
036063             FI                           % ENDIF WORD
036063          OD                              % ENDDO WORDS
036065          X:=SVX                          % RESTORE X
036066   OUT:   EXIT                            % RETURN
036067   RBUS
036072

036072   %==============================================================================
036072   % 37.8         C S E G S   X C S E G S
036072   %
036072   % SUBROUTINES TO CLEAR SEGMENTS
036072   % CSEGS CLEARS IF SEGMENT IS PRESENT (A=SEGMENT POINTER), ALSO SPIT SEGMENTS
036072   % XCSEGS CLEARS ALWAYS, BUT NEVER SPIT SEGMENTS
036072
036072   SUBR CSEGS, XCSEGS, SP12J
036072   *"8N500
"036072   INTEGER POINTER IWDN5:=WNDN5*2+174000  % POINTER TO N500 WINDOW
036073   *"
"036073   INTEGER POINTER IWD41:=WND41*2+174000  % POINTER TO TERMINAL WINDOW
036074   INTEGER POINTER IWDBF:=WNDBF*2+174000  % POINTER TO DATA-BUFFER WINDOW
036075   INTEGER XREG
036076   INTEGER POINTER LREG
036077
036077   XCSEGS:X=:XREG:=L=:"LREG"  % SAVE X AND RETURN ADDRESS.
036102          0=:IWD41            % CLEAR TERMINAL WINDOW
036103          0=:IWDBF
036104   *"8N500
"036104          0=:IWDN5            % CLEAR ND500 WINDOW
036105   *"8LAMU
"036105          CALL CLAMU          % CLEAR LAMUS
036106   *"
"036106          X:=SEGMA            % SEGMENT A
036107          IF X >< 0 THEN      % IF PRESENT
036110              X:=:B
036111              *LDASG LOGAD    % A:=SEGMA.LOGADR
036121              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036125                  B=:A
036126                  CALL CLSEG
036127              FI
036127              X:=:B
036130          FI
036130          X:=SEGMB            % SEGMENT B
036131          IF X >< 0 THEN      % IF PRESENT
036132              X:=:B
036133              *LDASG LOGAD    % A:=SEGMA.LOGADR
036143              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036147                  B=:A
036150                  CALL CLSEG
036151              FI
036151              X:=:B
036152          FI
036152          X:=SEGMC            % SEGMENT C (REENTRANT SEGMENT)
036153          IF X >< 0 THEN      % IF PRESENT
036154              X:=:B
036155              *LDASG LOGAD    % A:=SEGMA.LOGADR
036165              IF A SH -6 >< SPIT THEN % DON'T CLEAR SEGMENTS IN SINTRAN PIT
036171                  B=:A
036172                  CALL CRSEG
036173              FI
036173              X:=:B
036174          FI
036174                                  % EXIT POINT
036174   OUT:   CALL CLERT              % CLEAR PIT ENTRIES FOR RT'S SYSTEM SEGMENT.
036175
036175   SP12J: CALL CHREENTPAGES       % ONLY FOR STD AND CX CPU.
036176          0=:SEGMA=:SEGMB=:SEGMC  % CLEAR CURRENT SEGMENT POINTERS.
036201          X:=XREG                 % RESTORE X
036202          GO LREG                 % RETURN
036203   *)FILL
036214
036214   CSEGS: IF A><SEGMA AND ><SEGMB AND ><SEGMC THEN    % IF A IS NONE OF THE CURRENT SEGMENTS.
036225              IF A><S3SEG THEN        % AND NOT CURRENT SPIT SEGMENT
036230                  EXIT                % THEN RETURN
036231              ELSE
036232                  0=:S3SEG            % CLEAR SPIT SEGMENT
036233                  T:=L=:"LREG"        % SAVE RETURN ADDRESS
036235                  CALL CLSEG          % CLEAR SPIT
036236                  GO LREG             % RETURN
036237          FI  FI
036237                                      % A IS ONE OF THE ACTIVE SEGMENTS.
036237          X=:XREG:=L=:"LREG"          % SAVE X AND RETURN ADDRESS.
036242          0=:IWD41                    % CLEAR TERMINAL WINDOW
036243          0=:IWDBF
036244   *"8N500
"036244          0=:IWDN5                    % CLEAR ND500 WINDOW
036245   *"8LAMU
"036245          CALL CLAMU                  % CLEAR LAMUS
036246   *"
"036246          X:=SEGMA                    % SEGMENT A
036247          IF X >< 0 THEN              % IF PRESENT
036250              X:=:B
036251              *LDASG LOGAD            % A:=SEGMA.LOGADR
036261              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036265                  0=:S3SEG
036266              FI
036266              B=:A; CALL CLSEG; X:=:B % CLEAR SEGMENT
036271          FI
036271          X:=SEGMB                    % SEGMENT B
036272          IF X >< 0 THEN              % IF PRESENT
036273              X:=:B
036274              *LDASG LOGAD            % A:=SEGMA.LOGADR
036304              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036310                  0=:S3SEG; FI
036311              B=:A; CALL CLSEG; X:=:B % CLEAR SEGMENT
036314          FI
036314          X:=SEGMC                    % SEGMENT C (REENTRANT SEGMENT)
036315          IF X >< 0 THEN              % IF PRESENT
036316              X:=:B
036317              *LDASG LOGAD            % A:=SEGMA.LOGADR
036327              IF A SH -6 = SPIT THEN  % RESET POINTER TO SEGMENTS IN SINTRAN PIT
036333                  0=:S3SEG; FI
036334              B=:A; CALL CRSEG; X:=:B % CLEAR SEGMENT
036337          FI
036337          GO OUT                      % GO TO EXIT POINT
036340
036340   RBUS
036350

036350   %=======================================================================
036350   %
036350   %   C H R E E N T P A G E S     CHECK FOR MODIFIED REENTRANT PAGES.
036350   %
036350   SUBR CHREENTPAGES, VSEVSX
036350
036350   INTEGER CSEG, BREG, ERINDICATOR, NXP
036354   INTEGER POINTER LREG
036355
036355   CHREENTPAGES:
036355           IF SEGMC=0 THEN EXIT FI                 % ONLY IF PROGRAM HAS REENTRANT SEGMENT.
036360           A=:CSEG=:X                              % X = REENTRANT SEGMENT
036362           T:=SEGTBANK; *SGSTA@3 LDATX             % A:=X.FLAG
036364           IF A NBIT 5WPM THEN EXIT FI             % IF NOT WRITE PERMIT THEN RETURN
036367           A:=L=:"LREG"; A:=B=:BREG                % SAVE L AND B
036373           0=:ERINDICATOR                          % NO ERRORS YET
036374           *BPAGL@3 LDXTX                          % X := BPAGLINK
036375           T:=CORMBANK
036376           DO WHILE X >< 0                         % DO UNTIL END OF PAGE LIST.
036377               *PROTE@3 LDATX                      % A:=X.PROTECT
036400               IF A BIT 5WIP THEN                  % PAGE IS MODIFIED.
036402                   *PAGLI@3 LDATX                  % GET POINTER TO NEXT PAGE
036403                   A=:NXP                          % AND SAVE IT.
036404                   *REMPG                          % REMOVE PAGE FROM REENTRANT SEGMENT.
036405                   CALL SHADLINK; A=:ERINDICATOR   % LINK PAGE TO SHADOW SEGMENT (SAVE PSBL. ERROR)
036407                   X:=NXP                          % RESTORE POINTER TO NEXT PAGE.
036410                   T:=CORMBANK                     % RESTORE T
036411               ELSE
036412                   *PAGLI@3 LDXTX                  % GET POINTER TO NEXT PAGE.
036413               FI
036413           OD
036414           BREG=:B
036416           T:=SEGTBANK; X:=CSEG; *PAGLI@3 LDATX    % A:=CSEG.PAGLINK
036421           IF A><0 THEN                            % IF SEGMENT IS IN SEGMENT LIST THEN
036422               *BPAGL@3 LDATX                          % IF REENTRANT SEGMENT BECAME EMPTY
036423               IF A=0 THEN CALL OUTSEGLINK FI          % THEN REMOVE IT FROM SEGMENT LIST.
036425           FI
036425           IF T:=ERINDICATOR >< 0 THEN             % IF NO SHADOW SEGMENT UNDER MODIFIED PAGE
036430               "S14ERR"; CALL GOMLEV               % THEN REPORT ERROR. (OUTSIDE SEGMENT BOUNDS)
036432           FI
036432           GO LREG
036433   RBUS
036443

036443   %=======================================================================
036443   %
036443   %   S H A D L I N K         LINK PAGE TO SHADOW SEGMENT.
036443   %
036443   %
036443   SUBR SHADLINK
036443
036443   INTEGER POINTER LREG
036444   INTEGER CME,ERPAGE,SHAINSTR(0); *SHA
036447
036447   SHADLINK:
036447           A:=L=:"LREG"
036451           X=:CME
036452           SEGMA; CALL INSRPAGE        % TRY TO LINK TO SEGMA.
036454           IF A=0 THEN                 % IF FAILED THEN
036455               SEGMB; CALL INSRPAGE    % TRY TO LINK TO SEGMB.
036457               IF A=0 THEN             % IF FAILED THEN
036460                   T:=CORMBANK         % LINK TO DUMMY SEGMENT AND REPORT ERROR.
036461                   *LOGPA@3 LDATX      % GET PAGE NUMBER.
036462                   A=:ERPAGE           % SAVE ERROR.
036463                   XSGRT=:B            % DUMMY SEGMENT.
036465                   *INSPG              % INSERT IN PAGE LIST.
036466                   *LDASG SGSTA        % COPY PROTECT ENTRY TO RESET WIP BIT
036476                   *PROTE@3 STATX
036477                   X:=B; T:=SEGTBANK
036501                   *SEGLI@3 LDATX      % GET SEGLINK OF DUMMY SEGMENT.
036502                   IF A=0 THEN         % IF DUMMY SEGMENT NOT IN SEGMENT LIST.
036503                       CALL INSEGLINK  % INSERT IN SEGMENT LIST
036504                       *SEGLI@3 LDATX  % AND MOVE TO END OF LIST.
036505                       A=:BSEGLINK
036506                   FI
036506                   A:=ERPAGE
036507                   GO LREG             % ERROR RETURN WITH PAGE IN A-REG.
036510           FI  FI
036510                                       % UPDATE BITMAP.
036510           T:=SEGTBANK; X:=SEGMC       % REENTRANT SEGMENTS
036512           *LOGAD@3 LDATX              % A:=LOGADR.
036513           A/\1700=:D                  % D:=BITMAPS LOGICAL START.
036515           T:=CORMBANK; X:=CME         % CORE MAP ENTRYS
036517           *LOGPA@3 LDATX              % A:=LOGPAGE.
036520           A-D; AD SHZ -4; D SHZ -14   % A:=WORD NO. IN BITMAP; D:=BIT NO. IN WORD.
036523           X:=SEGPROG.RTDLGADDR+5BITMAP+A  % X POINTS TO BITMAP WORD.
036527           A:=SHAINSTR                 % "SHIFT" INSTRUCTION.
036530           D+A                         % ADD "SHIFT" INSTRUCTION TO SHIFT COUNT.
036531           A:=1; *EXR SD               % SET A "1" AT WANTED POSITION IN WORD.
036533           A=:D; T:=0; *LDATX          % GET BITMAP WORD.
036536           A\/D; *STATX                % MASK IN THE NEW PAGE AND STORE.
036540           MIN "LREG"                  % OK: SKIP RETURN.
036541           GO LREG
036542   RBUS
036556

036556   %====================================================================
036556   %
036556   %   I N S R P A G E         INSERT PAGE IN SHADOW SEGMENT IF WITHIN IT.
036556   %                           A=SEGMENT,  X:=CORE MAP POINTER
036556   %
036556   %                           RETURN: A=0  :  NOT WITHIN THIS SEGMENT.
036556   %                                   A><0 :  OK, PAGE IS LINKED.
036556   SUBR INSRPAGE
036556
036556   INTEGER CME, SHSEG
036560   INTEGER POINTER LREG
036561
036561   INSRPAGE:
036561           IF A=0 THEN EXIT FI                 % NO SEGMENT: ON INSERT
036563           T:=SEGTBANK
036564           X=:CME:=A; *FLAG@3 LDATX            % A:=SEGMENT.FLAG
036567           IF A NBIT 5DEMAND THEN              % NON-DEMAND SEGMENT:
036571               X:=CME; A:=0; EXIT              %   CANNOT OVERLAP.
036574           FI
036574           A:=L=:"LREG"
036576           X=:SHSEG                            % SAVE SHADOW SEGMENT
036577           *LOGAD@3 LDDTX                      % A:=LOGADR; D:=SEGLENGTH
036600           X:=CME; T:=CORMBANK
036602           *LOGPA@3 LDXTX                      % X:=CME.LOGICAL PAGE
036603           IF X>=A AND X<D+A THEN              % IF WITHIN SEGMENT THEN
036610               T:=X                            % T:=LOGICAL PAGE
036611               SHSEG=:B                        % B:=SEGMENT POINTER
036613               X:=CME                          % X:=CORE MAP POINTER
036614               *INSPG                          % INSERT PAGE INTO SEGMENT.
036615               X:=:B; T:=SEGTBANK              % B:=COREMAP; X:=SEGMENT
036617               *SGSTA@3 LDATX                  % A:=SHSEG.SGSTATUS
036620               A/\777=:D                       % MASK "STATUS"-BITS
036622               X:=:B                           % X:=COREMAP; B:=SEGMENT
036623               T:=CORMBANK;  *PROTE@3 LDATX    %       INTO
036625               A/\177000\/D; *PROTE@3 STATX    %       COREMAP.PROTECT.
036630               X:=B; T:=SEGTBANK               % X:=SEGMENT
036632               *SEGLI@3 LDATX                  % A:=SEGMENT.SEGLINK
036633               IF A=0 THEN CALL INSEGLINK FI   % IF SEGMENT WAS EMPTY THEN
036635               A:=1                            % OK: PAGE IS LINKED TO SHADOW SEGMENT.
036636           ELSE
036637               A:=0                            % NOT WITHIN THIS SEGMENT.
036640           FI; X:=CME; GO LREG
036642   RBUS
036650

036650   %==============================================================================
036650   %
036650   %                S E G M E N T   F E T C H I N G
036650   %
036650   %==============================================================================
036650   % 37.10         S E G I N
036650
036650   % SUBROUTINE TO GET A NEW SEGMENT INTO CORE
036650   % B=SEGMENT ELEMENT; NO RETURN
036650
036650   SUBR SEGIN
036650
036650   INTEGER LSTCALLER  % ADDRESS OF LAST CALL TO SEGIN
036651   SYMBOL 5READ,5WRITE
036651
036651   SEGIN: A:=L=:LSTCALLER
036653          5CLOAD; X:=RTREF; CALL CALLMLEV(MLRESERVE)
036657          IF <0 THEN                      %SEG. TRANSFER GOING ON
036660             IF SWPFLAG><0 THEN
036662                X.STATUS BONE 5WAIT BONE 5SWWAIT=:X.STATUS    % SET IO-WAIT AND SWAP-WAIT
036666                RTREF+"BRESLINK"=:X
036671                DO WHILE X:=X.RESLINK><RTREF
036675                   IF X.TYPRING/\3=3 THEN     % RELEASE ANY SWAPPING RESOURCES HELD
036702                       X=:B:=RTREF
036704                       CALL CALLMLEV(MLBRELEASE)
036706                       RTREF+"BRESLINK"=:X    % RESTART FROM BEGINNING OF LIST
036711                   FI
036711                OD
036712             FI
036712             "RWAIT"; CALL GOMLEV ; *)FILL
036724          FI
036724                          % SINGLE THREAD FROM HERE.
036724          A:=B=:SEGREF    % SET SWAPPING SEGMENT.
036726          X=:SRTREF       % SET SWAPPING PROGRAM.
036727          NSEGA=:TSEGA    % SET SWAPPING PROGRAMS SEGMENTS.
036731          NSEGB=:TSEGB
036733          NSEGC=:TSEGC
036735          CALL XCSEGS     % CLEAR SEGMENTS FROM PIT.
036736          *LDASG FLAG     % A:=B.FLAG
036746          IF A NBIT 5DEMAND THEN      % IF NON DEMAND SEGMENT
036750              IF XSGRT=B GO FAR INSG1 % SEGMENT #1 IS HANDLED IN A SPECIAL WAY
036753              DO                      % UNTIL THE SEGMENT HAS GOT ENOUGH PAGES
036753                  *LDASG SEGLE        % A:=B.SEGLENGTH
036763                  A-=:NUMBER          % -SEGLENGTH =: NUMBER
036765                  *LDXSG BPAGL        % BEGINNING OF PAGE LIST.
036774                  IF X><0 THEN        % IF SEGMENT HAS PAGES IN MEMORY
036775                      *LDASG LOGAD    % A:=B.LOGADR
037005                      A=:D
037006                      *LDACM LOGPA    % A:=X.LOGPAGE
037014                      D-A=:A
037016                      A=:NUMBER       % NUMBER OF PAGES MISSING.
037017                  FI
037017              WHILE NUMBER><0         % NOT ENOUGH PAGES
037021                  CALL LRU; X:=:B         % FIND AN LRU SEGMENT AND PAGE.
037023                  *LDASG FLAG             % LRU.FLAG=:SAVEFLAG BZERO 5OK=:LRU.FLAG
037033                  A=:SAVEFLAG BZERO 5OK   %
037035                  *STASG FLAG             %
037045                  5WRITE; CALL TRNSEG     % WRITE LRU-PAGE TO DISK IF WRITTEN TO.
037047                  IF A><0 THEN            % IF TRANSFER WAS MADE THEN
037050                      A:=SAVEFLAG         % SAVEFLAG=:FLAG
037051                      *STASG FLAG         % RESTORE LRU.FLAG
037061                      GO FAR END1         % THIS PROGRAM HAS USED ENOUGH SWAPPING RESOURCES FOR
037062                      *)FILL              % THE TIME BEING, LET ANOTHER PROGRAM RUN.
037104                  FI
037104                  X:=:B; CALL LINKOVER    % LINK LRU-PAGE TO PAGE REQUESTING SEGMENT (SEGREF).
037106                  IF SAVEFLAG BIT 5DEMAND THEN % IF LRU-SEGMENT IS DEMAND SEGMENT.
037111                      X:=:B                    % THEN RESTORE LRU.FLAG
037112                      *STASG FLAG
037122                      X:=:B
037123                  FI
037123              OD
037124              A:=0    % READ ALL NECESSARY PAGES (NUMBER IS UNKNOWN)
037125          ELSE                    % DEMAND SEGMENT
037126

037126                                  % DEMAND SEGMENT
037126              IF A BIT 5OK THEN   % IF SEGMENT IS OK
037130                  -1=:NUMBER      % GET ONE PAGE
037132                  PNUMB=:CPNUMB   % PNUMB IS PAGEFAULTED PAGE
037134                  *LDASG FLAG     % SEGREF.FLAG
037144                  A BZERO 5OK     %             BZERO 5OK
037145                  *STASG FLAG     %                      =:SEGREF.FLAG
037155                  CALL LRU; X:=:B % FIND AN LRU SEGMENT AND PAGE.
037157                  *LDASG FLAG     % LRU.FLAG
037167                  A=:SAVEFLAG     %         =:SAVEFLAG
037170                  A BZERO 5OK     %                    BZERO 5OK
037171                  *STASG FLAG     %                             =:LRU.FLAG
037201                  5WRITE; CALL TRNSEG         % WRITE LRU-PAGE TO DISK IF WRITTEN TO.
037203                  X:=:B; CALL LINKOVER        % LINK LRU-PAGE TO PAGE REQUESTING SEGMENT.
037205                  IF SAVEFLAG BIT 5DEMAND THEN% IF LRU-SEGMENT IS DEMAND SEGMENT
037210                      X:=:B                    % THEN RESTORE LRU.FLAG
037211                      *STASG FLAG
037221                      X:=:B
037222                  FI
037222                  GO L1; *)FILL
037233   L1:        FI                  % ENDIF A BIT 5OK
037233              A:=-1               % READ 1 PAGE (DEMAND SEGMENT)
037234          FI
037234          A=:NUMBER
037235          5READ; CALL TRNSEG      % READ NUMBER OR ALL NEEDED PAGES.
037237
037237   %SEGMENT OK:
037237          *LDASG FLAG % FLAG
037247          A BONE 5OK  %      BONE 5OK
037250          *STASG FLAG %              =:FLAG
037260          IF A BIT 5DEMAND THEN                   % IF DEMAND SEGMENT
037262              *LDASG SGSTA
037272              IF A BIT 5NCLSEG OR B=S3SEG THEN    % AND (FILSEGM OR 5NSEGM OR FUSEGM OR S3SEGM) THEN
037277                  *LDXSG BPAGL                    % FIRST PAGE IN PAGE LIST (THE JUST READ PAGE)
037306                  CALL STPAGE                     % ENTER IT INTO PIT.
037307          FI; FI
037307   END1:  X:=SRTREF; 5CLOAD
037311          CALL CALLMLEV(MLRELEASE)    % RELEASE SWAPPING SEMAPHORE.
037313          IF X=RTREF THEN             % IF SWAPPING PROGRAM IS RUNNING THEN
037316              "RW"                    % LET IT CONTINUE.
037317          ELSE                        % ELSE
037320              "STUPR"                 % START HIGHEST PRIORITY READY PROGRAM.
037321          FI
037321          CALL GOMLEV                 % GO TO MONITOR LEVEL.
037322   *)FILL
037336
037336   % WRITE ALL SWAPPING PAGES WITH WIP-BIT SET, BACK TO DISC.
037336   % REMOVE ALL SEGMENTS FROM THE SEGMENT LINK, AND LINK ALL SWAPPING PAGES
037336   % TO THE DUMMY SEGMENT
037336   %
037336   INSG1: S3SEG;   CALL XCLSEG    % CLEAR OUT CURRENT SINTRAN SEGMENT.
037340          0=:S3SEG
037341          FILSEGM; CALL XCLSEG    % CLEAR OUT FILE SYSTEM.
037343   *"8N500
"037343          5NSEGM;  CALL XCLSEG    % CLEAR OUT ND500 MONITOR.
037345   *"8RFAC
"037345          FUSEGM;  CALL XCLSEG    % CLEAR OUT REMOTE FILE ACCESS.
037347   *"
"037347          DO
037347             -1=:NUMBER           % ONE PAGE AT A TIME
037351             CALL LRU; X:=:B      % FIND LRU SEGMENT AND PAGE.
037353             *LDASG FLAG          % LRU.FLAG
037363             A=:SAVEFLAG BZERO 5OK %        =:SAVEFLAG BZERO 5OK
037365             *STASG FLAG          %                             =:LRU.FLAG
037375             5WRITE; CALL TRNSEG  % WRITE LRU PAGE TO DISK IF WRITTEN TO.
037377             IF A><0 THEN         % IF TRANSFER WAS MADE THEN
037400                A:=SAVEFLAG       % SAVEFLAG=:FLAG
037401                *STASG FLAG       % RESTORE LRU.FLAG
037411             FI
037411             X:=:B; CALL LINKOVER % LINK LRU PAGE TO DUMMY SEGMENT.
037413          OD                      % EXIT FROM THIS LOOP IS MADE IN LRU WHEN
037414   RBUS                           % NO MORE SWAPPING PAGES CAN BE FOUND.
037427

037427   %==============================================================================
037427   % 37.11      L R U
037427
037427   %SUBROUTINE TO FIND LEAST RECENTLY USED SEGMENT
037427   %ENTRY: B=SEGREF
037427   % RETURN: X=LRU SEGMENT POINTER
037427
037427   SUBR LRU
037427   INTEGER ARRAY TSGN:=(TSEGB,TSEGC,TSEGA,TSEGC,TSEGA,TSEGB,TSEGC,TSEGB)
037437   INTEGER POINTER LREG=?; INTEGER R01
037440   LRU:   A:=L=:"LREG"
037442          *LDASG SGSTA
037452          IF A BIT 5NCLSEG AND B><BSEGLINK THEN   % IF THE PAGE REQUESTING SEGMENT
037457              *LDASG SEGLI                        % IS A "SPECIAL" SEGMENT NOT AT THE
037467              IF A><0 THEN                        % HEAD OF THE SEGMENT LIST, AND HAS
037470                  X:=:B                           % PAGES IN MEMORY,
037471                  CALL OUTSEGLINK                 % THEN MOVE IT TO THE HEAD OF THE
037472                  CALL INSEGLINK                  % SEGMENT LIST TO AVOID TRASHING
037473                  X:=:B                           % BECAUSE OF THESE SEGMENTS.
037474          FI  FI
037474          *LDASG FLAG % A:=B.FLAG
037504          IF X:=MAXP << 200 AND A BIT 5DEMAND THEN % IF THERE IS A LIMIT TO THE NUMBER
037512              *LDXSG BPAGL    % X:=B.BPAGLINK      % OF PAGES A SEGMENT MAY HAVE IN MEMORY,
037521              D:=0                                 % COUNT PAGES IN PAGE LIST.
037522              DO WHILE X><0                        % IF THE PAGE REQUESTING SEGMENT
037523                  *LDXCM PAGLI % X:=X.PAGLI        % HAS MORE THAN THE MAXIMUM
037531                  D+1                              % ALLOWED NUMBER OF PAGES IN MEMORY,
037532              OD                                   % THEN TAKE PAGES FROM ITSELF.
037533              IF D>=MAXP THEN B=:X; GO OUT FI
037540          FI
037540          B=:D    % SAVE B IN D                   % CHECK WHETHER THE PROGRAM USES
037541          FOR X:=-3 DO                            % THREE SEGMENTS OR LESS.
037542              IF TSEGS(X)=0 THEN B:=D; GO NOTF FI % NO, IT USES AT MOST TWO SEGMENTS.
037546              X:=:A=:B
037550              *LDXSG SEGLI    % X:=B.SEGLINK
037557              IF X=0 THEN B:=D; GO NOTF FI        % NO, SEGMENT HAS NO PAGES IN MEMORY.
037563              A=:X
037564          OD
037565          B:=D    % RESTORE B             % YES, SEGMENT HAS THREE SEGMENTS IN MEMORY.
037566          CALL GETLAST                    % CHECK IF LAST SEGMENT IS USED BY THIS PROGRAM
037567          IF =0 GO OUT                    % NO, USE THIS AS LRU SEGMENT.
037570                      % ALL THREE SEGMENTS PRESENT, TAKE ONE OF THE TWO OTHERS.
037570          FOR X:=-3 DO WHILE TSEGS(X)><B OD   % FIND INDEX OF SEGREF IN TSEGS.
037575          R01-,=:R01; X+3+X-A                 % COMPUTE INDEX INTO TSGN TO SELECT
037603          *1BANK                              % ONE OF THE OTHERS.
037604          X:=TSGN(X)                          % TSGN IS A LOCAL ARRAY AND MUST BE
037605          *2BANK                              % ACCESSED IN 1 BANK MODE.
037606          X:=X.S0; GO OUT                     % USE THIS AS LRU SEGMENT.
037610
037610   *)FILL
037622   INTEGER POINTER LREG
037623   INTEGER LRUS2
037624
037624   %      THE PROGRAM HAS AT MOST TWO SEGMENTS IN MEMORY.
037624   NOTF:  CALL GETLAST; IF =0 GO OUT  % IF LAST SEGMENT IS NOT USED BY THE PROGRAM, USE IT AS LRU.
037626          CALL GETLAST; X=:LRUS2      % TRY THE NEXT LAST.
037630          IF <0 THEN CALL GETLAST     % IF ALSO IN USE GET ANOTHER.
037632              IF <0 THEN              % AT MOST TWO SEGMENTS IN MEMORY.
037633                  X=:D:=:B=:T; *LDASG FLAG
037646                  A/\100 SHZ -5               % GET DEMAND STATUS OF THIS SEGMENT.
037650                  X:=LRUS2=:B; *LDXSG FLAG
037661                  *BLDA 60 DX; BSTA 0 DA      % GET DEMAND STATUS OF THE OTHER.
037663                  B:=T; X:=D                  % A IS NOW IN THE RANGE 0 TO 3
037665                  GOSW ERR,FRSTDEM,OUT,BOTHDEM % DEPENDING ON THE 5DEMAND BITS
037672   BOTHDEM:       IF X><B GO OUT              % TWO DEMAND SEGMENTS
037674   FRSTDEM:       X:=LRUS2                    % LRUS2 IS THE FIRST
037675          FI  FI
037675   % X=SEGMENT TO BE REMOVED(LRU-SEG):
037675   OUT:   X=:A; CALL CSEGS                    % CLEAR PAGE TABLES IF SEGMENT IS ACTIVE.
037677          X:=:B; *LDASG SEGLI                 % IF SEGMENT IS NOT IN THE SEGMENT
037710          IF A=0 THEN X:=:B; GO NOTF; FI      % LIST, THEN FIND ANOTHER.
037713          *LDASG SGSTA                        % IF THE LRU SEGMENT IS A "SPECIAL" SEGMENT
037723          IF A BIT 5NCLSEG AND BIT 5WPM THEN  % AND HAS WRITE PERMIT
037727              CALL GETWIP                     % THEN MOVE THE WIP BITS TO THE CORE MAP.
037730          FI
037730          CALL SEGSORT; CALL RANDOM           % FIND A PAGE TO BE SWAPPED OUT.
037732          X=:T                                % SAVE SEGREF IN T.
037733          *LDXSG BPAGL                        % POINTER TO FIRST PAGE OF SEGMENT.
037742          *LDACM PROTE                        % PROTECT ENTRY FOR THIS PAGE.
037750          X:=B; B:=T                          % RESTORE X(LRU) AND B(SEGREF).
037752          IF A BIT 5FIX THEN                  % DO NOT TAKE FIXED PAGES.
037754              X=:A                            % MOVE LAST SEGMENT TO HEAD OF SEGMENT LIST.
037755              T:=SEGTBANK; X:=BSEGLINK        % FIRST SEGMENT.
037757              *PRESE@3 LDXTX                  % FIRST.PREVIOUS = LAST
037760              X=:BSEGLINK                     % LAST =: FIRST
037761              X:=A                            % RESTORE X.
037762              GO FAR NOTF                     % GET ANOTHER SEGMENT.
037763          FI
037763          GO LREG                             % EXIT.
037764   *)FILL
037776   ERR:   IF SEGREF=XSGRT THEN                % SEGMENT 1, FIXC OR SET5NONDEMAND.
040002             "CLFIE"=:B; X:=SRTREF            % RELEASE SWAPPING SEMAPHORE.
040005             CALL CALLMLEV(MLBRELEASE)
040007             0=:X.ACT1SEG=:X.ACT2SEG          % RESET PROGRAMS SEGMENTS.
040011             "STUPR"; CALL GOMLEV             % GO STUPR.
040013          FI
040013          SRTREF=:RTREF
040015          A:="S19ERR"                         % ERROR 19.
040016          CALL GOMLEV                         %          AND GO PRTEXT.
040017   *)FILL
040030
040030   % LOCAL SUBROUTINE TO FIND LAST SEGMENT
040030   % RETURN: X=LRU-SEG;IF =TSEGA OR TSEGB OR =TSEGC :A<0
040030   INTEGER LREG2
040031   GETLAST:B=:D   % SAVE B IN D
040032          IF BSEGLINK=:B=0 THEN CALL ERRFATAL FI  % EMPTY SEGMENT LIST IS FATAL ERROR
040036          *LDXSG PRESE    % X:=BSEGLINK.PRESEG    % GET LAST SEGMENT IN LIST
040045          IF X=TSEGA OR X=TSEGB OR X=TSEGC THEN
040056   MOVESEG:   IF B><X THEN        % IF NOT FIRST SEGMENT THEN
040060                  A:=L=:LREG2
040062                  CALL OUTSEGLINK % MOVE SEGMENT TO HEAD OF LIST
040063                  CALL INSEGLINK
040064                  LREG2=:L
040066              FI
040066              A:=-1               % SEGMENT IS IN USE BY CURRENT PROGRAM
040067          ELSE
040070
040070              GO SKIP2
040071              SRTREF; CALL GETXSEG    % CHECK IF WANTED LRU IS SPECIAL SEGMENT
040073              IF X=A GO MOVESEG       % AND IF IT IS, MOVE IT TO HEAD OF LIST.
040075
040075   SKIP2:     A:=0
040076          FI
040076          B:=D    % RESTORE B
040077          EXIT
040100   RBUS
040112

040112   %==============================================================================
040112   %              G E T X S E G
040112   %
040112   %      FIND OUT WHETHER OR NOT A PROGRAM USES A SPECIAL SEGMENT.
040112   %      RETURNS SEGMENT POINTER OR ZERO.
040112   %      ENTRY: A=RT-PROGRAM.
040112   %      EXIT:  A=SEGMENT POINTER.
040112   %
040112   SUBR GETXSEG
040112
040112   INTEGER ARRAY SGPNT:=(0,0,0,FUSEGM,FILSEGM,5NSEGM)
040120   INTEGER XREG,TREG
040122
040122   GETXSEG: T=:TREG               % SAVE T.
040123          X=:XREG:=A              % SAVE X, X=RT-PROG.
040125          X.ACTPRI SHR 5 /\ 17    % COMPUTE PIT NO. OF NPT.
040130          IF A>=3 AND A<=5 THEN   % IF SPECIAL PIT THEN
040136              *1BANK
040137              X:=SGPNT(A); *2BANK % GET SEGMENT POINTER ADDRESS.
040142              A:=X.S0             % GET SEGMENT POINTER.
040143          ELSE
040144              A:=0                % NOT SPECIAL PIT.
040145          FI
040145          X:=XREG; T:=TREG
040147          EXIT
040150   RBUS
040152

040152   %==============================================================================
040152   % 37.12         S E G S O R T
040152   %
040152   %      SUBROUTINE TO PUT NON-USED PAGES FIRST IN PAGE LINK
040152   %      B=SORT SEGMENT
040152   %
040152   %
040152   SUBR SEGSORT, SP07J, SP07L % SEGSORT FOR NEW ENHANCED CX CPU
040152   INTEGER XREG
040153   INTEGER POINTER LREG
040154
040154   SEGSORT:IF B=XSGRT THEN EXIT FI        % DO NOT SORT DUMMY SEGMENT
040160
040160   SP07J:  GO SP07L
040161           *ILDAS FLAG
040162           IF A NBIT 5DEMAND THEN EXIT FI % DO NOT SORT NON DEMAND SEGMENTS
040165           X=:XREG:=L=:"LREG"
040170           *ILDXS BPAGL                   % START OF PAGE LIST
040171           DO WHILE X >< 0                % PASS BY UNUSED PAGES AT HEAD OF LIST
040172               *ILDAC PROTE               % GET PROTECT WORD
040173           WHILE A NBIT 5PGU AND A NBIT 5FIX  % WHILE PAGE IS UNUSED
040177               *ILDXC PAGLI               % GET NEXT PAGE
040200           OD
040201           DO WHILE X >< 0                % PASS THROUGH REST OF LIST
040202               *ILDAC PAGLI               % GET NEXT PAGE
040203               A=:D                       % AND SAVE IN D
040204               *ILDAC PROTE               % GET PROTECT WORD
040205               IF A NBIT 5PGU AND A NBIT 5FIX THEN % UNUSED PAGE IS FOUND
040211                   *ILDAC LOGPA           % REMEMBER THE LOGICAL PAGE NUMBER
040212                   A=:T                   % IN T
040213                   *IREMP                 % LINK OUT
040214                   *IINSP                 % INSERT FIRST
040215               FI
040215               X:=D                       % RESTORE NEXT PAGE POINTER
040216           OD
040217           X:=XREG
040220           GO LREG                        % RETURN
040221   RBUS
040223

040223   SUBR SP07L     % SEGSORT FOR CX CPU WITH ECO ONLY
040223   INTEGER XREG
040224   INTEGER POINTER LREG
040225
040225   SP07L:  %%% IF B=XSGRT THEN EXIT FI    % DO NOT SORT DUMMY SEGMENT
040225           *LDASG FLAG
040235           IF A NBIT 5DEMAND THEN EXIT FI % DO NOT SORT NON DEMAND SEGMENTS
040240           X=:XREG:=L=:"LREG"
040243           *LDXSG BPAGL                   % START OF PAGE LIST
040252           DO WHILE X >< 0                % PASS BY UNUSED PAGES AT HEAD OF LIST
040253               *LDACM PROTE               % GET PROTECT WORD
040261           WHILE A NBIT 5PGU              % WHILE PAGE IS UNUSED
040263               *LDXCM PAGLI               % GET NEXT PAGE
040271           OD
040272           DO WHILE X >< 0                % PASS THROUGH REST OF LIST
040273               *LDACM PAGLI               % GET NEXT PAGE
040301               A=:D                       % AND SAVE IN D
040302               *LDACM PROTE               % GET PROTECT WORD
040310               IF A NBIT 5PGU THEN        % UNUSED PAGE IS FOUND
040312                   *LDACM LOGPA           % REMEMBER THE LOGICAL PAGE NUMBER
040320                   A=:T                   % IN T
040321                   *REMPG                 % LINK OUT
040322                   *INSPG                 % INSERT FIRST
040323               FI
040323               X:=D                       % RESTORE NEXT PAGE POINTER
040324           OD
040325           X:=XREG
040326           GO LREG                        % RETURN
040327   RBUS
040333

040333   %==============================================================================
040333   % 37.13         R A N D O M
040333
040333   % SUBROUTINE TO TAKE A RANDOM(PREFERABLY NOT USED) PAGE AND PUT IT FIRST
040333   % ENTRY:     B=SEGMENT
040333   SUBR RANDOM, SP08J, SP08L      % RANDOM FOR ENHANCED NEW CX CPU
040333   INTEGER XREG,XN:=3614,CC:=33031,AA:=12465
040337   INTEGER POINTER LREG
040340   RANDOM:
040340   SP08J: GO SP08L
040341
040341          *ILDAS FLAG                 % A:=B.FLAG
040342          IF A NBIT 5DEMAND THEN      % NO RANDOM ON NON DEMAND SEGMENTS.
040344              EXIT FI
040345          X=:XREG:=L=:"LREG"
040350          *ILDXS BPAGL                % GET BEGINNING OF PAGE LIST.
040351          D:=0                        % COUNT PAGES IN D.
040352          DO
040352          WHILE X >< 0                % DO TILL END OF PAGE LIST
040353              *ILDAC PROTE            % A:=X.PROTECT
040354          WHILE A NBIT 5PGU
040356              D+1                     % COUNT UNUSED PAGES
040357              *ILDXC PAGLI            % X:=X.PAGLI
040360          OD
040361          IF D=0 THEN                 % IF NO UNUSED PAGES THEN
040363             DO WHILE X >< 0
040364                D+1                   % COUNT USED PAGES
040365                *ILDXC PAGLI
040366             OD
040367          FI
040367          D=:T; XN*AA+CC=:XN
040374          A BZERO 17=:D:=0; *RDIV ST  % COMPUTE WHICH PAGE TO TAKE
040400          *ILDXS BPAGL                % X:=B.BPAGLINK
040401          IF D > 1 THEN               % IF THE FIRST WAS NOT SELECTED
040404              FOR D-+1+1 TO 0 DO
040411                  *ILDXC PAGLI        % X:=X.PAGLI
040412              OD
040414              *ILDAC LOGPA            % A:=X.LOGPAGE
040415              A=:T
040416              *IREMP                  % MOVE THE SELECTED PAGE TO THE
040417              *IINSP                  % BEGINNING OF THE PAGE LIST
040420          FI
040420          X:=XREG
040421          GO LREG                     % RETURN
040422   RBUS
040423

040423   SUBR SP08L    % RANDOM FOR CX CPU WITH ECO ONLY
040423   INTEGER XREG,XN:=3614,CC:=33031,AA:=12465
040427   INTEGER POINTER LREG
040430
040430   SP08L: *LDASG FLAG                 % A:=B.FLAG
040440          IF A NBIT 5DEMAND THEN      % NO RANDOM ON NON DEMAND SEGMENTS.
040442              EXIT FI
040443          X=:XREG:=L=:"LREG"
040446          *LDXSG BPAGL                % GET BEGINNING OF PAGE LIST.
040455          D:=0                        % COUNT PAGES IN D.
040456          DO
040456          WHILE X >< 0                % DO TILL END OF PAGE LIST
040457              *LDACM PROTE            % A:=X.PROTECT
040465          WHILE A NBIT 5PGU
040467              D+1                     % COUNT UNUSED PAGES
040470              *LDXCM PAGLI            % X:=X.PAGLI
040476          OD
040477          IF D=0 THEN                 % IF NO UNUSED PAGES THEN
040501             DO WHILE X >< 0
040502                D+1                   % COUNT USED PAGES
040503                *LDXCM PAGLI
040511             OD
040512          FI
040512          D=:T; XN*AA+CC=:XN
040517          A BZERO 17=:D:=0; *RDIV ST  % COMPUTE WHICH PAGE TO TAKE
040523          *LDXSG BPAGL                % X:=B.BPAGLINK
040532          IF D > 1 THEN               % IF THE FIRST WAS NOT SELECTED
040535              FOR D-+1+1 TO 0 DO
040542                  *LDXCM PAGLI        % X:=X.PAGLI
040550              OD
040552              *LDACM LOGPA            % A:=X.LOGPAGE
040560              A=:T
040561              *REMPG                  % MOVE THE SELECTED PAGE TO THE
040562              *INSPG                  % BEGINNING OF THE PAGE LIST
040563          FI
040563          X:=XREG
040564          GO LREG                     % RETURN
040565   RBUS
040571

040571   %==============================================================================
040571   % 37.14      T R N S E G  R W S E G M  X T R N S E G
040571
040571   %SUBROUTINE TO READ OR WRITE PAGES OF A SEGMENT; NUMBER=-NEEDED PAGES
040571   % ENTRY:     A=READ/WRITE FLAG, B=SEGMENT
040571   %RETURN WITH A=0 IF NO TRANSFER HAS BEEN DONE
040571
040571   SUBR TRNSEG,RWSEGM,XTRNSEG,INRWSEGM
040571
040571   INTEGER WRITTEN=?,MODUS=?,CNUMBER=?,LMASSNO=?,XREG=?,XREG2=?,BREG=?,CABLPAGE=?
040571   DOUBLE BLSTX=?
040571   INTEGER POINTER LREG
040572
040572   % ENTRY: D=NUMBER OF PAGES TO TRANSFER
040572   %        X=CORMAP ELEMENT OF FIRST PAGE TO TRANSFER
040572   %        A=READ/WRITE FLAG
040572   %        B=SEGMENT ADDRESS
040572   %
040572   XTRNSEG: A=:MODUS:=RTREF=:SRTREF:=D; 0=:WRITTEN; CALL RWSEGM
040600            "STUPR"; CALL GOMLEV
040602
040602
040602   TRNSEG: A=:MODUS:=L=:"LREG"; X=:XREG
040606          0=:WRITTEN                  % NO TRANSFER IS MADE YET.
040607          NUMBER=:CNUMBER             % COPY NUMBER OF PAGES TO LOCAL VARIABLE.
040611          *LDXSG BPAGL                % (X:=BPAGLINK) GET FIRST CORE MAP ELEMENT
040620          FOR CNUMBER DO WHILE X><0
040621             *LDACM PROTE             % A:=X.PROTECT
040627             IF A=:D/\160000\/MODUS=0 OR MODUS SHR 5WIP/\D><0 THEN
040637                                      % IF READ TRANSFER AND PAGE NOT IN MEMORY
040637                                      % OR WRITE TRANSFER AND PAGE IS MODIFIED THEN
040637                1; CALL RWSEGM        % TRANSFER 1 PAGE.
040641             FI
040641             *LDXCM PAGLI             % (X:=X.PAGLI) GET NEXT CORE MAP ELEMENT
040647          OD
040651          IF WRITTEN><0 THEN          % IF A TRANSFER HAS BEEN MADE THEN
040653              X:=SRTREF; LMASSNO      % RELEASE DISK
040655              CALL CALLMLEV(MLRELEASE)
040657          FI
040657          A:=WRITTEN                  % RETURN TRANSFER FLAG IN A
040660          X:=XREG; GO LREG            % RETURN
040662   *)FILL
040674

040674   INTEGER NPGS=?,BMASS=?
040674   INTEGER POINTER LREG2=?
040674
040674   RWSEGM:A=:NPGS                     % SAVE NUMBER OF PAGES TO TRANSFER.
040675          A:=L=:"LREG2":=B=:BREG      % SAVE RETURN ADDRESS AND B.
040701          X=:XREG2                    % SAVE X.
040702          IF WRITTEN=0 THEN           % IF NO TRANSFER HAS YET BEEN MADE.
040704                                      % THEN RESERVE DISK RESOURCES.
040704              *LDASG FLAG             % SEGMENT FILE NO. IS IN TOP OF FLAG.
040714              A SHZ -15               % 3 UPPER BITS.
040715              MASSUNIT(A) SH 6        % DISK UNIT FOR SEGMENT FILE
040720              A+MODUS+60=:SWPMTMODUS  %   + MODUS(READ/WRITE)+ 60(TRANSFER) =: SWAP PARAMETER.
040723              ABLPAGE(X)=:CABLPAGE    % NUMBER OF DISK BLOCKS PER PAGE.
040725              A*NPGS=:SWPBLPAGE       % NUMBER OF BLOCKS TO TRANSFER =: SWAP PARAMETER.
040727              X=:T+X                  % SAVE X IN T AND DOUBLE.
040731              DBLST(X)=:BLSTX         % DISK ADDRESS FOR THIS SEGMENT FILE (DOUBLE WORD).
040733              X:=T                    % RESTORE X (SEGMENT FILE NO.)
040734              IF D=0 AND A=0 THEN CALL ERRFATAL FI    % ZERO DISK ADDRESS IS FATAL ERROR.
040740              GO L1
040741
040741   INTEGER WRITTEN,MODUS,CNUMBER,LMASSNO,XREG,XREG2,BREG,CABLPAGE,NPGS,BMASS
040753   DOUBLE BLSTX
040755
040755   % DISC TRANSFER ERROR, ABORT PROGRAM CURRENTLY USING SEGADM.
040755   %
040755   ERR:   BMASS=:B                    % RESTORE DF-POINTER.
040757          "DISKERR"; CALL GOMLEV      % PRINT ERROR MESSAGE AND
040761                                      % ABORT PROGRAM
040761   *)FILL
040772
040772   INTEGER POINTER LREG2
040773   L1:        MASSNO(X)=:LMASSNO      % LOGICAL UNIT FOR THE DISK OF THIS SEGMENT FILE.
040775              CALL CALLMLEV(MLLOGPH)  % GET DATAFIELD ADDRESS
040777              A=:BMASS=:B             % AND SAVE (BMASS).
041001              X:=SRTREF               % FOR SWAPPING PROGRAM
041002              CALL CALLMLEV(MLBRSERVE)% TRY TO RESERVE DISK.
041004              IF A<0 THEN             % IF THE DISK WAS IN USE THEN
041005                  IF SWPFLAG><0 THEN  % IF SWAPPING STRATEGY >< 0
041007                      BMASS=:B        % DISK DATAFIELD
041011                      A:="LNK1SWAP"   % START "1SWAP".
041012                      CALL GOMLEV     % ON MONITOR LEVEL.
041013                  FI
041013                                      % SWAPPING STRATEGY = 0
041013                  A:=5CLOAD           % RELEASE SWAPPING SEMAPHORE.
041014                  CALL CALLMLEV(MLRELEASE)
041016                  IF X=RTREF THEN "RWAIT" ELSE "STUPR" FI
041024                  CALL GOMLEV         % RESTART THIS OR ANOTHER PROGRAM.
041025                  *)FILL
041037              FI
041037                                      % DISK IS NOW RESERVED.
041037              MIN WRITTEN; BREG=:B    % SET TRANSFER FLAG, RESTORE B
041042          FI
041042          X:=XREG2; *LDACM LOGPA      % RESTORE X, GET LOGICAL PAGE NUMBER.
041051          A=:D
041052          *LDASG LOGAD                % FIRST LOGICAL PAGE OF THIS SEGMENT.
041062          D-A                         % FIND PAGE NUMBER RELATIVE TO START OF SEGMENT.
041063          *LDASG MADR                 % MASS STORAGE ADDRESS OF THIS SEGMENT.
041073          A+D*CABLPAGE=:L             % COMPUTE DISK BLOCK ADDRESS FOR THIS PAGE.
041076          BLSTX; D+L; A:=A+C
041101          AD=:SWPMASSADR              % DISK ADDRESS =: SWAP PARAMETER.
041102          A:=X SHZ -2                 % A:=PHYSICAL PAGE NO. TO TRANSFER TO/FROM.
041104          D:=0; AD SHZ -6=:SWPCOREADR % PHYSICAL PAGE =: SWAP PARAMETER.
041107   *"8SWLG
"041107          IF CSWLG><0 AND MODUS BIT "0" THEN        % COUNT PAGES WRITTEN BACK
041114             *MIN I (SNWP2; SKP; MIN I (SNWP1; JMP *+1
041120          FI
041120   *"
"041120          A:=BMASS=:B:="SWPPARLIST"   % B:=DATAFIELD, A:=SWAP PARAMETER LIST.
041123          CALL CALLMLEV(PMTRANS)      % PERFORM DISK TRANSFER.
041125                                      % RETURNS WITH STATUS IN A-REG.
041125          IF A BIT 4 GO ERR           % ERROR OCCURED IN TRANSFER.
041127          X:=BREG=:B:=XREG2           % RESTORE B AND X
041132          IF MODUS><0 THEN            % IF PAGE WAS WRITTEN TO DISK THEN
041134              *LDACM PROTE            % RESET WIP BIT
041142              A BZERO 5WIP
041143          ELSE                        % ELSE PAGE WAS READ FROM DISK
041144              *LDASG SGSTA            % GET PROTECT ENTRY FROM SEGMENT ENTRY
041154          FI
041154          *STACM PROTE                % STORE PROTECT ENTRY IN CORE MAP ENTRY.
041162          GO LREG2
041163   *)FILL
041174
041174   RBUS
041174

041174   %==============================================================================
041174   % 37.16         L I N K O V E R
041174
041174   %SUBROUTINE TO LINK PAGES OVER TO REQUESTING SEGMENT
041174   % ENTRY: B=REQ.SEGMENT (SEGREF)
041174   %        X=LRU-SEGM
041174
041174   SUBR LINKOVER
041174   INTEGER CURPAGE=?,CNUMBER=?,LRUSEG=?
041174   INTEGER POINTER LREG=?
041174   LINKOVER: A:=L=:"LREG"
041176          X=:LRUSEG                   % SAVE LRU SEGMENT
041177          NUMBER=:CNUMBER             % AND LOCAL COPY OF NUMBER OF PAGES TO LINK.
041201          B=:A                        % CLEAR SEGMENTS IF PAGE REQUESTING
041202          CALL CSEGS                  % IS ACTIVE.
041203          *LDASG SGSTA                % A:=B.FLAG
041213          IF A BIT 5FIX THEN          % FIXED SEGMENTS SHOULD NEVER COME HERE.
041215              CALL ERRFATAL FI          % FATAL ERROR.
041216          A:=B-SEGSTART=:D:=0         % VERIFY THAT THIS IS A VALID
041222          T:=5SEGSIZE; *RDIV ST       % SEGMENT TABLE POINTER.
041224          IF D><0 THEN CALL ERRFATAL FI % NO, FATAL ERROR.
041227          LRUSEG=:D                   % D=LRUSEG, B=SEGREF
041231          GO L1
041232   INTEGER CURPAGE,CNUMBER,LRUSEG
041235   INTEGER POINTER LREG
041236   *)FILL
041243   L1:    FOR CNUMBER DO              % TRY TO GET CNUMBER NUMBER OF PAGES.
041243              D:=:B                   % D=SEGREF, B=LRUSEG
041244              *LDXSG BPAGL            % X:=LRUSEG.BPAGLINK
041253          IF X=0 GO OUT               % WHILE PAGES LEFT IN LRUSEG.
041254              *LDACM PROTE            % A:=X.PROTECT
041262          IF A BIT 5WIP OR BIT 5FIX GO OUT % WHILE THERE ARE NON MODIFIED PAGES TO TAKE.
041266              X=:CURPAGE              % SET CURRENT PAGE.
041267              IF A BIT 5NCLSEG THEN   % IF "SPECIAL" SEGMENT THEN
041271                  CALL CLPAGE         % REMOVE PAGE PROM PIT
041272              FI
041272              *REMPG                  % REMOVE PAGE FROM SEGMENT
041273              B:=:D                   % B=SEGREF, D=LRUSEG
041274              *LDXSG BPAGL            % X:=SEGREF.BPAGLINK
041303              IF X=0 THEN             % IF SEGMENT HAS NO PAGES IN CORE
041305                  *LDASG SEGLI        % A:=SEGREF.SEGLINK
041315                  IF A=0 THEN         % IF SEGMENT IS NOT IN SEGMENT LIST
041316                      X:=B
041317                      CALL INSEGLINK  % LINK IT IN
041320                      X:=0
041321                  FI
041321                  *LDASG LOGAD        % A:=SEGREF.LOGADR
041331                  A-NUMBER            % COMPUTE PAGE NUMBER FOR NON DEMAND SEGMENTS.
041332              ELSE
041333                  *LDACM LOGPA        % A:=X.LOGPAGE
041341              FI
041341              A=:T                    % T=PREVIOUS LOGICAL PAGE NUMBER
041342              X:=CURPAGE              % CURRENT PAGE.
041343              *LDASG FLAG             % A:=SEGREF.FLAG
041353              IF A NBIT 5DEMAND THEN  % IF NON DEMAND SEGMENT
041355                  T-1                 % T=LOGICAL PAGE NUMBER FOR THIS PAGE
041356              ELSE                    % ELSE DEMAND SEGMENT
041357                  T:=CPNUMB           % T=PAGE FAULTED PAGE.
041360              FI
041360              *INSPG                  % INSERT PAGE INTO SEGREF
041361              *STZCM PROTE            % CLEAR THE PROTECT ENTRY SO THE PAGE WILL BE READ FROM DISK
041367          OD
041371          B:=:D                       % B=LRUSEG, D=SEGREF
041372   OUT:   *LDASG BPAGL                % A:=LRUSEG.BPAGLINK
041402          X:=B                        % X=LRUSEG
041403          IF A=0 THEN                 % IF LRU SEGMENT TURNED EMPTY
041404              CALL OUTSEGLINK FI      % THEN LINK IT OUT
041405          B:=D                        % B=SEGREF
041406          GO LREG                     % RETURN
041407   RBUS
041420

041420   %============================================================================
041420   % 37.21         X O V E R L A P
041420   %                                  (CALLED BY PROGRAMMING FROM APPL. LEVEL)
041420   % SUBROUTINE TO SEARCH FOR OVERLAP BETWEEN A REENTRANT SEGMENT AND
041420   %  A SHADOW SEGMENT AND IF NECESSARY DELETE PAGES FROM THE LATTER.
041420   %
041420   % ENTRY:     A=SEGMENT TABLE POINTER, T=REENTRANT SEGMENT
041420   %
041420   SUBR XOVERLAP, SP09J, SP09L    % XOVERLAP FOR ENHANCED CX CPU
041420   INTEGER RSTRT,REND,NXP
041423
041423   XOVERLAP: IF A=0 GO OUT                    % NO SHADOW SEGMENT: NO OVERLAP.
041424   SP09J: GO SP09L
041425
041425          A=:B                                % B=SHADSEG.
041426          *ILDAS SEGLI                        % SEGMENT LINK
041427          IF A=0 GO OUT                       % IF SEGMENT IS NOT IN SEGMENT LIST: NO OVERLAP.
041430          B:=:T                               % B=REENTSEG, T=SHADSEG.
041431          *ILDAS LOGAD                        % R.LOGADR
041432          A=:RSTRT                            %         =:START OF REENTRANT SEGMENT.
041433          *ILDAS SEGLE                        % R.SEGLENGTH
041434          A+RSTRT =:REND                      % + START OF REENTSEG =: END OF REENTRANT SEGMENT.
041436          B:=:T                               % B=SHADSEG, T=REENTSEG.
041437          *ILDXS BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041440          DO WHILE X><0                       % DO FOR ALL PAGES IN SHADOW SEGMENT.
041441              *ILDAC LOGPA                    % GET LOGICAL PAGE NUMBER
041442              IF A>=RSTRT  AND A<REND THEN    % IF WITHIN REENTRANT SEGMENT THEN OVERLAP
041450                  CALL CLPAGE                 % REMOVE PAGE FROM PAGE INDEX TABLES.
041451                  *ILDAC PAGLI                % GET POINTER TO NEXT PAGE
041452                  A=:NXP                      % AND SAVE IT.
041453                  *IREMP                      % REMOVE PAGE FROM SHADOW SEGMENT.
041454                  T:=XSGRT:=:B                % B=DUMMY SEGMENT(XSGRT), T=SHADSEG.
041456                  *IINSP                      % INSERT IT IN DUMMY SEGMENT.
041457                  *ILDAS SGSTA                % COPY PROTECT ENTRY TO RESET 5WIP BIT
041460                  *ISTAC PROTE
041461                  *ILDAS SEGLI                % SEGLINK OF DUMMY SEGMENT.
041462                  IF A=0 THEN                 % IF DUMMY SEGMENT WAS EMPTY
041463                      B:=:X
041464                      CALL INSEGLINK          % INSERT IN SEGMENT LIST
041465                      X:=BSEGLINK:=:B
041467                      *ILDAS SEGLI            % MOVE TO END OF LIST
041470                      A=:BSEGLINK
041471                  FI
041471                  B:=T                        % B=SHADSEG.
041472                  X:=NXP                      % RESTORE POINTER TO NEXT PAGE.
041473              ELSE                            % NO OVERLAP
041474                  *ILDXC PAGLI                % GET POINTER TO NEXT PAGE
041475              FI
041475          OD
041476          *ILDAS BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041477          IF A=0 THEN                         % IF IT BECAME EMPTY
041500              B=:X; CALL OUTSEGLINK FI        % REMOVE IT FROM THE SEGMENT LIST.
041502   OUT:   *WAIT                               % RETURN TO CALLING LEVEL
041503          CALL ERRFATAL
041504   RBUS
041513

041513   SUBR SP09L   % XOVERLAP FOR CX CPU WITH ECO ONLY
041513   INTEGER RSTRT ,REND,NXP
041516
041516   SP09L: %%% IF A=0 GO OUT
041516          A=:B                                % B=SHADSEG.
041517          *LDASG SEGLI                        % SEGMENT LINK
041527          IF A=0 GO OUT                       % IF SEGMENT IS NOT IN SEGMENT LIST: NO OVERLAP.
041530          B:=:T                               % B=REENTSEG, T=SHADSEG.
041531          *LDASG LOGAD                        % R.LOGADR
041541          A=:RSTRT                            %         =:START OF REENTRANT SEGMENT.
041542          *LDASG SEGLE                        % R.SEGLENGTH
041552          A+RSTRT =:REND                      % + START OF REENTSEG =: END OF REENTRANT SEGMENT.
041554          B:=:T                               % B=SHADSEG, T=REENTSEG.
041555          *LDXSG BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041564          DO WHILE X><0                       % DO FOR ALL PAGES IN SHADOW SEGMENT.
041565              *LDACM LOGPA                    % GET LOGICAL PAGE NUMBER
041573              IF A>=RSTRT  AND A<REND THEN    % IF WITHIN REENTRANT SEGMENT THEN OVERLAP
041601                  CALL CLPAGE                 % REMOVE PAGE FROM PAGE INDEX TABLES.
041602                  *LDACM PAGLI                % GET POINTER TO NEXT PAGE
041610                  A=:NXP                      % AND SAVE IT.
041611                  *REMPG                      % REMOVE PAGE FROM SHADOW SEGMENT.
041612                  T:=XSGRT:=:B                % B=DUMMY SEGMENT(XSGRT), T=SHADSEG.
041614                  *INSPG                      % INSERT IT IN DUMMY SEGMENT.
041615                  *LDASG SGSTA                % COPY PROTECT ENTRY TO RESET 5WIP BIT
041625                  *STACM PROTE
041633                  *LDASG SEGLI                % SEGLINK OF DUMMY SEGMENT.
041643                  IF A=0 THEN                 % IF DUMMY SEGMENT WAS EMPTY
041644                      B:=:X
041645                      CALL INSEGLINK          % INSERT IN SEGMENT LIST
041646                      X:=BSEGLINK:=:B
041650                      *LDASG SEGLI            % MOVE TO END OF LIST
041660                      A=:BSEGLINK
041661                  FI
041661                  B:=T                        % B=SHADSEG.
041662                  X:=NXP                      % RESTORE POINTER TO NEXT PAGE.
041663              ELSE                            % NO OVERLAP
041664                  *LDXCM PAGLI                % GET POINTER TO NEXT PAGE
041672              FI
041672          OD
041673          *LDASG BPAGL                        % SHADOW SEGMENTS PAGE LIST.
041703          IF A=0 THEN                         % IF IT BECAME EMPTY
041704              B=:X; CALL OUTSEGLINK FI        % REMOVE IT FROM THE SEGMENT LIST.
041706   OUT:   *WAIT                               % RETURN TO CALLING LEVEL
041707          CALL ERRFATAL
041710   RBUS
041722

041722   %==================================================
