031775   @DEV (S-S-L)PH-P2-RESTART:NPL
031775

031775   * SRSTA=*
031775   INTEGER 9PWFAIL              % ><0 WHEN POWER-FAIL HAS OCCURED
031776   %==============================================================================
031776   %
031776   %   3 8 . 0     S Y S T E M   S T A R T  A N D  S T O P
031776   %
031776   %==============================================================================
031776   % 38.1       P W F A I L   R E S T A R T   S E T P T A B L
031776   %
031776   @ICR;
031776   % INITIAL VALUES OF PCR REGISTERS FOR ALL INTERRUPT LEVELS
031776   INTEGER ARRAY PCCS:=(
031776           NMPIT+ADPIT+ERNG2+000,
031777           NMPIT+ADPIT+ERNG2+ALEVB,
032000           NMPIT+ADPIT+ERNG2+MLEVB,
032001           NIPIT+ADPIT+ERNG3+SLEVB,
032002           NRPIT+ADPIT+ERNG2+BLEVB,
032003           NXPIT+ADPIT+ERNG2+50,
032004           64,
032005           74,
032006           104,
032007           114,
032010           NMPIT+ADPIT+ERNG2+LV10B,
032011           NIPIT+ADPIT+ERNG2+LV11B,
032012           NMPIT+ADPIT+ERNG2+LV12B,
032013           NMPIT+ADPIT+ERNG2+LV13B,
032014           NMPIT+ADPIT+ERNG2+LV14B,
032015           174);
032016   @CR;
032016
032016   INTEGER ARRAY LEV1=?
032016   INTEGER LEV14=?,URERTP=?
032016
032016   SUBR PWFAIL,SETPTABL,RESTART
032016
032016
032016   DISP 0
032016   INTEGER TTINF=NBPROGS
032016   INTEGER TTSPEED=CNBATCHES
032016   INTEGER CCNTRG=CPRVTSIZE
032016   INTEGER CURBX=SWPDRIVER
032016   INTEGER CURPAGE=CBPRTSIZE
032016   PSID
032016
032016
032016   INTEGER ARRAY QMSDF:=(DRFIE,DRFI2,BIGDI,BIGD2,BIGD3,BIGD4,GIGDI,GIGD2,WIGDI,WIGD2,-1)
032031   DISP 0; REAL FS0, RCTRG=CTRG, RTRG=TRG; PSID
032031
032031   %========================================================================
032031   %            P I N H B T C A C H E   -   P E N A B C A C H E
032031   %
032031   % LOCAL SUBROUTINES TO ENABLE/DISABLE PAGE IN CACHE FOR THE ND-110 COMPUTER
032031   %
032031   INTEGER CINSTR
032032   INTEGER CEINSTR
032033   INTEGER FLGCACHE
032034
032034   PINHBTCACHE:
032034          0=:FLGCACHE
032035          *LDA (BSKP ONE 00 DD; LDT (BSKP ONE 170 DD
032037          GO PCFELLS
032040   PENABCACHE:
032040          100000=:FLGCACHE
032042          *LDA (BSKP ZRO 00 DD; LDT (BSKP ZRO 170 DD
032044   PCFELLS: A=:CINSTR; T=:CEINSTR
032046          0=:CURPAGE
032047          DO WHILE CURPAGE<<=37777
032053             T:=MBCACHINHIBIT; A:=CURPAGE SHZ -4+CACHINHIBIT=:X; *LDATX
032061             A=:D; T:=CINSTR
032063             FOR X:=-20 DO
032064                *EXR ST
032065                GO NPENABLE
032066                A:=CURPAGE+FLGCACHE; *TRR CILP           % ENABLE/DISABLE PAGE IN CACHE
032071   NPENABLE:    MIN CURPAGE
032072             WHILE CEINSTR><T
032075                T+10
032076             OD
032077          OD; *TRR CCLR
032101          EXIT
032102
032102   *)FILL
032112
032112   *"8N500
"032112   %==========================================================================
032112   %           5 P F 1   -   5 P F 2   -   5 P F 3
032112   %
032112   % SUBROTINE TO THE SINTRAN III POWER FAIL ROUTINE ON LEVEL 14
032112   %
032112   INTEGER 5PFFL,5PFCPUDF
032114   5PF1:  1=:5PFFL; GO 5PF
032117   5PF2:  2=:5PFFL; GO 5PF
032122   5PF3:  3=:5PFFL
032124   5PF:   X:="S5CPUDF"+DPITPHYS
032126          DO WHILE X<<="E5CPUDF"+DPITPHYS
032132             X=:5PFCPUDF; T:=DPITBANK
032134             *AAX CPUAV; LDATX; AAX -CPUAV
032137             IF A=:B/\5CPUTYPE><0 THEN
032142                *AAX MAIL1; LDDTX
032144                A=:T; D=:X; *AAX X5CLR; STZTX; AAX -X5CLR
032151                X:=5PFCPUDF; T:=DPITBANK
032153                IF 5PFFL-1 = 0 THEN
032156                   *AAX C5PWF; STZTX; AAX -C5PWF
032161                ELSE IF A-2 = 0 THEN
032164                   *AAX C5STA; LDATX
032166                   A BONE BHPFAIL; *STATX; AAX -C5STA
032171                FI; FI
032171                *AAX C5PWF; LDATX
032173                IF A=0 THEN
032174                   IF A:=B/\5CPUTYPE = SAMSON THEN
032201                      A:=1; *STATX
032203                      GO NCPUPF
032204                   FI
032204                   *AAX HDEV-C5PWF; LDATX
032206                   A+RSTA5=:T; *IOXT
032211                   IF A BIT 5ILOC THEN
032213                      T+"TERM5-RSTA5"; *IOXT
032215                      FOR X:=-10 DO; OD
032217                      T+"RSTA5-TERM5"; *IOXT
032221                      IF A BIT 5ILOC THEN
032223                            GO NCPUPF      % NEXT CPU IF THIS ONE DID NOT STOP
032224                      FI
032224                   FI;
032224                   T:=DPITBANK; A:=1
032226                   *AAX C5PWF-HDEV; STATX
032230                   *AAX HDEV-C5PWF; LDATX
032232                   A+LCON5=:T; A:=10; *IOXT
032236                   T+"RSTA5-LCON5"; *IOXT
032240                   A BONE 5POWOF; T+"LSTA5-RSTA5"; *IOXT
032243                   A:="0"; T+"LCON5-LSTA5"; *IOXT
032246                   A:=400; *IOXT
032250                   T+"SLOC5-LCON5"; *IOXT
032252                   T+"TERM5-SLOC5"; *IOXT
032254                FI
032254             FI
032254   NCPUPF:   X:=5PFCPUDF+5CPUDFSZ
032256          OD; EXIT
032260   *)FILL
032264   *"-8N500
"032264
032264   %==========================================================
032264   %      C C L N R E E N T R A N T
032264   %
032264   % LOCAL SUBROUTINE TO CLEAR "NON-REENTRANT" PAGES OF
032264   % A REENTRANT SEGMENT
032264   %
032264   INTEGER ARRAY POINTER RTDSCR,PTBLE
032266   CCLNREENTRANT:
032266          X:=X.RTDLGADDR
032267          X=:"RTDSCR"                     % X POINTS TO REGISTER BLOCK AND BITMAP.
032270          X:=SEGMC; T:=SEGTBANK           % SAVE B IN T AND SET TO SEGMENT
032272          *LOGAD@3 LDATX
032273          A/\1700 SH 1+174000=:"PTBLE"    % MAKE PIT POINTER FOR THIS SEGMENT.
032277          5BITMAP=:D; *POF                % DISPLACEMENT OF BITMAP INTO D, TURN OFF PAGING TO ACCESS PITS.
032302          FOR D TO "5BITMAP+7" DO         % TEST ALL BITMAP WORDS.
032305             "PTBLE"+40=:"PTBLE"          % POINTER TO END OF PIT FOR THIS WORD
032310             T:=0; X:="RTDSCR"+D; *LDATX  % GET BITMAP WORD
032314             IF A><0 THEN                 % IF ANY BIT SET IN THIS WORD THEN
032315                FOR X:=-20 DO             % TEST ALL BITS IN THIS WORD
032316                   A SHR -1               % MOVE BIT TO THE SIGN POSITION
032317                   IF A<0 THEN            % IF THIS BIT IS SET THEN
032320                       X=:T+X             % SAVE X IN T AND DOUBLE
032322                       0=:PTBLE(X)        % CLEAR PIT FOR THIS PAGE
032323                       X:=T               % RESTORE X
032324                   FI                     % ENDIF BIT
032324                OD                        % ENDDO BITS
032325             FI                           % ENDIF WORD
032325          OD                              % ENDDO WORDS
032327          *PON ; EXIT                     % TURN ONN PAGING AND RETURN.
032331   *)FILL
032335
032335   %=========================================================
032335   %       C S E T R T
032335   %
032335   % LOCAL SUBROUTINE TO SET-UP RT'S SYSTEM SEGMENT IN PIT.
032335   %
032335   INTEGER ARRAY POINTER CPITADDR:=DPIT*200+174000+SYSST+5ESSZ+SYSST+5ESSZ
032336   DOUBLE  ARRAY POINTER DCPITADDR=CPITADDR
032336   CSETRT:T:=DPITBANK; X:="RTSYSG"; *LDATX
032341          A=:D; SISYSEG-"5ESSZ"-1 SH 1 =:T
032347          A:=162000; *POF
032351          FOR X:=0 STEP 2 TO T DO  % SET UP PIT FOR RT SYSTEM SEGMENT.
032354              AD=:DCPITADDR(X); D+1
032356          OD; *PON
032361          EXIT
032362   *)FILL
032366
032366   %=================================================
032366   %      T B U S P E E D
032366   %
032366   % LOCAL SUBROUTINE TO SET SPEED FOR TERMINAL BUFFER AND MULTITERMINAL INTERFACE
032366   % THE SPEED IS FOUND IN INPUT DATAFIELD; -1 MEANS DO NOT SET SPEED
032366   % THE ROUTINE ALSO CHECKS WHICH TYPE OF TERMINAL INTERFACE IS USED
032366   % AND IN CASE OF BUFF.TERM CONTROLLER SETS 5FIFO IN TINFO.
032366   % IF CNTREG IS DEFINED WITH CHARACTER LENGTH EQUAL 8-BITS 58BIT IS
032366   % ALSO SET IN TINFO.
032366
032366   TBUSPEED: A:=L=:"CLINK"
032370          T:=RPIFPHPAGE SH 12
032372          "TMRTE"-"PITEX"+T=:ETMRADDR-2=:TMRADDR
032400          T:=RPIFPHPAGE SHZ -6=:RPIBANK
032403          DO
032403             T:=RPIBANK; X:=TMRADDR; *LDATX
032406          WHILE A><-1 OR X=ETMRADDR
032414             IF X=ETMRADDR OR X=0 GO NXT
032421             IF A.TYPRING BIT 5TERM THEN
032425                T:="TINFO"; CALL XGTDFADDR; A=:TTINF
032430                T:="HDEV"; CALL XGTDFADDR
032432                IF A NBIT 2 AND A><0 THEN               % TERMINAL INPUT
032435                   T:=A+DST; *IOXT
032440                   IF A BIT 10 THEN                     % FIFO TERMINAL
032442                      TTINF BONE 5FIFO=:TTINF
032445                   FI
032445                   T:="CNTREG"; CALL XGTDFADDR
032447                   IF A/\14000=0 THEN                   % 8-BIT MODE
032451                      TTINF BONE 58BIT=:TTINF
032454                   FI
032454                   T:="TINFO"; TTINF; CALL XSTDFADDR
032457                   T:="TSPEED"; CALL XGTDFADDR; A=:TTSPEED
032462                   IF A><-1 THEN                        % IF TSPEED >< -1 THEN
032465                      T:="HDEV"; CALL XGTDFADDR         % SET BAUD RATE AS
032467                      T:=A+1; A:=TTSPEED; *IOXT         % SPESIFIED IN TSPEED.
032472                   FI
032472                FI
032472   NXT:      FI; MIN TMRADDR
032473          OD; GO CLINK
032475   *)FILL
032506
032506   %=======================================================
032506   %      C L A D V
032506   %
032506   % LOCAL SUBROUTINE TO CLEAR ALL IOX-DEVICES EXCEPT
032506   % USER-RESERVED IOX'S
032506   %
032506   INTEGER 5IX:=0, 500IOX
032510   INTEGER ARRAY 5IOXARR(0)     % ND-500 IOX TABLE
032510   *"8N500; 60  ;"              % ASCENDING IOX PLEASE !
""032511   *"8CP55; 560 ;"
"032511   *"8CP53; 660 ;"
""032512   *"8CP54; 760 ;"
""032513   *"8CP52; 1060;"
""032514   *"
"032514   * -1
032515
032515   % CLEAR ALL DEVICES EXCEPT CUSTOMER RESERVED DEVICES
032515   INTEGER CCIOX
032516   CLADV: A:=L=:"CLINK"; *1BANK
032521          5IOXARR(0)=:500IOX; *2BANK
032525          0=:CCIOX
032526          DO
032526             IF CCIOX=500IOX THEN                   % ND-500 DEVICE NUMBER
032532                CALL 5MCST; X:=5IX+1=:5IX; *1BANK
032537                5IOXARR(X)=:500IOX; *2BANK
032542                CCIOX+20=:CCIOX; GO NXIOX
032546             FI; X:=0
032547             *1BANK
032550             DO WHILE X<<"USDVSIZE*2"               % DO NOT CLEAR USER RESERVED DEV.NO'S
032553                AD:=USIOXTAB(X)
032554                IF A<<=CCIOX AND D>>=T THEN
032561                   A:=D/\177774=:CCIOX; GO NXIOX
032565                FI; X+2
032566             OD
032567             T:=CCIOX+"DCONT"; A:=20; *IOXT     % CLEAR DEVICE
032573   NXIOX: WHILE CCIOX+4><0
032576             A=:CCIOX; *2BANK
032600          OD; *2BANK
032602          GO CLINK
032603   *)FILL
032607
032607   %=======================================================
032607   %          S S G I P T A B L E
032607   %
032607   % LOCAL SUBROUTINE TO SET UP A SEGMENT IN PIT
032607   %
032607   % ENTRY:     X=SEGMENT ADDRESS
032607   %
032607   INTEGER BREG,XWIP
032611   RSSGIPTABLE:
032611          IF X=0 THEN EXIT FI
032614          0=:XWIP; GO FELLS
032616   SSGIPTABLE:
032616          IF X=0 THEN EXIT FI
032621          T:=SEGTBANK; *SGSTA@3 LDATX
032623          IF A BIT 5WPM THEN A:=0 BONE 5WIP ELSE A:=0 FI
032631          A=:XWIP
032632   FELLS: A:=B=:BREG
032634          T:=SEGTBANK; *BPAGL@3 LDXTX
032636          T:=CORMBANK
032637          *POF
032640          DO WHILE X><0
032641             D:=X SHZ -2; *LOGPA@3 LDATX
032644             A SH 1+174000=:B; *PROTE@3 LDATX
032650             A\/XWIP; AD=:DS0; *PAGLI@3 LDXTX
032653          OD; BREG=:B; *PON
032657          EXIT
032660
032660
032660   INTEGER CSGTENTRY,CSGTBANK,CCMBANK
032663
032663   %======================================================
032663   %            S S G F P T A B L E
032663   %
032663   % LOCAL SUBROUTINE TO REMOVE A SEGMENT FROM PIT
032663   %
032663   % ENTRY:     X=SEGMENT ADDR
032663   %
032663   SSGFPTABLE:
032663          IF X><0 THEN
032664             T:=CSGTBANK; *BPAGL@3 LDXTX
032666             T:=CCMBANK
032667             DO WHILE X><0
032670                *LOGPA@3 LDATX
032671                A SH 1+174000=:B; 0=:S0
032675                *PAGLI@3 LDXTX
032676             OD
032677          FI; EXIT
032700
032700   %======================================================
032700   %            S S W I P I N F O
032700   %
032700   % LOCAL SUBROUTINE TO SAVE WIP BITS FOR A SEGMENT
032700   %
032700   % ENTRY:     X=SEGMENT TABLE ADDR
032700   %
032700   SSWIPINFO:
032700          IF X=0 THEN EXIT FI
032703          X=:CSGTENTRY; T:=CSGTBANK; *SGSTA@3 LDATX
032706          IF A BIT 5WPM THEN
032710             *BPAGL@3 LDXTX
032711             T:=CCMBANK
032712             DO WHILE X><0
032713                *LOGPA@3 LDATX
032714                 A SH 1+174000=:B
032717                 IF S0><0 THEN
032721                    *PROTE@3 STATX
032722                 FI; *PAGLI@3 LDXTX
032723             OD
032724          FI; EXIT
032725   *)FILL
032730
032730

032730   %============================================================================
032730   %           P W F A I L
032730   %
032730   %ROUTINE ON LEVEL 14, ACTIVATED BY POWER FAIL
032730   %CAN ALSO BE CALLED BY THE STOP-SYSTEM COMMAND
032730   %
032730   INTEGER LEVC,SRBI(0); *SRB 10
032732   DOUBLE ARRAY SWPTWIDOWS(5)                       % SAVED DPIT-WINDOWS
032744   PWFAIL: CALL FAR 5PF1
032745          -15=:LEVC; SRBI; X:="LEV1"
032751          FOR LEVC DO; *EXR SA                      % SAVE REGISTERS ON ALL LEVELS
032752                X+10; A+10
032754          OD
032756          FOR X:=1 TO 15 DO                         % SAVE PCR ON LEVEL 1-13
032762             A:=X SHZ 3=:T; *TRA 14
032766             A/\177603+T+4=:PCCS(X)
032772          OD;  *TRA PIE
032775          T:=DPITBANK; X:="PIEREG+DPITPHYS"; *STATX
033000          A=:9PWFAIL; *TRA PID
033002          X:="PIDREG+DPITPHYS"; *STATX
033004          CALL FAR 5PF2
033005          CALL FAR 5PF3
033006          "WNDBF+WNDBF+174000"=:B; X:=0; T:=5
033012          DO WHILE T><0; DS0=:SWPTWINDOWS(X); X+2; B+2; T-1; OD % SAVE DPIT WINDOWS
033022          T:=DPITBANK; X:="CORMBANK+DPITPHYS"; *LDATX
033025          A=:CCMBANK                                   % PHYS ADDR OF CORMBANK
033026          X:="SEGTBANK+DPITPHYS"; *LDATX
033030          A=:CSGTBANK                                  % PHYS ADDR OF SEGTBANK
033031          X:="SEGMA+DPITPHYS"; *LDATX
033033          X:=A; CALL FAR SSGFPTABLE
033035          X:="SEGMB+DPITPHYS"; T:=DPITBANK; *LDATX
033040          X:=A; CALL FAR SSGFPTABLE
033042          X:="SEGMC+DPITPHYS"; T:=DPITBANK; *LDATX
033045          X:=A; CALL SSWIPINFO     % SAVE WIP-BITS FOR SEGMC
033047          GO PWAIT; *)FILL
033071   PWAIT: *WAIT; JMP *
033073
033073   %=============================================
033073   %      R E S T A R T
033073   %
033073   %- - - POWER UP AGAIN:
033073   RESTART:
033073          2000; *TRR IIE; TRA IIC                    %ENABLE POWER FAIL
033076          A:=6; *TRR PCR; SEX
033101          *2BANK
033102          X:=174000; A:=0; D:=0
033105          DO WHILE X><0; AD=:X.DS0; X+2 OD           % CLEAR ALL PITS
033111          "HWINFO"+DPITPHYS=:X; T:=DPITBANK; *LDATX
033116          IF A/\377 >= 2  THEN
033122             *143500                                 % EXTENDED MICROPROGRAM
033123          FI
033123
033123   % IF DISK DMA WAS ACTIVE AT POWER FAIL TIME, FORCE NEW CALL
033123
033123          X:="QMSDF"; X=:B
033125   QL0:   IF X:=S0=-1 GO SETPTABL
033131          IF X=0 GO QL1
033132          A:=DPITPHYS; X+A; % T:=DPITBANK
033134          100; *AAX DIFTC; STATX         % WAIT 100B*3 SECS. BEFORE TIMOUT ON DISC
033137          *AAX BUSFL-DIFTC; STZTX        % FORCE NEW CALL
033141          *AAX TACNS-BUSFL; LDATX; AAX TACOU-TACNS; STATX
033145          *AAX RCTRG-TACOU; LDATX
033147          A=:L; *LDDTX 10; AAX RTRG-RCTRG; STDTX 10; COPY SL DA; STATX
033155          *AAX CXRG-RTRG; LDATX; AAX XRG-CXRG; STATX
033161   QL1:   B+1; GO QL0
033163   *)FILL
033171
033171   % LOCAL SUBROUTINE TO MAP A SEGMENT INTO A PIT
033171   %
033171   % ENTRY: A=SEGMENT NUMBER
033171   %
033171   SGMAP: A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *BPAGL@3 LDXTX
033176          T:=CORMBANK
033177          DO WHILE X><0
033200             D:=X SHZ -2        % D=PHYSICAL PAGE
033202             *LOGPA@3 LDATX
033203             A SH 1 +174000=:B  % B=PIT ENTRY
033206             *PROTE@3 LDATX
033207             *POF; STD ,B; PON
033212             *PAGLI@3 LDXTX
033213          OD; "XSBFIELD"=:B
033216          EXIT
033217
033217   % LOCAL SUBROUTINE TO MAP THE I/O BUFFER AREA INTO PITS
033217   %
033217   % ENTRY: A=PIT NUMBER
033217   %
033217   IOMAP: A*200+174000=:X; A:=ASCBUF SHZ -12 SH 1; X+A
033226          A:=IOBFPHPAGE=:D:=162000
033231          DO
033231             *POF; STD ,X; PON
033234          WHILE D><IOBLPHPAGE
033237             D+1; X+2
033241          OD; EXIT
033243
033243   % LOCAL SUBROUTINE TO MAP COMMON-CODE INTO PITS
033243   %
033243   % ENTRY: A=PIT NUMBER
033243   %
033243   CCMAP: A*200+174000=:X; D:=0; T:=CMLPHPAGE
033250          A:=162000
033251          DO
033251             *POF; STD ,X; PON
033254          WHILE D><T
033256             D+1; X+2
033260          OD; EXIT
033262   *)FILL
033272
033272
033272   SETPTABL:
033272          "XSBFIELD"=:B
033274          CALL IPTMAP           % USE PIT #0 AS NPIT AND PIT #17 AS APIT
033275          X:="DPIT*200+174000"; A:=162000; D:=0
033300          *POF; STD ,X; PON            % MAP "MICRO-COMMON" INTO DPIT
033303          D+1; X+2; *POF; STD ,X; PON
033310          CALL LOCOSTORE        % LOAD NEW MICRO PROGRAMM
033311   % MAP I/O BUFFERS INTO RPIT AND MPIT
033311          RPIT; CALL IOMAP
033313          MPIT; CALL IOMAP
033315   % MAP COMMON CODE INTO THE NECESSARY PITS
033315          RPIT; CALL CCMAP
033317          SPIT; CALL CCMAP
033321          FPIT; CALL CCMAP
033323          FUPIT;CALL CCMAP
033325          5PIT; CALL CCMAP
033327          XPIT; CALL CCMAP
033331          MPIT; CALL CCMAP
033333          IPIT; CALL CCMAP
033335          5ECOM; CALL FAR SGMAP           % MAP EXT. COMMON SEGENT (RPIT)
033337          A:=0; X:=0                      % ALSO MAP INTO MPIT,IPIT
033341          T:=4=:L:="RPIT*200+174000+26"=:D:="MPIT*200+174000+26"; *MOVPP
033347          T:=4=:L:="RPIT*200+174000+26"=:D:="IPIT*200+174000+26"; *MOVPP
033355          5RPIT; CALL FAR SGMAP           % MAP RPIT SEGMENT
033357          5MPIT; CALL FAR SGMAP           % MAP MPIT SEGMENT
033361          5IPIT; CALL FAR SGMAP           % MAP IPIT SEGMENT
033363          5DPIT; CALL FAR SGMAP           % MAP DATA SEGMENT
033365          42; CALL FAR SGMAP              % MAP 1 PAGE IN SPIT (EDIT-ROUTINES)
033367          55PIT; CALL FAR SGMAP           % MAP 5PIT SEGMENT
033371   *"8FLMN
"033371          GO BYP1; *)FILL
033403
033403   % MAP PIT HANDLING ROUTINES ON RING 3 IN IPIT
033403
033403   BYP1:  A:="SRNG3" SHZ -12 SH 1 + "IPIT*200+174000"=:X
033410          A:="EERG3" SHZ -12 SH 1 + "IPIT*200+174000"=:T
033415          A:=163000; *POF
033417          DO A=:X.S0; WHILE X><T; X+2 OD
033424          *PON
033425          0=:PWRFREST
033426   % INITIALIZE PCR ON ALL LEVELS EXCEPT LEVEL 0
033426          *1BANK
033427          FOR X:=1 TO 17 DO
033433             PCCS(X); *TRR PCR
033435          OD; *2BANK
033440          IF PIDREG><0 THEN                         % AFTER POWER FAIL
033442             X:="S5CPUDF"
033443             DO WHILE X<<="E5CPUDF"
033446                X.TTMR=:X.TMR
033450                X+5CPUDFSZ
033451             OD
033452             IF BACKGROUND=0 THEN CALL FAR CSETRT FI % SET UP RT'S SYSTEM SEGMENT
033455             IF X:=SEGMC><0 THEN
033457                CALL FAR RSSGIPTABLE; X:=RTREF; CALL FAR CCLNREENTRANT
033462             FI; X:=SEGMA; CALL FAR SSGIPTABLE; X:=SEGMB; CALL FAR SSGIPTABLE
033466             X:=FILSEGM; CALL FAR SSGIPTABLE
033470             X:=5NSEGM; CALL FAR SSGIPTABLE
033472             X:=FUSEGM; CALL FAR SSGIPTABLE
033474             *POF
033475             "WNDBF+WNDBF+174000"=:B
033477             FOR X:=0 STEP 2 TO 10 DO
033503                AD:=SWPTWINDOWS(X)=:DS0; B+2        % RESTORE DPIT WINDOWS
033506             OD; *PON
033511             "XSBFIELD"=:B
033513             *1BANK
033514             "ERR14"=:LEV14
033516             *2BANK
033517          FI
033517          CALL FAR TBUSPEED
033520          CALL FAR CLADV
033521          GO L1; *)FILL
033556
033556   L1:
033556          LGCOLDSTART; CALL LOGPH
033560          IF A=0 OR A.TYPRING NBIT 5TERM THEN X:="DT01R" FI
033566          T:="CNTREG"; CALL XGTDFADDR; A BZERO "0"=:CCNTRG
033572          T:="HDEV"; CALL XGTDFADDR; T:=A+DCONT; CCNTRG; *IOXT
033600   *"8SCSI
"033600          CALL SCPWF                               % SCSI START/RESTART HANDLING
033601   *"
"033601          MASSNO(0); CALL LOGPH
033604          IF A."DODMA"><"SCSDI" THEN
033611             X.HDEV+"164000+5"=:T
033614             "0"; *EXR ST                          % SELECT UNIT
033616             FOR X:=100000 DO OD                   % HOLD 3 MICRO SEC.
033620             20; *EXR ST                           % CLEAR DEVICE
033622             FOR X:=100000 DO OD                   % HOLD 3 MICRO SEC.
033624             IF T BIT 11 THEN
033626                A:=34004; *EXR ST                  % RETURN TO ZERO SEEK IF BIG DISC
033630             FI; T-1                               % READ STATUS (4=READ STATUS)
033631   DDLAY:    FOR X:=100000 DO; OD                  % DELAY
033633             *EXR ST; BSKP ZRO 160 DA; JMP ADLAY   % ON CYLINDER
033636             *BSKP ONE 030 DA; JMP DDLAY           % UNTIL ON CYLINDER
033640          FI
033640   ADLAY: GO LDLAY
033641
033641   *"8FLMN
"033641
033641   LDLAY: *BSET ZRO SSZ
033642          *TRA IIC; TRA PEA; TRA PGS
033645          "0"; *TRR PID; TRR PIE
033650          "LV0"; *IRW 0 DP; ION
033653   LV0:   *IOF
033654          IMASK; *TRR IIE
033656          GO BYPAX; *)FILL
033675
033675   BYPAX:
033675   *"8BEX1
"033675   % INITIALIZE BUS EXPANDER
033675          IF MEMTYPE BIT BBEXPANDER THEN
033700             T := 100000 =: CURBX
033702             T:=CURBX+4=:CURBX            % NEXT ADRESS
033705             T-1; A:=20; *IOXT            % SET SWITCH LIMITS
033710             DO WHILE 100040 >> CURBX     % 8 EXPANDERS MAXIMUM!!!
033714                T + 4 =: CURBX - 1
033717                A := 20; *IOXT; TRA IIC   % SET SWITC ON THIS
033722                IF A = 7 GO L2            % NOT PRESENT!!!
033725                A:=40; *IOXT              % ENABLE READING OF PEA-REG
033727                T-3; *IOXT                % READ PEA-REG.
033731                T+3; A:=2; *IOXT          % ENABLE INTERRUPT FROM EXPANDER
033734             OD
033735          FI
033735   *"
"033735
033735   L2:
033735   *"8MPM4
"033735   %  INITIALIZE MULTIPORT IV
033735          IF MEMTYPE BIT BMPM4 THEN
033740             T:= 100200 =: CURBX                    % INIT FIRST DEVNO
033742             DO WHILE 100400 >> CURBX               % CLEAR AND INIT
033746                T+4 =: CURBX - 1                    % ALL POSSIBLE MPM4 BUSC'S
033751                A := 040; * IOXT                    % ENABLE READ LPEA
033753                T - 3; * IOXT                       % READ LPEA
033755                T + 2; * IOXT                       % READ STATUS TO CLEAR IT
033757                T + 1; A := 06; * IOXT              % CLEAR DEVICE AND ENABLE INTERRUPT
033762             OD; * TRA IIC                          % CLEAR IIC
033764          FI
033764   *"
"033764          GO L3; *)FILL
033772
033772   % RESTORE REGISTER BLOCKS
033772   INTEGER LEVCN,LRBI(0); *LRB 10
033774   L3:    *1BANK
033775          X:="LEV1"; -16=:LEVCN; LRBI
034001          FOR LEVCN DO; *EXR SA
034002                X+10; A+10 OD
034006          "FREQU+160001"; *IOX DCONT RTCLD
034010          *2BANK
034011          9TIM0; *IOX DDW RTCLD
034013          PIEREG; *TRR PIE
034015          PIDREG ; *TRR PID
034017          IF PIDREG><0 THEN
034021             IF X:=URESTART><0 THEN
034023                *JPL ,X                             % CALL "USER-RESTART" ROUTINE
034024              FI
034024              X:="URERTP"; MQUEU=:X.MLINK; X=:MQUEU % START USER RESTART PROGRAM
034030          FI
034030   % INITIALIZE NOTS CONTROLLERS
034030          CALL MNINIT
034031   % SET UP POINTERS TO AND INITIALIZE THE MEMORY AREA USED
034031   % FOR REG.BLOCKS AND REE.BITMAP
034031         IF PIDREG=0 THEN           % NOT AFTER POWER FAIL
034033            "SRTDL"=:D
034035            X:=RTSTART
034036            DO WHILE X <<="ERTBS"-5RTSIZE
034042               A:=D=:X.RTDLGADDR+5XRTDSIZE=:D
034046               IF X.BRESLINK=0 THEN X=: X.BRESLINK FI
034051               X+5RTSIZE
034052            OD
034053            X:="SRTDL"; *1BANK
034055            DO WHILE X<<D; 0=:X.S0; X+1 OD; *2BANK
034063            "DUMMY".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034071            "STSIN".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034077            "1SWAP".STADR; X:=X.RTDLGADDR; *1BANK; STA DPREG,X; 2BANK
034105          FI; GO OVFI1; *)FILL
034125   OVFI1:
034125   % INITIALIZE MICRO SEGADM FOR CX/K MICRO PROGRAM
034125          IF HWINFO(0)/\377 >= 3 THEN
034133              TAD:=GLOBPARAM
034134              *WGLOB
034135                          % AND CHECK THAT THEY ARE CORRECT
034135              0=:T=:A=:D
034140              *RGLOB
034141              IF T >< X:=SEGTBANK THEN CALL ERRFATAL FI
034145              IF A >< X:=SEGSTART THEN CALL ERRFATAL FI
034151              IF D >< X:=CORMBANK THEN CALL ERRFATAL FI
034155          FI
034155          GO L4
034156   *)FILL
034164
034164   L4:
034164          IF PIDREG=0 THEN                            % INITIAL START, (NOT AFTER POWER FAIL)
034166             A:=UCACHLIM=:D:=LCACHLIM; CALL DISCACHE; 0/\0
034173             IF HWINFO(0)/\ 377 >=3  THEN                 % ND-110 , ND-120
034201                DBDPAGE;    CALL DISCACHE; 0/\0
034204                DHDLCPAGES; CALL DISCACHE; 0/\0
034207                DSPTRPHPAGE;CALL DISCACHE; 0/\0
034212             FI
034212          FI
034212          IF HWINFO(0)/\ 377 >=3  THEN                    % ND-110 , ND-120
034220             IF PIDREG=0 THEN
034222                CALL FAR PINHBTCACHE                  % INHIBIT PAGES IN CACHE
034223             ELSE
034224                CALL FAR PENABCACHE                   % ENABLE PAGES IN CACHE (CACHE IS CLOSED AFTER MASTER-CLEAR)
034225             FI
034225          ELSE
034226             CALL FFPCACHEINHIBIT; A:=-1; *TRR 11  % SET LOWER CACHE INHIBIT PAGE
034231             CALL FLPCACHEINHIBIT; A:=0;  *TRR 12  % SET UPPER CACHE INHIBIT PAGE
034234             *TRR CCLR                             % CLEAR CACHE
034235          FI
034235   % CLEAR PIT #0 AND PIT #17
034235          X:=174000; A:=0; D:=0
034240          *POF
034241          DO AD=:X.DOU0; X+2 WHILE X><174200 OD
034247          X:=177600; DO AD=:X.DOU0; X+2 WHILE X><0 OD
034254          PCCS(0); *TRR PCR               % SET PCR FOR LEVEL 0
034257          GO L5
034260   *)FILL
034275   TRIPLE ARRAY POINTER ESPARRAY
034276
034276   % RESTORE PIT ENTRIES FOR SEGMENTS ENTERED WITH MON ENTSG
034276   % GET NUMBER OF SEGMENTS ENTERED WITH ENTSG
034276   L5:    "ESCNT"=:X; T:=DPITBANK; *LDATX          % PHYSICAL ADDRESS OF ESCNT.
034302          IF A >< 0 THEN                           % IF ANY SEGMENTS ENTERED
034303              "ESARRAY"=:"ESPARRAY"                % SET POINTER TO ENTERED SEGMENTS TABLE
034305              FOR X:=0 STEP 3 TO "ESMAX-1*3" DO    % REENTER SEGMENTS.
034311                  TAD:=ESPARRAY(X)
034312                  IF T >< 0 THEN CALL PFENTSG FI
034315              OD
034317          FI
034317          CALL UPPOW                 % POWWER UP TO OCTOBUSS ?
034320          GO PENT0
034321   RBUS
034326
034326
034326   @ICR
034326   INTEGER ARRAY LEV1:=(
034326   ERRFA,0,0,0,0,0,1,0,
034336   MONEN,0,0,0,0,0,1,0,
034346   ERRFA,0,0,0,0,0,1,0,
034356   ERRFA,0,0,0,0,0,1,0,
034366   ERRFA,0,0,0,0,0,1,0,
034376   ERRFA,0,0,0,0,0,1,0,
034406   ERRFA,0,0,0,0,0,1,0,
034416   ERRFA,0,0,0,0,0,1,0,
034426   ERRFA,0,0,0,0,0,1,0,
034436   WT10,0,0,0,0,0,1,0,
034446   WT11,0,0,0,0,0,1,0,
034456   WT12,0,0,0,0,0,1,0,
034466   ID13+4,0,0,0,0,0,1,0);
034476   INTEGER LEV14:=(
034476   ENT14,0,0,0,0,0,1,0);
034506   @CR;
034506
034506   *"8LAMU
"034506   %

034506   %=========================================================================
034506   %      L A M A R R
034506   %
034506   % PHYSICAL MEMORY PARTS AVAILABLE FOR LAMUS
034506   %
034506   % FORMAT: 2 LOCATIONS FOR EATCH ENTRY
034506   %         FIRST PHYSICAL PAGE IN AREA
034506   %         LAST PHYSICAL PAGE IN AREA
034506   %
034506   DOUBLE ARRAY LAMARR(NINSZ*2)
034626   * LAMAR<*; )ZERO
034626   *"
"034626
034626   %==========================================================================
034626   %       M N I N I T
034626   %
034626   % SUBROUTINE TO INITIALIZE NOTS CONTROLLERS
034626   %
034626   SUBR MNINIT
034626   INTEGER CC1,CC2
034630   INTEGER POINTER LREG
034631   MNINIT: A:=L+1=:"LREG":="MNTAB"=:CC1
034635           DO WHILE CC1.S0 >< -1                                  % SEARCH MNTAB
034642              A=:CC2
034643              IF A >< 0 THEN                                      % MBNIU PRESENT ?
034644                 T:=A.HDEV+2; 22; *IOXT                           % SET MEMORY SIZE AND WINDOW ADDRESS
034651                 T:=X.HDEV; 5; *IOXT                              % ENABLE INTERRUPTS AND MEMORY ACCESSES
034654                 T+4; *IOXT                                       % CLEAR MULTIBUS TIME-OUT BIT
034656                 T:=CC2.MNCBNK; X:="MNCONT+MNHST"; MNRST; *STATX  % INDICATE HOST INITIATED RESTART
034663                 IF PIDREG=0 THEN                                 % NOT IF POWER FAIL
034665                    A:=T SHZ 6+77=:D-177; CALL DISCACHE; *JMP *   % DISABLE CACHE FOR THIS MEMORY
034674                 FI
034674                 T:=CC2.HDEV+5; 2; *IOXT                          % GENERATE TIMER INTERRUPT
034701              FI
034701              MIN CC1
034702           OD
034703           IF PIDREG><0 THEN                                      % POWERFAIL ?
034705              IF MNACT><0 THEN
034707                 "WT10"; *IRW LV10B DP                            % ABORT DRIVER IF ACTIVE
034711              FI
034711              "LREG"+52=:"LREG"                                   % OLD CODE
034714           FI
034714           GO LREG
034715   RBUS
034723
034723   %==========================================================================
034723   %       I P T M A P
034723   %
034723   % SUBROUTINE TO SET UP PIT #0 AND PIT #17 FOR THE START AND RESTART ROUTINES
034723   %
034723   SUBR IPTMAP
034723   IPTMAP: *PIOF
034724   % INITIALIZE PAGE TABLE #0 TO LOGICAL EQUAL PHYSICAL ADDR
034724          A:=162000; D:=0; X:=174000
034727          DO AD=:X.DOU0; X+2; D+1 WHILE X><174200 OD
034736   % CLEAR ALL THE OTHER PAGE TABLES
034736          A:=0; D:=0
034740          DO AD=:X.DOU0; X+2 WHILE X><0 OD
034744          X:=177600; D:=0; A:=162000; AD=:X.DOU0
034750          X+2; D+1; AD=:X.DOU0
034753          "STPBS" SHZ -11+177600=:T
034757          A:=DPITBANK SHZ 6+2=:D:=162000; X+2
034765          DO AD=:X.DOU0; X+2; D+1 WHILE X><T OD          % MAP GLOBAL DATA
034773          A:="STPBS" SHZ -12=:D:=162000; AD=:X.DOU0      % MAP SBFIELD
035000          A:="ADTPIT+ERNG2"; *TRR PCR          % LEVEL 0: NPIT=0, APIT=17, RING=2
035002          EXIT
035003   RBUS
035010
035010   *"8SCSI
"035010   %--------------------------------------------------
035010   %
035010   % POWERFAIL/RESET ROUTINE FOR SCSI
035010   %
035010   SUBR SCPWF
035010
035010   %..............................
035010   % DEFINITIONS FOR SCSI DRIVER .
035010   %..............................
035010
035010   SYMBOL RLMAR=00              % READ MEMORY ADDRESS REGISTER BITS 14-0
035010   SYMBOL WLMAR=01              % WRITE MEMORY ADDRESS REGISTER BITS 14-0
035010   SYMBOL REDAT=02              % READ DATA
035010   SYMBOL WRDAT=03              % WRITE DATA
035010   SYMBOL RSTAU=04              % READ STATUS
035010   SYMBOL CTBUS=02              % CONTROLLER BUSY
035010   SYMBOL NCRIT=11              % INTERRUPT FROM NCR
035010   SYMBOL SCREQ=15              % REQ FROM SCSI BUS
035010   SYMBOL WCONT=05              % WRITE CONTROL
035010   SYMBOL ENDMA=05              % ENABLE DMA
035010   SYMBOL RHMAR=06              % READ MEMORY ADDRESS REGISTER BITS 23-15
035010   SYMBOL WHMAR=07              % WRITE MEMORY ADDRESS REGISTER BITS 23-15
035010   SYMBOL RNDAT=40              % READ NCR DATA REGISTER
035010   SYMBOL WNDAT=41              % WRITE NCR DATA REGIISTER
035010   SYMBOL RNCOM=42              % READ NCR COMMAND REGISTER
035010   SYMBOL WNCOM=43              % WRITE NCR COMMAND REGISTER
035010   SYMBOL RNCNT=44              % READ NCR CONTROL REGISTER
035010   SYMBOL WNCNT=45              % WRITE NCR CONTROL REGISTER
035010   SYMBOL RDESI=46              % READ DESTINATION ID REGISTER
035010   SYMBOL WDESI=47              % WRITE DESTINATION ID REGISTER
035010   SYMBOL RAUXS=50              % READ AUXILIARY STATUS
035010   SYMBOL DARGF=07              % DATA REGISTER FULL
035010   SYMBOL WAUXS=51              % WRITE AUXILIARY STATUS
035010   SYMBOL ROIDN=52              % READ OWN ID NUMBER
035010   SYMBOL RITRG=54              % READ INTERRUPT REGISTER
035010
035010   SYMBOL ILCOM=16              % ILLEGAL COMMAND
035010   SYMBOL RECON=14              % RECONNECT
035010   SYMBOL CONEC=13              % CONNECT
035010   SYMBOL DISCO=12              % DISCONNECT
035010   SYMBOL BUSSI=11              % BUS SERVICE INTERRUPT
035010   SYMBOL FUCOM=10              % FUNCTION COMPLETE
035010   SYMBOL PARIT=06              % PARITY ERROR
035010   SYMBOL PAUSE=02              % PAUSED
035010   SYMBOL TCZRO=01              % TRANSFER COUNT ZERO
035010
035010   SYMBOL RSOUI=56              % READ SOURCE ID
035010   SYMBOL RDIST=62              % READ DIAGNOSTIC STATUS
035010   SYMBOL SLFCO=07              % SELFTEST COMPLEAT NCR 5386
035010   SYMBOL RTCM=70               % READ TRANSFER COUNTER MOST
035010   SYMBOL WTCM=71               % WRITE TRANSFER COUNTER MOST
035010   SYMBOL RTC2=72               % READ TRANSFER COUNTER 2ND.
035010   SYMBOL WTC2=73               % WRITE TRANSFER COUNTER 2ND.
035010   SYMBOL RTCL=74               % READ TRANSFER COUNTER LEAST
035010   SYMBOL WTCL=75               % WRITE TRANSFER COUNTER LEAST
035010
035010   SYMBOL 6SFUN=17              % FUNCTION STARTED
035010   SYMBOL 6STMS=16              % TARGET SUPPORTS OPTIONAL MESSAGES
035010   SYMBOL 6SRST=15              % SCSI BUS RESET
035010   SYMBOL 6SBCZ=13              % BYTECOUNT ZERO
035010   SYMBOL 6SMSO=12              % MESSAGE OUT PENDING
035010   SYMBOL 6SRFD=11              % RETURN ON COMMAND ACCEPTED (I.E. FIRST DISCONNECT)
035010   SYMBOL 6SDIS=10              % DISCONNECT MESSAGE RECEIVED
035010   SYMBOL 6SCCO=7               % COMMAND COMPLETE MESSAGE RECEIVED
035010   SYMBOL 6SMSI=6               % MESSAGE RECEIVED
035010   SYMBOL 6SARB=5               % ARBITRATION PHASE
035010   SYMBOL 6SSBT=4               % SINGLE BYTE TRANSFER
035010   SYMBOL 6SCRP=3               % CONNECT/RECONNECT PHASE
035010
035010
035010   INTEGER CLMSK:=0; * *-1/1@8SRIN+^; *-1/1@8SDIA+^; *-1/1@8STMR+^
035011                     * *-1/1@8SERR+^; *-1/177777-^
035011
035011   SCRST: IF NCROK=0 THEN
035013             IF X:=SCTST>>2 THEN TMR=:X.SUTMR FI        % SAVE CURRENT TIMER
035021             -1=:SCEIM; 2=:SCTST                        % LOCK INTERFACE
035025             "0" BONE 8SRST=:NCROK
035030             IF X:=SCCSU><0 THEN
035032                IF X.SUTRG=0 THEN PFAIL=:X.SUTRG FI     % INDICATE POWERFAIL
035036                BUSFL BONE 6SRST=:BUSFL                 % INDICATE RESET STARTED
035041                NCROK BONE 8SCLR=:NCROK                 % RECOVERY NECESSARY
035044             ELSE
035045                "0" BONE 6SRST=:BUSFL                   % INDICATE RESET STARTED
035050             FI
035050             X:="SCTQP-SULINK"+B
035052             DO
035052                WHILE X:=X.SULINK><0                    % FOR ALL ACTIVE OPERATIONS
035054                IF X.SUTHS BIT 6SDIS THEN
035057                   A BONE 6SRST=:X.SUTHS                % INDICATE RESET
035061                   IF X.SUTRG=0 THEN PFAIL=:X.SUTRG FI  % INDICATE POWERFAIL
035065                   NCROK BONE 8SCLR=:NCROK              % RECOVERY NECESSARY
035070                FI
035070             OD
035071          ELSE
035072             NCROK/\CLMSK=:NCROK
035075          FI
035075          IF PIDREG><0 THEN NCROK BONE 8SPWF=:NCROK FI  % POWERFAIL
035102          "0"; T:=HDEV+WNCOM; *IOXT                     % DISCONNECT TO NCR
035106          20; T+"WCONT-WNCOM"; *IOXT                    % CLEAR CONTROLLER
035111          T+"RSTAU-WCONT"; *IOXT                        % READ STATUS
035113          IF A BIT 5 THEN
035115             NCROK BONE 8SRIN BONE 8SPWF=:NCROK         % RECEIVING RST
035121             -1=:TMR
035123          ELSE
035124             T+"WCONT-RSTAU"
035125             2000; *IOXT                                % SET RESET ON SCSI BUS
035127             -5000=:TMR; FOR TMR DO OD                  % LEAVE "RST" ON FOR AT LEAST 250 us
035133             "0"; *IOXT                                 % CLEAR RESET
035135             T+"RDIST-WCONT"                            % READ DIAGNOSTIC STATUS
035136             FOR X:=-1000 DO
035137                *IOXT
035140                WHILE A NBIT 7
035142             OD
035143             IF A=200 THEN                              % SELFCHECK OK
035146                NCROK BONE 8SDIA=:NCROK
035151                13; T:=HDEV+WNCOM; *IOXT                % START DIAGNOSTIC
035155                376; T+"WNDAT-WNCOM"; *IOXT             % WRITE DATAREGISTER
035160                5; T+"WCONT-WNDAT"; *IOXT               % ENABLE INTERRUPT
035163                -2=:TMR                                 % DIAGNOSTIC TIMER
035165             ELSE
035166                100000=:NCROK                           % ERROR IN INTERFACE
035170             FI
035170          FI
035170          EXIT
035171   *)FILL
035201
035201   INTEGER SCDNO, SAVB
035203   INTEGER POINTER HOME
035204
035204   SCPWF: A:=B=:SAVB:=L=:"HOME"
035210          2202=:SCDNO
035212          FOR SCDNO TO 2205 DO
035216             CALL LOGPH
035217             IF A=:B><0 THEN CALL FAR SCRST FI
035222          OD
035226          A:=SAVB=:B; GO HOME
035231   RBUS
035235   *"
"035235   %
035235   % ==================================================================
035235   %
035235   %  Load Control-Store if ND-110 or ND-120
035235   %
035235   %     + Loads and/or compares control-store-RAM in 110/120 from a segment
035235   %     + Segment must be permanently in memory and reside within one bank.
035235   %     + Compares the versions of the CPU-m.code and the segment.
035235   %         If CPU lowest then both loading and comparing is performed.
035235   %         If equal then only compare.
035235   %         If CPU highest then no action.
035235   %     + Floating (32/48) is choosen from the CPU type or it may be
035235   %       forced by Sintran (UCLOAD=40B OR 60B)
035235   %
035235   %     Must only be called if ND-110 or ND-120  !!!!! (or UCLOAD=0)
035235   %
035235   %     Called both when Sintran starts an after powerfail
035235   %     in 2BANK mode.
035235   %
035235   %     Separate segment for 110 and 120. Only one of them will be
035235   %     fixed in memory . Here is a visualization of the segment
035235   %     layout:
035235   %
035235   %                  ___________
035235   %     Seg. start  l           l 0
035235   %                 l info rec. l
035235   %                 l           l   See description below.
035235   %                 l-----------l
035235   %                 l           l
035235   %                 l           l
035235   %                 l-----------l <DASTA>   - Start of U-code data
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l * * * * * l <32UST>   - Start of floating part
035235   %                 l * * * * * l             of U-code. ( Micro address )
035235   %                 l * * * * * l             This part contains 32bit
035235   %                 l * * * * * l             floating. 48LEN is length
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l . . . . . l
035235   %                 l___________l           - End of U-code data.
035235   %                 l           l             <DASTA>+LENGT is address
035235   %                 l           l
035235   %                 l-----------l <48STA>   - Same as floating part above
035235   %                 l + + + + + l             but whith 48bit floating
035235   %                 l + + + + + l             48LEN is length
035235   %                 l + + + + + l
035235   %                 l + + + + + l
035235   %                 l-----------l
035235   %     Seg. end    l           l
035235   %                  -----------
035235   %
035235   %
035235
035235   INTEGER XERCR:='$Error in CPU control store RAM. Address : '
035263   INTEGER XERSG:='$Mismatch  CPU / micro-code-segm'
035304   INTEGER XERLC:='$$Micro-code not loaded. CPU revision too low !!$$'
035336   INTEGER XMG32:='$CPU forced to 32 bit floating!'
035356   INTEGER XMG48:='$CPU forced to 48 bit floating!'
035376
035376   SUBR LOCOSTORE
035376
035376   INTEGER SAVL=?
035376
035376   DOUBLE FLSEG=?
035376   INTEGER FLSGB=?
035376   INTEGER FLSGA=?
035376
035376   INTEGER 48FLOAT=?
035376   INTEGER SGPNTER=?
035376   INTEGER MICVER=?
035376   INTEGER CONVER=?
035376   INTEGER MXADR=?
035376   INTEGER FLSTA=?
035376   INTEGER FLDISP=?
035376   INTEGER FLEND=?
035376
035376   % ------------------------------------------------------------
035376   %  I N F O    R E C O R D.
035376   % It will be located from locaton zero on the segment,
035376   % and will describe the segment layout
035376   %
035376
035376
035376   %DISP  0; INTEGER STATU    ; PSID % Status
035376   DISP  1; INTEGER DASTA    ; PSID % U-code start addr. in segment
035376   DISP  2; INTEGER LENGT    ; PSID % U-code length in 16 bit words
035376                                    %  48 bit floating part that may be xchanged
035376   DISP  3; INTEGER 32UST    ; PSID % U-start address for floating (in micro prog 64bit words)
035376   DISP  4; INTEGER 48STA    ; PSID % Data start in segment
035376   DISP  5; INTEGER 48LEN    ; PSID % Length in segment in 16 bit words
035376
035376   LOCOSTORE:
035376           A:=L=:SAVL
035400
035400           A:=UCFPA=:D:=0
035403           AD SH 12 =: FLSEG
035405
035405     %------------------------------------------------------
035405     % Check if control store should be loaded and which one
035405
035405           IF UCLOAD =0 THEN
035407              EXIT
035410           ELSE
035411              HWINFO(0) =:D
035414              IF UCLOAD><40 AND A><60 THEN
035423                IF D NBIT 10 THEN "1" ELSE "0" FI
035430              ELSE
035431                *1BANK
035432                IF A=40 THEN                       % Floating forced by Sintran
035435                   IF D NBIT 10 THEN "XMG32"; CALL 3UTXT FI
035441                   "0"
035442                ELSE
035443                   IF D BIT 10 THEN "XMG48"; CALL 3UTXT FI
035447                   "1"
035450                FI
035450                *2BANK
035451              FI
035451           FI
035451           A =:48FLOAT =:D :=HWINFO(0)            % "1" is 48 bit float
035455           IF D=0 THEN A BONE 10
035460           ELSE A BZERO 10 FI
035462           A=: HWINFO(X)
035463
035463    % ---------------------------
035463    % Set up working variables
035463
035463   %        *VERSN                             % U-code version CPU
035463           X := 100
035464           *150017
035465           A =: MICVER =: D
035467           IF A<<13 THEN              % CPU rev low
035472              *1BANK
035473              "XERLC"; CALL 3UTXT
035475              *2BANK
035476              GO FAR NOTLOAD
035477           FI
035477
035477           T:=FLSGB; X:=FLSGA     % Start of segment
035501
035501           *AAX DASTA; LDATX
035503           A=:FLDISP+FLSGA=:SGPNTER            % Start of U-code
035506
035506           *AAX LENGT-DASTA; LDATX
035510           A+SGPNTER =: MXADR                  % End of U-code
035512
035512           *AAX 32UST-LENGT; LDATX
035514           A SH 2 + SGPNTER =: FLSTA           % Start of floating part in U-code
035517
035517           *AAX 48STA-32UST; LDATX
035521           A +SGPNTER -FLDISP =:L -FLSTA =:FLDISP     % Disp to 48 bit floating part
035526
035526           *AAX 48LEN-48STA; LDATX
035530           A + L =: FLEND                       % End of 48 bit floating
035532           *AAX -48LEN
035533
035533           X:=SGPNTER
035534           *AAX 100; LDATX                      % U-code version in segment
035536           A =: CONVER
035537
035537           IF A >< D THEN
035541              *1BANK
035542              IF A BIT 17 AND D NBIT 17 THEN "XERSG"; CALL 3UTXT; CALL ERRFATAL FI
035551              IF A NBIT 17 AND D BIT 17 THEN "XERSG"; CALL 3UTXT; CALL ERRFATAL FI
035560              *2BANK
035561           FI
035561           IF A << D GO NOTLOAD
035563
035563           GO CONTLO
035564   *)FILL
035575
035575   % --------------------------------------------
035575   %        Variables
035575
035575   INTEGER SAVL
035576
035576   DOUBLE FLSEG(0)
035576   INTEGER FLSGB           % Segments physical address in memory (fixed)
035577   INTEGER FLSGA
035600
035600   INTEGER 48FLOAT           % 0=32 bit fl. / 1=48 bit fl.
035601   INTEGER SGPNTER           % Current address on segment
035602   INTEGER MICVER            % Micro prog version from CPU
035603   INTEGER CONVER            % Version from segment
035604   INTEGER MXADR             % End of chosen control store
035605   INTEGER FLSTA             % Trig address in segment for start load floating part
035606   INTEGER FLDISP            % Disp to get 48 float part for same
035607   INTEGER FLEND             % End address for same
035610     %-------------------
035610     % Load control store
035610
035610   CONTLO: 0=:D          % CONT START ADDR
035611           X:=SGPNTER
035612           IF 48FLOAT=1 THEN K:="1" ELSE K:="0" FI
035621           DO
035621                                               % X=segm/ D=cpu
035621                IF K THEN             % 48 bit floating handeling
035623                   IF X=FLSTA THEN    % Start floating
035626                      A:=X+FLDISP=:X
035631                   FI
035631                   IF X=FLEND THEN    % End floating
035634                      A:=X-FLDISP=:X
035637                      K:="0"
035640                   FI
035640                FI
035640                T := FLSGB
035641                *LDATX                % Load from segm.
035642                X:=:D                          % X=cpu / D=segm
035643                *150117               % Store to CPU
035644                X:=:D
035645                                               % X=segm/ D=cpu
035645                X+1; D+1
035647                WHILE X><MXADR
035652           OD
035653    % --------------------
035653    % Test control store
035653
035653   CHKCONT:
035653           0=:D          % CONT START ADDR
035654           X:=SGPNTER
035655           IF 48FLOAT=1 THEN K:="1" ELSE K:="0" FI
035664           DO
035664                IF K THEN             % 48 bit floating handeling
035666                   IF X=FLSTA THEN    % Start floating
035671                      A:=X+FLDISP=:X
035674                   FI
035674                   IF X=FLEND THEN    % End floating
035677                      A:=X-FLDISP=:X
035702                      K:="0"
035703                   FI
035703                FI
035703
035703                T:=FLSGB
035704                *LDATX
035705                X:=:D ; A=:L
035707                *150017               % Read cont store
035710                X:=:D
035711
035711                IF A >< L THEN         % Error in cpu
035713                   A:=D=:SGPNTER
035715                   *1BANK
035716                   "XERCR"; CALL 3UTXT
035720                   SGPNTER; CALL FOCTU
035722                   CALL ERRFATAL
035723                FI
035723                X+1 ; D+1
035725                WHILE X><MXADR
035730           OD
035731   NOTLOAD:
035731           A:=SAVL=:L
035733           EXIT
035734   RBUS
035740
035740
035740   %==============================================================================
035740   % 36.24      N S W P A G E  -  N I N I T P A G E  -   C U M T A B L E
035740   %
035740   % NSWPAGE    : MEMORY AREA NOT USED AS SWAPPING AREA
035740   % NINITPAGE  : MEMORY AREA NOT LEGAL TO INITIALIZE
035740   %
035740   % THE LAYOUT IN THE TABLES:
035740   %      TWO WORDS FOR EACH ENTRY, FIRST PAGE AND LAST PAGE IN AREA
035740   %      THE TABLES ARE TERMINATED BY A ZERO
035740   %
035740   DOUBLE ARRAY NSWPAGE(NNSWSZ)           % MEMORY AREAS UNAVAILABLE FOR SWAPPING
036010   *NINSZ
036011   DOUBLE ARRAY NINITPAGE(NINSZ)          % MEMORY AREAS NOT ACCESSED IN START-UP (SHARED BETWEEN CPU'S)
036061   *0;0                                   % RESERVED FOR MBNIU PATCH
036063   DOUBLE ARRAY CUMTABLE(CUMSIZE)         % CUSTOMER RESERVED MEMORY AREAS
036107   DOUBLE ARRAY USIOXTAB(USDVSIZE)        % CUSTOMER RESERVED PHYSICAL DEVICE NUMBERS (SHOULD NOT BE CLEARED)
036127   DOUBLE ARRAY MMPIOC(24)                % PHYS MEMORY USED BY THE PIOCS, (FIRST AND LAST PHYS PAGE)
036177                                          % PIOC NUMBER IS INDEX IN MMPIOC
036177   * NSWPA<*; )ZERO
036177   * CURR=*
036177   * USIOX/144300;144677                  % SCSI DEVICE NUMBERS
036111   * CURR/ )KILL CURR
036177
036177   @DEV 1
