066341   @DEV (S-S-L)RP-P2-SEGADM:NPL
066341   % TAB S8,4
066341

066341   %%%%%%%%%%%%%%%%%%%%%%% C X - R P I T - S E G A D M %%%%%%%%%%%%%%%%%%%%%%%%%%
066341   %=============================================================================
066341   %            C L R B M A P
066341   %
066341   % CLRBMAP:   CLEAR THE REENTRANT BITMAP
066341   %      ENTRY:  X=RTDESCRIPTION; INTERRUPT MUST BE OFF OR MLEV DISABLED
066341   %
066341   SUBR CLRBMAP
066341
066341   CLRBMAP:
066341          X:=X.RTDLGADDR; *AAX BITMA
066343          T:=0
066344          *STZTX 00; STZTX 10; STZTX 20; STZTX 30
066350          *STZTX 40; STZTX 50; STZTX 60; STZTX 70
066354          EXIT
066355   RBUS
066355   %==============================================================================
066355   %
066355   %                S E G M E N T  M O N I T O R  C A L L S
066355   %
066355   %==============================================================================
066355   % 36.5    (R)   M C A L L   M E X I T
066355
066355   % MONITOR CALLS MCALL AND MEXIT - TO CHANGE SEGMENTS
066355   % APPL. LEVEL
066355
066355   SUBR SGMTY,MCALL,MEXIT,0LEGSEG,LEGSEG,R15ERRD,RLEGSEG
066355
066355   DISP 0
066355       DOUBLE MSTADR
066355       INTEGER MSEGM=D0
066355       INTEGER FUNCTION=D0, ADRESS=D1, SEG1=D2, SEG2=D3, PITS=D4
066355       DOUBLE SVSEG=D5
066355   PSID
066355   INTEGER MSEG1=?, MSEG2=?
066355   DOUBLE DMSEG=?
066355   INTEGER STRA=?,LA=?,STRB=?,LB=?
066355
066355   MCALL: CALL GET0; X:=ZTREG % T POINTS TO PARAMETERS
066357          A:=OLDPAG           % TO SET UP WINDOW.
066360          CALL USALTPIT       % SET UP USERS APT AS APT.
066361          MLEV; *MST PIE      % ENABLE MON LEVEL FOR PAGEFAULT HANDLING
066363          AD:=X.MSTADR        % GET PARAMETERS FROM USERS PIT.
066364          CALL SINALTPIT      % RESET APT.
066365          T:=ZPREG=:ZLREG     % SAVE RETURN ADDRESS
066367          A=:ZPREG:=D=:MSEGM  % NEW P AND SEGMENTS
066372          MLEV; *MCL PIE
066374          RTREF.DACTSEG=:SVSEG
066377          IF A>376 OR D>T GO FAR ERRIL
066404          D SH 10; A+D; A=:ZTREG        % SAVE OLD SEGMENTS IF MCALL
066407          GO MMC
066410
066410   MEXIT: CALL GET0; ZLREG=:ZPREG; ZTREG=:MSEGM
066415          AD:=RTREF.DACTSEG
066417          IF A<=376 AND D<=376 THEN   % MEXIT ON "OLD" SEGENT NUMBERS SHOULD
066425              D SH 10;A+D             % RETURN CURRENT SEGMENT NUMBERS IN
066427              A=: ZTREG               % CALLERS T-REG
066430          FI                          %
066430   MMC:   IF MSEGM SHZ -10=377 THEN -1 FI; A=:SEG2; IF A-1=0 GO FAR ERRIL % SEGNO 1
066442          IF MSEGM /\ T   = T  THEN -1 FI; A=:SEG1; IF A-1=0 GO FAR ERRIL % IS ILLEGAL
066453          GO FELLS
066454   *)FILL
066463

066463   %=============================================================================
066463   %
066463   % (R)  S G M T Y       SEGMENT MULTI FUNCTION MONITOR CALL.
066463   %                      T-REGISTER POINTS TO PARAMETER ADDRESS LIST:
066463   %                          FUNCTION CODE
066463   %                          ADDRESS
066463   %                          SEGMENT 1
066463   %                          SEGMENT 2
066463   %                          PITS
066463   %      FUNCTIONS: 0 - MCALL                1 - MEXIT
066463   %                 2 - MCALL W/PIT CHANGE   3 - MEXIT W/PIT CHANGE
066463   %                 4 - REMSG (REMOVE SEGMENT ENTEREED WITH ENTSG)
066463   %
066463   %      EXIT:   MCALL:  T = SEGMENT 1
066463   %                      D = SEGMENT 2
066463   %                      L = RETURN ADDRESS
066463   %                      X = OLD PITS IF PITS CHANGED (FUNCTION 2)
066463   %
066463   %              MEXIT:  NO REGISTER CHANGE
066463   %
066463   %              REMSG:  A = STATUS (SEE REMSG)
066463   %
066463   SGMTY: T=:B; CALL GET5
066465          IF FUNCTION >> 4 GO FAR ERRFUNC
066471          A GOSW KMCALL, KMEXIT, PMCALL, PMEXIT, GOTOREMSG
066477   GOTOREMSG:
066477          CALL XREMSG
066500
066500   PMEXIT:
066500   PMCALL:PITS=:D/\377    % ALT. PIT
066503          CALL LEGPIT     % CHECK IT
066504          A:=D SHZ -10    % NORM. PIT
066506          CALL LEGPIT     % CHECK IT
066507          A:=0
066510          AD SH 10; D SH 4; AD SHZ -5 % ALIGN NIBBLES
066513          OLDPAG=:T/\100177\/D=:OLDPAG
066520          IF FUNCTION-2=0 THEN % IF PMCALL
066523              A:=T SHZ -7/\17:=:T SHZ -3/\7400\/T=:ZXREG % REALIGN NIBBLES AS BYTES
066533          ELSE
066534              GO KMEXIT
066535          FI
066535   KMCALL:RTREF.ACT1SEG=:ZTREG    % RETURN OLD SEGMENT NUMBERS
066540          X.ACT2SEG=:ZDREG
066542          ZPREG=:ZLREG            % SAVE RETURN ADDRESS
066544   KMEXIT:ADRESS=:ZPREG           % SET NEW ADDRESS
066546   FELLS: X:=RTREF
066547          IF SEG1=-1 THEN X.ACT1SEG FI        % IF SEG.NO. = -1 KEEP OLD SEG.NO.
066554          A=:MSEG1; CALL DECO; A=:STRA        % FIND START AND LENGTH OF SEGMENT
066557          T=:LA; X:=RTREF
066561          IF SEG2=-1 THEN X.ACT2SEG FI        % IF SEG.NO. = -1 KEEP OLD SEG.NO.
066566          A=:MSEG2; CALL DECO; T=:LB          % FIND START AND LENGTH OF SEGMENT
066571          % CHECK FOR OVERLAP
066571          IF A>STRA THEN IF A-LA<T GO ERRO
066577                    ELSE IF A+LB>T GO ERRO
066603          FI
066603          DMSEG=:RTREF.DACTSEG
066606          GO RETSTUPR
066607
066607   INTEGER STRA,LA,STRB,LB
066613   *)FILL
066626   % LOCAL SUBROUTINE TO VALIDATE PIT NUMBERS.
066626   LEGPIT:IF A=1 OR=2 OR=17 THEN EXIT FI  % RING 0/1 PROGRAMS ONLY IN PITS 1,2,17
066640          IF A><0 AND OLDPAG/\3 >= 2 THEN EXIT FI  % RING 2/3 PROGRAMS ANY PIT EXCEPT 0
066647          CALL 9ERRA(#94) % ILLEGAL PAGE INDEX TABLE
066651          GO RETXIT
066652
066652   INTEGER MSEG1, MSEG2
066654   DOUBLE DMSEG=MSEG1
066654   INTEGER POINTER LREG
066655

066655   % DECODE SEGMENT ELEMENT
066655   % ENTRY: A=SEGMENT NUMBER; X=RTREF
066655   % EXIT:  A=FIRST LOGICAL PAGE IN SEGMENT; T=NUMBER OF PAGES IN SEGMENT
066655   DECO:  IF A=0 THEN T:=0; EXIT FI
066660          T:=L=:"LREG"; IF A=X.RSEGM GO ERRIL
066665          CALL LEGSEG
066666          CALL SHRSOVERLAP
066667          X:=:B
066670          *LDASG SEGLE
066700          A=:T
066701          *LDASG LOGAD
066711          X:=:B
066712          GO LREG
066713
066713   % SUBROUTINE TO CHECK FOR LEGAL SEGMENT
066713   % SHOULD BE CALLES IN IOF OR WITH MONITOR LEVEL DISABLED.
066713   % ENTRY:     A=SEGMENT NUMBER
066713   % EXIT:      A=SEGMENT FLAG; D=SEGMENT NUMBER; X=SEGMENT TABLE ADDRESS
066713   % RETURN TO RETXIT IF ERROR
066713
066713   INTEGER TTTTT  % FOR SAVING T
066714
066714   0LEGSEG: IF A=0 GO ERRIL
066715   LEGSEG:  IF A>>X:=SGMAX OR A=X:=1 GO ERRIL
066723            A=:D*5SEGSIZE+SEGSTART=:X
066727            T=:TTTTT:=SEGTBANK
066731            *SGSTA@3 LDATX % A:=SGSTATUS
066732            IF A = 0 GO ERRNL
066733            *FLAG@3 LDATX % A:=FLAG
066734            T:=TTTTT
066735            IF A BIT 5INHB GO ERRNL
066737            EXIT
066740
066740   *)FILL
066751   ERRRIL:X:=:B;A:=D0   % ILLEGAL REENTRANT SEGMENT
066753   R15ERRD:
066753   ERRIL: CALL 9ERRA(#15); GO RETXIT                % ILL.SEGM.NO.
066756   ERRNL: A:=D; CALL 9ERRA(#16); GO RETXIT          % SEGMENT NOT LOADED
066762   ERRO:  A:=MSEG1; T:=MSEG2                        % OVERLAP
066764          CALL 9ERRA(#42); GO RETXIT
066767   ERRFUNC: CALL 9ERRA(#95); GO RETXIT              % ILLEGAL FUNCTION CODE
066772
066772   % CHECK FOR LEGAL SEGMENT NUMBER IN MON REENT/SREENT CALLED FROM BACKGROUND
066772   % PROGRAMS. ONLY SEGMENTS ON PIT 1 AND PIT 2 WITH PROTECTION RING ZERO
066772   % IS LEGAL
066772   %
066772   RLEGSEG: IF BACKGROUND><0 AND OLDPAGE/\3=0 THEN
066777                X:=:B; *LDASG LOGAD
067010                IF A/\1700><100 AND A><200 GO ERRRIL  % ILLEGAL PIT
067017                *LDASG SGSTA
067027                IF A/\3000><0 GO ERRRIL               % ILLEGAL RING
067031                X:=:B
067032            FI; EXIT
067033   RBUS
067043

067043   %=======================================================================
067043   %       MON SPCHG         CHANGE SEGMENT AND PIT
067043   %
067043   %      PERFORMS THE SAME FUNCTIONS AS MCALL AND MEXIT,
067043   %      BUT ALSO MAKES IT POSSIBLE TO CHANGE THE NORMAL
067043   %      AND ALTERNATIVE PAGE TABLES FOR THE PROGRAM.
067043   %      ONLY PRESENT TO OBTAIN COMPATABILITY WITH VSE AND
067043   %      EARLIER SINTRAN VERSIONS. ONLY ALLOWED WITH PITS 1 & 2.
067043   %
067043   %      PARAMETERS:
067043   %           D-REG BIT 15 IS SET IF MEXIT (MON 132) IS WANTED
067043   %                   IT IS RESET IF MCALL (MON 133) IS WANTED
067043   %
067043   %        IF MCALL: D BIT 2-3 CONTAIN NEW NORMAL PIT
067043   %                  D BIT 0-1 CONTAIN NEW ALTERNATIVE PIT
067043   %                  T LIKE MCALL
067043   %                    (POINTS TO ADDRESS AND SEGMENT NOS)
067043   %        RETURN:   T AND L LIKE MCALL
067043   %                  D CONTAINS OLD PAGE TABLES.
067043   %
067043   %        IF MEXIT: D CONTAINS D-REG FROM MCALL RETURN
067043   %                    (BUT BIT 15 SET)
067043   %                  T AND L FROM MCALL RETURN (LIKE MEXIT)
067043   %
067043   %
067043   SUBR SPCHG
067043
067043   SPCHG:
067043           IF X.ZDREG BIT 17 GO PMEXIT % D BIT 15 IS SET FOR MEXIT WITH PIT CHANGE
067046                                       % ELSE FOR MCALL WITH PIT CHANGE
067046
067046   PMCALL: A/\17; AD SHZ -2        % NEW PITS IN A BITS 0-1
067050           D SHZ -16               % AND D BITS 0-1
067051           IF A=T:=0 OR D=0 OR A=3 OR D=T GO ILLPIT
067063           A SHZ 13; D SHZ 7\/A    % ALIGN PITS FOR PCR
067066           X.OLDPAG=:X.ZDREG/\NACLEAR\/D=:X.OLDPAG    % MASK INTO SAVED ACTPRI
067073           GO MCALL                % CONTINUE IN MCALL
067074
067074   PMEXIT: A/\77600=:D             % OLD PITS IN BITS 7-16
067076           IF A/\74000=T:=0 OR A:=D/\3600=0 GO ILLPIT
067106           X.OLDPAG/\NACLEAR\/D=:X.OLDPAG   % MASK INTO SAVED ACTPRI
067112           GO MEXIT                % CONTINUE IN MEXIT
067113
067113   ILLPIT: A:=T; CALL 9ERRA(#94)   % ILLEGAL PAGE INDEX TABLE
067116           GO RETXIT
067117   RBUS
067130

067130   %==============================================================================
067130   % 36.6    (R)   M F I X   M U N F I X
067130
067130   %MONITOR CALLS: CALL FIX(SEGNO),CALL UNFIX(SEGNO)
067130   SUBR MOFIX,MUNFIX
067130   DISP 0; INTEGER SGADR=D1; DOUBLE OLDSGNO=D2; INTEGER ERFLAG=D4; PSID
067130
067130   MOFIX: CALL GET1; D0; CALL 0LEGSEG
067133          X=:SGADR:=:B
067135          IF A BIT 5DEMAND GO FAR ERRD
067137          IF A BIT 5FIXC GO RETU
067141          *LDASG SGSTA
067151          IF A BIT 5FIX OR A BIT 5SPTFIXED GO RETU
067155          *LDASG SEGLE
067165          IF A=0 GO FAR ERRNL
067167          A=:D
067170          IF A+FIXPAGES>FIXMAX GO FAR ERRF
067174          A=:FIXPAGES
067175          A:=D+MINSWPAGES; CALL CHNSWPAGES; GO FAR ERRF
067201          X=:B
067202          RTREF.DACTSEG=:OLDSGNO  % SAVE OLD SEGMENT NUMBERS
067205          D0=:D:=0;AD=:X.DACTSEG  % USE THE SEGMENT TO BE FIXED INSTEAD
067211          "STUPR"; *IRW MLEVB DP
067213          MLEV; *MST PID; MST PIE
067216   %RETURN WITH CHANGED SEGMENT
067216          MLEV; *MCL PIE      % DISABLE MONITOR LEVEL
067220          OLDSGNO=:X.DACTSEG  % CHANGE BACK
067222          "1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067225   *"8FLMN                                % FOR FLOMEN FOX FIXING SEGMENT 3
"067225   NTSPIT:SLEV; *MST PID; ION             % TO GET SEGMENT OUT OF PAGE TABLES.
067230          X:=SGADR:=:B
067232          *LDASG SGSTA
067242          A BONE 5FIX; *STASG SGSTA
067253          *LDASG SEGLI
067263          IF A=0 THEN CALL ERRFATAL FI    % CHECK THAT SEGMENT IS IN SEGMENT LIST
067265          X=:D
067266          *LDXSG BPAGL
067275          T:=CORMBANK
067276          DO WHILE X><0       % FOR ALL PAGES IN MEMORY
067277              *PROTE@3 LDATX
067300              A BONE 5FIX     % SET 5FIX BIT IN PROTECT WORD
067301              *PROTE@3 STATX
067302              *PAGLI@3  LDXTX
067303          OD
067304          X:=B; B:=D
067306          A:="1OUTSEGLINK"        % LINK SEGMENT OUT OF SEGMENT LIST
067307          *IOF; IRW SLEVB DP      % MUST BE DONE ON SEGADM LEVEL
067311          SLEV; *MST PID; ION
067314          GO RETSTUPR
067315
067315   RETU:  B:=X; GO RET    % RESTORE B AND END MONITOR CALL
067317
067317   *)FILL
067341   MUNFIX: CALL GET1; IF D0=0 OR A>>SGMAX GO FAR ERRIL
067347          A*5SEGSIZE+SEGSTART
067351          B=:X:=A; *LDASG FLAG
067363          A=:T; *LDASG SGSTA
067374          IF A BIT 5SPTFIXED GO FAR ERRPF
067376          IF A BIT 5FIX OR T BIT 5FIXC THEN
067402              A BZERO 5FIX; *STASG SGSTA
067413              A:=T BZERO 5FIXC; *STASG FLAG
067425              IF B=NSEGA OR B=NSEGB THEN
067433                  "1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067436                  SLEV; *MST PID; ION             % TO GET SEGMENT OUT OF PAGE TABLES.
067441              FI
067441              *LDASG SEGLI
067451              IF A><0 THEN CALL ERRFATAL FI
067453              X:=:B
067454              DO  A:=D0       % SEGMENT NUMBER.
067455                  CALL UREMSG % REMOVE SEGMENT FROM PIT, SKIP RETURN IF NOT ENTERED.
067456              OD
067457              GO L1; *)FILL
067474   L1:        X:=:B=:D
067476              *LDXSG BPAGL
067505              T:=CORMBANK
067506              DO WHILE X><0       % FOR ALL PAGES IN MEMORY
067507                  *PROTE@3 LDATX
067510                  A BZERO 5FIX    % RESET 5FIX BIT IN PROTECT WORD
067511                  *PROTE@3 STATX
067512                  *PAGLI@3  LDXTX
067513              OD
067514              *LDASG SEGLE        % CHECK NUMBER OF PAGES FIXED.
067524              IF A- +FIXPAGES < 0 THEN A:=0; K:="1"
067531                                  ELSE       K:="0" FI
067533              A=:FIXPAGES
067534              B=:X:=D
067536              A:="1INSEGLINK"     % LINK SEGMENT INTO LINK (ON SEGADM LEVEL)
067537              *IOF; IRW SLEVB DP
067541              SLEV; *MST PID; ION
067544              IF K THEN X:=B; GO ERRF FI
067550              IF X=NSEGA OR X=NSEGB GO RETSTUPR
067556          ELSE
067557              B:=:X
067560          FI
067560          GO RET
067561   *)FILL
067571
067571   ERRNL: B:=X; D0; CALL 9ERRA(#16); GO RETXIT    % EMPTY SEGMENT (NOT LOADED)
067576   ERRD:  B:=X; D0; CALL 9ERRA(#17); GO RETXIT    % FIXING DEMAND
067603   ERRF:  B:=X; D0; CALL 9ERRA(#18); GO RETXIT    % TOO MANY FIXED
067610   ERRIL:       D0; CALL 9ERRA(#15); GO RETXIT    % ILLEGAL SEGMENT NUMBER
067614   ERRPF: B:=X; D0; CALL 9ERRA(#96); GO RETXIT    % SEGMENT IS FIXED IN PIT
067621   RBUS
067623

067623   %==============================================================================
067623   % 36.8   (R)    R E E N T
067623
067623   % MONITOR CALL REENT(SEGNO) - ATTACH REENTRANT SEGMENT
067623   SUBR REENT,IMREENT
067623   DISP 0; INTEGER RESEG=D1; PSID
067623
067623   REENT: CALL GET1
067624   IMREENT:"1XCSEGS"; *IOF; IRW SLEVB DP   % CALL XCSEGS ON SEGADM LEVEL
067627           SLEV; *MST PID; ION
067632           IF D0><0 THEN
067634               CALL LEGSEG
067635               X=:RESEG; IF A NBIT 5DEMAND GO ERRD
067640               IF X=NSEGA OR X=NSEGB GO RETSTUPR
067646               CALL RLEGSEG
067647               GO NEWWAY
067650               CALL WIPCHECK
067651   NEWWAY:     X:=NSEGA:=:B; *LDASG FLAG
067663               X:=:B; T:=D0; CALL SHRSOVERLAP
067666               X:=NSEGB:=:B; *LDASG FLAG
067700               X:=:B; T:=D0; CALL SHRSOVERLAP
067703               NSEGA; T:=RESEG; CALL OVERLAP
067706               NSEGB; T:=RESEG; CALL OVERLAP
067711           FI
067711           X:=RTREF; CALL CLRBMAP
067713   OUT:    D0=:RTREF.RSEGM; GO RETSTUPR
067717
067717   ERRD:   CALL 9ERRA(#45); GO RETXIT  % NOT DEMAND SEGMENTS
067722   *)FILL
067741   %=====================================================================
067741   %
067741   %      W I P C H E C K         CHECK WHETHER REENTRANT SEGMENT IS
067741   %                              MODIFIED AND WRITE IT BACK BEFORE USING IT.
067741   %                              CALLED WITH X=SEGMENT TABLE POINTER.
067741   DISP 0;INTEGER POINTER LREG=D2; PSID
067741
067741   WIPCHECK:
067741          A:=L=:"LREG"
067743          T:=SEGTBANK; *BPAGL@3 LDXTX             % GET PAGE LIST OF REENTRANT SEGMENT.
067745          T:=CORMBANK
067746          DO WHILE X><0                           % FOR WHOLE PAGE LIST DO
067747              *PROTE@3 LDATX
067750              IF A BIT 5WIP THEN                  % IF RSEGM HAS MODIFIED PAGE THEN
067752                  A:=D0; X:=RESEG; CALL WSEGX     % WRITE SEGMENT TO DISK.
067755                  GO LREG                         % CONTINUE WITH MON REENT.
067756              FI
067756              *PAGLI@3 LDXTX                      % GET NEXT PAGE.
067757          OD
067760          GO LREG                                 % CONTINUE WITH MON REENT
067761
067761   RBUS
067764

067764   %===========================================================================
067764   %
067764   %       E N T S G       MON ENTSG   ENTER A FIXED SEGMENT INTO A PAGE TABLE
067764   %
067764   %       PARAMETERS:     A - PARAMETER LIST
067764   %                               SEGMENT NUMBER
067764   %                               PAGE INDEX TABLE
067764   %                               INTERRUPT LEVEL
067764   %                               START ADDRESS
067764   %
067764   %       RETURN:         A - STATUS
067764   %                           0  - OK
067764   %                           <0 - ERROR:
067764   %                                -1  : ATTEMPT TO ENTER TOO MANY SEGMENTS
067764   %                                -2  : ILLEGAL SEGMENT NUMBER
067764   %                                -3  : ILLEGAL PAGE INDEX TABLE SPECIFIED
067764   %                                -4  : SEGMENT IS NOT FIXED
067764   %                                -5  : ILLEGAL INTERRUPT LEVEL
067764   %                                -6  : WANTED PIT ENTRY WAS IN USE
067764   %
067764   SUBR ENTSG
067764   %               GLOBAL VARIABLES AND SYMBOLS
067764   %
067764   %               ESMAX   : MAX NUMBER OF SEGMENTS THAT MAY BE ENTERED.
067764   %               ESCNT   : NUMBER OF SEGMENTS CURRENTLY ENTERED.
067764   %               ESDATA  : ARRAY OF SEGMENTS ENTERED (3 WORDS PER SEGMENT)
067764   %               ESBANK  : PHYSICAL BANK OF ESDATA.
067764   %               ESEDATA : END OF ESDATA.
067764   %
067764   %               SGMAX   : HIGHEST POSSIBLE SEGMENT NUMBER
067764   %
067764   %               LAYOUT OF ESDATA ENTRIES
067764   DISP 0
067764       INTEGER ESSGNO          % NUMBER OF ENTERED SEGMENT.
067764       INTEGER ESPTLV          % PIT (LEFT BYTE) AND LEVEL (RIGHT BYTE) OF SEGMENT
067764       INTEGER ESADR           % START ADDRESS FOR THIS LEVL
067764   PSID
067764
067764   DISP 0
067764       INTEGER SGNO=D0         % SEGMENT NUMBER    (PARAMETER)
067764       INTEGER PITNO=D1        % PIT NUMBER        (PARAMETER)
067764       INTEGER ILNO=D2         % INTERRUPT LEVEL   (PARAMETER)
067764       INTEGER STAD=D3         % START ADDRESS     (PARAMETER)
067764       INTEGER SGAD=D4         % SEGMENT TABLE ADDRESS
067764       TRIPLE  ESPAR=D5        % PARAMETER TO DOENTSG ROUTINE
067764       INTEGER ES1PAR=D5       % FIRST WORD OF ESPAR
067764       DOUBLE  ES23PAR=D6      % SECOND AND THIRD WORD OF ESPAR
067764   PSID
067764
067764   ENTSG:  CALL GET4                       % GET PARAMETERS AND DISABLE MLEV
067765           IF ESCNT >= ESMAX GO FAR ERRMX  % TOO MANY SEGMENTS ENTERED
067771           IF SGNO >> SGMAX GO FAR ERRSG   % ILLEGAL SEGMENT NUMBER
067775           A*5SEGSIZE+SEGSTART=:SGAD       % COMPUTE SEGMENT TABLE ADDRESS
070000           IF PITNO><6 AND <=7 OR >>17 GO FAR ERRPT% ILLEGAL PAGE INDEX TABLE (MUST BE 10B TO 17B OR 6)
070012           T:=SEGTBANK; X:=SGAD; *SGSTA@3 LDATX    % A:=SGAD.SGSTA
070015           IF A NBIT 5FIX GO FAR ERRFX     % SEGMENT MUST BE FIXED
070017           IF ILNO<5 OR >11 GO FAR ERRLV   % INTERRUPT LEVEL MUST BE IN 5 TO 11 (OCT)
070026           X:="ESPAR"+B                    % X POINTS TO ESPAR.
070030           SGNO=:X.ESSGNO              % BUILD ESDATA ENTRY IN ESPAR (SEGNO)
070032           PITNO SH 10 +ILNO=:X.ESPTLV %                     (PIT AND LEVEL)
070036           STAD=:X.ESADR               %                     (START ADDRESS)
070040           T:= ESBANK
070041           A:=ESEDATA=:L
070043           X:=ESDATA                   % MAKE IT POSSIBLE TO ENTER A SEGMENT
070044           DO                          % ON SEVERAL INTERRUPT LEVEL
070044              *LDDTX
070045              IF A-SGNO=0 THEN
070047                  D SHZ -10 =: A
070051                  IF A-PITNO= 0  THEN
070053                     AD:= ES23PAR
070054                     GO DOLVENT        % GO IN ROUTINE DOENTSG
070055                  FI
070055              FI
070055              X+3
070056                  WHILE X << L
070060           OD
070061
070061           PITNO SH 7+174000=:L        % POINTER TO PIT.
070065                                       % CHECK WHETHER PIT ENTRIES ARE USED OR NOT.
070065           T:=SEGTBANK; X:=SGAD; *BPAGL@3 LDXTX    % GET PAGE LIST OF SEGMENT
070070           T:=CORMBANK
070071           DO WHILE X >< 0             % TO END OF PAGE LIST
070072               *LOGPA@3 LDATX          % FIND LOGICAL PAGE NUMBER OF PAGE
070073               X=:D                    % SAVE X IN D
070074               A/\77 SH 1\/L=:X        % COMPUTE PIT POINTER FOR THIS PAGE
070100               T:=0; *LDATX            % READ PIT ENTRY
070102               IF A >< 0 GO ERRPIT     % PIT WAS NOT EMPTY
070103               X:=D; T:=CORMBANK       % RESTORE X
070105               *PAGLI@3 LDXTX          % NEXT PAGE IN LIST
070106           OD
070107           GO L1; *)FILL               % PIT ENTRIES ARE NOT USED
070133   L1:     TAD:=ESPAR                  % PARAMETERS FOR DOENTSG
070134           CALL DOENTSG                % SET UP PIT, PIE, PCR AND P-REG.
070135           T:=ESBANK; X:=ESDATA        % TX POINTS TO ESDATA ARRAY
070137           ESEDATA=:D                  % END OF ESDATA
070141           DO                          % FIND A FREE ENTRY IN ESDATA
070141               *LDATX                  % READ THE FIRST WORD OF AN ENTRY
070142           WHILE A><0                  % WHILE ENTRY TAKEN
070143               X+3                     % NEXT ENTRY
070144           WHILE X << D OD             % UNTIL END OF TABLE
070147           IF X>>=D THEN CALL ERRFATAL FI % AN ENTRY SHOULD ALWAYS BE FOUND HERE
070152           A:=ES1PAR;   *STATX 00      % MOVE ESPAR TO ESDATA
070154           AD:=ES23PAR; *STDTX 10
070156           MIN ESCNT                   % INCREASE NUMBER OF USED ESDATA ENTRIES
070157           0=:ZAREG                    % INDICATE SUCCESSFUL COMPLETION
070160           GO RET                      % END OF MONITOR CALL
070161
070161   % ERROR HANDLING
070161   %
070161   ERRMX:  -1; GO ERRRR    % ATTEMPT TO ENTER TOO MANY SEGMENTS
070163   ERRSG:  -2; GO ERRRR    % ILLEGAL SEGMENT NUMBER
070165   ERRPT:  -3; GO ERRRR    % ILLEGAL PAGE INDEX TABLE SPECIFIED
070167   ERRFX:  -4; GO ERRRR    % SEGMENT IS NOT FIXED
070171   ERRLV:  -5; GO ERRRR    % ILLEGAL INTERRUPT LEVEL
070173   ERRPIT: -6              % WANTED PIT ENTRY WAS IN USE
070174
070174   ERRRR:  A=:ZAREG        % SET ERROR CODE IN A REGISTER
070175           GO RET          % END OF MONITOR CALL
070176   RBUS
070205

070205   %=======================================================================
070205   %
070205   %       U R E M S G     CALLED FROM UNFIX TO REMOVE SEGMENT FROM PITS
070205   %                       BEFORE UNFIXING.
070205   %
070205   %       R E M S G       MON SGMTY
070205   %                       FUNCTION 4: REMOVE SEGMENT (ENTERED W/ENTSG) FROM PIT
070205   %
070205   %       PARAMETERS:     T - PARAMETER LIST
070205   %                              FUNCTION (4)
070205   %                              ZERO (0)
070205   %                              SEGMENT NUMBER
070205   %                              ZERO (0)
070205   %                              ZERO (0)
070205   %
070205   %       RETURN:         A - STATUS
070205   %                           0  - OK
070205   %                           <0 - ERROR:
070205   %                                -1  : SEGMENT NOT ENTERED
070205   %                                -2  : ILLEGAL SEGMENT NUMBER
070205   %                                -3  : NO SEGMENTS ENTERED
070205   %                                -4  : ILLEGAL PARAMETER
070205   %
070205   SUBR XREMSG, UREMSG
070205
070205   DISP 0
070205       INTEGER SGNO=D2     % SEGMENT NUMBER (PARAMETER)
070205       INTEGER SGAD=D5     % SEGMENT TABLE ADDRESS
070205       INTEGER LREG=D6     % RETURN ADDRESS IF UREMSG
070205       INTEGER SAVX=D7     % SAVED X-REG IN UREMSG
070205   PSID
070205
070205   UREMSG: A=:D:=L=:LREG               % D:=SEGNO, SAVE RETURN ADDRESS.
070210           X=:SAVX                     % SAVE X-REG.
070211           IF T:=ESCNT=0 GO UERR       % NO SEGMENTS ENTERED, RETURN.
070214           A:=D                        % RESTORE A.
070215           GO FELLS
070216
070216   XREMSG: 0=:LREG                     % PARAMETERS ARE FETCHED AND MLEV IS DISABLED BY SGMTY.
070217           IF D1><0 OR D3><0 OR D4><0 GO ERRIL    % ILLEGAL PARAMETER.
070226           IF ESCNT=0 GO ERRNS         % NO SEGMENTS ENTERED.
070230           SGNO=:D                     % SEGMENT NUMBER IS HELD IN D-REGISTER.
070232           IF A>SGMAX GO ERRSG         % VERIFY SEGMENT NUMBER.
070235
070235   FELLS:  A*5SEGSIZE+SEGSTART=:SGAD   % COMPUTE SEGMENT TABLE ADDRESS.
070240           ESEDATA=:L                  % L POINTS TO END OF ESDATA.
070242           T:=ESBANK; X:=ESDATA        % TX POINTS TO ESDATA.
070244           DO                          % LOOP THROUGH ESDATA.
070244               *LDATX 00               % READ FIRST WORD OF EACH ENTRY.
070245           WHILE A >< D                % UNTIL WANTED ENTRY FOUND.
070247               X+3                     % NEXT ENTRY
070250           WHILE X << L                % UNTIL END OF TABLE
070252           OD
070253           IF A = D THEN               % IF ENTRY WAS FOUND
070255               *LDATX 10; STZTX 00     % READ PIT AND LEVEL, RESET SEGMENT NUMBER.
070257               A SHZ -10               % SEPARATE PIT NUMBER.
070260               A SHZ 7 + 174000=:D     % COMPUTE PIT POINTER.
070263               T:=SEGTBANK; X:=SGAD    % TX POINTS TO SEGMENT ENTRY.
070265               *BPAGL@3 LDXTX          % GET PAGE LIST.
070266               CALL DOREMSG            % CLEAR PIT FOR THIS SEGMENT.
070267               ESCNT-1=:ESCNT          % DECREASE NUMBER OF ENTERED SEGMENTS.
070272               IF A<0 THEN CALL ERRFATAL FI % SHOULD NEVER BECOME NEGATIVE.
070274               IF LREG><0 GO UOK       % UREMSG OK.
070276               0=:ZAREG                % OK
070277           ELSE
070300               IF LREG><0 GO UERR      % UREMSG ERROR.
070302               -1=:ZAREG               % SEGMENT NOT PREVIOUSLY ENTERED.
070304           FI
070304           GO RET                      % END OF MONITOR CALL
070305
070305   % ERROR HANDLING
070305   %
070305   ERRSG:  -2; GO ERRRR    % ILLEGAL SEGMENT NUMBER
070307   ERRNS:  -3; GO ERRRR    % NO SEGMENTS ENTERED
070311   ERRIL:  -4              % ILLEGAL PARAMETER
070312
070312   ERRRR:  A=:ZAREG        % SET ERROR CODE IN A-REGISTER
070313           GO RET          % END OF MONITOR CALL
070314
070314                           % UREMSG RETURNS, CALLED WITH RETURN ADDRESS IN A.
070314   UERR:   A+1             % SEGMENT NOT ENTERED, SKIP RETURN.
070315   UOK:    X:=SAVX; A=:P   % SEGMENT REMOVED, NORMAL RETURN.
070317   RBUS
070333

070333   *"8SREE
"070333

070333   %==============================================================================
070333   %      (R)      S G A N D   S G O R
070333   %
070333   % SUBROUTINES TO THE SEGMENT-WRITE-PERMIT AND SEGMENT-WRITE-PROTECT COMMANDS
070333   % ENTRY: T=SEGMENT TABLE ENTRY
070333   %
070333   SUBR SGAND,SGOR
070333
070333   SGAND: K:="0"; GO FELLS
070335   SGOR:  K:="1"
070336
070336   FELLS: MLEV; *MCL PIE
070340
070340          "1XCSEGS"; *IOF; IRW SLEVB DP   % CLEAR USERS SEGMENTS FROM PIT
070343          SLEV; *MST PID; ION
070346
070346          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR S3SEG FROM PIT
070351          SLEV; *MST PID
070353          S3SEG; *ION
070355          0=:S3SEG
070356
070356          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR FILE SYSTEM FROM PIT
070361          SLEV; *MST PID
070363          FILSEGM; *ION
070365   *"8RFAC
"070365          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR RFA SEGMENT FROM PIT
070370          SLEV; *MST PID
070372          FUSEGM; *ION
070374   *"8N500
"070374          "1XCLSEG"; *IOF; IRW SLEVB DP   % CLEAR ND500 SEGMENT FROM PIT
070377          SLEV; *MST PID
070401          5NSEGM; *ION
070403   *"
"070403          B=:D:=T
070405          *LDASG SGSTA
070415          IF K THEN A BONE 5WPM ELSE A BZERO 5WPM FI
070422          *STASG SGSTA
070432          *LDXSG BPAGL
070441          B:=D
070442          T:=CORMBANK
070443          DO WHILE X><0
070444              *PROTE@3 LDATX
070445              IF K THEN
070447                  A BONE 5WPM
070450              ELSE
070451                  A BZERO 5WPM
070452              FI
070452              *PROTE@3 STATX
070453              *PAGLI@3 LDXTX
070454          OD
070455
070455          T:=SEGTBANK
070456          X:=FILSEGM; *BPAGL@3 LDXTX
070460          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER FILE SYSTEM INTO PIT
070463          SLEV; *MST PID; ION
070466   *"8RFAC
"070466          X:=FUSEGM; *BPAGL@3 LDXTX
070470          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER RFA SEGMENT INTO PIT
070473          SLEV; *MST PID; ION
070476   *"8N500
"070476          X:=5NSEGM; *BPAGL@3 LDXTX
070500          "1XSSEG"; *IOF; IRW SLEVB DP   % ENTER ND500 SEGMENT INTO PIT
070503          SLEV; *MST PID; ION
070506   *"
"070506          "STUPR"; *IOF; IRW MLEVB DP     % SET UP USER SEGMENTS.
070511          MLEV; *MST PIE; MST PID; ION
070515          EXIT
070516   RBUS
070530
070530
070530   %============================================================================
070530   % 37.18   (R)   A T R N S E G
070530   %
070530   % SUBROUTINE ON APPLICATION LEVEL TO START
070530   % TRNSEG ON MONITOR LEVEL
070530   %
070530   % ENTRY:     A=NUMBER OF PAGES TO TRANSFER
070530   %            X=ADDRESS OF CORMAP ENTRY
070530   %            D=READ/WRITE FLAG
070530   %            T=SEGMENT ADDRESS
070530   %
070530   SUBR ATRNSEG
070530   INTEGER CT,CA,CD,CX,CB; TRIPLE CTAD=CT
070535   INTEGER POINTER CLR
070536   ATRNSEG: TAD=:CTAD; X=:CX:=L=:"CLR":=B=:CB
070544   LOOP:  *IOF
070545          "XTRNSEG"; *IRW SLEVB DP
070547          CT; *IRW SLEVB DB
070551          CX; *IRW SLEVB DX
070553          CD; *IRW SLEVB DA
070555          CA; *IRW SLEVB DD
070557          "SLEV+MLEV";*MST PID; MST PIE; ION
070563          TAD:=CTAD; X:=CB=:B:=CX
070567          GO CLR
070570   RBUS
070571
070571   %==============================================================================
070571   %
070571   %   (R)   INTERFACE FOR CALLING XOVERLAP ON SLEV.
070571   %
070571   SUBR OVERLAP
070571   OVERLAP:
070571          *IOF
070572          *IRW SLEVB DA
070573          A:=T; *IRW SLEVB DT
070575          A:="XOVERLAP"
070576          *IRW SLEVB DP
070577          SLEV; *MST PID; ION
070602          EXIT
070603   RBUS
070604
070604
070604   %==============================================================================
070604   %
070604   %   S H R S O V E R L A P          SHADOW & REENTRANT SEGMENTS OVERLAP
070604   %
070604   % ENTRY:   A=SEGMENT FLAG OF SHADOW SEGMENT
070604   %          X=SEGMENT TABLE ADDRESS OF SHADOW SEGMENT
070604   %          T=SEGMENT NUMBER OF REENTRANT SEGMENT
070604   % EXIT:    NO OVERLAP
070604   %
070604   % IF ERROR: RETURN TO RETXIT (TERMINATE CALLING PROGRAM)
070604   %
070604   SUBR SHRSOVERLAP
070604   INTEGER XREG,CSTRA,CLA; DOUBLE CSTLA=CSTRA
070607
070607   SHRSOVERLAP:
070607          IF A BIT 5DEMAND OR T=0 OR X=0 THEN EXIT FI
070616          X=:XREG
070617          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *LOGAD@3 LDDTX
070625          AD=:CSTLA               % START AND LENGTH
070626          X:=XREG; *LOGAD@3 LDDTX
070630          IF A>CSTRA THEN
070633              IF A-CLA<T GO 45ERR
070636          ELSE
070637              IF A+D>T GO 45ERR
070642          FI
070642          EXIT           % OK, NO OVERLAP
070643
070643   % ERROR, REENTRANT SEGMENT OVERLAP NONDEMAND SEGMENT
070643   45ERR: CALL 9ERRA(#45); GO RETXIT
070646
070646   RBUS
070653
070653   %=============================================================================
070653   %       (R)     S S S W P
070653   %
070653   % RT-PROGRAM RESERVING THE SWAPPING-SEMAPHORE (CLFIE) AND WAITING FOR
070653   % THE DISC ON BEHALF OF THE SWAPPING-REQUESTING PROGRAM
070653   % THE SWAPPING-REQUESTING PROGRAM WILL BE SET IN SWAPPING-WAIT
070653   %
070653   SUBR SSSWP
070653   INTEGER XREGG
070654   SSSWP: *IOF
070655          "XRTEX"; *IRW MLEVB DP
070657          MLEV; *MST PID; ION
070662          GO SSSWP
070663   RBUS
070665

070665   %===========================================================================
070665   %            S P L R E E
070665   % MON SPLREE(SGNO,FP1,NP1,FP2,LP2,FLAG)
070665   %            FP1= FIRST PAGE IN LOG.AREA 1 TO OVERLAP BACKGROUND SEGMENT
070665   %            NP1= NUMBER OF PAGES IN AREA 1
070665   %            FP2= FIRST PAGE IN LOG.AREA 2 TO OVERLAP BACKGROUND SEGMENT
070665   %            NP2= NUMBER OF PAGES IN AREA 2
070665   %            FLAG><0: CLEAR PAGE-OWNER TABLE
070665   %
070665   SUBR SPLRE
070665   DISP 26                      % D5+1
070665   INTEGER CBSGNO,CPOTADDR,CCFP,CCLP,CORSEGM,CCBMX,CCPOTADDR,CREBMAP,CURRX
070665   INTEGER NEXTX=CCPOTADDR,CBPIDX=CPOTADDR
070665   INTEGER CFP1=D1,CLP1=D2,CFP2=D3,CLP2=D4
070665   DOUBLE DDDS1=CFP1,DDDS2=CFP2,DDDD0=D0,DDDD2=D2,DDDD4=D4,CCLMS=CCFP
070665   PSID
070665
070665   DISP 0; TRIPLE 3BM0,3BM3; DOUBLE 2BM6; PSID
070665
070665   % COMPUTE ADDRESSES AND SIZES USED BY SEVERAL ROUTINES
070665   %
070665   GTVALUES:
070665          AD=:CCLMS
070666          T:=D-A; AD SHZ -4; A+CREBMAP=:CCBMX
070673          AD SHZ 7; A/\170=:D
070676          CCFP+CPOTADDR=:CCPOTADDR
070701          EXIT
070702
070702   % FOR ALL PAGES IN PREVIOUS LOGICAL ADDRESS AREA DO
070702   %      IF BIT OF CORRESPONDING PAGE IN BITMAP IS SET THEN
070702   %         SET CORRESPONDING POT-TABLE ENTRY EQUAL CURRENT REENTRANT SEGMENT
070702   %      FI
070702   % OD
070702   %
070702   INTEGER POINTER LREG=?
070702   INTEGER ENDINSTR(0); *BSKP ONE 170 DT
070703   INTEGER CINSTR(0); *BSKP ONE 00 DT
070704   STPOTTABLE: T:=L=:"LREG"; CALL GTVALUES
070707           T=:L; A:=CINSTR; D\/A
070712           DO WHILE L>>0                            % FOR ALL BITMAP LOCATIONS DO:
070714              X:=CCBMX;T:=0;*LDATX
070717              A=:T
070720              IF T><0 THEN                    % IF UNEQUAL ZERO
070722                  *EXR SD                     % TEST EACH BIT
070723                  GO NOTSET                   % DON'T CHANGE POT IF BIT NOT SET
070724                  A:=CORSEG                   % A = RSEGM FROM RT-DESC
070725                  T:=SREBBANK                 % T = BANK OF POT
070726                  X:=CCPOTADDR                % X = ADDRESS OF POT ENTRY
070727                  *STATX                      % STORE IT
070730   NOTSET:        MIN CCPOTADDR; 0/\0         % INCREMENT POT POINTER
070732                  L-1
070733                  T:=10
070734                  IF D+T>>ENDINSTR GO INELSE  % MODIFY BSKP INSTRUCTION TO TEST FOR NEXT BIT
070740             ELSE % BITMAP WORD IS 0
070741                  A:=D SHZ -3/\17; T:=20-A    % T = NUMBER OF APPLICABLE BITS IN THIS WORD
070746                  L-T                         % DECREASE LOOP COUNTER
070747                  CCPOTADDR+T=:CCPOTADDR      % INCREASE POT POINTER
070752   INELSE:        CINSTR=:D; MIN CCBMX        % MAKE READY TO TEST NEXT BITMAP WORD
070755             FI
070755           OD
070756           GO LREG
070757
070757   INTEGER CBSET(0); *BSET ZRO 00 DA
070760   INTEGER LBSET(0); *BSET ZRO 170 DA
070761   INTEGER POINTER LREG
070762   MBCLBITS:T:=L=:"LREG"; CALL GTVALUES
070765          T=:L; A:=CBSET; D\/A
070770          DO WHILE L><0                       % FOR ALL PAGES IN LOGICAL AREA DO:
070772              X:=CCPOTADDR; T:=SREBBANK; *LDATX   % READ A WORD FROM POT-TABLE
070775              IF A-D0><0 THEN                     % IF UNEQUAL SEGMENT NO IN PARAMETERLIST
070777                  A:=CBSGNO
071000                  *STATX                          % UPDATE POT WITH BG SEGM
071001                  X:=CCBMX; T:=0                  % AND BITMAP
071003                  *LDATX; EXR SD; STATX           % SET THE RESPECTIVE BIT TO 0
071006              FI
071006              T:=10
071007              IF D+T>>LBSET THEN                  % IF LAST BIT IN THIS LOC. HAS BEEN SET
071013                  CBSET=:D; MIN CCBMX; 0/\0       %   MAKE READY FOR THE NEXT ONE
071017              FI
071017              MIN CCPOTADDR; 0/\0
071021              L-1
071022          OD                                  % END FOR
071023          GO LREG
071024   *)FILL
071027
071027   DOUBLE ALLONES=?
071027
071027   CCHLIMS: D+A; IF C OR A>>200 OR D>>T GO CR15ERRD
071037            EXIT
071040
071040   CR15ERRD: D0; GO R15ERRD
071042
071042   INTEGER SVDFLAG
071043   ESPLRE: IF SVDFLAG NBIT 5IESC THEN
071046              CALL GETDATAFIELD; *IOF
071050              T:="DFLAG"; CALL XGTDFADDR
071052              A BZERO 5IESC
071053              T:="DFLAG"; CALL XSTDFADDR
071055              *ION
071056           FI
071056           GO RETSTUPR
071057   *)FILL
071066
071066   SPLRE:  CALL GET6
071067           "BFIELD".BPIUSINDX=:CBPIDX                         % GET BP IDX BEFORE CLEARING PITS
071072           X.TTIFIELD.DFLAG=:SVDFLAG BONE 5IESC =:X.DFLAG     % DISABLE ESCAPE AND REMEMBER ESCAPE STATE.
071077           "1XCSEGS"; *IOF; IRW SLEVB DP                      % CALL XCSEGS ON SEGADM LEVEL
071102           SLEV; *MST PID; ION
071105           RTREF.SEGM2+1=:CBSGNO                              % GET BACKGROUND SEGMENT NO (SYS.SEGM.+1)
071111           IF A*5SEGSIZE+SEGSTART><NSEGB GO RETSTUPR          % IF UNEQUAL NSEGB START THEN SOMETHING WRONG, RETURN
071116           CBPIDX*POTESIZE+SREBADDR=:CPOTADDR                 % CPOTADDR = POINTER TO POT-ENTRY
071122           RTREF.RSEGM=:CORSEGM                               % SAVE REENTRANT SEGMENT NUMBER
071125           X.RTDLGADDR+5BITMAP=:CREBMAP
071130           IF D0=0 AND CORSEGM=0 THEN
071134              X:=NSEGB; CBSGNO; CALL WSEGX                    % WRITE SHADOW SEGMENT BACK
071137           FI
071137           IF D0><0 THEN                                      % IF SEGMENT NUMBER UNEQUAL O
071141              CALL LEGSEG; IF A NBIT 5SREEP GO CR15ERRD       % LEGAL SEGMENT ? DEMAND SEGMENT?
071144              T:=SEGTBANK; *SGSTA@3 LDATX
071146              IF A SHZ -11/\3><0 GO CR15ERRD                  % RING ><0 ?
071151              *LOGAD@3 LDATX
071152              IF A SHZ -6/\17<1 OR A>2 GO CR15ERRD      % PAGE TABLE MUST BE 1 OR 2
071162           FI
071162           AD:=DDDS1; CALL CCHLIMS; AD=:DDDS1                 % LOGICAL AREA 1 TOO LARGE?
071165           AD:=DDDS2; CALL CCHLIMS; AD=:DDDS2                 % LOGICAL AREA 2 TOO LARGE?
071170           GO OVFI; *)FILL
071210   OVFI:   IF D5><0 THEN                                      % IF POT-ENTRY FOR THIS PROGRAM IS TO BE CLEARED
071212              X:=CPOTADDR; A:=X+200=:L                        %    X POINTS TO START OF POT-ENTRY, L POINTS TO THE NEXT
071216              CBSGNO=:D; T:=SREBBANK
071221              DO WHILE X><L                                   %    FOR ALL BYTES IN THE POT-ENTRY
071223                 *STDTX; AAX 2                                %    FILL IN BACKGROUND SEGMENT NUMBER
071225              OD;
071226           ELSE
071227              IF CORSEGM><0 THEN
071231                 X:=CPOTADDR; T:=SREBBANK; *AAX 177; LDDTX 10 % AD:=<T,X+200> PREVIOUS LOG. AREA
071235                 CALL FAR STPOTTABLE
071236                 X:=CPOTADDR; T:=SREBBANK; *AAX 177; LDDTX 30 % AD:=<T,X+202> PREVIOUS LOG. AREA
071242                 CALL FAR STPOTTABLE
071243              FI
071243           FI
071243           X:=CREBMAP;AD:=ALLONES;T:=0
071246           *STDTX; STDTX 20; STDTX 40; STDTX 60               % SET WHOLE BITMAP TO 1
071252           IF D0><0 THEN
071254              AD:=DDDS1; CALL FAR MBCLBITS
071256              AD:=DDDS2; CALL FAR MBCLBITS
071260           FI; GO L1; *)FILL
071265
071265
071265   DOUBLE ALLONES(0); DATA(-1,-1)
071267   INTEGER POINTER PPBPAG1:=BPAG1
071270   INTEGER CBSKP(0); *BSKP ZRO 00 DT
071271
071271   L1:     AD:=DDDS1; T:=SREBBANK; X:=CPOTADDR; *AAX 177; STDTX 10 % AD=:<T,X+200> SET PREVIOUS LOG. AREA
071276           T:=100; A+T; D+T; AD=:DDDS1
071302           AD:=DDDS2; T:=SREBBANK; *STDTX 30                       % AD=:<T,X+202> SET PREVIOUS LOG. AREA
071305           T:=100; A+T; D+T; AD=:DDDS2
071311           IF D0=0 GO FAR ENDIF         % IF D0><0 THEN
071314              B=:L
071315              X:=NSEGB
071316              T:=SEGTBANK; *BPAGL@3 LDXTX
071320              DO WHILE X><0       % FOR ALL PAGES IN BACKGROUND SEGMENT DO
071321                  *LDACM PAGLI
071327                  A=:NEXTX; X=:CURRX
071331                  *LDACM LOGPA
071337                  IF A>=CFP1 AND A<CLP1 GO COVERLAP
071345                  IF A<CFP2 OR A>=CLP2 GO NOVERLAP
071353                  GO COVERLAP;    *)FILL
071361   COVERLAP:      A-100; AD SHZ -4; A+CREBMAP=:X  % IF PAGE IS WITHIN NEW RSEGM
071365                  AD SH 7; A/\170+CBSKP;          % AND BIT NOT SET IN BITMAP
071370                  T:=0; *LDXTX; COPY SX DT ;EXR SA
071374                  GO NOVERLAP
071375                  X:=CURRX                        % THEN REMOVE PAGE FROM SEGMENT
071376                  *2REMP
071414                  XSGRT=:B
071416                  *2INSP                          % AND LINK TO DUMMY SEGMENT
071440                  *LDASG SGSTA                    % COPY DUMMY SEGS PROTECT ENTRY
071450                  *STACM PROTE
071456                  B:=L
071457   NOVERLAP:      X:=NEXTX
071460              OD
071461              T:=SEGTBANK; X:=XSGRT
071463              *SEGLI@3 LDATX
071464              A=:D; *BPAGL@3 LDATX
071466              GO L2; *)FILL                       % IF DUMMY SEGMENT WAS EMPTY
071475   L2:        IF A><0 AND D=0 THEN                % AND NOT IN SEGMENT LIST
071500                  "1INSEGLINK"; *IOF; IRW SLEVB DP    % THEN LINK IT INTO LIST
071503                  SLEV; *MST PID; ION        % ON SEGADM LEVEL
071506                  X:=BSEGLINK; T:=SEGTBANK
071510                  *SEGLI@3 LDATX
071511                  A=:BSEGLINK
071512              FI
071512
071512          ENDIF: %  FI
071512          D0=:RTREF.RSEGM                     % SET NEW RSEGM
071515          GO FAR ESPLRE
071516   RBUS
071523

071523   %============================================================================
071523   % 36.15    (R)   S T M L E V   Y T R N S E G
071523   %
071523   SUBR STMLEV,YTRNSEG
071523   STMLEV:    *ION; EXIT
071525
071525   YTRNSEG:   "XTRNSEG"; *IOF; IRW SLEVB DP   % START XTRNSEG ON SEGADM LEVEL.
071530              SLEV; *MST PID; ION
071533              EXIT
071534   RBUS
071535
071535   %==============================================================================
071535   % 36.7   (R)  W S E G   -   W S E G X   -  W S O U T
071535   %
071535   % MONITOR CALL: CALL WSEG(SEGNO) - WRITE BACK SEGMENT
071535   %
071535   SUBR WSEG, WSEGX, WSOUT
071535
071535   INTEGER POINTER CRETADR    % RETURN ADDRESS
071536   INTEGER SVFLG              % SAVED FLAG
071537
071537   WSEG:  CALL GET1
071540          "RET"=:"CRETADR"
071542          D0=:WSSG  ; A BZERO 17      % CLEAR BIT 17
071545          CALL 0LEGSEG                % LEGAL SEGMENT
071546          T:=SEGTBANK; *SGSTA@3 LDATX
071550          IF A BIT 5SPTFIXED GO RET   % IGNORE WSEG OF SEGMENTS FIXED IN PIT.
071552   FELLS: X=:WSSGA
071553          CALL SRESER             % RESERVE SWAPPING RESOURCES
071554          T:=SEGTBANK; X:=WSSGA; *FLAG@3 LDATX
071557          A=:SVFLG BZERO 5OK;    *FLAG@3 STATX
071562          RTREF=:SRTREF; X=:SEGREF
071565          *IOF
071566          A:=X;     *IRW SLEVB DB
071570          "SMWSEG"; *IRW SLEVB DP % START SMWSEG ON SEGADM LEVEL
071572          "MLEV+SLEV"; *MST PID   % TO DO THE ACTUAL WRITEBACK
071574          MLEV; *MST PIE
071576          *ION; IOF
071600          MLEV; *MCL PIE
071602          *ION
071603          A:=SVFLG; *FLAG@3 STATX % RESET OLD FLAG
071605          CALL SRELES             % RELEASE SWAPPING RESOURCES
071606   WSOUT: GO CRETADR
071607
071607   % CALLED FROM 3SPLREE
071607   % ENTRY:     A=SEGMENT NUMBER
071607   %            X=ADDRESS OF SEGMENT TABLE ENTRY
071607   %
071607   WSEGX: A=:WSSG:=L=:"CRETADR"; GO FELLS
071613   RBUS
071627

071627   %==============================================================================
071627   %      (R)   S R E S E R   -   S R E L E S
071627   %
071627   % SUBROUTINES TO RESERVE AND RELEASE ALL SWAPPING RESOURCES
071627   %
071627   % ENTRY:     B=MONITOR CALL WORKING FIELD
071627   %
071627   SUBR SRESER,SRELES,ZSRELES
071627   INTEGER BRG,CINDX,XREGG
071632   INTEGER POINTER CLR
071633
071633   SRESER: A:=L=:"CLR":=B=:BRG; X=:XREGG
071640          X:=RTREF; "CLFIE"=:B
071643          CALL BRESERVE
071644          IF A<0 THEN
071645             CALL SRELES
071646             X.STATUS BONE 5WAIT BONE 5SWWAIT=:X.STATUS
071652             GO VENT
071653          FI
071653          0=:CINDX
071654          DO WHILE X:=CINDX<=7
071660             IF MASSNO(X)><0 THEN
071662                CALL LOGPH; A=:B; X:=RTREF; CALL BRESERVE
071666                IF A<0 THEN
071667                   CALL SRELES; CALL FREXQU; CALL TOWQU
071672                   GO VENT
071673                FI
071673             FI
071673             MIN CINDX
071674          OD
071675          BRG=:B; X:=XREGG; GO CLR
071701
071701   VENT:  BRG=:B; ZPREG-1=:ZPREG; GO M61RET
071707
071707   INTEGER CPROG,XINDX,BBRG,XXRG
071713   INTEGER POINTER CLLR
071714
071714   ZSRELES: X=:CPROG=:XXRG; GO FELLS
071717   SRELES: RTREF=:CPROG; X=:XXRG
071722   FELLS: A:=L=:"CLLR":=B=:BBRG
071726          0=:XINDX
071727          DO WHILE X:=XINDX<=7
071733             IF MASSNO(X)><0 THEN
071735                CALL LOGPH
071736                IF A.RTRES=CPROG THEN X=:B; X:=CPROG; CALL BRELEASE FI
071746             FI
071746             MIN XINDX
071747          OD
071750          "CLFIE"=:B; X:=CPROG; IF RTRES=X THEN CALL BRELEASE FI
071757          BBRG=:B; X:=XXRG; GO CLLR
071763   RBUS
071776
071776   @DEV 1
