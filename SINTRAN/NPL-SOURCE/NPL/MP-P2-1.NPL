050716   @DEV (S-S-L)MP-P2-1:NPL
050716   %==========================================================================
050716   %
050716   %
050716   %
050716   %==========================================================================
050716
050716   %==========================================================================
050716   %      P M T R A N S       INTERFACE BETWEEN SEGADM AND DISK DRIVER
050716   %
050716   SUBR PMTRANS
050716   INTEGER LREG
050717   INTEGER CHK:=0            % TO ENSURE PROPER CALLING SEQUENCE.
050720   PMTRANS:       IF CHK><0 GO PMTRANS
050723                  A-1=:CHK
050725                  *IRR SLEVB DB                % GET DATAFIELD FROM SLEV.
050726                  A=:B; *IRR SLEVB DL          % GET RETURN ADDRESS ON SLEV.
050730                  A+1=:LREG; *IRR SLEVB DA     % GET PARAMETER LIST FROM SLEV.
050733                  T:=7; CALL MTRANS            % DO DISK TRANSFER.
050735                  MIN CHK; *JMP *
050737                  *IRW SLEVB DA                % RETURNS WITH STATUS IN A-REG.
050740                  LREG; *IRW SLEVB DP          % RETURN TO SLEV.
050742                  SLEV; *MST PID; JMP *
050745   RBUS
050746
050746   %==============================================================================
050746   %     ( M )    I O R E M
050746   %
050746   % MONITOR FUNCTION ROUTINE TO START PROGRAM USING SYNC.MODEM
050746   %
050746   SUBR IOREM
050746   IOREM: IF X:=X.RTRES >< 0 THEN CALL RTENTRY; CALL FTIMQU FI
050752          GO STUPR
050753   RBUS
050756
050756
050756   *"8BACS
"050756   %==============================================================================
050756   %      BACKGROUND PROCESS ALLOCATION SYSTEM ROUTINES
050756   %==============================================================================
050756
050756   %============================================================================
050756   %            C M B A B P R O C
050756   %
050756   % CALLED FROM MON LOGIN
050756   %
050756   SUBR CMBABPROC
050756   CMBABPROC: CALL MBABPROC; GO MONEN
050760          A:=X; *IRW ALEVB DX; IRR ALEVB DP; AAA 1; IRW ALEVB DP
050765          GO MONEN
050766   RBUS
050770   *"
"050770
050770   SUBR MBABPROC,T2P08
050770
050770   *"8BACS
"050770   %=============================================================================
050770   %            C F B P P R O C       ( M )
050770   %
050770   % LOCAL SUBROUTINE TO SEARCH FOR A BACKGROUND PROCESS TO ALLOCATE
050770   %
050770   % ENTRY:     B=INPUT DATAFIELD
050770   %
050770   % EXIT:      NO BACKGROUND PROCESS FOUND
050770   %
050770   % EXIT+1:    BACKGROUND PROCESS FOUND.
050770   %            X=ADDRESS IN BACKGROUND PROCESS TABLE (SBPRTAB)
050770   %
050770   INTEGER BFOUND
050771   CFBP:     0=:BFOUND
050772             X:=ASBPRTAB
050773             DO WHILE X<<=AEBPRTAB-BPRTSIZE
050777                T:=MBSPRTAB; *CBPTE@3 LDATX
051001                IF A=B THEN EXITA FI                % BACKGROUND PROC FOUND
051004                IF A=0 AND BFOUND=0 THEN            % BACKG.PROC. IS FREE AND NO OTHER CANDIDATE IS FOUND
051007                   X=:D; *BBPRO@3 LDXTX
051011                   IF X.STATUS BIT 5RTOFF THEN X:=D; GO NXT FI
051016                   X:=D; *BPRFL@3 LDATX
051020                   IF A NBIT BPNAVAILABLE AND A/\BTYPRMASK><0 THEN % AVAILABLE AND LEGAL FOR THIS DEVICE TYPE?
051024                      X=:BFOUND                     % FREE ENTRY FOUND
051025                   FI
051025                FI
051025   NXT:         X+BPRTSIZE
051026             OD
051027             IF X:=BFOUND><0 THEN EXITA FI          % A FREE BACKGROUND PROCESS IS FOUND
051032             EXIT                                   % NO BACKGROUND PROCESS FOUND
051033   *)FILL
051037   *"
"051037
051037   %============================================================================
051037   %            M B A B P R O C       ( M )
051037   %
051037   % ALLOCATE BACKGROUND PROCESS
051037   %
051037   % MONITOR LEVEL - CALLED FROM MESCAPE
051037   %
051037   % ENTRY:     X= DATAFIELD
051037   %
051037   % EXIT:      STARTED A TAD USED AS A SERVER OR
051037   %            NOT TERMINAL/TAD OR NOT BOTH INPUT AND OUTPUT DATAFIELDS
051037   %            ARE FREE.
051037   %
051037   % EXIT+1:    X=BACKGROUND PROGRAM CONNECTED TO THE ACTUAL TERMINAL/TAD
051037   %
051037   % THIS ROUTINE WILL RETURN TO MONEN IF NO BACKROUND PROGRAM IS FOUND
051037   %
051037
051037   INTEGER POINTER LREG=?
051037   INTEGER CCBBPROG=?,PRVTADDR=?,CADDR=?,SVCLASS=?,SRVTAD=?
051037
051037   MBABPROC:
051037   *"-8BACS
"051037          IF X.RTRES><0 THEN EXIT FI                          % INPUT DATAFIELD FREE?
051042          IF X.TYPRING /\ BTYPRMASK = 0 THEN  EXIT FI         % NOT TERMINAL OR TAD
051046          A:=L=:"LREG"
051050          T:="DFOPP"; CALL XGTDFADDR
051052          IF A=0 GO LREG                                      % TWO WAYS DEVICE?
051054          B:=X                                                % YES
051055          IF T:=TYPRING BIT 5SPLITDF THEN A:=B+"9CXTI" FI
051062          IF A.RTRES><0 THEN X:=B; GO LREG FI                 % OUTPUT DATAFIELD FREE?
051067          CALL FAR CFBP; GO FAR NFND; GO OK                   % YES, TRY TO FIND FREE BACKGROUND PROC.
051072   *)FILL
051077
051077   OK:    X=:CADDR; T:=MBSPRTAB; *BBPRO@3 LDXTX
051102          IF X.WLINK><0 GO FAR TMONEN                         % PROGRAM ALREADY ACTIVE
051105          IF X.STATUS BIT 5RTOFF GO FAR TMONEN                % PROGRAM CANNOT BE STARTED
051110          A BZERO 5WAIT BZERO 5REP=:X.STATUS
051113          "9ENTOPCOM"=:X.STADR                                % START ADDR. OF BACKGROUND PROGRAM
051115          X=:CCBBPROG:=X.RTDLGADDR                            % X=ADDR OF REGISTER BLOCK
051117          T:=0; A:=B; *AAX DBREG; STATX                       % SET REGISTERS FOR BACKGROUND PROGRAM
051123          A:=CCBBPROG; X:=B; T:="DBPROG"; CALL XSTDFADDR      % UPDATE DBPROG IN DATAFIELD
051127          T:=MBSPRTAB; X:=CADDR; A:=B; *CBPTE@3 STATX
051133          A:=B; CALL 9GTLOGDV; D:=0                           % FIND LOGICAL DEVICE NUMBER OF TERMINAL (TAD)
051136          A:=D; T:=MBSPRTAB; X:=CADDR; *BPLOG@3 STATX
051142          X:=B; CALL FIBCKTABLE; GO FAR TMONEN
051145          CALL GBTINDX; GO FAR TMONEN
051147          X:=CCBBPROG; CALL CHNLG; GO FAR ERR                 % CHECK NUMBER OF INLOGGED USERS.
051152          T:=MBSPRTAB; X:=CADDR; *BTBIN@3 STATX
051155          A*5PRVTSIZE+APRVTTABLE=:X=:PRVTADDR                 % ADDRESS OF PRIVATE-SYSTEM-SEGMENT-INFO TABLE ELEMENT
051161          T:=MBPRVTTABLE; *SVBPR@3 LDATX
051163          A BONE BPSOK; X:=CADDR; T:=MBSPRTAB; *BPRFL@3 STATX % INSERT FLAG BITS
051167          D:=0; *AAX TTMCO; STDTX; STDTX 20; STDTX 40         % CLEAR "TIMEOUT" VARIABLES
051174          A:=CCBBPROG-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
051202          A=:X:=B=:XBCKTABLE(X); 0=:SRVTAD                    % UPDATE XBCKTAB
051206          IF TYPRING BIT 5BAD THEN
051211             X:=B; T:="TADTYP"; CALL XGTDFADDR
051214             IF A=377 THEN 1=:SRVTAD FI                       % SERVER TYPE TAD
051221          FI
051221          X:=CCBBPROG; CALL GTSLPINDEX; GO NSLIS; GO OVFILL   % FIND TIMESLICE INDEX
051225   *"-8BACS BADAD
"051225   INTEGER POINTER LREG
051226   INTEGER CCBBPROG,PRVTADDR,CADDR,SRVTAD,SVCLASS=PRVTADDR
051232   *)FILL
051255
051255   *"8BACS
"051255   INTOTSLPRTAB:
051255           T:=GLTMBANK; *LDDTX; STDTX 20                      % MOVE END OF TABLE
051260           A:=CCBBPROC-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
051266           A=:D:=CCBBPROC; T:=GLTMBANK; *STDTX
051272           EXIT
051273
051273   OVFILL:
051273          IF SRVTAD><0 THEN                                   % TAD TYPE 377 (SERVER)
051275             A:=X*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK
051302             *TSLST@3 LDATX
051303             A=:SVCLASS; A:=5 SH 7CUTY; *TSLST@3 STATX        % SET SERVER CLASS
051307             X:=B; T:="XDFOPP"; CALL XGTDFADDR
051312             X:=A; T:="SVOTS"; A:=SVCLASS; CALL XSTDFADDR     % SAVE OLD TIMESLICE CLASS
051316             CCBBPROC.STATUS BONE 5TSLICED BONE 5ESCF=:X.STATUS
051323             CALL FPITSLPRTAB; CALL INTOTSLPRTAB
051325          ELSE
051326             T:=MBPRVTTABLE; X=:D:=PRVTADDR; *SVTSL@3 LDATX
051332             A=:L:=D*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK
051340             A:=L; *TSLST@3 STATX                             % SET TIMESLICE CLASS
051342             IF L NBIT 5NOSLICE THEN
051344                CCBBPROC.STATUS BONE 5TSLICED BONE 5ESCF=:X.STATUS
051351                CALL FPITSLPRTAB; CALL INTOTSLPRTAB
051353             ELSE
051354                CCBBPROC.STATUS BZERO 5TSLICED=:X.STATUS
051360                CALL FPITSLPRTAB; GO NSLIS
051362                A:=X-D=:L; T:=D; X:=GLTMBANK
051367                A:=T+2=:D:=X; *MOVPP                          % COMPRESS DTSLPRTAB
051374             FI
051374          FI
051374   NSLIS: X:=CCBBPROG; MIN "LREG"
051376          GO LREG
051377   *)FILL
051411
051411   % NO BACKGROUND PROCESS FOUND, CHECK IF ANY
051411   % OF THE BACKGROUND PROCESSES IS FREE
051411   NFND:   X:=ASBPRTAB
051412           DO WHILE X<<=AEBPRTAB-BPRTSIZE
051416              X=:D; T:=MBSPRTAB; *BPRFL@3 LDATX
051421              IF A NBIT BPCFIXED THEN                         % NOT PERMANENT OCCUPIED
051423                 *BBPRO@3 LDXTX
051424                 IF X.TLINK=0 AND X.WLINK=0 AND X.STATUS NBIT 5RWAIT THEN
051433                    X:=D; *CBPTE@3 STZTX                      % BACKGROUND PROCESS IS PASSIVE
051435                 FI
051435              FI; X:=D+BPRTSIZE
051437           OD; CALL FAR CFBP; GO ERR                          % CHECK IF ANY FREE NOW
051442           GO FAR OK                                          % FREE PROGRAM FOUND
051443
051443   *"
"051443   ERR:   CALL 9GTLOGDV; GO TMONEN
051445          A:=D; CALL 9ERR(#98)
051450   T2P08:
051450   TMONEN: *IOF
051451          CALL CBERSP; 0/\0                                 % SEND ESCAPE RESPONSE IF TAD
051453          GO MONEN
051454
051454   *"-8BACS BADAD
"051454   RBUS
051465

051465   %=============================================================================
051465   %       (M)   C H N L G
051465   %
051465   %       ROUTINE TO CHECK NUMBER OF ACTIVE USERS.
051465   %
051465   %       ENTRY: B=INPUT DATAFIELD
051465   %              X=RT DESCRIPTION ADDRESS
051465   %       EXITA: LOGIN ALLOWED
051465   %       EXIT:  LOGIN NOT ALLOWED
051465   SUBR CHNLG
051465   INTEGER CADR,LREG,AREG
051470   CHNLG:  X=:CADR; A=:AREG
051472           IF "DT01R"=B THEN AREG; EXITA FI             % ALWAYS ACCEPT CONSOLE
051477           IF TYPRING BIT 5BAD THEN                     % IF TAD, CHECK IF REMOTE.
051502              A:=L=:LREG
051504              X:=B+"9CXTI"; T:="PARTNER"; CALL XGTDFADDR% GET FIRST PART OF MAGNO (CPU NO.)
051510              T:=LREG=:L
051512              IF A=SYSNO THEN AREG; EXITA FI            % LOCAL CONNECTIONS ALWAYS OK
051517           FI
051517           GO BYP
051520           IF "STDRIV"="MTINS" THEN                     % IF MTAD, CHECK IF REMOTE.
051524              IF MTFLAG NBIT 5MTRC THEN AREG; EXITA FI  % LOCAL ALWAYS OK.
051531           FI
051531   BYP:    IF NACTI+1>NLEGU THEN EXIT FI                % NO MORE USERS ALLOWED
051537           A=:NACTI                                     % UPDATE NO. OF ACTIVE USERS
051540           CADR.INPRITY BONE 5COUNT=:X.INPRITY          % MARK PROGRAM HAS BEEN COUNTED
051544           AREG; EXITA
051546   RBUS
051555   %=============================================================================
051555   *"99SM1
"051555   %==============================================================================
051555   %      S M T B R E L       (M)
051555   %
051555   % MONITOR LEVEL ROUTINE TO RELEASE THE STC-DMA DATAFIELD AND DECREMENT
051555   % THE CALLING PROGRAM'S P-REGISTER
051555   %
051555   SUBR SMTBREL
051555   SMTBREL: X=:B:=X.RTRES; CALL BRELEASE
051560          IF X=CURPROG THEN
051563             *IRR ALEVB DP; AAA -1; IRW ALEVB DP
051566          ELSE
051567             X=:D:=X.RTDLGADDR; T:=0; *LDATX XTDPR
051573             A-1; *STATX XTDPR
051575             X:=D
051576          FI; "RETRA"=:MFUNC; GO MONEN
051601   RBUS
051605
051605

051605   *"8MT1+8DMVC+8CDLI+8FDI1+8FDI2+8BFD1+8BFD2+8MT2+8MT3+8MT4
"051605   %==============================================================================
051605   %       C G M L E V       (M)
051605   % IOTRANS ROUTINE FOR MAG.TAPE, VERSATEC ON DMA, AND FLOPPY DISK
051605   %
051605   % MONITOR LEVEL FOR INPUT
051605   SUBR CGMLEV,CBMLEV
051605   CGMLEV:CALL CBF2; T:=7; CALL MTRANS; CALL BRELEASE
051611          CALL MBFDISC; X:=BREGC;0=:X.CERRO
051614          IF TYPRING BIT 5FLOP THEN
051617             IF HSTAT NBIT 4 THEN
051622                IF A BIT 5 THEN A BONE 4=:HSTAT; 3=:CERRCODE; A:=0
051631                ELSE
051632                   X:=BREGC.CASUN; X:=FDIFORM(X); WDSCT(X)     % WORDS PER SECTOR ACCORDING TO FORMAT
051636                FI
051636             ELSE
051637                A:=0
051640             FI; A=:BREGC.NOWRE
051642          FI
051642          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B
051650             IF T:=X.NOWRE=0 THEN A=:X.DERROR ELSE A=:X.CERROR FI
051656          FI
051656   CBGE1: X=:B;NOWRE SHZ 1=:BHOLD;0=:HENTE=:CFREE
051664          GO STUPR
051665   %
051665   % MONITOR LEVEL FOR OUTPUT
051665   %
051665   CBMLEV:CALL CBF2
051666          T:=7;CALL MTRANS; CALL BRELEASE
051671          CALL MBFDISC; X:=BREGC
051673          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B; A=:X.DERROR FI
051702          X=:B;MAX=:CFREE;0=:FYLLE=:BHOLD
051707          GO STUPR
051710   *)FILL
051715
051715   INTEGER POINTER REGL
051716   INTEGER BREG
051717   CBF2:  A:=L=:"REGL"
051721          *IRR ALEVB DP
051722          A-1;*IRW ALEVB DP
051724          MAX SHZ -1=:NOWRE; CLOGDV; CALL LOGPH
051731          IF A=0 THEN 2=:DERROR; GO STUPR; FI     % NO  "DMA" DATAFIELD
051735          A:=:B;A=:BREG; X:=RTREF; CALL BRESERVE  % RESERVE "DMA" DATAFIELD
051741          IF A<0 THEN
051742             CALL FREXQU;CALL TOWQU; GO STUPR     % WAIT FOR "DMA" DEVICE TO BE FREE
051745          FI
051745          IF TYPRING BIT 5FLOP THEN
051750             1=:BREG.NOWRE
051753             X:=X.CASUN; NFDIADR(X)=:BREG.FDIADR
051757          FI; BREG=:BREGC; A+"CPARM"; GO REGL
051763   %
051763   % INCREMENT DISC ADDRESS IF FLOPPY DISC
051763   %
051763   MBFDISC: IF TYPRING BIT 5FLOP THEN
051766                X:=BREGC.CASUN; MIN NFDIADR(X); 0/\0
051772            FI; EXIT
051773   RBUS
052002
052002   %==============================================================================
052002   %      S M T R A                               (M)
052002   %
052002   SUBR SMTRA
052002   % SUBROUTINE TO SET UP A CALL TO THE MASS STORAGE DRIVER
052002   % MONITOR LEVEL
052002
052002   SMTRA: X=:B                            % LEVEL 2  (MONITOR LEVEL)
052003          CLOGDV; CALL LOGPH; A=:X
052006          "SRETRA"=:X.MFUNC
052010          IF X.TYPRING BIT 5FLOP THEN
052013             X=:D; 1=:NOWRE; CASUN+X+"NFDIADR"=:X; X.S0; MIN X.S0; 0/\0
052025            A=:FDIADR; D=:X
052027          FI
052027          A:=B+"CPARM"; X=:B;CALL CMTRANS
052033          IF HSTAT BIT 4 THEN X:=:B; CALL MERRCODE; X:=:B ELSE A:=0 FI; A=:D
052044          IF CURPROG=MRTREF THEN
052050              A:=D; *IRW ALEVB DA
052052          ELSE
052053             A:=D; X:=MRTREF.RTDLGADDR; T:=0; *STATX XTDAR
052060          FI; X:=MRTREF
052061          "RETRANS"=:MFUNC; CALL BRELEASE; BREGC=:B
052066          "IORES"=:MFUNC
052070   OUT:   GO STUPR
052071
052071   RBUS
052104
052104
052104   *"8MT1+8MT2+8FDI1+8FDI2+8BFD1+8BFD2+8DLP1+8DLP2+8DMVC+8DVE1+8DVE2+8MT3+8MT4
"052104   %==============================================================================
052104   % 34.11      C M T R A N S   S R E T R A
052104   %
052104   %
052104   % SUBROUTINE TO START DRIVER ON LEVEL 11
052104   % MONITOR LEVEL
052104   % ENTRY: B=DATAFIELD ADDRESS
052104   %        A=ADDRESS OF PARAMETER LIST
052104   %
052104   SUBR CMTRANS,SRETRA
052104
052104   CMTRANS: T:=L=:"TRLREG"
052106          CALL GAPFD
052107          *IOF; TRR 10
052111          "STDRIV";*IRW LV11B DT
052113          A:=B; *IRW LV11B DB; IRW LV11B DX;
052116          "SLV11"; *IRW LV11B DP
052120          LV11;*MST PID
052122          X:=MRTREF;CALL WDATA
052124          *ION
052125          IF X=RTREF GO RWAIT; GO MONEN
052131
052131   % X=DATAFIELD ADDRESS
052131   SRETRA: X=:B:=MRTREF;IF X=0 GO MONEN
052135          CALL RDATA;GO TRLREG
052137
052137   RBUS
052147
052147   *"8HDMA
"052147   %

052147   %==============================================================================
052147   %     ( M )     H I T R N S
052147   %
052147   %  SUBROUTINE TO START DRIVER ON LEVEL 13,
052147   %  RETURN WHEN FINISHED
052147   %  MONITOR LEVEL
052147   %  ENTRY:  A=PARAMETER LIST ADDRESS
052147   %          B=DATAFIELD ADDRESS
052147   %
052147
052147   SUBR HITRNS
052147   INTEGER TREG,AREG,LREG
052152   HITRNS:
052152          T=:TREG:=L=:LREG;A=:AREG
052156          IF T=0 THEN   % FROM ABSTR
052160            X:=RTREF; CALL BRESERVE; IF A<0 GO WT    % RESERV DF.
052164          FI
052164          LREG=:"TRLREG"; AREG
052167          IF T:=TREG=0 THEN CALL GAPFU ELSE CALL GAPFD; FI  % GET PARAMETERS FROM USER OR DPIT
052175          *IOF;TRR 10                         % CLEAR CACHE
052177          B=:A; *IRW LV13B DB; IRW LV13B DX
052202          "STDRIV"; *IRW LV13B DP
052204          LV13; *MST PID
052206          X:=RTRES; CALL WDATA
052210          *PION
052211          IF X=RTREF GO RWAIT; GO MONEN
052215
052215   RBUS
052226
052226
052226   %==============================================================================
052226   %      ( M )      H O T R N S
052226   %
052226   %  SUBROUTINE TO START DRIVER ON LEVEL 12,
052226   %  RETURN WHEN FINISHED.
052226   %  MONITOR LEVEL
052226   %  ENTRY:  A=PARAMETERLIST ADDRESS
052226   %          B=DATAFIELD ADDRESS
052226   %
052226
052226   SUBR HOTRNS
052226   INTEGER TREG,AREG,LREG
052231   HOTRNS:
052231          T=:TREG:=L=:LREG;A=:AREG
052235          IF T=0 THEN   % FROM ABSTR
052237            X:=RTREF; CALL BRESERVE; IF A<0 GO WT    % RESERV DF.
052243          FI
052243          LREG=:"TRLREG"; AREG
052246          IF T:=TREG=0 THEN CALL GAPFU ELSE CALL GAPFD; FI  % GET PARAMETERS FROM USER OR DPIT
052254          *IOF;TRR 10
052256          B=:A; *IRW LV12B DB; IRW LV12B DX
052261          "STDRIV"; *IRW LV12B DP
052263          LV12; *MST PID
052265          X:=RTRES; CALL WDATA
052267          *PION
052270          IF X=RTREF GO RWAIT; GO MONEN
052274
052274   RBUS
052305
052305   % PREDECLARATION
052305   SUBR HDMIDRIV
052305   RBUS
052305
052305   %==============================================================================
052305   %    ( M )   C T R O D   C T R I D   H D O B U S   H D I B U S   H D O F I N
052305   %            H D I F I N   H D O F E I L   H D I F E I L   H D I T I M
052305   %            H D O T I M
052305   %
052305   % ROUTINE TO SET UP CALL TO HDLC-BSC/DMA OUTPUT/INPUT DRIVER.
052305   %
052305   % LEVEL 12/LEVEL 13
052305   %
052305   % ACTIVATED BY MTRANS
052305   %
052305   % ENTRY : B=ADDRESS OF THE DATAFIELD
052305   %         X=ADDRESS OF THE PARAMETER LIST (OF ABTRANS)
052305   %
052305   % PARAMETERS : PAR0          = FUNCTION CODE
052305   %              PAR1          = POINTER TO THE MEMORY ADDRESS
052305   %              PAR2          = NOT USED
052305   %              PAR3          = NO. OF WORDS IN READ/WRITE
052305   %                            = PROTOCOL IN SET-PROTOCOL
052305   %                            = MODE IN SET-MODE
052305   %                            = SECONDS IN SET-RECEIVE-TIMER
052305   %
052305
052305   SUBR CTROD,CTRID,HDOBUS,HDIBUS,HDOFIN,HDIFIN,HDOFEIL,HDIFEIL,HDITIM,HDOTIM
052305
052305   DISP 0; DOUBLE POINTER DP1=P1; PSID
052305   DISP -44
052305   INTEGER HCTRL
052305   INTEGER HMOD
052305   %INTEGER CERRCODE
052305   PSID
052305   DISP -40; INTEGER HSPFL; PSID
052305   SYMBOL HDHDX=5,BROCK=10
052305
052305   CTROD:
052305          0=:CERRCODE=:HSTAT
052307          IF ABFUN/\77=1 OR =55 OR =52 GO RWOPER    % SEND, CONTROL OR INIT
052322          IF A=51 THEN                              % SELECT HALF/FULL DUPLEX
052325             IF ABP31<0 OR >1 THEN
052332                174=:CERRCODE; GO OFINEY
052335             FI
052335             T:=HCTRL=:D
052337             IF A=1 THEN D BONE HDHDX ELSE D BZERO HDHDX FI
052345             A:=D=:HCTRL; GO OFINOK
052350          FI
052350          201=:CERRCODE; GO OFINEY                  % ILL. FUNCTION CODE
052353
052353   OFINOK:
052353          GO OFIN
052354   OFINEY:
052354          HSTAT BONE 4=:HSTAT; GO OFIN
052360   IFINOK:
052360          GO IFIN
052361   IFINEY:
052361          HSTAT BONE 4=:HSTAT; GO IFIN
052365
052365   RWOPER:
052365          AD:=MEMAD; A:=:D; A=:CARG; A:=D/\37 SH 12=:T
052374          ABFUN/\377+T=:CTRG
052400          ABP31=:CXRG
052402          TAD:=CTADRG=:TADRG; X:=CXRG=:XRG
052406          IF A=0 THEN A=:MRETURN FI
052410          DO
052410              TTMR=:TMR; X:=XRG; TAD:=TADRG
052414              CALL TRNSF; GO ERROR; GO BUSY; GO FINISH
052420   RWBUSY:
052420          OD
052421
052421   HDIBUS:CALL ID13
052422          T:=HDEV+10; *EXR ST
052425          IF A NBIT BROCK THEN
052427             GO HDIBUS                   % BLOCK NOT READY
052430          ELSE
052431             A=:HSPFL; GO HDMIDRIV
052433          FI
052433   HDOBUS:
052433          CALL ID12; GO RWBUSY
052435
052435   HDIFIN:
052435          X=:HSTAT
052436   IFIN:  IF RTRES><0 THEN
052440             0=:HSPFL=:TMR; CALL RTACT
052443          FI
052443          GO HDIBUS
052444   HDIFEIL:
052444          A=:CERRCODE; X BONE 4=:HSTAT; GO IFIN
052450   HDOFIN:
052450          X=:HSTAT
052451   OFIN:  IF RTRES><0 THEN CALL RTACT FI
052454          0=:TMR; CALL ID12; A+1; GO ERR22
052460   HDOFEIL:
052460          A=:CERRCODE; X BONE 4=:HSTAT; GO OFIN
052464
052464   *)FILL
052476
052476   % INPUT
052476
052476   CTRID: 0=:CERRCODE=:HSTAT
052500          IF ABFUN/\77=0 GO RWOPER        % RECEIVE
052503          IF A=53 THEN                    % SET REC. TIMER
052506             ABP31-=:TTMR; GO IFINOK
052512          FI
052512          IF A=50 THEN                    % SELECT PROTOCOL
052515             ABP31=:HMOD; GO IFINOK
052520          FI
052520          201=:CERRCODE; GO IFINEY
052523
052523   % TIME-OUT ON LEVEL 12/13
052523   %
052523   % ACTIVATED FROM TIME PROGRAM
052523
052523   HDITIM:
052523          HSTAT BONE 4=:HSTAT; 12=:CERRCODE
052530          100; T:=HDEV+11; *EXR ST
052534          GO IFIN
052535   HDOTIM:
052535          HSTAT BONE 4=:HSTAT; 12=:CERRCODE
052542          "0"; T:=HDEV+13; *EXR ST
052546          GO OFIN
052547
052547   RBUS
052551
052551
052551
052551   *"8FDI1
"052551   %==============================================================================
052551   %            C L M L E V
052551   %
052551   % IOTRANS ROUTINE FOR LINE-PRINTER AND VERSATEC
052551   % MONITOR LEVEL
052551   SUBR CLMLEV
052551   CLMLEV: *IRR ALEVB DP
052552           A-1; *IRW ALEVB DP
052554           MDATAF=:B; X:=RTREF; CALL BRESERVE
052560           IF A<0 THEN
052561              CALL FREXQU; CALL TOWQU; GO STUPR
052564           FI; BREGC=:B
052566           MAX SHZ -1=:NOWRE; 0=:BHOLD=:FYLLE; MAX=:CFREE
052575           A:=B+"CPARM";X:=MDATAF=:B; T:=7; CALL MTRANS; CALL BRELEASE
052604           BREGC=:B
052606           GO STUPR
052607   RBUS
052616
052616   %==============================================================================
052616   %         C L T R A                 (M)
052616   %
052616   % ROUTINE TO CLOSE LINE-PRINTER/VERSATEC
052616   % MONITOR LEVEL
052616   SUBR CLTRA
052616   CLTRA: X=:B; "IORES"=:MFUNC
052621          CALL MCHDVBUF; GO L4
052623          IF BHOLD><0 THEN
052625                IF CFREE><0 AND PVEFUNC><10 THEN
052633                   12; CALL DBPUT
052635                   IF CFREE >< 0 THEN
052637                      215; CALL DBPUT
052641                   FI
052641                FI
052641                IF BHOLD BIT "0" THEN
052644                  A:=0; CALL DBPUT
052646                  BHOLD
052647                FI
052647                A SHZ -1=:NOWRE; MDATAF=:B
052653                "SRETRANS"=:MFUNC; BREGC+"CPARM"; CALL CMTRANS
052660                "RETRANS"=:MFUNC; BREGC=:B
052664          ELSE
052665                X:=MDATAF=:B; X:=MRTREF; CALL RDATA; BREGC=:B
052673          FI
052673   L3:    IF CURPROG=MDATAF.MRTREF THEN
052700                A:=0; *IRW ALEVB DA
052702          ELSE
052703                X:=T.RTDLGADDR; T:=0; *STZTX XTDAR
052707          FI
052707          IF MDATAF.RTRES><0 THEN X=:B:=A; CALL BRELEASE FI
052715          GO STUPR
052716   L4:    MDATAF=:B; X:=MRTREF; CALL RDATA; BREGC=:B; GO L3
052725
052725   RBUS
052741   *"8DLP1+8DLP2+8DVE1+8DVE2
"052741   %==============================================================================
052741   % 39.7       C L P 1 0    (MPIT)
052741   %
052741   %
052741   % ROUTINE ON LEVEL 10 TO HANDLE INTERRUPT FROM LP.
052741   %
052741   SUBR CLP10
052741   CLP10: B=:X; "LP5MF"-"MFUNC"+B=:B; CALL RTACT; X=:B; CALL ID10; GO CLP10
052752   RBUS
052757
052757
052757   %==============================================================================
052757   % 39.8       X T R D L P     T R D L P      (M)
052757   %
052757   %
052757   % SUBROUTINE ON MONITOR LEVEL TO TRANSFER DATA TO THE DEVICE
052757   %
052757
052757   SUBR XTRDLP,TRDLP
052757
052757   INTEGER WDIO1=?,RSIO1=?,WDIO2=?,RSIO2=?
052757
052757
052757   TRDLP:
052757   XTRDLP: X.S0=:B; 0=:TMR
052762          IF VEFLG><0 THEN
052764                IF PVEFUNC=10 THEN 104 ELSE 4 FI; A=:CIOXC
052774          FI
052774          IF CXBHOLD><0 THEN              % NUMBER OF BYTES IN EXTRA BUFFER
052776             X:=CXHENTE; GO L1
053000          FI
053000   L0:    IF XCBHOLD=0 GO FIN              % NUMBER OF BYTES IN DEVICE BUFFER
053002          IF A<<=CXMAX THEN
053005             % IF THE NUMBER OF BYTES LEFT IN DEVICE BUFFER IS LESS THAN
053005             % CAPACITY OF THE EXTRA BUFFER
053005             % COPY FROM DEVICE BUFFER/ABSTR BUFFER TO EXTRA BUFFER IN DATAFIELD
053005             A:=XCHENTE SHZ -1+XCBUFST=:D; A:=XCBHOLD=:CXBHOLD+1 SHZ -1=:L
053016             A:=MEMA1; T:=CXBUFST;  *MOVPA
053021             IF VEMOD=0 THEN
053023                IF RTRES><0 THEN CALL RTACT FI
053026             FI
053026             IF XCHENTE BIT "0" THEN X:=1 ELSE X:=0 FI
053034             0=:XCBHOLD                          % ODD BYTE LEFT OVER ?
053035   L1:       IOXRS=:RSIO1; IOXWD=:WDIO1
053041             DO
053041                INTEGER RSIO1       % READ STATUS
053042             WHILE A BIT 3
053044                T:=CXBUFST
053045                IF CHCONV><0 THEN
053047                   *LBYT
053050                   CALL CONVCH
053051                ELSE
053052                   *LBYT
053053                FI
053053                INTEGER WDIO1
053054                T:=IOXWC; CIOXC; *EXR ST
053057                X=:A; FOR X:=LPDELAY DO OD; X:=A             % DELAY
053063                X+1; CXBHOLD-1=:CXBHOLD
053067                IF A=0 THEN
053070                   IF XCBHOLD=0 GO PIN1
053072                   GO L0
053073                FI
053073             OD
053074   PIN1:     X=:CXHENTE; T:=IOXWC; CIOXC BZERO 2 BONE "0"; *EXR ST
053102             TTMR=:TMR; GO PSTUPR
053105   *)FILL
053111
053111   FIN:      IF VEMOD><0 THEN
053113                0=:VEMOD
053114                IF A=30 THEN
053117                   11
053120                ELSE
053121                   IF A=31 THEN
053124                      10
053125                   ELSE
053126                         GO L2
053127                FI;FI
053127                A=:PVEFUNC; GO FINX
053131
053131   L2:          1505; T:=IOXWC; *EXR ST
053134                GO PSTUPR
053135                FI
053135   FINX:     IF RTRES><0 THEN CALL RTACT FI
053140             GO PSTUPR
053141          FI
053141          IOXRS=:RSIO2; IOXWD=:WDIO2
053145          DO
053145             INTEGER RSIO2                                    % READ STATUS
053146          WHILE A BIT 3                                       % UNTIL NOT READY
053150             T:=MEMA1; A:=XCHENTE=:D SHZ -1+XCBUFST=:X
053156             *LDATX                                           % FETCH WORD FROM BUFFER
053157             IF D NBIT "0" THEN A SHZ -10 ELSE A/\377 FI      % GET BYTE
053164             MIN XCHENTE
053165             IF T := CHCONV >< 0 THEN
053170                CALL CONVCH                                   % CONVERT BYTE?
053171             FI
053171             INTEGER WDIO2                                    % WRITE DATA
053172             T:=IOXWC; CIOXC; *EXR ST
053175             X=:A; FOR X:=LPDELAY DO OD; X:=A                      % DELAY
053201             XCBHOLD-1=:XCBHOLD
053204             IF A=0 GO PIN2
053205          OD
053206   PIN2:  T:=IOXWC; CIOXC BZERO 2 BONE "0"; *EXR ST
053213          TTMR=:TMR; GO PSTUPR
053216
053216   CONVCH:
053216          A=:D
053217          IF VEFLG><0 AND PVEFUNC=10 THEN A:=D ; EXIT FI
053227          A:=D/\177
053231          X=:D:="CHCONV"
053233          DO
053233                IF T:=X.S0=0 THEN X:=D; EXIT FI
053240                IF A=T THEN X.S1; X:=D; EXIT FI
053245                X+2
053246          OD
053247   RBUS
053256   *"
"053256   %===========================================================================
053256   % 34.21    M C H D V B U F     (M)
053256   %
053256   % SUBROUTINE TO CHECK IF A DEVICE BUFFER IS RESERVED FOR THIS LOGICAL
053256   % DEVICE UNIT BY THE PROGRAM WHICH HAS RESERVED THE LOGICAL
053256   % DEVICE UNIT
053256   %
053256   % ENTRY:     B=ADDRESS OF I/O DATAFILELD
053256   % EXIT:      NO DEVICE BUFFER RESERVED
053256   % EXITA:     DEVICE BUFFER RESERVED
053256   %
053256   SUBR MCHDVBUF
053256   DISP 5; INTEGER LGIOLOG; PSID          % LOGICAL DEVICE NUMBER IN BUFFER
053256
053256   MCHDVBUF:
053256          X=:D
053257          IF ADRBHEAD=0 OR A.RTRES><RTRES OR X.LGIOLOG><CIOLOG THEN
053272             X:=D
053273             EXIT
053274          FI
053274          X:=D; EXITA
053276   RBUS
053276   *"8UDMA+8VICO
"053276   %============================================================================
053276   %        MONITOR LEVEL ENTRY FOR MON UDMA  ON MPIT
053276   %============================================================================
053276   SUBR MUDMA
053276
053276   MUDMA: *IRR ALEVB DT;
053277          IF A < LUDV OR  A >HUDV THEN "240"; GO MERR; FI
053307          CALL LOGPH; A:=D
053311          IF A=0 THEN "33"; GO MERR; FI
053314          IF A.RTRES >< RTREF THEN "5"; GO MERR; FI
053323          A:=X.DFPNT; CALL SWAPPR;
053325          GO MONEN
053326   MERR:  *IRW ALEVB DA
053327          GO MONEN
053330
053330   RBUS
053337   *"
"053337   *"IBL01+IBL02+IBL03+IBL04+IBL05
"053337

053337   %==============================================================================
053337   %     ( M )    I M T R I    I M T R O
053337   %
053337   %
053337   %      MTRANS ROUTINES FOR BLOCK ORIENTED INTERNAL DEVICES. ONLY FUNCTION CODES
053337   %      0, 1 AND 21 ARE VALID.
053337   %
053337   SUBR IMTRI,IMTRO
053337
053337   DISP -3
053337   INTEGER DBLDN                % DBH LOGICAL DEVICE NUMBER: USED AS A FLAG AND FOR LOCKING / UNLOCKING.
053337   INTEGER INWORDS              % NO. OF WORDS IN BUFFER
053337   INTEGER IDFOPP               % ADDRESS OF OUTPUT DATAFIELD
053337   INTEGER POINTER CIFUNC       % POINTER TO FUNCTION CODE
053337   DOUBLE POINTER PDCADDR(2)    % POINTER TO MEMORY (BUFFER) ADDRESS
053337   INTEGER POINTER PNWORDS      % POINTER TO THE PAR. NO. OF WORDS
053337   PSID
053337
053337   INTEGER POINTER LREG; INTEGER XREG
053341
053341   IMTRI: A=:X; X:=:B; A:=L=:"LREG"; 0=:X.HSTAT
053346          IF CIFUNC /\ 77 = 0 THEN
053351   %
053351   %         READ FROM INTERNAL DEVICE.
053351   %
053351             IF X.BREGC >< 0 THEN
053353                0=:X.BREGC                          % BREGC IS USED AS A FLAG: IF >< 0 THERE IS DATA WAITING
053354                IF X.INWORDS < PNWORDS THEN         % TO BE READ IN THE IBD. IF = 0 THERE IS NONE.
053360                   A=:PNWORDS                       % NUMBER OF WORDS IN IBD < NUMBER SPECIFIED.
053361                FI
053361                X=:XREG
053362                IF X.IDFOPP.RTRES >< 0 THEN
053365                   X=:B:=A; CALL RDATA              % OUTPUT DATAFIELD IS RESERVED.
053370                   A:=XREG=:B; A:=DBLDN; CALL LOGPH
053374                   IF A = 0 THEN CALL ERRFATAL FI
053376                   A=:B; 1=:DKFUN                   % CHANGE FUNCTION CODE IN DBH TO WRITE
053401                   CALL BRESERVE                    % RESERVE DBH FOR RT-PROG OWNING OUTPUT DATFIELD.
053402                   IF A < 0 THEN
053403                      CALL FREXQ; CALL TOWQU        % PUT THE RT-PROG INTO WAITING QUEUE FOR DBH.
053405                   FI
053405                FI
053405                XREG=:B; X:=RTRES; GO LREG
053411             FI
053411             X=:B; A:=DBLDN
053413   CALLWDATA:CALL LOGPH
053414             IF A = 0 THEN CALL ERRFATAL FI
053416             B=:D; A=:B; X:=RTRES; CALL BRELEASE
053422             B:=D; X:=RTRES; CALL WDATA             % SET THE CALLING PROGRAM INTO I/O WAIT.
053425             IF X=RTREF THEN
053430                *IRR ALEVB DP
053431                A-1; *IRW ALEVB DP                  % DECREMENT THE P-REG ON APPLICATION LEVEL.
053433                GO RWAIT
053434             FI
053434             X:=X.RTDLGADDR; T:=0; *LDATX XTDPR
053437             A-1; *STATX XTDPR
053441             GO MONEN
053442          FI
053442   %
053442   %      NOT READ: IS FUNCTION CLEAR DEVICE?
053442   %
053442          IF A=21 THEN
053445             0=:X.DBLDN=:BREGC                      % CLEAR DEVICE: CLEAR DBH LDN AND DATA IN BUFFER FLAG.
053447          ELSE
053450             20=:X.HSTAT                            % INDICATE ILLEGAL FUNCTION.
053452          FI
053452          X=:B:=RTRES; EXIT
053455   %
053455   %      WRITE TO IBD.
053455   %
053455   IMTRO: A=:X; X:=:B; A:=L=:"LREG"; 0=:X.HSTAT
053462          IF CIFUNC/\77 >< 1 THEN
053467             20=:X.HSTAT; X=:B:=RTRES; EXIT         % FUNCTION NOT WRITE: INDICATE ILLEGAL FUNCTION CODE.
053474          FI
053474          X=:XREG
053475          IF X.IDFOPP.BREGC >< 0 THEN
053500             A:=X.DBLDN; X:=XREG=:B
053503             GO CALLWDATA                           % WAIT UNTIL DATA HAS BEEN READ BEFORE WRITING NEW DATA.
053504          FI                                        % X-REG NOW POINTS TO INPUT PART.
053504          1=:X.BREGC                                % FLAG IBD AS CONTAINING DATA.
053506          PNWORDS=:X.INWORDS
053510          IF X.RTRES >< 0 THEN
053512             X=:B; A=:X; CALL RDATA; A:=DBLDN; CALL LOGPH
053517             IF A = 0 THEN CALL ERRFATAL FI
053521             A=:B; 0=:DKFUN; CALL BRESE             % FUNCTION TO BE CONTINUED IS READ.
053524             IF A < 0 THEN
053525                CALL FREXQ; CALL TOWQU
053527             FI
053527          FI
053527          X:=XREG=:B:=RTRES; GO LREG
053533   RBUS
053547

053547   *"8ACC                                 % CPU-TIME USED FOR USER RT-PROGRAMS
"053547   %============================================================================
053547   %      ( M )        N A C C O U N T
053547
053547   SUBR NACCOUNT
053547   %% RT-ACCOUNTING                                 % USER RT-PROGRAM
053547   NACCOUNT: IF A:=CURPROG>>="9FBPR" THEN EXIT FI   % BG PROG.
053554          IF A >>="RTBES" GO NN2                    % USER PROG.
053557          IF      A="RWRT1" THEN A:="DF1".SSREF
053564          ELSE IF A="RWRT2" THEN A:="DF2".SSREF
053572          FI FI
053572   NN1:   IF A << "RTBES" THEN EXIT;FI              % NOT USER RT-PROGRAM
053576
053576   NN2:   A-"RTBES"=:D:=0;T:=5RTSIZE;*RDIV ST       % COMPUTE USER RT-DESC INDEX
053603          A=:D SHZ  1 +D+ ACTAB=:X                  % ACCOUNT ENTRY
053610          T:=GLTMBANK; *LDATX
053612          IF A><0 THEN
053613              *LDDTX 10
053614              D+1; A:=A+C
053616              *STDTX 10
053617          FI
053617          EXIT
053620   *)FILL
053631   *"-8ACC
"053631   RBUS
053631
053631   *"8LOG+8HIST
"053631   %==============================================================================
053631   %     ( M )    L O G 1
053631   %
053631   % ROUTINES TO GATHER SYSTEM AND PROGRAM STATISTICS
053631   % CALLED FROM TERMINAL OUTPUT DRIVER (LEVEL 10)
053631   % THE INFORMATION IS USED BY THE COMMAND "RT-PROGRAM-LOG"
053631   %
053631   SUBR LOG1,SHISTI
053631
053631   %========================================================================%
053631   % NOTE: THESE DISPLACEMENTS CORRESPONDS TO THE DATA STRUCTURE DEFINED    %
053631   %       IN THE HISTOGRAM AND LOGGING COMMANDS ON THE COMMAND SEGMENT.    %
053631   %       DO NOT CHANGE THIS DEFINITIONS WITHOUT DOING THE SAME CHANGE     %
053631   %       IN THE COMMAND ROUTINES!                                         %
053631   %========================================================================%
053631   DISP -13
053631   INTEGER HTOT1,HTOT2          % TOTAL NUMBER OF SAMPLES
053631   INTEGER STLT1,STLT2          % COUNTS BACKGROUND PROGRAM EXECUTING ON RING 2/3
053631   INTEGER HISTPROG             % PROGRAM TO DO HISTOGRAMING ON
053631   INTEGER HISTART              % FLAG >< 0 WHEN HISTOGRAM IS STARTED
053631   INTEGER FPREG                % ADDR OF FIRST HISTOGRAM INTERVAL
053631   INTEGER DELTA                % SIZE OF EACH HISTOGRAM INTERVAL
053631   INTEGER HISTFLAG             % FLAG >< 0 WHEN SYSTEM-HISTOGRAM
053631   INTEGER CHILEV               % "IRR XX DP" INSTRUCTION
053631   INTEGER FLGHIST              % FLAG FOR COMMANDS ROUTINES
053631   PSID
053631
053631   DISP 0
053631   INTEGER ACTC1,ACTC2                % CPU ACTIVE
053631   INTEGER ACTP1,ACTP2                % TARGET PROGRAM ACTIVE (USING CPU)
053631   INTEGER SWC1,SWC2                  % SWAPPER IN USE
053631   INTEGER SWP1,SWP2                  % SWAPPER IN USE BY TARGET PROGRAM
053631   INTEGER FILC1,FILC2                % FILESYSTEM IN USE
053631   INTEGER FILP1,FILP2                % FILESYSTEM IN USE BY TARGET PROGRAM
053631   INTEGER DIC1,DIC2                  % MAIN SWAP-DISC IN USE
053631   INTEGER PASP1,PASP2                % TARGET PROGRAM PASSIVE
053631   INTEGER IOWP1,IOWP2                % TARGET PROGRAM IN I/O WAIT
053631   INTEGER TOTL1,TOTL2                % TOTAL NUMBER OF SAMPLES
053631   INTEGER U1T1,U1T2                  % ADDITIONAL LOG.UNIT #1 USED
053631   INTEGER U1P1,U1P2                  % ADDITIONAL LOG.UNIT #1 USED BY TARGET PROGRAM
053631   INTEGER U2T1,U2T2                  % ADDITIONAL LOG.UNIT #2 USED
053631   INTEGER U2P1,U2P2                  % ADDITIONAL LOG.UNIT #2 USED BY TARGET PROGRAM
053631   INTEGER ADRSWP,ADRU1,ADRU2         % ADDRS OF DATAFIELDS
053631   INTEGER LOGPROG                    % RT-DESCR OF TARGET PROGRAM
053631   INTEGER PTOT1,PTOT2
053631   INTEGER XINCR,CINCR
053631   PSID
053631   *"8LOG
"053631   INTEGER CSVB=?
053631   LOG1:  MIN "LGARR".CINCR; EXIT; X.XINCR=:X.CINCR % CINCR=INTERRUPTS BETWEEN SAMPLES
053636          X:=:B=:CSVB
053640          IF COMRTP=0 GO FAR TALLRTP                % IS IT PROGRAM LOG?
053643          IF LOGFIELD.RTRES><"F1202".RTRES THEN     % IS THE LOGGING SEMAPHORE STILL RESERVED BY THE ACTUAL PROGR?
053651             IF ALLRTP=0 THEN 0=:LOGFIELD=:MNLOGFI FI % NO
053655             0=:COMRTP                              % MARK RT-PROGRAM-LOG TERMINATED (BY ESCAPE)
053656             GO OUT
053657          FI; *TRA PVL
053660          IF A SH 11 SHZ -14><0 THEN                % CPU ACTIVE (PREVIOUS LEVEL NOT ZERO)
053663             *MIN ACTC2,B; SKP; MIN ACTC1,B; RAND
053667             IF LOGPROG=CURPROG THEN                % ANY TARGET PROGRAM DEFINED AND TARGET PROGRAM ACTIVE?
053673                 *MIN ACTP2,B; SKP; MIN ACTP1,B; RAND % YES
053677             FI
053677          FI
053677          IF "CLFIE".RTRES><0 AND A><"1SWAP" THEN   % ND-100 SWAPPER RESERVED?
053705             *MIN SWC2,B; SKP; MIN SWC1,B; RAND     % YES
053711             IF A=LOGPROG AND A><CURPROG THEN       % ANY TARGET PROGRAM DEFINED AND TARGET PROGRAM USING SWAPPER?
053717                *MIN SWP2,B; SKP; MIN SWP1,B; RAND  % YES
053723             FI
053723          FI; GO LOG2; *)FILL
053736
053736   INTEGER CSVB
053737   OUT:   CSVB=:B; EXIT
053742
053742   LOG2:
053742          IF ADRSWP.STPRW=:D><0 THEN                % MAIN-SWAP DEVICE RESERVED?
053746             *MIN DIC2,B; SKP; MIN DIC1,B; RAND     % YES
053752             IF "CLFIE".RTRES=0 OR A="1SWAP" THEN   % USED FOR SWAPPING?
053760                *MIN FILC2,B; SKP; MIN FILC1,B; RAND % NO, ASSUME USED FOR FILE-SYSTEM
053764                IF D=LOGPROG THEN                   % FILE-SYSTEM USED BY TARGET-PROGR?
053767                   *MIN FILP2,B; SKP; MIN FILP1,B; RAND % YES
053773                FI
053773             FI
053773          FI
053773          IF X:=LOGPROG><0 THEN                     % ANY SPECIFIC TARGET PROGRAM?
053775             IF X.WLINK=0 THEN                      % YES, IS IT PASSIVE (IDLE)?
053777                *MIN PASP2,B; SKP; MIN PASP1,B; RAND % YES
054003             FI
054003             IF X.STATUS BIT 5WAIT THEN             % IS IT IN I/O WAIT?
054006                *MIN IOWP2,B; SKP; MIN IOWP1,B; RAND % YES
054012             FI
054012          FI; *MIN TOTL2,B; SKP; MIN TOTL1,B; RAND  % INCREMENT TOTOAL NUMBER OF SAMPLES
054016          IF X:=ADRU1><0 THEN                       % ANY ADDITIONAL LOG.UNIT #1 DEFINED?
054020             IF X>>="9FDFD" AND X<<"9EDFD" THEN     % DISK
054026                X.STPRW                             % DISK SORTING/PARALLEL SEEK
054027             ELSE
054030                X.RTRES
054031             FI
054031             IF A><0 THEN                           % IS IT RESERVED?
054032                *MIN U1T2,B; SKP; MIN U1T1,B; RAND  % YES
054036                IF A=LOGPROG THEN                   % RESERVED BY THE TARGET PROGRAM?
054041                   *MIN U1P2,B; SKP; MIN U1P1,B; RAND % YES
054045                FI
054045             FI
054045          FI
054045          IF X:=ADRU2><0 THEN                       % ANY ADDITIONAL LOG.UNIT #2 DEFINED?
054047             IF X>>="9FDFD" AND X<<"9EDFD" THEN     % DISK
054055                X.STPRW                             % DISK SORTING/PARALLEL SEEK
054056             ELSE
054057                X.RTRES
054060             FI
054060             IF A><0 THEN                           % IS IT RESERVED ?
054061                *MIN U2T2,B; SKP; MIN U2T1,B; RAND  % YES
054065                IF A=LOGPROG THEN                   % RESERVED BY THE TARGET PROGRAM?
054070                   *MIN U2P2,B; SKP; MIN U2P1,B; RAND  % YES
054074                FI
054074             FI
054074          FI; GO TALLRTP; *)FILL
054101
054101   INTEGER POINTER PCSVB:=CSVB
054102
054102   TALLRTP: IF ALLRTP=0 GO FAR OUT
054105          IF LOGPROG><"F1352".RTRES GO OUT
054112          CURPROG-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
054120          A SH 1; T:=MBLGARR; X:=ALGARR+A; *LDDTX
054125          D+1; A:=A+C; *STDTX
054130          *MIN PTOT2,B; SKP; MIN PTOT1,B; RAND
054134   *"8LOG 8HIST
"054134          IF "HISTO".HISTPROG><LOGPROG OR X.FLGHISTO=0 OR X.HISTART><0 GO FAR OUT
054146          *1BANK
054147          PCSVB=:B; *2BANK
054152          *TRA PVL
054153          A SHZ -3/\17=:D
054156          A SH 1+"SLVTB"=:X
054161          *MIN 1,X; SKP; MIN ,X; RAND
054165          IF "HISTO".CHILEV SHZ -3/\17><D GO FAR OUT
054173          GO IHIST
054174   *"8HIST
"054174   %=============================================================================
054174   %      ( M )    S H I S T I
054174   %
054174   % ROUTINE CALLED FROM LEVEL 13 FOR HISTOGRAM SAMPLING.
054174   % ACTIVATED EITHER BY THE @DEFINE-SYSTEM-HISTOGRAM COMMAND
054174   % OR BY THE @DEFINE-HISTOGRAM/@START-HISTOGRAM COMMAND
054174   %
054174   SHISTI:IF "HISTO".HISTFLAG><0 THEN               % @DEFINE-SYSTEM-HISTOGRAM
054177   IHIST:    T:=X.CHILEV; *EXR ST
054201             A-X.FPREG=:D:=0; T:=X.DELTA; *RDIV ST
054206             IF A>>=100 THEN A:=100 FI
054212             X:="HISTO"+A+A
054215             *MIN 1,X; SKP; MIN ,X; RAND
054221             X:="HISTO"
054222             *MIN HTOT2,X; SKP; MIN HTOT1,X; RAND
054226             EXIT
054227          FI
054227          IF X.HISTART><0 AND X.HISTPROG=CURPROG THEN    % ORDINARY HISTOGRAM
054235             IF BACKGROUND=0 OR CURPROG.ACTPRI/\3=0 THEN
054243                *IRR ALEVB DP
054244                A-"HISTO".FPREG=:D:=0; T:=X.DELTA; *RDIV ST
054252                IF A>>=100 THEN A:=100 FI
054256                X:="HISTO"+A+A
054261                *MIN 1 ,X; SKP; MIN ,X; RAND
054265                X:="HISTO"
054266             ELSE
054267                X:="HISTO"
054270                *MIN STLT2,X; SKP; MIN STLT1,X; RAND
054274             FI; *MIN HTOT2,X; SKP; MIN HTOT1,X; RAND
054300          FI; EXIT
054301   RBUS
054315
054315   *"8DILG
"054315
054315   %===========================================================================
054315   %            M L D I L
054315   %
054315   % MONITOR LEVEL ROUTINE TO START OR STOP THE DISC ACCESS LOG RT-PROGRAM
054315   %
054315   SUBR MLDIL
054315   MLDIL:  IF "RTDIL".WLINK><0 THEN                     % ALREADY RUNNING
054320              IF "DFDIL".DILGFLAG NBIT DILIABSTR THEN   % NOT EXECUTING MON ABSTR
054324                 "RTDIL".STATUS BZERO 5WAIT=:X.STATUS   % RESTART PROGRAM
054330              FI
054330           ELSE
054331              CALL RTENTRY                              % NOT RUNNING, START IT
054332          FI; GO MONEN
054333   RBUS
054337
054337   *"8DIR
"054337

054337   %==============================================================================
054337   % 37.8.1     B U S E X
054337   %
054337   %      BUS EXTENDER DRIVER FOR LEVEL 13
054337   %
054337   %      ON ENTRY:             A = IDENTCODE - 1
054337   %
054337
054337   SUBR BUSEX
054337
054337
054337   INTEGER BEXNO, BEXHDEV, LPES
054342
054342   BUSEX: *IOF
054343          A - 7 =: BEXNO                  % BEXNO CONTAINS EXTENDER NO.
054345          A SH 2 + HDEV =: T =: BEXHDEV   % T=BEXHDEV=DEVNO OF CALLING BEX
054351          X := "B14"                      % X POINTS TO BASE-FIELD FOR ENT14
054352          *TRA PVL
054353          A =: D; *EXR SA                 % GET PERR
054355          A =: X.PERR                     % TO E14.PERR
054356          A := D SH 11 SHZ -14 =: X.ACTLV % TO E14.ACTLV
054362          A := 2; T + "DCONT"; *IOXT      % ENABLE NEW INTERRUPT
054365          T + "DST-DCONT"; *IOXT          % READ BEX STATUS
054367          IF A BIT 14 GO PFINT            % POWER FAIL?
054371          IF A BIT 12 GO ILPARITY         % MEMORY PARITY ERROR?
054373          BEXNO; CALL 9ERR (#48)          % ERROR MESSAGE
054376   UTBEX: *ION
054377          CALL ID13                       % WAIT FOR INTERRUPT
054400          GO BUSEX
054401
054401   %%%    POWER FAIL
054401
054401   PFINT: 12 =: X.IBITNO                  % TO E14.IBITNO
054403          CALL 9ERR (#49)                 % ERROR MESSAGE
054405          GO UTBEX
054406
054406   %%%    MEMORY ERROR
054406
054406   ILPARITY: 10 =: X.IBITNO                  % TO E14.IBITNO
054410          T := BEXHDEV + "DCONT"          % T = DEV.NO OF INTERRUPTING BEX
054412          A:=2; *IOXT                     % ENABLE FOR NEXT INTERRUPT
054414          T + "DDR-DCONT"; *IOXT          % READ LOCAL PES-REGISTER
054416          A =: LPES := 102                % SAVE CODE
054420          T + "DCONT-DDR"; *IOXT          % ENABLE FOR READING LOW LIM.
054422          T + "DDR-DCONT"; *IOXT          % READ LOW LIM.
054424          A /\ 377 + LPES =: X.PESERR     % STORE IN E14.PESERR
054427          A:=42; T + "DCONT-DDR"; *IOXT   % ENABLE FOR READING LOCAL PEA.
054432          T + "DDR-DCONT"; *IOXT          % READ LOCAL PEA
054434          A =: X.PEAERR                   % TO E14.PEAERR
054435          BEXNO; CALL 9ERR (#70)          % ERROR MESSAGE
054440          "EFJOB"; *IRW 160 DP            % SET LEV.14 P-REG
054442          "40000"; *MST PIE; MST PID      % ENABLE/WAKE LEVEL 14
054445          GO UTBEX
054446
054446   RBUS
054455
054455   *"8MPM4
"054455   %==============================================================================
054455   %                   BUSCD
054455   %
054455   %      MPM4 INTERRUPT HANDLER FOR LEVEL 13D
054455   %
054455   %      ON ENTRY:               A = IDENTCODE - 1
054455   %
054455
054455   SUBR BUSCD
054455
054455
054455   INTEGER POINTER IROUT:=ROUTI
054456   INTEGER BUSCNO,BUSST,LLIM,LPES,LPEA
054463
054463   BUSCD: *IOF
054464          A-017=:BUSCNO SHZ 2 + HDEV + 2 =:T; * IOXT          % READ BUSC STATUS
054473          A=:BUSST
054474          IF A BIT 7 GO PFINT                       % MPM4 POWER FAIL
054476          IF A BIT 6 GO MOOR                        % MEMORY OUT OF RANGE
054500          IF A BIT 5 GO ILPARITY                    % PARITY ERROR
054502          CALL IROUT                                % RE-INIT INTERRUPT
054503          A:=BUSCNO; T:=BUSST; CALL 9ERR(#71)       % ILLEGAL BUSC INTERRUPT
054507   RETUR: *ION
054510          CALL ID13                                 % WAIT FOR INTERRUPT
054511          GO BUSCD
054512
054512   PFINT: A:=BUSCNO; CALL 9ERR(#72); GO RETUR       % MPM4 POWER FAIL INTERRUPT
054516
054516   MOOR:  CALL IROUT
054517          A:=BUSCNO; T:=LLIM; CALL 9ERR(#73)        % MPM4 MEMORY OUT OF RANGE
054523   MOOR1: A:=LPES; T:=LPEA; CALL 9ERR(#74); GO RETUR  % WRITE PES AND PEA
054530
054530   ILPARITY: CALL IROUT
054531          IF BUSST BIT 4 GO WRPAR
054534          A:=BUSCNO; T:=LLIM; CALL 9ERR(#75)        % MPM4 MEMORY ERROR
054540          GO MOOR1
054541
054541   WRPAR: A:=LPES SHZ -010 /\ 017 =:T               % WRITE-PARITY ERROR
054545          A:=BUSCNO; CALL 9ERR(#76); GO RETUR
054551
054551   ROUTI: A:=0; T:=T+1; * IOXT                      % PREPARE READ LPES
054554          T:=T-3; * IOXT                            % READ LPES
054556          A=:LPES
054557          A:=040; T:=T+3; * IOXT                    % PREPARE READ LPA
054562          T:=T-3; * IOXT                            % READ LPEA
054564          A=:LPEA
054565          A:=0106; T:=T+3; * IOXT                   % PREPARE READ LIMITS
054570          T:=T-3; * IOXT                            % READ LIMITS
054572          A /\ 0377 =:LLIM
054574          EXIT
054575
054575   RBUS
054602
054602   *"8COSP
"054602   %===========================================================================
054602   %  (M)     C O S P S
054602   %
054602   %  START ADDRESS OF COSMOS SPOOLING RT-PROGRAM.
054602   %  STARTED ON MPIT, GET ADRESS OF SPOOLING DATAFIELD, CHANGE TO
054602   %  NUPIN AND GO TO START-ADDRESS ON SEGMENT.
054602   SUBR COSPS
054602   COSPS:  *IOF
054603           "MCOSPS"; *IRW MLEVB DP
054605           MLEV; *MST PID; ION
054610           CALL ERRFATAL
054611   MCOSPS: "COSDA"; *IRW ALEVB DA                % ADDRESS OF SPOOLING DATAFIELD
054613           "0"; *IRW ALEVB DP                    % START ADDRESS ON SEGMENT
054615           "NUPIN+AUPIN+ALEVB+ERNG2"
054616           A=:CURPROG.ACTPRI; *TRR PCR           % NEW ACTPRI
054621           GO MONEN
054622   RBUS
054630   *"
"054630
054630   @DEV 1
