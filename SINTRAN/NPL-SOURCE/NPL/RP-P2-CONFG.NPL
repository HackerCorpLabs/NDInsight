124305   @DEV (S-S-L)RP-P2-CONFG:NPL
124305   % TAB P
124305   %

124305   %==============================================================================
124305   %
124305   %   MON   C O N F I G U R A T I O N         (VSX)
124305   %
124305   %           ENTRY:  A - PARAMETER LIST:
124305   %                           FUNCTION.
124305   %                           PARAMETER INDEX.
124305   %                           PARAMETER SUBINDEX.
124305   %                           VALUE (IN/OUT).
124305   %
124305   %           EXIT:   SKIP RETURN:    OK.
124305   %                   ERROR RETURN:   A - ERROR CODE:
124305   %                                        25 - YOU ARE NOT AUTHORIZED TO DO THIS.
124305   %                                        33 - NO SUCH LOGICAL UNIT.
124305   %                                       174 - ILLEGAL PARAMETER.
124305   %                                       201 - ILLEGAL FUNCTION CODE.
124305   %                                      3201 - ILLEGAL INDEX.
124305   %                                      3222 - TO BIG TABLES. REDUCE SOME OF THE VARIABLES
124305   %                                             X4TSK,X5PRT,X5LNK,X4ACK,X4NBF OR  X5TRB
124305   %
124305   SUBR MNCFG
124305
124305   %       FUNCTION ARRAY TABLE ENTRY.
124305
124305   DISP 0
124305       INTEGER CFFUN                           % LEGAL FUNCTIONS FOR THIS ENTRY.
124305       INTEGER CFHOW                           % HOW TO COMPUTE THIS VALUE.
124305       INTEGER CFVAL                           % VALUE TO USE OR DIVIDE.
124305       INTEGER POINTER CFSPECI=CFVAL           % SPECIAL ROUTINE.
124305       INTEGER CFDIV, CFMIN=CFDIV              % VALUE TO DIVIDE BY.
124305       INTEGER POINTER CFADR, CFROUT=CFADR     % ROUTINE OR VALUE POINTER.
124305       INTEGER CFDESC=CFADR                    % DESCRIPTOR POINTER.
124305   PSID
124305
124305   %       DESCRIPTOR ENTRY.
124305   DISP 0
124305       INTEGER DEADR           % ADDRESS OF ARRAY IN SAVE AREA.
124305       INTEGER DENUMB          % NUMBER OF ELEMENTS IN ARRAY.
124305       INTEGER ELSIZE          % SIZE OF EACH ELEMENT IN THE ARRAY.
124305       INTEGER POINTER DECHECK % ROUTINE TO CHECK FOR LEGAL VALUES.
124305   PSID
124305
124305   %       LEGAL FUNCTIONS.
124305   @ICR;
124305   SYMBOL  0FUSAVE  =17, 1FUSAVE  =100000,     % READ SAVE AREA (NEXT VALUE).
124305           0FUREAD  =16, 1FUREAD  = 40000,     % READ ACTIVE VALUE.
124305           0FUWRITE =15, 1FUWRITE = 20000,     % WRITE SAVE AREA (NEXT VALUE).
124305           0FUGENER =14, 1FUGENER = 10000,     % READ GENERATED VALUE.
124305           0FUFREE  =13, 1FUFREE  =  4000,     % AVAILABLE UNITS (IN MEMORY).
124305           0FUSPECI =12, 1FUSPECI =  2000,     % SPECIAL FUNCTION (PARAMETER DEPENDENT).
124305
124305   %       FUNCTIONS ALLOWED FROM ALL USERS (SUBSET OF ABOVE)
124305
124305           0BFSAVE  = 7, 1BFSAVE  =100200,     % READ SAVE AREA (NEXT VALUE).
124305           0BFREAD  = 6, 1BFREAD  = 40100,     % READ ACTIVE VALUE.
124305           0BFWRITE = 5, 1BFWRITE = 20040,     % WRITE SAVE AREA (NEXT VALUE).
124305           0BFGENER = 4, 1BFGENER = 10020,     % READ GENERATED VALUE.
124305           0BFFREE  = 3, 1BFFREE  =  4010,     % AVAILABLE UNITS (IN MEMORY).
124305           0BFSPECI = 2, 1BFSPECI =  2004,     % SPECIAL FUNCTION (PARAMETER DEPENDENT).
124305
124305   %       PROCEDURE TO COMPUTE VALUE.
124305
124305           0PRDIVIDE   =0, 1PRDIVIDE  =  1,    % DIVIDE VALDIV BY DIVBY.
124305           0PRVALUE    =1, 1PRVALUE   =  2,    % USE VALUE.
124305           0PRADDRESS  =2, 1PRADDRESS =  4,    % USE ADDRESS.
124305           0PRROUTINE  =3, 1PRROUTINE = 10,    % CALL ROUTINE.
124305           0PRPHADDR   =4, 1PRPHADDR  = 20,    % USE PHYSICAL ADDRESS.
124305           0PRUADDR    =5, 1PRUADDR   = 40,    % USE VALUE AS ADDRESS.
124305           0PRARRAY    =6, 1PRARRAY   =100,    % ADDRESS OF ARRAY.
124305           0PRDESCR    =7, 1PRDESCR   =200,    % USE DESCRIPTOR.
124305           0PRUROUT   =10, 1PRUROUT   =400,    % USE VALUE AS ROUTINE.
124305
124305   %       RANGE.
124305
124305           0RAONOFF =17, 1RAONOFF =100000,     % VALUE IS ON OR OFF.
124305           0RAMIN   =16, 1RAMIN   = 40000;     % MINIMUM VALUE.
124305   ;@CR;
124305   INTEGER ARRAY FUNARR(0)                     % FUNCTION ARRAY.
124305   *"8VSX0
"124305   DATA(1FUGENER+1FUREAD, 1PRVALUE+1PRADDRESS, 1, 0, WMVERS)   % STANDARD SYSTEM.
124312   *"-8VSX0
"124312   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 5BUFA, 0, MXDVBUFS)     % DEVICE BUFFERS.
124317   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE, 77777, 0, DVBFPAGE)     % FIRST DVBUF PAGE.
124324   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9BDSL-9BDST, 5BDSZ, MXTADS)      % TADS.
124331   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LBPR-9LTBP, 5RTSIZE, MXBATCHES) % BATCHES.
124336   *"-8COSP
"124336   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, ENDSP-SPTAB-11, 12, MXSPOOLERS)  % SPOOLERS.
124343   *"-8BACS
"124343   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LTBP-9FBPR, 5RTSIZE, MXBPROGS)  % BAKS.
124350   *"
"124350   DATA(1FUREAD,                           1PRADDRESS,          0,     0, MXTBPROGS)       % BAKS IN USE.
124355   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 0DBNU, 0, MXSDB) % DEBUGGERS.
124362   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, NU5PR, 0, MX5PROCS)    % ND500 PROCS.
124367   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRUADDR+1PRADDRESS, NRFSG, 0, MXRFACS)     % RFA SEGMENTS.
124374   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE+1RAMIN, 16,    2, SPQSSIZE)    % SPOOL-Q SIZE.
124401   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRADDRESS+1PRVALUE+1RAMIN, 10,    5, SISYSEG)     % SYS.SEG SIZE.
124406   *"-8ADP
"124406   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS+1RAONOFF, 1, 0, SGADPSIZE) % MON ADP.
124413   *"-8BACS
"124413   DATA(1FUGENER,                          1PRVALUE,   1, 0, 0) % 8BACS.
124420   *"-8COSP
"124420   DATA(1FUGENER,                          1PRVALUE, 1, 0, 0)   % COSMOS SPOOLING.
124425   *"
"124425
124425   DATA(1FUGENER+1FUFREE,      1PRDIVIDE+1PRROUTINE, 9FBPR-RTBES, 5RTSIZE, RTFREE) % USER RTP.
124432   DATA(1FUGENER+1FUFREE,      1PRVALUE+1PRROUTINE,  0USSG,       0,       SGFREE) % USER SEGS.
124437   DATA(1FUREAD+1FUGENER,      1PRDIVIDE+1PRROUTINE, 5TFST-5TTST, 5TTSZ,   TERCNT) % TERMINALS.
124444   DATA(1FUGENER,              1PRDIVIDE,            5TEND-5TFST, 5TTSZ+5TTSZ, 0)  % TELEFIXES.
124451
124451   DATA(1FUGENER,              1PRDIVIDE,            0SELA-0SEFI, 4 , 0)           % SEMAPHORES.
124456   DATA(1FUGENER,              1PRVALUE,             0INDV,    0, 0)               % INT. DEV. (TOTAL).
124463   DATA(1FUGENER,              1PRVALUE,             0INBL,    0, 0)               % INT. DEV. (BLOCK).
124470   DATA(1FUGENER,              1PRVALUE,             SIBAP-SIBBD, 0, 0)            % SIBAS.
124475   DATA(1FUREAD,               1PRROUTINE,           0, 0, VOPFI)                  % OPEN FILES.
124502   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 14000, 10, MXALLMEM) % ALLOCATED MEMORY.
124507
124507   *"8LAMU
"124507   DATA(1FUGENER,                 1PRVALUE,                      1, 0, 0)       % MON LAMU (PRESENT).
124514   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 4000, 1, GNLAMU)  % MAX NUMBER OF LAMUS.
124521   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN,  100, 1, GNLPRT)  % MAX LAMUS PER PROG.
124526   DATA(1FUSAVE+1FUREAD+1FUWRITE, 1PRADDRESS+1PRVALUE+1RAMIN, 4000, 0, GNSYL)   % MAX SYSTEM LAMUS.
124533   *"-8LAMU
"124533   DATA(1FUREAD,       1PRARRAY,  1\2, 0, SOFT500)     % ND500 SOFTWARE VERSIONS.
124540   DATA(1FUREAD,       1PRARRAY, 1\10, 0, MICP500)     % ND500 MICROPROGRAM (PER CPU).
124545   DATA(1FUREAD,       1PRADDRESS,  0, 0, HWINFO+1)    % ND110 MICROPROGRAM.
124552
124552   DATA(1FUREAD,       1PRARRAY, 0\12, 0, MEMCON)  % MEMORY CONFIGURATION.
124557
124557   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUSPECI, 1PRDESCR,   DELOGNO, 0, HDDESC)       % HDLC TYPE.
124564   DATA(1FUGENER,                          1PRUROUT,    CNHDLC, 0, 0)            % # HDLC-HDLC.
124571   DATA(1FUGENER,                          1PRUROUT,    CNSYNC, 0, 0)            % # HDLC-SYNCH.MOD.
124576   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRVALUE+1PRADDRESS, 0NX21, 0, MXX21) % X21.
124603
124603   DATA(1FUSAVE+1FUREAD+1FUWRITE,          1PRDESCR, 0,       0, SPDESC) % SPOOLING DEVICES.
124610   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUSPECI, 1PRDESCR, DELOGNO, 0, LPDESC) % LINE-PRINTER TYPE.
124615
124615   *"8F5UD
"124615   DATA(1FUSAVE+1FUREAD+1FUWRITE+1FUGENER, 1PRDIVIDE+1PRADDRESS, 9LPUD-9FPUD, 5RTSIZE, 5FUDMA) % FAST UDMA.
124622   *"-8F5UD
"124622   DATA(1BFREAD, 1PRADDRESS, 0, 0, FPIMP)            % READ FIRST PAGE IN MULTIPORT
124627
124627   DATA(1FUREAD                 , 1PRDESCR, 0, 0, DXCAL)  % READ XMSG PARAMETERS USED FOR CALCULATION OF SPACE
124634   DATA(1FUREAD+1FUSAVE+1FUWRITE, 1PRDESCR, 0, 0, DXRUN)  % MANIPULATE XMSG PARAMETERS
124641   DATA(1FUSAVE,                  1PRDESCR, 0, 0, DXFRE)  % READ FIRST FREE ADDRESS ON XMSG SEGMENT
124646   DATA(1FUREAD+1FUSAVE+1FUWRITE, 1PRDESCR, 0, 0, NUCON)  % NUCLEUS CONFIGURATION PARAMETERS
124653
124653   INTEGER ENARR(0)    % END OF FUNARR.
124653
124653   **<*50;)ZERO        % ADDITIONAL AREA FOR PATCHING IN UPTO 8 NEW PARAMETERS.
124653   **50/
124723
124723
124723   % DESCRIPTORS.
124723   INTEGER ARRAY HDDESC:=(0HDTA,0NHDL,TBLHDLCSIZE,CHKHD) % HDLC DEVICES.
124727   INTEGER ARRAY LPDESC:=(0LPTA,0NLPS,LPTBSIZE,CHKLP)    % LINE PRINTERS.
124733   INTEGER ARRAY SPDESC:=(0SPTA,0SPLE,1,CHKSP)           % SPOOLING DEVICES.
124737   INTEGER ARRAY  DXCAL:=(XCALC,7,1,CXDUM)               % XMSG VALUES USED FOR CALCULATIONS OF SPACE
124743   INTEGER ARRAY  DXRUN:=(XRUNA,30,3,CXKXM)              % XMSG GENERATION PARAMETERS
124747   INTEGER ARRAY  DXFRE:=(FSXMF,1,1,CXDUM)               % FIRST FREE ADDRESS ON XMSG SEGMENT
124753   INTEGER ARRAY  NUCON:=(NUPAR,12,1,CXDUM)              % NUCLEUS GENERATION PARAMETERS
124757
124757   DISP 0
124757       INTEGER FUNC=D0             % FUNCTION (PARAMETER).(NB! D0 also used by XFLAG)
124757       INTEGER IDEX=D1             % INDEX IN FUNARR (PARAMETER).(NB! D1 also used by LTEM)
124757       INTEGER SUBIDEX=D2          % SUBINDEX (PARAMETER).
124757       INTEGER VAL=D3              % INPUT OR OUTPUT VALUE (PARAMETER).
124757
124757       INTEGER LTEM=D1             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER POINTER LREG=D7     % RETURN ADDRESS IN LOCAL SUBROUTINES.
124757       INTEGER LANT=D7             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER XGPSEGM=D4          % SEGMENT FOR WSEG.
124757       INTEGER AGPSEGM=D5          % ADDRESS OF XPGSEGM.
124757       INTEGER LPDISP=D5           % RECORD DISPLACEMENT IN CNHDLC AND CNSYNC.
124757       INTEGER LPEND=D6            % LOOP END VALUE FOR LOCAL SUBROUTINES.
124757       INTEGER TAVL=D6             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER LPCNT=S5            % LOOP COUNTER FOR LOCAL SUBROUTINES.
124757       INTEGER BUSD=S5             % USED BY THE CXKXM ROUTINE (CHECK LEGAL XMSG VALUES)
124757       INTEGER DEPNT=S4            % ADDRESS OF ARRAY ENTRY.
124757       INTEGER CHVAL=D3            % SPOOLING DEVICE NUMBER.
124757   PSID
124757
124757   DISP 0                          % VARIBALES FOR GGVAL/PPVAL.
124757       INTEGER XVAL=D4             % SAVED VALUE TO PUT.
124757       INTEGER XRSEGM=D8           % SAVED REENTRANT SEGMENT.
124757       INTEGER XAREG=D9            % SAVED X OR A REGISTER.
124757       INTEGER XOLD1SEG=D10        % SAVED ACT1SEG.
124757       INTEGER POINTER XLREG=D11   % RETURN ADDRESS.
124757       INTEGER XFLAG=D0            % GET/PUT FLAG
124757   PSID
124757
124757   GGVAL:  1=:XFLAG; GO XXVAL                          % GET VALUE FROM SEGMENT.
124762   PPVAL:  A=:XVAL; 0=:XFLAG                           % PUT VALUE TO SEGMENT.
124764   XXVAL:  X=:XAREG; X:=L=:"XLREG"                     % SAVE REGISTERS.
124767           RTREF.ACT1SEG=:XOLD1SEG; X.RSEGM=:XRSEGM    % SAVE OLD SEGMENTS.
124774           T=:X.ACT1SEG; 0=:X.RSEGM                    % SET NEW SEGMENT, NO REENTRANT.
124776           RTREF; CALL LAMINHIBIT                      % NO LAMUS, RETURN THROUGH STUPR.
125000           XAREG=:D:=XFLAG=:L; T:=XVAL                 % GET VALUE AND ADDRESS.
125005           RTREF.ACTPRI/\ACLEAR\/AUPIN=:X.ACTPRI; *TRR PCR % SET UP PCR TO ACCESS SEGMENT.
125013           X:=D                                        % ADDRESS IN X.
125014           IF L=0 THEN
125016               T=:X.S0                                 % PUT VALUE.
125017           ELSE
125020               T:=X.S0                                 % GET VALUE.
125021           FI
125021           *IOF
125022           "NRPIT+ADPIT+ALEVB+ERNG2"; *TRR PCR         % RESTORE ORIGINAL PCR.
125024           A=:RTREF.ACTPRI; *ION
125027           XOLD1SEG=:X.ACT1SEG; XRSEGM=:X.RSEGM        % RESTORE SEGMENTS.
125033           T=:XAREG                                    % SAVE VALUE WHILE
125034           RTREF; CALL LAMENABLE                       % ENABLING LAMUS, RETURN THROUGH STUPR.
125036           A:=XAREG                                    % GET VALUE.
125037           GO XLREG                                    % RETURN.
125040   *)FILL
125046   INTEGER PENARR:=ENARR                               % POINTER TO END OF PARAMETER ARRAY.
125047
125047   MNCFG:  CALL GET4                                   % GET PARAMETERS.
125050           MLEV; *MST PIE                              % ENABLE PAGE FAULTS.
125052           IF IDEX*5+"FUNARR" >>= PENARR GO ILLIDX     % CHECK INDEX.
125060           X:=A; *1BANK; LDF 0,X; 2BANK; STF CFFUN,B   % MOVE TABLE ENTRY
125065                 *1BANK; LDD 3,X; 2BANK; STD CFDIV,B   %   TO WORK AREA.
125071           IF X:=FUNC = 0 OR X >> 6 GO ILLFUNC         % CHECK FUNCTION.
125076           T:=1; X-                                    % BUILD FUNCTION MASK.
125100           FOR X DO T SHR -1; OD
125102           IF CFFUN/\T = 0 GO ILLFUNC                  % CHECK FUNCTION.
125105           IF BACKGROUND><0 AND "BFIELD".PASSTYPE-2><0 THEN
125113              T SHZ -10; IF CFFUN/\T=0 GO ERRAUTH      % MUST BE USER SYSTEM IF BG-PROG.
125117           FI
125117           FUNC GOSW ILLFUNC, FUSAVE, FUREAD, FUWRITE, FUGENER, FAR FUFREE, FAR FUSPECI
125130
125130   PUTVAL: X:=ZAREG+3                  % RETURN DATA IN FOURTH PARAMETER.
125132           T:=OLDPAG=:D
125134           CALL DALTON                 % IN USER DATA PIT.
125135           A=:X.S0.S0                  % GIVE USER DATA.
125137           CALL SINALTPIT              % BACK TO DPIT.
125140   OKEND:  MIN ZPREG; 0/\0             % SKIP RETURN.
125142   ENDMO:  IF BACKGROUND >< 0 THEN CALL XBMRET; FI % FIX SYS.SEG. IN MEMORY.
125145           GO RET                      % END OF MONITOR CALL.
125146
125146   ILLPAR: 174; GO ERRRR   % ILLEGAL PARAMETER.
125150   ILLIDX: RX001; GO ERRRR % ILLEGAL INDEX.
125152   ILLSPA: RX022; GO ERRRR % NO MORE SPACE LEFT ON SEGMENT S3XMK
125154   ILLUNI:  33; GO ERRRR   % NO SUCH LOGICAL UNIT.
125156   ILLFUNC:201; GO ERRRR   % ILLEGAL FUNCTION CODE (FOR THIS INDEX).
125160   ERRAUTH: 25; GO ERRRR   % YOU ARE NOT AUTHORIZED TO DO THIS.
125162   ERRINT:  -1             % INTERNAL ERROR.
125163   ERRRR:  A=:ZAREG
125164           GO ENDMO
125165   *)FILL
125203
125203   FUSAVE: IF CFHOW  BIT 0PRADDRESS THEN X:="CFADR"; T:=5SDPIT; CALL FAR GGVAL
125211           ELSE IF A BIT 0PRDESCR   THEN GO FAR DESAVE
125215           ELSE GO ERRINT FI FI
125217           GO PUTVAL
125220
125220   FUREAD: IF CFHOW  BIT 0PRADDRESS THEN A:=CFADR
125224           ELSE IF A BIT 0PRROUTINE THEN CALL CFROUT
125230           ELSE IF A BIT 0PRDESCR   THEN GO FAR DEREAD
125234           ELSE IF A BIT 0PRARRAY   THEN
125237               A:=CFVAL; AD SHZ -10; D SHZ -10      % SPLIT LOWER AND UPPER LIMITS.
125242               IF T:=SUBIDEX<A OR T>D GO FAR ILLIDX % CHECK SUBINDEX.
125247               CALL CFROUT
125250           ELSE GO ERRINT FI FI FI FI
125252           GO PUTVAL
125253
125253   FUWRITE:IF CFHOW  BIT 0PRADDRESS THEN
125256               IF A BIT 0RAONOFF THEN
125260                   IF VAL >< 0 THEN A:=1 FI    % BINARY VALUE.
125263               ELSE
125264                   CALL WRGENER                                  % GET GENERATED VALUE (MAX).
125265                   IF  A << VAL GO ILLPAR                        % CHECK AGAINST MAX.
125270                   IF CFHOW BIT 0RAMIN AND T<<A:=CFMIN GO ILLPAR % CHECK AGAINST MIN.
125276                   A:=T
125277               FI
125277               X:="CFADR"; T:=5SDPIT; CALL FAR PPVAL       % PUT NEW VALUE.
125302               5SDPIT=:XGPSEGM; A:=B+"XGPSEGM"=:AGPSEGM
125307               A:=B+"AGPSEGM"; *MON 2WSEG                  % WRITE BACK SAVE AREA.
125312           ELSE IF A BIT 0PRDESCR THEN GO FAR DEWRITE
125316           ELSE GO ERRINT FI FI
125320           GO OKEND
125321
125321   FUGENER:A:="PUTVAL"; GO XXGENER
125323   WRGENER:A:=L
125324   XXGENER:A=:"LREG"
125325           IF CFHOW  BIT 0PRUADDR  THEN X:=CFVAL; T:=5SDPIT; CALL FAR GGVAL
125333           ELSE IF A BIT 0PRDIVIDE THEN A:=CFVAL=:D:=0; T:=CFDIV; *RDIV ST
125343           ELSE IF A BIT 0PRVALUE  THEN A:=CFVAL
125347           ELSE IF A BIT 0PRUROUT  THEN CALL CFSPECI
125353           ELSE GO FAR ERRINT FI FI FI FI
125355           GO LREG
125356
125356   FUFREE: IF CFHOW  BIT 0PRROUTINE THEN CALL CFROUT
125362           ELSE GO FAR ERRINT FI
125364           GO FAR PUTVAL
125365
125365   FUSPECI:CALL CFSPECI
125366
125366   *)FILL
125401   RTFREE: D:=0                    % COUNT NUMBER OF FREE USER RT PROGRAMS.
125402           X:="RTBES"
125403           DO WHILE X<<"9FBPR"
125406               IF X.STATUS NBIT 5USED THEN D+1 FI
125412               X+5RTSIZE
125413           OD
125414           A:=D
125415           EXIT
125416
125416   SGCNT:  DO WHILE X<<=LPEND      % COUNT NUMBER OF FREE SEGMENTS FROM X TO LPEND.
125421               T:=SEGTBANK; *SGSTA@3 LDATX
125423               IF A = 0 THEN D+1 FI
125425               X+5SEGSIZE
125426           OD
125427           EXIT
125430
125430   SGFREE: A:=L=:"LREG"            % COUNT NUMBER OF FREE USER SEGMENTS.
125432           D:=0
125433           SEGSTART+"1STFS"=:X     % FIRST GROUP.
125436           SEGSTART+3760=:LPEND
125441           CALL SGCNT
125442           SEGSTART+"SEGTX"=:X     % SECOND GROUP.
125445           SGMAX*5SEGSIZE+SEGSTART=:LPEND
125451           CALL SGCNT
125452           A:=D
125453           GO LREG
125454
125454   TERCNT: D:=0                    % COUNT NUMBER OF TERMINALS IN TIMER TABLE.
125455           X:="9SXTD"
125456           *1BANK                  % TABLE IS IN RPIT.
125457           DO WHILE X<<"9EXTD"
125462               IF X.S0>>"5TTST" AND <<"5TFST" THEN D+1 FI  % TERMINAL PRESENT.
125472               X+2                 % TWO ENTRIES PER TERMINAL.
125473           OD
125474           *2BANK
125475           A:=D
125476           EXIT
125477
125477   VOPFI:  IF DV100>=NPOOL THEN A:=T FI    % THE MAX NUMBER OF OPEN FILES IS
125504           EXIT                            % THE MINIMUM OF THE SIZE OF THE OPEN
125505                                           % OPEN FILE TABLE AND THE NUMBER OF BUFFERS.
125505   *)FILL
125524   DEMOVE: X:=CFDESC                   % MOVE DESCRIPTOR TO WORK AREA.
125525           *1BANK; LDD DEADR,X; 2BANK; STD DEADR,B
125531           *1BANK; LDD ELSIZ,X; 2BANK; STD ELSIZ,B
125535           IF SUBIDEX=0 OR >> DENUMB GO FAR ILLIDX     % CHECK SUBINDEX.
125542           A-1*ELSIZE+DEADR=:X                         % COMPUTE ENTRY POINTER.
125546           EXIT
125547
125547   DESAVE: CALL DEMOVE                 % READ DESCRIPTOR SAVE AREA.
125550           T:=5SAVE; CALL FAR GGVAL
125552           GO FAR PUTVAL
125553
125553   DEREAD: CALL DEMOVE                 % READ DESCRIPTOR CURRENT VALUE.
125554           T:=0; *LDATX
125556           GO FAR PUTVAL
125557
125557   DEWRITE:CALL DEMOVE                 % WRITE DESCRIPTOR NEXT VALUE.
125560           X=:DEPNT
125561           A:=VAL                      % GET VALUE.
125562           CALL DECHECK                % CHECK IT.
125563           X:=DEPNT
125564           T:=5SAVE; CALL FAR PPVAL    % WRITE IT.
125566           5SAVE=:XGPSEGM; A:=B+"XGPSEGM"=:AGPSEGM
125573           A:=B+"AGPSEGM"; *MON 2WSEG                  % WRITE BACK SAVE AREA.
125576           GO FAR OKEND
125577
125577   DELOGNO:CALL DEMOVE     % FIND LOGICAL DEVICE NUMBER.
125600           T:=0; *LDATX 10 % GET DEVICE NUMBER.
125602           GO FAR PUTVAL
125603   *)FILL
125612   CHKHD:  K:="0"; GO CHFEL    % CHECK HDLC PARAMETERS.
125614   CHKLP:  K:="1"              % CHECK LINE PRINTER PARAMETERS.
125615   CHFEL:  IF A=:D = 0 THEN EXIT FI    % 0 IS ALWAYS OK.
125620           IF D=1 THEN                 % FIRST CHOICE.
125623               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125625               IF K THEN; *LDATX 30    % L-P.
125630               ELSE;      *LDATX 20    % HDLC.
125632               FI
125632           ELSE IF D=2 THEN            % SECOND CHOICE.
125636               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125640               *LDATX 40
125641           ELSE IF D=3 AND K THEN      % THIRD CHOICE, ONLY L-P.
125647               T:=0; X:=DEPNT          % CHECK IF PRESENT.
125651               *LDATX 50
125652           ELSE
125653               GO FAR ILLPAR           % OTHER CHOICES ARE ILLEGAL.
125654           FI FI FI
125654           IF A=0 GO FAR ILLPAR        % NOT PRESENT.
125656           A:=D                        % RESTORE VALUE.
125657           EXIT
125660
125660
125660   CHKSP:                              % CHECK SPOOLING PARAMETERS.
125660           EXIT
125661   *)FILL
125662   CNHDLC: 2=:LPDISP       % COUNT NUMBER OF HDLC-HDLC.
125664           GO CNFEL
125665   CNSYNC: 4=:LPDISP       % COUNT NUMBER OF HDLC-SYNCH.
125667   CNFEL:  0=:VAL
125670           *1BANK
125671           A:=HDDESC(1); *2BANK
125674           A-=:LPEND; *1BANK   % NUMBER OF ENTRIES.
125677           A:=HDDESC(0); *2BANK
125702           A=:LPCNT            % FIRST ADDRESS.
125703           FOR LPEND DO
125703               T:=5SAVE; LPCNT+LPDISP=:X
125707               CALL FAR GGVAL
125710               IF A >< 0 THEN MIN VAL FI   % COUNT ENTRIES >< 0.
125712               A:=LPCNT;    *1BANK
125714               A+HDDESC(2); *2BANK
125717               A=:LPCNT
125720           OD
125722           A:=VAL
125723           GO FAR PUTVAL
125724   *)FILL
125727   CXDUM:  EXIT                            % NO CHECK
125730   CXKXM:  A=:D; A:=L=:TAVL; T:=0; X-1
125735           *LDATX
125736           IF A>>D THEN GO FAR ILLPAR FI   % Value less than legal minimum value
125741           X+2
125742           *LDATX
125743           IF A<<D THEN GO FAR ILLPAR FI   % Value greater than legal max. value
125746           IF SUBIDEX = 20 THEN
125752              X:=DEPNT; X-3; T:=5SAVE      % Read input frame size
125755              CALL FAR GGVAL; X:=VAL
125757              IF X >> A THEN GO FAR ILLPAR FI  % Output frame size must be <=  input frame
125762           FI
125762           IF SUBIDEX = 17 THEN
125766              X:=DEPNT; X+3; T:=5SAVE      % Read output frame size
125771              CALL FAR GGVAL; X:=VAL
125773              IF X << A THEN GO FAR ILLPAR FI  % Output frame size must be <=  input frame
125776           FI
125776           IF SUBIDEX = 23 THEN
126002              X:=DEPNT; X-52; T:=5SAVE     % Read number of message elements
126005              CALL FAR GGVAL; X:=VAL
126007              IF X >> A THEN GO FAR ILLPAR FI  % Number of network server transmitt buffer
126012           FI                                  % must be less than total message elements
126012           IF SUBIDEX = 5 THEN
126016              X:=DEPNT; X+52; T:=5SAVE         % Read number of network server transmitt buffer
126021              CALL FAR GGVAL; X:=VAL
126023              IF X << A THEN GO FAR ILLPAR; *)FILL        % Number of network server transmitt buffer
126030              FI
126030           FI                                             % must be less than total message elements
126030           X:="XRUNA"
126031           T:=1 CALL CHIND                                % Calculate space for task tables
126033           A*"4TLEN"; A=:BUSD; X:="XRUNA"; X+3
126037           T:=2; CALL CHIND                               % Calculate space for port tables
126041           A*"4PLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+14
126046           T:=5; CALL CHIND                               % Calculate space for message tables
126050           A*"4MLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+36
126055           T:=13; CALL CHIND                              % Calculate space for link tables
126057           IF A = 0 GO NOLINK                             % If number of link is 0, no space vil be used for
126060           A=:LANT*"4LLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+60% acknowledgement and receive frames
126066           T:=21; CALL CHIND                              % Calculate space for acknowledgement frames
126070           A+12*"5FLEN"; A+BUSD=:BUSD; X:="XRUNA"; X+63
126076           T:=22; CALL CHIND                              % Calculate space for receive frames
126100           A*LANT*"5FLEN"; A+BUSD=:BUSD;
126104           GO NOLINK
126105   *)FILL
126114   NOLINK: X:="XRUNA"; X+105
126116           T:=30; CALL CHIND                              % Calculate space for trace buffers
126120           A*2; A+"X5FUN"; A+BUSD=:BUSD; X:="FSXMF"
126125           T:=5SAVE; CALL FAR GGVAL                       % Find first free location on segment 76
126127           X:="X6TOP"; X-1 ; X-A                          % Top of segment 76
126132           A:=BUSD
126133           IF A >>= X THEN GO FAR ILLSPA FI               % Check if there is enough space on segment
126136           53=:IDEX                                       % Restore index number (same location as LTEM)
126140           A:=TAVL=:L; A:=VAL; X:=DEPNT;                  % Restore value and address within XRUNA
126144           EXIT
126145   CHIND:  A:=SUBIDEX
126146           IF A=T THEN
126150                A:=VAL                                            % If current subindex use actual value
126151           ELSE
126152                T:=L=:LTEM; T:=5SAVE; CALL FAR GGVAL; T:=LTEM=:L  % if not; read value from save area
126160           FI
126160           EXIT
126161   *)FILL
126170   DISP 0
126170       INTEGER PCOUNT=D4       % PAGE COUNTER
126170       INTEGER MASK=D5         % MASK FOR MEMORY COUNTER.
126170       INTEGER NBANKS=D6       % NUMBER OF BANKS.
126170   PSID
126170
126170   MEMCON:             % MEMORY CONFIGURATION
126170   SUBIDEX GOSW MMTOT,MMLOCAL,MPIO,MM3,MM4,MM5,MMSWAP,MMSIN,MMRTC,MM500,FAR MMDAT
126205
126205   MMTOT:  A:=0;      GO MMLOOP    % NOT MEMORY.
126207   MMLOCAL:A:=KMECCR; GO MMLOOP    % LOCAL ND-100 MEMORY.
126211   MPIO:   A:=KMPIOC; GO MMLOOP    % PIOC MEMORY.
126213   MM3:    A:=KMPM3;  GO MMLOOP    % MPM 3 MEMORY.
126215   MM4:    A:=KMPM4;  GO MMLOOP    % MPM 4 MEMORY.
126217   MM5:    A:=KMPM5                % MPM 5 MEMORY.
126220   MMLOOP:             % COUNT NUMBER OF BANKS OF THIS KIND OF MEMORY.
126220           A=:MASK                             % SET WANTED MEMORY TYPE.
126221           T:=MBMEMARRAY; X:=MEMARRAY          % MEMORY DESCRIPTION ARRAY.
126223           A:=X+200=:L                         % END OF ARRAY.
126226           0=:NBANKS                           % RESET BANK COUNTER.
126227           DO WHILE X << L
126231               *LDATX                  % GET TWO BYTES.
126232               AD SHZ -10              % SPLIT THE BYTES, TEST UPPER BYTE.
126233               IF A-MASK = 0 THEN      % IF MEMORY IS OF WANTED KIND THEN
126235                   MIN NBANKS          % COUNT ONE BANK.
126236               FI
126236               AD SHZ 10; A/\377       % TEST LOWER BYTE.
126240               IF A-MASK = 0 THEN      % IF MEMORY IS OF WANTED KIND THEN
126242                   MIN NBANKS          % COUNT ONE BANK.
126243               FI
126243               X+1
126244           OD
126245           IF SUBIDEX = 0 THEN 400-NBANKS=:NBANKS FI % COMPLEMENT TO ALL MEMORY.
126252           A:=NBANKS SHZ 6             % MULTIPLY BANKS BY 64 TO GET PAGES.
126254           GO FAR PUTVAL
126255
126255   MMSWAP:             % PAGES FOR SWAPPING.
126255           A:=-1; CALL CHNSWPAGES
126257           GO FAR PUTVAL
126260   MMSIN:              % PAGES USED BY RESIDENT SINTRAN.
126260           "0DMMLIMS"/\1777\/PITST=:X  % START OF MEMORY ARRAY IN START BASE FIELD.
126264           "0EMMLIMS"/\1777\/PITST=:L  % END OF MEMORY ARRAY.
126270           T:=0                        % BANK #0.
126271           0=:PCOUNT                   % RESET PAGE COUNTER.
126272           DO WHILE X<<L               % DO FOR WHOLE ARRAY.
126274               *LDDTX                  % GET MEMORY ENTRY.
126275               IF A>=0 THEN            % IF USED THEN
126276                   D-A+1               % COMPUTE SIZE AND
126300                   PCOUNT+D=:PCOUNT    % ADD TO TOTAL.
126303               FI
126303               X+2                     % NEXT ENTRY.
126304           OD
126305           A:=PCOUNT
126306           GO FAR PUTVAL
126307   *)FILL
126323   MMRTC:              % PAGES USED BY RT-COMMON.
126323           A:=CCNOX
126324           GO FAR PUTVAL
126325   MM500:              % PAGES RESERVED BY ND-500.
126325           IF PN500D >< 0 THEN
126327               A:=A.AN5PAGES
126331           FI
126331           GO FAR PUTVAL
126332
126332   MICP500:            % ND500 MICROPROGRAM VERSIONS.
126332           IF PN500D = 0 GO FAR ILLIDX         % NO ND500 IN THIS SYSTEM.
126335           IF SUBIDEX-1*"5CPUDFSZ"+"S5CPUDF" >> "E5CPUDF" GO FAR ILLIDX % VALID CPU NUMBER.
126344           IF A.CPUAVAILABLE = 0 GO FAR ILLPAR % THE CPU DOES NOT EXIST.
126350           IF X.5INITFLAG BIT BCSLOADED THEN   % IF MICRO PROGRAM IS LOADED.
126353               A:=X.5MICPVERS                  % GET MICRO PROGRAM VERSION.
126354           ELSE
126355               A:=0                            % MICRO PROGRAM NOT LOADED.
126356           FI
126356           GO FAR PUTVAL
126357   *)FILL
126367   % VERSION DISPLACEMENT AND SIZE IN WORDS.
126367   DOUBLE SWDATA(0);DATA(5SWVERS,4)    % SWAPPER VERSION.
126371   DOUBLE SMDATA(0);DATA(5SYMVERS,6)   % SYSTEM MONITOR VERSION.
126373
126373   SOFT500:            % ND500 SOFTWARE VERSIONS:
126373           IF PN500D = 0 GO FAR ILLIDX         % NO ND500 IN THIS SYSTEM.
126376                                               % SUBINDEX HAS TO BE 1 OR 2 HERE.
126376                               % MOVE VERSION TO USER.
126376           X:=ZAREG+3          % POINTER TO FOURTH PARAMETER ADDRESS.
126400           OLDPAG=:D           % USERS PITS.
126402           CALL DALTON         % IN USERS DATA PIT.
126403           T:=X.S0             % GET DESTINATION ADDRESS.
126404           CALL SINALTPIT      % BACK TO DPIT.
126405           IF SUBIDEX-1 = 0 THEN                                  % SWAPPER VERSION
126410               IF PN500D.SYSINITFLAG NBIT BSWLOAD GO FAR ILLPAR   % SWAPPER NOT LOADED.
126414               AD:=SWDATA
126415           ELSE                                                   % SYSTEM MONITOR VERSION.
126416               IF 5MSINIT = 0 GO FAR ILLPAR                       % SYSTEM MONITOR NOT STARTED.
126421               AD:=SMDATA
126422           FI
126422           D=:X                % NUMBER OF WORDS IN X.
126423           A+PN500D=:D         % SOURCE ADDRESS IN D.
126425           A:=OLDPAG; K:="1"   % USER PIT; TO USER.
126427           CALL MOVUS          % MOVE DATA.
126430           GO FAR OKEND        % THAT'S IT.
126431
126431   MMDAT:                            % READ MEMORY TYPE ARRAY
126431         X:=ZAREG+3
126433         OLDPAGE=:D  ; CALL DALTON
126436         T:=X.S0
126437         CALL SINALTPIT                % RESET TO DPIT AS ALT PIT
126440         X:=MEMARRAY ; A:=MBMEMARRAY
126442         CALL DALTON
126443         X =: D ; X:=200=:L ; *MOVPA   % MOVE PHYSICAL TO USER(ALT PIT)
126447         CALL SINALTPIT
126450         GO FAR OKEND
126451   RBUS
126464   @DEV 1
