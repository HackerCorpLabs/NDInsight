041352   @DEV (S-S-L)PH-P2-OPPSTART:NPL
041352

041352   %%%%%%%%%%%%%%%%%%%%%%% P H - P 2 - O P P S T A R T %%%%%%%%%%%%%%%%%%%%%%%%%%%
041352
041352   SUBR SINTR,TTMMAP
041352
041352   %===============================================================================
041352   % 36.16      S I N T R
041352   %
041352   *SRTDL=*                     % START OF REG-BLOCKS AND REE-BITMAPS
041352   %===========================================================================
041352   *PL000=*
041352   % MAIN-SWAPPING-DISC DATA  (XXDIS)
041352   % EACH ENTRY CONSIST OF THE FOLLOWING 4 LOCATIONS:
041352   %       0: ADDRESS OF DATAFIELD
041352   %       1: LOGICAL DEVICE NUMBER
041352   %       2: ENTRY POINT OF DRIVER USED BY BOOTS-STRAP, ("SWAP DRIVER")
041352   %       3: ENTRY POINT OF START-UP DRIVER
041352   %       4: HARDW. DEV NO FOR SWAPPE CONT.
041352   @ICR;
041352   INTEGER ARRAY MDISCS:=(
041352           0,    0,    0,    0,    0,    0,    0,    0,   % 00 - 07
041362       WWDIS,WWDIS,WWDIS,WWDIS,WWDIS,WWDIS,    0,BBDIS,   % 10 - 17
041372       BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,   % 20 - 27
041402       BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,BBDIS,SCDIS,    0,   % 30 - 37
041412           0,    0,    0,    0,    0,    0,    0,    0);  % 40 - 47
041422
041422   INTEGER ARRAY WWDIS:=(WIGDI,1224,ZWDIS,WIDIS,   500);  % ST-506
041427   INTEGER ARRAY BBDIS:=(BIGDI,1100,ZBDIS,BDISK,  1540);  % SMD
041434   INTEGER ARRAY SCDIS:=(SCDI1,2210,SCSWD,SCSWD,144300);  % SCSI
041441   INTEGER ARRAY XXDIS:=(    0,   0,    0,    0,     0);  % SPARE
041446   @CR;
041446   %=============================================================================
041446   %            T T M M A P
041446   %
041446   % LOCAL SUBROUTINE TO TEST IF A PAGE (MEMORY BANK), EXIST OR NOT
041446   %
041446   % ENTRY:     A=PAGE NUMBER
041446   %
041446   % EXIT:      PAGE DOES NOT EXIST
041446   %
041446   % EXIT+1:    PAGE EXSIST
041446   %
041446   TRIPLE TRARDR
041451   INTEGER XR,CCBTST(0); *BSKP ZRO DT
041453   TTMMAP: TAD=:TRARDR; X=:XR
041455          A SHZ -6; AD SHZ -4; T:=TMMAP(A)
041461          AD SH 4; A/\17 SH 3+CCBTST; *EXR SA
041466          L+1; TAD:=TRARDR; X:=XR
041471          EXIT
041472
041472   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 10
041472   %
041472   % ENTRY:  A=IDENT CODE
041472   %
041472   10IDCLEAR:
041472          IF A><0 THEN
041473             A-1=:X:="ITB10"-"PITEX"; X+A
041500             A:=MPIFPHPAGE SHZ 12; X+A
041503             T:=MPIBANK; *STZTX                               % CLEAR ENTRY
041505          FI; EXIT
041506
041506   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 11
041506   %
041506   % ENTRY:  A=IDENT CODE
041506   %
041506   11IDCLEAR:
041506          IF A><0 THEN
041507             A-1=:X:="ITB11"-"PITEX"; X+A
041514             A:=IPIFPHPAGE SHZ 12; X+A
041517             T:=IPIBANK; *STZTX                               % CLEAR ENTRY
041521          FI; EXIT
041522
041522   % CLEAR AN ENTRY IN IDENT-CODE TABLE FOR LEVEL 12
041522   %
041522   % ENTRY:  A=IDENT CODE
041522   %
041522   12IDCLEAR:
041522          IF A><0 THEN
041523             A-1=:X:="ITB12"-"PITEX"; X+A
041530             A:=MPIFPHPAGE SHZ 12; X+A
041533             T:=MPIBANK; *STZTX                               % CLEAR ENTRY
041535          FI; EXIT
041536
041536
041536   % CLEAR AN ENTRY IN THE LOGICAL UNIT TABLE
041536   %
041536   % ENTRY:  A=LOG.DEV.NO
041536   %
041536   CLLOGENTRY:
041536          IF A><0 THEN
041537             A=:D SHZ -6; X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
041550             T:=LOGDBANK; *STZTX; STZTX 10
041553          FI; EXIT
041554
041554
041554   % LOCAL SUBROUTINE TO REMOVE AN ELEMENT FROM THE TIMER TABLE
041554   %
041554   % ENTRY:   A=ACTUAL TIMER-TABLE-ELEMENT VALUE
041554   %
041554   RFTMTABLE:
041554          IF A><0 THEN
041555             A=:XA; "TMRTA"-"PITEX"=:X; RPIFPHPAGE SHZ 12=:D; X+A  % X=START OF TIMER TABLE
041565             "ETMRT"-"PITEX"; D+A                                  % D=END OF TIMER TABLE +1
041570             DO WHILE X<<D
041572                T:=RPIBANK; *LDATX
041574                IF A-XA=0 THEN                                     % ELEMENT FOUND
041576                   *STZTX                                          % CLEAR ENTRY
041577                   EXIT
041600                FI; X+1
041601             OD
041602          FI; EXIT
041603   *)FILL
041616
041616   *PL001=*
041616
041616   % LOCAL SUBROUTINE TO CHECK IF A FLOPPY INTERFACE IS PRESENT
041616   % AND UPDATE TIMER-TABLE, IDENT-CODE TABLE, LOGICAL UNIT TABLE
041616   % ACCORDING TO THE RESULT OF THE INVESTIGATION, I.E
041616   % ENTRIES ARE CLEARED IF INTERFACE NOT FOUND, CORRECT DATAFIELD,
041616   % OLD OR NEW FLOPPY, IS INSERTED INTO THE TABLES IF INTERFACE IS PRESENT.
041616   %
041616   INTEGER POINTER FFLLREG
041617   FINDFLOPPY: X=:CSAVX                              % X=ADDR OF FLOPPY-ARRAY
041620          0=:1CLTIMER=:2CLTIMER
041622          A:=L=:"FFLLREG"
041624          IF X.S0><0 OR X.S1><0 THEN                % ANY FLOPPY CONTROLLER GENERATED?
041630             X:=A; A:=200; *TRR IIE; TRA IIC        % ENABLE FOR IOX-ERRORS
041634             T:=X.HDEV+2; *EXR ST                   % IOX READ STATUS
041637             A=:D; *TRA IIC                         % D=FLOPPY STATUS
041641             IF A=0 THEN                            % INTERFACE PRESENT
041642                IF D<0 THEN
041644                   CSAVX.S1; T:=X.S0                 % NEW FLOPPY
041647                ELSE
041650                   CSAVX.S0; T:=X.S1                 % OLD FLOPPY
041653                FI; T=:1CLTIMER                     % ENTRY TO BE REMOVED FROM TIMER TABLE
041654             ELSE
041655                CSAVX.S0=:1CLTIMER; X.S1=:2CLTIMER
041662                A:=0                                % INTERFACE NOT PRESENT
041663             FI; A=:XA                              % D=VALUE TO INSERT INTO TABLES
041664             CSAVX.S2=:T SHZ -6; X:=CNVRT(A)
041672             A:=T/\77 SH 1+1; X+A                   % X=ADDR IN LOG.DEV.NO. TABLE
041677             A:=XA; T:=LOGDBANK; *STATX             % UPDATE LOG.DEV.NO. TABLE
041702             T:=IPIFPHPAGE SHZ 12=:D
041705             A:="ITB11"-"PITEX"+D+CSAVX.S3-1=:X
041714             T:=IPIBANK; A:=XA; *STATX              % UPDATE IDENT CODE TABLE
041717             1CLTIMER; CALL RFTMTABLE
041721             2CLTIMER; CALL RFTMTABLE
041723          FI; GO FFLLREG
041724   *)FILL
041732
041732
041732   % LOCAL SUBROUTINE TO BUILD A SEGMENT
041732   %
041732   % ENTRY: A=FIRST PHYS.PAGE IN SEGMENT
041732   %        D=LAST PHYS.PAGE IN SEGMENT
041732   %        T=SEGMENT NUMBER
041732   SGBUILD:
041732          IF A+1=0 THEN EXIT FI                     % NO MEMORY RESERVED FOR THIS SEGMENT
041735          A-1; X:=L=:"CLINK"
041740          T=:CSGNO
041741          A:=:D-D+1=:NPAGES
041745          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
041752          A:=D SH 2+CORMSTART
041755          *BPAGL@3 STATX; LOGAD@3 LDATX
041757          A=:D; *SGSTA@3 LDATX
041761          A BONE 5CMSYS
041762          AD=:DPROLOGAD                   % PROTECT AND LOGADR
041763          A:=NPAGES
041764          *SEGLE@3 STATX; BPAGL@3 LDXTX
041766          X=:L; T:=CORMBANK
041770          DO WHILE NPAGES><0
041772             A:=PROLOG; *PROTE@3 STDTX
041774             D+1; *PAGLI@3 LDXTX
041776             NPAGES-1=:NPAGES
042001          OD; IF X><0 THEN CALL ERRFATAL FI
042004          X:=L; A:=CSGNO SH 2+3; *PREVI@3 STATX
042011          GO CLINK
042012   *)FILL
042020
042020   % LOCAL SUBROUTINE TO SIMULATE LOGPH FOR ELEMENTS IN IOBUTAB
042020   %
042020   % ENTRY:     A=LOGICAL DEVICE NUMBER
042020   %            CINDADDR MUST POINT TO ELEMENT IN IOBUTAB
042020   %
042020   % EXIT:      X=ADDRESS OF DATAFIELD
042020   %
042020   % CALL TO ERRFATAL WHEN ERROR
042020   @ICR;
042020   INTEGER ARRAY ENTAB:=(EN000,0,EN200,EN300,EN400,EN500,EN600,EN700,
042030                         E1000,E1100,E1200,E1300,E1400,E1500,E1600,E1700,
042040                         E2000,E2100,E2200,E2300,E2400,E2500,E2600,E2700,
042050                         E3000,E3100,    0,E3300,    0,    0,    0,    0);
042060   @CR;
042060   CLOGPH: K:=1; GO ILOGPH
042062   XLOGPH: K:="0"
042063   ILOGPH: AD SHZ -6; IF A=1 OR A =RDLNO OR A>LGDGMAX THEN CALL ERRFATAL FI
042076          A=:X:=D SHZ -12
042101          A+A+CCNVRT(X)+1=:D; *1BANK
042106          IF A-ENTAB(X)>=0 THEN CALL ERRFATAL FI; *2BANK
042112          X:=D; *POF; LDD ,X; PON
042116          IF K THEN
042120             IF A><0 THEN X:=A ELSE X:=D FI
042124          ELSE
042125             X:="ICINDADDR"; *POF; LDT ,X; PON
042131             IF T BIT 17 THEN D=:X ELSE A=:X FI
042136          FI; IF X=0 THEN CALL ERRFATAL FI
042141          EXIT
042142   *)FILL
042144   *PL002=*
042144
042144   % ROUTINE ON LEVEL 14 TO TEST FOR MMS II AND PGS WITH 10 BITS PAGE NUMBER
042144   TSPCR: *TRA IIC
042145          IF A><3 THEN CALL ERRFATAL FI                 % NOT PAGE FAULT
042151          *TRA PGS
042152          IF A/\1777><1777 THEN CALL ERRFATAL FI        % NOT MMS II?
042157          *IRR 0 DP; AAA 1; IRW 0 DP                    % INCREMENT P-REG ON LEVEL 0
042162          *WAIT; JMP *-1
042164   *)FILL
042166
042166   % LOCAL SUBROUTINES TO COMPRESS THE EXTENDED IDENT CODE TABLES
042166   %
042166   % ENTRY: X=LOGICAL START ADDR OF TABLE.
042166   %
042166   INTEGER CCBNK,CCPHP
042170
042170   EIDCIPIT:IPIBANK=:CCBNK; IPIFPFPAGE=:CCPHP; GO EIDFELLS
042175   EIDCMPIT:MPIBANK=:CCBNK; MPIFPFPAGE=:CCPHP
042201   EIDFELLS:
042201          A:=L=:"CLINK"
042203          A:=X-"PITEX"=:D:=CCPHP SHZ 12+D=:X   % PHYS. ADDR OF TABLE WITHIN MEM.BANK
042212          X=:CSAVX; T:=CCBNK
042214          DO
042214             *LDATX                       % FIND END OF TABLE
042215          WHILE A+1><0; X+2
042220          OD; X=:PREVX                    % END OF TABLE
042222          DO
042222             X:=CSAVX
042223             DO
042223                T:=CCBNK; *LDATX
042225             WHILE A><0 AND A><-1; X+2
042232             OD
042233             IF A=-1 GO CLINK                % EXIT, TABLE IS COMPRESSED
042236             IF PREVX-2<<=X GO CLINK         % EXIT, TABLE IS COMPRESSED
042242             A=:PREVX-X=:L                   % L=NUMBER OF WORDS TO MOVE
042245             A:=X+2=:D; X=:CSAVX=:T
042252             A:=CCBNK=:X; *MOVPP             % COMPRESS TABLE
042255             T:=CCBNK; X:=PREVX
042257             *STZTX; STZTX 10                % FILL OUT WITH ZEROES
042261          OD; *)FILL
042263
042263   %---------------------------------------------------------------
042263   % READ DPIT INTO BANK 1. KGT
042263   %---------------------------------------------------------------
042263   * ODDFI=*+112; ODDFI+40/; ODDFI-75<*; )ZERO  % DISK DF
042435
042435          INTEGER POINTER PSWD:=BDISK
042436          INTEGER DPAH:=DPITBANK,DPAL:=4000    % MEMORY ADDRESS
042440          DOUBLE DPAD=DPAH
042440
042440          INTEGER DPSA:=MSDPT,DPIM:=MIDPT      % DISK ADDRESS (SAVE/IMAGE)
042442          INTEGER DPLN:=LSDPT                  % LENGTH
042443          INTEGER LSST                         % SCETORS/PAGE
042444          INTEGER POINTER L3RG
042445
042445   DPRE: A:=L=:"L3RG"
042447         A:="ODDFI"=:B                           % DF. FOR DISK DRIVER
042451         T:=ODISP(SWTYP)=:HTABL(0)               % COPY OF DISPE ON START SEGM
042455         T:=T.S0; A:=2000=:D:=0; *RDIV ST        % SECTORS/PAGE
042463         IF D><0 THEN CALL ERRFATAL FI
042466         A=:LSST
042467         X:= MDISCS(SWTYPE)                      % ADDR OF DISC-ATTRIBUTES
042471         X.SWHDEV=:HDEV
042473         IF X.SWDDRIVER=:"PSWD"><"SCSWD" THEN    % DRIVER ADDRESS
042500            A:=B+"NWLBA-5"=:NWLBA                % SPARE TRACK ADDRESS
042503         ELSE
042504            A:=-70+B=:D:=0; *STD ,B -72          % SCSI BUFFER ADDRESS
042511         FI
042511         DPAD=:MEMAD=:CMADR; T:=42; X:=1
042516   LDF:  CALL PSWD; CALL ERRFATAL;GO LDF         % INITIATE DF
042521         DPAD=:MEMAD=:CMADR; A:=DPLN*LSST =:X           % PARAMETERS TO DRIVER
042527         IF HENTFLAG=0 THEN A:=DPSA ELSE A:=DPIM FI
042534         A+SEGFSTART*LSST=:D:=0; 0=:T
042541   RLOP: CALL PSWD; CALL ERRFATAL;GO RLOP
042544         GO L3RG
042545   *)FILL
042557   %-----------------------------------------------------------------
042557   %     S I N T R
042557   %-----------------------------------------------------------------
042557   % INITIALIZE PAGING SYSTEM AND INTERRUPT SYSTEM
042557   SINTR: A:=0; *PIOF; TRR IIE; TRA IIC
042563          A:=0; *TRR PID; TRR PIE
042566          A:=6; *TRR PCR; SEX; TRA PGS; TRA STS
042573          IF A NBIT 5N100 THEN CALL ERRFATAL FI % THIS SYSTEM IS ONLY FOR NORD 100!!!!
042576          A:="LV0"; *IRW 0 DP; ION
042601   LV0:   *IOF
042602          CALL DPRE                            % READ DPIT
042603          "SBFIELD"=:B
042605          CALL IPTMAP                          % SET UP THE PAGE TABLES
042606   % TEST IF THIS ND-100 HAS MMS II WITH 10 BITS PAGE NUMBER IN PGS.
042606          A:=LV14; *TRR PIE                    % ENABLE INTERRUPT ON LEVEL 14
042610          A:=10; *TRR IIE                      % ENABLE FOR PAGE FAULT
042612          A:="TSPCR"; *IRW LV14B DP
042614          A:="ADTPIT+ERNG2"; *TRR PCR          % LEVEL 0:NPIT=0, APIT=DTPIT, RING=2
042616          A:="ERNG2+LV14B"; *TRR PCR           % LEVEL 14: NPIT=APIT=0, RING=2
042620          X:=-1; *PION; 2BANK
042623          X.S0; CALL ERRFATAL                  % LEVEL 14 SHOULD INREMENT P ON LEVEL 0
042625          A:=0; *TRR PIE; TRR PID              % CLEAR LEVEL 14 ENABELING
042630          *TRA STS
042631          A=:CPSTA
042632          CALL SYSEVAL                         % FIND CPU TYPE
042633          IF HWINFO(0)/\377 >= 3 THEN CALL GCPUNR FI    % TRY TO GET CPU NUMBER
042642          IF HWINFO(0)/\377 <  2 THEN CALL ERRFATAL FI  % MUST BE ND-100/CX , ND-110/CX OR ND-120/CX
042651          IF HWINFO(0) SHZ -10=4 OR =5 THEN
042662             13642=:CPULOOPTIME                % CPU LOOP TIME FOR ND-110.
042664             -15=:LPDELAY
042666          ELSE
042667             IF A=6 OR =7 THEN
042675                27627=:CPULOOPTIME             % CPU LOOP TIME FOR ND-120.
042677                -30=:LPDELAY
042701          FI;FI
042701          A:=-1; *TRR 11
042703          A:=0; *TRR 12                        % NO CACHE INHIBIT
042705          CALL MNHDSJ                          % CHECK NOTS CONTROLLERS
042706   *IFILL
042730
042730   % TEST MEMORY ADDRESS BITS 19-23 (1-32MB)
042730          1000=:CURRPAGE
042732   % IF MULTIPORT 3 THEN 3777=:ENDPAGE ELSE 37777=:ENDPAGE FI
042732          A:=200; *TRR IIE; TRA IIC; IOX 750; TRA IIC
042737          IF A=0 THEN A:=3777 ELSE A:=37777 FI; A=:ENDPAGE
042744          A:=0; *TRR IIE
042746          DO WHILE CURRPAGE><ENDPAGE+1
042753             X:=0
042754             DO WHILE X<<"NINSZ+1*2"
042757                *1BANK
042760                AD:=NINITPAGE(X)
042761                *2BANK
042762                IF A><0 AND A<<=CURRPAGE AND D>>=T GO NEXT
042770                X+2
042771             OD; *POF
042773             X:=0; 124000=:X.S0
042776             *PON
042777             A:=CURRPAGE=:D:=162000; X:=177776
043003             *POF; STD ,X; PON
043006             A:=1000; *TRR IIE; TRA IIC                 % ENABLE FOR MEMORY OUT OF RANGE
043011             X:=176000; X.S0; *TRA IIC
043014             IF A=0 THEN                                % MEMORY OUT OF RANGE?
043015                *PON                                    % NO, TEST FOR WRAP-AROUND
043016                A:=X.S0=:D:=-1=:X.S0; *POF
043023                X:=0
043024                IF X.S0=124000 THEN                     % TEST IF PHYS.ADDR 0 IS CHANGED
043030                   A:=D; X:=176000; *PON
043033                   A=:X.S0; *TRA IIC
043035                ELSE
043036                   124000=:X.S0; *PON
043041                   CURRPAGE-1=:ENDPAGE
043044                   GO LABL1
043045                FI
043045             FI
043045   NEXT:     CURRPAGE SH 1=:CURRPAGE
043050          OD; *IFILL
043063
043063   *PL003=*
043063
043063   % FIND LAST 32K MEMORY MODULE
043063   INTEGER CCTBSET(0); *BSET ONE DT
043064   LABL1: FOR X:=0 TO 17 DO; 0=:TMMAP(X); OD
043073          A:=0=:LPHYSPAGE
043075   DO1:   DO WHILE A<<=ENDPAGE
043100             CALL PHYSPTEST; GO NOTEXIST; A=:CURRPAGE
043103             IF A/\77=0 THEN
043105                CURRPAGE SHZ -6; AD SHZ -4; A=:X    % X=INDEX IN BIT-MAP ARRAY TMMAP
043111                AD SH 4; A/\17 SHZ 3 +CCTBSET
043115                T:=TMMAP(X); *EXR SA
043117                T=:TMMAP(X)
043120             FI; CURRPAGE+37=:LPHYSPAGE; A+1
043124          OD; GO L1
043126   NOTEXIST: A+40; GO DO1
043130   *)FILL
043135
043135   L1:    LPHYSPAGE=:ENDPAGE
043137          A:="ERTBS"-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
043145          A=:NNRTP                        % NUMBER OF RT-DESCRIPTIONS
043146          A*5XRTDSIZE+"SRTDL"=:ERTDLGADDR % END OF REG-BLOCKS AND REE-BITMAPS
043151          IF C THEN CALL ERRFATAL FI
043154          IF A>>=60000 THEN CALL ERRFATAL FI        % OVERLAP WITH GLOBAL DATA
043160          GO CHHDLC; *)FILL
043170
043170   % CHECK ALL GENERATED HDLC'S
043170   INTEGER CLGTADDR=?,CSVXX=?
043170   CHHDLC:
043170          "0HDTA"=:CSVXX                            % START OF HDLC CONFIG. TABLE
043172   HDLOOP:
043172          IF X:=CSVXX>>="0HDEN" GO FAR FINCHDLC
043176          *1BANK
043177          IF X.NHDLC=0 AND X.SYNHDLC=0 GO FAR NXHDLC % DATAFIELDS DOES NOT EXIST
043204          A=:D:=X.LOGHDLC=:T SHZ -6=:X
043211          A:=T/\77 SH 1; *2BANK
043215          A+CCNVRT(X)+1=:CLGTADDR; *1BANK     % ACTUAL ADDR IN LOG.DEV.NO TABLE
043221          IF CSVXX.HDLCSELECTION=0 GO CLHDLC  % HDLC CANNOT BE USED
043224          IF A>>2 GO CLHDLC                   % ILLEGAL SELECTION
043227          A:=200; *TRR IIE; TRA IIC; 2BANK
043233          T:=D.HDEV+RRTS; *EXR ST; TRA IIC; 1BANK
043241          IF A=0 THEN                         % INTERFACE IS PRESENT
043242             IF CSVXX.HDLCSELECTION=1 THEN    % NORMAL HDLC
043247                IF X.NHDLC=0 GO CLHDLC        % DATAFIELD FOR HDLC DOES NOT EXIST
043251                D:=0; X:=CLGTADDR             % UPDATE LOG.NO TABLE
043253                *POF; STD ,X; PON             % LOGNO.IN=INDF; LOGNO.OUT=0
043256                A:=CSVXX.NOHDLC=:D:=0; X:=CLGTADDR
043263                *POF; STD 2,X; PON            % LOGNO+1.IN=0; LOGNO+1.OUT=OUTDF
043266                A:=CSVXX.NHDLC; T:=X.SYNHDLC
043271                D:=0 BONE BISYMOD
043273             ELSE                             % HDLC SYNC
043274                IF X.SYNHDLC=0 GO CLHDLC      % ILLEGAL SELECTION
043276                X.DSYNHDLC; X:=CLGTADDR
043300                *POF; STD ,X                  % LOGNO.IN=INDF; LOGNO.OUT=OUTDF
043302                *STZ 2,X; STZ 3,X; PON        % LOGNO+1.IN=0; LOGNO+1.OUT=0
043305                A:=CSVXX.SYNHDLC; T:=X.NHDLC
043310                D:=0 BONE BIHDLC
043312             FI; T=:X.CDF1CLTIMER             % T=DF TO REMOVE FROM TIMER
043313             A=:X.INTHDLC                     % VALUE TO INSERT IN IDENT TABLE
043314             X.LOGHDLC\/D=:D+1=:L
043321             X:="IOBUTAB"; *POF
043323             DO WHILE X<<"EIOBUTAB"           % CLEAR ENTRIES IN IOBUTAB
043326                IF X.S0/\77777=D OR A=L THEN 0=:X.S0 FI
043335                X+2
043336             OD; *PON
043340          ELSE                                % DON'T USE THIS HDLC
043341             GO CLHDLC; *)FILL
043353             INTEGER CLGTADDR,CSVXX
043355   CLHDLC:   A:=0; D:=0; X:=CLGTADDR
043360             *POF; STD ,X; STD 2,X            % CLEAR ENTRIES IN LOG.UNIT TABLE
043363             CSVXX.LOGHDLC=:D+1=:L
043370             0=:X.HDLCSELECTION
043371             X:="IOBUTAB"
043372             DO WHILE X<<"EIOBUTAB"
043375                IF X.S0/\7777=D OR A=L THEN
043403                   0=:X.S0                    % REMOVE FROM IOBUTAB
043404                FI; X+2
043405             OD; *PON
043407             0=:CSVXX.INTHDLC                 % A=VALUE TO INSERT IN IDENT TABLE
043411             X.NHDLC=:X.CDF1CLTIMER
043413             X.SYNHDLC=:X.CDF2CLTIMER
043415          FI
043415   NXHDLC: CSVXX+TBLHDLCSIZE=:CSVXX
043420          GO FAR HDLOOP
043421   FINCHDLC: *2BANK
043422          GO CHLPS; *)FILL
043427
043427   *PL004=*
043427
043427   INTEGER CSVXY
043430   CHLPS: "0LPTA"=:CSVXY; *1BANK
043433          DO WHILE CSVXY.LPSELECTION><-1                      % -1: END OF TABLE
043440             IF A=0 OR A>>3 THEN
043444                1=:X.LPCLENTRY; GO NXLPENTRY                  % ILLEGAL SELECTION (OR DON'T USE THIS L-P)
043447             FI; A-1+"LPIODF"; X+A
043452             IF X.LPIODF=0 OR X.XLPDMDF=0 THEN                % DATAFIELD(S) NOT GENERATED
043456                1=:CSVXY.LPCLENTRY; GO NXLPENTRY
043462             FI; *2BANK
043463             T:=A.HDEV+2; A:=200; *TRR IIE; TRA IIC; 1BANK
043472             IF CSVXY.LPSELECTION-2=0 THEN
043476                *EXR ST
043477             ELSE
043500                *IOXT
043501             FI; *TRA IIC
043502             IF A><0 THEN 1=:X.LPCLENTRY FI                   % INTERFACE NOT PRESENT
043505   NXLPENTRY:
043505             IF CSVXY.LPSELECTION><3 OR X.LPCLENTRY><0 THEN
043514                X.LPLOGNO=:D; X:="IOBUTAB"
043517                DO WHILE X<<"EIOBUTAB"
043522                   IF X.S0/\7777=D THEN 0=:X.S0 FI            % REMOVE FROM IOBUTAB
043527                   X+2
043530                OD
043531             FI; CSVXY+LPTBSIZE=:CSVXY
043534          OD; *2BANK
043536          GO TSYMODEM; *)FILL
043545
043545   TSYMODEM:
043545          0=:0CINX; 0=:NPAGES                       % NPAGES=NUMBER OF SYNC.MODEM TO USE
043547          DO
043547             0CINX*TBLSYMSIZE+"0SYMTABLE"=:CSAVX=:X; *1BANK
043555          WHILE X.SYMSELECTION><-1
043561             IF A><0 AND X:=X.SYMIDFELT><0 THEN
043564                A:=200; *TRR IIE; TRA IIC; 2BANK
043570                T:=X.HDEV; *EXR ST; TRA IIC
043573                IF A=0 THEN                         % INTERFACE PRESENT
043574                   MIN NPAGES; X:=CSAVX; *1BANK
043577                   0=:X.SYMCLENTRY; GO NXSYMODEM
043601                FI
043601             FI; *2BANK
043602             X:=CSAVX; *1BANK
043604             X.SYMLOGNO=:D                          % D=LOGICAL DEVICE NUMBER
043606             X:="IOBUTAB"
043607             DO WHILE X<<"EIOBUTAB"
043612                IF X.S0/\7777=D THEN 0=:X.S0 FI     % CLEAR ENTRY IN IOBUTAB
043617                X+2
043620             OD
043621   NXSYMODEM:*2BANK
043622             MIN 0CINX
043623          OD; *2BANK
043625          GO LABL2; *)FILL
043634   *PL005=*
043634
043634   % FIND THE I/O BUFFER AREA
043634   % THE I/O BUFFER AREA WILL BE MAPPED IN RPIT AND MPIT.
043634   LABL2: IF FSDRP(2)>>FSDMP(X) THEN A=:ASCBUF ELSE T=:ASCBUF FI
043644          A:=ASCBUF+1777 SHZ -12 SH 12=:ASCBUF=:CBUF
043652          0=:0CINX; X:=XIOBUTAB
043654          DO
043654             *POF; LDD ,X; PON
043657          WHILE A><-1
043662             IF A><0 AND A><276 THEN                   % SKIP ERROR DEV NO 276
043666                IF A NBIT BIHDLC AND A NBIT BISYMOD THEN
043672                   A:=D/\77777+CBUF
043675                   IF C THEN CALL ERRFATAL FI          % BUFFER AREA CROSS MEMORY BANK
043700                   A=:CBUF
043701                ELSE
043702                   IF A BIT BIHDLC AND A:=D/\77777>=2000 THEN
043711                      *POF; LDD ,X; PON
043714                      T:=0CINX; X:=:T; AD=:ZHDLCSIZE(X)
043717                      X+2=:0CINX:=T
043722                   FI
043722                FI
043722             FI; X+2
043723          OD; A:=-1=:D; AD=:ZHDLCSIZE(0CINX); GO IOBOK; *)FILL
043741
043741   % SET UP THE I/O BUFFERS
043741   IOBOK: A:=CBUF-ASCBUF- SHZ -12 SH 12=:ASCBUF
043747          ASCBUF=:CBUF; XIOBUTAB=:"CINDADDR"
043753          DO
043753             X:="CINDADDR"; *POF; LDD ,X; PON
043757          WHILE A><-1
043762             IF A><0 THEN
043763                AD=:CIOBENTRY
043764                IF A NBIT BIHDLC AND A NBIT BISYMOD THEN
043770                   A/\7777;
043771                   IF A=276 THEN                        % SPECIAL FOR ERS INT.DEV.
043774                      CALL FAR XLOGPH; AD:=CIOBENTRY
043776                   ELSE
043777                      CALL FAR XLOGPH
044000                      CBUF=:X.BUFST; AD:=CIOBENTRY
044003                      A:=D BZERO 17+CBUF=:CBUF
044007                   FI
044007                   IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
044015                   A=:X.MAX=:X.CFREE
044017                FI
044017             FI; "CINDADDR"+2=:"CINDADDR"
044022          OD
044023
044023   % FIND BUFFER FOR SYNC.MODEM AND HDLC
044023          0=:CHDLCF=:BUSYMOD
044025          X:=XIOBUTAB
044026          DO
044026             *POF; LDD ,X; PON
044031          WHILE A><-1
044034             IF A BIT BIHDLC THEN
044036                IF A:=D/\77777<<2000 THEN
044043                   A+CHDLCF=:CHDLCF
044045                   IF C THEN CALL ERRFATAL FI       % BUFFER EXCEED MEMORY BANK
044050                FI; GO NXT
044051             FI
044051             IF A BIT BISYMOD THEN
044053                A:=D/\77777+BUSYMOD=:BUSYMOD
044057                IF C THEN CALL ERRFATAL FI          % BUFFER EXCEED MEMORY BANK
044062             FI
044062   NXT:      X+2
044063          OD
044064   % SET UP BUFFER FOR ERROR-DEVICE (LOG.DEV. 500B)
044064          "99EBU"=:"IERRF".BUFST
044067          IF 2000 < X.MAX THEN
044073             A=:X.MAX=:X.CFREE
044075          FI
044075   % COMPUTE MEMORY ADDRESS LIMITS IN PHYSICAL PAGES
044075          A:=FSDCC(2) SHZ -12=:CMLPHPAGE       % END OF COMMON CODE
044101          0=:CMFPHPAGE                         % START OF COMMON CODE
044102          "PITST" SHZ -12=:RSFPHPAGE           % START OF RESTART ROUTINES & REG.BLOCKS
044105          A:=ERTDLGADDR SHZ -12=:RSLPHPAGE     % END OF START ROUTINES & REG.BLOCKS
044110          DPITBANK SHZ 6+2=:DPIFPHPAGE         % START OF DPIT
044114          A:=FSDDP(2)-"DPSTA"; CALL FPGNO
044120          A+DPIFPHPAGE=:DPILPHPAGE             % END OF DPIT
044122          A:="9ERST"+1777 SHZ -12=:CFPHYSPAGE  % FIRST PHYS.PAGE AVAILABLE FOR BUFFERS
044126          GO OVFI1; *)FILL
044146
044146   *PL006=*
044146
044146   % CHECK IF THE PIOC INTERFACES ARE PRESENT OR NOT
044146   % IF NOT PRESENT THE ENTRY IN THEN LOG.NO TABLE IS CLEARED
044146   % IF PRESENT THEN THE SIZE OF THE PIOC IS UPDATED IN TH ELOCATION PIMPG IN
044146   %      THE DATAFIELD
044146   OVFI1:
044146          0=:CSAVX; A:=200; *TRR IIE; TRA IIC        % ENABLE FOR IOX-ERROR AND CLEAR
044152          DO
044152             AD:=PIOCS(CSAVX)
044154          WHILE A><-1
044157             IF A><0 THEN
044160                AD=:XAD
044161                T:=A.HDEV; T+2; *IOXT                  % READ STATUS
044165                A=:D; *TRA IIC                         % D=STATUS REGISTER
044167                IF A><0 THEN                           % INTERFACE PRESENT?
044170                   A:=XD/\77=:T; A:=XD SHZ -6=:X       % NO, CLEAR TABLE ENTRIES
044176                   X:=CCNVRT(X)+T+T+1
044201                   *POF; LDD ,X; PON                   % FETCH ENTRY IN LOG.NO TABLE
044204                   IF A=XA AND D=T THEN                % MATCH FOUND
044211                      *POF; STZ ,X; STZ 1,X; PON       % CLEAR ENTRY IN LOG.NO. TABLE
044215                   FI
044215                ELSE                                   % INTERFACE IS PRESENT
044216                   IF D BIT 6 THEN                     % 64K PIOC OR "OLD" PIOC
044220                      A:=D SHZ -10 SHZ 6=:D            % D=PHYS PAGE NO OF START OF PIOC MEMORY
044224                      A:=77=:XA.PIMPG
044227                   ELSE
044230                      IF D BIT 10 THEN CALL ERRFATAL FI % ODD BANK NUMBER; NOT LEGAL IN SINTRAN
044233                      A:=D SHZ -10/\375 SHZ 6=:D       % D=FIRST PHYS PAGE
044240                      A:=377=:XA.PIMPG                 % 256K PIOC
044243                   FI; A+D; A:=:D                      % A=FIRST PHYS PAGE; D=LAST PHYS PAGE
044245                   X:=CSAVX; *1BANK; STD I ,X (MMPIO; 2BANK  % SAVE PIOC RESERVED MEMORY
044251                FI
044251             FI; CSAVX+2=:CSAVX
044254          OD; GO XOVF1; *)FILL
044265
044265   XOVF1:
044265   % SET UP RT-COMMON TABLE
044265          IF CCNOX><0 THEN                % NUMBER OF PAGES IN RT-COMMON
044267             IF ACCTAB(0)=0 THEN          % NO ENTRIES IN CCTAB
044272                IF CCSTART=0 THEN         % FIRST PHYS.PAGE OF RT-COMMON NOT SPECIFIED
044274                   LPHYSPAGE; X:=CCNOX; T:=0        % ALLOCATE RT-COMMON FROM TOP OF PHYS.MEM
044277                   CALL YGETAREA; CALL ERRFATAL
044301                   A-CCNOX+1=:CCSTART     % FIRST PHYS.PAGE OF RT-COMMON
044304                FI; A=:D
044305                200-CCNOX+161000; T:=CCNOX; X:=0    % COMPUTE FIRST LOG.PAGE OF RT-COMMON
044312                DO WHILE T><0
044314                   AD=:DCCTAB(X); A+1; D+1; X+2; T-1 % FILL IN LOG.PAGE AND PHYS.PAGE
044321                OD; -1=:ACCTAB(X)                   % -1 IS END OF TABLE
044324             FI
044324          ELSE
044325             IF ACCTAB(0)=0 THEN -1=:ACCTAB(X) FI
044332          FI; GO L2; *)FILL
044341   % TEST IF RT-COMMON PAGES EXIST AND INITIALIZE THE RT-COMMON PAGES
044341   L2:    X:=0
044342        DO WHILE ACCTAB(X)><-1
044346           X+1; ACCTAB(X); CALL PHYSPTEST; CALL ERRFATAL
044352           CALL INITPAGE; X+1
044354        OD
044355
044355   *PL007=*
044355
044355   *"8STRD -8DIMI
"044355        GO FILL1; *)FILL
044361
044361   *PL008=*
044361
044361   % LOCAL SUBROUTINE TO READ FROM DISC / WRITE TO DISC
044361   %
044361   % ENTRY:     A= DISCADDR IN PAGES
044361   %            X= NUMBER OF PAGES
044361   %            T= READ/WRITE FLAG
044361   %            CDDMADDR=MEMORY ADDRESS
044361   %
044361   INTEGER POINTER CTRNSF=?
044361   INTEGER LOOPC=?
044361   CRDISC:
044361          IF A><0 THEN A*CDABLPAGE+XXSWTYPE FI
044364          A=:CDFBLCK
044365          A:=L=:"CLINK"
044367          A:=-6=:LOOPC
044371          A:=DSKTYPE; T+A =: CDTBLCK
044374          A:= X*CDABLPAGE =: CDNBLCK
044377   RTRY:  CDDMADDR=:CSWPDF.CMADR=:X.MEMAD
044403          A := CDFBLCK =: D :=0
044406          T := CDTBLCK  ; X =: L
044410          X := CDNBLCK  ; L =: B
044412   CRLOOP: CALL CTRNSF; GO GVTRY ; GO CRLOOP
044415          "SBFIELD"=:B
044417          *TRR 10
044420          GO CLINK
044421   GVTRY: "SBFIELD" =: B
044423          MIN LOOPC ; GO RTRY ; CALL ERRFATAL
044426
044426   INTEGER LOOPC             % COUNTER USED WHEN ERROR FROM THE DRIVER
044427
044427   % LOCAL SUBROUTINE TO COPY FROM THE SAVE-AREA TO IMAGE/SEGMENTS
044427   % ENTRY: T=DISC ADDR, IN PAGES, READ FROM
044427   %        X=NUMBER OF PAGES TO MOVE
044427   %        A=DISC ADDR, IN PAGES, TO WRITE TO
044427   %        CDDMADDR=MEMORY ADDRESS
044427   %        CDABLPAGE=NUMBER OF SECTORS PER TRACK
044427   %
044427   % EXIT: OK
044427   % CALL ERRFATAL IF ERROR OCCURS.
044427   %
044427   CRWDISC: A*CDABLPAGE+XXSWTYPE=:CDTBLCK
044432          A:=T*CDABLPAGE+XXSWTYPE=:CDFBLCK
044436          A:=X*CDABLPAGE=:CDNBLCK
044441          A:=L=:"CLINK"
044443          A:=-6=:LOOPC
044445   TRYR:  CDDMADR=:CSWPDF.MEMAD=:X.CMADR
044451          X:=CDNBLCK; A:=CDFBLCK=:D:=CSWPDF
044455          T:=DSKTYPE; A=:B:=0
044460   RLOOP: CALL CTRNSF; GO RDISK ; GO RLOOP
044463          A:=-6=:LOOPC
044465   TRYW:  "SBFIELD".CDDMADR=:MEMAD=:CMADR
044471          T:=DSKTYPE BONE "0"
044473          A:=X.CDTBLCK=:D:=0; X:=X.CDNBLCK
044477   WLOOP: CALL CTRNSF; GO WDISK ; GO WLOOP
044502          "SBFIELD"=:B
044504          *TRR 10
044505          GO CLINK
044506   RDISK: "SBFIELD" =: B
044510          MIN LOOPC ; GO TRYR ; CALL ERRFATAL
044513   WDISK: MIN LOOPC ; GO TRYW ; CALL ERRFATAL
044516   *)FILL
044523   INTEGER LDTA                       % ADDRESS IN DISK DESCRIPTION TABLE
044524   INTEGER POINTER CTRNSF
044525
044525   *PL009=*
044525
044525   FILL1:
044525
044525   % FIND SWAP-DEVICE
044525          IF SWTYP<<7 OR>>36 THEN CALL ERRFATAL FI  % ILLEGAL MAIN-SWAP-DEVICE TYPE
044535          IF A=7 THEN                               % MAIN SWAP-DEVICE IS FIXED PHOENIX DISK
044540             20=:SWTYP; 40000=:DSKTYPE; 100000=:XXSWTYPE
044546          ELSE
044547             0=:XXSWTYPE=:DSKTYPE
044551          FI;                          *1BANK
044552          X:= MDISCS(SWTYPE)=:LDTA                 % ADDR OF DISC-ATTRIBUTES
044555          X.SWDLOGNO;                  *2BANK
044557          CALL FAR CLOGPH; A:=X;       *1BANK
044562          T:=LDTA.SWDDFILD;            *2BANK
044565          IF A=0 OR A >< T THEN CALL ERRFATAL FI % ILLEGAL LOGICAL DEV.NO.
044571          A=:CSWPDF=:X
044573          IF XXSWTYPE><0 THEN
044575             X.M2UNTYPE BONE "0"=:X.M2UNTYPE           % MARK FIXED PHOENIX
044600          FI; *1BANK
044601          LDTA.SWDDRIVER=:"CTRNSF"                     % DISC-DRIVER ADDR
044604          A:=X.SWDSWDRIV; *2BANK
044606          A=:SWPDRIVER;   *1BANK                       % ADDR OF SWAP-DRIVER
044610          A:=X.SWDLOGNO;  *2BANK
044612          A=:MASSNO(0)                                 % LOGICAL DEV.NO. OF MAIN-SWAP-DEVICE
044614
044614          X:=DISPE(SWTYP); T:=X.S0; A:=2000=:D:=0; *RDIV ST   % SECTORS/TRACK
044623          IF D><0 THEN CALL ERRFATAL FI
044626          A=:ABLPAGE(0)=:CDABLPAGE
044631          A*200+XXSWTYPE=:BLST(1)                   % SET START OF SEGFIL0 IN SECTORS.
044635          CSWPDF=:B
044637          DISPE(SWTYP)=:HTABL(0)                    % INITIAL DISC-LAYOUT TABLE
044643          MASSNO(0)=:MASSNO(4)                      % INITIALIZE "SEGMENT FILE" #4.
044647          MASSUNIT(0)=:MASSUNIT(4)
044653          ABLPAGE(0)=:ABLPAGE(4)+"SBFIELD".XXSWTYPE=:BLST(11) % SIZF IS PREDEFINED (177)
044663
044663   % FIND SWAP-DEVICE DISC LAYOUT
044663
044663          IF "CTRNSF"="BDISK" OR ="SCSWD" THEN
044672             T:=42; X:=1; A:=0=:D         % READ FORMAT NECESSARY
044676   DIBUS:    CALL CTRNSF; CALL ERRFATAL; GO DIBUS
044701          FI
044701          X:=HTABL(0); "SBFIELD"=:B
044705          X=:CDIFELEMENT                  % DISC LAYOUT ELEMENT ADDRESS
044706          GO FILL2; *)FILL
044730   *PL010=*
044730
044730   FILL2:
044730   % FIND MEMORY AREA TO USE IN DISC TRANSFERS
044730          IF HENTFLAG=0 THEN X:=70 ELSE X:=1 FI
044735          A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
044741          A=:D:=0; AD SH 12=:CDDMADR                % MEMORY ADDR FOR DISC TRANSFERS
044745          SEGFSTART=:CBLST                          % START OF SEGFILE 0
044747   *IFILL
044754          IF HENTFLAG><0 GO FAR OVCO
044757   % COPY FROM SAVE TO IMAGE
044757             X:=CBLST; T:="MSECO"+X; A:="MIECO"+X
044764             X:="LSECO"; CALL FAR CRWDISC           % COPY EXT. COMMON
044766             X:=CBLST; T:="MSDPT"+X; A:="MIDPT"+X
044773             X:="LSDPT"; CALL FAR CRWDISC           % COPY DPIT
044775             X:=CBLST; T:="MSRPT"+X; A:="MIRPT"+X
045002             X:="LSRPT"; CALL FAR CRWDISC           % COPY RPIT
045004             X:=CBLST; T:="MSMPT"+X; A:="MIMPT"+X
045011             X:="LSMPT"; CALL FAR CRWDISC           % COPY MPIT
045013             X:=CBLST; T:="MSIPT"+X; A:="MIIPT"+X
045020             X:="LSIPT"; CALL FAR CRWDISC           % COPY IPIT
045022             X:=CBLST; T:="MSSGT"+X; A:="MISGT"+X
045027             X:="LSSGT"; CALL FAR CRWDISC           % COPY SEGMENT TABLE
045031             X:=CBLST; T:="MFILS"+X; A:="MIFIL"+X
045036             X:="LFILS"; CALL FAR CRWDISC           % COPY FILE SYSTEM
045040             X:=CBLST; T:="MRTLO"; A:="S04MA"+X
045044             X:=20; CALL FAR CRWDISC                % COPY RT-LOADER PROGRAM SEGMENT
045046   *IFILL
045101             X:=CBLST; T:="MRTLO"+20; A:="S37MA"+X
045106             X:=16; CALL FAR CRWDISC                % COPY RT-LOADER DATA SEGMENT
045110             X:=CBLST; T:="MERRP"; A:="S14MA"+X
045114             X:="LERRP"; CALL FAR CRWDISC           % COPY ERROR PROGRAM
045116             X:=CBLST; T:="MSCOM"+X; A:="S41MA"+X
045123             X:=1; CALL FAR CRWDISC                 % COPY "EDIT-ROUTINE" SEGMENT
045125             X:=CBLST; T:="MSCOM"+1+X; A:="MICOM"+X
045133             X:="LOPCO"-1; CALL FAR CRWDISC         % COPY COMMAND SEGMENT
045136             X:=CBLST; T:="MSSMS"+X; A:="MISMS"+X
045143             X:="LSSMS"; CALL FAR CRWDISC           % COPY SM SEGMENT
045145             X:=CBLST; T:="MSSYS"+X; A:="S05MA"+X
045152             X:="5ESSZ"; CALL FAR CRWDISC           % COPY SEGMENT 5 (INCLUDING RT'S SYS.SEGM)
045154             X:=CBLST; T:="MSSYS"+X; A:="MISYS"+X
045161             X:="LSSYS"; CALL FAR CRWDISC           % COPY FIRST PART OF SYSTEM SEGMENT
045163   *IFILL
045206             X:=CBLST; T:="MS5PT"+X; A:="MI5PT"+X
045213             X:="LS5PT"; CALL FAR CRWDISC           % COPY 5PIT SEGMENT
045215             X:=CBLST; T:="MSXMK"+X; A:="MIXMK"+X
045222             X:="LSXMK"; CALL FAR CRWDISC           % COPY XMSG KERNEL
045224             X:=CBLST; T:="MSXRO"+X; A:="MIXRO"+X
045231             X:="LSXRO"; CALL FAR CRWDISC           % COPY XMSG XROUT
045233             X:=CBLST; T:="MSNMT"+X; A:="MINMT"+X
045240             X:="LSNMT"; CALL FAR CRWDISC           % COPY DEVICE NAME TABLE
045242             X:=CBLST; T:="MSFID"+X; A:="MIFID"+X
045247             X:="LSFID"; CALL FAR CRWDISC           % COPY XMSG WATCHDOG (XMFIDO)
045251             X:=CBLST; T:="MSNKS"+X; A:="MINKS"+X
045256             X:="LSNKS"; CALL FAR CRWDISC           % COPY NK-SERV
045260             X:=CBLST; T:="MSNKN"+X; A:="MINKN"+X
045265             X:="LSNKN"; CALL FAR CRWDISC           % COPY NK-NAME
045267             X:=CBLST; T:="MSERC"+X; A:="MIERC"+X
045274             X:="LSERC"; CALL FAR CRWDISC           % COPY ERSWD CODE
045276             X:=CBLST; T:="MSERD"+X; A:="MIERD"+X
045303             X:="LSERD"; CALL FAR CRWDISC           % COPY ERSWD DATA
045305   *IFILL
045342             X:=CBLST; T:="MSUC1"+X; A:="MIUC1"+X
045347             X:="LSUC1"; CALL FAR CRWDISC           % COPY 110 MICRO CODE
045351             X:=CBLST; T:="MSUC2"+X; A:="MIUC2"+X
045356             X:="LSUC2"; CALL FAR CRWDISC           % COPY 120 MICRO CODE
045360             X:=CBLST; T:="MSPRM"+X; A:="MIPRM"+X
045365             X:="LSPRM"; CALL FAR CRWDISC           % COPY PROCESSOR MANAGER SERVER
045367             X:=CBLST; T:="MSEMG"+X; A:="MIEMG"+X
045374             X:="LSEMG"; CALL FAR CRWDISC           % COPY EVENT MESSAGE SERVER
045376             X:=CBLST; T:="MSBOP"+X; A:="MIBOP"+X
045403             X:="LSBOP"; CALL FAR CRWDISC           % COPY BOPCOM SERVER
045405             X:=CBLST; T:="MSMTS"+X; A:="MIMTS"+X
045412             X:="LSMTS"; CALL FAR CRWDISC           % COPY MTSERV
045414             X:=CBLST; T:="MSDMW"+X; A:="MIDMW"+X
045421             X:="LDDMW"; CALL FAR CRWDISC           % COPY DIMWD
045423   *PL011=*
045423   *"8N500
"045423             X:=CBLST; T:="MN5MO"+X; A:="MI5MO"+X
045430             X:="LN5MO"; CALL FAR CRWDISC           % COPY ND-500 SYSTEM MONITOR
045432   *"
"045432   OVCO:
045432   *IFILL
045464   % SET UP DISC LAYOUT TABLE FOR THE "SWAP-DRIVER"
045464          CDIFELEMENT=:D; 11=:L; "DFELT"+"DED01"=:T; *MOVAN
045474          "DFELT"+"HTABL"=:X; A:="DFELT"+"DED01";
045501          *1BANK; STA ,X; 2BANK                         % ADDR OF DISC-LAYOUT TABLE
045504   %INITIALIZE THE DATAFIELD FOR THE "SWAP-DRIVER"
045504          CDABLPAGE*77; *1BANK; STA I (NOBLK; 2BANK
045511          CSWPDF.HDEV; *1BANK; STA I (KLHDE; 2BANK
045516          A+"IOX+4"; *1BANK; STA I (KLIOX; 2BANK
045522          DBLST(0); *1BANK; STD I (DYBLS; 2BANK
045527          DSKTYP; *1BANK; STA I (XSWTP; 2BANK
045533          A:=-4; *1BANK; STA I (KLRC1; 2BANK
045537          SWPDRIVER; *1BANK; STA I (LDRAD; 2BANK
045543          A+SWDSIZE; *1BANK; STA I (ADR2B; 2BANK
045547          IF SWPDRIVER="ZBDIS" THEN A:=1               % SYSTEM DISC IS A "BIG-DISC"
045554          ELSE IF A="ZWDIS" THEN A:=2                  % SYSTEM DISC IS A "WINCHESTER" DISC
045561          ELSE IF A="SCSWD" THEN
045565             CSWPDF.BLSZ; *1BANK; STA I (KBLSZ
045571             *STZ I (KLIOX; 2BANK
045573             A:=3
045574          ELSE A:=0
045576          FI; FI; FI; *1BANK; STA I (YSWTY; 2BANK
045601
045601   % READ PAGE #0 AND INSERT BOOTS-STRAP AND "SWAP-DRIVER", AND
045601   % THEN WRITE THE PAGE BACK
045601          A:=0; X:=1; T:=0; CALL FAR CRDISC
045605   % MOVE BOOTS-STRAP INTO "PAGE #0"
045605          A:="LDEND"-"RELOA"=:L; A:="RELOA"=:D
045612          X:=1CDDMADR; T:=2CDDMADR; *MOVNP
045615   % MOVE SWAP-DRIVER TO "PAGE #0"
045615          SWDSIZE=:L; A:=SWPDRIVER=:D; *MOVNP
045622   % WRITE PAGE #0 BACK TO DISC
045622          A:=0; X:=1; T:=1; CALL FAR CRDISC
045626          GO OVFI3; *)FILL
045657   *PL012=*
045657   % COMPUTE SIZE OF MEMORY MAP, FIND CONTINUOUS MEMORY FOR THE MEMORY MAP
045657   % AND SET UP MEMORY MAP FOR ALL PAGES (0 - LPHYSPAGE)
045657   % THE PHYSICAL PAGE NUMBER IS INDEX IN THE MEMORY MAP
045657   INTEGER CCCPG
045660   OVFI3:
045660          IF LPHYSPAGE><37777 THEN A SH 2; CALL FPGNO; A+D ELSE A:=100 FI
045671          A=:MMSIZE; 100=:CCCPG
045674          DO WHILE CCCPG<<LPHYSPAGE
045700             X:=MMSIZE; T:=A+X-1
045704             CALL GETAREA; GO TRNX1; GO MMFOUND
045707   TRNX1:    CCCPG+100=:CCCPG
045712          OD; CALL ERRFATAL; *)FILL                 % NO MEMORY FOUND FOR MEMORY MAP
045720   MMFOUND:
045720          A=:MMFPAGE+MMSIZE-1=:MMLPAGE
045724          A:=MMFPAGE=:D:=0; AD SH 12; A=:CORMBANK:=D=:CORMSTART
045733
045733   % COMPUTE SIZE OF THE LOGICAL NUMBER TABLES, AND RESERVE MEMORY
045733   % FOR THESE TABLES
045733          A:="EN999"-"DV000"; CALL FPGNO; A+D=:MMSIZE
045740          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
045745          A=:LGTFPHPAGE+MMSIZE-1=:LGTLPHPAGE
045751          A:=LGTFPHPAGE=:D:=0; AD SH 12; A=:LOGDBANK
045756          A:=D=:CNVRT(0); CCNVRT(2)-CCNVRT(0)+D=:CNVRT(2); X=:0CINX
045771          DO WHILE X><LGDGMAX
045774             X+1; IF CCNVRT(X) >< 0 THEN
045777               X=:D; A-CCNVRT(0CINX)+CNVRT(X)
046003               A=:CNVRT(D); X=:0CINX
046006             FI
046006          OD
046007   % MOVE THE LOGICAL NUMBER TABLES
046007          "DV000"=:D; X:=LOGDBANK; T:=LGTFPHPAGE SH 12
046014          DO WHILE MMSIZE><0
046016             A:=2000=:L; *MOVNP
046021             MMSIZE-1=:MMSIZE
046024          OD; GO OVFI4; *)FILL
046040
046040   OVFI4:
046040
046040   % COMPUTE SIZE OF EXT. COMMON AND ALLOCATE AREA
046040          FSDEC(2)-"PITST"; CALL FPGNO; A+D=:MMSIZE
046046          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046053          A=:ECOFPHPAGE+MMSIZE-1=:ECOLPHPAGE
046057
046057   % COMPUTE SIZE OF RPIT AND ALLOCATE AREA
046057          FSDRP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046065          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046072          A=:RPIFPHPAGE=:RPTPHPAGE+MMSIZE-1=:RPILPHPAGE
046077          RPIFPHPAGE SHZ -6=:RPIBANK
046102
046102   % COMPUTE SIZE OF MPIT
046102          FSDMP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046110          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046115          A=:MPIFPHPAGE=:MPTPHPAGE+MMSIZE-1=:MPILPHPAGE
046122          A:=MPIFPHPAGE SHZ -6=:MPIBANK
046125
046125   % COMPUTE SIZE OF IPIT
046125          FSDIP(2)-"PITEX"; CALL FPGNO; A+D=:MMSIZE
046133          X:=MMSIZE; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046140          A=:IPIFPHPAGE=:IPTPHPAGE+MMSIZE-1=:IPILPHPAGE
046145          A:=IPIFPHPAGE SHZ -6=:IPIBANK
046150
046150   % ALLOCATE MEMORY FOR SEGMENT 42
046150          A:=100; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
046155          A=:EDFPHPAGE=:EDLPHPAGE
046157
046157   % ALLOCATE MEMORY FOR THE I/O BUFFERS
046157          A:=ASCBUF SHZ -12; X:=100-A=:MMSIZE
046164          X:=MMSIZE; A:=CFPHYSPAGE; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046171          A=:IOBFPHPAGE+MMSIZE-1=:IOBLPHPAGE
046175
046175   % ALLOCATE MEMORY FOR RT'S SYSTEM SEGMENT
046175          A:=SISYSEG-"5ESSZ"=:MMSIZE=:X
046201          A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046205          A=:RTSGFPHPAGE+MMSIZE-1=:RTSGLPHPAGE
046211
046211   *"8FLMN
"046211
046211   *PL013=*
046211
046211   *"8N500
"046211          A:=100; T:=LPHYSPAGE; X:="LS5PT"; CALL GETAREA; CALL ERRFATAL
046216          A=:5PIFPHPAGE+"LS5PT"-1=:5PILPHPAGE
046222   *"
"046222          GO OVFI5; *)FILL
046242   OVFI5:
046242   % COMPUTE THE NUMBER OF DEVICE-BUFFERS TO USE IN THIS SYSTEM
046242          A:=ENDBU-"DEVBU"=:D:=0; T:=DBLEN; *RDIV ST
046250          IF A<<MXDVBUFS THEN A=:MXDVBUFS FI
046254          MXDVBUFS*DBLEN+"DEVBU"=:ENDBU             % UPDATE END OF DEVICE-BUFFER HEADERS
046260   % FIND CONTIGUOUS AREA FOR THE DEVICE-BUFFERS
046260   % AND INITIALIZE THESE PAGES
046260          A:=DVBFPAGE; X:=MXDVBUFS; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046265          A=:DBFPAGE/\77 SH 12=:BUFASTART=:SBUF     % START ADDRESS OF BUFFER AREA WITHIN BUFBANK
046272          A:=DBFPAGE SHZ -6=:BUFBANK=:SBANK         % MEMORY BANK IN WHICH THE BUFFERS LIE
046276          DBFPAGE+MXDVBUFS-1=:DBLPAGE
046302          FOR A:=DBFPAGE TO DBLPAGE DO CALL INITPAGE; OD
046311          GO INZSPRTAD; *)FILL
046327
046327   *PL014=*
046327
046327   INZSPRTAD:
046327
046327   % COMPUTE AND SET-UP THE ADDR OF "SPARE-TRACK-TRANSFER-BUFFER" IN THE DATAFIELD
046327   % FOR ALL "BIG-DISCS" AND WINCHESTER DISCS.
046327           IF DVBFPAGE><0 THEN
046331              T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL    % RESERVE 1 PAGE FOR "SPARE-TRACK-ADDR-BUFFER"
046335              A=:SPTRFPHPAGE=:SPTRLPHPAGE
046337              0=:0CINX
046340              FOR X:=0 TO 3 DO
046344                 IF BIGDDFS(X)><0 THEN                  % FOR ALL BIG-DISCS DO
046346                    X=:L:=A; A:=SPTRFPHPAGE=:D:=0; AD SH 12; A:=:D+0CINX
046356                    A:=:D; AD=:X.DNWLBB
046360                    0CINX+2=:0CINX; X:=L
046364                 FI
046364              OD
046366              FOR X:=0 TO 1 DO
046372                 IF WDIDFS(X)><0 THEN                   % FOR ALL WINCHESTER DISCS DO
046374                    X=:L:=A; A:=SPTRFPHPAGE=:D:=0; AD SH 12; A:=:D+0CINX
046404                    A:=:D; AD=:X.DWNLBA
046406                    0CINX+2=:0CINX; X:=L
046412                 FI
046412              OD
046414           ELSE                                         % "SPARE-TRACK-ADDR-BUFFER" IS IN DATAFIELD
046415              FOR X:=0 TO 3 DO                          % FOR ALL BIG-DISCS DO
046421                 IF BIGDDFS(X)><0 THEN
046423                    X=:L:=A; A+"NWLBB"-4=:D:=DPITBANK; AD=:X.DNWLBB
046432                    X:=L
046433                 FI
046433              OD
046435              FOR X:=0 TO 1 DO                          % FOR ALL WINCHESTER DISCS DO
046441                 IF WDIDFS(X)><0 THEN
046443                    X=:L:=A; A+"ALTPO"=:D:=DPITBANK; AD=:X.DWNLBA
046451                    X:=L
046452                 FI
046452              OD
046454           FI; GO INZMENT; *)FILL
046462
046462   *PL015=*
046462
046462   INZMENT:
046462
046462   % INITIALIZE THE VARIABLES FOR MON ENTSG.
046462
046462          0=:ESBANK                            % MEMORY BANK OF "ESARRAY"
046463          "ESARRAY"=:ESDATA                    % DISPLACEMENT WITHIN BANK OF ESDATA.
046465          "ESEARRAY"=:ESEDATA                  % DISPLACEMENT WITHIN BANK OF ESEDATA.
046467          0=:ESCNT                             % CLEAR NUMBER OF ENTERED SEGMENTS.
046470
046470   % RESERVE MEMORY FOR MICRO CODE
046470          IF UCLOAD >< 0 THEN
046472             A:=100; T:=LPHYSPAGE;X:="LSUC1"
046475             CALL 1BAREA; CALL ERRFATAL; AD=:UCPAG
046500          FI
046500
046500   % RESERVE MEMORY FOR THE LAMU SYSTEM AND CLEAR THE LAMU TABLES
046500   *IFILL
046513          IF GNLAMU><0 OR GNSYL >< 0 THEN
046517             GNSYL*SDTSZ=:CLAMSIZE             % SIZE OF LAMU DESCRIPTOR (SYLDT)
046522             GNLAMU*LDTSZ+CLAMSIZE=:CLAMSIZE   % ADD SIZE OF LAMU DESCRIPTOR (LAMDT)
046526             "NXRTP"*GNLPRT*ALMSZ              % SIZE OF ACTIVE LAMU TABLE (LAMACT)
046531             A+NINSZ                           % SIZE OF LAMU AREA MON 61 INDEX (LAMAI)
046532             A+"NXRTP"                         % SIZE OF LAMU INHIBIT TABLE
046533             A+CLAMSIZE; CALL FPGNO; A+D=:NPLAMU; IF A > 100 THEN CALL ERRFATAL FI
046543             A:=100; T:=LPHYSPAGE; X:=NPLAMU; CALL GETAREA; CALL ERRFATAL
046550             A=:D=:FLAMPAGE+NPLAMU-1=:LLAMPAGE:=0; AD SHZ 12
046557             A=:LAMBANK; A:=D=:SYLDT         % SYLDT  START
046562             GNSYL*SDTSZ+D=:LAMDT            % LAMDT  START
046566             A:=D+CLAMSIZE=:LAMACT=:D        % LAMACT START
046572             "NXRTP"*GNLPRT*ALMSZ+D=:LAMAI   % LAMAI  START
046577             A+NINSZ=:LAMIH                  % LAMIH  START
046601             A:=FLAMPAGE; T:=NPLAMU+A
046604             DO WHILE A><T; CALL ZEROPAGE; A+1; OD
046611             GO AFLAM; *)FILL
046633          FI
046633
046633   *PL016=*
046633
046633   AFLAM:
046633   *"8MCLG
"046633   % RESERVE MEMORY FOR THE MONITOR-CALL-LOG TABLE
046633          IF "MCLGPAGE"><0 THEN
046635             A:=0; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
046642             A=:MCLGPAGE=:CMCLFPHPAGE=:CMCLLPHPAGE
046645             A=:D:=0; AD SHZ 12; A=:MCLGBANK:=D=:TNMCALL
046653          FI
046653   *"
"046653   % RESERVE MEMORY FOR THE SYNC.MODEM BUFFERS.
046653
046653          IF BUSYMOD><0 THEN
046655             CALL FPGNO; A+D=:X=:SYMLPHPAGE
046661             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046665             A=:SYMFPHPAGE-1+SYMLPHPAGE=:SYMLPHPAGE
046671             A:=SYMFPHPAGE=:D:=0; AD SHZ 12; A=:MBSYMOD:=D=:CBUF
046700             XIOBUTAB=:"CINDADDR"
046702   % INITIALIZE THE SYNC.MODEM DATAFIELDS WITH
046702   % BUFFER START ADDR, MAX AND CFREE
046702             DO
046702                X:="CINDADDR"; *POF; LDD ,X; PON
046706             WHILE A><-1
046711                IF A BIT BISYMOD THEN
046713                   AD=:CIOBENTRY
046714                   A/\7777; CALL FAR XLOGPH
046716                   CBUF=:X.BUFST
046720                   AD:=CIOBENTRY
046721                   IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
046727                   A=:X.MAX=:X.CFREE
046731                   A:=D BZERO 17+CBUF=:CBUF
046735                FI; "CINDADDR"+2=:"CINDADDR"
046740             OD
046741          FI; GO BYPFILL; *)FILL
046753
046753   BYPFILL:
046753   *PL017=*
046753
046753   % RESERVE MEMORY FOR THE HDLC BUFFERS.
046753          IF CHDLCF><0 THEN
046755             CALL FPGNO; A+D=:X=:HDLCLPHPAGE
046761             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
046765             A=:HDLCFPHPAGE-1+HDLCLPHPAGE=:HDLCLPHPAGE
046771             A:=HDLCFPHPAGE=:D:=0; AD SHZ 12; A=:CHDLCF:=D=:CBUF
047000   % INITIALIZE THE HDLC DATAFIELDS
047000             XIOBUTAB=:"CINDADDR"
047002             DO
047002                X:="CINDADDR"; *POF; LDD ,X; PON
047006             WHILE A><-1
047011                IF A BIT BIHDLC THEN
047013                   AD=:CIOBENTRY
047014                   IF A:=D/\77777<<2000 THEN
047021                      A:=C1IOBENTRY/\7777; CALL FAR XLOGPH
047024                      CBUF=:X.BUFST
047026                      AD:=CIOBENTRY
047027                      IF A:=D NBIT 17 THEN A SH 1 ELSE A BZERO 17 FI
047035                      A=:X.MAX=:X.CFREE; CHDLCF=:X.MASTB
047041                      A:=D BZERO 17+CBUF=:CBUF
047045                   FI
047045                FI; "CINDADDR"+2=:"CINDADDR"
047050             OD; GO OVFILL; *)FILL
047061          FI
047061   OVFILL:
047061
047061   % COMPUTE SIZE OF THE SEGMENT TABLE, AND ALLOCATE MEMORY
047061   % FOR THE SEGMENT TABLE
047061           "9ESGT"-"XSEGS"; CALL FPGNO; A+D=:NPSGTAB
047066           X:=NPSGTAB; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
047073           A=:SGTFPHPAGE+NPSGTAB-1=:SGTLPHPAGE
047077           A:=SGTFPHPAGE=:D:=0; AD SH 12
047103           A=:SEGTBANK:=D=:SEGSTART+5SEGSIZE=:XSGRT
047110   % READ IN THE SEGMENT TABLE FROM IMAGE
047110          A:=SGTFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047115          A:="MISGT"+CBLST; X:=NPSGTAB; T:=0; CALL FAR CRDISC
047122          GO L3; *)FILL
047135
047135   *PL018=*
047135   % RESERVE MEMORY FOR ERROR DEVICE BUFFER (LOG.NO 276B)
047135   L3:    IF "ERSIN".MAX SHZ -1><0 THEN
047141             CALL FPGNO; A+D=:X=:IERLPHPAGE
047145             A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
047151             A=:IERFPHPAGE-1+IERLPHPAGE=:IERLPHPAGE
047155             A:=IERFPHPAGE=:D:=0; AD SHZ 12; A=:MBIERBUFF
047162             A:=D=:"ERSIN".BUFST
047165          FI
047165          0=:CURRPAGE; X:=CORMSTART
047167          FOR CURRPAGE DO WHILE CURRPAGE<<=LPHYSPAGE
047173             T:=CORMBANK; A:=X-4=:D+10; *PAGLI@3 STDTX
047201             A:=0; D:=0; *PROTE@3 STDTX
047204             X+4
047205          OD; X-4=:ECORMAP; T:=CORMBANK; *PAGLI@3 STZTX
047213          X:=CORMSTART+4; A:=7; *PREVI@3 STATX
047217          A:=X; X:=XSGRT; T:=SEGTBANK; *BPAGL@3 STATX
047223          X:=CORMSTART; T:=CORMBANK; A:=0 BONE 5CMINHB
047227          *PROTE@3 STATX; PAGLI@3 STZTX
047231          GO OVFI6; *)FILL
047244   OVFI6:
047244   % INITIALISE THE SEGMENT LINK
047244          T:=SEGTBANK; X:=XSGRT=:A
047247          *SEGLI@3 STATX; PRESE@3 STATX
047251          X=:BSEGLINK
047252
047252   % READ IN THE EXT. COMMON
047252          A:=ECOFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047257          A:=ECOLPHPAGE-ECOFPHPAGE+1=:X; A:="MIECO"+CBLST; T:=0; CALL FAR CRDISC
047267   % READ IN THE RPIT
047267          A:=RPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047274          A:=RPILPHPAGE-RPIFPHPAGE+1=:X; A:="MIRPT"+CBLST; T:=0; CALL FAR CRDISC
047304          GO BYP1; *)FILL
047313   % READ IN MPIT
047313   BYP1:  A:=MPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047320          A:=MPILPHPAGE-MPIFPHPAGE+1=:X; A:="MIMPT"+CBLST; T:=0;  CALL FAR CRDISC
047330   % READ IN IPIT
047330          A:=IPIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047335          A:=IPILPHPAGE-IPIFPHPAGE+1=:X; A:="MIIPT"+CBLST; T:=0;  CALL FAR CRDISC
047345   % READ IN SEGMENT 42
047345          A:=EDFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047352          X:=1; A:="S41MA"+CBLST; T:=0; CALL FAR CRDISC
047357   % READ IN RT'S SYSTEM SEGMENT AND CLEAR THE BUFFER-POOL
047357          A:=RTSGFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047364          A:=SISYSEG-"5ESSZ"=:X; A:="MISYS"+"5ESSZ"+CBLST
047372          T:=0; CALL FAR CRDISC
047374          T:="DV100"+1; A:="5ESSZ" SH 12 + "BGSYS"; T-A         % CLEAR SEGM FROM DV100+1 TO END OF SEGM
047402          A:=RTSGFPHPAGE SH 12+T=:X; T:=RTSGFPHPAGE SHZ -6      % TX=PHYS.ADDR OF DV100+1
047410          A:=RTSGLPHPAGE SH 12-1=:D                             % D= END OF SEGMENT
047414          DO
047414             *STZTX
047415          WHILE X><D
047417             X+1
047420          OD
047421   *PL019=*
047421   *IFILL
047433
047433
047433   *"8N500
"047433   % READ IN 5PIT SEGMENT
047433          A:=5PIFPHPAGE=:D:=0; AD SH 12=:CDDMADDR
047440          X:="LS5PT"; A:="MI5PT"+CBLST; T:=0; CALL FAR CRDISC
047445
047445   *"8FLMN
"047445         IF UCLOAD >< 0 THEN          % READ IN MICRO CODE
047447           A:=UCFPA=:D:=0; AD SH 12=:CDDMADDR
047454           IF HWINFI(0) /\ 377 = 3 OR A= 11 OR A = 12 THEN    % ND 110
047470             X:="LSUC1"; A:="MIUC1"
047472           ELSE IF A = 4 OR A = 10 THEN                       % ND 120
047501             X:="LSUC2"; A:="MIUC2"
047503           ELSE
047504             0=:UCLOAD; GO NOUC
047506           FI FI
047506           A+CBLST; T:=0; CALL FAR CRDISC
047511         FI
047511   *IFILL
047524   NOUC:
047524          A:=RPIFPHPAGE; T:=MPIFPHPAGE
047526          CALL XCHIOX           % FIND OUT HOW MANY TERM.INTERFACES THERE ARE
047527                                % IN THIS SYSTEM, AND CHECK THE IDENT CODE OF
047527                                % THE EXISTING TERM.INTERFACES
047527
047527   *"-8BACS
"047527   *PL020=*
047527
047527   % COMPUTE REQUIRED SPACE FOR THE TERMINAL DATAFIELDS OUTSIDE RESIDENT
047527   % INITIALISE THESE PAGES
047527
047527          X:="TIOBU"; L:=0; *1BANK
047532          DO WHILE X.S0><-1
047536             IF A><0 THEN
047537                AD:=X.DOU1
047540                A+D+TDISIZ+TDOSIZ; DO A-400; L+1 WHILE A>0 OD
047550             FI; X+3
047551          OD; *2BANK
047553          A:=L*400; CALL FPGNO; A+D=:X=:TDLPHPAGE
047561          IF X >> 200 THEN CALL ERRFATAL FI    % MAX 200 PAGES FOR BIG TERM DF
047565          A:=100; T:=LPHYSPAGE; CALL ZGETAREA; CALL ERRFATAL
047571          A=:TDFPAGE SHZ -6=:TDFBANK; TDFPAGE-1+TDLPHPAGE=:TDLPHPAGE
047600          GO OVFI8; *)FILL
047611
047611   % LOCAL SUBROUTINE TO REMOVE A TAD DF. FROM THE TIMER TABLE
047611   ZTMRTENTRY: T:=L=:"CLINK"
047613          AD=:DCDFADR; X=:0CINX
047615          X:=TMRADDR
047616          DO WHILE X<<ETMRADDR
047621             T:=RPIBANK; *LDATX
047623             IF A=C1DFADDR OR A=C2DFADDR THEN
047631                T:=RPIBANK; *STZTX
047633             FI; X+1
047634          OD; A:=C1DFADDR; CALL CLBCKTABENTRY
047637          X:=0CINX; GO CLINK
047641   *)FILL
047642
047642   OVFI8:
047642   % FIND NUMBER OF TAD'S IN THIS SYSTEM
047642          A:=CNVRT(15)=:AD1500
047645          A:="9EBAD"-"DV000"; T:=LGTFPHPAGE SH 12+A=:AETADS
047653          X:=CNVRT(14)+1; 0=:NTADS
047657          DO                                        % SEARCH IN LOG.DEV TABLES
047657             IF X=AD1500 THEN X+1 FI
047663          WHILE AETADS>>X AND NTADS<<MXTADS
047672             T:=LOGDBANK; *LDDTX
047674             IF A><0 OR D><0 THEN MIN NTADS FI
047700             X+2
047701          OD
047702   % IF MAX NUMBER OF TADS TO USE, IS LESS THAN THE NUBER OF TADS GENERATED
047702   % IN THIS SYSTEM, THEN CLEAR THE NOT USED ENTRIES IN THE LOGICAL UNIT TABLE
047702          IF X<<AETADS THEN
047705              T:=RPIFPHPAGE SH 12
047707              A:="TMRTE"+1-"PITEX"+T=:TMRADDR
047714              A:="ETMRT"-"PITEX"+T=:ETMRADDR
047720              DO WHILE X<<AETADS
047723                 IF X=AD1500 THEN X+1 FI
047727                 T:=LOGDBANK; *LDDTX; STZTX; STZTX 10  % CLEAR ENTRY IN LOG.UN. TABLE
047733                 IF A><0 THEN CALL ZTMRTENTRY FI
047735                 X+2
047736              OD
047737          FI
047737   *"-8BACS
"047737
047737   *PL021=*
047737
047737   % COMPUTE NUMBER OF TAD/TERMINAL BACKGROUND PROGRAMS TO USE,
047737   % THE REMAINING TAD/TERMINAL BACKGROUND PROGRAMS WILL BE SET IN RTOFF.
047737          A:="2THSS"-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
047745          IF A>MXBPROGS THEN
047750             A:=MXBPROGST=:NBPROGS*5RTSIZE+"9FBPR"=:X
047755             DO WHILE X><"9LTBP"
047760                X.STATUS BONE 5RTOFF=:X.STATUS
047763                X+5RTSIZE
047764             OD
047765          ELSE
047766             A=:NBPROGS
047767          FI; NBPROGS=:MXTBPROGS                   % NUMBER OF TERMINAL/TAD BACKG.PROGS IN USE
047771   *"
"047771          GO GTADMEMORY; *)FILL
050010   GTADMEMORY:
050010
050010   % RESERVE MEMORY FOR THE "BIG" TAD DATAFIELDS
050010          IF NTADS><0 THEN
050012             A*200; CALL FPGNO; A+D=:MMSIZE=:X      % 200B WORDS PER TAD DF.
050017             A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050023             A=:FTADPAGE+MMSIZE-1=:LTADPAGE         % FIRST AND LAST PHYS.PAGE FOR TAD DF'S
050027             X:=CNVRT(14)+1; 0=:NTADS
050033             DO                                      % SEARCH IN LOG.DEV TABLES
050033               IF X=AD1500 THEN X+1 FI
050037             WHILE AETADS>>X
050042               T:=LOGDBANK; *LDDTX
050044               IF A><0 OR D><0 THEN
050047                  X=:0CINX; T:=NTADS; X:=A; CALL FAR MAKTADDF; MIN NTADS; X:=0CINX
050055               FI; X+2
050056             OD
050057          FI; GO OVFI9; *)FILL
050067
050067   OVFI9:
050067
050067   % FIND NUMBER OF BATCHES TO USE IN THIS SYSTEM
050067          0=:CNBATCES; "BCHTA"+1=:0CINX
050073          DO WHILE 0CINX.S0><-1
050100             IF CNBATCHES>>=MXBATCHES THEN
050104                -1=:X.S0
050106                X.S1.STATUS BONE 5RTOFF=:X.STATUS
050112                T:=0CINX.S2 SHZ -6; X.S2/\77 SH 1
050120                X:=CNVRT(T)+A; T:=LOGDBANK; *LDATX 10
050125                CALL CLBCKTABENTRY                  % REMOVE FROM BACKGROUND TABLE
050126                *STZTX 10; STZTX 20                 % CLEAR LOG.UNIT TABLE ELEMENT
050130                T:=0CINX.S3 SHZ -6; X.S2/\77 SH 1
050136                X:=CNVRT(T)+A; T:=LOGDBANK; *STZTX 10; STZTX 20
050144                0=:0CINX.S2=:X.S3
050147             FI; MIN CNBATCHES; 0CINX+4=:0CINX
050153          OD
050154          IF CNBATCHES>>MXBATCHES THEN A:=T FI
050161          A=:"BCHTAB".S0+NBPROGS=:NBPROGS
050165          GO OVFIA; *)FILL
050174
050174   OVFIA:
050174
050174   % COMPUTE SIZE OF THE PAGE-OWNER TABLE FOR MON SPLREE
050174          NBPROGS*POTESIZE; CALL FPGNO; A+D=:X=:POWSIZE
050202          A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050206          A=:D=:POWFPAGE+POWSIZE-1=:POWLPAGE:=0; AD SH 12=:DSREBADDR
050216
050216   *PL022=*
050216
050216   *"8BACS
"050216   % COMPUTE SIZE OF THE BACKS-TABLE AREA, AND RESERVE MEMORY FOR THIS AREA
050216          A:="EPRVT"-"PRVTT"=:D:=0; T:=5IPRVTSIZE; *RDIV ST
050224          IF D><0 THEN CALL ERRFATAL FI; A*5PRVTSIZE=:CPRVTSIZE
050231          T:=RPIBANK=:MBPRVTTABLE
050233          T:=RPIFPHPAGE SH 12
050235          A:="PRVTTABLE"-"PITEX"+T=:APRVTTABLE+CPRVTSIZE=:AEPRVTTABLE
050243          A:="EBPRT"-"SBPRT"=:D:=0; T:=5IBPRTSIZE; *RDIV ST
050251          IF D><0 THEN CALL ERRFATAL FI
050254          MXTBPROGS*BPRTSIZE=:CBPRTSIZE
050257          CALL FPGNO; A+D=:MMSIZE=:X
050263          A:=0; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
050267          A=:BACSFPHPAGE+MMSIZE-1=:BACSLPHPAGE
050273          A:=BACSFPHPAGE=:D:=0; AD SH 12; A=:MBSPRTAB
050300          A:=D=:ASBPRTAB+CBPRTSIZE=:AEBPRTAB
050304          NBPROGS=:1NBPP                                % NUMBER OF BACKGROUND PROGS IN USE
050306          A:="9LBPR"-"9FBPR"=:D:=0; T:=5RTSIZE; *RDIV ST
050314          IF D><0 THEN CALL ERRFATAL FI; A=:2NBPP       % NUMBER OF BACKGROUND PROG. RT-DESCR
050320   *"
"050320          GO AFILL; *)FILL
050350
050350   *PL023=*
050350
050350   AFILL:
050350          A:="9FSSG"=:D:=0; T:=5SEGSIZE; *RDIV ST
050355          A=:CSGNO                                  % FIRST CONFIG.DEPENDANT SEGMENT AFTER DILGS
050356          "9FSMA"=:NXMADR                           % MASS ADDR OF FIRST CONFIG.DEPENDANT SEGMENT
050360
050360   % COMPUT NUMBER OF SPOOLING PROCESSES TO USE IN THIS SYSTEM
050360   % SET SEGMENT SIZE AND MASS STORAGE ADDR OF THE SPOOLING QUEUE SEGMENTS
050360   % TO USE. THE UNUSED SPOOLING QUEUE SEGMENTS WILL BE SET
050360   % INHBT AND THE PERIPHERAL DEVICE NUMBER IN THE SPOOLING TABLE ELEMENT
050360   % WILL BE CLEARED (SET TO -1), AND THE CORRESPONDING SPOOLING
050360   % RT-PROGRAM WILL BE SET RTOFF
050360
050360          A:="ENDSP"-"SPTAB"=:D:=0; T:=SPLEN; *RDIV ST
050366          IF A<<MXSPOOLER THEN A=:MXSPOOLERS FI  % MAX SPOOLERS TO USE
050372          IF "SPTAB"="ENDSP" GO FAR OVFIB
050376          IF SPQSSIZE>>14 THEN A:=T FI           % ADDR 150000-177777 IS AVAILABLE FOR SPOOL.QUEUE
050403          A=:CSGSIZE                             % SPOOLING QUEUE SEGMENT SIZE
050404          IF HENTFLAG=0 THEN
050406             200=:CBLST; A:=100; T:=LPHYSPAGE; X:=1; CALL GETAREA; CALL ERRFATAL
050415             A=:D:=0; AD SH 12=:CDDMADDR
050421          FI; 0=:0CINX; X:="SPTAB"
050423          GO ISPOOLOOP; *)FILL
050437   ISPOOLOOP:
050437          DO WHILE X><"ENDSP"
050442             X=:CSAVX
050443             IF 0CINX><MXSPOOLERS OR X="COSDA"+1 THEN      % USE MORE SPOOLERS?
050453                IF HENTFLAG=0 THEN
050455                   CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK % YES
050462                   NXMADR; *MADR@3 STATX                   % SET MASSADDR OF SEGMENT
050464                   CSGSIZE; *SEGLE@3 STATX                 % SET LENGTH OF SEGMENT
050466                   X:=CBLST; T:="MSPDF"+X; A:=NXMADR+X
050473                   X:=1; CALL FAR CRWDISC           % COPY QUEUE-HANDLING ROUTINES
050475                   NXMADR+CSGSIZE=:NXMADR
050500                FI; MIN 0CINX
050501             ELSE
050502                -1=:X.SPERI                                % CLEAR LOG.DEV.NO OF SPOOLING TABLE ELEMENT
050504                CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
050511                *FLAG@3 LDATX
050512                A BONE 5INHBT; *FLAG@3 STATX               % SET SEGMENT INHBT
050514                CSAVX.SPROG.STATUS BONE 5RTOFF=:X.STATUS    % RTOFF ON SPOOLING RT-PROGR.
050521             FI; MIN CSGNO; X:=CSAVX+SPLEN
050524          OD; GO OVFIB; *)FILL
050537
050537   *PL024=*
050537
050537   OVFIB: X:=1; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL % ALLOCATE PAGE FOR CACHE INHIBIT BIT MAP
050544          A=:FPHPCACHEINHIBIT=:LPHPCACHEINHIBIT
050546          A=:D:=0; AD SHZ 12; A=:MBCACHINHIBIT:=D=:CACHINHIBIT
050554          A:=FPHPCACHEINHIBIT; CALL ZEROPAGE                    % CLEAR CACHE INHIBIT BIT MAP
050556
050556          CALL OCSTART                               % START UP FOR OCTOBUS
050557          CALL NUCST                                 % START UP FOR NUCLEUS
050560   *"8N500
"050560   % COMPUTE THE MAX. NUMBERS OF ND-500 PROCESSES TO USE IN THIS SYSTEM.
050560   % SET THE MASS. STORAGE ADDR OF THE ND-500 DATA SEGMENTS TO USE.
050560   % THE UNUSED ND-500 DATA SEGMENTS AND ND-500 FILE TRANSFER SEGMENTS
050560   % WILL BE SET INHBT.
050560   %
050560          CALL CH5CPUPRESENT; 0=:MX5PROCS           % CHECK IF ND-500 CPU IS PRESENT
050562          A:="S500E"-"S500S"=:D:=0; T:=5PRDSIZE; *RDIV ST
050570          IF A-1<<MX5PROCS THEN A=:MX5PROCS FI
050575          "F5DSG"=:CSGNO*5SEGSIZE+SEGSTART=:X
050602          T:=SEGTBANK; *SEGLE@3 LDATX
050604          A=:CSGSIZE                                % ND-500 DATA SEGMENT SIZE
050605          0=:0CINX
050606          IF HENTFLAG >< 0 THEN
050610             A:="F5DSG"*5SEGSIZE+SEGSTART=:X
050614             T:=SEGTBANK; *FLAG@3 LDATX
050616                IF A BIT 5INHB THEN
050620                   0=:MX5PROCS                      % ND-500 DATA SEGMENT IS NOT INITIALIZED
050621                FI
050621          FI
050621          DO WHILE CSGNO><"L5DSG"
050625             IF 0CINX><MX5PROCS THEN
050631                IF HENTFLAG=0 THEN
050633                   NXMADR; T:=SEGTBANK; *MADR@3 STATX  % MASS STORAGE OF ND-500 DATA SEGM
050636                   A+CSGSIZE=:NXMADR
050640                FI; X+5SEGSIZE+5SEGSIZE; MIN 0CINX
050643             ELSE
050644                IF HENTFLAG=0 THEN
050646                   T:=SEGTBANK; *FLAG@3 LDATX
050650                   A BONE 5INHB; *FLAG@3 STATX         % INHBT OF ND-500 DATA SEGM
050652                   X+5SEGSIZE; *FLAG@3 LDATX
050654                   A BONE 5INHB; *FLAG@3 STATX         % INHBT OF ND-500 FILE TRANSFER SEGM
050656                   X+5SEGSIZE
050657                FI
050657             FI; MIN CSGNO; MIN CSGNO
050661          OD
050662   *"
"050662          GO SCAPM; *)FILL
050704
050704   *"8SCSI
"050704   %==============================================================================
050704   %        S C A P M
050704   %
050704   %
050704   % SCAPM : ALLOCATE PHYSICAL MEMORY BUFFERS TO SCSI DEVICES
050704   %
050704
050704   % ROUTINE TO ALLOCATE PHYSICAL MEMORY BUFFERS TO DEVICE AND LUN DATAFIELDS
050704   % ENTRY: AD = PHYSICAL ADDRESS OF BUFFER LOW PART
050704   % EXIT: AD = FIRST ADDRESS NOT USED
050704
050704   INTEGER CURDF, SAVX, SAVB
050707   INTEGER CPHA1,CPHA2
050711   DOUBLE CPHAD=CPHA1
050711
050711   ALPHM: AD=:CPHAD; A:=B=:SAVB
050714          "SCBDF"=:CURDF
050716          DO WHILE CURDF<<"SCDDF"
050722             IF CURDF.S1=:B><0 THEN
050726                CPHA1; AD=:SCPMB; A:=10; D+A
050732             FI
050732             CURDF+2=:CURDF
050735          OD
050736          CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
050743          "SCDDF"=:CURDF
050745          DO WHILE CURDF<<"SCSDF"
050751             IF CURDF.S1=:B><0 AND SCIDN SHZ -4><0 THEN
050760                0=:SAVX
050761                FOR SAVX TO 3 DO
050765                   IF X:=PUNDF(SAVX)><0 THEN
050770                      CPHAD; T:=SDDBS; D+T; AD=:X.CMADR
050774                      CPHAD=:X.SCDFA.SMBPA
050777                   FI
050777                   CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
051004                OD
051010             FI
051010             CURDF+2=:CURDF
051013          OD
051014          DO WHILE CURDF.S0><-1
051021             IF X.S1=:B><0 AND SCIDN SHZ -4><0 THEN
051027                X:=SCDFA+1; CPHAD=:X.SMBPA
051033                T:=SDDBS; D+T; AD=:CMADR
051036                CPHAD; T:=LUNBL; D+T; A:=A+C; AD=:CPHAD
051043             FI
051043             CURDF+2=:CURDF
051046          OD
051047          SAVB=:B; CPHAD; EXIT
051053   *)FILL
051057
051057   INTEGER NPAGS
051060   INTEGER NOP(0); *RAND
051061
051061   *"
"051061
051061   SCAPM:
051061
051061   *"8SCSI
"051061          A:=0=:D; CALL FAR ALPHM              % DETERMINE AMOUNT OF MEMORY NEEDED
051064          AD SHZ 6; IF D><0 THEN A+1 FI        % NUMBER OF PAGES
051070          IF X:=A=:NPAGS><0 THEN
051073             DVBFPAGE; T:=LPHYSPAGE            % LEGAL AREA
051075             CALL ZGETAREA; CALL ERRFATAL      % GET MEMORY AREA
051077             A=:D-1+NPAGS:=:D; AD=:SCPHYSPAGE  % FIRST AND LAST PAGE
051104             D:=0; AD SHZ -6; CALL FAR ALPHM   % INITIALIZE DATAFIELDS
051107          FI
051107          IF HWINFO(0)/\ 377 >= 3 THEN         % ND-110 , ND-120
051115             NOP=:SCCLR; SCPHYSPAGES           % REMOVE CLEAR CACHE INSTRUCTION
051120             CALL DISCACHE; CALL ERRFATAL      % DISABLE CACHE
051122          FI
051122          GO OVFIC
051123   *)FILL
051133   *"
"051133
051133   *PL026=*
051133
051133   OVFIC:
051133
051133   *"8RFAC
"051133   % COMPUTE THE MAX NUMBER OF REMOTE-FILE-ACCES CONNECTIONS THAT
051133   % SIMULTANEOUSLY CAN BE ACTIVE IN TH SYSTEM
051133   % THE MASS STORAGE ADDR OF THE REMOTE-FILE-TRANSFER DATA SEGMENTS, THAT CAN
051133   % BE USED IS SET UP, AND THE REST OF THE REMOTE-FILE-TRANSFER DATA SEGMENTS
051133   % ARE SET INHBT.
051133          IF "NRFSG".S0<<MXRFACS THEN A=:MXRFACS FI
051141          A+"DSSNM"=:D                              % D=LAST SEGM+1 FOR REMOTE-FILE-ACC.
051143          "DSSNM"=:CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051152          A=:CSGSIZE; 0=:0CINX
051154          DO WHILE CSGNO<<D
051157             IF 0CINX><MXRFACS THEN
051163                IF HENTFLAG=0 THEN
051165                   NXMADR; T:=SEGTBANK; *MADR@3 STATX
051170                   A+CSGSIZE=:NXMADR
051172                FI; MIN 0CINX
051173             ELSE
051174                T:=SEGTBANK; *FLAG@3 LDATX
051176                A BONE 5INHB; *FLAG@3 STATX
051200             FI; MIN CSGNO; X+5SEGSIZE
051202          OD; MXRFACS=:"NRFSG".S0
051206   *"
"051206   % COMPUTE THE MAX NUMBER OF ND-100 SYMBOLIC DEBUGGERS THAT SIMULTANEOUSLY
051206   % CAN BE ACTIVE.
051206   % THE MASS STORAGE ADDR OF THE SYMBOLIC DEBUGGER SEGMENTS, THAT CAN BE USED,
051206   % IS SET UP, AND THE REST OF THE DEBUGGER DATA SEGMENTS PRESENT
051206   % ARE SET INHBT.
051206          A:="9SGNU"=:D:=0; T:=5SEGSIZE; *RDIV ST
051213          IF A-"SGNUM"<<MXSDBUGGER THEN A=:MXSDBUGGER FI
051220          "SGNUM"=:CSGNO*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051227          A=:CSGSIZE; 0=:0CINX
051231          DO WHILE "9SGNU"+SEGSTART><X
051235             IF 0CINX><MXSDBUGGERS THEN
051241                IF HENTFLAG=0 THEN
051243                   NXMADR; T:=SEGTBANK; *MADR@3 STATX
051246                   A+CSGSIZE=:NXMADR
051250                FI; MIN 0CINX
051251             ELSE
051252                T:=SEGTBANK; *FLAG@3 LDATX
051254                A BONE 5INHB; *FLAG@3 STATX
051256             FI; X+5SEGSIZE; MIN CSGNO
051260          OD; GO OVFID; *)FILL
051274
051274   *PL027=*
051274
051274   OVFID:
051274
051274          A:="1SYSS"=:D:=0; T:=5SEGSIZE; *RDIV ST
051301          A=:CFSYSEG                                % FIRST SYSTEM SEGMENT IN THIS SYSTEM
051302          IF HENTFLAG=0 THEN
051304             CFSYSEG*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK
051311             NXMADR; *MADR@3 STATX                     % MASS STORAGE ADDR OF FIRST SYSTEM SEGMENT
051313             SISYSEG; *SEGLE@3 STATX                   % SYSTEM SEGMENT SIZE
051315             X+5SEGSIZE; A+NXMADR; *MADR@3 STATX       % MASS STORAGE ADDR OF FIRST BACKGROUND SEGMENT
051320             X+5SEGSIZE
051321             DO WHILE "9SYSS"+SEGSTART>>X
051325                SISYSEG; T:=SEGTBANK; *SEGLE@3 STATX   % SET SEGMENT LENGTH OF ALL SYS.SEGMS
051330                X+5SEGSIZE+5SEGSIZE
051332             OD
051333          FI
051333          IF "MNADP"><0 AND SGADPSIZE><0 THEN
051337             "FREDS"*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
051345             A=:SGADPSIZE                           % SIZE OF ADP.SEGMENT
051346          ELSE
051347             0=:SGADPSIZE                           % CANNOT USE "MON ADP", NO ADP-DATA-SEGM AVAILABLE
051350          FI
051350          MXALLMEM+40                               % NALME+ MAX.NO. OF HDLS'C
051352          IF T:=SGADPSIZE><0 THEN A+NBPROGS FI      % IF MON ADP THEN 1 ELEMENT FOR EACH BACKGR.PROGR
051356          A SH 1=:D=:FXCTSIZE                       % 2 LOCS FOR EACH ENTRY IN FXCTAB
051361          "NXRTP"*TSLSIZE+D=:D                      % TIMESLICE TABLE AREA
051365          "NXRTP"+1 SH 1+D=:D                       % DTSLPRTAB
051372   *"8ACC
"051372          A:="8RTN"*3+D=:D                          % RT-ACCOUNTING
051376   *"8IOAC
"051376          A:="NXRTP" SH 1+D=:D                      % I/O ACCOUNTING
051402   *"8LOG+8HIST
"051402          A:="NXRTP" SH 1+D=:D                      % LOG/HISTOGRAM SAMPLING AREA
051406   *"
"051406          A:=200; D+A                               % MEMORY-TYPE ARRAY
051410          GO OVFIE; *)FILL
051431
051431   *PL028=*
051431
051431   OVFIE: A:=D; CALL FPGNO; A+D=:MMSIZE
051435          A=:X; A:=100; T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL
051442          A=:8LOGFPHPAGE+MMSIZE-1=:8LOGLPHPAGE=:D
051447          A:=8LOGFPHPAGE; DO CALL ZEROPAGE WHILE A><D; A+1; OD
051455          A:=8LOGFPHPAGE=:D:=0; AD SH 12; A=:GLTMBANK
051462   *"8LOG+8HIST
"051462          A=: MBLGARR
051463   *"
"051463          A=:MBMEMARRAY
051464          A=:MBFXCTAB:=D=:FXCTAB+FXCTSIZE=:EFXCTAB=:D  % FXCTABLE ADDRESSES
051472          A:=D=:GTSLTAB; "NXRTP"*TSLSIZE+D
051477          A=:DTSLPRTAB=:D; "NXRTP"+1 SH 1+D
051505   *"8ACC
"051505          A=:ACTABLE=:D:="8RTN"*3+D
051512   *"8IOAC
"051512          A=:IOACTABLE=:D:="NXRTP" SH 1+D
051517   *"8LOG+8HIST
"051517          A=:ALGARR=:D:="NXRTP" SH 1+D
051524   *"
"051524          A=:MEMARRAY                               % MEMEORY-TYPE-ARRAY ADDR
051525   % ALLOCATE MEMORY FOR THE RT-PROGR'S MON.CALL WORKING FIELDS
051525          A:="9FBPR"-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
051533          A*40; CALL FPGNO; A+D=:MMSIZE
051537          A=:X:=0; T:=LPHYSPAGE; CALL ZGETAREA; CALL ERRFATAL
051544          A=:RTWFPAGE=:FRTWFPAGE+MMSIZE-1=:LRTWFPAGE
051551   % INITIALIZE THE RT-DESCRS WITH PAGE NUMBER FOR MON.CALL WORKING FIELD
051551          A:=RTWFPAGE; X:=RTSTART
051553          DO
051553             T:=-40=:0CINX
051555             FOR 0CINX DO
051555                A=:X.TRMWINDOW
051556                IF X+5RTSIZE>>="9FBPR" GO OVFIG
051562             OD; A+1
051565          OD; *)FILL
051617
051617   *PL029=*
051617
051617   OVFIG:
051617          AD:=CMDPHPAGE; A+1; CALL MOUTLINKL % LINK OUT COMMON CODE
051622          AD:=DPIDPHPAGE; CALL MOUTLINKL    % LINK OUT DPIT
051624          AD:=RSDPHPAGE; CALL MOUTLINKL     % LINK OUT RESTART ROUTINE AND REG-BLOCKS/REE-BITMAP
051626          "STPBS" SHZ -12=:D-1; D+1; CALL MOUTLINK % LINK OUT SBFIELD + ERROR RING BUFFER + PATCH INFO AREA
051634          AD:=RTSGDPHPAGE; CALL MOUTLINKL   % LINK OUT RT'S SYSTEM SEGMENT
051636          AD:=PITSDPHPAGE; CALL IMOUTLINKL  % LINK OUT PIT PAGES AND INITIALIZED THEM.
051640          AD:=LGTDPHPAGE; CALL MOUTLINKL    % LINK OUT LOG.DEV.NO. TABLE
051642          AD:=MMDPAGE; CALL MOUTLINKL       % LINK OUT MEMORY MAP AREA
051644          AD:=DBDPAGE; CALL IMOUTLINKL      % LINK OUT DEVICE BUFFER AREA
051646          AD:=SGTDPHPAGE; CALL MOUTLINKL    % LINK OUT SEGMENT TABLE
051650          AD:=ECODPHPAGE; CALL MOUTLINKL    % LINK OUT EXT. COMMON
051652          AD:=RPIDPHPAGE; CALL MOUTLINKL    % LINK OUT RPIT
051654          AD:=MPIDPHPAGE; CALL MOUTLINKL    % LINK OUT MPIT
051656          AD:=IPIDPHPAGE; CALL MOUTLINKL    % LINK OUT IPIT
051660          AD:=DEDPHPAGES; CALL MOUTLINKL    % LINK OUT "EDIT-ROUTINES" SEGMENT
051662          AD:=IOBDPHPAGE; CALL IMOUTLINKL   % LINK OUT I/O BUFFER PAGES
051664          AD:=POWDPAGE; CALL IMOUTLINKL     % LINK OUT PAGE-OWNER TABLE AREA
051666          AD:=DCMCLPAGE; CALL IMOUTLINKL    % LINK OUT MONITOR-CALL-LOG-TABLE PAGE
051670          AD:=SYMDPHPAGE; CALL IMOUTLINKL   % LINK OUT SYNC.MODEM I/O BUFFERS
051672          AD:=DHDLCPAGES; CALL IMOUTLINKL   % LINK OUT HDLC BUFFER AREA
051674          AD:=TDDPAGE; CALL IMOUTLINKL      % LINK OUT TERMINAL DATAFIELD AREA
051676          AD:=DTADPHPAGE; CALL IMOUTLINKL   % LINK OUT TAD DATAFIELD AREA
051700          AD:=DLAMPAGE; CALL IMOUTLINKL     % LINK OUT LAMU AREA
051702          AD:=DBACSPHPAGES; CALL IMOUTLINKL % LINK OUT BACS TABLE AREA
051704          AD:=5PIDPHPAGES; CALL MOUTLINK    % LINK OUT 5PIT SEGMENT PAGES
051706          AD:=D8LOGPHPAGE; CALL IMOUTLINKL  % LINK OUT PROG-LOG PAGES
051710          AD:=DSPTRPHPAGE; CALL IMOUTLINKL  % LINK OUT "SPARE-TRACK-ADDR-BUFFER"
051712          AD:=DRTWFPAGE; CALL IMOUTLINKL    % LINK OUT RT-PROG'S MON.CALL WORKING FIELDS
051714          AD:=DCACHEINHIBIT; CALL MOUTLINKL % LINK OUT CACHE INHIBIT BIT MAP PAGE
051716          AD:=SCPHYSPAGE; CALL IMOUTLINKL   % LINK OUT SCSI BUFFER PAGES
051720          AD:=NUPHYSPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR NUCLEUS
051722          AD:=OCPHYSPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR OCTOBUS
051724          AD:=IERDPHPAGE; CALL IMOUTLINKL   % LINK OUT PAGES FOR ERROR DEVICE BUFFER
051726   *"8FLMN
"051726          IF UCLOAD >< 0 THEN
051730            AD:=UCPAG; CALL IMOUTLINKL      % LINK OUT PAGES FOR MICR CODE
051732          FI; *IFILL
051737
051737   *PL030=*
051737
051737   % LINK OUT RT-COMMON
051737          IF ACCTAB(0)><-1 THEN
051744             A/\177=:ARTFPAGE SH 1; T:="XCCTAB"-A=:IRTCPIT
051752             ARTFPAGE\/77=:ARTLPAGE
051755             DO WHILE ACCTAB(X)><-1
051761                X=:0CINX; A=:1CCTAB
051763                X+1; ACCTAB(X)=:D=:2CCTAB; CALL IMOUTLINKL
051770                A:=2CCTAB=:D:=161000; AD=:XCCTAB(0CINX); X+2
051776             OD
051777          ELSE
052000             -1=:ARTFPAGE=:ARTLPAGE
052003          FI
052003
052003   % LINK OUT NOT-SWAP PAGES AND INITIALIZE THE PAGES
052003          X:=0
052004          DO WHILE X<<"NNSWSZ*2"
052007             *1BANK
052010             AD:=NSWPAGE(X)
052011             *2BANK
052012             IF A><0 AND A<<=D THEN
052015                CALL MOUTLINKL
052016                DO WHILE A<<=D; CALL INITPAGE; A+1; OD
052023             FI; X+2
052024          OD; *IFILL
052041
052041   % LINK OUT LAMU AREAS
052041          X:=0; DO WHILE X<<"NINSZ+1*2"
052045             *1BANK
052046             AD:=LAMARR(X); *2BANK
052050             IF A><0 AND D >< 0 THEN CALL MOUTLINKL FI  % LINK OUT LAMU AREAS
052054             X+2
052055          OD
052056
052056   % FIND NUMBER OF SWAPPING PAGES AND INITIALIZE THE SWAPPING PAGES
052056          0=:CURRPAGES; T:=SEGTBANK; X:=XSGRT; *AAX BPAGL-PAGLI
052062   INDO2: DO
052062             *PAGLI@3 LDXTX
052063          WHILE X><0
052064             T:=CORMBANK; A:=X SHZ -2     % A= PHYSICAL PAGE NUMBER
052067             CALL PHYSPTEST; GO COUTLINKL; CALL INITPAGE
052072             MIN CURRPAGE
052073          OD; CURRPAGE=:NOPGS; GO L4
052077
052077   % LINK OUT A MEMORY MAP ELEMENT (X=ADDR OF ELEMENT)
052077   COUTLINKL: T:=CORMBANK; X=:L
052101          A:=0 BONE 5CMINHB; *PROTE@3 STATX
052104          *PREVI@3 LDATX; PAGLI@3 LDXTX
052106          IF X><0 THEN
052107             *PREVI@3 STATX
052110          FI; X=:D:=A
052112          IF A/\3><0 THEN
052114             X:=XSGRT; T:=SEGTBANK; *AAX BPAGL-PAGLI
052117          FI; A:=D; *PAGLI@3 STATX
052121          GO INDO2
052122   *)FILL
052133
052133   *PL031=*
052133
052133   L4:
052133          GO LL4; *)FILL
052134
052134   LL4:
052134
052134   *PL032=*
052134
052134   % SET TIMESLICE CLASS
052134   % IF SAVED TIMESLICE CLASS (TSLSTATUS BIT 14-17) EQUALS ZERO THEN
052134   %          TIMESLICE CLASS FOR TERMINALS IS SET TO ZERO AND TIMESLICE
052134   %          CLASS FOR BATCH IS SET TO ONE
052134   % ELSE
052134   %          TIMESLICE CLASS IS SET EQUAL SAVED TIMESLICE CLASS
052134   % ENDIF
052134   %
052134          0=:NPAGES=:CCOUNT; RTSTART=:0CINX
052140   *"-8BACS
"052140          DO WHILE X:=0CINX<<"ERTBS"
052144             IF X.STATUS BIT 5TSLICED AND A NBIT 5RTOFF THEN
052151                IF A NBIT 5BACKGR OR X>>="2THSS" THEN         % ONLY RT-PROGR AND BATCHES
052156                   A BONE 5ESCF=:X.STATUS
052160                   IF A BIT 5BACKGR THEN
052162                      A:=1                                    % BATCH: TIMESLICE CLASS 1
052163                   ELSE
052164                      IF 0CINX.INTSLCLASS BIT BINTSLCLASS THEN
052170                         A SHZ -7CUTY/\TSLCMSK                 % "SAVED" TIMESLICE CLASS
052172                      ELSE
052173                         A:=0                                 % DEFAULT CLASS
052174                      FI
052174                   FI; A SHZ 7CUTY=:D
052176                   A:=NPAGES*TSLSIZE+GTSLTAB=:X
052202                   T:=GLTMBANK; A:=D; *TSLST@3 STATX          % INSERT TIMESLICE CLASS
052205                   A:=CCOUNT+DTSLPRTAB=:X
052210                   A:=NPAGES=:D:=0CINX; *STDTX                % INSERT IN DTSLPRTAB
052214                   CCOUNT+2=:CCOUNT                           % INCREMENT INDEX IN DTSLPRTAB
052217                FI
052217             FI; MIN NPAGES; 0CINX+5RTSIZE=:0CINX             % INCREMENT RT-DESCR ADDR AND RT-PROGR INDEX
052223          OD
052224   *"
"052224   *PL033=*
052224
052224          CCOUNT+DTSLPRTAB=:X; T:=GLTMBANK
052230          A:=-1=:D; *STDTX
052233          0=:CCOUNT
052234          DO WHILE CCOUNT<<"NXRTP"
052240             A*TSLSIZE+GTSLTAB=:X; T:=GLTMBANK; A:=-1; *TSLCO@3 STATX
052246             MIN CCOUNT
052247          OD; X:=RTSTART
052251          DO WHILE X<<RTEND; 0=:X.INTSLCLASS; X+5RTSIZE; OD
052257          GO FFLTYPE; *)FILL
052272
052272   FFLTYPE:
052272          X:="FLOP1"; CALL FAR FINDFLOPPY
052274          X:="FLOP2"; CALL FAR FINDFLOPPY
052276
052276          0=:0CINX
052277          DO WHILE BDISTABLE(0CINX)><-1
052304             IF A><0 THEN                                     % DISK DF. GENERATED
052305                A:=200; *TRR IIE; TRA IIC                     % ENABLE FOR IOX-ERRORS
052310                X:=BDISTABLE(X); T:=X.HDEV+2; *IOXT; TRA IIC
052315
052315   *"8FLMN      % DO NOT REMOVE DISK IF FOR FLOMEN
"052315                IF A=0 THEN
052316                   BDISTABLE(0CINX)                           % INTERFACE PRESENT
052320                ELSE
052321                   BDISTABLE(0CINX); CALL FAR RFTMTABLE       % REMOVE FROM TIMER TABLE
052324                   A:=0                                       % DISK INTERFACE NOT PRESENT
052325                FI; A=:XA; MIN 0CINX
052327                BDISTABLE(0CINX)=:T SHZ -6; X:=CNVRT(A)
052335                A:=T/\77 SH 1+1; X+A                          % X=ADDR IN LOG.DEV.NO. TABLE
052342                A:=XA; T:=LOGDBANK; *STATX                    % UPDATE LOG.DEV.NO. TABLE
052345                MIN 0CINX; T:=IPIFPHPAGE SHZ 12=:D
052351                A:="ITB11"-"PITEX"+D+BDISTABLE(0CINX)-1=:X
052360                T:=IPIBANK; A:=XA; *STATX                     % UPDATE IDENT CODE TABLE
052363                MIN 0CINX
052364             ELSE
052365                0CINX+3=:0CINX
052370             FI
052370          OD
052371          GO MB2MT; *)FILL
052405   MB2MT:
052405          0=:0CINX
052406          DO AD:=DMTDITABLE(0CINX) WHILE A><-1
052413             IF A><0 OR A:=D><0 THEN                          % DATAFIELD EXISTS
052416                A=:X; A:=200; *TRR IIE; TRA IIC               % ENABLE FOR IOX-ERROR
052422                T:=X.HDEV+3; A:=20; *IOXT; TRA IIC            % CLEAR DEVICE AND CHECK FOR IOX-ERRORS
052427
052427   *"8FLMN      % DO NOT REMOVE DISK IF SINTRAN IF FOR FLOMEM
"052427                IF A=0 THEN                                   % INTERFACE EXISTS
052430                   T+"5-3"; *IOXT                             % WRITE COMMAND WHEN STC
052432                   A:=MT1MASK; *IOXT
052434                   A:=0; T+"2-5"; *IOXT                       % READ STATUS
052437                   IF A/\170040=170040 THEN
052443                      A:=MT2MASK; T:=X.HDEV+5; *IOXT          % WRITE COMMAND WHEN STC
052447                      A:=0; T+"2-5"; *IOXT                    % READ STATUS
052452                      IF A/\170040><40 GO NOTSTC              % NOT STC MAG.TAPE
052456                      X:=0CINX+1; MTDITABLE(X); CALL FAR RFTMTABLE
052462                      MTDITABLE(0CINX)                        % STC MAG.TAPE
052464                   ELSE
052465   NOTSTC:            MTDITABLE(0CINX); CALL FAR RFTMTABLE
052470                      X:=0CINX+1; MTDITABLE(X)                % CIPHER/PERTEC MAG.TAPE OR WINCHESTER DISC
052473                   FI
052473                ELSE
052474                   MTDITABLE(0CINX) CALL FAR RFTMTABLE
052477                   X:=0CINX+1; MTDITABLE(X); CALL FAR RFTMTABLE
052503                   A:=0;                                      % INTERFACE NOT PRESENT
052504                FI; A=:XA; 0CINX+2=:0CINX
052510                MTDITABLE(0CINX)=:T SHZ -6; X:=CNVRT(A)
052516                A:=T/\77 SH 1+1; X+A                          % X=ADDR IN LOG.DEV.NO. TABLE
052523                A:=XA; T:=LOGDBANK; *STATX                    % UPDATE LOG.DEV.NO. TABLE
052526                MIN 0CINX; T:=IPIFPHPAGE SHZ 12=:D
052532                A:="ITB11"-"PITEX"+D+MTDITABLE(0CINX)-1=:X
052541                T:=IPIBANK; A:=XA; *STATX                     % UPDATE IDENT CODE TABLE
052544                MIN 0CINX
052545              ELSE
052546                0CINX+4=:0CINX
052551              FI
052551          OD; GO XCLMT; *)FILL
052565
052565   *PL034=*
052565
052565   % CLEAR ALL UNUSED MAG.TAPE UNITS FROM LOG.NO TABLES AND TIMER TABLE
052565   XCLMT: "XMTTABLE"=:CSAVX
052567          DO WHILE CSAVX.S0><-1
052574             AD SHZ -6; X:=CNVRT(A); AD SH 6
052600             A/\77 SH 1+1; X+A; T:=LOGDBANK; *LDXTX
052606             IF X=0 OR X.TYPRING NBIT 5MT THEN              % NO MAG.TAPE
052612                CSAVX.S1; CALL FAR CLLOGENTRY; CSAVX.S2; CALL FAR CLLOGENTRY
052620                CSAVX.S3; CALL FAR CLLOGENTRY; CSAVX.S4; CALL FAR CLLOGENTRY
052626                CSAVX.S5; CALL FAR RFTMTABLE; CSAVX.S6; CALL FAR RFTMTABLE
052634                CSAVX.S7; CALL FAR RFTMTABLE; CSAVX.S10; CALL FAR RFTMTABLE
052642             FI; CSAVX+11=:CSAVX
052645          OD
052646
052646   *"8SCSI
"052646        CALL FAR SCOPS
052647   *"
"052647        GO FAR TPIOCS; *)FILL
052660
052660   *"8SCSI
"052660   %==============================================================================
052660   %        S C O P S
052660   %
052660   %
052660   % SCOPS : HANDLING OF SCSI DEVICES IN SINTRAN START
052660   %
052660
052660
052660   % ROUTINE TO UPDATE RESIDENT LOGICAL NUMBER TABLE
052660   % ENTRY: T = DEVICE NUMER, AD = DATAFIELD ADDRESSES
052660
052660   STDFA: T=:X SHZ -6:=:X SHZ 12 SHZ -11; X:=CNVRT(X)+T
052667          T:=LOGDBANK; *STDTX 10
052671          EXIT
052672   *)FILL
052674
052674   % ROUTINE TO CHECK IF CORRESPONDING HOST INTERFACE EXITS
052674   % ENTRY: A= DEVICE DATAFIELD ADDRESS
052674
052674   INTEGER POINTER SAVL
052675   INTEGER HIDFN
052676
052676   CHBDF: A.SCIDN SHZ -4=:HIDFN:=L=:"SAVL"     % HOST INTERFACE DEVICE NUMBER
052704          X:="SCBDF"
052705          DO WHILE X<<"SCDDF"
052710             IF X.S0=HIDFN THEN
052714                CALL LOGPH; GO SAVL            % CHECK INTERFACE
052716             FI
052716             WHILE X+2<<"SCDDF"
052722          OD
052723          "0"; GO SAVL
052725   *)FILL
052730
052730   TRIPLE ARRAY SCMUD(0)                       % MAGTAPE UNIT DATAFIELDS
052730          *   40; MTDI1; MTDO1
052733          *   32; M2DI1; M2DO1
052736          * 1232; M3DI1; M3DO1
052741          * 1225; M4DI1; M4DO1
052744
052744   INTEGER U, SAVR
052746   INTEGER POINTER HOME
052747
052747   SCOPS: A:=L=:"HOME"; "SCBDF"=:U
052753
052753          DO
052753             U.S0; CALL LOGPH; A=:SAVR   % CHECK DEVICE NUMBER
052757             IF X:=A><0 THEN
052761                200; *TRR IIE; TRA IIC         % ENABLE IOX ERRORS
052764                T:=X.HDEV+4; *IOXT; TRA IIC    % TEST INTERFACE
052770
052770   *"8FLMN                   % ALL SCSI GENERATED IN THE SINTRAN WILL BE PRESENT
"052770
052770                IF A><0 THEN
052771                   U.S0; CALL FAR CLLOGENTRY   % REMOVE DEVICE NUMBER
052774                   SAVR; CALL FAR RFTMTABLE    % REMOVE FROM TIMER TABLE
052776                   SAVR; CALL 11EIDCLEAR       % REMOVE FROM IDENT TABLE
053000                FI
053000             FI
053000             WHILE U+2=:U<<"SCDDF"
053006          OD
053007          "SCDDF"=:U
053011          DO
053011             IF U.S1><0 THEN                   % DATAFIELD GENERATED
053014                CALL FAR CHBDF                 % CHECK HOST INTERFACE
053015                IF A=0 THEN
053016                   U.S0; CALL FAR CLLOGENTRY   % REMOVE DEVICE NUMBER
053021                FI
053021             FI
053021             WHILE U+2=:U<<"SCTDF"
053027          OD
053030          DO
053030             WHILE U.S0>0; CALL LOGPH
053035             IF A=0 AND U.S1><0 THEN           % NOT IN USE AND GENERATED
053041                CALL FAR CHBDF                 % CHECK HOST INTERFACE
053042                IF A><0 THEN
053043                   T:=U.S0; X.S1; D:=0
053047                   CALL FAR STDFA              % DEFINE TAPE DATAFIELD
053050                   U-"SCTDF" SHZ -1*3
053054                   *1BANK
053055                   SCMUD(A)
053057                   *2BANK
053060                   CALL FAR STDFA              % DEFINE UNIT DATAFIELD
053061                FI
053061             FI
053061             U+2=:U
053064          OD
053065          GO HOME
053066   *)FILL
053102   *"
"053102
053102   TPIOCS:
053102   % CLEAR NON-EXISTING PIOCS FROM THE TIMER TABLE,
053102   % AND FROM THE EXTENDED IDENT-CODE-TABLE.
053102          0=:CSAVX
053103          DO AD:=PIOCS(CSAVX) WHILE A><-1
053110             IF A><0 THEN                           % PIOC DATAFIELD EXISTS
053111                AD=:XAD
053112                *1BANK; LDD I ,X (MMPIO; 2BANK
053115                IF A=0 AND D=0 THEN                 % PIOC INTERFACE NOT PRESENT
053120                   XA; CALL FAR RFTMTABLE
053122                   A:=MPIFPHPAGE SHZ 12=:D
053125                   A:="ITE12"-"PITEX"+D=:X
053131                   DO
053131                      T:=MPIBANK; *LDDTX
053133                   WHILE A><-1
053136                      IF D=XA THEN
053141                         T:=MPIBANK; *STZTX; STZTX 10   % CLEAR ENTRY IN EXTENDED IDENT CODE TABLE
053144                         GO NXPIOC
053145                      FI; X+2
053146                   OD
053147                FI
053147   NXPIOC:   FI; CSAVX+2=:CSAVX
053152          OD; GO XCHHDLC; *)FILL
053161
053161   *PL035=*
053161
053161   % CHECK ALL GENERATED HDLC'S
053161   XCHHDLC:
053161          "0HDTA"=:CSAVX                             % START OF HDLC CONFIG. TABLE
053163          DO WHILE X:=CSAVX<<"0HDEN"
053167             *1BANK
053170             IF X.NHDLC><0 OR X.SYNHDLC><0 THEN     % DATAFIELD EXISTS
053174                X.HDLCSELECTION=:L                  % L=HDLCSELECTION
053176                X.INTHDLC=:D; X.IDHDLC-1+"ITB13"-"PITEX"=:X
053205                *2BANK
053206                A:=MPIFPHPAGE SH 12; X+A; T:=MPIBANK
053212                A:=D; *STATX                         % UPDATE IDENT-CODE TABLE
053214                IF A><0 THEN
053215                   A:="ITB12"-"ITB13"+X=:D           % D=ADDR OF ENTRY IN ITB12-TABLE
053221                   X:=CSAVX; *1BANK
053223                   IF 1=L THEN X.NOHDLC ELSE X.SYNOHDLC FI
053231                   X:=D; *STATX; 2BANK               % UPDATE ITB12 ENTRY
053234                ELSE
053235                   A:="ITB12"-"ITB13"                % ENTRIES SHOULD BE CLEARED
053237                   X+A; A:=D; *STATX
053242                   X:=CSAVX; *1BANK
053244                   X.NHDLC; *2BANK
053246                   CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
053251                   AD:=X.DSYNHDLC=:X.2CDFCLTIMER
053253                   X.NOHDLC; *2BANK
053255                   CALL FAR RFTMTABLE
053256                FI; X:=CSAVX; *1BANK
053260                X.CDF1CLTIMER; *2BANK
053262                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK  % REMOVE FROM TIMER TABLE
053265                X.CDF2CLTIMER; *2BANK
053267                CALL FAR RFTMTABLE                   % REMOVE FROM TIMER TABLE
053270             FI; *2BANK
053271             CSAVX+TBLHDLCSIZE=:CSAVX
053274          OD; GO FAR XCHLPS; *)FILL
053305
053305   *PL036=*
053305
053305   % LOCAL SUBROUTINE TO UPDATE THE LOG.DEV.NO TABLE FOR A LINE-PRINTER
053305   %
053305   % ENTRY:     A=I/O-DF
053305   %            D=DMA-DF
053305   %            X=ADDR OF ENTRY IN LINE-PRINTER CONFIG.TABLE (0LPTA)
053305   %            CALLED IN 1BANK MODE
053305   %
053305   INTEGER CSVAA,CSVDD,CXXX1; DOUBLE CSVAD=CSVAA
053310   UPDLPLOGNO:
053310          AD=:CSVAD; X=:CXXX1
053312          IF X.LPLOGNO><0 THEN
053314             A=:D SHZ -6; *2BANK
053317             X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
053326             T:=LOGDBANK; A:=CSVAA; *STATX 10; STZTX          % LOG.NO.IN=0; LOG.NO-OUT=I/O-DF
053332             *1BANK
053333          FI
053333          IF CXXX1.LPDMLOGNO><0 THEN
053336             A=:D SHZ -6; *2BANK
053341             X:=CNVRT(A); A:=D/\77 SH 1+1; X+A
053350             T:=LOGDBANK; A:=CSVDD; *STATX; STZTX 10          % LOG.NO-IN=DMA-DF; LOG.NO-OUT=0
053354             IF A=0 THEN                                      % NOT "DMA-TYPE" LINE-PRINTER
053355                *STZTX 20; STZTX 30                           % CLEAR LOG.NO.TABLE ENTRY FOR "DF-DF"
053357             FI; *1BANK
053360          FI; EXIT
053361   *)FILL
053364   % CLEAR AN ENTRY IN EXTENDED IDENT CODE TABLE FOR LEVEL 11
053364   %
053364   % ENTRY:  A=DF.ADDR TO REMOVE FROM IDENT-CODE TABLE
053364   %
053364   11EIDCLEAR:
053364          IF A><0 THEN
053365             A=:D:="ITE11"-"PITEX"=:X
053371             A:=IPIFPHPAGE SHZ 12; X+A
053374             DO
053374                T:=IPIBANK; *LDATX 10
053376             WHILE A><-1                            % -1: END OF TABLE
053401                IF A=D THEN                         % ENTRY FOUND
053403                   T:=IPIBANK; *STZTX; STZTX 10     % CLEAR ENTRY
053406                   EXIT
053407                FI; X+2
053410             OD
053411          FI; EXIT
053412
053412   % LOCAL SUBROUTINE TO CLEAR A LINE-PRINTER FROM ALL TABLES
053412   %
053412   % ENTRY:  X=ADDR IN LINE-PRINTER DESCRIPTION TABLE (0LPTA)
053412   %         CALLED IN 1BANK MODE
053412   %
053412   INTEGER POINTER CLLPLREG
053413   INTEGER CXX1,CXX2
053415
053415   *PL037=*
053415
053415   CLLPENTRY: A:=L=:"CLLPLREG"
053417          X=:CXX1; *1BANK
053421          X.LPLOGNO; *2BANK
053423          CALL FAR CLLOGNENTRY; *1BANK              % CLEAR MAIN-DF FROM LOG.DEV.NO TABLE
053425          CXX1.LPDMLOGNO; *2BANK
053430          CALL FAR CLLOGENTRY; *1BANK               % CLEAR DMA-DF FROM LOG.DEV.NO TABLE
053432          CXX1.LPDMLOGNO+1; *2BANK
053436          CALL FAR CLLOGENTRY                       % CLEAR DF-DF FROM LOG.DEV.NO TABLE
053437          *1BANK
053440          CXX1+"LPDMDF"=:CXX2
053443          CXX2.S0; *2BANK
053446          CALL FAR RFTMTABLE; *1BANK                % REMOVE FROM TIMER TABLE
053450          CXX2.S1; *2BANK
053453          CALL FAR RFTMTABLE; *1BANK
053455          CXX2.S2; *2BANK
053460          CALL FAR RFTMTABLE; *1BANK
053462          CXX1+"LPIDENT"=:CXX2
053465          CXX1.1LPDMDF; *2BANK
053470          CALL 11EIDCLEAR; *1BANK                   % REMOVE FROM IDENT-CODE TABLE
053472          CXX2.S1; *2BANK
053475          CALL FAR 10IDCLEAR; *1BANK
053477          CXX2.S2; *2BANK
053502          CALL FAR 10IDCLEAR; *1BANK
053504          GO CLLPLREG                               % EXIT
053505   *)FILL
053515
053515   *PL038=*
053515
053515   INTEGER CSXXY,CLPSELECTION
053517   XCHLPS:
053517          "0LPTA"=:CSXXY; *1BANK
053522          DO WHILE CSXXY.LPSELECTION><-1
053527             IF X.LPCLENTRY><0 THEN
053531                CALL CLLPENTRY; GO NXTLP                      % CLEAR ALL TABLE-ENTRIES FOR THIS L-P
053533             FI
053533             IF CSXXY.LPSELECTION=3 THEN
053540                A:=0                                          % NO DMA-DF
053541             ELSE
053542                A-1+"LPDMDF"; X+A; X.S0                       % DMA-DF
053546             FI
053546             A=:D:=CSXXY.LPSELECTION
053551             A-1+"LPIODF"; X+A; X.S0
053555             X:=CSXXY
053556             CALL FAR UPDLPLOGNO                              % UPDATE LOG.DEV.NO TABLE
053557             IF CSXXY.LPSELECTION=1 THEN                      % "DMPR-TYPE" PRINTER
053564                X.2LPIDENT; *2BANK
053566                CALL FAR 10IDCLEAR                            % CLEAR ENTRY IN LEVEL 10 IDENT-CODE-TABLE (ITB10)
053567             ELSE
053570                T:=X.2LPIDENT; A-1+"LPDMDF"; X+A; X.S0=:D
053576                "ITB10"-"PITEX"=:X; *2BANK
053602                A:=MPIFPHPAGE SH 12; X+A+T-1                  % X=ADDR IN IDENT-CODE-TABLE (ITB10)
053607                T:=MPIBANK; A:=D; *STATX; 1BANK               % UPDATE IDENT-CODE TABLE
053613                CSXXY.1LPDMDF; *2BANK
053616                CALL FAR 11EIDCLEAR                           % CLEAR "DMPR-TYPE" L-P FROM EXTENDED-IDENT-CODE-TABLE
053617             FI; *1BANK
053620             1=:CLPSELECTION
053622             DO WHILE CLPSELECTION<<=3
053626                IF CLPSELECTION><CSXXY.LPSELECTION THEN
053633                   A-1+"LPDMDF"; X+A; X.S0; *2BANK            % A=DMA-DF
053640                   CALL FAR RFTMTABLE; *1BANK                 % REMOVE FROM TIMER TABLE
053642                FI; MIN CLPSELECTION
053643             OD
053644   NXTLP:    CSXXY+LPTBSIZE=:CSXXY
053647          OD; *2BANK
053651          GO TDMVC; *)FILL
053663
053663   TDMVC: X:="0DMVT"
053664          DO
053664             X=:CSAVX
053665             *1BANK
053666          WHILE X.DMVSELECTION><-1
053672             IF A><0 THEN                                     % VERSATEC CAN BE USED
053673                IF X.DMVDATFADDR><0 THEN                      % DATAFIELD EXISTS
053675                   A:=200; *TRR IIE; TRA IIC
053700                   T:=X.DMVHDEV+4; *IOXT; TRA IIC
053704                   IF A=0 THEN                                % INTERFACE IS PRESENT
053705                      X.DMVIDENT=:L; X:=X.DMVDATFADDR=:D; *2BANK
053712                      T-4=:X.HDEV                             % UPDATE HDEV IN DATFIELD
053714                      IF L<<"MAX11" THEN
053717                         "ITB11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12
053724                         X+A+L-1; T:=IPIBANK; A:=D; *STATX    % UPDATE IDENT CODE TABLE
053732                      ELSE
053733                         "ITE11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12; X+A
053741                         DO
053741                            T:=IPIBANK; *LDATX
053743                            IF A=-1 GO CLVERS
053746                            IF A=0 THEN
053747                               A:=L; T:=IPIBANK; *STDTX
053752                               GO SCODFF
053753                            FI; X+2
053754                         OD
053755   SCODFF:            FI; X:=D
053756                      IF DVBFPAGE><0 THEN
053760                         *LDA -110,B; SWAP SA CLD DD
053762                         AD SH 12; T:=1770; D+T
053765                         T:=X.CODFF; *DEPO
053767                      ELSE
053770                         A:=X+"CODFF"=:D:=DPITBANK
053774                      FI; AD=:X.VCODFFADDR                    % UPDATE ADDR OF FORM-FEED
053775                      GO NXVERS
053776                   FI
053776                FI
053776             FI; GO CLVERS; *)FILL
054010
054010   *PL039=*
054010
054010   CLVERS:   *2BANK
054011             X:=CSAVX; *1BANK
054013             X.DMVDATFADDR; *2BANK
054015             CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054020             X.DMVDLOGNO; *2BANK
054022             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054025             X.DMVDFLOGNO; *2BANK
054027             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054032             X.DMVIOLOGNO; *2BANK
054034             CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054037             X.DMVIDENT; *2BANK
054041             CALL FAR 11IDCLEAR
054042   NXVERS:   *2BANK
054043             X:=CSAVX+TBLVERSATEC
054045          OD; *2BANK
054047          IF MXX21<<"0NX21" THEN                    % GENERATED MORE X21 THAN WANTED TO USE
054053             A*TBLX21SIZE+"CX21TABLE"=:CSAVX
054056             DO WHILE CSAVX.S0><-1
054063                CALL FAR RFTMTABLE                  % REMOVE FROM TIMER TABLE
054064                CSAVX.S1; CALL FAR CLLOGENTRY        % REMOVE FROM LOGICAL NUMBER TABLE
054067                CSAVX+TBLX21SIZE=:CSAVX
054072             OD
054073          FI; GO SSPODEV; *)FILL
054102
054102   *PL040=*
054102
054102   % SET SPOOLING DEVICE NUMBER IN SPOOLING-DATAFIELD ACCORDING TO
054102   % THE VALUES SET UP IN SPOOLING-CONFIG.TABLE (0SPTA)
054102   SSPODEV:
054102          0=:0CINX; "SPTAB"=:CSAVX
054105          DO WHILE 0CINX><MXSPOOLERS AND CSAVX><"COSDA"+1
054116             "0SPTA"+0CINX=:X; *1BANK; LDA ,X; 2BANK
054124             IF A><0 THEN
054125                A=:CSPERI; AD SHZ -6
054127                IF A<<=LGDGMAX THEN
054132                   X:=CNVRT(A)
054134                   IF X >< 0 THEN
054135                     AD SH 6; A/\77+A; X+A+1; T:=LOGDBANK; *LDDTX % D=OUTPUT DF
054143                     IF D><0 THEN
054145                        IF T:=D.TYPRING BIT 5TERM AND T:=X.ZTINFO NBIT 5PCONN THEN
054154                           X:=A; CALL CLBCKTABENTRY            % REMOVE FROM BACKGROUND TABLE
054156                           T:=X.ZDBPROG; 0=:X.ZDBPROG    % CLEAR DBPROG BECAUSE OF TERMINAL TIMER ROUTINE
054160                           IF "BPTMP"=0 THEN
054162                              T.STATUS BONE 5RTOFF=:X.STATUS  % SET DBPROG RTOFF
054166                           FI
054166                        FI
054166                     FI; CSPERI=:CSAVX.SPERI
054171                   FI
054171                FI
054171             FI; MIN 0CINX; CSAVX+SPLEN=:CSAVX
054175          OD; GO CLSYMODEM; *)FILL
054210
054210   % CLEAR UNUSED SYNC-MODEM ENTRIES
054210   CLSYMODEM: 0=:0CINX
054211          DO
054211             0CINX*TBLSYMSIZE+"0SYMTABLE"=:CSAVX=:X; *1BANK
054217          WHILE X.SYMSELECTION><-1
054223             IF X.SYMCLENTRY><0 THEN
054225                X.SYMIDFELT; *2BANK
054227                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054232                X.SYMODFELT; *2BANK
054234                CALL FAR RFTMTABLE; X:=CSAVX; *1BANK
054237                X.SYMLOGNO; *2BANK
054241                CALL FAR CLLOGENTRY; X:=CSAVX; *1BANK
054244                X.SYMCIDENT; *2BANK
054246                CALL FAR 10IDCLEAR; X:=CSAVX; *1BANK
054251                X.SYMCIDENT; *2BANK
054253                CALL FAR 12IDCLEAR
054254             FI; *2BANK
054255             MIN 0CINX
054256          OD; *2BANK
054260          GO CLUDMA; *)FILL
054267
054267   *PL041=*
054267
054267   % SUBROUTINE TO TEST IF AN UDMA-TYPE INTERFACE IS PRESENT
054267   % IF PRESENT THEN EXIT ELSE EXITA FI
054267   CCIOXTER:
054267          A:=200; *TRR IIE; TRA IIC; IOXT; TRA IIC
054274          IF A=0 THEN EXIT FI
054276          EXITA
054277
054277   CLUDMA:
054277          "TBUDMA"=:0CINX
054301          DO
054301             X:=0CINX; *1BANK; LDA ,X
054304          WHILE A><-1                                         % -1: END OF TABLE
054307             IF A><0 THEN                                     % DATAFIELD EXISTS
054310                *2BANK
054311                CALL FAR 11EIDCLEAR                           % REMOVE FROM IDENT CODE TABLE
054312                X:=0CINX; *1BANK
054314                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT NORMAL UDMA?
054320                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT VICOM?
054324                X+2; T:=X.S0; CALL CCIOXTERR; GO UDMOK        % IS IT RTAMTEC
054330   NOUDMA:      *2BANK                                        % INTERFACE DOES NOT EXIST
054331                X:=0CINX; *1BANK; LDA ,X; 2BANK
054335                CALL FAR RFTMTABLE                            % REMOVE FROM TIMER TABLE
054336                X:=0CINX; *1BANK; LDA 1,X; 2BANK
054342                CALL FAR CLLOGENTRY                           % REMOVE FROM LOG.NO.TABLE
054343                GO NXUDMA
054344
054344   UDMOK:       X.S1=:L; *LDA ,X; 2BANK                       % L=IDENT CODE
054350                X:=0CINX; *1BANK; LDX ,X; 2BANK
054354                *COPY SX DD; STA ,X HDEV                      % D=DATAFIELD
054356                "ITE11"-"PITEX"=:X; A:=IPIFPHPAGE SH 12; X+A
054364                DO
054364                   T:=IPIBANK; *LDATX
054366                   IF A=-1 GO NOUDMA                          % END OF ITE11
054371                   IF A=0 THEN                                % FREE ENTRY
054372                      A:=L; T:=IPIBANK; *STDTX                % INSERT IN ITE11
054375                      GO NXUDMA
054376                   FI; X+2
054377                OD
054400             FI
054400   NXUDMA:   *2BANK
054401             0CINX+TUDMSIZE=:0CINX
054404          OD; *2BANK
054406          GO INTDFIELDS; *)FILL
054416
054416   *PL042=*
054416
054416   % COMPUTE THE NUMBER OF DAYS IN FEBRUARY THE YEAR THE SYSTEM
054416   % IS GENERATED
054416   INTDFIELDS:
054416          GENDA(4)-PTBASE(X); D:=0
054422          DO WHILE A>0
054424             A-1; IF D+1>3 THEN D:=0 FI
054432          OD; IF D=1 THEN 35 ELSE 34 FI; A=:CCFEB
054442          X:=GENDA(3)-1; A:=DAMO(X)+1-=:MND
054451          A:=200; *TRR IIE; TRR IIC
054454          A:=10; *TRR ECCR; TRA IIC
054457          IF A><0 THEN
054460             0=:TCNTI
054461          ELSE
054462             A:=4; *TRR ECCR
054464          FI; A:=0; *TRR IIE; TRA PGS; TRA PEA; TRA IIC
054471          GO L0; *)FILL
054477
054477   L0:
054477          A:=-1; FOR X:=0 TO 37 DO A=:DFTBIT(X) OD
054507          A:=TDLPHPAGE-TDFPAGE+1*4=:D:=0; T:=20; *RDIV ST
054517          X:=0; DO WHILE X><A; 0=:DFTBIT(X); X+1 OD
054525          A:=-1; T:=174005
054527          DO WHILE D><0
054531             *EXR ST
054532             D-1; T+10
054534          OD; A=:DFTBIT(X)
054536          4=:GPART; GO STLOP; *)FILL
054543
054543   *PL043=*
054543
054543   STLOP: "TIOBU"=:"CINDADDR"
054545   LOOP:  X:="CINDADDR"; *1BANK; LDF ,X; 2BANK
054551          TAD=:CTIOBENTRY
054552          IF A=-1 THEN
054555             GPART -1=:GPART
054560             IF A=0 GO RETU
054561             GO STLOP
054562          FI
054562          "CINDADDR"+3=:"CINDADDR"
054565          AD:=TBUSZ; A+D+TDISIZ+TDOSIZ; T:=0; DO A-400; T+1; WHILE A>0 OD
054577          IF T>A:=4 THEN CALL ERRFATAL FI
054603          IF GPART><T GO LOOP
054606          IF TRLND=0 GO LOOP
054610          TRLND; CALL LOGPH; IF A=0 THEN CALL ERRFATAL FI
054614          A=:0DFADDR
054615          DFTINDX=:DFTEND; GPART=:L
054621   DLOOP: DFTBIT(DFTINDX)=:DFTELM
054624          IF A><-1 THEN
054627             T:=175005; 0=:FREBIT=:BTNUM
054632             FOR X:=-20 DO
054633                A:=DFTELEM; *EXR ST
054635                GO NTFBIT; MIN FREBIT
054637                IF FREBIT=L THEN
054642                   X=:CSAVX:=4; A:=BTNUM=:D:=0; *RDIV SX
054650                   IF D+1>=L THEN
054653                      A=:X:=DFTINDX*4+X
054657                      A SH 2 ; D-L ; A+D=:L
054663                      BTNUM SHZ 3; T:=174205; T+A; DFTELM
054670                      FOR X:=FREBIT- DO; *EXR ST
054673                        T-10
054674                      OD
054675                      A=:DFTBIT(DFTINDX)
054677                      A:=L; CALL FAR MAKETDFS; GO LOOP
054702                   FI
054702                   A:=D=:FREBIT; X:=CSAVX
054705                FI; GO FBIT
054706   NTFBIT:      0=:FREBIT
054707   FBIT:        T+10; MIN BTNUM
054711             OD
054712          FI
054712          IF DFTINDX+1=40 THEN "0" FI; A=:DFTINDX
054721          IF A=DFTEND THEN CALL ERRFATAL FI
054725          GO DLOOP; *)FILL
054736
054736   *PL044=*
054736
054736   INTEGER XBONE(0); *BSET ONE DX
054737   RETU:  FOR X:=0 TO 17 DO     % ALL FOUND MEMORY IS INITALLY SET TO MPM5 MEMORY
054743             IF TMMAP(X)><0 THEN
054745                X=:CSAVX; A=:XA:=X SH 12=:CURRPAGE
054752                FOR X:=-20 DO
054753                   IF XA BIT "0" THEN               % MEMORY BANK EXSIST
054756                      T:=KMPM5; A:=CURRPAGE; CALL SMEMTYPE
054761                   FI; XA SHZ -1=:XA
054764                   CURRPAGE+100=:CURRPAGE
054767                OD; X:=CSAVX
054771             FI
054771          OD
054773          0=:MEMTYPE
054774          A:=200; *TRR IIE; TRA IIC
054777   *"8BEX1
"054777          T:=100000; *IOXT; TRA IIC
055002          IF A=0 THEN MEMTYPE BONE BBEXPANDER=:MEMTYPE FI
055006   *"
"055006          *IOX 750; TRA IIC
055010          IF A=0 THEN MEMTYPE BONE BMPM3=:MEMTYPE FI
055014          A:=4; T:=100115; *IOXT; TRA IIC
055020          IF A=0 THEN MEMTYPE BONE BMECCR=:MEMTYPE FI
055024   *"8MPM4
"055024          0=:NBUSCN; 0=:XA
055026          FOR NBUSCN TO 17 DO
055032             A:=NBUSCN*4+100200=:T; *IOXT; TRA IIC
055040             IF A=0 THEN
055041                NBUSCN SH 3+XBONE; X:=XA
055045                *EXR SX                                % BSET BONE XX DD
055046                X=:XA
055047                MEMTYPE BONE BMPM4=:MEMTYPE
055052                T+3; A:=100; *IOXT                      % ENABLE READ LIMITS
055055                T-3; *IOXT                              % READ LIMITS
055057                A=:D/\377 SH 6:=:D SHZ -10 SH 6:=:D
055066                IF A><D THEN D-1 ELSE A:=0; D:=0 FI     % TEST FOR EMPRY MPM4 PORT
055074             ELSE
055075                A:=0; D:=0
055077             FI; X:=NBUSCN+X; AD=:DMPM4(X)
055102          OD; XA=:NBUSCN
055110          GO MMMM4; *)FILL
055124   MMMM4:
055124   *"8MPM4
"055124          IF MEMTYPE NBIT BMPM4 THEN
055127             T:=MPIFPHPAGE SH 12
055131             A:="ITB13"-"PITEX"+17+T=:X+20=:D; T:=MPIBANK
055141             DO WHILE X<<D
055143                *STZTX; AAX 1
055145             OD
055146          FI
055146   *"
"055146
055146   *PL045=*
055146          IF MEMTYPE BIT BMPM3 THEN CALL MPM3MAP FI
055152          IF MEMTYPE BIT BMPM4 OR A BIT BMECCR THEN CALL MPM4MAP FI
055160          X:=0
055161          DO WHILE X<<50                  % DEFINE PIOC-MEMORY
055164             *1BANK
055165             AD:=MMPIOCS(X)
055166             *2BANK
055167             IF A><0 THEN
055170                A=:CURRPAGE:=D=:NPAGES
055173                DO WHILE CURRPAGE<<=NPAGES
055177                   A:=CURRPAGE; T:=KMPIOC; CALL SMEMTYPE
055202                   CURRPAGE+100=:CURRPAGE
055205                OD
055206             FI; X+2
055207          OD; GO SMPM4MEM; *)FILL
055220   SMPM4MEM:
055220   *"8MPM4
"055220          0=:XA
055221          FOR XA TO 17 DO
055225             X:=XA+X; AD:=DMPM4(X); A=:CURRPAGE:=D=:NPAGES
055233             DO WHILE CURRPAGE<<NPAGES
055237                A:=CURRPAGE; T:=KMPM4; CALL SMEMTYPE
055242                CURRPAGE+100=:CURRPAGE
055245             OD
055246          OD
055252   *"
"055252          GO FN5MEM; *)FILL
055255
055255   *PL046=*
055255
055255   FPMPMPAGE: K:="0"; GO FMPMFELLS                  % FIND FIRST PAGE IN MPM MEMORY
055257   LPMPMPAGE: K:=1                                  % FIND FIRST PAGE NOT IN MPM MEMORY
055260   FMPMFELLS:
055260          A=:D
055261          DO WHILE D<<ENDPAGE
055264             A:=D SHZ -7+MEMARRAY=:X; T:=MBMEMARRAY; *LDATX
055272             IF D BIT 6 THEN A/\377 ELSE A SHZ -10 FI
055277             IF A=KMPM3 OR A=KMPM4 OR A=KMPM5 THEN
055310                IF K NBIT THEN A:=D; EXITA FI                    % FIRST PAGE IN MPM PART
055314             ELSE
055315                IF K THEN A:=D; EXITA FI                         % FIRST PAGE IN NOT-MPM PART
055321             FI; A:=100; D+A
055323          OD; A:=D; EXIT
055326          *)FILL
055332
055332   FN5MEM:
055332          A:=0; CALL FPMPMPAGE; A:=-1; A=:FPIMPM                 % DETERMINE FIRST PAGE IN MULTIPORT
055336          IF X:=PN500D><0 AND X.ADRZERO=-1 THEN                  % MEMORY NOT DEFINED FOR ND-500
055344             0=:0CINX; 0=:CURRPAGE
055346             DO WHILE 0CINX<20                                   % 20 IS MAX MERMORY PARTS
055352                CURRPAGE; CALL FPMPMPAGE; GO FMPM5; A=:CURRPAGE  % FIRST MPM PAGE IN MEMORY PART
055356                IF PN500D.ADRZERO=-1 THEN CURRPAGE=:X.ADRZERO FI % ND-500 PAGE ZERO
055365                CURRPAGE-X.ADRZERO; T:=0CINX; *AAX AMEMT         % START OF MEMORY PART
055371                X+T; A=:X.S0; PN500D+"TYPMTAB"=:T
055376                A:=7; X:=0CINX; *SBYT                            % MEMORY PART TYPE
055401                MIN 0CINX
055402                CURRPAGE; CALL LPMPMPAGE; P+0; A=:CURRPAGE       % FIRST PAGE IN NEXT MEMORY PART
055406                A-PN500D.ADRZERO; T:=0CINX; *AAX AMEMT
055412                X+T; A=:X.S0; PN500D+"TYPMTAB"=:T
055417                A:=0; X:=0CINX; *SBYT                            % MEMORY PART TYPE (NOT MPM MEMORY)
055422                MIN 0CINX
055423             OD
055424          FI
055424   FMPM5: X:=MEMARRAY; A:=X+200=:D
055430          DO WHILE X<<D
055432             T:=MBMEMARRAY; *LDATX
055434             IF A SHZ -10=KMPM5 GO SMPM5
055440             T:=MBMEMARRAY; *LDATX
055442             IF A/\377=KMPM5 GO SMPM5
055446             X+1
055447          OD; GO MEMFINE
055451   SMPM5: MEMTYPE BONE BMPM5=:MEMTYPE
055454          GO MEMFINE; *)FILL
055465
055465   *PL047=*
055465
055465   MEMFINE:
055465          A:=RTSGFPHPAGE=:RTSYSG              % FIRST FPHYS.PAGE IN RT'S SYS.SEG
055467          A:=CDABLPAGE+XXSWTYPE=:D:=0; AD=:DDASA
055474          A:="9ESGT"=:D:=0; T:=5SEGSIZE; *RDIV ST
055501          A-1=:SGMAX
055503          5FILSEG*5SEGSIZE+SEGSTART=:FILSEGM
055507   *"8FLMN
"055507          55MOSEG*5SEGSIZE+SEGSTART=:5NSEGM
055513   *"8RFAC
"055513          5FIUS  *5SEGSIZE+SEGSTART=:FUSEGM
055517   *"
"055517   % INITIALIZE ALL BACKGROUND PROGRAMS WITH SYSTEM SEGMENT AND OP.COM SEGMENT
055517          CFSYSEG=:D
055521          X:="9FBPR"
055522          DO WHILE X<<="9LBPR"-5RTSIZE
055526             A:=5OPSEG; AD=:X.DSEGM; D+1; D+1
055532             X+5RTSIZE
055533          OD
055534
055534   *PL048=*
055534
055534   % BUILD SEGMENTS.
055534
055534          AD:=ECODPHPAGE; T:=5ECOM; CALL FAR SGBUILD
055537          AD:=RPIDPHPAGE; T:=5RPIT; CALL FAR SGBUILD
055542          AD:=MPIDPHPAGE; T:=5MPIT; CALL FAR SGBUILD
055545          AD:=IPIDPHPAGE; T:=5IPIT; CALL FAR SGBUILD
055550          AD:=DPIDPHPAGE; T:=5DPIT; CALL FAR SGBUILD
055553          AD:=DEDPHPAGES; T:=42; CALL FAR SGBUILD
055556          AD:=5PIDPHPAGES; T:=55PIT; CALL FAR SGBUILD
055561   *"8FLMN
"055561          GO DOCOMPRESS; *)FILL
055576
055576   INTEGER POINTER TMTCLREG
055577   TMTCOMPRESS: A:=L=:"TMTCLREG"
055601          DO WHILE X<<TMRADDR
055604             T:=RPIBANK; *LDATX
055606             IF A=0 THEN
055607                A:=ETMRADDR; CALL COMPTMRTABLE
055611                TMRADDR-1=:TMRADDR
055614             ELSE
055615                X+1
055616             FI
055616          OD; GO TMTCLREG
055620
055620   *PL049=*
055620
055620   DOCOMPRESS:
055620   % COMPRESS THE EXTENDED-IDENT-CODE TABLES
055620          X:="ITE10"; CALL FAR EIDCMPIT
055622          X:="ITE11"; CALL FAR EIDCIPIT
055624          X:="ITE12"; CALL FAR EIDCMPIT
055626          X:="ITE13"; CALL FAR EIDCMPIT
055630
055630   % COMPRESS THE FIRST PART OF THE TIMER TABLE
055630          A:=RPIFPHPAGE SHZ 12=:D
055633          "M1TMR"-"PITEX"+1+D=:X
055640          "9SXTD"-"PITEX"-1+D=:ETMRADDR
055645          "8USTM"-"PITEX"+D=:TMRADDR
055651          CALL TMTCOMPRESS
055652
055652   % COMPRESS THE LAST PART OF THE TIMER TABLE
055652          A:=RPIFPHPAGE SHZ 12=:D
055655          "9SXTD"-"PITEX"+1+D=:X
055662          "ETMRT"-"PITEX"+D=:ETMRADDR=:TMRADDR
055667          CALL TMTCOMPRESS
055670
055670   % CHANGE CLEAR-CACHE INSTRUCTION WITH "RAND 0 0"
055670          IF HWINFO(0)/\ 377 >=3  THEN        % ND-110/CX , ND-120/CX
055676             "PITEX"=:L; MPIFPHPAGE SH 12=:D
055703             D-L; 0=:0CINX
055705             DO WHILE X:=CCMPIT(0CINX)><-1
055712                IF X><0 THEN
055713                   X+D; T:=MPIBANK; *LDA (RAND; STATX
055717                FI; MIN 0CINX
055720             OD; RPIFPHPAGE SH 12=:D
055724             D-L; 0=:0CINX
055726             DO WHILE X:=CCRPIT(0CINX)><-1
055733                IF X><0 THEN
055734                   X+D; T:=RPIBANK; *LDA (RAND; STATX
055740                FI; MIN 0CINX
055741             OD
055742          FI; GO UPDMICP; *)FILL
055764
055764   *PL050=*
055764
055764   UPDMICP:
055764
055764   % UPDATE THE SEGMENT ADMINISTRATION WITH THE ALTERNATIVE ROUTINES
055764   % IF THIS CPU HAS THE NEW "K-VERSION MICRO PROGRAM"
055764          IF HWINFO(0)/\377 >=3 THEN             % ND-110/CX , ND-120 OR LATER VERSION
055772             T:=MPIFPHPAGE SHZ -6                % MEMORY BANK FOR MPIT
055774             "PITEX"=:L; MPIFPHPAGE/\77 SH 12=:D
056002             D-L
056003             0=:0CINX
056004             DO WHILE X:=VSXMMICP(0CINX)><A:=-1
056011                IF X >< 0 THEN
056012                    X+D; *LDA (RAND; STATX
056015                FI
056015                MIN 0CINX
056016             OD
056017             T:=IPIFPHPAGE SHZ -6                % MEMORY BANK FOR IPIT
056021             "PITEX"=:L; IPIFPHPAGE/\77 SH 12=:D
056027             D-L
056030             0=:0CINX
056031             DO WHILE X:=VSXIMICP(0CINX)><A:=-1
056036                IF X >< 0 THEN
056037                    X+D; *LDA (RAND; STATX
056042                FI
056042                MIN 0CINX
056043             OD
056044          FI
056044          GO SETPTABL
056045   RBUS
056053
056053   SUBR MAKETDFS
056053   %=============================================================================
056053   %            M A K E T D F S       M A K T A D D F
056053   %
056053   % LOCAL SUBROUTINES TO THE INTDFIELDS ROUTINE
056053   %
056053   % MAKEDFS:   CREATES TERMINAL DATAFIELDS OUTSIDE RESIDENT
056053   %            0DFADDR= RESIDENT DATAFIELD ADDR
056053   %            L= DISPLACEMENT OF DATAFIELD RELEATIVE TO START OF DATAFIELD AREA
056053   %            CTIOBENTRY= CURRENT TIOBTAB ENTRY
056053   %
056053   % MAKTADDF:  CREATES TAD DATAFIELDS OUTSIDE RESIDENT
056053   %            X-REG = RESIDENT DATAFIELD, T-REG = TAD INDEX
056053   %
056053
056053   INTEGER IDFTFLAG=?,ODFTFLAG=?,IZPAIRDF=?,OZPAIRDF=?
056053
056053       INTEGER SVA
056054       INTEGER SVD
056055       DOUBLE  SVDD=SVA
056055
056055   MAKETDFS: A:=:L=:"CLINK"
056057          A:=TDFPAGE=:D:=0; AD SHZ 12
056063          AD =: SVDD ; L=:D    ; A:=0
056066          AD SH 10   ; A:=:D   ; A+SVD
056071          A:=:D      ; A:=A+C  ; A+SVA
056074          AD=:CDDMADDR                                  % CDDMADDR=PHYS. ADDR. OUTSIDE RESIDENT
056075          FOR X:="XTDFELT" TO "XEDFELT"-1 DO 0=:X.S0 OD % CLEAR WORKING AREA
056105   %
056105   %      INITIALIZE INPUT DF OUTSIDE RESIDENT
056105   %
056105          0DFADDR=:B; IF TYPRING NBIT 5TERM THEN CALL ERRFATAL FI
056113          X:="XTDFELT"+TDINDI; *LDA ,B ZTINF+9CXTI
056116          A=:X.TINFO; IF A NBIT 5PRINT THEN T:=ZDBPROG=:X.DBPROG FI
056123          T:="TTGET"=:X."IOTRANS"; T:="TEXIT"=:X."STDEV"
056127          T:="CTRTI"=:X."SETDV"; "0" BONE 5LBLOG=:X.FLAGB        % ALWAYS LOGOUT ON MISSING CARRIERE
056134          HDEV=:X.HDEV; ZCESCP=:X.CESCP; ZDFLAG=:X.DFLAG
056142          -1=:X.RSISTE; ZROUSPEC=:X."ROUSPEC"; ZCTTYP=:X.CTTYP
056150          "ECH0"=:X.ECHOTAB; "BRK0"=:X.BRKTAB; 5TMR=:X.TMR=:X.TTMR
056157          TYPRING=:X.TYPRING; A:=B=:X.TDRADDR
056163          "SBFIELD"=:B
056165          A:=2CDDMADR/\1777+"WND41*2000"+TDISIZ+BINSZ+TDONDI=:X.DFOPP
056174          TDIPDI+1+BINSZ+TDONDI=:X.XOPPDF
056201          A:=2CDDMADR/\1777+TDISIZ=:X.BUFST
056205          BINSZ+BINSZ=:X.MAX=:X.CFREE
056211          0DFADDR=:B+"9CXTI"=:X.XDFOPP
056215   *IFILL
056231   %
056231   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056231   %
056231          *LDA ,B ZDFTY+9CXTI
056232          A=:IDFTFLAG GOSW ITRM,ITFX,ITFX,INTS,IMTA
056241   *)FILL
056241   ITRM:  "TYENT"=:X."DRIVER"; "STTIN"=:X."STDRIV"
056245          "TTIMR"=:X."TMSUB"
056247          ZXONOFCR/\377=:X.XONCR; ZXONOFCR SHZ -10=:X.XOFCR
056255          ZTSPEED=:X.TSPEED; ZCNTREG=:X.CNTREG
056261          GO MOVI
056262   ITFX:  T:=ZPAIRDF=:X.PAIRDF=:IZPAIRDF
056265          IF A=1 THEN
056270             "ERRFATAL"=:X."STDRIV"
056272             "TFRSTDEV"=:X."TMSUB"=:X."STDEV"
056275             "TFRSETDV"=:X."SETDV"; "TFRGET"=:X."IOTRANS"
056301          ELSE
056302             "TFINPUT"=:X."STDRIV"; "TEXIT"=:X."TMSUB"
056306          FI
056306          GO MOVI
056307   INTS:  *LDA ,B 9CXTI                                      % WINDOW ADDRESS
056310          A=:X.MNWAD; *LDA ,B 9CXTI+2                        % CONTROLLER ADDRESS
056312          A=:X.MNCDF:=0=:X.MNTMFL=:X.TMR=:X.TTMR
056317          "MNITI"=:X."TMSUB"; "MNINS"=:X."STDRIV"
056323          "MNMAI"=:X."DRIVER"
056325          X.FLAGB BONE 5LSTA=:X.FLAGB
056330          GO MOVI
056331   IMTA:  BMTDFLI=:X.MTDFLI; A:=B=:BMTDFLI                 % LINK DF
056335          0=:X.MTMBPH; 1=:X.MTFLAG
056340          "MTITI"=:X."TMSUB"; "MTINS"=:X."STDRIV"
056344          "MTIND"=:X."DRIVER"
056346          0=:X.TMR=:X.TTMR; X.FLAGB BONE 5LSTA=:X.FLAGB
056353   MOVI:  "SBFIELD"=:B
056355          X:=1CDDMADR; T:=2CDDMADR; A:=TDISIZ=:L:="XTDFELT"=:D:=0; *MOVAP
056365          GO RDFI
056366   *)FILL
056411   INTEGER IDFTFLAG,IZPAIRDF
056413   %
056413   %      INITIALIZE INPUT RESIDENT DF
056413   %
056413   RDFI:  A:=2CDDMADR+TDINDI=:0DFADDR.TDFLGADDR
056417          AD:=CDDMADR SHZ -12; A:=D=:X.TDFPHPAGE
056423          0=:X.RESLINK=:X.RTRES; X=:X.BWLINK; 0=:X.ISTATE=:X.MLINK
056430   %
056430   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056430   %
056430          IDFTFLAG GOSW IRTR,IRTF,IRTF,IRNT,IRMT
056437   *)FILL
056437   IRTR:  "STTIN"=:X."STDRIV"; "TYENT"=:X."DRIVER"
056443          GO OUTPUT
056444   IRTF:  T:=IZPAIRDF=:X.PAIRDF
056446          IF A=1 THEN "ERRFATAL" ELSE "TFINPUT" FI; A=:X."STDRIV"
056455          GO OUTPUT
056456   IRNT:  T:="MNINS"=:X."STDRIV":="MNMAIN"=:X."DRIVER"
056462          GO OUTPUT
056463   IRMT:  T:="MTINS"=:X."STDRIV":="MTIND"=:X."DRIVER"        % DRIVER ADDRESSES IN RES. OUTP. DF
056467   *IFILL
056500   OUTPUT:
056500          FOR X:="XTDFELT" TO "XEDFELT" DO 0=:X.S0 OD            % CLEAR WORKING AREA
056507          0DFADDR+"9CXTI"=:B
056512          IF TYPRING NBIT 5TERM THEN CALL ERRFATAL FI
056516          X:="XTDFELT"+TDONDI
056520   %
056520   %      INITIALIZE OUTPUT DF OUTSIDE RESIDENT
056520   %
056520          "TTOMR"=:X."TMSUB"; "DMOUT"=:X."STDEV"
056524          "0" BONE 5EMPT=:X.BITFLAG; -10=:X.TTMR
056531          HDEV=:X.HDEV; "TRTPUT"=:X."IOTRANS"; "CTRTO"=:X."SETDV"
056537          TYPRING=:X.TYPRING
056541          "SBFIELD"=:B
056543          A:=2CDDMADR/\1777+"WND41*2000"+TDINDI=:X.DFOPP
056550          TDIPDI+1+BINSZ+TDONDI-=:X.XOPPDF
056556          A:=2CDDMADR/\1777+TDISIZ+TDOSIZ+BINSZ=:X.BUFST
056564          BOUSZ+BOUSZ=:X.MAX=:X.CFREE SHZ -1=:X.MINBHOLD
056572          0DFADDR+"9CXTI"=:B=:X.TDRADDR; A-"9CXTI"=:X.XDFOPP
056600   *IFILL
056613   %
056613   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056613   %
056613          ZDFTYP=:ODFTFLAG GOSW OTRM,OTFX,OTFX,ONTS,OMTA
056623   *)FILL
056623   OTRM:  "DWRITE"=:X."DRIVER"=:X."STDRIV"
056626          ZXONOFCR/\377=:X.XONCR; ZXONOFCR SHZ -10=:X.XOFCR
056634          GO MOVO
056635   OTFX:  T:=ZPAIRDF=:X.PAIRDF=:OZPAIRDF
056640          IF A=1 THEN
056643             "ERRFATAL"=:X."STDRIV"
056645             "TEXIT"=:X."TMSUB"; "TFRSTDEV"=:X."STDEV"
056651          ELSE
056652             "TFWRITE"=:X."STDRIV"; "TTOMR"=:X."STDEV"
056656          FI
056656          GO MOVO
056657   ONTS:  *LDA ,B 1                               % BANK NO OF WINDOW AREA
056660          A=:X.MNWBNK
056661          "MNOTI"=:X."TMSUB"; "MNOUS"=:X."STDRIV"
056665          "MNMAIN"=:X."DRIVER"; "MNOST"=:X."STDEV"
056671          GO MOVO
056672   OMTA:  0=:X.TMR=:X.TTMR
056674          "MTOTI"=:X."TMSUB"; "MTOUS"=:X."STDRIV"
056700          "MTOUD"=:X."DRIVER"; "MTOST"=:X."STDEV"
056704
056704   MOVO:  "SBFIELD"=:B
056706          X:=1CDDMADR; A:=2CDDMADR+TDISIZ+BINSZ=:T
056713          A:=TDOSIZ=:L:="XTDFELT"=:D:=0; *MOVAP
056721          GO RDFO
056722   *)FILL
056743   INTEGER ODFTFLAG,OZPAIRDF
056745   %
056745   %      INITIALIZE OUTPUT RESIDENT DF
056745   %
056745   RDFO:  0DFADDR+"9CXTI"=:X
056750          A:=2CDDMADR+TDISIZ+TDONDI+BINSZ=:X.TDFLGADDR
056755          AD:=CDDMADR SHZ -12; A:=D=:X.TDFPHPAGE
056761          0=:X.ISTATE=:X.RESLINK=:X.RTRES=:X.MLINK; X=:X.BWLINK
056766   %
056766   %      TYPE DEPENDENT VALUES (TERMINAL,TELEFIX,NOTS,MTAD)
056766   %
056766          ODFTFLAG GOSW ORTR,ORTF,ORTF,ORNT,ORMT
056775   ORTR:  "DWRITE"=:X."DRIVER"=:X."STDRIV"
057000          GO END
057001   ORTF:  T:=OZPAIRDF=:X.PAIRDF
057003          IF A=1 THEN "ERRFATAL" ELSE "TFWRITE" FI; A=:X."STDRIV"
057012          GO END
057013   ORNT:  T:="MNOUS"=:X."STDRIV":="MNMAIN"=:X."DRIVER"
057017          GO END
057020   ORMT:  T:="MTOUS"=:X."STDRIV":="MTOUD"=:X."DRIVER"
057024
057024   END:   AD:=CDDMADR; T:=400; D+T; A:=A+C; AD=:CDDMADR
057031          GO CLINK
057032   *)FILL
057042
057042   SYMBOL TSLAK=3               % ADDITIONAL LOCATIONS IN INPUT DATAFIELD
057042
057042   MAKTADDF: A:=L=:"CLINK"; X=:0DFADDR
057045          A:=FTADPAGE=:D:=0; AD SHZ 12=:DTDFADDR; A:=200; *RMPY ST DA
057054          A:=:D+2TDFADDR; A:=:D; A:=A+C+1TDFADDR; AD=:DTDFADDR
057062          FOR X:="XTDFELT" TO "XEDFELT" DO 0=:X.S0 OD
057071          0DFADDR=:B; IF TYPRING NBIT 5BAD THEN CALL ERRFATAL FI
057077          X:="XTDFELT"+TAINDI
057101          ZDBPROG=:X.DBPROG; ZNOBUF=:X.NOBUF; ZFBSIZ=:X.FBSIZ
057107          ZTADTYP=:X.TADTYP; ZCTTYP=:X.CTTYP; ZCESCP=:X.CESCP
057115          TYPRING=:X.TYPRING
057117          "ECH0"=:X.ECHOTAB; "BRK0"=:X.BRKTAB; "TEXIT"=:X."TMSUB"
057125          "BDGET"=:X."IOTRANS"; "TEXIT"=:X."STDEV"; "CTIBAD"=:X."SETDV"
057133          A:=B=:X.TDRADDR
057135          "SBFIELD"=:B; 0DFADDR+"9CXTI"=:X.XDFOPP
057142          A:=2TDFADDR/\1777+"WND41*2000"+TAISIZ+TSLAK+TAONDI=:X.DFOPP
057151          A:=2TDFADDR+TAINDI=:0DFADDR.TDFLGADDR
057155          AD:=DTDFADDR SHZ -12; A:=D=:X.TDFPHPAGE
057161          0=:X.RESLINK=:X.RTRES; A:=X=:X.BWLINK; 0=:X.ISTATE=:X.MLINK
057167          GO MKTD1; *)FILL
057204
057204   MKTD1: 0DFADDR+"9CXTI"=:0DFADDR=:B
057210          IF TYPRING NBIT 5BAD THEN CALL ERRFATAL FI
057214          X:="XTDFELT"+TAISIZ+TSLAK+TAONDI
057220          TYPRING=:X.TYPRING
057222          "BDTOU"=:X."TMSUB"; -3=:X.TTMR; "BDPUT"=:X."IOTRANS"
057230          "TEXIT"=:X."STDEV"; "CTOBAD"=:X."SETDV"
057234          A:=B=:X.TDRADDR
057236          "SBFIELD"=:B
057240          A:=2TDFADDR/\1777+"WND41*2000"+TAINDI=:X.DFOPP
057245          0DFADDR-"9CXTI"=:X.XDFOPP
057250          X:=1TDFADDR; T:=2TDFADDR
057252          A:=TAISIZ+TSLAK+TAOSIZ=:L:="XTDFELT"=:D:=0; *MOVAP
057262          A:=2TDFADDR+TAISIZ+TSLAK+TAONDI=:0DFADDR.TDFLGADDR
057270          AD:=DTDFADDR SHZ -12; A:=D=:X.TDFPHPAGE
057274          0=:X.ISTATE=:X.RESLINK=:X.RTRES=:X.MLINK; A:=X=:X.BWLINK
057302          GO CLINK
057303   RBUS
057314
057314   %=======================================================================
057314   %       (C)   M N H D S J
057314   %
057314   % ROUTINE TO FIND NOTS INTERFACES
057314   %
057314   % MEMORY ACCESSES ARE DISABLED TO HIDE MEMORY FOR SINTRAN
057314   %
057314   SUBR MNHDSJ
057314   INTEGER FLG:=0,CC1
057316   INTEGER POINTER LREG
057317   MNHDSJ: A:=L=:"LREG":=200; *TRR IIE; TRA IIC         % ENABLE IOX-ERRORS
057324           "MNTAB"=:CC1
057326           DO WHILE X:=CC1.S0 >< -1
057333              IF X >< 0 THEN
057334                 T:=X.HDEV+5; 20; *IOXT; TRA IIC        % TRY TO CLEAR MBNIU
057341                 IF A-7=0 THEN                          % IOX ERROR
057343                    "0"=:CC1.S0                         % CLEAR ELEMENT IN MNTAB
057346                 ELSE
057347                    IF FLG=0 THEN X=:CURNOTS; CC1=:PMNTA; 1=:FLG FI
057356                    T-1; *IOXT; SHA ZIN SHR 10          % READ BANK NO
057361                    A+1=:X.MNCBNK
057363              FI;FI
057363              MIN CC1
057364           OD
057365           GO LREG
057366   RBUS
057372
057372   %=======================================================================
057372   %       (C)   M N A L L O C
057372   %
057372   % ROUTINE TO ALLOCATE TERMINAL DATAFIELDS TO A NOTS CONTROLLER
057372   % CALLED FROM "XCHIOX" WHEN IOX ERROR
057372   %
057372   % ENTRY: X = DF ADDRESS
057372   % EXIT:  DF IS USED FOR NOTS
057372   % EXITA: DF IS NOT USED FOR NOTS
057372   %
057372   SUBR MNALLOC
057372   INTEGER CCN:=0
057373   MNALLOC:IF CURNOTS = -1 THEN EXITA FI                      % NO MORE MBNIUS
057400           X=:D
057401           IF X.HDEV NBIT 2 THEN
057404              CURNOTS."MNIDF"+CCN=:X                          % INPUT DF
057410              A:=D=:X.S0; D=:X
057413              0=:X.HDEV
057414           ELSE
057415              CURNOTS."MNODF"+CCN=:X                          % OUTPUT DF
057421              A:=D=:X.S0; D=:X; "0"=:X.HDEV; 3=:X.ZDFTYP      % 3 IN ZDFTYP TO INDICATE NOTS TERMINAL
057430              CCN*4000=:X.S0; CURNOTS.MNCBNK-1=:D.S1          % WINDOW ADDRESS AND WINDOW BANK NO.
057440              CURNOTS=:X.S2; CCN+1=:CCN
057445           FI
057445           IF CCN=40 THEN                                     % THIS MBNIU FILLED UP ?
057451              X:=PMNTA+1                                      % POINTS TO NEXT ELEMENT IN MNTAB
057453              DO WHILE X.S0=0 AND A><-1; X+1; OD              % FIND NEXT ELEMENT
057462              A=:CURNOTS; X=:PMNTA; 0=:CCN                    % CURNOTS = -1 AT END
057465           FI
057465           EXIT
057466   RBUS
057471
057471   %=======================================================================
057471   %       (C)   M T A L L O C
057471   %
057471   % ROUTINE TO ALLOCATE TERMINAL DATAFIELDS TO MTAD
057471   % CALLED FROM "XCHIOX" WHEN IOX ERROR
057471   %
057471   % ENTRY: X=DF ADDRESS
057471   % EXIT:  DF ALLOCATED TO MTAD
057471   % EXITA: DF NOT ALLOCATED
057471   %
057471   SUBR MTALLOC
057471   INTEGER CNO:=1
057472   MTALLOC:IF CNO > MTMAX THEN EXITA FI                      % NO MORE MTADS
057477           IF X.HDEV BIT 2 THEN
057502              4=:X.ZDFTYP; MIN CNO                          % INDICATE MTAD
057505           FI
057505           0=:X.HDEV
057506           EXIT
057507   RBUS
057510
057510   %==============================================================================
057510   %            C O M P T M R T A B L E
057510   %
057510   % SUBROUTINE TO COMPRESS THE TIMER-TABLE
057510   %
057510   % ENTRY:     X=DESTINATION ADDR IN TIMER TABLE
057510   %            T=MEMORY BANK OF TIMER TABLE
057510   %            A=END OF TIMER TABLE
057510   %
057510   SUBR COMPTRMTABLE
057510
057510   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
057514   INTEGER POINTER LREG
057515
057515   COMPTMRTABLE: TAD=:TADREG; X=:XREG:=:L=:"LREG"
057521          X:=L:=:T; L:=:A-A; D:=T+1; A:=X; *MOVPP
057530          TAD:=TADREG; X:=XREG
057532          GO LREG
057533   RBUS
057533
057533   %==============================================================================
057533   %            C L B C K T A B E N T R Y
057533   %
057533   % SUBROUTINE TO CLEAR AN ENTRY IN THE BACKGROUND TABLE
057533   %
057533   % ENTRY:     A=DATAFIELD ADDRESS TO CLEAR FROM THE BACKGROUND TABLE
057533   %
057533   SUBR CLBCKTABENTRY
057533   INTEGER TREG,AREG,DEREG,XREG; TRIPLE TADREG=TREG
057537   INTEGER POINTER LREG
057540   CLBCKTABENTRY: TAD=:TADREG; X=:XREG:=L=:"LREG"
057544          X:=0
057545          DO WHILE BACKTAB(X)><-1
057551             IF A=AREG THEN
057554                0=:BACKTAB(X)
057555   *"-8BACS
"057555                GO OUT
057556             FI; X+1
057557          OD
057560   OUT:   TAD:=TADREG; X:=XREG
057562          GO LREG
057563   RBUS
057564
057564   %===============================================================================
057564   %       G E T A R E A     Y G E T A R E A
057564   %
057564   %  SUBROUTINE TO ALLOCATE CONTINUOUS AREA IN MEMORY
057564   %
057564   % ENTRY: A=FIRST PAGE TO TEST
057564   %        B=SBFIELD IN SINTR
057564   %        X=NUMBER OF PAGES IN AREA
057564   %        T=LAST POSSIBLE PAGE IN AREA
057564   %
057564   %         GETAREA: ALLOCATES PAGES FROM A UPP TO T
057564   %                  AND TEST THAT WHOLE AREA IS IN ONE BANK
057564   %        YGETAREA: ALLOCATES PAGES FROM A DOWN TO T
057564   %                  (CALLED WHEN ALLOCATING PAGES TO RT-COMMON)
057564   %        ZGETAREA: SAME AS GETAREA BUT CAN CROSS MEMORY BANK
057564   % EXIT:  AREA NOT FOUND
057564   %
057564   % EXIT+1: AREA FOUND, A=FIRST PAGE IN AREA
057564   %
057564   SUBR GETAREA,YGETAREA,ZGETAREA
057564
057564   INTEGER ROUTSWITCH=?,PIOCTESTED=?,CCAA=?
057564
057564   YGETAREA: TAD=:XTAD; T:=0; GO XGT1
057567   GETAREA:  TAD=:XTAD; T:=1; GO XGT1
057572   ZGETAREA: TAD=:XTAD; T:=2
057574   XGT1:  X=:NPAGES; X-=:XXX; A:=L=:"CLINK"
057601          "EMMLIM"-"DMMLIM"=:0CINX
057604          XA=:CCAA; T=:ROUTSWITCH; 0=:PIOCTESTED
057610          GO AGAIN; *)FILL
057613   AGAIN: XXX=:CCOUNT; XA=:CURRPAGE
057617          FOR CCOUNT DO
057617             X:=0
057620             DO WHILE X<<0CINX
057623                AD:=DMMLIMS(X)
057624                IF T:=CURRPAGE>>=A AND T<<=D GO FAR TRNX
057631                X+2
057632             OD
057633             X:=0
057634             IF ROUTSWITCH><0 THEN
057636               DO WHILE ACCTAB(X)><-1                         % RT COMMON
057642                  X+1; IF ACCTAB(X)=CURRPAGE GO FAR TRNX; X+1
057650               OD; X:=0
057652             FI
057652             DO WHILE X<<"NINSZ+1*2"
057655                *1BANK
057656                AD:=NINITPAGE(X); *2BANK
057660                IF A><0 AND A<<=CURRPAGE AND D>>=T GO FAR TRNX
057666                X+2
057667             OD; X:=0
057671             DO WHILE X<<"NINSZ+1*2"
057674                *1BANK
057675                AD:=LAMARR(X); *2BANK
057677                IF A><0 AND A<<=CURRPAGE AND D>>=T GO FAR TRNX
057705                X+2
057706             OD; X:=0
057710             DO WHILE X<<"CUMSIZE*2"
057713                *1BANK
057714                AD:=CUMTABLE(X)
057715                *2BANK
057716                IF A><0 AND A<<=CURRPAGE AND D>>=T GO TRNX
057724                X+2
057725             OD
057726             IF PIOCTESTED=0 THEN
057730                X:=0
057731                DO WHILE X<<50
057734                   *1BANK
057735                   AD:=MMPIOCS(X)
057736                   *2BANK
057737                   IF A><0 AND A<<=CURRPAGE AND D>>=T GO TRNX
057745                   X+2
057746                OD
057747             FI; GO BYP; *)FILL
057755   INTEGER ROUTSWITCH,PIOCTESTED,CCAA
057760   BYP:      CURRPAGE; CALL PHYSPTEST; GO TRNX
057763             IF ROUTSWITCH><0 THEN
057765                IF A=1 THEN
057770                   CURRPAGE/\177700=:T
057773                   IF XA/\177700><T THEN               % CHECK THAT WHOLE IS IN ONE BANK
057777                      IF CURRPAGE+NPAGES>>XT GO MBNOTFOUND
060004                      CURRPAGE=:XA; GO AGAIN
060007                   FI
060007                FI; MIN CURRPAGE
060010             ELSE
060011                CURRPAGE-1=:CURRPAGE
060014             FI
060014          OD
060016          MIN "CLINK"; A:=XA; GO CLINK          % AREA FOUND
060021   TRNX:  IF ROUTSWITCH><0 THEN
060023             IF NPAGES+CURRPAGE>>XT GO MBNOTFOUND
060030             CURRPAGE+1=:XA
060033          ELSE
060034             IF CURRPAGE-NPAGES<<XT GO MBNOTFOUND
060041             CURRPAGE-1=:XA
060044          FI; GO FAR AGAIN
060045
060045   MBNOTFOUND: IF PIOCTESTED=0 THEN
060047                  MIN PIOCTESTED; CCAA=:XA; GO FAR AGAIN
060053               FI; GO CLINK                    % AREA NOT FOUND
060054   RBUS
060057
060057   SUBR 1BAREA
060057   %------------------------------------------------------------------------
060057   % SUBROUTINE TO ALLOCATE CONTINUOUS AREA IN MEMORY NOT CROSSING BANK BOUNDARY
060057   %
060057   % ENTRY: B=SBFIELD IN SINTR
060057   %        A=FIRST PAGE TO TEST
060057   %        X=NUMBER OF PAGES IN AREA
060057   %        T=LAST POSSIBLE PAGE IN AREA
060057   %
060057   % EXIT : NO AREA FOUND
060057   % EXITA: AD= FIRST, LAST PAGE
060057   %
060057   %------------------------------------------------------------------------
060057   INTEGER POINTER LREG
060060   INTEGER LPAG,AREG,XREG
060063   1BAREA:
060063          T=:LPAG:=L=:"LREG"; A=:AREG; X=:XREG
060070          DO WHILE AREG+X<<LPAG
060075             A-X=:T; T:=:A; A\/77:=:T
060102             X:=XREG; CALL GETAREA; GO TRN;
060105             MIN "LREG"; A /\ A;
060107             A=:D+XREG-1; A:=:D; GO RETU
060114   TRN:      AREG+100/\ 177700=:AREG    % TRY NEXT BANK
060120          OD
060121   RETU:   GO LREG
060122   RBUS
060125
060125   %========================================================================
060125   %      X C H I O X
060125   %
060125   % CHECK FOR EXISTING TERMINAL INTERFACES.
060125   % IF A TERMINAL INTERFACE NOT EXIST, THEN THE POINTER
060125   % TO THIS DATAFIELD IS REMOVED FROM THE TIMER TABLE, FROM THE LOGICAL
060125   % UNIT TABLE, AND FROM THE TIOBUTAB
060125   %
060125   % WHEN GETTING IOX-ERRORS WHEN ADDRESSING A INTEFACE, THE INTERFACE
060125   % IS DEFINED AS NOT PRESENT.
060125   %
060125   % THIS ROUTINE WILL CHECK IF THE IDENT-CODE FOR THE TERMINALS ARE
060125   % CORRECT, IF NOT AN ERROR MESAGE WILL BE WRITTEN WHEN THE SYSTEM
060125   % IS STARTED.
060125   %
060125   % ENTRY:         A=FIRST PHYSICAL PAGE IN RPIT
060125   %                T=FIRST PHYSICAL PAGE IN MPIT
060125   SUBR XCHIOX
060125
060125   INTEGER POINTER LREG
060126   INTEGER XREG,TREG,AREG,DREG; TRIPLE TADREG=TREG
060132   INTEGER C1ETMRADDR=?,C2ETMRADDR=?
060132   INTEGER PI12T=?,PI12B=?,PI10T=?,PI10B=?
060132
060132   OUT:   TAD:=TADREG; X:=XREG
060134          GO LREG
060135
060135   INTEGER POINTER CL
060136   INTEGER CLUG,CLOGNO,CEND,CCDFAD
060142   CSUBR: T:=L=:"CL"; A SHZ -6=:CLUG
060146          X:=CNVRT(A); A:=X+200=:CEND
060153          DO WHILE X<<=CEND
060156             T:=LOGDBANK; *LDDTX 10
060160             IF A=CCDFAD OR D=T THEN EXIT FI
060166             X+2
060167          OD; EXITA
060171
060171   % LOCAL SUBROUTINE TO CLEAR A ENTRY IN THE LOGICAL UNIT TABLE AND IN
060171   % THE TIOBUTAB
060171   %
060171   INTEGER POINTER LRG
060172   ZEROENTRIES: A=:CCDFADR
060173          A:=L=:"LRG"
060175          A:=0; CALL CSUBR; GO LGFOUND
060200          A:=1000; CALL CSUBR; GO LGFOUND
060203          A:=2000; CALL CSUBR; GO LGFOUND
060206          A:=2700; CALL CSUBR; GO LGFOUND
060211          A:=3000; CALL CSUBR; GO LGFOUND
060214          GO LRG
060215   LGFOUND: IF A><CCDFADDR THEN X+1 FI
060221          T:=LOGDBANK; *STZTX 10                    % CLEAR ENTRY IN LOG.UN.TABLE
060223          X=:D; A:=X-CNVRT(CLUG) SHZ -1; T:=X SH 6
060232          A+T=:CLOGNO
060234          T:=LOGDBANK; *1BANK
060236          X:="TIOBU"
060237          DO WHILE X.S0><-1
060243             IF A=CLOGNO THEN
060246                0=:X.S0; *2BANK
060250                GO LRG
060251             FI; X+3
060252          OD; *2BANK
060254          GO LRG
060255
060255   *)FILL
060265
060265   XCHIOX: TAD=:TADREG; X=:XREG:=L=:"LREG"
060271          RPIFPHPAGE SH 12=:D
060274          "TMRTE"+1-"PITEX"+D=:TMRADDR              % "START-POINT" IN TIMER TABLE
060301          "9EXTD"-"PITEX"+D=:C1ETMRADDR               % "END-POINT" IN TIMER TABLE
060305          "ETMRT"-"PITEX"+D=:C2ETMRADDR              % END OF TIMER TABLE
060311          T:=MPIFPHPAGE SH 12
060313          "ID12T"-"PITEX"+T=:PI12T                  % PHYS.ADDR OF ID12T
060317          "ITB12"-"PITEX"+T=:PI12B                  % PHYS.ADDR OF ITB12
060323          "ID10T"-"PITEX"+T=:PI10T                  % PHYS.ADDR OF IT10T
060327          "ITB10"-"PITEX"+T=:PI10B                  % PHYS ADDR OF ITB10
060333          GO LABL1
060334
060334   *)FILL
060344
060344   INTEGER PI12T                % PHYS ADDR OF ID12T
060345   INTEGER PI12B                % PHYS ADDR OF ID12B
060346   INTEGER PI10T                % PHYS ADDR OF ID10T
060347   INTEGER PI10B                % PHYS ADDR OF ID10B
060350   INTEGER C1ETMRADDR           % LAST TERM.DF. ENTRY IN TIMER TABLE
060351   INTEGER C2ETMRADDR           % END OF TIMER TABLE
060352
060352   LABL1: A:=200; *TRR IIE; TRA IIC
060355          DO WHILE X:=TMRADDR<<C1ETMRADDR
060361             *TRA IIC
060362             T:=RPIBANK; *LDXTX
060364             IF X=-1 GO FAR OUT                     % -1: END-OF-TABLE
060367             IF X=0 OR X.TYPRING NBIT 5TERM GO FAR NXT
060373             IF X.HDEV><0 THEN
060375                X=:0DFADDR
060376                T:=A+2; *IOXT; TRA IIC
060402                IF A=7 THEN                         % IOX-ERROR ?
060405                   CALL MNALLOC; GO IDOK            % SHOULD DF BE USED FOR NOTS ?
060407                   CALL MTALLOC; GO IDOK            % SHOULD DF BE USED FOR MTAD ?
060411                   T:=RPIBANK; X:=TMRADDR; *STZTX   % DO NOT USE IT, CLEAR ENTRY
060414                ELSE
060415                   GO IDOK                          % MOL/% OOP
060416                   IF X.HDEV NBIT 2 THEN            % CHECK IDENT CODE IF INPUT DEVICE
060421                      X=:D; T:=X.HDEV+3; A:=30; *IOXT
060426                      *IDENT PL10; IDENT PL12; TRA IIC
060431                      15; *IOXT
060433                      A:=0; T+"5-3"; *IOXT
060436                      0=:CCOUNT; FOR CCOUNT DO OD; FOR CCOUNT DO OD
060443                      5; T+"7-5"; *IOXT
060446                      A:=0; *IDENT PL12
060450                      IF A=0 GO FAR ERRID; A-1
060453                      IF A<<="HIDTERM" AND A>>="LIDTERM" THEN
060461                         IF A-T>>"MXX12" GO FAR ERRID
060465                         A+PI12T
060466                      ELSE
060467                         A+PI12B
060470                      FI; X:=A; T:=MPIBANK; *LDATX
060473                      IF A><D GO FAR ERRID; A:=0; *IDENT PL10
060477                      IF A=0 GO FAR ERRID; A-1
060502                      IF A<<="HIDTERM" AND A>>="LIDTERM" THEN
060510                         IF A-T>>"MXX10" GO FAR ERRID
060514                         A+PI10T
060515                      ELSE
060516                         A+PI10B
060517                      FI; X:=A; T:=MPIBANK; *LDATX
060522                      T:="9CXTI"; D+T
060524                      IF A><D GO FAR ERRID
060526                      T+"3-7"; A:=30; *IOXT; IDENT PL10; IDENT PL12; TRA IIC
060534   IDOK:           FI
060534                FI
060534             FI; T:=RPIBANK; X:=TMRADDR; *LDATX
060537             IF A=0 THEN
060540                A:=0DFADDR; CALL FAR ZEROENTRIES
060542                A:=0DFADDR; CALL CLBCKTABENTRY
060544             FI
060544   NXT:      MIN TMRADDR
060545          OD; GO FAR OUT
060547   *)FILL
060563
060563   ERRID: GO IDOK                                % MAY BE PATCHED TO 124001
060564          D.HDEV; T:=0; CALL 9ERR(#23); GO IDOK  % TO GET IOX ERROR !
060572
060572   RBUS
060573
060573
060573   %============================================================================
060573   %
060573   % SUBROUTINE TO INITIALIZE A PAGE (READ AND WRITE IN EVERY ADDRESS IN THE PAGE)
060573   %
060573   % ENTRY: A=PAGE NUMBER
060573   %
060573   % 36.19      I N I T P A G E
060573   %
060573   SUBR INITPAGE
060573   INTEGER XREG,TREG,AREG,DREG
060577   TRIPLE TADR=TREG
060577   INITPAGE:
060577          TAD=:TADR; X=:XREG
060601          X:=0; *1BANK
060603          DO WHILE X<<"NINSZ+1*2"
060606             AD:=NINITPAGE(X)
060607             IF A><0 AND A<<=AREG AND D>>=T GO OUT
060615             X+2
060616          OD; *2BANK
060620          A:=AREG=:D:=162000; X:=177776; *POF
060625          AD=:X.DOU0; *PON
060627          FOR X:=176000 DO X.S0=:X.S0 OD
060633   OUT:   TAD:=TADR; X:=XREG; *2BANK
060636          EXIT
060637   RBUS
060642
060642
060642   %============================================================================
060642   % 36.21       F P G N O
060642   %
060642   %
060642   % SUBROUTINE TO CONVERT ADDRESS TO PAGE NUMBER
060642   %
060642   % ENTRY: A=ADDRESS
060642   %
060642   % EXIT:  A=PAGE NUMBER
060642   %        D=0 WHEN ADDRESS IS MODULO 2K BYTE ELSE D=1
060642   %
060642   SUBR FPGNO
060642   FPGNO: D:=0; AD SHZ -12; IF D><0 THEN D:=1 FI; EXIT
060650   RBUS
060650
060650
060650   %============================================================================
060650   % 36.11       P H Y S P T E S T
060650   %
060650   % SUBROUTINE TO TEST IF PAGE EXIST IN MEMORY
060650   %
060650   % ENTRY: A=PAGE NUMBER
060650   %
060650   % EXIT:  PAGE DOES NOT EXIST
060650   %
060650   % EXIT+1: PAGE EXSIST
060650   %
060650   SUBR PHYSPTEST
060650   INTEGER XREG,TREG,AREG,DREG
060654   TRIPLE TADR=TREG
060654   PHYSPTEST:
060654          TAD=:TADR; X=:XREG:=0
060657          *1BANK
060660          DO WHILE X<<"NINSZ+1*2"
060663             AD:=NINITPAGE(X)
060664             IF A><0 AND A<<=AREG AND D>>=T GO NOTOK
060672             X+2
060673          OD; *2BANK
060675          A:=AREG=:D:=162000; X:=177776; *POF
060702          AD=:X.DOU0
060703          A:=1000; *TRR IIE; PON; TRA IIC           % TEST FOR MEMORY OUT OF RANGE
060707          X:=-1; X.S0; *TRA IIC
060712          IF A=0 THEN L+1 FI; A:=0; *TRR IIE
060716   NOTOK: TAD:=TADR; X:=XREG; *2BANK
060721          EXIT
060722   RBUS
060725
060725   %==============================================================================
060725   %            O U T L I N K   -   I O U T L I N K
060725   %
060725   % SUBROUTINE TO LINK OUT AN AREA FROM THE MEMORY MAP
060725   % IMOUTLINKL WILL ALSO INITIALIZE THE AREA (READ AND WRITE IN ALL LOCATIONS)
060725   %
060725   % ENTRY:     A=FIRST PAGE TO LINK OUT
060725   %            D=LAST PAGE TO LINK OUT
060725   SUBR MOUTLINKL,IMOUTLINKL
060725   INTEGER TREG,AREG,DREG,XREG
060731   TRIPLE TADR=TREG
060731   INTEGER POINTER LREG
060732   INTEGER CFMMENTRY,CLMMENTRY,CPREV
060735
060735   IMOUTLINKL: K:=1; GO FELLS
060737   MOUTLINKL: K:="0"
060740   FELLS: TAD=:TADR; X=:XREG:=L=:"LREG"
060744          IF A=-1 GO OUT
060747          IF K THEN
060751             TAD:=TADR
060752             DO CALL INITPAGE; WHILE A><D; A+1; OD
060757          FI; TAD:=TADR
060760          D-A; A:=D+1=:NPAGES
060763          AREG SH 2=:CFMMENTRY; DREG SH 2=:CLMMENTRY
060771          T:=SEGTBANK; X:=XSGRT; *BPAGL@3 LDXTX
060774          DO WHILE X><0
060775             IF X=CFMMENTRY GO FOUND
061000             T:=CORMBANK
061001             *PAGLI@3 LDXTX
061002          OD; CALL ERRFATAL               % MEMORY MAP ELEMENT NOT FOUND
061004   FOUND: T:=CORMBANK; *PREVI@3 LDATX
061006          A=:CPREV
061007          DO NPAGES-1=:NPAGES WHILE NPAGES><0
061014             *PAGLI@3 LDXTX
061015             IF X=0 THEN CALL ERRFATAL FI % INCOSISTENT MEMORY MAP
061020          OD
061021          IF X><CLMMENTRY THEN CALL ERRFATAL FI
061025          T:=CORMBANK; *PAGLI@3 LDATX; PAGLI@3 STZTX
061030          IF X:=A><0 THEN
061032             CPREV; *PREVI@3 STATX        % SET PREVIOUS
061034          FI
061034          IF CPREV/\3=0 THEN              % FIRST IN LISTE?
061037             A:=CPREV:=:X; *PAGLI@3 STATX % NO, SET PAGLINK
061042          ELSE
061043             T:=SEGTBANK; A:=X; X:=XSGRT; *BPAGL@3 STATX
061047          FI; X:=CFMMENTRY
061050          DO WHILE X<<=CLMMENTRY
061053             T:=CORMBANK; A:=0 BONE 5CMSYS; *PROTE@3 STATX    % MARK MEMORY MAP ELEMENT IN USE BY "SYSTEM AREA"
061057             IF X+4=0 GO OUT
061061          OD
061062   OUT:   TAD:=TADR; X:=XREG
061064          GO LREG
061065   RBUS
061073
061073
061073   %=============================================================================
061073   %      Z E R O P A G E
061073   %
061073   % SUBROUTINE TO FILL A PAGE WITH ZEROES
061073   %
061073   % ENTRY:     A=PHYSICAL PAGE NUMBER
061073   %
061073   SUBR ZEROPAGE
061073   INTEGER XREG; TRIPLE TADR
061077   ZEROPAGE: TAD=:TADR; X=:XREG
061101          A=:D:=162000; X:=177776; *POF
061105          AD=:X.DOU0; *PON
061107          FOR X:=176000 DO 0=:X.S0 OD
061112          TAD:=TADR; X:=XREG; EXIT
061115   RBUS
061117
061117
061117   *9ERST=*                     % FIRST FREE LOCATION FOR BUFFER AREAS
061117
061117   %=============================================================================
061117   %  38.10     S Y S E V A L
061117   %
061117   %  ROUTINE TO DEDUCT CPU/SYSTEM INFORMATION AND UPDATE THE GLOBAL
061117   %  SINTRAN VARIABLES WITH THIS INFORMATION
061117   %
061117   %  A 12 WORD (14 OCTAL) ARRAY CONTAIN VARIOUS INFORMATION ABOUT THE SYSTEM.
061117   %  THE ARRAY IS SUBDIVIDED INTO SEVERAL FIELDS FOR VARIOUS TYPE OF INFORMATION.
061117   %  THE FOLLOWING GIVES A DETAILED DESCRIPTION OF THE INFORMATION PRESENT IN
061117   %  THE VARIOUS ENTRIES
061117   %
061117   %-----------------------------------------------------------------------------
061117   %
061117   %  DISP  NAME            DESCRIPTION
061117   %
061117   %   0    SYSNO           SYSTEM NUMBER (NORMALLY CPU NUMBER), 16 BIT INTEGER
061117   %
061117   %   1    HWINFI(0)       HARWARE INFORMATION
061117   %                        LEFT BYTE = CPU TYPE
061117   %                                    0 = NORD-10  48 BIT FLOATING
061117   %                                    1 = NORD-10  32 BIT FLOATING
061117   %                                    2 = ND-100   48 BIT FLOATING
061117   %                                    3 = ND-100   32 BIT FLOATING
061117   %                                    4 - ND-110   48 BIT FLOATING
061117   %                                    5 - ND-110   32 BIT FLOATING
061117   %                                    6 - ND-120   48 BIT FLOATING
061117   %                                    7 - ND-120   32 BIT FLOATING
061117   %                        RIGHT BYTE = INSTRUCTION SET
061117   %                                    0 = STANDARD (NORD-10 OR ND-100)
061117   %                                    1 = NORD-10 COMMERCIAL, ND-100/CE
061117   %                                    2 - ND-100/CX
061117   %                                    3 - ND-110 PCX
061117   %                                    4 - ND-120 PCX
061117   %                                    5 - NOT USED
061117   %                                    6 - NOT USED
061117   %                                    7 - NOT USED
061117   %                                   10 - ND-120/CX
061117   %                                   11 - ND-110/CX  PRINT 3095
061117   %                                   12 - ND-110/CX  PRINT 3090
061117   %                                   13 - 255 NOT USED
061117   %
061117   %   2    HWINFO(1)       ND-110 MICROPROGRAM VERSION
061117   %
061117   %   3    HWINFO(2)       SYSTEM TYPE  (100,102,500,502,5561..)
061117   %
061117   %   4    SINVER(0)       OPERATING SYSTEM
061117   %                        LEFT BYTE = OPERATING SYSTEM
061117   %                                    0 = SINTRAN III VS
061117   %                                    1 = SINTRAN III VSE
061117   %                                    2 = SINTRAN III VSE/500
061117   %                                    3 = SINTRAN III RTP
061117   %                                    4 = SINTRAN III VSX
061117   %                                    5 = SINTRAN III VSX/500
061117   %                                    6 - 255 NOT USED
061117   %                        RIGHT BYTE = VERSION LETTER
061117   %                                     ASCII CHARACTER WITHOUT PARITY (A-Z)
061117   %
061117   %   5    SINVER(1)       NOT USED  (SIBAS SYSTEM NO)
061117   %
061117   %   6    REVLEV          PATCH/CORRECTION LEVEL INDICATIOR, 16 BIT INTEGER
061117   %                        (SYSTEM DEPENDANT CODING)
061117   %
061117   %   7    GENDAT(0)       SYSTEM GENERATION TIME  (MINUTES)
061117   %   8    GENDAT(1)       SYSTEM GENERATION TIME  (HOURS)
061117   %   9    GENDAT(2)       SYSTEM GENERATION TIME  (DAY)
061117   %  10    GENDAT(3)       SYSTEM GENERATION TIME  (MONTH)
061117   %  11    GENDAT(4)       SYSTEM GENERATION TIME  (YEAR)
061117   %
061117   %-----------------------------------------------------------------------------
061117
061117   SUBR SYSEVAL
061117
061117   INTEGER SXREG,SBREG,STREG,AREG,SDREG,CHWINFO
061125   TRIPLE TADR=STREG
061125   INTEGER POINTER SLREG
061126
061126   SYSEVAL:
061126         TAD=:TADR; X=:SXREG:=B=:SBREG:=L=:"SLREG"
061134
061134   %  32/48 BIT FLOATING?
061134          T:=0; A:=1; *NLZ 20
061137          IF T=0 THEN T:=1 ELSE T:=0 FI
061144
061144   %  NORD-10 OR ND-100?
061144          CPSTA/\10000 SHZ -13+T SH 10
061151          A=:CHWINFO
061152
061152   %  INSTRUCTION SET
061152   %  COMMERCIAL INSTRUCTION SET?
061152          *TRA IIC
061153          A:=20; *TRR IIE
061155          A:=0; *TRR PIE; TRR PID
061160          A:=40000; *MST PIE
061162          *POF
061163          A:="CLEV14"; *IRW 160 DP; ION
061166          T:="L1"=:L:=0; *140130; JMP *+1; TRA IIC            % BFILL
061174   L1:    IF A=0 THEN
061175             "L2"=:L
061177             B:=0; D:=0; A:=0; X:=0; *142700; TRA IIC         % GECO
061205   L2:       IF A><0 GO OUT
061206          FI
061206          *143500                                             % SLWCS
061207          MIN CHWINFO
061210          T:="L3"=:L; X:=0; *ICLEP; TRA IIC
061215   L3:    IF A=0 THEN MIN CHWINFO FI
061217          T:="LL3"=:L; X:=0; *WGLOB; TRA IIC                  % (MICRO-SEGADM FOR 16 PITS?
061224   LL3:   IF A=0 THEN MIN CHWINFO FI
061226          T:="LL4"=:L; *VERSN; TRA IIC                        % ND-110?
061232   LL4:   IF A=0 THEN
061233             *VERSN
061234             A SHZ -15 ; A+CHWINFO=:CHWINFO
061237             A:=0 ; *TRR PIE; TRR PID; PON
061243             T=:HWINFO(1)                                     % ND-110/ND-120 MICROPROGRAM VERSION
061245             CHWINFO/\174777+2000=:CHWINFO
061251             IF T BIT 17 THEN                                 % ND-120?
061253                A+1000=:CHWINFO
061255             FI
061255          FI
061255   OUT:   A:=0; *TRR PIE; TRR PID; PON
061261          CHWINFO=:HWINFO(0)
061264          A:=4
061265          IF T:=PN500D><0 THEN A+1 FI                         % ND-500 INCLUDED
061271          A SH 10+##L                                         % VERSION LETTER
061273          A=:SINVER(0)
061275          *IOF; TRA IIC
061277          A:=0; *TRR PIE; TRR PID; TRR IIC
061303          TAD:=TADR; X:=SBREG=:B:=SXREG
061307          GO SLREG
061310   % ROUTINE ON LEVEL 14 TO CHECK FOR ILLEGAL INSTRUCTION
061310   CLEV14: *TRA IIC
061311          IF A><4 THEN CALL ERRFATAL FI
061315          *IRW DA; IRR DL; IRW DP
061320          *WAIT
061321          GO CLEV14
061322
061322   RBUS
061342   %============================================================================
061342   %       G C P U N R
061342   %
061342   %       ROUTINE TO GET CPU NUMBER FROM BACK WIRING PROM.
061342   %       CALLED ONLY IF 110/120 CPU.
061342   %
061342   %       DUE TO ERROR IN MICROPROGRAM THE VERSN INSTRUCTION HAS TO BE
061342   %       EXECUTED ON THE LEVEL CORRESPONDING TO THE BYT NO. TO BE READ.
061342   %
061342   SUBR GCPUNR
061342   INTEGER INF0,INF1,INF2,INF3
061346   GCPUNR: *PIOF
061347           400;  *IRW 10 DA; LDA (EXVE; IRW 10 DP
061353           1000; *IRW 20 DA; LDA (EXVE; IRW 20 DP
061357           1400; *IRW 30 DA; LDA (EXVE; IRW 30 DP
061363           2000; *IRW 40 DA; LDA (EXVE; IRW 40 DP
061367           2400; *IRW 50 DA; LDA (EXVE; IRW 50 DP
061373           3000; *IRW 60 DA; LDA (EXVE; IRW 60 DP
061377           3400; *IRW 70 DA; LDA (EXVE; IRW 70 DP
061403           377; *TRR PIE; TRR PID; ION; IOF; PON
061411           A:=0; *TRR PIE; VERSN; 1BANK
061415           T:="INF0"; X:=0; A:=D; *SBYT
061421           X+1; *IRR 10 DD; SBYT
061424           X+1; *IRR 20 DD; SBYT
061427           X+1; *IRR 30 DD; SBYT
061432           X+1; *IRR 40 DD; SBYT
061435           X+1; *IRR 50 DD; SBYT
061440           X+1; *IRR 60 DD; SBYT
061443           X+1; *IRR 70 DD; SBYT; 2BANK
061447           IF INF3><52652 THEN EXIT FI             % NOT CORRECT PROM
061454           IF INF0><-1 THEN
061460              A=:SYSNO=:FCPUN; 1=:PRFLAG           % CPU NUMBER (PRFLAG IS USED BY NEW-SYSTEM)
061464           FI
061464           IF INF1><-1 THEN A=:HWINFO(2) FI        % CPU TYPE
061472           IF INF2 SHZ -10><377 THEN A=:NLEGU FI   % NUMBER OF LEGAL USERS
061500           EXIT
061501   EXVE:   *VERSN; WAIT
061503   RBUS
061531   %============================================================================
061531   %       T I O B U T A B
061531   @MAC

)9SCLC
061531
061531  TIOBU=*
061531
061531              1;    44;    134
061534  "8TR5 -9SMO1;     44;    44;    134
061537  "8TR6;     45;    44;    134
061542  "8TR7;     46;    44;    134
061545  "8TR8;     47;    44;    134
061550  "8TR9 -9SMO2;     60;    44;    134
061553  "8TR10;    61;    44;    134
061556  "8TR11;    62;    44;    134
061561  "8TR12;    63;    44;    134
061564  "8TR13 -9SMO3;    64;    44;    134
061567  "8TR14;    65;    44;    134
061572  "8TR15;    66;    44;    134
061575  "8TR16;    67;    44;    134
061600  "8TR17 -9SMO4;     7;    44;    134
061603  "8TR18;    17;    44;    134
061606  "8TR19;    52;    44;    134
061611  "8TR20;    53;    44;    134
061614  "8TR21 -9SMO5;    54;    44;    134
061617  "8TR22;    55;    44;    134
061622  "8TR23;    56;    44;    134
061625  "8TR24;    57;    44;    134
061630  "8TR25 -8SMO9;    70;    44;    134
061633  "8TR26;    71;    44;    134
061636  "8TR27;    72;    44;    134
061641  "8TR28;    73;    44;    134
061644  "8TR29 -9SMO6;    74;    44;    134
061647  "8TR30 -9SMO7;    75;    44;    134
061652  "8TR31;    76;    44;    134
061655  "8TR32;    77;    44;    134
061660  "8TR33;  1040;    44;    134
061663  "8TR34;  1041;    44;    134
061666  "8TR35 -8SMO7;  1042;    44;    134
061671  "8TR36 -8SMO8;  1043;    44;    134
061674  "8TR37 -8SMO9;  1044;    44;    134
061677  "8TR38 -9SMO1;  1045;    44;    134
061702  "8TR39 -9SMO2;  1046;    44;    134
061705  "8TR40 -9SMO3;  1047;    44;    134
061710  "8TR41 -9SMO4;  1050;    44;    134
061713  "8TR42 -9SMO5;  1051;    44;    134
061716  "8TR43 -9SMO6;  1052;    44;    134
061721  "8TR44 -9SMO7;  1053;    44;    134
061724  "8TR45;  1054;    44;    134
061727  "8TR46;  1055;    44;    134
061732  "8TR47;  1056;    44;    134
061735  "8TR48;  1057;    44;    134
061740  "8TR49;  1060;    44;    134
061743  "8TR50;  1061;    44;    134
061746  "8TR51;  1062;    44;    134
061751  "8TR52;  1063;    44;    134
061754  "8TR65;  2000;    44;    134
061757  "8TR66;  2001;    44;    134
061762  "8TR67;  2002;    44;    134
061765  "8TR68;  2003;    44;    134
061770  "8TR69;  2004;    44;    134
061773  "8TR70;  2005;    44;    134
061776  "8TR71;  2006;    44;    134
062001  "8TR72;  2007;    44;    134
062004  "8TR73;  2010;    44;    134
062007  "8TR74;  2011;    44;    134
062012  "8TR75;  2012;    44;    134
062015  "8TR76;  2013;    44;    134
062020  "8TR77;  2014;    44;    134
062023  "8TR78;  2015;    44;    134
062026  "8TR79;  2016;    44;    134
062031  "8TR80;  2017;    44;    134
062034  "8TR81;  2020;    44;    134
062037  "8TR82;  2021;    44;    134
062042  "8TR83;  2022;    44;    134
062045  "8TR84;  2023;    44;    134
062050  "8TR85;  2024;    44;    134
062053  "8TR86;  2025;    44;    134
062056  "8TR87;  2026;    44;    134
062061  "8TR88;  2027;    44;    134
062064  "8TR89;  2030;    44;    134
062067  "8TR90;  2031;    44;    134
062072  "8TR91;  2032;    44;    134
062075  "8TR92;  2033;    44;    134
062100  "8TR93;  2034;    44;    134
062103  "8TR94;  2035;    44;    134
062106  "8TR95;  2036;    44;    134
062111  "8TR96;  2037;    44;    134
062114  "8TR97;  2040;    44;    134
062117  "8TR98;  2041;    44;    134
062122  "8TR99;  2042;    44;    134
062125  "9TR00;  2043;    44;    134
062130  "9TR01;  2044;    44;    134
062133  "9TR02;  2045;    44;    134
062136  "9TR03;  2046;    44;    134
062141  "9TR04;  2047;    44;    134
062144  "9TR05;  2050;    44;    134
062147  "9TR06;  2051;    44;    134
062152  "9TR07;  2052;    44;    134
062155  "9TR08;  2053;    44;    134
062160  "9TR09;  2054;    44;    134
062163  "9TR10;  2055;    44;    134
062166  "9TR11;  2056;    44;    134
062171  "9TR12;  2057;    44;    134
062174  "9TR13;  2060;    44;    134
062177  "9TR14;  2061;    44;    134
062202  "9TR15;  2062;    44;    134
062205  "9TR16;  2063;    44;    134
062210  "9TR17;  2064;    44;    134
062213  "9TR18;  2065;    44;    134
062216  "9TR19;  2066;    44;    134
062221  "9TR20;  2067;    44;    134
062224  "9TR21;  2070;    44;    134
062227  "9TR22;  2071;    44;    134
062232  "9TR23;  2072;    44;    134
062235  "9TR24;  2073;    44;    134
062240  "9TR25;  2074;    44;    134
062243  "9TR26;  2075;    44;    134
062246  "9TR27;  2076;    44;    134
062251  "9TR28;  2077;    44;    134
062254  "9TR29;  2700;    44;    134
062257  "9TR30;  2701;    44;    134
062262  "9TR31;  2702;    44;    134
062265  "9TR32;  2703;    44;    134
062270  "9TR33;  2704;    44;    134
062273  "9TR34;  2705;    44;    134
062276  "9TR35;  2706;    44;    134
062301  "9TR36;  2707;    44;    134
062304  "9TR37;  2710;    44;    134
062307  "9TR38;  2711;    44;    134
062312  "9TR39;  2712;    44;    134
062315  "9TR40;  2713;    44;    134
062320  "TEFX1;  1540;    44;    134
062323           1560;    44;     20
062326  "
062326  -1; -1; -1
062331  )9RCLC
)9SLPL
062331

062331   %==============================================================================
062331   %  27.1      L O A D   P R O G R A M
062331   %
062331
062331   @MAC

)9SCLC
062331  %
062331  % "LOAD" PROGRAM
062331  %
062331
062331  LOLOG=-2
062331  LOUNI=-1
062331  LKONS=177000
062331
062331
062331  % SET CACHE INHIBIT LIMIT AND CLEAR CACHE
062331  RELOA, PIOF; TRA STS; BSKP ONE 140 DA; JMP *+5; SAA 0
062336         TRR 11; SAA 77; JMP *+2; LDA (37400; TRR 12; TRR 10
062344  % MOVE RELOAD PROGRAM TO ADDRESS LKONS-WORD2
062344         LDX ADR3; LDA I ,X ADR1; STA I ,X ADR2; JNC *-2
062350         LDA ADR1; ADD (SWDSI; STA ADR1
062353  % MOVE DRIVER TO THE CORRECT ADDRESS
062353         LDX (-SWDSI; LDA I ,X ADR1; STA I ,X ADR2B; JNC *-2
062357         JMP I *+1; LKONS-WORD2
062361  ADR1,  TRANS+WORD2-RELOA
062362  ADR2,  LKONS
062363  ADR3,  -WORD2
062364
062364  )FILL
062367  TRANS, LDA (LKONS-WORD6; COPY SA DB
062371         LDT YSWTY; AAT -1; SKP DT EQL 0; JMP NBDI
062375         AAA NWLBB-4; COPY SA DD; SAA 0; STD NWLBB,B      % SPARE TRACK ADDR.
062401         JMP NALOA
062402  NBDI,  AAT -1; SKP DT EQL 0; JMP SCDI
062405  LOWDI, AAA ALTPO; COPY SA DD; SAA 0; STD WNLBA,B        % SPARE TRACK ADDR
062411         JMP NALOA
062412  SCDI,  AAT -1; SKP DT EQL 0; JMP NALOA
062415         SAT 42; JPL I LDRAD; JMP *-2; JMP *-2
062421         JMP NALOA
062422  NOBLK, 0
062423  ADR2B, 0
062424  DYBLS, 0;0
062426  LDRAD, 0
062427  XSWTP, 0
062430  YSWTY, 0         % 1=BDIS; 2=WDIS
062431
062431  NALOA, LDX NOBLK; LDT LOUNI,B; SHT 6
062434         LDA XSWTP; RADD SA DT; LDD DYBLS
062437  NALO4, JPL I LDRAD; JMP NALOA; JMP *+2; JMP NALO3   % CALL DRIVER
062443         STA NALO5
062444  NALOY, MCL PID; MCL PID; MCL PID; MCL PID
062450  KLIOX, IOX 4; BSKP ZRO 20 DA; JMP NALOY; LDA NALO5; JMP NALO4
062455  NALO3=*
062455  NALO2, IDENT PL11; JMP I (SINTR
062457  NALO5, 0
062460  )FILL
062462
062462  DFELT=*+110
062462  KLOLO=DFELT+LOLOG
062462  KLHDE=DFELT+HDEV
062462  KLRC1=DFELT+ERRC1
062462  KBLSZ=DFELT+BLSZ
062462
062462  *<DFELT+20
062462  )ZERO
062462
062462  DFELT-72/ 0; *+1             % ADDRESS TO SCSI IO-BUFFER
062502  DFELT+DEDFA+1/
062631  WORD2=*-TRANS
062631  UPADR=*+1400
062631  LDEND=*
062631  WORD6=*-DFELT
062631
062631  )KILL NOBLK DYBLS TOUT TOUT1 CHOUT TINN TINN1 TINN2 OUTR TINN3 NALOY
062631  )KILL NALOA NALO4 KLIOX NALO3 NALO2 CHSWD NALO5 KLOLO KLHDE WORD2
062631  )KILL UPADR DFELT WORD3 WORD4 WORD5 WORD6
062631  )KILL ADR1 ADR2 ADR3 TRANS ALO1 TX0 TX1 TX2 LOLOG LOUNI LKONS
062631  )KILL YSWTY LOWDI
062631  )9RCLC
)9SLPL
062631
062631
062631   %=============================================================================
062631   %            T N I N I T P
062631   %
062631   % SUBROUTINE TO TEST IF A PAGE IN A MEMORY-BANK CAN BE ACCESSED, I.E.
062631   % THE WHOLE MEMORY-BANK IS NOT SETUP IN NINITPAGES
062631   %
062631   % ENTRY:     A=FIRST PAGE IN MEMORY-BANK
062631   %
062631   % EXIT:      NO PAGES IN MEMORY BANK CAN BE ACCESSED
062631   %
062631   % EXIT+1:    A=PAGE NUMBER TO ACCESS IN MEMORY BANK
062631   %
062631   SUBR TNINITP
062631   TRIPLE TRARDR
062634   INTEGER XR,CENDPAGE
062636   TNINITP: TAD=:TRARDR; A=:CURRPAGE; X=:XRG
062641          A\/77=:CENDPAGE
062643   LOOP:  DO WHILE CURRPAGE<<=CENDPAGE
062647             X:=0
062650             DO WHILE X<<="NINSZ+1*2"
062653                *1BANK
062654                AD:=NINITPAGE(X)
062655                *2BANK
062656                IF A><0 AND A<<=CURRPAGE AND D>>=T THEN
062664                   T+1=:CURRPAGE; GO LOOP
062667                FI; X+2
062670             OD; L+1; GO OUT
062673          OD
062674   OUT:   TAD=:TRARDR; A:=CURRPAGE; X:=XR
062677          EXIT
062700   RBUS
062702
062702
062702   %==============================================================================
062702   %            M P M 3 M A P   -   M P M 4 M A P
062702   %
062702   % SUBROUTINE TO FIND MPM3 AND MPM4 MEMORY
062702   %
062702   SUBR MPM3MAP,MPM4MAP
062702
062702   INTEGER POINTER LREG
062703   INTEGER TR,AR,DR,XR; TRIPLE TRARDR=TR
062707   INTEGER ROUTSWITCH,ORGCONT
062711
062711   MPM3MAP: TAD=:TRARDR; 1=:ROUTSWITCH; GO FELLS
062715   MPM4MAP: TAD=:TRARDR; 0=:ROUTSWITCH
062717   FELLS: X=:XR:=L=:"LREG"
062722          A:=400; *TRR IIE                          % ENABLE FOR MEMORY PARITY ERROR
062724          *TRA PGS; TRA PEA; TRA IIC                % CLEAR INTERNAL REGISTERS
062727          0=:CURRPAGE
062730          DO WHILE CURRPAGE<<=ENDPAGE
062734             CALL TTMMAP; GO NXT                    % TEST IF MEM.BANK EXIST
062736             CALL TNINITP; GO NXT                   % TEST IF MEM IS INVISIBLE
062740             A=:D:=162000; X:=177776
062743             T:=0; *STDTX                           % INITIALIZE PIT ENTRY
062745             X.S0=:ORGCONT; *TRA IIC; TRA PEA
062751             IF ROUTSWITCH=0 THEN                   % MPM4
062753                A:=11; *TRR ECCR
062755                0=:X.S0; A:=4; *TRR ECCR; TRR 10
062761                X.S0; *TRA IIC
062763                IF A=10 THEN T:=KMECCR; A:=CURRPAGE; CALL SMEMTYPE FI
062771             ELSE                                   % MPM3
062772                A:=140751; *IOX 751
062774                0=:X.S0; A:=140764; *IOX 751; TRR 10
063000                X.S0; *TRA IIC
063002                IF A=10 THEN T:=KMPM3; A:=CURRPAGE; CALL SMEMTYPE FI
063010             FI; ORGCOUNT=:X.S0                     % RESET ORIGINAL CONTENT
063012             *TRA PES; TRA PEA; TRA IIC; TRA PGS    % CLEAR INTERNAL REGISTERS
063016   NXT:      CURRPAGE+100=:CURRPAGE
063021          OD
063022          A:=10; *TRR ECCR
063024          A:=4; *TRR ECCR
063026          TAD:=TRARDR; X:=XR
063030          GO LREG
063031   RBUS
063041
063041
063041   %=============================================================================
063041   %            S M E M T Y P E
063041   %
063041   % SUBROUTINE TO SETUP MEMORY-TYPE OF A MEMORY BANK
063041   %
063041   % ENTRY:     A=PHYS.PAGE
063041   %            T=MEMORY TYPE
063041   %
063041   SUBR SMEMTYPE
063041   INTEGER TR,AR,DR,XR; TRIPLE TRARDR=TR
063045   SMEMTYPE: TAD=:TRARDR; X=:XR
063047          A=:D SHZ -7+MEMARRAY=:X; T:=MBMEMARRAY; *LDATX
063055          IF D BIT 6 THEN
063057             A/\177400\/TR
063061          ELSE
063062            A/\377; T:=TR SH 10; A\/T; T:=MBMEMARRAY
063067          FI; *STATX
063070          X:=XR; TAD:=TRARDR
063072          EXIT
063073   RBUS
063077
063077   %=============================================================================
063077   %               C H 5 C P U P R E S E N T
063077   %
063077   % Subroutine called from the start-up (SINTR) sequence to check if
063077   % the generated ND-500 cpu's (SAMSON) exists or not
063077   %
063077   % EXIT:   No ND-500 cpu is presnet
063077   %
063077   % EXIT+1: ND-500 cpu is present
063077   %
063077   SUBR CH5CPUPRESENT
063077   *"8N500
"063077   INTEGER CBSET(0); *BSET ONE DA
063100   INTEGER COMD,CCPU,CCSAM,COLD
063104
063104   CH5CPUPRESENT: B=:D; A:="S5CPUDF"=:B:=0; *TRR IIE
063111          0=:COMD=:CCSAM=:COLD; 1=:CCPU
063116          DO WHILE B<<="E5CPUDF"
063121             IF CPUAVAILABLE BIT 5NOTPRESENT GO 2CH5CPU
063124             IF CCSAM><0 GO 1CH5CPU
063126             T:=HDEV+RSTA5; *TRA IIC
063131             A:=200; *TRR IIE; IOXT; TRA IIC
063135             IF A=0 THEN                                % If not IOX-error then
063136                CPUAVAILABLE/\140000\/OLD500
063141                A BONE 5ALIVE
063142                MIN COLD
063143             ELSE
063144                IF COLD><0 GO 2CH5CPU
063146   1CH5CPU:     *TRA IIC                                % Read octobus if. status
063147                A:=200; *TRR IIE
063151                T:=100406; *IOXT; TRA IIC
063154                IF A=0 THEN                             % Octobus present? - (assumes Samson)
063155                   DO                                   % Wait for data ready
063155                      *IOXT
063156                   WHILE A NBIT 3
063160                   OD
063161                   ASTATION\/COMD=:5STATION
063164                   A SH 10 BONE CBIT BONE EBIT=:X       % To start Samson selftest:
063170                   T:=100405; A\/CMMACLE; *IOXT         % - send "masterclear Samson system" frame
063173                   A:=X\/CMACONT; *IOXT                 % - send "continue accp" frame
063176                   MIFLAG BONE MUDOM=:MIFLAG
063201                   CPUAVAILABLE/\140000\/SAMSON
063204                   MIN CCSAM
063205                ELSE
063206   2CH5CPU:        A:=0
063207                FI
063207             FI
063207             A=:CPUAVAILABLE
063210             MIN CCPU; MIN COMD; B+5CPUDDFSZ
063213          OD; D=:B
063215          EXITA
063216   *"-8N500
"063216   RBUS
063230
063230   %==============================================================================
063230   %  (R)    C B P O O L
063230   %
063230   % CREATE BUFFER POOL. CALLED FROM ROUTINE OCSTART
063230   %
063230   % ENTRY:   T - BANK NUMBER
063230   %          X - ADDRESS WITHIN BANK
063230   %          D - NUMBER OF BUFFERS
063230   %          A - ADDRESS TO START OF BUFFER DESCRITORS
063230   % EXIT:    X - ADDRESS TO LAST ENTRY
063230   %
063230   SUBR CBPOOL
063230   INTEGER TADDR,XADDR
063232   CBPOOL:
063232          T=:TADDR; X=:XADDR:=A
063235          DO WHILE D>0
063237              MBFREC+1=:MBFREC
063242              TADDR=:X.MBYA1            % SET BANK OF BUFFERS
063244              XADDR=:X.MBYA2            % ADDRESS WITHIN BANK
063246              XADDR+OBSIZE=:XADDR       % NEXT BUFFER ADDRESS
063251              IF D-1>0 THEN             % NOT LAST BUFFER?
063254                  A:=X+DSIZE            % DESCRIPTOR ADDRESS OF NEXT BUFFER.
063256              ELSE                      %
063257                  A:=0                  % END OF DESCRIPTOR CHAIN.
063260              FI                        %
063260              A=:X.MBLINK; X:=A         %
063262          OD
063263          X:=XADDR; EXIT
063265   RBUS
063267
063267   %==============================================================================
063267   %  (R)    C E N T R Y
063267   %
063267   % CREATE IDENT TABLES, LAST PART FOR OMD DATAFIELDS AND KICK ENTRIES.
063267   % CALLED FROM ROUTINE OCSTART.
063267   % ENTRY:   T - BANK NUMBER
063267   %          X - ADDRESS WITHIN BANK
063267   %          B - ADDRESS TO OCTOBUS INPUT CONTROLLER
063267   % EXIT:    X - ADDRESS TO LAST ENTRY
063267   %
063267   SUBR CENTRY
063267   INTEGER POINTER LREG
063270
063270   CENTRY:A:=L=:"LREG"
063272          IF X=0 THEN X+1 FI                      %
063275          A:=17=:D; X=:A:=0                       % LAST PART FOR OMD:
063301          DO WHILE X <= D                         %
063303              A=:OMDENT(X); A:=:X                 % SET ADDRESS TO OMD ENTRIES.
063305              *OLINK@3 STZTX; DLEVE@3 STZTX       % SET ZERO IN LAST PART.
063307              *DFADD@3 STZTX                      %
063310              A:=:X; A+3; X+1                     %
063313          OD                                      %
063314          X:=17=:D; X:=0                          % KICK ENTRIES:
063317          DO WHILE X <= D                         %
063321              A=:KICKENT (X); A:=:X               % SET ADDRESS TO KICK ENTRIES
063323              *OLINK@3 STZTX; DLEVE@3 STZTX       % ZEROSET
063325              *DFADD@3 STZTX                      %
063326              A:=:X; A+3; X+1                     %
063331          OD                                      %
063332                                                  % IDENT ENTRIES:
063332          X:=A; D:=0                              % X= ADDRESS WITHIN BANK
063334          DO WHILE D <= 77                        % MAKE IDENT ENTRIS FOR FOR SOURCE STATIONS.
063337             X:=:D                                %
063340             A:=SOUIDEN (X); X:=:D                %
063342             IF A>0 THEN                          % IDENT ENTRIES FOR THIS SOURCE?
063344                T:=IENTBANK; *STATX               % NUMBER OF IDENT ENTRIES FOR SOURCE STATION.
063346                L:=A; A:=X; X:=:D                 %
063351                A=:SOUIDEN (X); X:=:D; X+1        % SET ADDRESS TO START OF IDENT ENTRIES.
063354                DO WHILE L>0                      % SET ZERO IN IDENT ENTRIES.
063356                   *OLINK@3 STZTX                 %
063357                   *DLEVE@3 STZTX                 %
063360                   *DFADD@3 STZTX                 %
063361                   L-1                            %
063362                   X+3                            %
063363                OD                                %
063364             FI                                   %
063364             D+1                                  %
063365         OD                                       %
063366         GO LREG
063367   RBUS
063367
063367
063367   %==============================================================================
063367   %         O C S T A R T
063367   %
063367   % START UP ROUTINE FOR OCTOBUS
063367   % CHECK IF OCTOBUS INTERFACE IS PRESENT AND ALLOCATE MEMORY FOR
063367   % BUFFER POOL AND TABLES IN PHYSICAL MEMORY.
063367   %
063367   % NOTE !!! THIS OCTOBUS DRIVER ONLY HANDLE ONE OCTOBUS INTERFACE (DEVICE 0)
063367   %
063367   %
063367   SUBR OCSTART
063367   INTEGER BREG,BPAGS,NPAGS
063372   INTEGER POINTER LREG
063373
063373   OCSTART:
063373         A:=L=:"LREG"
063375         A:=B=:BREG
063377         OCTICON(0)=:B                            %
063402         IF B=0 GO OUT                            % GENERATED WITH THIS OCTOBUS
063404         A:=200; *TRR IIE; TRA IIC                % ENABLE FOR IOX-ERROR
063407         T:=HDEV+2; *IOXT; TRA IIC                %
063413         IF A=7 THEN                              % IOX-ERROR ?
063416             0=:TMR; 0=:OCTICONT(0)               % RESET TIMER COUNTER
063421             0=:OCTOCONT(0); GO OUT               %
063424         FI                                       %
063424         T:=HDEV+DCONT; 20; *IOXT                 % CLEAR INTERFACE
063430         T+4; *IOXT                               %
063432         A:="ONOBU"=:D                            % GET NUMBERS OF BUFFERS TO BE CREATED
063434         X:="STOCT"=:MBPOOL                       % START OF BUFFER POOL DESCRIPTORS
063436         A:=D*OBSIZE SHZ -12 +1 =: BPAGS          % NUMBER OF PAGES FOR BUFFERS.
063443         X:=0; T:=77=:D:=0                        % CALCULATE NUMBER OF WORDS FOR
063447         DO WHILE X <= D                          % IDENT ENTRY IN PHYSICAL MEMORY
063451            IF SOUIDENT(X)><0 THEN                %
063453               A*3+1+T=:T                         % T= NUMBERS OF WORDS REQUIRED.
063457            FI                                    %
063457            X+1                                   %
063460         OD                                       %
063461         A:=40*3                                  % KICK AND OMDS
063463         A+T SHZ -12 +1                           % KICK TABLES IN PHYSICAL MEMORY
063466         A+BPAGS=:X; "SBFIELD"=:B; X=:MMSIZE      % TOTAL NUMBER OF PAGES
063473         A:=100; T:=LPHYSPAGE                     %
063475         CALL GETAREA; CALL ERRFATAL              %
063477         A=:D-1+MMSIZE:=:D; AD=:OCPHYSPAGE        % FIRST AND LAST PAGE
063504         A=:D:=0; AD SH 12                        %
063507         T:=OCTICONT(0)=:B; A=:IENTBANK           %
063513         T:=A; X:=D                               %
063515         A:="ONOBU"=:D; A:=MBPOOL; CALL CBPOOL    % CREATE BUFFER POOL.
063521         A:="SBFIELD"=:B                          %
063523         AD:=OCPHYSPAGE; A+BPAGS                  %
063525         A=:D:=0; AD SH 12                        %
063530         T:=OCTICONT(0)=:B                        %
063533         A=:T; D=:X; CALL CENTRY                  % OCTOBUS TABLES IN PHYSICAL MEMORY
063536         IENTBANK=:"OCD12".OCTBANK                % SET BANK NO FOR LEVEL LINK...
063541         A=:"OCD11".OCTBANK                       % .. ELEMENTS FOR OCTOBUS.
063543         A=:"OCD10".OCTBANK                       %
063545   OUT:  A:=BREG=:B                               %
063547         GO LREG
063550   RBUS
063570
063570
063570   %==============================================================================
063570   %         N U C S T
063570   %
063570   % START UP ROUTINE FOR NUCLEUS.
063570   % ALLOCATE MEMORY FOR NUCLEUS SERVER MAILBOX, BUFFER FOR ROUTINE NCALL,
063570   % ABORT TABEL IN PHYSICAL MEMORY.
063570   %
063570   %
063570   %
063570   SUBR NUCST
063570   INTEGER POINTER LREG
063571   NUCST:
063571         A:=L=:"LREG"
063573         "SBFIELD"=:B
063575         "NXRTP" * 2 =: ABTSIZE                   % SIZE OF ABORT TABEL FOR NUCLEUS
063600         A SHZ -12+3=:X; A=:MMSIZE; A:=100        % +3 BECAUSE 2 EXTRA PAGES NEEDED
063605         T:=LPHYSPAGE; CALL GETAREA; CALL ERRFATAL%
063610         A=:D-1+MMSIZE:=:D; AD=:NUPHYSPAGE        % FIRST AND LAST PAGE
063615         A=:D:=0; AD SH 12                        %
063620         A=:NMAA1;A=:SMAA1; A=:ABTBNK             % BANK NO
063623         A:=D=:NMAA2; A+2000=:SMAA2               % ADDRESS WITHIN BANK
063627         A+2000=:ABTSTART                         %
063631         0=:ABTPUT=:ABTGET                        % ABORT TABEL PUT AND GET POINTERS
063633         GO LREG
063634   RBUS
063653
063653
063653   *)KILL 99END
063653   * 99END=*
063653
063653   @DEV 1
