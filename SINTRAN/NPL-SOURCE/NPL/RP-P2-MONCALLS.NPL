076223   @DEV (S-S-L)RP-P2-MONCALLS:NPL
076223   % TAB S8,4
076223   %

076223   %======================= C X - R P I T - M O N C A L L S ======================
076223
076223   %===========================================================================
076223   %      ( R )      F I X C  -   F I X C 5 0 0
076223   %
076223
076223   SUBR FIXC,FIXC500
076223
076223   DISP 26            % DISP D6
076223   INTEGER FIXFLAG
076223   INTEGER SGADR
076223   INTEGER NPAG
076223   INTEGER CURPAGE
076223   INTEGER FPHYS
076223   INTEGER CECORMAP
076223   INTEGER CCORMSTART
076223   INTEGER CMMENTRY
076223   INTEGER CSEGAD
076223   INTEGER COLDFLAG
076223   INTEGER CFXCTADDR
076223   INTEGER SVFLAGB
076223   INTEGER AFPHYS
076223   INTEGER ALPHYS
076223   INTEGER PGFOUND
076223   INTEGER PARTINDX
076223   INTEGER RETINDX
076223   INTEGER CPEND
076223   PSID
076223   %
076223   % MON FIXC(SEGMENT NUMBER,PHYSICAL PAGE NUMBER)
076223   %
076223
076223   FIXC:  CALL GET2                                 % D0=SEG.NO, D1=PHYSICAL PAGE NO.
076224          IF D0 BZERO 17<<2 OR A>>SGMAX GO ERRIL    % ILLEGAL SEGMENT NUMBER
076234          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
076237          T:=SEGTBANK; X:=SGADR; *SEGLE@3 LDATX     % A=SEGMENT SIZE
076242          IF A=0 GO ERRNL                           % EMPRY SEGEMENT
076243          A=:NPAG
076244          *FLAG@3 LDATX                             % A=SEGMENT FLAG
076245          IF A BIT 5INHB GO ERRNL                   % SEGMENT NOT LOADED
076247          IF A BIT 5DEMAND GO ERRD                  % DEMAND SEGMENT NOT LEGAL
076251          *SGSTA@3 LDATX                            % A=SEGMENT STATUS
076252          IF A=0 GO ERRNL                           % SEGMENT NOT LOADED
076253          IF A BIT 5FIX THEN                        % SEGMENT IS FIXED
076255             D1=:CURPAGE; *BPAGL@3 LDXTX            % CHECK IF FIXED CONTIGUOUS IN CORRECT MEMORY ADDR
076260             T:=CORMBANK
076261             DO
076261                IF A:=X SHZ -2 -CURPAGE><0 GO ERRFX % FIXED IN WRONG ADDR
076265                MIN CURPAGE; *PAGLI@3 LDXTX
076267             WHILE X><0
076270             OD; GO FXOKRET                         % SEGMENT FIXED CONTIGUOUS IN CORRECT ADDR
076272          FI; *FLAG@3 LDATX                         % A=SEGMENT FLAG
076273          IF A BIT 5FIXC THEN                       % SEGMENT ALREADY FIXED CONTIGUOUS
076275             *BPAGL@3 LDATX
076276             IF A SHZ -2=D1 GO FXOKRET              % OK, FIXED CONTIGUOUS IN CORRECT ADDR.
076302             GO ERRFX                               % ERROR, FIXED CONTIGUOUS IN WRONG ADDR.
076303          FI
076303          IF NPAG+FIXPAGES>>FIXMAX GO ERRF          % TOO MANY FIXED PAGES
076310          NPAG+MINSWPAGES; CALL CHNSWPAGES; GO ERRF
076314          D1=:FPHYS                                 % FIRST PHYSICAL PAGE
076316          0=:FIXFLAG                                % ROUTINE SWITCH IN PFIXC
076317          GO FAR PFIXC                              % GO TO COMMON ROUTINE FOR MON FIXC AND MON FIXC5
076320
076320   ERRIL: IF D0 BIT 17 THEN A:=-2; GO FXRET FI
076325          CALL 9ERRA(#15); GO RETXIT                % ILL.SEGM.NO.
076330   ERRNL: IF D0 BIT 17 THEN A:=-3; GO FXRET FI
076335          CALL 9ERRA(#16); GO RETXIT                % NOT LOADED
076340   ERRD:  IF D0 BIT 17 THEN A:=-4; GO FXRET FI
076345          CALL 9ERRA(#17); GO RETXIT                % FIXING DEMAND
076350   ERRF:  IF D0 BIT 17 THEN A:=-5; GO FXRET FI
076355          CALL 9ERRA(#18); GO RETXIT                % TOO MANY PAGES FIXED
076360   ERRFX: IF D0 BIT 17 THEN A:=-6; GO FXRET FI
076365          CALL 9ERRA(#25); GO RETXIT                % ALREADY FIXED
076370   FXOKRET: X:=SGADR; T:=SEGTBANK; *FLAG@3 LDATX
076373          A BONE 5FIXC; *FLAG@3 STATX               % MARK SEGMENT FIXED CONTIGUOUS
076375          IF D0 BIT 17 THEN A:=0 FI                 % FIXED CONTIGUOUS OK.
076401   FXRET: A=:ZAREG; GO RETSTUPR                     % RETURN TO USER PROGRAM
076403   *)FILL
076421
076421   %=========================================================================
076421   %      ( R )      F I X C 5 0 0
076421   %
076421   % MONITOR CALL TO ALLOCATE MEMORY SPACE FOR NORD-500 SEGMENTS
076421   % AND/OR FIXC (IN MEMORY AREA)/ ALLOCATE BUFFER (IN MEMORY AREA)
076421   %
076421   %
076421   % FUNCTION=1:      ALLOCATE MEMORY FOR ND-500.
076421   %
076421   % PAR1:      NUMBER OF PAGES IN SEGMENT
076421   % PAR2:      FIRST LEGAL PHYSICAL PAGE FOR SEGMENT
076421   % PAR3:      LAST LEGAL PHYSICAL PAGE FOR SEGMENT
076421   % PAR4:      MUST BE ZERO! (NUMBER OF SINTRAN III/N500 SHARED AREAS)
076421   % PAR5:      DUMMY         (ADDRESS OF SHARED INFORMATION ARRAY (PHYSICAL ADDRESS))
076421   %
076421   % RETURN:    ERROR - NO AREA ALLOCATED FOR NORD-500
076421   %
076421   % SKIP RETURN:  MEMORY ALLOCATED FOR ND-500.
076421   %               A=FIRST PHYSICAL PAGE IN NORD-500 SEGMENT
076421   %
076421   %
076421   % FUNCTION=2:    GIVE N500 SWAPPING PAGES
076421   %
076421   % PAR1:      NO. OF PAGES
076421   % PAR2:      NO. OF N500 HARDWARE CONFIGURATION MEMORY PARTS
076421   % PAR3:      ADDRESS OF N500 HARDWARE CONFIGURATION MEMORY PARTS TABLE
076421   %            (PHYSICAL ADDRESS)
076421   % PAR4:      MAX NO. OF MEMORY INTERVALS TO RETURN
076421   % PAR5:      ADDRESS OF TABLE TO RETURN THE AVAILABLE MEMORY PARTS INTO
076421   %            (PHYSICAL ADDRESS)
076421   %
076421   % RETURN:    ERROR
076421   % SKIP RETURN: A = NO. OF MEMORY INTERVALS
076421   %
076421   %
076421   % FUNCTION=3:   ILLEGAL FUNCTION (TAKE PAGES FROM N500)
076421   %
076421   % PAR1:      (NO. OF PAGES)
076421   % PAR2:      (NO. OF MEMORY PARTS)
076421   % PAR3:      (ADDRESS OF MEMORY PARTS TABLE (PHYSICAL ADDRESS))
076421   % PAR4:      (DUMMY)
076421   % PAR5:      (DUMMY)
076421   %
076421   % RETURN:    ERROR
076421   % SKIP RETURN: OK
076421   %
076421   %
076421   % FUNCTION=4:   FIX A SEGMENT CONTIGOUSLY AT ANY ADDRESS WITHIN A
076421   %               SPECIFIED AREA
076421   %
076421   % PAR1:      SEGMENT NUMBER
076421   % PAR2:      FIRST (LOWER) LEGAL PHYSICAL PAGE NUMBER
076421   % PAR3:      LAST (UPPER) LEGAL PHYSICAL PAGE NUMBER
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    A=0: AREA OCCUPIED
076421   %            A=1: "PAR2">>LAST PAGE IN MEMORY MAP
076421   %            A=2: SOMETHING WRONG WITH THE SEGMENT (DEMAND, ALREADY FIXED...)
076421   %
076421   % SKIP RETURN:  SEGMENT IS FIXED CONTIGOUSLY, A=FIRST PHYSICAL PAGE IN SEGMENT
076421   %
076421   %
076421   % FUNCTION=5:   RESERVE A CONTIGOUS MEMORY AREA
076421   %
076421   % PAR1:      NUMBER OF PAGES TO RESERVE
076421   % PAR2:      FIRST (LOWER) LEGAL PHYSICAL PAGE
076421   % PAR3:      LAST (UPPER) LEGAL PHYSICAL PAGE
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR:
076421   %            A=0: AREA OCCUPIED
076421   %            A=1: "PAR2" >> LAST PAGE IN MEMORY MAP
076421   %            A=2: NO FREE TABLE ELEMENT (TRYING TO RESERVE TO MANY AREAS)
076421   %            A=3: WRONG PARAMETERS OR TOO MANY FIXED
076421   %
076421   % SKIP RETURN:  OK, A=FIRST PHYSICAL PAGE IN AREA, T=TABLE INDEX
076421   %
076421   %
076421   % FUNCTION=6:   RELEASE MEMORY AREA RESERVED BY FUNCTION=5
076421   %
076421   % PAR1:      TABLE INDEX (RETURN PARAMETER FROM FUNCTION=5)
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA (FROM FUNCTION=5)
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR
076421   %
076421   % SKIP RETURN:  OK
076421   %
076421   %
076421   % FUNCTION=7:   RELEASE ALL MEMORY AREAS RESERVED BY A SPECIFIC PROGRAM.
076421   %               THE MEMORY AREAS MUST BE RESERVED BY FUNCTION=5 IN MON 61.
076421   %
076421   % PAR1:      RT-PROGRAM WHICH HAS RESERVED THE MEMORY AREAS
076421   %            PAR1=0 MEANS CALLING PROGRAM.
076421   % PAR2:      DUMMY
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR
076421   %
076421   % SKIP RETURN: OK
076421   %
076421   %
076421   %
076421   % FUNCTION=10:  GET SEGMENT'S FIXED-STATUS
076421   %
076421   % PAR1:      SEGMENT NUMBER
076421   % PAR2:      PAGE NUMBER WITHIN SEGMENT TO FIND THE PHYSICAL MEMORY PAGE OF,
076421   %            IF THE SEGMENT IS FIXED.
076421   %            <PAR2>=0 IS ALLWAYS FIRST PAGE IN SEGMENT.
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % RETURN:    ERROR; A=174 : ILLEGAL SEGMENT NUMBER <PAR1> OR ILLEGAL PAGE
076421   %                           NUMBER WITHIN SEGMENT <PAR2>
076421   %                   A=2   : SEGMENT NOT LOADED
076421   %
076421   % SKIP RETURN: OK, T=FIXED STATUS
076421   %                  T=0 : SEGMENT NOT FIXED
076421   %                  T=1 : SEGMENT FIXED SCATTERED
076421   %                  T=2 : SEGMENT FIXED CONTIGUOUSLY
076421   %                  A=PHYSICAL PAGE NUMBER WHER <PAR2> PAGE RESIDE IN MEMORY
076421   %                  D=SEGMENT-TABLE-ELEMENT.FLAG
076421   %
076421   %
076421   %
076421   % FUNCTION=11:  GET INFORMATION ABOUT A PROGRAMS ATTATCHED SEGMENTS.
076421   %               (MON.CALL WHAMI).
076421   %
076421   % PAR1:      ACTUAL RT-PROGRAM (=0 MEANS CALLING PROGRAM)
076421   % PAR2:      ADDR OF ARRAY WHERE THE SEGMENT INFO IS STORED
076421   %            THE SIZE OF THE ARRAY MUST BE AT LEAST 18 WORDS.
076421   %            THE LAYOUT OF THE INFORMATION IS:
076421   %      ELEMENT # 0: SEGMENT NUMBER OF ACTSEG 1 (BIT 0-7 IN ACSEG; J-VERS AND VSE)
076421   %      ELEMENT # 1: FIRST LOGICAL PAGE IN ACSEG 1
076421   %      ELEMENT # 2: SEGMENT SIZE IN NUMBER OF PAGES
076421   %      ELEMENT # 3: SEGMENT DESCRIPTOR
076421   %              BIT 17B:     WRITE PERMITTED
076421   %              BIT 16B:     READ PERMITTED
076421   %              BIT 15B:     FETCH PERMITTED
076421   %              BIT 11B-12B: PROTECTION RING OF SEGMENT
076421   %              BIT  5B:     DEMAND SEGMENT
076421   %              BIT  4B:     SEGMENT IS FIXED CONTIGUOUSLY
076421   %              BIT  3B:     SEGMENT IS FIXED.
076421   %              BIT  2B:     REENTRANT SUBSYSTEM SEGMENT
076421   %              BIT  1B:     PROTECTED SEGMENT
076421   %              BIT  0B:     SYSTEM SEGMENT
076421   %      ELEMENT # 4: FIRST PHYS.PAGE OF SEGMENT IF FIXED CONTIGUOUSLY.
076421   %
076421   %      ELEMENT # 5 - 9 : SAME AS ELEMENT # 0 - 4, BUT FOR ACTSEG2, (BIT 8-15 IN ACTSEG
076421   %                                                 VSE AND J-VERSION).
076421   %
076421   %      ELEMENT #10 -14 : SAME AS ELEMENT # 0 - 4, BUT FOR REENTRANT SEGMENT
076421   %
076421   %      ELEMENT #15: FIRST LOGICAL PAGE OF RTCOMMON (=0 IF NO RTCOMMON).
076421   %      ELEMENT #16: SIZE OF RTCOMMON IN PAGES.
076421   %      ELEMENT #17: FIRST PHYSICAL PAGE OF RTCOMMON (=0 IF RTCOMMON NOT CONTIGUOUS)
076421   %
076421   % PAR3:      DUMMY
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   %
076421   % FUNCTION=12:  RELEASE NINITPAGES OR MEMORY AREA RESERVED BY FUNCTION=5 IN FIXC5
076421   %
076421   % PAR1:      ><0 : SAME AS FOR FUNCTION=6, (TABLE INDEX RETURNED IN FUNCTION=5)
076421   %            =0  : RELEASE A WHOLE AREA IN NINITPAGES
076421   %
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA.
076421   % PAR3:      NUMBER OF PAGES IN AREA (DUMMY IF PAR1><0)
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421   % FUNCTION=13:  RELEASE LAMARPAGES OR MEMORY AREA RESERVED BY FUNCTION=5 IN FIXC5
076421   %
076421   % PAR1:      ><0 : SAME AS FOR FUNCTION=6, (TABLE INDEX RETURNED IN FUNCTION=5)
076421   %            =0  : RELEASE A WHOLE AREA IN NINITPAGES
076421   %
076421   % PAR2:      FIRST PHYSICAL PAGE IN AREA.
076421   % PAR3:      NUMBER OF PAGES IN AREA (DUMMY IF PAR1><0)
076421   % PAR4:      DUMMY
076421   % PAR5:      DUMMY
076421   %
076421
076421
076421
076421   FIXC500:
076421          CALL GET6
076422          IF D0>>13 OR A=0 OR A=3 GO ERET           % ILLEGAL FUNCTION CODE
076432          A=:FIXFLAG                                % SET ROUTINE SWITCH (1 TO 10)
076433          IF A<4 AND PN500=0 GO ERET                % FUNCTION CODE << 4 ILLEGAL WHEN SYSTEM
076440                                                    % NOT GENERATED WITH ND-500
076440          IF FIXFLAG=11 THEN
076444             X:=ZAREG+2; CALL USALTPIT; X.S0; CALL SINALTPIT
076451             A=:D2                                  % ADDR OF CALLER'S ARRAY
076452             MLEV; *MCL PIE                         % INCASE PAGE-FAULT.
076454          FI; GO FAR PFIXC
076455   ERET:  174=:ZAREG; GO RET                        % ILLEGAL PARAMETER
076460   *)FILL
076466
076466

076466   %=====================================
076466   % C L E A L L S E G S
076466   %
076466   % LOCAL SUBROUTINE TO CLEAR ALL SEGMENTS FROM PITS
076466   %
076466   CCCLS: IF T><0 THEN
076470             "1XCLSEG"; *IOF; IRW SLEVB DP
076473             SLEV; *MST PID
076475             A:=T; *ION
076477             X:=A; T:=SEGTBANK; *FLAG@3 LDATX
076502             A BZERO 5OK; *FLAG@3 STATX
076504          FI; EXIT
076505
076505   CSNOK: A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *FLAG@3 LDATX
076512          A BZERO 5OK; *FLAG@3 STATX
076514          EXIT
076515
076515   CLEALLSEGS: L=:D
076516          "1XCSEGS"; *IOF; IRW SLEVB DP
076521          SLEV; *MST PID; ION
076524          T:=S3SEG; 0=:S3SEG; CALL CCCLS  % CLEAR SEGMENTS FROM PITS
076527          T:=FILSEGM; CALL CCCLS
076531          T:=5NSEGM; CALL CCCLS
076533          T:=FUSEGM; CALL CCCLS
076535          5OPSEG;   CALL CSNOK            % SET SPIT-SEGMENTS NOT OK
076537          5RTSG;    CALL CSNOK
076541          5MACDSEG; CALL CSNOK
076543          ECODSEG;  CALL CSNOK
076545          5BADM;    CALL CSNOK
076547          5SMSEG;   CALL CSNOK; 5NKSERV; CALL CSNOK
076553          5PROMAN;  CALL CSNOK; 5EVME;   CALL CSNOK
076557          5BOPC;    CALL CSNOK; 5MTSE;   CALL CSNOK
076563          D=:P
076564   *)FILL
076575   %======================================
076575   % I D U M L I N K
076575   %
076575   % LOCAL SUBROUTINE TO LINK A PAGE INTO THE DUMMY SEGMENT (FREE PAGE LINK)
076575   %
076575   % ENTRY: X=MEMORY MAP ELEMENT
076575   %
076575   IDUMLINK:
076575          T:=CORMBANK; *PROTE@3 LDATX
076577          IF A BIT 5CMIDUM THEN                     % DOES PAGE BELONG TO DUMMY SEGMENT?
076601             A BZERO 5CMIDUM; *PROTE@3 STATX        % YES, RESET TEMPORARY MARK
076603             X=:D:=XSGRT; T:=SEGTBANK; *BPAGL@3 LDXTX
076607             IF X><0 THEN
076610                A:=D; T:=CORMBANK; *PREVI@3 STATX   % ACTUAL MM-ELEMENT=:(XSGRT.BPAGLINK).PREVIOUS
076613                A:=:X; *PAGLI@3 STATX               % XSGRT.BPAGLINK=:ACTUAL MM-ELEMENT.PAGLINK
076615             ELSE
076616                X:=D; T:=CORMBANK; *PAGLI@3 STZTX   % 0=:ACTUAL MM-ELEMENT.PAGLINK
076621             FI; A:=7; *PREVI@3 STATX               % SET ACTUAL MM-ELEMENT.PREVIOUS
076623             X:=XSGRT; T:=SEGTBANK; A:=D; *BPAGL@3 STATX % ACTUAL MM-ELEMENT=:XSGRT.BPAGLINK
076627             *SEGLI@3 LDATX
076630             IF A=0 THEN
076631                "1INSEGLINK"; *IOF; IRW SLEVB DP    % INSERT DUMMY.SEGM. IN SEGMENT LISTE
076634                SLEV; *MST PID; ION
076637                T:=SEGTBANK; *IOF; SEGLI@3 LDATX
076642                A=:BSEGLINK; *ION                   % SET DUMMY.SEGM LAST IN SEGMENT LISTE
076644             FI; X:=D
076645          FI; EXIT
076646   *)FILL
076653
076653   %======================================
076653   % S O R T D U M M Y
076653   %
076653   % LOCAL SUBROUTINE TO SORT THE PAGE FREE LIST
076653   %
076653   % ENTRY: A=FIRST PHYSICAL PAGE IN ACTUAL AREA
076653   %        D=LAST PHYSICAL PAGE IN ACTUAL AREA
076653   %        T>=0: SORTING IN ASCENDING PAGE NUMBERS
076653   %        T<0:  SORTING IN FALLING PAGE NUMBERS
076653   %
076653   INTEGER POINTER SORTRET
076654   INTEGER SORTFPAGE,SORTLPAGE,SORTXREG,SORT
076660
076660   SORTDUMMY: A=:SORTFPAGE:=D=:SORTLPAGE:=L=:"SORTRET"
076665          X=:SORTXREG; T=:SORT
076667          X:=XSGRT; T:=SEGTBANK; *BPAGL@3 LDATX
076672          IF A=0 GO SORTOUT                         % PAGE FREE LIST EMPTY?
076673          *BPAGL@3 STZTX                            % NO, 0=:XSGRT.BPAGLINK
076674          T:=CORMBANK; X:=A
076676          DO
076676             *PROTE@3 LDATX
076677             A BONE 5CMIDUM; *PROTE@3 STATX         % MARK ALL PAGES IN DUMMY TEMPORARY
076701             *PAGLI@3 LDXTX
076702          WHILE X><0
076703          OD
076704          IF SORTFPAGE><0 THEN
076706             A-1 SH 2=:CECORMAP; X:=CORMSTART       % INSERT PAGES BELOW ACTUAL AREA IN DYMMY AGAIN
076712             DO WHILE X><CECORMAP; CALL IDUMLINK; X+4 OD
076720          FI; SORTLPAGE+1 SH 2=:X; IF X=0 GO CONT   % INSERT PAGES ABOVE ACTUAL AREA IN DUMMY AGAIN
076725          DO WHILE X<<=ECORMAP; CALL IDUMLINK; IF X+4=0 GO CONT; OD
076734   CONT:  IF SORT>=0 THEN
076736             SORTFPAGE SH 2=:CECORMAP               % SORT IN ASCEDING ORDER
076741             SORTLPAGE SH 2=:X
076744             DO WHILE X>>=CECORMAP; CALL IDUMLINK; X-4 OD
076752          ELSE
076753             SORTLPAGE SH 2=:CECORMAP               % SORT IN FALLING ORDER
076756             SORTFPAGE SH 2=:X
076761             DO WHILE X<<=CECORMAP; CALL IDUMLINK; IF X+4=0 GO SORTOUT; OD
076770          FI
076770   SORTOUT: X:=SORTXREG; GO SORTRET
076772   *)FILL
076777
076777   %===========================================
076777   % R L S A R E A
076777   %
076777   % LOCAL SUBROUTINE TO  RELEASE AN ALLOCATED MEORY AREA
076777   %
076777   % ENTRY: X=ADDR IN FXCTAB
076777   %
076777   INTEGER POINTER RLSRRET
077000   INTEGER RLSAXREG,RLSAFPAGE,RLSALPAGE
077003   RLSAREA: X=:RLSAXREG; A:=L=:"RLSRRET"
077006          T:=MBFXCTAB; *LDATX
077010          A=:X SHZ -2=:RLSAFPAGE
077013          T:=CORMBANK
077014          DO
077014             A:=0 BONE 5CMIDUM; *PROTE@3 STATX; PAGLI@3 LDATX % MARK ELEMNT SHALL BE INSERTED IN DUMMY
077020          WHILE A><0
077021             X:=A
077022          OD; A:=X SHZ -2=:RLSALPAGE
077026          RLSAFPAGE SH 2=:X
077031          DO CALL FAR IDUMLINK WHILE X><RLSALPAGE SH 2; X+4 OD
077040          T:=MBFXCTAB; X:=RLSAXREG; *STZTX  % CLEAR ELEMENT IN FXCTAB
077043          GO RLSRRET
077044   *)FILL
077047
077047   %========================
077047   % C F I N D S E G M E N T
077047   %
077047   % LOCAL SUBROUTINE TO FIND THE SEGMENT TABLE ENTRY
077047   % A MEMORY MAP ELEMENT BELONGS TO
077047   %
077047   % ENTRY:   X=MEMORY MAP ELEMENT
077047   %
077047   % EXIT:    A=SEGMENT TABLE ELEMENT ADDR OF SEGMENT OWNING THE MEMORY MAP ELEMENT
077047   %
077047   CFINDSEGMENT: X=:D; T:=CORMBANK
077051          DO
077051             *PREVI@3 LDATX
077052             IF A BIT 0 OR A BIT 1 THEN
077056                A SHZ -2*5SEGSIZE+SEGSTART          % A=SEGMENT TABLE ELEMENT ADDR
077061                X:=D; EXIT
077063             FI; *PREVI@3 LDXTX
077064          OD
077065   *)FILL
077070
077070   %========================
077070   % S G F I X C
077070   %
077070   % LOCAL SUBROUTINE TO FIND A CONTIGUOUS MEMORY AREA
077070   % AND RESERVE THIS AREA.
077070   %
077070   % ENTRY: FPHYS   = FIRST PHYSICAL PAGE
077070   %        CURPAGE = LAST PHYSICAL PAGE
077070   %
077070   % EXIT:  ERROR
077070   %
077070   % EXIT+1: OK
077070   %
077070   INTEGER POINTER SGFLREG
077071   SGFIXC: A:=L=:"SGFLREG"
077073          CURPAGE SH 2=:CCORMSTART                  % FIRST MEMORYMAP ELEMENT (LAST PHYS PAGE)
077076          FPHYS SH 2=:CECORMAP                      % LAST MEMORYMAP ELEMENT (FIRST PHYS PAGE)
077101          IF X:=CCORMSTART >> ECORMAP GO SGFLREG    % OUTSIDE PHYS. MEMORY
077105          DO
077105             T:=CORMBANK; X=:CMMENTRY; *PROTE@3 LDATX % A=PROTECT
077110             IF A/\5CMMASK><0 GO SGFLREG            % CAN MEMEORY MAP ELEMENT BE USED?
077113             CALL CFINDSEGMENT; A=:CSEGAD           % YES, FIND SEGMENT OWNING THE PAGE
077115             CALL OUTLINK                           % LINK PAGES TO DUMMY SEGMENT IF NON DEMAND SEG.
077116             X:=CSEGAD; T:=SEGTBANK; *FLAG@3 LDATX
077121             A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX   % SET SEGM TEMPORARLY NOT-OK
077124             X:=CMMENTRY; T:=CORMBANK; *PROTE@3 LDATX
077127             IF A BIT 5WIP THEN                     % WRITTEN IN PAGE?
077131                T:=CSEGAD; A:=1=:D; CALL ATRNSEG    % YES, WRITE PAGE TO DISK
077135             FI
077135             IF COLDFLAG BIT 5DEMAND THEN
077140                X:=CSEGAD; T:=SEGTBANK; *FLAG@3 STATX % RESET SEGM.FLAG
077143             FI; X:=CMMENTRY
077144             IF FIXFLAG=0 OR A=4 THEN A:=CSEGAD; T:=SGADR; CALL XLINKOVER FI
077154             IF FIXFLAG=1 OR A=2 THEN A:=CSEGAD; CALL X5LINKOVER FI
077165             IF FIXFLAG=5 THEN A:=CSEGAD; T:=CFXCTADDR; CALL XALINKOVER FI
077174             IF X=CECORMAP THEN                     % ALL PAGES FOUND?
077177                IF FIXFLAG=0 OR A=4 THEN            % YES, FIX-SEGMENT-CONTIGUOUS?
077204                   T:=SEGTBANK; X:=SGADR; *FLAG@3 LDATX
077207                   A BONE 5FIXC BONE 5OK; *FLAG@3 STATX  % SET SEGMENT FIXC AND OK
077212                   *SGSTA@3 LDATX
077213                   A BONE 5FIX=:D; *SGSTA@3 STATX        % SET SEGMENT FIXED
077216                   *LOGAD@3 LDATX; BPAGL@3 LDXTX         % A=LOGADR; X=BPAGLINK
077220                   A:=:D; T:=CORMBANK
077222                   DO WHILE X><0
077223                      *PROTE@3 STDTX                     % SET PROTECT AND LOGPAG
077224                      D+1; *PAGLI@3 LDXTX
077226                   OD
077227                   T:=SEGTBANK; X:=SGADR; *SEGLE@3 LDATX % A=SEGMENT LENGTH
077232                   *BPAGL@3 LDXTX                        % X=SGADR.BPAGLINK
077233                   D:=0; T:=SGADR; CALL ATRNSEG          % TRANSFER SEGMENT TO MEMORY
077236                FI; MIN "SGFLREG"; GO SGFLREG            % OK RETURN
077240             FI; X:=CMMENTRY-4
077242          OD
077243   *)FILL
077254
077254   %===================
077254   % X R E L E S
077254   %
077254   % LOCAL SUBROUTINE TO RELEASE THE "SWAPPING SYSTEM".
077254   %
077254   CCSTSEG: IF X><0 THEN
077255               T:=SEGTBANK; *BPAGL@3 LDXTX
077257               "1XSSEG"; *IOF; IRW SLEVB DP
077262               SLEV; *MST PID; ION
077265            FI; EXIT
077266
077266   CSOK:  A*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *FLAG@3 LDATX
077273          A BONE 5OK; *FLAG@3 STATX
077275          EXIT
077276
077276   INTEGER POINTER XRELLREG
077277   XRELES: A:=L=:"XRELLREG"
077301          MLEV; *MCL PIE
077303          X:=FILSEGM; CALL CCSTSEG        % SET SEGMENTS INTO PITS
077305          X:=5NSEGM; CALL CCSTSEG
077307          X:=FUSEGM; CALL CCSTSEG
077311   *FLOME=*                               % FOR FLOMEM
077311          *JMP *+1
077312          5OPSEG;   CALL CSOK             % SET SPIT-SEGMENT OK
077314          ECODSEG;  CALL CSOK             % SET SEGMENT ERROR 14
077316          5RTSG;    CALL CSOK
077320          5MACDSEG; CALL CSOK
077322          5BADM;    CALL CSOK
077324          CALL SRELES                               % RELEASE SWAPPING-DEVS AND SWAPPING SEMAPHORE
077325          0=:FIXCRT                                 % MARK THAT NONE IS EXECUTING FIXC/FIXC5
077326          IF BACKGROUND><0 AND SVFLAGB BIT 5ESCON THEN CALL ESCON FI
077334          MLEV; *MST PIE
077336          GO XRELLREG
077337   *)FILL
077352
077352   %===========================================
077352   % M B S R E M O V E  -  X M B S R E M O V E
077352   %
077352   % LOCAL SUBROUTINE TO REMOVE ALL PAGES OF A SEGMENT FROM MEMORY
077352   %
077352   INTEGER POINTER MBSLREG
077353   INTEGER MBRFLG
077354   XMBSREMOVE: 1=:MBRFLG; GO MBFELLS
077357   MBSREMOVE:  0=:MBRFLG
077360   MBFELLS: A:=L=:"MBSLREG"
077362          X:=SGADR; T:=SEGTBANK; *SEGLI@3 LDATX
077365          IF A><0 THEN                              % HAS SEGMENT PAGES IN MEMORY?
077366             "1OUTSEGLINK"; *IOF; IRW SLEVB DP      % YES, REMOVE SEGMENT FROM SEGLINK.
077371             SLEV; *MST PID; ION
077374          FI; *FLAG@3 LDATX
077375          A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX      % SET SEGMENT NOT AVAILABLE (NOT OK)
077400          DO                                        % REMOVE ALL PAGES CURRENTLY IN SEGMENT
077400             X:=SGADR; T:=SEGTBANK; *BPAGL@3 LDXTX  % X:=SGADR.BPAGLINK
077403          WHILE X><0
077404             T:=CORMBANK; *PROTE@3 LDATX            % A:=(SGADR.BPAGLINK).PROTECT
077406             IF A BIT 5WIP AND MBRFLG=0 THEN        % WRITTEN IN PAGE?
077412                A:=1=:D; T:=SGADR; CALL ATRNSEG     % YES, WRITE PAGE TO MASS STORAGE
077416             FI; T:=XSGRT; SGADR; CALL XLINKOVER   % LINK PAGE TO DUMMY SEGMENT
077421          OD
077422          IF COLDFLAG BIT 5DEMAND THEN
077425             X:=SGADR; T:=SEGTBANK; *FLAG@3 STATX
077430          FI; GO MBSLREG
077431   *)FILL
077437
077437   %===================
077437   % P F I X C
077437   %
077437   % COMMON ROUTINE FOR MON FIXC AND MON FIXC5
077437   %
077437   INTEGER POINTER PPTTIF:=TTIFIELD
077440
077440   PFIXC: IF BACKGROUND><0 THEN
077442             PPTTIF.FLAGB=:SVFLAGB; CALL ESCOFF     % SAVE CURRENT ESCON/ESCOFF STATUS AND SET ESCOFF
077446          FI; CALL SRESER                           % RESERVE "SWAPPING SYSTEM"
077447          RTREF=:FIXCRT                             % CURRENT PROGRAM EXECUTING FIXC/FIXC5
077451          CALL FAR CLEALLSEGS                       % CLEAR ALL SEGMENTS FROM PIT
077452          0=:PAGPN
077453          MLEV; *MST PIE
077455   @ICR
077455          FIXFLAG GOSW 0F500,FAR 1F500,FAR 2F500,FAR 3F500,FAR 4F500,
077464         FAR 5F500,FAR 6F500,FAR 7F500,FAR 10F500,FAR 11F500,FAR 12F500,
077472         FAR 13F500;
077473   @CR;
077473   %
077473   % FIXFLAG=0: NORMAL MON FIXC
077473   % D0: SEGMENT NUMBER
077473   % D1: FIRST PHYSICAL PAGE
077473   %
077473   0F500: CALL FAR MBSREMOVE              % REMOVE SEGMENT FROM MEMORY
077474          NPAG-1+FPHYS=:CURPAGE           % CURRPAGE=LAST PHYSICAL PAGE NEEDED BY THE SEGMENT
077500          CALL FAR SGFIXC; GO 0ERR        % FIX SEGMENT CONTIGUOUSLY
077502          FIXPAGES+NPAG=:FIXPAGES         % UPDATE NUMBER OF PAGES FIXED IN THE SYSTEM
077505          CALL FAR XRELES                 % RELEASE SWAPPING SYSTEM
077506          IF D0 BIT 17 THEN 0=:ZAREG FI
077512          GO RETSTUPR                     % RETURN TO USER AFTER MON FIXC
077513
077513   0ERR:  CALL FAR XMBSREMOVE             % REMOVE ALL PAGES FROM THE SEGMENT
077514          CALL FAR XRELES                 % RELEASE SWAPPING SYSTEM
077515          IF D0 BIT 17 THEN -1=:ZAREG; GO RETSTUPR FI % GIVE ERROR RETURN
077523          CALL 9ERRA(#28); GO RETXIT      % ERROR MESSAGE AND TERMINATE CALLER
077526   *)FILL
077560
077560   %
077560   % FIXFLAG=1: RESERVE CONTIGUOUS MEMORY FOR ND-500
077560   % D1=NUMBER OF PAGES
077560   % D2=FIRST LEGAL PHYSICAL PAGE IN AREA TO RESERVE
077560   % D3=LAST LEGAL PHYSICAL PAGE IN AREA TO RESERVE
077560   % D4 MUST BE ZERO (IN PREVIOUS VERSIONS: NUMBER OF ND-500/ND-100 SHARED AREAS)
077560   %
077560   1F500: IF D4><0 GO 1E174                         % ILLEGAL PARAMETER (NO. OF SHARED AREAS)
077562          IF D1=0 GO 1E174                          % ZERO PAGES TO RESERVE IS ILLEGAL
077564          A+MINSWPAGES; CALL CHNSWPAGES; GO 1E174
077567          IF D2=0 THEN A:=1 FI; A=:AFPHYS           % FIRST PHYS.PAGE TO TEST
077573          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS    % LAST PHYS.PAGE TO TEST
077601          IF AFPHYS>>ALPHYS OR A+D1-1>>T GO 1E174   % ILLEGAL PARAMETERS (AREA NOT AVAILABLE)
077611          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY % SORT PAGE FREE LIST IN DESCENDING ORDER
077616          ALPHYS SH 2=:CECORMAP                     % MEMORY MAP ELEMENT OF LAST LEGAL PAGE
077621          AFPHYS SH 2=:X                            % X=MEMORY MAP OF FIRST PAGE IN AREA
077624   1LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND
077630          DO WHILE X<<=CECORMAP                     % SEARCH LEGAL AREA FOR AVAILABLE CONTIGUOUS PAGES
077633             T:=CORMBANK; *PROTE@3 LDATX
077635             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
077637                IF D1 SH 2+X>>CECORMAP GO 1ERR2     % NO, STILL POSSIBLE TO RESERVE AREA?
077645                X+4; GO 1LOOP                       % YES
077647             FI
077647             IF PGFOUND+1=D1 THEN                   % SUFFICIENT NO. OF PAGES FOUND?
077654                FPHYS+D1-1=:CURPAGE                 % LAST PAGE IN RESERVED AREA
077660                CALL FAR SGFIXC; CALL ERRFATAL      % LINK PAGES TO "ND-500"
077662                CALL FAR XRELES
077663                FPHYS=:ZAREG; PAGPN=:ZTREG; 0=:PAGPN % A=FIRST PAGE RESERVED, T=MEMORY MAP OF THIS PAGE
077670                MIN ZPREG; 0/\0
077672                GO RETSTUPR                         % OK RETURN
077673             FI; A=:PGFOUND; IF X+4=0 GO 1ERR2
077676          OD
077677   1ERR2: A:=0; GO 1ERRF                            % AREA NOT AVAILABLE
077701   1E174: A:=174
077702   1ERRF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
077705   *)FILL
077720
077720   % LOCAL SUBROUTINE FOR 2F500 TO RETURN A RESERVED MEMORY AREA
077720   % INTO THE USER SPECIFIED ADDR ON DPIT
077720   CRETMAREA: A:=D5+RETINDX:=:X                     % X=ADDR WHER THE RESULT WILL BE RETURNED
077723          A SHZ -2; T:=CPEND=:D; AD=:X.DS0          % A=FIRST PHYS.PAGE; D=LAST PHYS.PAGE IN RESERVED AREA
077727          IF RETINDX+2 SHZ -1+1>D4 GO FAR 2ERR2     % NO MORE SPACE FOR RETURNING MEMORY AREAS
077736          RETINDX+2=:RETINDX; 0=:CPEND
077742          EXIT
077743   *)FILL
077744   %
077744   % FIXFLAG=2: RESERVE SWAPPING PAGES FOR ND-500
077744   % D1=NUMBER OF PAGES
077744   % D2=NUMBER OF DIFFERENT MEMORY PARTS
077744   % D3=ADDR OF MEMEORY PART TABLE (ADDR IN DPIT)
077744   % D4=MAX NUMBER OF AREAS TO RESERVE
077744   % D5=ADDR WHER THE RESULT SHOULD BE RETURNED (ADDR IN DPIT)
077744   %
077744   2F500: IF D2=0 OR D4=0 GO FAR 2ERR1              % ILLEGAL PARAMETERS
077751          D1+MINSWPAGES; CALL CHNSWPAGES; GO FAR 2ERR1
077755          0=:PARTINDX=:RETINDX=:PGFOUND
077760          FOR PARTINDX DO WHILE PARTINDX<<=D2       % SEARCH ALL MEMEORY PARTS FOR AVAILABLE PAGES
077764             A SH 1+D3=:X; AD:=X.DS0                % A=FIRST PH.PAGE, D=LAST PH.PAGE IN MEMORY PART
077770             IF A=0 THEN A:=1 FI; A=:AFPHYS
077773             IF A:=D>>ENDPAGE THEN A:=T FI; A=:ALPHYS
100001             IF A<<AFPHYS GO NXPART                 % ILLEGAL MEMORY PART DESCR.
100004             A=:D:=AFPHYS
100006             T:=-1; CALL FAR SORTDUMMY              % SORT PAGE FREE LIST IN FALLING ORDER
100010             AFPHYS SH 2=:CECORMAP
100013             ALPHYS SH 2=:X
100016             0=:CPEND
100017             DO
100017                X=:CMMENTRY; T:=CORMBANK; *PROTE@3 LDATX
100022                IF A/\5CMMASK=0 THEN                % IS PAGE AVAILABLE?
100024                   IF CPEND=0 THEN A:=X SHZ -2=:CPEND FI % CPEND IS FIRST PAGE IN AN AREA
100031                   CALL FAR CFINDSEGMENT; A=:CSEGAD % FIND SEGMENT TABLE ENTRY OF PAGE-OWNER
100033                   CSEGAD; CALL OUTLINK             % LINK OUT REST OF SEGMENT IF NON DEMAND SEGMENT
100035                   T:=CORMBANK; *PROTE@3 LDATX
100037                   IF A BIT 5WIP THEN               % WRITTEN IN PAGE?
100041                      T:=SEGTBANK; X:=CSEGAD; *FLAG@3 LDATX % YES WRITE PAGE TO MASS STORAGE
100044                      A=:COLDFLAG BZERO 5OK; *FLAG@3 STATX
100047                      X:=CMMENTRY; T:=CSEGAD; A:=1=:D; CALL ATRNSEG
100054                      IF COLDFLAG BIT 5DEMAND THEN
100057                         X:=CSEGAD; T:=SEGTBANK; *FLAG@3 STATX
100062                      FI
100062                   FI; X:=CMMENTRY; A:=CSEGAD; CALL X5LINKOVER   % RESERVE PAGE FOR ND-500
100065                   PGFOUND+1=:PGFOUND
100070                   IF A=D1 THEN                     % SUFFICIENT NUMBER OF PAGES RESERVED?
100073                      CALL FAR CRETMAREA            % YES
100074                      RETINDX SHZ -1=:ZAREG; PAGPN=:ZTREG   % A=NUMBER OF INTERVALS; T=START OF "LINKED-MEMORY-ELEMENTS"
100101                      MIN ZPREG; 0/\0               % SKIP-RETURN
100103                      CALL FAR XRELES
100104                      GO RETSTUPR
100105                      *)FILL
100125                   FI
100125                ELSE
100126                   IF CPEND><0 THEN                 % AREA RESERVED?
100130                      X+4; CALL FAR CRETMAREA       % YES, UPDATE REUR INFO
100132                   FI
100132                FI
100132             WHILE X:=CMMENTRY>>CECORMAP
100136                X-4
100137             OD
100140             IF CPEND><0 THEN
100142                X+4; CALL FAR CRETMAREA
100144             FI
100144   NXPART:
100144         OD; GO 2ERR2
100147   *)FILL
100150   2ERR1: CALL FAR XRELES
100151          174=:ZAREG; GO RETSTUPR
100154
100154   % NOT SUFFICIENT NUMBER OF PAGES AVAIALBLE,
100154   % RELEASE THE PAGES ALREADY RESERVED
100154   2ERR2: X:=PAGPN; T:=CORMBANK
100156          DO WHILE X><0
100157             A:=0 BONE 5CMIDUM; *PROTE@3 STATX
100162             *PAGLI@3 LDXTX
100163          OD; X:=4; ENDPAGE SH 2=:CECORMAP
100170          DO CALL FAR IDUMLINK WHILE X><CECORMAP; X+4; OD
100176          2=:ZAREG; CALL FAR XRELES
100201          GO RETSTUPR
100202   *)FILL
100210
100210
100210   %
100210   % FIXFLAG=3: ILLEGAL IN K-VERSION
100210   %
100210   3F500: 174=:ZAREG; CALL FAR XRELES; GO RETSTUPR % ERROR RETURN
100214
100214
100214   %
100214   % FIXFLAG=4: FIX A SEGMENT CONTIGUOUS ANYWHERE INSIDE A SPECIFIED AREA
100214   % D1=SEGMENT NUMBER
100214   % D2=FIRST LEGAL PHYSICAL PAGE IN AREA
100214   % D3=LAST LEGAL PHYSICAL PAGE IN AREA
100214   %
100214   4F500: IF D1 <<2 OR A>>SGMAX GO FAR 4ERR2        % ILLEGAL SEGMENT NUMBER
100223          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
100226          X:=A; T:=SEGTBANK; *SEGLE@3 LDATX         % A=SEGMENT SIZE
100231          IF A=0 GO FAR 4ERR2                       % EMPRY SEGEMENT
100233          A=:NPAG
100234
100234          IF NPAG-1+D2>>ECORMAP SHZ -2 GO FAR 4ERR1 % OUTSIDE PHYSICAL MEMORY
100243          IF D2>>=D3 OR D2+NPAG-1>>T GO FAR 4ERR3 % WRONG PARAMETER VALUES
100254          T:=SEGTBANK; *FLAG@3 LDATX                % A=SEGMENT FLAG
100256          IF A BIT 5INHB GO FAR 4ERR2               % SEGMENT NOT LOADED
100260          IF A BIT 5DEMAND GO FAR 4ERR2             % DEMAND SEGMENT NOT LEGAL
100262          *SGSTA@3 LDATX                            % A=SEGMENT STATUS
100263          IF A=0 GO FAR 4ERR2                       % SEGMENT NOT LOADED
100265          IF A BIT 5FIX THEN                        % SEGMENT IS FIXED
100267             *BPAGL@3 LDXTX                         % CHECK IF FIXED CONTIGUOUS
100270             A:=X SHZ -2=:CURPAGE=:FPHYS            % FIRST PAGE IN SEGMENT
100274             T:=CORMBANK
100275             DO
100275                IF A:=X SHZ -2 -CURPAGE><0 GO FAR 4ERR2 % NOT FIXED CONTIGUOUS
100302                MIN CURPAGE; *PAGLI@3 LDXTX
100304             WHILE X><0
100305             OD; GO 4F5L1; *)FILL                   % FIXED CONTIGUOS
100322          FI; *FLAG@3 LDATX                         % A=SEGMENT FLAG
100323          IF A BIT 5FIXC THEN                       % SEGMENT ALREADY FIXED CONTIGUOUS
100325   4F5L1:    T:=SEGTBANK; X:=SGADR; *BPAGL@3 LDATX
100330             IF A SHZ -2>>=D2 AND A-1+NPAG<<=D3 GO 4F5OK % FIXED CONTIGUOUS IN LEGAL ADDRS
100341             GO 4ERR2                               % FIXED CONTIGUOUS IN WRONG ADDR
100342          FI
100342          IF NPAG+FIXPAGES>>FIXMAX GO FAR 4ERR3     % TOO MANY FIXED PAGES
100347          NPAG+MINSWPAGES; CALL CHNSWPAGES; GO FAR 4ERR3
100353          CALL FAR MBSREMOVE
100354          IF D2=0 THEN A+1 FI; A=:AFPHYS            % PAGE #0 IS UNAVAILABLE
100360          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS
100366          IF AFPHYS+NPAG-1>>ALPHYS GO 4ERR3         % TOO SMALL AREA SPECIFIED
100374          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY
100401          AFPHYS SH 2=:X                            % AFPHYS=FIRST LEGAL PHYSICAL PAGE
100404          ALPHYS SH 2=:CECORMAP                     % ALPHYS=LAST LEGAL PHYSICAL PAGE
100407   4LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND            % FPHYS=FIRST PHYS. PAGE USED
100413          DO
100413             T:=CORMBANK; *PROTE@3 LDATX
100415             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
100417                X+4                                 % NO, STILL POSSIBLE TO FIXC SEGMENT WITHIN AREA?
100420                IF A:=X SHZ -2 -1+NPAG>>ALPHYS GO 4ERR0
100427                GO 4LOOP                            % YES
100430             FI
100430             IF PGFOUND+1=NPAG THEN               % AREA FOUND?
100435                FPHYS-1+NPAG=:CURPAGE             % YES, CURRPAGE IS LAST USED PAGE
100441                CALL FAR SGFIXC; CALL ERRFATAL    % FIXC SEGMENT
100443                NPAG+FIXPAGES=:FIXPAGES           % UPDATE NUMBER OF FIXED PAGES COUNTER
100446                GO 4F5OK
100447             FI; A=:PGFOUND
100450          WHILE X<<CECORMAP
100453             X+4
100454          OD
100455   4ERR1: A:=1; GO 4ERRF                            % OUTSIDE MEMORY
100457   4ERR2: A:=2; GO 4ERRF                            % SOMETHING WRONG WITH THE SEGMENT
100461   4ERR3: A:=3                                      % WRONG PARAMETERS OR TOO MANY FIXED
100462   4ERRF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR
100465   4ERR0: 0=:ZAREG; CALL FAR XMBSREMOVE
100467          CALL FAR XRELES; GO RETSTUPR
100471   4F5OK: T:=SEGTBANK; X:=SGADR; *SGSTA@3 LDATX
100474          IF A BIT 5FIX GO 4F5UT; *FLAG@3 LDATX
100477          A BONE 5FIXC; *FLAG@3 STATX               % MARK SEGMENT FIXED CONTIGUOUS
100501   4F5UT: X:=SGADR; T:=SEGTBANK; *BPAGL@3 LDATX
100504          A SHZ -2=:ZAREG                           % FIRST PHYSICA PAGE USED BU THE SEGMENT
100506          CALL FAR XRELES; MIN ZPREG; 0/\0
100511          GO RETSTUPR
100512   *)FILL
100533
100533   %
100533   % RESERVE A CONTIGUOUS MEMORY AREA
100533   % D1=NUMBER OF PAGES TO RESERVE
100533   % D2=FIRST LEGAL PHYSICAL PAGE
100533   % D3=LAST LEGAL PHYSICAL PAGE
100533   %
100533   5F500: IF D1=0 GO 5ERR3                          % ERROR, NO PAGES TO RESERVE
100535          D1+MINSWPAGES; CALL CHNSWPAGES; GO 5ERR3
100541          IF D2>>=D3 OR A+D1-1>>T GO 5ERR3          % ILLEGAL SPECIFIED AREA
100551          X:=FXCTAB                                 % SEARCH FOR FREE ENTRY IN FXCTABLE
100552          DO WHILE X<<EFXCTAB
100555             T:=MBFXCTAB; *LDATX
100557             IF A=0 GO 5F5L1                        % IF ENTRY=0 THEN FREE
100560             X+2
100561          OD; GO 5ERR2                              % NO FREE ENTRY FOUND
100563   5F5L1: X=:CFXCTADDR                              % X=ADDR OF FREE ENTRY IN FXCTAB
100564          D1=:NPAG
100566          IF D2=0 THEN A+1 FI; A=:AFPHYS            % D2=FIRST LEGAL PHYSICAL PAGE
100572          IF D3>>ENDPAGE THEN A:=T FI; A=:ALPHYS    % D3=LAST PHYSICAL PAGE
100600          IF AFPHYS+NPAG-1>>ALPHYS GO 5ERR1         % OUTSIDE MEMORY OR TOO SMALL LIMITS SEPCIFIED
100606          A:=ALPHYS=:D:=AFPHYS; T:=-1; CALL FAR SORTDUMMY
100613          ALPHYS SH 2=:CECORMAP
100616          AFPHYS SH 2=:X
100621   5LOOP: A:=X SHZ -2=:FPHYS; 0=:PGFOUND            % FPHYS=FIRST PHYS. PAGE USED
100625          DO
100625             T:=CORMBANK; *PROTE@3 LDATX
100627             IF A/\5CMMASK><0 THEN                  % CAN THIS PAGE BE USED?
100631                X+4                                 % NO, STILL POSSIBLE TO ALLOCATE AREA WITHIN LIMITS?
100632                IF A:=X SHZ -2 -1+NPAG>>ALPHYS GO 5ERR0
100641                GO 5LOOP                            % YES
100642             FI
100642             IF PGFOUND+1=NPAG THEN                 % AREA FOUND?
100647                FPHYS-1+NPAG=:CURPAGE               % YES, CURRPAGE IS LAST USED PAGE
100653                CALL FAR SGFIXC; CALL ERRFATAL      % FIXC SEGMENT
100655                GO 5F5OK
100656             FI; A=:PGFOUND
100657          WHILE X<<CECORMAP
100662             X+4
100663          OD
100664   5ERR0: A:=0; GO 5ERFELLS                        % AREA ALREADY OCCUPIED
100666   5ERR1: A:=1; GO 5ERFELLS                         % OUTSIDE MEMORY
100670   5ERR2: A:=2; GO 5ERFELLS                         % NO FREE ENTRY IN FXCTABLE.
100672   5ERR3: A:=3                                      % WRONG PARAMETERS OR TOO MANY FIXED
100673   5ERFELLS: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR
100676   5F5OK: T:=MBFXCTAB; X:=CFXCTADDR+1; A:=RTREF; *STATX % SET RT-PROGR. RESERVING THE AREA
100703          A:=X-FXCTAB=:ZTREG; FPHYS=:ZAREG           % T=TABLE INDEX, A=FIRST PHYS PAGE ALLOCATED
100710          CALL FAR XRELES; MIN ZPREG; 0/\0
100713          GO RETSTUPR
100714   *)FILL
100732
100732   %
100732   % FIXFLAG=6: RELEASE A CONTIGUOUS MEMORY AREA
100732   % D1: RESERVED MEMORY AREA INDEX OF AREA TO RELEASE
100732   % D2: FIRST PHYSICAL PAGE IN AREA TO BE RELEASED
100732   %
100732   6F500: IF D1-1+FXCTAB>>=EFXCTAB OR A BIT "0" GO 6ERR3 % ILLEGAL INDEX
100742          A=:D1
100743          T:=MBFXCTAB; X:=D1; *LDATX
100746          IF A SHZ -2><D2 GO 6ERR3                     % ILLEGAL PHYSICAL PAGE
100752          IF D2=0 GO 6ERR3                             % ILLEGAL PHYSICAL PAGE
100754          CALL FAR RLSAREA                             % LINK PAGES TO DUMMY SEGMENT
100755          0=:ZAREG; MIN ZPREG; 0/\0
100760          CALL FAR XRELES; GO RETSTUPR                 % OK RETURN
100762   6ERR3: 3=:ZAREG; CALL FAR XRELES; GO RETSTUPR       % ERROR RETURN
100766   *)FILL
100774
100774
100774   %
100774   % FIXFLAG=7: RELEASE ALL MEMORY AREA RESERVED BY A SPECIFIED PROGRAM
100774   % D1: PROGRAM TO RELEASE MEMORY AREAS FOR (=0 MEANS CALLING PROGRAM)
100774   %
100774   7F500: IF D1=0 THEN RTREF=:D1 FI
101000          IF A<<RTSTART OR A>>=RTEND GO 7ERR3       % ILLEGAL RT.PROGR
101006          A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
101013          IF D><0 GO 7ERR3                          % ILLEGAL RT.PROGR
101015          FXCTAB=:CFXCTADDR
101017          DO WHILE X:=CFXCTADDR<<EFXCTAB            % SEARCH TABLE FOR AREA RESERVED BY SPECIFIED PROGR
101023             T:=MBFXCTAB; *LDDTX
101025             IF D=D1 AND A><0 THEN CALL FAR RLSAREA FI
101032             CFXCTADDR+2=:CFXCTADDR
101035          OD; 0=:ZAREG; MIN ZPREG; 0/\0
101041          CALL FAR XRELES; GO RETSTUPR              % OK RETURN
101043   7ERR3: 3=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
101047   *)FILL
101060
101060   %
101060   % FIXFLAG=10; GET SEGMENT INFO
101060   % D1=SEGMENT NUMBER
101060   % D2=LOGICAL PAGE WITHIN SEGMENT
101060   %
101060   10F500:
101060          IF D1>>SGMAX OR A<<2 GO 174ER             % ILLEGAL SEGMENT NUMBER
101067          A*5SEGSIZE+SEGSTART=:SGADR                % SEGMENT TABLE ELEMENT ADDR
101072          X:=SGADR; T:=SEGTBANK; *FLAG@3 LDATX
101075          IF A BIT 5INHB GO 174ER                   % SEGMENT NOT USED
101077          *SGSTA@3 LDATX
101100          IF A=0 GO 10ER2                           % SEGMENT NOT LOADED
101101          *SEGLE@3 LDATX
101102          IF A=0 GO 174ER                           % EMPTY SEGMENT
101103          IF A<<D2 GO 174ER                         % ILLEGAL LOGICAL PAGE SPECIFIED IN MON.CALL
101106          0=:ZTREG
101107          T:=SEGTBANK; *SGSTA@3 LDATX
101111          IF A BIT 5FIX THEN 1=:ZTREG FI            % SEGMENT IS FIXED
101115          *FLAG@3 LDATX
101116          IF A BIT 5FIXC THEN 2=:ZTREG FI           % SEGMENT IS FIXED CONTIGUOUSLY
101122          IF ZTREG><0 THEN                          % SEGMENT IS FIXED
101124             D:=0                                   % PAGE WITHIN SEGMENT
101125             *BPAGL@3 LDXTX
101126             DO
101126                IF D2=D THEN
101131                   A:=X SHZ -2=:ZAREG               % FPYSICAL PAGE OF ACTUAL PAGE WITHIN SEGMENT
101134                   GO 10FOK
101135                FI; D+1
101136                IF X=0 GO 174ER
101137                T:=CORMBANK; *PAGLI@3 LDXTX
101141             OD
101142          FI; 0=:ZAREG
101143   10FOK: T:=SEGTBANK; X:=SGADR; *FLAG@3 LDATX
101146          A=:ZDREG; MIN ZPREG; 0/\0                 % D=SEGMENT FLAG
101151          CALL FAR XRELES; GO RETSTUPR              % OK RETURN
101153   174ER: 174; GO 10ERF
101155   10ER2: 2
101156   10ERF: A=:ZAREG; CALL FAR XRELES; GO RETSTUPR    % ERROR RETURN
101161   *)FILL
101170
101170   % FIXFLAG=11; GET INFO. ABOUT A PROGRAM'S ATTATCHED SEGMENTS
101170   % D1=RT-PROGRAM
101170   % D2=ADDR OF BUFFER WHERE INFO WILL BE RETURNED.
101170   %
101170   DISP 0; INTEGER POINTER PPD3=D3; PSID
101170
101170   % LOCAL SUBROUTINE TO SAVE "SEGMENT-INFO".
101170   % ENTRY: A=SEGMENT NUMBER; T="SEGMENT-INFO-ELEMENT" INDEX (0-2).
101170   %
101170   SUB11F500:
101170          IF A><0 THEN
101171             A:=:T*5+"D4"+B=:D3                     % ADDR IN SEG.INFO ARRAY
101176             T=:PPD3; MIN D3                        % SEGMENT NUMBER
101200             A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *LOGAD@3 LDATX
101206             A=:PPD3; MIN D3                        % SEGMENT'S FIRST LOGICAL PAGE
101210             *SEGLE@3 LDATX
101211             A=:PPD3; MIN D3                        % SEGMENT LENGTH IN PAGES
101213             *SGSTA@3 LDATX
101214             A=:D; *FLAG@3 LDATX
101216             T:=0
101217             IF A BIT 5SYSEGM THEN T BONE "0" FI    % SYSTEM SEGMENT
101222             IF A BIT 5SPROT THEN T BONE 1 FI       % PROTECTED SEGMENT
101225             IF A BIT 5SREEP THEN T BONE 2 FI       % REENTRANT SUBSYSTEM SEGMENT
101230             IF A BIT 5FIX THEN T BONE 3 FI         % SEGMENT IS FIXED
101233             IF A BIT 5FIXC THEN T BONE 4 FI        % SEGMENT IS FIXED CONTIGUOUSLY
101236             IF A BIT 5DEMAND THEN T BONE 5 FI      % DEMAND SEGMENT
101241             A:=D/\163000; T\/A                     % WP,RP,FP AND RING
101244             T=:PPD3; MIN D3                        % SEGMENT "STATUS"
101246             IF T BIT 5CMSYS THEN
101250                T:=SEGTBANK; *BPAGL@3 LDATX
101252                A SHZ -2=:PPD3                      % PHYSICAL PAGE NUMBER OF SEGMENT
101254             FI
101254          FI; EXIT
101255   *)FILL
101263
101263   11F500:
101263          IF D1=0 THEN RTREF=:D1 FI
101267          IF A<<RTSTART OR A>>=RTEND GO 174ER       % NOT RT-DESCR. ADDR.
101275          A:=A-RTSTART=:D:=0; T:=5RTSIZE; *RDIV ST
101302          IF D><0 GO 174ER                          % NOT RT-DESCR ADDR.
101304          OLDPAGE=:D; A:=D2; T:=22; X:=RTREF
101311          CALL CHLIM; GO 11ERF                      % CHECK ADDR OF USER'S BUFFER
101313          "D4"+B=:D3=:X; T:=X+22
101321          DO WHILE X<<T; 0=:X.S0; X+1; OD           % CLEAR ARRAY
101326          T:=0; D1.ACT1SEG; CALL SUB11F500
101332          T:=1; D1.ACT2SEG; CALL SUB11F500
101336          T:=2; D1.RSEGM; CALL SUB11F500
101342          A:=3*5+"D4"+B=:D3
101347          IF CCFPAGE><100 THEN                      % ANY RT-COMMON IN THIS SYSTEM?
101353             ARTFPAGE=:PPD3; MIN D3                 % YES, SAVE FIRST LOG.PAGE
101356             CCLPAGE-CCFPAGE+1=:PPD3=:T; MIN D3     % RT-COMMON SIZE
101364             ARTFPAGE SH 1+IRTCPIT=:X
101370             X.S1=:D=:L                             % FIRST PHYS.PAGE OF RT-COMMON
101373             DO WHILE T><0                          % IS RT-COMMON CONTIGUOUS IN PHYS.MEM?
101375                IF X.S1><D GO RTCNCONTIG
101400                D+1; X+2; T-1
101403             OD; A:=L=:PPD3                         % FIRST PHYS PAGE OF RT-COMMON
101406   RTCNCONTIG:
101406          FI; CALL FAR XRELES
101407          *IOF
101410          "STUPR"; *IRW MLEVB DP
101412          MLEV; *MST PIE; MST PID; ION
101416          A:=B+"D4"=:D; T:=D2; X:=22; A:=OLDPAGE
101424          K:=1; CALL MOVUS                          % COPY SEGMENT-INFO ARRAY TO USER AREA
101426          MIN ZPREG; 0/\0                           % SKIP-RETURN
101430          GO RET
101431
101431   11ERF: ER92=:ZAREG; CALL FAR XRELES; GO RETSTUPR % ERROR RETURN
101435   *)FILL
101454
101454   % FIXFLAG=12:  RELEASE A MEMORY AREA RESERVED BY FIXC5 OR
101454   %              RELEASE A MEMORY AREA SETUP IN NINITPAGES
101454   % FIXFLAG=13:  RELEASE A MEMORY AREA RESERVED BY FIXC5 OR
101454   %              RELEASE A MEMORY AREA SETUP IN LAMAR
101454   %
101454   % D1: ><0: RESERVED MEMORY AREA INDEX TO RELEASE
101454   %     =0:  RELEASE AN AREA IN NINITPAGES
101454   % D2: FIRST PHYS PAGE IN MEM.AREA
101454   % D3: NUMBER OF PAGES TO RELEASE (DUMMY WHEN PAR1><0)
101454   %
101454   12F500:X:="NINITPAGES";GO 1213F
101456   13F500:X:="LAMAR"
101457   1213F: D2+D3; IF C GO FAR 174ER
101463          IF A=0 GO FAR 174ER; A-1=:D3        % LAST PHYS.PAGE IN AREA
101467          A:=NINSZ SH 1+X=:L                  % L=END OF NINITPAGES TABLE
101473          DO WHILE X<<L
101475             T:=0; *LDDTX
101477             IF A BZERO 17 =D2 AND D=D3 THEN  % BIT 17 SET TO PREVET CRE-LAMU IN AREA
101506                A:=0; D:=0; T:=0; *STDTX      % CLEAR AREA
101512                IF D1><0 THEN                 % RELEASE MEMORY RESERVED BY MON FIXC5
101514                  6=:FIXFLAG; GO FAR 6F500
101517                FI
101517                D2 SH 2=:X; D3 SH 2=:D3
101525                DO
101525                   T:=CORMBANK; A:=0 BONE 5CMIDUM; *PROTE@3 STATX
101531                   *PAGLI@3 STZTX; PREVI@3 STZTX; LOGPA@3 STZTX
101534                   CALL FAR IDUMLINK                % LINK PAGE INTO DUMMY SEGMENT
101535                WHILE X+4<<D3
101541                OD
101542                CALL FAR XRELES; MIN ZPREG; 0/\0    % SKIP-RETURN
101545                GO RETSTUPR
101546             FI; X+2
101547          OD
101550          174=:ZAREG; CALL FAR XRELES; GO RETSTUPR  % NO SUCH AREA IN NINITPAGES TABLE
101554   RBUS
101564
101564
101564   %============================================================================
101564   %      ( R )       C H N S W P A G E S
101564   %
101564   % SUBROUTINE TO CHECK FOR IF THE REQUIRED NUMBER OF PAGES IS AVAILABLE
101564   % FOR SWAPPING
101564   %
101564   % ENTRY:     A=REQUIRED NUMBER OF PAGES FO SWAPPING
101564   %            A=-1 MEANS FIND NUMBER OF PAGES FOR SWAPPING IN THE SYSTEM
101564   %                 (PAGES THAT IS NOT FIXED, NOT RESERVED FOR SPECIAL USE..)
101564   %
101564   % EXIT:      NOT SUFFICIENT PAGES FOR SWAPPING
101564   %            A=ACTUAL NUMBER OF PAGES FOR SWAPPING
101564   %
101564   % EXIT+1:    SUFFICIENT PAGES FOR SWAPPING
101564   %            A=REQUIRED NUMBER OF PAGES FOR SWAPPING
101564   %
101564   SUBR CHNSWPAGES
101564   INTEGER REQPAGS,NPAG,CSEG,XREG
101570   CHNSWPAGES:
101570          IF A=0 THEN EXITA FI
101572          *IOF
101573          A=:REQPAGS; 0=:NPAG; X=:XREG
101576          IF X:=BSEGLINK=0 THEN CALL ERRFATAL FI
101602          DO
101602             X=:CSEG; T:=SEGTBANK; *BPAGL@3 LDXTX
101605             DO WHILE X><0
101606                IF NPAG+1=REQPAGS THEN L+1; GO OUT FI
101615                A=:NPAG; T:=CORMBANK; *PAGLI@3 LDXTX
101620             OD; X:=CSEG; T:=SEGTBANK; *SEGLI@3 LDXTX
101624          WHILE X><BSEGLINK
101627          OD; A:=NPAG
101631   OUT:   X:=XREG
101632          *ION; EXIT
101634   RBUS
101640
101640
101640   %============================================================================
101640   %      ( R )        O U T L I N K
101640   %
101640   % SUBROUTINE TO REMOVE PAGES FROM A NON-DEMAND SEGMENT
101640   %
101640   % ENTRY:     X=MEMORY MAP ELEMENT OF FIRST PAGE NOT TO REMOVE
101640   %            A=SEGMENT ADDR.
101640   %
101640   SUBR OUTLINK
101640   INTEGER POINTER LREG
101641   INTEGER XREG,AREG
101643   OUTLINK: X=:XREG; A=:AREG:=L=:"LREG"
101647          IF AREG=XSGRT GO OUT                      % DUMMY SEGMENT
101653          X:=AREG; T:=SEGTBANK; *FLAG@3 LDATX
101656          IF A BIT 5DEMAND GO OUT                   % DEMAND SEGMENT
101660          *BPAGL@3 LDATX
101661          IF A=XREG GO OUT                          % NO PAGES TO REMOVE
101664          T:=SEGTBANK; *FLAG@3 LDATX
101666          A BZERO 5OK; *FLAG@3 STATX
101670          DO
101670             X:=AREG; T:=SEGTBANK; *BPAGL@3 LDXTX
101673          WHILE X><XREG
101676             T:=CORMBANK; *PROTE@3 LDATX
101700             IF A BIT 5WIP THEN                     % WRITTEN IN PAGE?
101702                A:=1=:D; T:=AREG; CALL ATRNSEG      % YES, WRITE PAGE TO MASS STORAGE
101706             FI; T:=XSGRT; AREG; CALL XLINKOVER
101711          OD
101712   OUT:   X:=XREG; GO LREG
101714   RBUS
101721
101721
101721   %============================================================================
101721   %      ( R )   X S L I N K O V E R   -   X 5 L I N K O V E R
101721   %              X A L I N K O V E R
101721   %
101721   % SUBROUTINE TO LINK A PAGE FROM A SEGMENT INTO
101721   %            ANOTHER SEGMENT       (XLINKOVER)
101721   %            TO ND-500 MEMORY      (X5LINKOVER)
101721   %            ALLOCATED MEMORY AREA (XALINKOVER)
101721   %
101721   % ENTRY:     T=ADDRESS OF SEGMENT TO LINK PAGE INTO
101721   %            X=ADDRESS OF CORMAP ENTRY
101721   %            A=ADDRESS OF SEGMENT TO LINK PAGE FROM
101721   %
101721   SUBR XLINKOVER,X5LINKOVER,XALINKOVER
101721
101721   INTEGER CMMELEMENT=?                             % MEMORY MAP ELEMENT
101721   INTEGER TOSEG=?                                  % SEGMENT TO LINK PAGE INTO
101721   INTEGER FRSEG=?                                  % SEGMENT TO LINK PAGE FROM
101721   INTEGER ROUTSWITCH=?                             % ROUTINE SWITCH
101721   INTEGER CFXCTADDR=?                              % ADDR OF ENTRY IN FXCTAB
101721
101721   X5LINKOVER: A=:FRSEG:=2; GO FELLS
101724   XALINKOVER: A=:FRSEG:=1; GO FELLS
101727   XLINKOVER: A=:FRSEG:=0
101731   FELLS: A=:ROUTSWITCH; T=:TOSEG; X=:CMMELEMENT
101734          T:=CORMBANK; *PAGLI@3 LDATX               % A=CMMELEMENT.PAGLI
101736          A=:D
101737          IF A><0 THEN
101740             *PREVI@3 LDATX                         % A:=CMMELEMENT.PREVIOUS
101741             X:=:D; *PREVI@3 STATX                  % CMMELEMENT.PREVIOUS=:(CMMELEMENT.PAGLINK).PREVIOUS
101743             X:=:D
101744          FI; *PREVI@3 LDATX                        % A:=CMMELEMENT.PREVIOUS
101745          IF A BIT 0 OR A BIT 1 THEN
101751             X:=FRSEG; T:=SEGTBANK; *AAX BPAGL      % CMMELEMENT FIRST IN PAGELINK
101754          ELSE
101755             X:=A
101756          FI; A:=D; *PAGLI@3 STATX                  % CMMELEMENT=:(CMMELEMENT.PREVIOUS).PAGLINK
101760          X:=FRSEG; T:=SEGTBANK; *BPAGL@3 LDATX
101763          IF A=0 THEN                               % HAS FRSEG ANY PAGES LEFT IN MEMORY?
101764             *SEGLI@3 LDATX
101765             IF A><0 THEN                           % NO, IS FRSEG IN SEGLINK?
101766                "1OUTSEGLINK"; *IOF; IRW SLEVB DP   % YES, REMOVE FRSEG FROM SEGLINK
101771                SLEV; *MST PID; ION
101774             FI
101774          FI; GO L1; *)FILL
102000
102000   INTEGER CMMELEMENT                               % MEMORY MAP ELEMENT
102001   INTEGER TOSEG                                    % SEGMENT TO LINK PAGE INTO
102002   INTEGER FRSEG                                    % SEGMENT TO LINK PAGE FROM
102003   INTEGER ROUTSWITCH                               % ROUTINE SWITCH
102004   INTEGER CFXCTADDR=TOSEG                          % INDEX IN FXCTAB
102004
102004   L1:    IF ROUTSWITCH=0 THEN                      % LINK PAGE FROM SEGMENT TO SEGMENT
102006             X:=TOSEG; T:=SEGTBANK; *BPAGL@3 LDATX
102011             A=:D:=CMMELEMENT; *BPAGL@3 STATX       % CMMELEMENT=:TOSEG.BPAGLINK
102014             *SGSTA@3 LDATX
102015             X:=CMMELEMENT; T:=CORMBANK; *PROTE@3 STATX % TOSEG.SGSTATUS=:CMMELEMENT.PROTECT
102020             A:=D; *PAGLI@3 STATX                   % TOSEG.BPAGLINK=:CMMELEMENT.PAGLINK
102022             IF A><0 THEN                           % ONLY THIS PAGE IN TOSEG.PAGLINK?
102023                X:=:A; *PREVI@3 STATX               % NO, CMMELEMENT=:TOSEG.PREVIOUS
102025             FI; A:=TOSEG-SEGSTART=:D:=0; T:=5SEGSIZE; *RDIV ST
102033             IF D><0 THEN CALL ERRFATAL FI          % A=SEGMENT NUMBER OF TOSEG
102036             A SHZ 2+3; X:=CMMELEMENT; T:=CORMBANK  % A BIT 2-15: SEGMENT NO. BIT 0-1:3
102042             *PREVI@3 STATX                         % A=:CMMELEMENT.PREVIOUS
102043             IF X:=TOSEG=XSGRT THEN
102047                T:=SEGTBANK; *SEGLI@3 LDATX
102051                IF A=0 THEN                         % SEGMENT IN SEGLINK?
102052                   "1INSEGLINK"; *IOF; IRW SLEVB DP % NO, INSERT IT IN SEGLINK
102055                   SLEV; *MST PID; ION
102060                FI
102060                T:=SEGTBANK; *IOF; SEGLI@3 LDATX    % SET XSGRT LAST IN SEGLINK
102063                A=:BSEGLINK; *ION
102065             FI
102065          FI
102065          IF ROUTSWITCH=1 THEN                      % LINK TO "RESERVED MEMORY AREA"
102071             X:=CFXCTADDR; T:=MBFXCTAB; *LDATX
102074             X:=CMMELEMENT; T:=CORMBANK; *PAGLI@3 STATX
102077             A:=0 BONE 5CMRES; *PROTE@3 STATX       % MARK PAGE IS IN RESERVED MEMORY AREA
102102             X:=CFXCTADDR; T:=MBFXCTAB
102104             CMMELEMENT; *STATX
102106          FI
102106          IF ROUTSWITCH=2 THEN                      % LINK TO ND-500
102112             PAGPN; X:=CMMELEMENT; T:=CORMBANK; *PAGLI@3 STATX
102116             A:=0 BONE 5CMRES; *PROTE@3 STATX       % MARK THAT PAGE IS RESERVED FOR "SPECIAL USE"
102121             X=:PAGPN
102122          FI; T:=SEGTBANK; X:=FRSEG; *FLAG@3 LDATX
102125          IF A NBIT 5DEMAND THEN
102127             A BZERO 5OK; *FLAG@3 STATX             % SEGMENT NOT OK WHEN NONDEMAND SEG
102131          FI; X:=CMMELEMENT; A:=FRSEG; T:=TOSEG
102134          EXIT
102135   RBUS
102146
102146
102146   %========================================================================
102146   %  34.36     E D T R M
102146   %
102146   % MONITOR CALL TO ENABLE/DISABLE PROGRAM TERMINATION HANDLING
102146   %
102146   % MONITOR CALL (206): ISTAT=EDTRM(<ENABLE/DISABLE>,<RT/UB/FE>
102146   %                                 <  1   /   0   >,< 0/ 1/ 2>
102146   %
102146   %
102146
102146   SUBR EDTRM
102146
102146   EDTRM: CALL GET2
102147          IF BACKGROUND><0 THEN
102151                IF D1=0 GO ILLPA
102153          ELSE
102154                IF D1>0 GO ILLPA
102157          FI
102157          IF D1=0 THEN          % RT
102161                IF D0=0 THEN    % DISABLE
102163                   0=:FLRTTERM
102164                ELSE            % ENABLE
102165                   IF RTTERM=0 GO ILLPA
102167                   1=:FLRTTERM
102171                FI
102171          ELSE                  % BACKGROUND
102172                MLEV; *MST PIE  % ENABLE MONITOR LEVEL
102174                IF TRMDEF=0 GO ILLPA
102176                IF D1 BIT "0" THEN % USER-BREAK
102201                   IF D0=0 THEN   % DISABLE
102203                      FLBGTERM BZERO "0"=:FLBGTERM
102206                   ELSE           % ENABLE
102207                      FLBGTERM BONE "0"=:FLBGTERM
102212                   FI
102212                FI
102212                IF D1 BIT 1 THEN % FATAL-ERROR
102215                   IF D0=0 THEN   % DISABLE
102217                      FLBGTERM BZERO 1=:FLBGTERM
102222                   ELSE           % ENABLE
102223                      FLBGTERM BONE 1=:FLBGTERM
102226                   FI
102226                FI
102226          FI; A:=0; GO OUT
102230
102230   ERR:   -1; GO OUT            % ERROR WHEN ACCESSING OPCOM SEGMENT
102232   ILLPA: 174                   % ILLEGAL PARAMETER
102233   OUT:   A=:ZAREG; GO RET
102235   RBUS
102244
102244
102244
102244   %========================================================================
102244   %  34.37     M P A S E T   M P A G E T
102244   %
102244   %  MONITOR CALL TO SET (56) AND GET (57) USER PARAMETERS
102244   %  CALLABLE FROM BACKGROUND ONLY
102244   %
102244   %  IERR=PASET(APAR),  IERR=PAGET(APAR)
102244   %
102244
102244   SUBR MPASET,MPAGET
102244
102244   MPASET: K:="0"; GO FSGPAR
102246   MPAGET: K:=1
102247   FSGPAR: CALL GETP0                               % GET ADDR OF ARRAY
102250          MLEV; *MST PIE
102252          IF K THEN
102254             "USPAR"=:D; T:=D0                      % GET PARAMETERS
102257          ELSE
102260             D0=:D; T:="USPAR"                      % SET PARAMETERS
102263          FI; X:=5; A:=OLDPAGE; CALL MOVUS          % COPY BETWEEN USER AND SYS.SEG
102266          0=:ZAREG; GO RET                          % A=0 ON RETURN
102270   RBUS
102274
102274
102274   %=============================================================================
102274   %  34.38     R E R R P
102274   %
102274   %  MONITOR CALL (207) TO READ ERROR PARAMETERS (9ERRP+ABPRO)
102274   %
102274   %  CALL RERRP(IARR)
102274   %
102274   %      IARR(1) = ERNUMB (ASCII)
102274   %      IARR(2) = ERPREG
102274   %      IARR(3) = N1 (A-REG)
102274   %      IARR(4) = N2 (T-REG)
102274   %      IARR(5) = RTPROG
102274   %      IARR(6) = ABPRO (0 IF ABORTED BY SYSTEM, ELSE RTPROG)
102274   %
102274
102274   SUBR RERRP
102274
102274   DISP 0; REAL FS0=S0,FS1=S3; PSID
102274
102274   RERRP: CALL GETP0
102275          MLEV; *MST PIE
102277          OLDPAG=:D; D0; T:=6; X:=RTREF; CALL CHLIM; GO ILLAD
102306          "9ERRP"=:D; T:=D0; X:=6; K:="1";  A:=OLDPAGE; CALL MOVUS
102315          A:=0
102316   OUT:   A=:ZAREG; GO RET
102320   ILLAD: 153; GO OUT           % ILLEGAL ADDRESS REF. IN MONITOR CALL
102322
102322   RBUS
102330
102330
102330   %==============================================================================
102330   %      ( R )     M S G
102330
102330   % MONITOR CALLS TO PRINT USER MESSAGE
102330   % X POINTS TO STRING, TERMINATED BY ',AND $ MEANS CRLF
102330   SUBR MSG
102330   TCX:   T:=1; *MON 2OUTB
102332          GO 3FILERR; EXIT
102334
102334   MSG:   CALL GET0
102335          T:=ZXREG; OLDPAGE=:D; CALL DALTON
102341          T=:D; MLEV; *MST PIE
102344          FOR X:=0 TO 1000 DO
102350                T:=D; *LBYT
102352                WHILE><##'
102355                IF A=##$ THEN 15; CALL TCX; 12 FI; CALL TCX
102364          OD; CALL SINALTPIT
102367          A:=X SHZ -1+1+ZXREG=:ZXREG
102374          CALL XBMRET
102375          GO RET
102376   RBUS
102405
102405
102405
102405   %======================================================================
102405   %
102405   %      ( R )      G E R D V
102405   %
102405   %  MONITOR CALL TO RETURN ERROR DEVICE (LOGICAL NUMBER) AND BY WHOM
102405   %  IT MIGHT BE RESERVED.
102405   %  (MON 254)
102405   %
102405
102405   SUBR GERDV
102405   INTEGER POINTER PTTNO:=TTNO
102406
102406   DISP 0
102406   INTEGER SVRSEGM=D1           % CALLERS RSEGM
102406   PSID
102406   GERDV: CALL GET0
102407          MLEV; *MST PIE                            % ENABLE MONITOR LEVEL FOR SWITCHING SEGMENTS
102411          RTREF.ACT2SEG=:D; 0=:X.ACT2SEG            % SAVE CALLERS SEGMENT
102415          X.RSEGM=:SVRSEGM; 0=:X.RSEGM
102420          T:=5ERRSEG; CALL M1MEXY; A:=PTTNO:=:D
102424          A=:X.ACT2SEG                              % RESET CALLERS SEGMENTS
102425          CALL M1MEXY; A:=D=:ZAREG                  % A=LOG.DEV.NO OF ERROR DEVICE
102430          CALL LOGPH; A:=D.RTRES=:ZDREG             % D=PROGR. RESERVING THE ERROR DEVICE
102434          SVRSEGM=:RTREF.RSEGM                      % RESTORE ORIGNAL REENTRANT SEGMENT
102437          GO RETSTUPR                               % FORCE PROGR THROUGH SEGADM
102440   RBUS
102445
102445   *"8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"102445

102445   %=======================================================================
102445   % 34.31     X T L X    S T U S P   S T L 1 2    S T L 1 3
102445   %
102445   %      MONITOR CALL HDLC
102445   %
102445   %=======================================================================
102445   %
102445   %
102445   %PUROSE: SIMULATE XTLX MONITOR CALLS FOR COMMUNICATION
102445   %        WITH HDLC-DRIVER.
102445   %
102445   %
102445   %
102445   %CALLING SEQUENCE:
102445   %
102445   %      LDA (PARAM
102445   %      MON  HDLC
102445   %      JMP ERROR
102445   %
102445   %      PARAM,PARA0
102445   %            PARA1
102445   %            PARA2     % ADDRESS OF USER BUFFER
102445   %            PARA3     % ADDRESS OF BYTECOUNT (USED IF RECEIVE)
102445   %            PARA4
102445   %
102445   %      PARA0 - FUNCTION. SEND OR RECEIVE
102445   %      PARA1 - PORT NO. (LOGICAL UNIT NO.)
102445   %      PARA2 - BUFFER
102445   %      PARA3 - BYTECOUNT
102445   %      PARA4 - P1 - 1  MAX BYTECOUNT OF MESSAGE
102445   %              P1 - 2  WAIT/CONTINUE IF NO MESSAGE IN QUEUE
102445   %
102445   %
102445   %DISP -9
102445   %       INTEGER HXDOK                   %LOCK,OPERATED BY X21(1-LOCKED,0-OPEN)
102445   %       INTEGER HXTMO                   %ADDRESS OF TIMEOUT-ROUTINE IN POF
102445   %PSID
102445   SUBR XTLX
102445   %
102445   %      TEMPORARY WORKING AREA
102445   %
102445   INTEGER TDAFI                          %ADDRESS OF CURRENT DATAFIELD
102446   INTEGER TDEFI                          %ADDRESS OF DEMAND FIELD
102447   %
102447   %ENTRY:X-DEMFIELD, B-PARAMETER POINTER
102447   %      NPT=RPIT, APT=DPIT, MONITOR LEVEL ENABLED, PON, ION
102447   %
102447   XTLX: X.OLDPAG=:X.SVOLDPAG   %%%%; CALL GAPIT; A:=D=:X.OLDPAG; CALL GETHD
102451         IF A/\74000=NDPIT THEN ADPIT ELSE X.OLDPAGE/\3600 FI
102461         A=:T:=X.OLDPAGE/\ACLEAR\/T=:X.OLDPAGE
102466         CALL GETHD
102467         SVOLDPAG=:OLDPAG
102471         IF D0=FRECV OR =FMXRECV THEN
102500            D5=:D3                                 %GET ADDRESS OF RETURN PARAMETER
102502         ELSE
102503            IF D0><FSEND THEN
102507               T:=EFUNC; GO ERET                   %ILLEGAL FUNCTION
102511         FI;FI
102511         X=:TDEFI
102512   %
102512   %     XREG POINTS TO DEMFIELD
102512   %     LEV 3 DISABLED
102512   %     FIND DATAFIELD AND SEE IF IT IS RESERVED BY CURRENT PROGRAM
102512   %
102512         A:=D1; CALL LOGPH;
102514         IF A = 0 THEN A:=D FI                     %TRY OUTPUT-FIELD
102516         IF A = 0 THEN T:=E2; GO ERET; FI
102521         A=:B=:TDAFI
102523         IF TYPRING /\ 177 >< 0 THEN T:=EDEVN; GO ERET FI     %*SIN-K
102530         IF HXCC><HXCOD THEN T:=EDEVN; GO ERET FI  % CORRECT DATAFIELD ?
102536         IF CURPROG><RTRES THEN                    % *80B*
102542           T:=E1;  GO ERET;                        % *80B* *81F*
102544         FI                                        % *80B*
102544   %
102544   %     COPY DATA TO DATAFIELD AND RELEASE DEMFIELD
102544   %
102544         T:="OFSET+ST"+B; ST=:D; D+X; "SP-ST+1"=:L; *MOVAA
102554         TDEFI=:B
102556         X:=CURPROG; CALL BRELEASE;
102560         A:=TDAFI=:B                               %DATAFIELDPOINTER
102562         CALL HDLC
102563   HBACK:IF T><0 THEN        % ERROR IF T><0
102565            B+OFSET
102566            T=:ZAREG; GO RET                        %*81F*
102570         FI
102570         A:=MESSID; B+OFSET; A=:ZAREG               % RETURN MESSAGE IDENTIFIER
102573         ZPREG+1=:ZPREG; GO RET
102577   ERET: X=:B; T=:ZAREG; GO RET                     % *81F*
102602   RBUS
102617
102617   SUBR Z0PHY
102617
102617   % Routines to transfer data between a user V.S. and physical memory.
102617   % The user's alternative page table must be set before copying.
102617   % Source,destination addresses and byte count is found in the datafield.
102617
102617   % On entry: B points to the datafield:
102617   INTEGER BREG
102620   Z0PHY: A:=L=:"XXHOM"
102622          X:=B+OFSET; X.OLDPAGE=:D        %%%%%CALL GAPIT;
102626          T:=XXSBK; X:=XXSBF; DDD3=:L; XXUBF; A:=:B; *IOF
102635          A=:BREG
102636          L=:A; CALL ZDALTON; A SHZ -1=:D; BREG; A:=:B; *ION
102645          A:=:D
102646          X:=:T                                     % XT=Destn address
102647          DO A=:L:=4000:=:L; WHILE A>0              % A=No of words left,L=4000
102654                *SKP IF DA GRE SL; COPY SA DL       % Skip if more than 4000?
102656                A-L; * MOVAP;                       % A=No of words left
102660          OD;
102661          IF M THEN                                 % Odd no of bytes
102663             D:=:X; A:=X.S0; A/\177400=:L
102667             D:=:X; X:=:T; *LDATX 0
102672             A/\377\/L; *STATX 0                    % Mask in lh byte and store
102675          FI;
102675          CALL ALTOF
102676          GO XXHOM
102677   RBUS
102704   SUBR Z0USR
102704   INTEGER BREG
102705   Z0USR: A:=L=:"XXHOM"
102707          X:=B+OFSET; X.OLDPAGE=:D  %%%%%CALL GAPIT;
102713          T:=XXSBK; X:=XXSBF; DDD3=:L; XXUBF; A:=:B; *IOF
102722          A=:BREG
102723          L=:A; CALL ZDALTON; A SHZ -1=:D; BREG; A:=:B; *ION
102732          A:=:T
102733          X:=:D                                     % T=Destn address
102734          DO X=:L:=4000:=:L; WHILE X>0              % X=No of words left,L=4000
102741                *SKP IF DX GRE SL; COPY SX DL       % Skip if more than 4000?
102743                X-L; * MOVPA;                       % X=No of words left
102745          OD;
102746          IF M THEN                                 % Odd no of bytes
102750             D=:X; T=:D; A=:T         % AD=:TX ; Save T in D
102753             *LDATX 0                 % Get remaining byte  from phys. mem.
102754             A/\177400=:L             % Mask and save in L
102756             D=:X;  A:=X.S0           % Get word from user area
102760             A/\377\/L; A=:X.S0       % Mask in lh byte and store
102763          FI;
102763          CALL ALTOF
102764          GO XXHOM
102765   RBUS
102772
102772
102772   %========================================================================
102772   % 39.12
102772   %      H D L C
102772   %
102772   %
102772   % ENTRY:  B-REG POINTS TO DATAFIELD
102772   %
102772   %         ION, LEV 3 DISABLED
102772   %
102772   SUBR HDLC
102772   %
102772   INTEGER MESSM:=0                       % INCREMENTED FOR EACH SEND
102773   HDLC:  A:=L=:"RSRET"                   % SAVE RETURN ADDRESS
102775          IF HINIF >< -1 THEN             % POOL INITIATED ?
103001             MASTB =: XXSBK               % BANKNO TO COPY ROUTINE
103003             MAX -1 SHZ -1 + BUFST =: D
103010             A:=BUFST
103011             X:=B; T:=MASTB; *AAX XBBNK
103014             CALL ZBINI; CALL PZCRA
103016             -1=:HINIF                    % MARK AS INITIATED
103020          FI
103020          IF DDD0 = FSEND THEN
103024   %
103024   % SEND
103024   %
103024             IF DDD3 < 0 THEN T:=EMSGS; GO RSRET FI    % ILLEGAL MESSAGE SIZE
103030             IF A > DDD4 THEN T:=EMAXS; GO RSRET FI    % MAX SIZE < USED SIZE
103035             X:="XBBNK"+B; "BHEAD+BHEAD"+DDD4; CALL ZBGET; CALL ZCRAS  %ALLOCATE BUFFER
103043             IF A = 0 THEN T:=ENBUF; GO RSRET FI
103046             A=:RSCUR=:X                               % USER PART OF MESSAGE
103050             IF MESSM + 1 < 0 THEN 1=:MESSM FI         % ONLY POSITIVE VALUES
103055             A=:MESSM=:MESSID; T:=MASTB; * BBID@3 STATX
103061             DDD4; * BMBYT@3 STATX                     % MAX BYTECOUNT IN MESSAGE
103063             DDD3; * BBYTC@3 STATX
103065             "OCHAIN"; *XCHAI@3 STATX                  % NOT XMSG DCB
103067             DDD2=:XXUBF; T:=DDD3=:D; X+BHEAD=:XXSBF
103075             CALL Z0PHY; * IOF                         % COPY USER DATA TO BUFFER
103077             X:=RSCUR; CALL ICHAIN; *ION               % SET MESSAGE IN QUEUE
103102             CALL STDEV                                % ACTIVATE DRIVER
103103             0=:T; GO RSRET;
103105          FI
103105   %
103105   % RECEIVE
103105   %
103105   REMSG: *IOF
103106          CALL DOCHAIN; GO CHEMTY                   % REMOVE MESSAGE FROM QUEUE
103110          *ION
103111          X=:RSCUR; T:=MASTB; * BBID@3 LDATX
103114          A=:MESSID                                 % MESSID OF CURRENT MESSAGE
103115          * BBYTC@3 LDATX
103116          A=:T
103117          IF DDD0-FMXRECV=0 AND DDD3<<T THEN
103125             T:=EMSGS=:DDD0; T:=A                   % ERROR, DCB GREATHER THAN SPECIFIED IN PARAMETER #4
103130          ELSE
103131             0=:DDD0
103132          FI
103132          % RETURN BYTECOUNT TO USER
103132          MLEV; *MST PIE                            % MUST ALLOW PAGEFAULT
103134          X:=B+OFSET
103136          X.OLDPAG=:D      %%%%CALL GAPIT;
103140          X:=DDD3; CALL DALTON; T=:X.S0
103143          CALL ALTOFF
103144          MLEV; *MCL PIE
103146          DDD2=:XXUBF; T=:DDD3
103151          X:=RSCUR; X+BHEAD=:XXSBF
103154          CALL Z0USR; B=:X; *AAX XBBNK              % COPY TO USER
103157          RSCUR; CALL ZBREL; CALL ZCRAS             % RELEASE BUFFER
103162          T:=DDD0; GO RSRET                         % GO BACK
103164   *)FILL
103201   %
103201   %
103201   CHEMTY:DDD4=:XWAITF
103203          IF A = 1 THEN
103206                X:=CURPR; CALL WDATA
103210                *ION
103211                B+OFSET; ZPREG-1=:ZPREG
103215                CALL RETSTUPR
103216          ELSE
103217                *ION
103220                T:=EEMTY; GO RSRET
103222          FI
103222          GO RSRET
103223   %
103223   PZCRA: IF A = 2 THEN T:=ENBUF; GO RSRET; FI
103230          CALL ZCRAS
103231   RBUS
103235
103235

103235   %=======================================================================
103235   % 39.16
103235   %      Z C R A S             INCONSISTENSY IN HDLC NONRESIDENT PART
103235   %
103235   %      T-REGISTER WILL CONTAIN OLD L-REGISTER WHEN STOP IN ERRFATAL
103235   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
103235   %
103235   SUBR ZCRAS
103235   INTEGER DHAAA                                  % ERRCODE
103236   INTEGER DHLLL                                  % WHERE I COME FROM
103237   ZCRAS: A=:DHAAA; A:=L=:DHLLL
103242          L=:T; A:=B+OFSET=:B; CALL 9ERR(#33)
103250          B-OFSET=:B; T:=HXERF; GO RSRET
103254   RBUS
103255
103255
103255   %=======================================================================
103255   % 34.32     H D T M 2      H D T M 3
103255   %       OUTPUT TIMEOUT ROUTINE
103255   %
103255   %       PURPOSE: ACTIVATE TIMEOUT ROUTINE ON LEVEL 12
103255   %
103255   SUBR   HDTM2
103255   HDTM2: T:=HXTMO; GO STL12                        % *80B*
103257   RBUS
103260   %
103260   %
103260   %       INPUT TIMEOUT ROUTINE
103260   %
103260   %       PURPOSE: ACTIVATE TIMEOUT ROUTINE ON LEVEL 13
103260   %
103260   SUBR HDTM3
103260   HDTM3: T:=HXTMO; GO STL13                        % *80B*
103262   RBUS
103263
103263
103263   %%%SUBR X21IN,X2STA,X21TO
103263   %%%RBUS
103263
103263
103263
103263   *"8XMSG+8CXHD+8C1X2+8C2X2+8C3X2+8C4X2
"103263

103263   %==============================================================================
103263   %
103263   % 40.9      GENERAL BUFFER ALLOCATION PACKAGE - ZB... for XMSG and HDLC
103263   %
103263   %==============================================================================
103263   SUBR ZBINI,ZBGET,ZBREL
103263   %
103263   %      THIS PACKAGE IS BASED ON THE CERN SMO MEMORY ALLOCATION PACKAGE. IT
103263   % ALLOCATES BUFFERS OF SIZE MULTIPLE OF FOUR WORDS. THE FIRST WORD OF EACH
103263   % BUFFER IS USED BY THE ALLOCATION PACKAGE AND CONTAINS:
103263   %      BIT 0 : SET IF THE BUFFER IS FREE (ZBCFR)
103263   %          1 : SET IF PRECEDING BUFFER IS FREE (ZBPFR)
103263   %       2-15 : BUFFER LENGTH IN MULTIPLE OF FOUR WORDS
103263   %
103263   %      IF THE BUFFER IS FREE (BIT 0 SET), THE LAST WORD OF THE BUFFER CONTAINS
103263   % THE ADDRESS OF ITS START (FOR CONCATENATION OF FREED BUFFERS.)
103263   %
103263   %      THE USER OF THIS PACKAGE MUST PROVIDE OF BUFFER AREA DESCRIPTOR OF 4
103263   % WORDS, WHICH MUST BE POINTED AT BY X ON ENTRY TO THESE ROUTINES:
103263   %
103263   DISP 0
103263          INTEGER ZBBNK         % BANK NO WHERE BUFFER AREA LIES (=0 IF N10)
103263          INTEGER ZBSTR         % ADDRESS OF FIRST WORD USED IN BANK FOR BUFFERS
103263          INTEGER ZBEND         % ADDRESS OF LAST WORD USED IN BANK FOR BUFFERS
103263          INTEGER ZBSAV         % SAVE LOCATION FOR USER B-REG
103263   PSID
103263   SYMBOL ZBCFR=0,ZBPFR=1       % BITS IN THE HEADER (DO NOT CHANGE - SEE CODE)
103263   %
103263   %      FUNCTIONS PROVIDED MUST BE CALLED WITH X POINTING TO THE DESCRIPTOR.
103263   % THE RETURN WILL BE BY SKIP RETURN UNLESS A FATAL ERROR IS DETECTED IN WHICH
103263   % CASE A WILL CONTAIN AN ERROR CODE:
103263   SYMBOL ZBX01=1               % BANK NO >< 0 AND CPSTA SAYS THIS IS A N10
103263   SYMBOL ZBX02=2               % NOT ENOUGH BUFFER SPACE TO INITIALISE
103263   SYMBOL ZBX03=3               % INCONSISTENCY IN BUFFERS FOUND BY ZBGET
103263   SYMBOL ZBX04=4               % ILLEGAL USER BUFFER ADDRESS TO ZBREL
103263   %
103263   %      FUNCTIONS ARE:            (B -> BUFFER AREA DESCRIPTOR)
103263   %
103263   % ZBINI:     INITIALISE BUFFER AREA
103263   %            T=BANK NO, A=ADDR OF FIRST WORD TO USE, D=ADDR OF LAST WORD
103263   %
103263   % ZBGET:     GET BUFFER SPACE
103263   %            A=NO OF BYTES
103263   %      SKIP: A:=USER BUFFER ADDRESS ( OR 0 IF NONE AVAILABLE )
103263   %            NB: This is the address of the first USABLE word in the buffer
103263   %
103263   % ZBREL:     RELEASE BUFFER SPACE
103263   %            A=USER BUFFER ADDRESS
103263   %
103263   INTEGER ZBMSK:=177774
103264   INTEGER POINTER ZBCPS:=CPSTA
103265
103265   ZBINI: X:=:B=:ZBSAV; T=:ZBBNK;                   % INITIALISE DESCRIPTOR
103270          IF T><0 AND X:=ZBCPS NBIT 5N100 THEN      % BANK><0 AND NOT N100
103275               ZBX01; GO ZBOUT                      % NOT ALLOWED
103277          FI
103277          X:=ZBMSK; A+3/\X=:ZBSTR; X/\D=:ZBEND      % ROUND START UP, END DOWN
103305          IF A+10>>=X THEN ZBX02; GO ZBOUT; FI      % NOT ENOUGH SPACE
103312          X-1; *STATX 0; SAA 2; STATX 10            % BACKPTR. LENG=0, PREV. FREE
103316          X:=ZBSTR; ZBEND-X BONE ZBCFR; *STATX 0    % SET LENGTH & FREE.
103323          GO ZBOKR                                  % SKIP RETURN
103324
103324   ZBGET: X:=:B=:ZBSAV                              % SAVE USER B-REG. B->DESCR.
103326          A SHZ -1; *BSKP ZRO SSM; RINC DA          % A=NUMBER OF USER WORDS
103331          A+4/\ZBMSK=:D; X:=ZBSTR                   % D=NUMBER OF WORDS NEEDED
103335          DO WHILE X><ZBEND                         % SCAN DOWN BUFFERS
103340                ZBX03; IF X>>T OR X<<ZBSTR GO ZBOUT % BUFFERS DESTROYED!
103346                T:=ZBBNK; *LDATX 0                  % GET HEADER WORD
103350                IF A BIT ZBCFR AND A>>=D THEN       % SPACE AVAILABLE?
103354                     A BZERO ZBCFR :=:D; * STATX 0  % SET NEW LENGTH IN HEADER
103357                     % NOW HAVE: X=BUFAD, A=NEWSIZE, D=OLDSIZE, T=BANK NO
103357                     D-A; A+X:=:X                   % D=REMNANT, A=USER BUF, X=NEW
103362                     IF D=0 THEN                    % FILLED WHOLE BUFFER?
103364                          D:=A; * LDATX 0           % GET HEADER OF NEXT BUFFER
103366                          A BZERO ZBPFR; * STATX 0  % CLEAR PREVIOUS FREE
103370                          A:=D                      % RECOVER USER ADDRESS
103371                     ELSE; * STATX 10               % SAVE USER ADDR IN NEW BUF(1)
103373                          A:=D BONE ZBCFR; *STATX 0 % BUILD NEW HEADER
103376                          X=:A+D-1; * STATX 0       % SET BACK POINTER
103402                          X:=A; * LDATX 10          % RECOVER USER ADDRESS
103404                     FI;
103404                     A+1; GO ZBOKR                  % RETURN WITH USER ADDR.
103406                FI; A/\ZBMSK+X=:X                   % TRY NEXT
103411          OD;
103412          A:=0; GO ZBOKR                            % NO SPACE LEFT
103414
103414   ZBREL: X:=:B=:ZBSAV; A-1=:X/\ZBMSK               % CONVERT USER->BUFFER ADDR
103421          IF A><X OR A<<ZBSTR OR A>>=ZBEND GO ZBIOW % CONSISTENCY CHECKING
103431          T:=ZBBNK; * LDATX 0                       % GET BUFFER HEADER
103433          IF A BIT ZBCFR THEN GO ZBIOW; FI          % SHOULD BE ALLOCATED
103436          A/\ZBMSK; X=:D+A; * LDATX 0               % GET HEADER OF NEXT BUFFER
103442          IF A BIT ZBCFR THEN A/\ZBMSK; X+A; FI     % IF FREE FIND ONE AFTER
103446          X:=:D; * LDATX 0                          % GO BACK TO ORIGINAL.
103450          IF A BIT ZBPFR                            % IF PREVIOUS FREE
103450          THEN X-1; * LDATX 0; COPY DX SA           % GET POINTER TO START OF PREV
103455          FI
103455          % WE NOW HAVE X=START OF NEW (CONCATENATED) BUFFER, D=START OF NEXT
103455          A:=D-X BONE ZBCFR; * STATX 0              % SET HEADER OF NEW
103461          X=:A:=D-1; * STATX 0; LDATX 10            % SET BACK PTR, GET NEXT HEAD
103466          A BONE ZBPFR; * STATX 10                  % SET PREVIOUS FREE
103470   ZBOKR: L+1; GO ZBOUT                             % SKIP RETURN SEQUENCE
103472   ZBIOW: ZBX04;                                    % ILLEGAL BUFFER ADDRESS
103473   ZBOUT: X:=ZBSAV:=:B; EXIT                        % RESTORE USER B AND X-REGS
103476   RBUS
103476   %==================== END OF BUFFER ALLOCATION ROUTINES (ZB...) ==============
103476
103476   *"8SIBA+8SIBX+8SIBM
"103476   %==============================================================================
103476   %      ( R )      M A P S I B   -   M S I B B
103476   %
103476   % SIBAS COMMUNICATION MONITOR CALL
103476   %
103476   SUBR MAPSIB,MSIBB,TISIBB
103476
103476   DOUBLE ARRAY CRTCADDR(0)
103476           *0;0;0;0;0;0;0;0;0;0;0;0
103512           *0;0;0;0;0;0;0;0;0;0;0;0
103526           *0;0;0;0;0;0;0;0;0;0;0;0
103542           *0;0;0;0;0;0;0;0;0;0;0;0
103556
103556   MAPSIB: X=:B;  MLEV; *MCL PIE                    % DISABLE MONITOR LEVEL
103561          IF BACKGROUND><0 THEN CALL ESCOFF FI
103564          IF SRTCSTAT><0 GO FAR M2ERR               % WAIT, SIBAS IS ACTIVE.
103567          IF ZTREG >> MXSIB GO FAR M1ERR            % SIBAS DEVNO NOT AVAILABLE
103573          X:=SIBBDEVS(ZTREG)                        % X=MON MSIBB WORKING FIELD
103575          IF X:=X.RTRES=0 GO FAR M1ERR              % SIBAS NOT STARTED
103600          IF X.STATUS NBIT 5WAIT GO FAR M2ERR       % SIBAS RUNNING (NOT WAITING FOR ME)
103603          X:=ZTREG+X; *1BANK
103606          AD:=CRTCADDR(X); *2BANK
103610          IF A=0 AND D=0 THEN                        % FIRST CALL TO THIS SIBAS
103613            X:=SIBBDEVS(ZTREG)
103615            IF X.SIBLAM >< 0 THEN                    % LAMU COMMUNICATION ?
103617               IF A- >= GNSYL  GO FAR M3ERR
103623               X=:L; A*SDTSZ+SYLDT=:X; T:=LAMBANK; *LDDTX
103631               A:=:D; A SHZ 12 =:L.SIBLSZ            % LAMU LENGTH IN WORD
103635               0=:A; AD SHZ 12; X:=ZTREG+X; *1BANK   % AD= PHYS ADDR FOR LAMU
103642               AD=:CRTCADDR(X); *2BANK
103644            ELSE
103645              IF ARTFPAGE=100 GO FAR M1ERR           % NO RTCOMMON IN THIS SYSTEM
103651              A:=CCLPAGE SHZ 12+1000; T:=ZTREG SH 11 % (LOG.START OF RT-COMMON)-(ZTREG*1000B)
103656              A-T SHZ -12+100+A+IRTCP=:X; X.S1       % A=PHYSICAL PAGE OF RT-COMMON
103665              A=:D; CALL DISPC; 0/\0                 % DISABLE PAGE FROM CACHE
103670              0=:A; AD SHZ 12
103672              IF T:=ZTREG NBIT "0" THEN T:=1000
103676              ELSE T:=0 FI
103700              D+T; A:=A+C; X:=ZTREG+X; *1BANK
103705              AD=:CRTCADDR(X); *2BANK                % AD=PHYSICAL ADDR OF SIBAS-MESSAGE-BUFFER
103707            FI
103707          FI; AD=:SIDRTC
103710          T:=SIAD2; X:=ZXREG; OLDPAGE=:D; A:=SIAD1
103715          CALL DALTON                               % USER-ALT-PIT=:CURRENT-ALT-PIT
103716          A=:L; X=:D; MLEV; *MST PIE                % ENABLE MLEV BEFORE FETCHING MESSAGE LENGTH
103722          X.S1                                      % MESSAGE LENGTH
103723          IF A=0 OR A>>X:=177 GO FAR XEE174         % 177*4=774B WORDS IS MAX. MESSAGE SIZE
103727          A SH 2:=:L; A=:X; *MOVAP                  % COPY MESSAGE TO RTCOMMON
103733          CALL ALTOFF                               % SET ALT.PIT=ADPIT
103734          GO OVER; *)FILL
103761   INTEGER CWORDCOUNT
103762   OVER:  *IOF
103763          X:=SIBBDEVS(ZTREG); 0=:X.TMR              % RESET SIBAS TIME OUT COUNTER
103766          IF X.SIB500=0 THEN                        % SIBAS IN ND-500?
103770             IF X:=X.RTRES=0 GO M1ERR               % NO IN ND-100; SIBAS TERMINATED?
103772             IF X.STATUS NBIT 5WAIT GO M1ERR        % NO, WAITING FOR REQUEST?
103775             A BZERO 5WAIT=:X.STATUS                % YES, REACTIVATE SIBAS
103777          ELSE
104000             IF X.RTRES=0 GO M1ERR                  % SIBAS IN ND-500; SIBAS TERMINATED?
104002             A=:D; CALL FSEMA; GO M1ERR             % NO, IS IT STILL IN ND-500?
104005             CALL 5PRACTIVATE; GO M1ERR             % YES, REACTIVATE SIBAS IN ND-500
104007          FI
104007          RTREF.STATUS BONE 5WAIT=:X.STATUS         % SET CALLER IN I/O-WAIT
104013          -1=:SRTCSTAT                              % MARK SIBAS IS ACTIVE
104015          "STUPR"; *IRW MLEVB DP
104017          MLEV; *MST PID; ION
104022          % RESTART HERE WHEN SIBAS RESTARTS ME.
104022          MLEV; *MCL PIE                            % PROTECT NON-REENTRANT SEQUENCE
104024          X:=SIAD2; T:=SIAD1; *LDATX 10             % FETCH SIZE OF ANSWER-MESS. FROM RTCOMMON
104027          IF A=0 OR A>>177 GO EE174                 % (177B*4)B WORDS IS STILL MAX.SIZE
104033          A SH 2=:CWORDCOUNT                        % NO OF WORDS IN ANSWER-MESS.
104035          T:=ZDREG; SIDRTC; X:=OLDPAGE:=:D; CALL DALTON % CALLER'S-ALT-PIT=:CURRENT-ALT-PIT
104042          D:=X; X:=CWORDCOUNT=:L
104045          A=:X:=MLEV; *MST PIE
104050          A:=X; *MOVPA                              % COPY ANSWER-MESSAGE FROM RT-COMMON TO CALLER
104052          CALL ALTOFF
104053   OKRET: 0=:ZAREG; MIN ZPREG; 0/\0                 % SKIP RETURN
104056          GO MXRET
104057   *)FILL
104067   XEE174: CALL ALTOFF
104070   EE174: 174; GO CERET
104072   M3ERR: A:=-3; GO CERET
104074   M2ERR: A:=-2; GO CERET
104076   M1ERR: A:=-1
104077   CERET: A=:ZAREG; *ION
104101          GO MXRET
104102
104102   %
104102   % MONITOR CALL MSIBB
104102   %
104102   MSIBB: X=:B;  MLEV; *MCL PIE                     % DISABLE MONITOR LEVEL
104105          A:=ZTREG SHZ -6
104107          IF A >< 0 AND A \/ 176000 >< SIBLAM THEN
104114            A=:SIBLAM;                              % UPDATE SIBAS LAMU NR
104115            A:=ZTREG /\ 77+A=:X                     % SIBAS INDEX
104121            A:=0=:D; *1BANK
104124            AD=:CRTCADDR(X); *2BANK                 % ZERO PHYS PAGE
104126          FI
104126          A:=ZTREG /\ 77=:X                         % SIBAS INDEX
104131          X:=SIBAPDEVS(X)=:D                        % D=MON MAPSIB'S WORKING FIELD
104133          0=:SIB500                                 % MARK THAT SIBAS RUNNING IN ND-100
104134          *IOF
104135          IF X:=X.RTRES><0 AND X.STATUS BIT 5WAIT THEN % ANY PROGRAM WAITING FOR THIS SIBAS?
104142             A BZERO 5WAIT=:X.STATUS                % YES, REACTIVATE IT
104144          FI
104144          IF ZAREG=0 THEN                           % SIBAS CONTINUE OR WAITING FOR NEW REQUEST?
104146             RTREF.STATUS BONE 5WAIT=:X.STATUS; A:=0 % WAITING FOR NEW REQUEST
104153             T:=TTMR=:TMR
104155          ELSE
104156             A:=1;0=:TMR                            % CONTINUE; MARK THAT SIBAS IS STILL RUNNING
104160          FI; A=:D.SRTCSTAT; MIN ZPREG; 0/\0        % SKIP RETURN
104164          GO RETSTUPR
104165   *)FILL
104175   INTEGER POINTER LREG
104176   TISIBB:
104176   %============================================================================
104176   % TIME OUT ROUTINE FOR MSIBB, ACTIVATED FROM TIMER PROGRAM.
104176   %============================================================================
104176           IF SIB500 = 0 THEN
104200             IF X:=RTRES >< 0 AND X.STATUS BIT 5WAIT THEN  % SIBAS RUNNING ?
104205                 A BZERO 5WAIT=:X.STATUS                   % YES, REACTIVATE IT
104207                 X:=X.RTDLGADDR; T:=0;* DPREG@3 LDATX
104212                 A-1; * DPREG@3 STATX                      % RESET SKIP RETURN
104214                 202; * DAREG@3 STATX                      % RETURN TIME OUT
104216             FI
104216           ELSE
104217             A:=L=:"LREG"
104221             IF RTRES =0 GO LREG; A=:D; CALL FSEMA; GO LREG
104227             CALL 5ERACTIVATE; A/\ A                       % REACTIVATE SIBAS IN ND-500
104231             GO LREG
104232           FI
104232           EXIT
104233   RBUS
104236
104236   *"8NSDB
"104236   %==============================================================================
104236   %      ( R )     S Y M B O L I C   D E B U G G E R
104236   %
104236   INTEGER CUIDX
104237   SUBR BRPNT,DEBUGGER
104237
104237   @MAC

)9SCLC
104237  MAXUS=0
104237  "8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB20+8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB10+8DB20+8DB30+8DB40+8DB50+8DB60
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+12; )KILL XYS
104237  "8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
104237  "8DB01+8DB02+8DB03+8DB04+8DB05+8DB06+8DB07+8DB08+8DB09
104237  XYS=MAXUS; )KILL MAXUS; MAXUS=XYS+1; )KILL XYS
104237  "8NSDB
104237  )9RCLC
)9SLPL
104237   INTEGER ARRAY DBUGSEG(0); * *+MAXUS/
104277   INTEGER ARRAY OLDSEGS(0); * *+MAXUS/
104337   INTEGER ARRAY BPHANDLER(0); * *+MAXUS/
104377   INTEGER ARRAY REGBL(0); * *+MAXUS/
104437   INTEGER ARRAY APTNO(0); * *+MAXUS/
104477   INTEGER ARRAY DBRSEGM (0);* *+MAXUS/
104537   *)KILL MAXUS
104537
104537   DISP 20                      % D0
104537   INTEGER OOLDPAGE            % TEMPORARY OLDPAGE
104537   INTEGER FILNR                % OPEN FILE NUMBER
104537   INTEGER BLCKNO               % BLOCK NUMBER WITHIN FILE
104537   INTEGER NWRD                 % NUMBER OF WORDS
104537   INTEGER ARRAY RWPAR(5)       % PARAMETER LISTE FOR MON RFILE
104537   INTEGER ARRAY BUFFR(7)       % BUFFER FOR MON RFILE; 7 FIRST WORDS ON PROG.FILE
104537   INTEGER WSPAR=BLCKNO
104537   INTEGER WLIST=NWRD
104537   PSID
104537
104537   % ROUTINE TO CHECK SAVED RT-DESCRIPTION BITMAP FOR A GIVEN ADDRESS
104537   % ENTRY: D = ADDRESS
104537   %        X = START OF SAVED BITMAP
104537   %        A = 0 IF NORMAL PIT; A=1 IF ALTERNATIVE PIT
104537
104537   INTEGER SKPINSTR;* *-1/BSKP ZRO 00 DT
104540   RBITM:   AD SHZ -12 ;D=:A          % PIT+PAGENO IN A
104542            D:=0;AD SHZ-4             % BITMAP WORD IN A;BIT NO. IN D
104544            X+A                       % BITMAP WORD ADDRESS IN X
104545            SKPINSTR;  D SHZ -11 + A  % BUILD BSKP INSTR WITH BITNO FROM D
104550            T:=X.S0 ;A:=0;            % GET BITMAP WORD,INDICATE BIT NOT SET
104552            *EXR SD; SAA 1            % A=1 IF BIT SET, A=0 IF NOT SET
104554            EXIT
104555
104555
104555   % ROUTINE TO CHECK IF SEGMENT NUMBER IS LEGAL AND THAT
104555   % SEGMENT IS AVAILABLE
104555   % ENTRY:      A= SEGMENT NUMBER
104555   % IF OK:      EXIT : X= SEGMENT TABLE FLAG
104555   % IF NOT OK:  GO ERR
104555
104555   SEGOK:  IF A>=2     AND <=SGMAX THEN
104563               A*5SEGSIZE+SEGSTART=: X;T:=SEGTBANK
104567               *FLAG@3 LDATX
104570               IF A BIT 5INHB GO ERR1
104572               *SGSTA@3 LDATX
104573               IF A= 0 GO ERR1
104574               EXIT
104575           FI
104575   ERR1:   A:=371; GO FAR ERR         % ILLEGAL SEGMENT
104577   *)FILL
104605   % ROUTINE TO CHECK FOR USER SYSTEM OR RT
104605   % CALLED FROM FUNCTIONS ACCESSING SEGMENTS
104605   % OK: RETURN TO CALLER
104605   % NOT SYS OR RT: ERROR RETURN FROM MONCALL WITH ERRCODE=25B
104605
104605   INTEGER POINTER PPASS:=PASSTYPE
104606   SYSRT: IF PPASS=0 THEN "ER4";GO FAR ERR FI
104612          EXIT
104613
104613   % SET AND RESET SEGMENT-WRITE-PROTECTION
104613   DWPROTECT: A:=0;GO FELLS
104615   DWPERMIT:  A:=1
104616   FELLS: A=:D
104617          CALL SYSRT;ZAREG; CALL SEGOK
104622          X=:T                                     % EXIT FROM SEGOK: X=SEG.TAB ADDR
104623          IF D=0 THEN
104625              ZAREG=:D;CALL SGAND                   % ENTRY TO SGAND/SGOR:
104630          ELSE                                      % T= SEGM TABLE ELEMENT ADDRESS
104631              ZAREG=:D;CALL SGOR                    %
104634          FI                                        %
104634          MIN ZPREG; 0/\0; GO FAR RETU
104637   *)FILL
104643
104643   INTEGER ARRAY DDRBIT (10)
104653   INTEGER SBREG,SVREE
104655   BRPNT: IF BACKGROUND=0 GO FAR RTBPT
104660          CALL GET0
104661          MLEV; *MST PIE
104663          A:=CURPROG;CALL LAMINHIBIT       % DISABLE LAMU
104665          RTREF.RSEGM=:SVREE
104670          T:=X.ACT1SEG;CALL M1MEXY         % FORCE SEGADM TO UPDATE BITMAP
104672          CALL FINDINDEX; GO FAR RETU      % FIND DEBUGGER-INDEX USED BY CALLER
104674          A:="DDRBIT":=:B=:SBREG
104677          X:=RTREF.RTDLG+5BITM;T:=0        % BITMAPS ARE IN PHYS. BANK 0
104703          *1BANK
104704          *LDDTX 0 ;STD 0,B                % SAVE BITMAP TEMPORARILY IN DDRBIT
104706          *LDDTX 20 ;STD 2,B
104710          *LDDTX 40 ;STD 4,B
104712          *LDDTX 60 ;STD 6,B
104714          A:=SBREG=:B
104716          *2BANK                           % UNSAVE B-REG
104717          MLEV;*MCL PIE
104721          X:=RTREF; CALL CLRBM
104723          *1BANK
104724          X:=CUIDX
104725          T:="SGNUM"+X                     % T=DEBUGGER'S DATA SEGMENT
104727          DBUGSEG(X); *2BANK               % A=DEBUGGER REENTRANT PROGRAM SEGMENT
104731          A=:RTREF.RSEGM
104733          MLEV;*MST PIE
104735          CALL M1MEXY;
104736          AUPIN=:D;CALL DALTON             % USERS NORMAL PIT AS APT (DEBUGGERS DATA SEGMENT)
104741          *1BANK
104742          T=:OLDSEG(CUIDX)
104744          A:=SVREE=:DBRSEGM (X)            % SAVE RSEGM FOR LATER START OF PROGRAM
104746          X:=REGBL(X)
104747          *2BANK; STA 14 ,X                % WRITE RSEGM TO DEBUGGER'S REGISTER BLOCK
104751          X=:T
104752          CALL SINALTPIT                   % RESET DPIT AS APT
104753          ZPREG-1=:ZPREG
104756          OLDPAGE=:OOLDPAGE/\600 SHZ -7+1=:OLDPAGE
104764          A:=B+"ZPREG"=:D; A:=200; X:=11; K:=1; CALL MOVUS
104773          OOLDPAGE/\174177+200=:OLDPAGE; *1BANK
105000          BPHANDLER(CUIDX); *2BANK
105003          A=:ZPREG
105004          IF A:=SVREE>< 0 THEN             % COPY BITMAP TO DEBUGGER'S DATA SEGMENT
105006                MLEV; *MCL PIE;
105010                *1BANK
105011                A:=REGBLO (CUIDX)+20:=:B =:SBREG
105016                X:="DDRBIT"
105017                *2BANK
105020                A:=AUPIN=:D;CALL DALTON
105023                *1BANK; LDD ,X 0; 2BANK; STD ,B 0
105027                *1BANK; LDD ,X 2; 2BANK; STD ,B 2
105033                *1BANK; LDD ,X 4; 2BANK; STD ,B 4
105037                *1BANK; LDD ,X 6; 2BANK; STD ,B 6
105043                CALL SINALTPIT
105044                A:=SBREG=:B
105046          FI
105046          GO FAR RETU
105047   *)FILL
105100
105100   INTEGER RTBRB=?             % BUFFER AREA FOR REGISTER BLOCK + +
105100   RTBPT: CALL GET0
105101          MLEV;*MCL PIE
105103          X:="RTBRB"       % COPY FROM WORKING FIELD TO BUFFER IN RPIT
105104          *LDF 7,B  ;1BANK; STF 0,X;2BANK
105110          *LDF 12,B ;1BANK; STF 3,X;2BANK
105114          *LDF 15,B ;1BANK; STT 6,X ;STA  7,X;2BANK
105121          OLDPAG /\ 600 SH -7+1;*1BANK; STA 10,X ;2BANK
105130          CURPROG;*1BANK;STA 11,X;2BANK
105134          AD:=CURPROG.DACTSEG;T:=X.RSEGM       % GET SEGMENTS AND RSEGM, X IS DESTROYED
105137          X:="RTBRB"                           % RESTORE X
105140          *1BANK; STA 12 ,X; COPY SD DA;STA 13,X; STT 14,X; 2BANK
105146          CURPROG.STATUS BONE 5WAIT=: X.STATUS % BREAKPOINTED PROGRAM IN I/O-WAIT
105152          CALL 9ERRA (-1)    % GIVE MESSAGE ON ERROR DEVICE
105154
105154   RETS:  X:=CURPROG;CALL BRELEASE
105156          GO FAR RETSTUPR
105157   G9ERR: A:=204 ;CALL 9ERRA(#00)
105162          X:=CURPROG
105163          CALL BRELEASE ;GO FAR RETXIT  % ABORT PROGRAM
105165
105165   *)FILL
105176   DEBUGGER: CALL GET0
105177          MLEV; *MST PIE
105201          IF ZTREG>>17 GO FAR RETU
105205   @ICR;
105205   A GOSW FAR GETDSEG,        %  0      GET DATA SEGMENT
105207          FAR PLAC1,          %  1      PLACE
105210          FAR PSTART,         %  2      START PROGRAM OR REENTRANT SUBSYSTEM
105211          FAR READLOC,        %  3      READ LOCATION
105212          FAR WRITLOC,        %  4      WRITE LOCATION
105213          FAR RELDSEG,        %  5      RELEASE DATA SEGMENT
105214          FAR RTGDBSEG,       %  6      GET DATA SEGMENT
105215          FAR CHLGSEG,        %  7      CHECK LEGAL SEGMENT
105216          FAR RRGBLOCK,       %  8      READ REGISTER BLOCK
105217          FAR WRGBLOCK,       %  9      WRITE REGISTER BLOCK
105220          FAR STRRT,          %  10     START RT-PROGRAM
105221          FAR RETU,           %  11     NOT USED
105222          FAR RETU,           %  12     NOT USED
105223          FAR DWPERMIT,       %  13     SEGMENT WRITE-PERMIT
105224          FAR DWPROTECT,      %  14     SEGMENT WRITE-PROTECT
105225          FAR PLREENTRANT     %  15     PLACE REENTRANT SUBSYSTEM
105225   ;@CR;
105226   *)FILL
105246   INTEGER SAVA ,REIND:=1,SEGA
105251   READLOC:
105251   WRITLOC:
105251           CALL FINDINDEX; GO ERR;1=: REIND
105255           T:=RTREF.ACT1SEGM;0=:RTREF.RSEGM;CALL M1MEXY
105262           IF ZAREG SHZ-1 = 0 GO ONBG        % NO SEGMENT NO.,USE BACKG. SEGMENT
105265           CALL FAR SEGOK; X=: SEGA          % X= SEGM TABLE ELEMENT
105267           T:=SEGTBANK; *FLAG@3 LDATX
105271           IF A NBIT 5SREEP GO ONSEG         % NOT REENTRANT SUBSYSTEM
105273           T:=AUPIN=:D
105275           T:=ZDREG
105276           A:=ZAREG /\ 1
105300           CALL DALTON;*1BANK            % GET UPITN AS APT
105302           T=:D
105303           X:=REGBLO (CUIDX)+20
105306           *2BANK
105307           CALL  FAR RBITM               % D=ADDRESS; X= BITMAP; A=0/1 (NPT/APT)
105310           A=: REIND
105311           CALL SINALTPIT                % RESTORE DPIT AS APT
105312           IF A=0 THEN         %SEGMENT
105313   ONSEG:     CALL FAR SYSRT
105314              T:=ZAREG SHR -1
105316           ELSE                %BACKGROUND SEGMENT
105317   ONBG:      T:=RTREF.SEGM2+1
105322              IF ZAREG/\ 1><0 THEN T BONE 17 FI
105326           FI;
105326           T=:SAVA;A:=CURPROG; CALL LAMENABLE;T:=SAVA
105332           X:=ZDREG
105333           IF ZTREG-3=0 THEN
105336                 CALL GET1L; GO ERR0;A=: ZAREG
105341           ELSE
105342               ZXREG; CALL PUT1L; GO ERR0
105345               IF REIND=0  THEN
105347                   A:=ZAREG SHZ -1=:WSPAR
105352                   A:="WSPAR"+B=:WLIST
105355                   A:="WLIST"+B
105357                   *MON 2WSEG
105360               FI
105360           FI
105360   OK:     MIN ZPREG; 0 /\ 0; GO OK1
105363   ERR0:   A:= 372      % ILLEGAL ADDRESS
105364   ERR:    A=: ZAREG
105365   OK1:    A:=CURPROG;CALL LAMINHIBIT     % DISABLE LAMU
105367           *1BANK
105370           X:=CUIDX; T:="SGNUM"+X; A:=DBUGSEG(X); *2BANK
105375           A=:RTREF.RSEGM;CALL M1MEXY
105400           GO FAR RETU
105401   *)FILL
105431   CHLGSEG:ZAREG;CALL FAR SEGOK
105433           MIN ZPREG; 0/\0
105435           GO FAR RETU
105436   *)FILL
105440
105440   INTEGER SSAVB
105441   PSTART: CALL FINDINDEX; GO FAR RETU
105443          T:=ZXREG; A:=ZAREG; *1BANK
105446          T=:BPHANDLER(CUIDX); A=:REGBL(X); *2BANK
105452          X:=10; T:="ZPREG"+B; ZAREG=:D; A:=OLDPAGE      % COPY REGISTER BLOCK FROM
105460          K:="0"; CALL MOVUS                             % DEBUGGERS DATA SEGMENT
105462                                                       % TO MONCALL DATAFIELD
105462          *1BANK
105463          T:=DBRSEGM (CUIDX)                           % SAVED RSEGM, EITHER FROM PLREE
105465          X:=REGBLO(X)                                 % OR FROM LAST BREAKPOINT
105466          *2BANK
105467          AUPIN=:D;CALL DALTON
105472          *LDA ,X 10 ;COPY SA DD                       % WREG, (ALTPIT IN DEBUGGER)
105474          CALL SINALTPIT
105475          MLEV; *MCL PIE
105477          T=: RTREF.RSEGM                              % INSTALL SAVED RSEGM HERE
105501          IF D=3 THEN
105504             *1BANK
105505             T:=APTNO(CUIDX); *2BANK
105510          ELSE
105511             T:=200
105512          FI
105512          T=:D
105513          OLDPAGE/\174177\/D=:OLDPAGE
105517          IF RTREF.RSEGM><0 THEN
105522                *1BANK
105523                A:=REGBLO (CUIDX)+20:=:B =:SSAVB
105530                *2BANK
105531                X:=RTREF.RTDLG+5BITM ;T:=0
105535                AUPIN=:D;CALL DALTON
105540                   *LDD ,B 0; STDTX  0
105542                   *LDD ,B 2; STDTX  20
105544                   *LDD ,B 4; STDTX  40
105546                   *LDD ,B 6; STDTX  60
105550                CALL SINALTPIT
105551                A:=SSAVB=:B
105553          FI
105553          MLEV;*MST PIE
105555          A:=CURPROG;CALL LAMENABLE
105557          *1BANK
105560          T:=OLDSEG(CUIDX); *2BANK
105563          CALL M1MEXY
105564          GO FAR RETU
105565   *)FILL
105607
105607
105607   RTGDBSEG: CALL FAR SYSRT
105610             IF DBGPROGS(0)><0 AND A><CURPROG GO E400
105616             CURPROG=:DBGPROGS(0)
105621             X:=0
105622             GO FAR SGFOUND
105623
105623   E400:     A:= 400
105624   ERR2:     A=: ZAREG; GO FAR RETU
105626   *)FILL
105634
105634   INTEGER BBREG
105635   STRRT: CALL FAR SYSRT
105636          IF ZAREG >>= RTEND  GO ILLRT
105642          IF A - RTSTART <0  GO ILLRT
105644          A=: D:=0; T:= 5RTSIZE; *RDIV ST
105650          IF D>< 0 GO ILLRT
105652   %%% PREPARE COPY OF REGBLOCK FROM DEBUGGER TO RT-DESCRIPTION
105652          A:=B=:BBREG               % SAVE B
105654          X:=ZAREG.RTDLG=:B;T:=0    % PHYS ADDR OF RTDESC'S REGBLOCK
105660          AUPIN=:D; CALL DALTON     % UPITN AS APT
105663          MLEV;*MCL PIE
105665          * 1BANK
105666          X:=REGBL (0)              % GET ADDR OF DEBUGGERS REGBLOCK
105670          *2BANK
105671          B:=:X                     % B = DEBUGGERS REGBLOCK
105672                                    % X = RT-DESCR'S REGBLOCK
105672         * LDD 0,B ; STDTX 0
105674         * LDD 2,B ; STDTX 20
105676         * LDD 4,B ; STDTX 40
105700         * LDD 6,B ; STDTX 60;
105702
105702          A:=BBREG=:B               % UNSAVE B
105704          CALL SINALTPIT            % RESET DPIT AS APT
105705
105705          IF A:=ZAREG.WLINK=0 THEN
105710              CALL RTENTRY          %  RTDESC IN X
105711          ELSE
105712              X.STATUS BZERO 5WAIT =: X.STATUS
105715          FI
105715          MIN ZPREG; 0/\ 0;GO FAR RETS
105720
105720   ILLRT: A:=274; GO FAR ERR2   % ILLEGAL RT-PROGRAM
105722
105722   INTEGER BRG =?              % SAVE LOC.
105722   INTEGER RTBRB ;* 0;0;0;0;0;0;0;0      % BUFFER AREA FOR REGISTER BLOCK + +
105733                  * 0;0;0;0;0;0;0;0
105743   *)FILL
105756   WRGBL: ZXREG
105757          *1BANK
105760          A=:REGBL (0)
105762          *2BANK
105763          MIN ZPREG;0/\0; GO FAR RETU
105766
105766   % COPY FROM REG.BLOCK BUFFER (RTBRB) TO DEBUGGER'S REG. BLOCK
105766   RRGBL: ZXREG
105767          *1BANK
105770          A=:REGBL (0)
105772          *2BANK
105773          AUPIN=:D; CALL DALTON
105776          A:=B=:BRG;X:="RTBRB"=:B
106002          *1BANK
106003          X:=REGBL(0)
106005          *LDF 0,B ;RDCR DT; 2BANK; STF 0,X   ; 1BANK;
106012          *LDF 3,B ;         2BANK; STF 3,X   ; 1BANK;
106016          *LDF 6,B ;         2BANK; STF 6,X   ; 1BANK;
106022          *LDF 11,B ;        2BANK; STF 11,X  ; 1BANK;
106026          *LDA 14,B;         2BANK; STA 14,X
106031          A:=BRG=:B
106033          CALL SINALTPIT
106034          MIN ZPREG;0/\0;GO FAR RETU
106037   *)FILL
106045
106045   INTEGER CLIST:=SEGN,SEGN
106047   INTEGER SVSTA,SAVT,SVCST,BRG
106053   INTEGER POINTER PCSTRI:=CSTRIN,PCPNT:=CPNT
106055
106055   PLREE: CALL FINDINDEX;GO FAR RETU
106057          A:=ZXREG
106060          *1BANK
106061          A=: REGBLO (CUIDX)
106063          *2BANK
106064          T:=ZAREG=:SAVT
106066          FOR X := 0 TO 20 DO            % COPY NAMESTRING
106072          AUPIN=:D; CALL DALTON          % FROM DEBUGGER (UPITN)
106075             T:= SAVT;    *LBYT          % TO
106077          CALL SINALTPIT                 %
106100             T:=PCSTRI; *SBYT          % CSTRING ON SYSTEM SEGMENT(DPIT)
106102             WHILE A >< ##'              %
106105          OD
106107          T:="5OPSEG" ;0=: RTREF.RSEGM; CALL M1MEXY
106113          A:="BFIELD";A:=:B;A=: BRG
106116          0=: PCPNT
106117          X:= "REECOMT";CALL CABLOOK;
106121          0=:PCPNT               % RESTORE COMMAND PROCESSOR POINTER
106122          IF A= 0 THEN           % FOUND IN REECOMT
106123                                 % T=SEGM NO; D= START ADDRESS
106123             IF A:=T><-1 THEN     % NOT 500 STANDARD DOMAIN
106127                A=:SEGN;A:=D=:SVSTA
106132                *1BANK
106133                T:=OLDSEGS (CUIDX);*2BANK
106136                0=:RTREF.RSEGM;CALL M1MEXY   % ACT1SEG= USER SEGM; RSEGM=0
106141                ARPIT=:D;CALL DALTON         % APT= RPIT
106144                "CLIST";*MON 2REEN           % MON REENT TO LINK OUT PAGES
106146                                             % FROM BACKGROUND SEGMENT
106146                CALL SINALTPIT
106147                *1BANK
106150                A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106155                A=:RTREF.RSEGM; CALL M1MEXY
106160
106160                AUPIN=: D; CALL DALTON
106163                *1BANK
106164                A:=SEGN;T:=SVSTA                    % WRITE SEGMENT NUMBER AND
106166                A=:DBRSEGM(CUIDX)                   % SAVE RSEGM FOR LATER STARTS
106170                X:=REGBLO (X)
106171                *2BANK
106172                *STT ,X 0; STA ,X 14                % START ADDRESS AND RSEGM TO DEBUGGER:
106174                CALL SINALTPIT
106175                A:=BRG =:B
106177                MIN ZPREG; 0/\0; GO FAR RETU
106202             FI
106202          FI
106202   %%%    ERRORS FROM ABLOOK:
106202          A=: D
106203          *1BANK
106204          A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106211          A=:RTREF.RSEGM; CALL M1MEXY
106214          A:=D
106215          IF A= -2 THEN % AMBIGUOUS
106220                A:="ER212"
106221          ELSE          % NO SUCH REENTRANT SUBSYSTEM
106222                A:=174  % ILLEGAL PARAMETER
106223          FI
106223          T:=BRG =:B
106225          GO FAR ERR
106226
106226   *)FILL
106252
106252   GETDSEG:
106252          X:=1   % START ON 1; INDEX 0 RESERVED RT-DEBUGGER
106253          DO WHILE X><MXSDBUGGER
106256             IF DBGPROGS(X)=RTREF GO SGFOUND
106262             X+1
106263          OD
106264          X:=1  % START ON 1; INDEX 0 RESERVED RT-DEBUGGER
106265          DO WHILE X><MXSDBUGGER
106270             IF DBGPROGS(X)=0 THEN RTREF=:DBGPROGS(X); GO SGFOUND FI
106275             X+1
106276          OD
106277          GO FAR RETU
106300   SGFOUND:
106300          *1BANK
106301          X=:CUIDX;*2BANK
106303          T:="SGNUM"+X; CALL M1MEXY; *1BANK
106307          T=:OLDSEG(X);0=:DBRSEGM(X)
106311          *2BANK
106312          A:=T*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *SEGLE@3 LDATX
106320          IF A=200 THEN T:=400 ELSE T:=200 FI
106326          A:=RTREF.RSEGM; *1BANK
106331          A=:DBUGSEG(CUIDX); T=:APTNO(X); *2BANK
106335          MIN ZPREG; 0/\0; GO FAR RETU
106340   *)FILL
106360
106360   RELDSEG: CALL FINDINDEX; GO FAR RETU
106362          0=:DBGPROGS(X)
106363          A:=CURPROG;CALL LAMENABLE
106365          MIN ZPREG; 0/\0; GO FAR RETU
106370
106370   PLAC1: CALL FINDINDEX; GO FAR RETU
106372          ZAREG=:FILNR; 0=:BLCKNO; 7=:NWRD
106377          "BUFFR"+B=:RWPAR(2)
106403          "RWPAR"+B; *MON 117
106406          IF A><0 THEN A=:ZAREG; GO FAR RETU FI
106411          GO PLAC2; *)FILL
106421
106421   PLAC2: 0=:RTREF.RSEGM; CALL GETDATAFIELD
106424          5BCOM; T:="BSTATE"; CALL XSTDFADDR
106427          T:=FILNR; X:="BUFFR"+B; CALL 2BDBRECOVER; GO ERET
106434          A:=0; MIN ZPREG; 0/\0
106437   ERET:  A=:ZAREG; CALL GETDATAFIELD
106441          5BUSER; T:="BSTATE"; CALL XSTDFADDR
106444          *1BANK
106445          A:=DBUGSEG(CUIDX); T:="SGNUM"+X; *2BANK
106452          A=:RTREF.RSEGM; CALL M1MEXY
106455          GO FAR RETU
106456   *)FILL
106471
106471
106471   FINDINDEX: X:=0   % START ON 0; FINDINDEX ALSO USED BY RT-DEBUGGER
106472          DO WHILE X><MXSDBUGGER
106475             IF DBGPROGS(X)=RTREF THEN
106501                 *1BANK
106502                 X=:CUIDX
106503                 *2BANK
106504                 EXITA
106505             FI
106505             X+1
106506          OD; EXIT
106510   RETU:  GO MXRET
106511
106511   RBUS
106516   *"
"106516
106516   *"8MOLI
"106516   %==============================================================================
106516   %
106516   % MON LOGIN
106516   %            <LOG.DEV>       : LOGICAL DEVICE NUMBER OF THE TERMINAL
106516   %            <USER NAME>
106516   %            <PASSWORD>
106516   %            <PROJECT PASSWORD>
106516   %            <SUBSYSTEM NAME>
106516   %            <PASET PARAMETERS>
106516   %            <RETURNED STATUS>
106516   %
106516
106516   SUBR MLOGIN
106516
106516   DISP 21
106516          INTEGER AS1,AS2,AS3,AS4,AS5,AS6 % PARAMETER ADDRESSES.
106516          INTEGER POINTER LREG            % RETURN ADDRESS IN CMOVSTR.
106516          INTEGER SUBCNT=AS1              % NUMBER OF 16 BYTE PARTS OF SUBSYSTEM
106516          INTEGER SUBPNT=AS2              % POINTER TO SUBSYSTEM PART.
106516   PSID
106516
106516   CMOVSTR:
106516          T:=L=:"LREG"            % SAVE RETURN ADDRESS.
106520          T:=MLICPNT              % FIRST FREE BYTE IN BUFFER.
106521          *BLDA 00 DT             % K:=(FIRST BYTE IS RIGHT BYTE)
106522          T SHZ -1                % WORD DISPLACEMENT.
106523          X:=T+B                  % X POINTS TO FIRST BUFFER WORD.
106525          T:=21=:D                % MAX 21 BYTES IN EACH PARAMETER.
106527          *BSTA 170 DT            % DESTINATION STARTS ON RIGHT BYTE.
106530          D BONE 16               % SOURCE IS IN ALTERNATIVE PIT.
106531          CALL MLMOV              % MOVE BYTES (IN MICRO COMMON).
106532          "LREG"=:L               % RESTORE RETURN ADDRESS.
106534          MLICPNT+21=:MLIMXADDR   % MAX VALUE OF MLICPNT.
106537          DO WHILE X:=MLICPNT >< MLIMXADDR
106543              T:=B                % B IS BASE ADDRESS FOR BUFFER.
106544              *LBYT               % READ A CHARACTER FROM THE BUFFER.
106545              A/\177              % REMOVE PARITY.
106546              IF A=##' OR =15 GO OUT  % STOP AT ' OR CR.
106554              MIN MLICPNT         % INCREASE BUFFER POINTER.
106555          OD
106556          EXIT                    % ERROR EXIT IF MORE THAN 20(OCT) BYTES IN PARAMETER.
106557
106557   OUT:   A:=15; T:=B; *SBYT      % CR IS PARAMETER DELIMITOR.
106562          MIN MLICPNT             % INCREASE BUFFER POINTER.
106563          EXITA                   % OK: SKIP RETURN.
106564
106564   *)FILL
106566
106566   MLOGIN:CALL GET1
106567          MLEV; *MST PIE
106571          ZAREG+1=:D                              % ADDRESS OF SECOND PARAMETER.
106574          T:="AS1"+B                              % DESTINATION IN DF.
106576          A:=OLDPAG                               % USERS PITS.
106577          X:=6; K:="0"                            % 6 WORDS FROM USER TO DPIT.
106601          CALL MOVUS
106602          AS6=:MLIADDR                            % ADDRESS OF STATUS PARAMETER.
106604          D0; CALL LOGPH; IF A=0 OR D=0 GO EDEV   % FIND TERMINAL DF.
106611          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD GO EDEV % CHECK FOR TERMINAL OR TAD.
106617          IF X.RTRES><0 GO EOCCU                  % CHECK THAT TERM. IS FREE.
106621          X=:MLITERM                              % SAVE DF ADDRESS.
106622          IF UNAFLAG><0 AND RTRES><"STSIN" GO ESUNA   % SYSTEM UNAVAILABLE.
106630          MLISTRNG SH 1=:MLICPNT                  % BYTE DISPLACEMENT OF BUFFER.
106633          AS1; CALL CMOVSTR; GO ESTRNG            % USER NAME.
106636          AS2; CALL CMOVSTR; GO ESTRNG            % PASSWORD.
106641          AS3; CALL CMOVSTR; GO ESTRNG            % PROJECT PASSWORD.
106644          -4=:SUBCNT                              % COPY SUBSYSTEM IN UPTO 4 PARTS.
106646          AS4=:SUBPNT                             % START OF SUBSYSTEM.
106650          FOR SUBCNT DO
106650              CALL CMOVSTR                        % MOVE UPTO 20(OCT) BYTES, SKIP RETURN IF END.
106651              GO NEXT10                           % NORMAL RETURN: END NOT FOUND, RESET END FLAG.
106652              GO SUBEND                           % IF END FLAG SET, FINISH LOOP.
106653   NEXT10:    SUBPNT+10=:SUBPNT                   % NEXT PART OF SUBSYSTEM STRING.
106656          OD
106660          GO ESTRNG                               % IF STRING LONGER THAN 100(OCT) CHARS, THEN ERROR.
106661   SUBEND:                                        % END OF SUBSYSTEM STRING FOUND.
106661          AS5=:D; T:=MLIPASET+B                   % USER PARAMTERS.
106665          A:=OLDPAG; X:=5; K:="0"                 % MOVE 5 WORDS TO DPIT.
106670          CALL MOVUS
106671          MLICPNT=:MLIMXADDR                      % END OF BUFFER.
106673          MLISTRNG SH 1=:MLICPNT                  % START OF BUFFER.
106676          *IOF
106677          IF MLITERM.RTRES><0 GO XEOCCU           % RECHECK THAT TERM. IS FREE.
106702          T:="FLAGB"; CALL XGTDFADDR              % GET FLAGB FOR TERMINAL.
106704          A BONE 5MLGIN                           % SET MLOGIN FLAG.
106705          T:="FLAGB"; CALL XSTDFADDR              % SET FLAGB.
106707   *"8MOLI -8BACS
"106707          A:=X; *IRW MLEVB DX                             % ALLOCATE A PROGRAM FOR THIS TERM.
106711          "CMBABPROC"; *IRW MLEVB DP
106713          MLEV; *MST PID; ION
106716          GO ENOFREE; *IOF                                % IF SKIP RETURN: OK.
106720   *"8MOLI
"106720          CALL RTENTRY                        % START BACKGROUND PROGRAM.
106721          RTREF.STATUS BONE 5WAIT=:X.STATUS   % WAIT FOR RESULT OF MLOGIN.
106725          TTMR=:TMR; "RWAIT"; *IRW MLEVB DP   % WAIT MAX 100(OCT) SECONDS.
106731          MLEV; *MST PID
106733   RETU:  *ION
106734          X:=MLIADDR                          % ADDRESS OF STATUS PARAMETER.
106735          A:=MLIMSTATUS                       % STATUS IN DF.
106736          CALL USALTPIT                       % USERS ALT. PIT.
106737          A=:X.S0                             % RETURN THE STATUS.
106740          CALL SINALTPIT                      % DPIT.
106741          *IOF
106742          X:=RTREF; CALL BRELEASE             % RELEASE MLIDFIELD.
106744          GO RET                              % END OF MONITOR CALL.
106745   *)FILL
106766
106766   ESUNA: A:=-1; GO EFEL              % ALL ERRORS RETURN STATUS -1
106770   XEOCC:                             % TO HIDE THE REASEON FOR FAILURE.
106770   EOCCU: A:=-1; GO EFEL
106772   EDEV:  A:=-1; GO EFEL
106774   XPEND: A:=-1; GO EFEL
106776   ESTRNG:A:=-1; GO EFEL
107000   ENOFREE: A:=-1
107001   EFEL:  A=:MLIMSTATUS; GO RETU
107003
107003   RBUS
107003
107003   %======================================================================
107003   %      M L G T M O U T
107003   %      TIMEOUT SUBROUTINE FOR MON LOGIN
107003   %      CALLED BY TIMER IF NO RESPONSE FROM STARTED BACKGROUND PROGRAM.
107003   %
107003   SUBR MLGTMOUT
107003
107003   MLGTMOUT: -1=:MLIMSTATUS                       % TIMEOUT: LOGIN FAILED.
107005             0=:TMR                               % STOP THE TIMER.
107006             RTRES.STATUS BZERO 5WAIT=:X.STATUS   % RESTART THE WAITING PROGRAM.
107012             EXIT                                 % RETURN TO TIMER PROGRAM.
107013   RBUS
107013   *"
"107013
107013
107013   %==============================================================================
107013   %            T R E P P     (TREPP  MON 332)
107013   %
107013   %      MONITORCALL TO DISABLE/ENABLE AND READ TERMINAL REPPORT
107013   %
107013   %      ENTRY: T = LOGICAL DEVICE NUMBER ( 1: OWN TERMINAL BACKGROUND)
107013   %             A = FUNCTION  = 0: DISABLE TERMINAL-REPPORT
107013   %                           = 1: ENABLE  TERMINAL-REPPORT
107013   %                           = 2: READ    TERMINAL-STATUS
107013   %      ERROR RETURN: A = ERROR NUMBER
107013   %      SKIP  RETURN: FUNCTION 0: OK
107013   %                    FUNCTION 1: OK
107013   %                    FUNCTION 2: OK  A = STATUS
107013   %                                        BIT  0: 1 - TERMINAL LINE DEAD
107013   %                                        BIT  1: 1 - LOGOUT WAITING FOR MON 0
107013   %                                        BIT  2: 1 - OVERRUN IN INPUT BUFFER
107013   %                                        BIT  3: 1 - PARITY ERROR IN INPUT
107013   %                                        BIT  4: 1 - FRAMING ERROR IN INPUT
107013   %      BITS USED IN FLAGB:
107013   %           BIT  0: 5TLREP
107013   %           BIT   : 5LOGOUT
107013   %           BIT 17: 5LSTA
107013   %      BITS USED IN TINFO:
107013   %           BIT 17: 5BFUL   - READ AND CLEAR
107013   %           BIT 16: 5PAER   - -----"-------
107013   %           BIT 15: 5FRER   - -----"-------
107013
107013   SUBR TREPP
107013   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG
107015   INTEGER WNDADDR:=WNDBF*2+174000
107016   TREPP: CALL GET0; MLEV; *MST PIE
107021          IF BACKGROUND><0 AND ZTREG=1 THEN          % BACKGROUND OWN TERMINAL
107027              IF PBCHFLAG=1 GO DUMRE                 % FAKE ALWAYS OK IF BATCH
107033              A:=PTTNO                               % LOG DEV NO OF OWN TERMINAL.
107034          ELSE                                       % RT OR BACKGROUND DEV SPEC.
107035             IF ZTREG/\177700=100 GO ILLDV           % FILE IS ILLEGAL
107042             A:=ZTREG                                % LOG DEV NO FROM PARAMETER.
107043          FI
107043          CALL LOGPH; IF A=0 GO ILLDV                % FIND DATAFIELD
107045          IF A.RTRES><RTREF GO NRESV                 % DEVICE MUST BE RESERVED
107052          IF X.TYPRING BIT 5SPLITDF THEN             % SPLIT DATAFIELD
107055             CALL XSETBFPAGE; K:=1                   % USE BUFFER WINDOW
107057          ELSE
107060             K:="0"                                  % NOT SPLIT DATAFIELD
107061          FI
107061          IF X.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN GO ILLDV FI
107067          IF ZAREG=0 THEN X.FLAGB BZERO 5TLREP=:X.FLAGB; GO DUMRE FI
107075          IF A=1 THEN X.FLAGB BONE 5TLREP=:X.FLAGB; GO DUMRE FI
107104          IF A=2 THEN; *IOF
107110             IF K THEN       % SET WNDBF AGAIN TO BE SURE TO AVOID PAGE FAULT
107112                X=:D; CURPROG.BUFWINDOW
107115                T:=0; X:=WNDADDR; *STATX 10           % PHYS PAGE TO PIT
107120                A:=142000; *STATX                     % PROTECT BITS TO PIT
107122                D=:X
107123             FI
107123             A:="0"; T:=X.TINFO
107125             IF T BIT 5BFUL THEN T BZERO 5BFUL; A BONE 2 FI
107131             IF T BIT 5PAER THEN T BZERO 5PAER; A BONE 3 FI
107135             IF T BIT 5FRER THEN T BZERO 5FRER; A BONE 4 FI; T=:X.TINFO; *ION
107143             IF T:=X.FLAGB BIT 5LOGOUT THEN A BONE 1 FI    % LOGOUT WANTED?
107147             IF T BIT 5LSTA THEN A BONE "0" FI             % LINE DEAD?
107152             GO RERET
107153          FI
107153          GO ILLFU
107154
107154   DUMRE: A:="0"
107155   RERET: MIN ZPREG; 0/\0
107157   RETU:  A=:ZAREG; GO RET
107161   NRESV: A:=5; GO RETU                   % DEVICE NOT RESERVED
107163   ILLDV: A:=240; GO RETU                 % ILLEGAL DEVICE TYPE
107165   ILLFU: A:=201; GO RETU                 % ILLEGAL FUNCTION CODE
107167   RBUS
107202
107202   %=======================================================================
107202   %  11.34     G D E V T Y
107202   %
107202   %  MONITOR CALL TO GET DEVICE-TYPE AND ATTRIBUTES (MON 263)
107202   %
107202   %  ENTRY:        T-REG:   DEVICE NUMBER
107202   %                A-REG:   0=INPUT, 1=OUTPUT
107202   %  SKIP RETURN:  T-REG:   DEVICE TYPE
107202   %                A&D REG: DEVICE ATTRIBUTES
107202   %  RETURN:       A-REG:   ERROR CODE
107202   %
107202   %  DEVICE TYPES RETURNED IN T-REG
107202   %      0 - UNSPECIFIED
107202   %      1 - TERMINAL
107202   %      2 - BACKGROUND ACCESS DEVICE (BAD)
107202   %      3 - COMMUNICATION CHANNEL
107202   %      4 - INTERNAL BLOCK DEVICE
107202   %      5 - FLOPPY-DISK
107202   %      6 - MAG-TAPE
107202   %      7 - MASS-STORAGE-FILE
107202   %
107202   %  ATTRIBUTES  RETURNED IN A&D REG
107202   %     BIT  0: INBT/OUTBT ALLOWED
107202   %     BIT  1: CONCT ALLOWED
107202   %     BIT  2: IOSET ALLOWED
107202   %     BIT  3: BLOCK CALLS ALLOWED
107202   %     BIT  4: CLEAR DEV ROUTINE AVAILABLE
107202   %     BIT  5: NO RESERVATION NECESSARY
107202   %     BIT  6: COSMOS REMOTE OPEN FILE
107202   %     BIT  7: NN-CHANNEL USED FOR REMOTE OPEN
107202
107202   SUBR GDEVTY
107202   SYMBOL 9BTERM=1,9BBAD,9BCOM,9BIBDV,9BFLOP,9BMT,9BRFILE            % TYPES
107202   SYMBOL AIOBT,ACONCT,ATISET,AM144,ACLDV,ANORES,ACOSOP,ANNOP,ANOTS,AMTAD,AREMC  % ATTRIBUTES
107202   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG, PTTIF:=TTIFIELD
107205
107205   GDEVTY:
107205          CALL GET0; MLEV; *MST PIE
107210          IF BACKGROUND><0 AND ZTREG=1 THEN
107216             IF PBCHFLAG=0 THEN
107220                PTTNO
107221             ELSE
107222                X:=PTTIF
107223                IF ZAREG=0 THEN X.RIFIL ELSE X.DFOPP.ROFIL FI
107231             FI
107231          ELSE
107232             ZTREG
107233          FI
107233          CALL LOGPH
107234          IF T:=ZAREG><0 THEN D=:A FI
107240          IF A=0 GO ERR                             % NO SUCH LOGICAL UNIT
107241          IF A.TYPRING BIT 5TERM THEN T:=9BTERM; GO ATRIB FI
107247          IF A BIT 5BAD   THEN T:=9BBAD;   GO ATRIB FI
107253          IF A BIT 5IBDV  THEN T:=9BIBDV;  GO ATRIB FI
107257          IF A BIT 5FLOP  THEN T:=9BFLOP;  GO ATRIB FI
107263          IF A BIT 5MT    THEN T:=9BMT;    GO ATRIB FI
107267          IF A BIT 5RFILE THEN T:=9BRFILE; GO ATRIB FI
107273          T:=0
107274   ATRIB: T=:ZTREG:=0
107276          IF A BIT 5RFILE THEN
107300             A=:D; IF X.OFFLG BIT 5RCFIL THEN T BONE ACOSOP FI
107305             IF A BIT 5REMPO THEN T BONE ANNOP FI
107310             D=:A
107311          FI
107311          IF A BIT 5IOBT  THEN T BONE AIOBT FI
107314          IF A BIT 5CONCT THEN T BONE ACONCT FI
107317          IF A BIT 5ISET  THEN T BONE ATISET FI
107322          IF A BIT M144B  THEN T BONE AM144 FI
107325          IF A BIT 5NORES THEN T BONE ANORES FI
107330          IF A NBIT 5TERM  THEN
107332             IF A BIT 5CLDV  THEN T BONE ACLDV FI
107335          ELSE
107336             T=:D
107337             CALL CHNOTS; GO C1; D BONE ANOTS
107342   C1:       CALL CHMTAD; GO C2; D BONE AMTAD
107345             T:=X.TDFPHPAGE SH -6; X:=X.TDFLGADDR; *AAX MTFLA; LDATX
107352             IF A BIT 5MTRC THEN D BONE AREMC FI
107355   C2:       T:=D
107356          FI
107356   UT:    T=:ZDREG; 0=:ZAREG; MIN ZPREG; 0/\0; GO RET
107363   ERR:   33=:ZAREG; GO RET
107366   RBUS
107374
107374
107374   %=============================================================================
107374   %            G E T X M     (MON 334)
107374   %                      A : ERROR CODE.
107374   %                      X : DATA ADDRESS.
107374   %
107374   SUBR GETXM
107374   DISP 0; INTEGER SVACTSG=D0,SVRSGM=D1; PSID
107374   GETXM: CALL GET0
107375          X:=RTREF; OLDPAG=:D; ZXREG; T:=100
107402          CALL CHLIM; GO FAR ERR                       % CHECK USER'S BUFFER ADDRESS
107404          RTREF.ACT1SEG=:SVACTSG; X.RSEGM=:SVRSGM      % SAVE USER'S SEGMENT
107411          MLEV; *MST PIE
107413          T:=ECODSEG; CALL M1MEXY                      % GET ERROR-PROGRAM SEGMENT
107415          A:=ZAREG
107416          T:="ASPIT"=:D; CALL DALTON                   % TO ACCESS ERRORTEXT
107421          T:="CBUFF"=:D
107423          IF A<<ER0 THEN
107426             ERSTB(A)
107430          ELSE IF A<<ERM THEN
107434             A-ER0
107435             ERTAB(A)
107437          ELSE IF A>>=RX000 AND A<<RXMAX THEN
107446              A-RX000
107447              XRTAB(A)
107451          ELSE IF A>>=1000 AND A<<1100 THEN
107460              A-1000=:X
107462              CALL FAR GET5M
107463              ND5T1(X)
107464          ELSE IF A>>=2000 AND A<<2400 THEN
107473              A-2000=:X
107475              CALL FAR GET5M
107476              ND5T2(X)
107477          ELSE IF A>>=7600 AND A<<7652 THEN
107506              A-7600=:X; T:=D; "T5TRP"=:D; 11=:L; *MOVAN
107516              T=:D; TRAPT(X)
107520          ELSE IF A>>=101400 AND A<<101500 THEN
107527              A-101400=:X; T:=D; "TOCTM"=:D; 11=:L; *MOVAN
107537              T=:D; OCTOT(X)
107541          ELSE IF A>>=150700 AND A<<151000 THEN
107550              A-150700=:X; T:=D; "T5ERR"=:D; 11=:L; *MOVAN
107560              T=:D; NDIXT(X)
107562          ELSE
107563              ERTAB(0)
107565          FI FI FI FI FI FI FI FI
107565          GO L1; *)FILL
107627   L1:    D=:T:=A; "CBUFF+77"-T=:L; *MOVAN                % COPY ERROR-MESSAGE
107635          CALL SINALTPIT
107636          SVRSGM=:RTREF.RSEGM; T:=SVACTSG; CALL M1MEXY    % RESTORE USER'S SEGMENT
107643          ##'=:D; T:="CBUFF"                              % COUNT NUMBER OF BYTES IN ERROR MESSAGE
107646          X:=0; 176=:L; *1BANK
107652          DO
107652              *LBYT
107653          WHILE A><D AND X<L
107657              X+1
107660          OD
107661          *2BANK
107662          A:=X+1 SHZ -1+1=:X                  % X:= NUMBER OW WORDS IN ERROR MESSAGE.
107666          T:=ZXREG                            % POINTER TO USER DATA
107667          OLDPAGE=:D; CALL DALTON
107672          "CBUFF"=:D; X=:L; *MOVNA            % MOVE TO USER'S BUFFER
107676          CALL SINALTPIT
107677          MIN ZPREG; 0/\0; GO RET
107702
107702   ERR:   153=:ZAREG; GO RET                                  % ILLEGAL ADDRESS REFS IN MONCALL
107705   *)FILL
107714   INTEGER ARRAY CBUFF(100)                                   % BUFFER FOR ERROR-MESSAGE
110014
110014   GET5M: IF A>>=2146 AND A<<2300 THEN
110022              IF A<<2165 THEN "TACCP"
110026              ELSE IF A<<2171 THEN "T5TMO"
110033              ELSE IF A<<2200 THEN "T5ERR"
110040              ELSE IF A<<2300 THEN "TMICP"
110045              FI FI FI FI
110045          ELSE
110046              "T5ERR"
110047          FI
110047          T:=D; A=:D; A:=11:=:L; *MOVAN
110054          T=:D; A=:L
110056          EXIT
110057   RBUS
110070
110070   %=========================================================
110070   %         C P L A M
110070   %   CHECK IF A PHYSICAL PAGE IS WITHIN A CONNECTED LAMU
110070   %   RETURNS WITH INTERRUPT ON
110070   %   ENTRY:    T = PHYSICAL PAGE
110070   %             A = RT DESCR
110070   %   EXIT:     NOT WITHIN A CONNECTED LAMU
110070   %   EXIT+1:   OK.
110070
110070   SUBR CPLAM
110070
110070   *"8LAMU
"110070   INTEGER PPAG                 % PHYSICAL PAGE
110071   INTEGER CACL                 % CURRENT ACTIVE LAMU ELEMENT
110072   INTEGER SAVX
110073   INTEGER LC                   % LOOP COUNTER
110074   *"
"110074
110074   CPLAM:
110074   *"8LAMU
"110074     *IOF
110075     X=:SAVX; T=:PPAG:=5RTSIZE; A-RTSTART=:D:=0; *RDIV ST
110104     A*GNLPRT*ALMSZ+LAMACT=:CACL; 0=:LC
110111     FOR LC TO GNLPRT-1 DO
110116           A*ALMSZ+CACL=:X; T:=LAMBANK; *LDATX
110123           IF A >< 0 THEN
110124              IF A > 0 THEN A*LDTSZ+LAMDT
110130              ELSE A-*SDTSZ+SYLDT FI A=:X
110135              *LDDTX LMPP
110136              D+A-1
110140              IF A <<= PPAG  AND D >>= T THEN
110145                  L+1; GO CHLRE
110147              FI
110147           FI
110147     OD
110153   CHLRE: X:=SAVX; *ION
110155   *"
"110155          EXIT
110156   RBUS
110167
110167   %==============================================================================
110167   %            E X A B S       (MON 335)
110167   %
110167   % ENTRY:     X=WORKING AREA
110167   %            B=PARAMETER LISTE
110167   %
110167   SUBR EXABS
110167
110167   DISP 0; TRIPLE TRIP1=ZPREG,TRIP2=ZAREG,TRIP3=ZSREG; PSID
110167
110167   INTEGER SVX=?
110167
110167   EXABS: X=:SVX; X.ZTREG; CALL LOGPH; IF A=0 GO ERR          % CHECK DATAFIELD
110173          IF SVX.OLDPAGE NBIT "1" THEN
110177             IF BACKGROUND=0 OR "BFIELD".PASSTYPE><2 GO ERR   % NOT USER SYSTEM
110206          FI
110206          MLEV; *MCL PIE
110210          FOR X:="FPL3ABS" STEP A3DFSIZE TO "LPL3ABS"-A3DFSIZE DO % FIND PARAMETER FIELD
110215             IF X.RTRES=0 OR A=RTREF GO FOUND
110222          OD
110224          IF X.RTRES=0 THEN X=:B:="DUMMY"; CALL BRESERVE; FI  % RESERVE QUEUEING SEMAPHORE FOR DUMMY
110231          X:=RTREF; CALL FREXQU; CALL TOWQU                   % WAIT FOR ABSTR PARAMETER LISTE
110234          SVX=:B; ZPREG-1=:ZPREG; GO RETSTUPR; *)FILL
110255
110255   ERR:   X:=SVX=:B; -1=:ZAREG; GO RETSTUPR                   % OPERATION REJECTED
110262
110262   INTEGER SVX
110263   FOUND: X=:B:=RTREF; CALL BRESERVE                          % RESERVE ABSTR PARAMETER LISTE
110266          IF A<0 THEN CALL ERRFATAL FI; X:=SVX
110271          TAD:=X.TRIP1=:TRIP1:=X.TRIP2=:TRIP2:=X.TRIP3=:TRIP3
110277          X:=:B=:SVX:=RTREF; CALL BRELEASE                    % RELEASE ORIGINAL WORKING FIELD
110303          SVX=:B; MLEV; *MST PIE
110307          X:=ZAREG:=:B; CALL GETXABS; MLEV; *MST PIE          % GET PARAMETERS
110314          IF BACKGROUND >< 0 THEN
110316             A3MEM SHZ 6; A=:T:=RTREF; CALL CPLAM; GO ERR     % CHECK WITHIN LAMU
110324          FI
110324          T:=ZTREG; "A3PLIST"+B; *MON 2ABST
110330          A=:ZAREG; X:=A3RETADDR; A3NWRD; CALL USALTPIT
110334          AD=:X.DS0; CALL SINALTPIT                           % RETURN LAST PARAMETER
110336          MLEV; *MCL PIE
110340          IF "LPL3ABS".RTRES="DUMMY" THEN
110345             IF X.BWLINK><X THEN
110350                X:=:B; X=:SVX:=A; CALL FRWQU; CALL TOEXQU; SVX=:B
110357             FI
110357          FI; X:=RTREF; CALL BRELEASE
110361          GO RET
110362
110362   RBUS
110402
110402   %==============================================================================
110402   %      ( R )      E L O N     E L O F
110402
110402   % MONITOR CALLS TO TURN ON OFF DELAYED ESCAPE HANDLING
110402   %
110402   % ELON  (ELON  - MON 302)   - NORMAL  ESCAPE/LOCAL DETECTION
110402   % ELOF  (ELOFF - MON 303)   - DELAYED ESCAPE/LOCAL DETECTION
110402   SUBR ELON,ELOF,T2P07
110402   INTEGER POINTER TTIF:=TTIFIELD
110403   ELON:  CALL GET0
110404          IF TTIF=0 THEN 33; GO RETU; FI
110410          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110416             240; GO RETU
110420          FI
110420          IF X.FLAGB BIT 5WLOC THEN
110423                IF A BIT 5LCHAR THEN
110425                   X.LUSADD=:ZPREG        % RETURN IN LOCAL CHAR HANDLING
110427                   GO ESON
110430                FI
110430          FI
110430          IF A BIT 5WESC THEN
110432                X:=:B; *IOF               % ESCAPE RESPONSE IF TAD
110434   T2P07:       CALL CBRERSP; 0/\0; *ION
110437                X:=:B
110440                IF X.FLAGB BIT 5USESC THEN
110443                   X.EUSADD=:ZPREG        % RETURN IN USER ESCAPE HANDLING
110445                   GO ESON
110446                ELSE
110447                   "XBRTWT"               % SYSTEM ESCAPE HANDLING
110450                   *IOF; IRW MLEVB DP
110452                   MLEV; *MST PID; MST PIE; ION
110456                FI
110456          FI
110456          MIN ZPREG; 0/\0
110460   ESON:  X.FLAGB BZERO 5ESCLOFF; GO OUT
110463
110463   ELOFF: CALL GET0; IF TTIF=0 THEN 33; GO RETU; FI
110470          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110476             240; GO RETU
110500          FI
110500          X.FLAGB BONE 5ESCLOFF; MIN ZPREG; 0/\0; GO OFOUT
110505   OUT:   A BZERO 5WLOC BZERO 5WESC
110507   OFOUT: A=:X.FLAGB; A:=0
110511   RETU:  A=:ZAREG; GO RET
110513   RBUS
110520
110520   %==============================================================================
110520   %      ( R )      E L O F U   D L O F U
110520
110520   % MONITOR CALLS TO ENABLE/DISABLE LOCAL FUNCTION
110520   %
110520   % ELOFU - MON 276   - ENABLE  LOCAL FUNCTION
110520   % DLOFU - MON 277   - DISABLE LOCAL FUNCTION
110520   SUBR ELOFU,DLOFU
110520   INTEGER POINTER TTIF:=TTIFIELD
110521   ELOFU: K:=1; GO FELLS
110523   DLOFU: K:="0"
110524   FELLS: CALL GET0
110525          IF TTIF=0 THEN 33; GO RETU; FI
110531          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110537             240; GO RETU
110541          FI
110541          IF K THEN
110543             ZAREG=:X.LUSADD; *IOF
110546             X.FLAGB BONE 5LCHAR=:X.FLAGB; *ION
110552          ELSE
110553             *IOF
110554             X.FLAGB BZERO 5LCHAR BZERO 5WLOC=:X.FLAGB; *ION
110561          FI
110561          MIN ZPREG; 0/\0; A:=0
110564   RETU:  A=:ZAREG; GO RET
110566   RBUS
110571
110571   %==============================================================================
110571   %            E U S E L   D U S E L
110571
110571   % MONITOR CALLS TO ENABLE/DISABLE USER ESCAPE HANDLING
110571   %
110571   % EUSEL - MON 300   - ENABLE  USER ESCAPE HANDLING
110571   % DUSEL - MON 301   - DISABLE USER ESCAPE HANDLING (NORMAL SINTRAN MODE)
110571   SUBR EUSEL,DUSEL
110571   INTEGER POINTER TTIF:=TTIFIELD
110572   EUSEL: K:=1; GO FELLS
110574   DUSEL: K:="0"
110575   FELLS: CALL GET0
110576          IF TTIF=0 THEN 33; GO RETU; FI
110602          IF A.TYPRING NBIT 5TERM AND A NBIT 5BAD THEN
110610             240; GO RETU
110612          FI
110612          IF K THEN
110614             ZAREG=:X.EUSADD; *IOF
110617             X.FLAGB BONE 5USESC=:X.FLAGB; *ION
110623          ELSE
110624             *IOF
110625             X.FLAGB BZERO 5USESC BZERO 5WESC=:X.FLAGB; *ION
110632          FI
110632          MIN ZPREG; 0/\0; A:=0
110635   RETU:  A=:ZAREG; GO RET
110637   RBUS
110642
110642   %=======================================================================
110642   %            I B R S I Z
110642   %
110642   % MONITOR CALL TO RETURN NUMBER OF CHARACTERS IN THE INPUT-BUFFER
110642   % IF BREAK STRATEGY APPLIES TO THE DEVICE, NUMBER OF CHARACTERS
110642   % UNTIL BREAK CONDITION IS ALSO RETURNED.
110642   % MON 313
110642   % ENTRY:       T = DEVICE-NUMBER
110642   % SKIP-RETURN: A = NUMBER OF CHARACTERS IN BUFFER
110642   %              X = BREAK CHARACTER NUMBER
110642   % NOSKIP:      A = ERROR CODE
110642
110642   SUBR IBRSIZ,T2P06
110642   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG
110644   INTEGER BREG=?,BCOUNT=?,BHENTE=?,BBUFS=?
110644   IBRSIZ:CALL GET0
110645          CALL GZTREG; GO FAR ERR; IF A=0 GO FAR ERR
110651          A:=:B=:BREG
110653          IF TYPRING BIT 5TERM THEN; *IOF           % TERMINAL
110657             B=:X; CALL XSETBFPAGE; X=:B
110662             0=:BCOUNT
110663             IF BRKTAB><0 THEN                                          % BREAK APPLIES
110665                IF BHOLD><0 THEN
110667                   IF DFLAG NBIT 5ECHO THEN                             % PAST BREAK IN DRIVER
110672                      HENTE=:BHENTE
110674                      IF RSISTE=-1 THEN                                 % HENTE PAST FIRST BREAK
110700   CHCHR:                1=:BCOUNT
110702                         A:=B/\176000+BUFST=:BBUFS
110706                         FOR X:=BCOUNT TO BHOLD DO; X=:BCOUNT           % SEARCH FOR BREAK
110713                            T:=BBUFS; X:=BHENTE
110715                            *LBYT
110716                            X+1; IF X=MAX THEN X:=0 FI; X=:BHENTE
110724                            X:=BRKTAB; CALL VSXGETBIT; IF A<0 GO RETTR
110727                         X:=BCOUNT; OD
110732                         0=:BCOUNT
110733                         IF BRKMAX><0 THEN
110735                            IF BHOLD+NCBRK>=BRKMAX THEN
110742                               BRKMAX-NCBRK=:BCOUNT
110745                            FI
110745                         FI
110745                      ELSE
110746                         IF BHENTE=RSISTE GO CHCHR
110752                         DO                                             % BREAK FROM DRIVER
110752                            A+1; IF A=MAX THEN A:=0 FI                  % FIND NUMBER
110757                            MIN BCOUNT; IF A=RSISTE GO RETTR
110763                         OD
110764             FI;FI;FI;FI
110764   RETTR:    A:=BHOLD
110765             GO RETU; *)FILL
110774
110774   INTEGER BREG,BCOUNT,BHENTE,BBUFS
111000
111000          FI
111000          IF TYPRING BIT 5BAD THEN                  % TAD
111003              B=:X; BREG=:B; CALL XISWTAD
111007   T2P06:     GO BISIZ; 0/\0                        % RETURN IN BISIZ IF TAD INCLUDED
111011          FI
111011          IF TYPRING BIT 5IOBT THEN
111014             0=:BCOUNT; A:=BHOLD; GO RETU
111017          FI
111017
111017   ERRB:  BREG=:B
111021   ERR:   240=:ZAREG; GO RET
111024   RETU:  T:=BREG=:B; T:=BCOUNT
111027          A=:ZAREG; T=:ZXREG; MIN ZPREG; 0/\0; GO RET
111034   RBUS
111040
111040
111040   *"8UDMA+8VICO
"111040   SUBR UDMA
111040   %------------------------------------------------------------------
111040   % LEVEL 1  PON, ION  RING 2
111040   % ENTRY: X = WORKING FIELD  (IN OUTPUT DATAFIELD)
111040   %        B = PARAMETER LIST
111040   %------------------------------------------------------------------
111040     DISP 20; INTEGER UFUNC; PSID        % FUNCTION CODE
111040     DISP 21; INTEGER UCORA; PSID        % ADDRESS TO USER BUFFER
111040     DISP 22; INTEGER UPA1H
111040              INTEGER UPA1L
111040         DOUBLE UPAR1=UPA1H; PSID        % INPUT PARAMETER (LENGTH)
111040     DISP 24; INTEGER UOUTD; PSID        % OUTPUT DATAFIELD HAS ABSTR PARAMETER LIST
111040     DISP 25; INTEGER UPIOD; PSID        % PIO OUTPUT DATA
111040     DISP 26; INTEGER URETW; PSID        % RETURN PARAMETER ADDRESS
111040     DISP 30; INTEGER UMAXW; PSID        % LOOP COUNTER WHEN COPYING DATA TO/FROM USER
111040     DISP 31; INTEGER UBANK;             % MOST SIGNIFIKANT BUFFER ADDRESS
111040              INTEGER UBADR;             % LEAST SIGNIFIKANT BUFFER ADDRESS
111040         DOUBLE UBUFF=UBANK; PSID        % FULL BUFFER ADDRESS
111040     DISP 35; INTEGER UFLAG; PSID        % USER FUNCTION FLAG
111040       SYMBOL BTUS=0            % COPY BUFFER TO USER
111040       SYMBOL BFUS=1            % COPY BUFFER FROM USER
111040       SYMBOL RETU=2            % RETURN PARAMETER TO USER
111040       SYMBOL DIRT=3            % DIRECT TRANSFER TO/FROM RT-PROG
111040       SYMBOL NRER=4            % NOT RETURN ERROR 171 (FOR READ STATUS)
111040       SYMBOL PIOI=5            % PIO IN PIO DATA IN 1 WORD BUFFER
111040       SYMBOL PIOO=6            % PIO OUT PIO DATA IN 1 WORD BUFFER
111040   DISP  0; DOUBLE POINTER DP2=P2; PSID
111040   DISP 7                     % ABSTRANS PARAMETER LIST IN OUTPUT DATAFIELD
111040       INTEGER POINTER FUNCP          % / *+4
111040       DOUBLE  POINTER MEMOP          % / *+4
111040       INTEGER POINTER BLOCP          % / *+5
111040       DOUBLE  POINTER DATP           % / *+5
111040
111040   PSID
111040   %---------------------------------------------------------------------
111040   % LOCAL SUBROUTINE FOR COPYING DATA TO/FROM DEVICE BUFFER FROM/TO USER ARRY
111040   %---------------------------------------------------------------------
111040   DTTU:  K:="0"; GO DTF
111042   DTFU:  K:=1
111043   DTF:   A:=L=:"MCLRG"; OLDPAGE=:D;     OFLCK; CALL XLOCK
111051          T:=UBANK; X:=UBADR; UCORA; CALL DBTRANS
111055          T:=UMAXW; * BSKP IF ZRO SSK; SWAP SX DA
111060          CALL COPYB; OFLCK; CALL XUNLOCK;
111063          GO MCLRG              % EXIT
111064   *)FILL
111071
111071   UDMA:
111071          CALL GETUD;  % GET PARAMETERS B = WORKING AREA
111072
111072          ZTREG; CALL LOGPH; IF A= 0 GO FAR EE033;
111076          D=:T; T=:UOUTD;    % SAVE OUTPUT DATAFIELD FOR ACCESSING ABSTR PARAMETER LIST
111100          IF A.TYPRING NBIT M144B GO FAR EE240          % UDMA LEGAL ON THIS DEVICE ?
111104          MLEV; *MST PIE;
111106          IF BACKGROUND >< 0 THEN                   % BACKGROUND
111110              X:=B+5REG;     *LRB BLEVB
111113              X:="ESCBLOCK"; *SRB BLEVB
111115              A:=B=:CMDFFIELD
111117          FI
111117
111117          "0"=:D
111121          IF UFUNC=0 THEN
111123             D BONE BTUS; D BONE RETU
111125            ELSE IF A = 1 THEN
111131                 D BONE BFUS
111132              ELSE IF A = 2  OR =  3 THEN
111141                  D BONE DIRT
111142                ELSE IF A = 20 OR = 24 THEN
111151                     D BONE RETU; D BONE NRER
111153                  ELSE IF A = 54 OR= 56 THEN
111162                       D BONE PIOI
111163                    ELSE IF A = 55 OR= 57 THEN
111172                         D BONE PIOO;
111173                      ELSE IF A = 7 OR = 62 THEN
111202                           D BONE RETU;
111203                        ELSE IF A=21 OR=64 OR=65 OR=70 THEN % FUNCTION OK
111220                          ELSE GO FAR EE174; *)FILL
111232           FI FI FI FI FI FI FI FI
111232
111232          A:=D=:UFLAG
111234          T:=OLDPAG=:D; X:=RTREF
111237          IF A BIT BTUS OR BIT BFUS OR BIT PIOI THEN          % CHECK USER ADDRESS SPACE
111245             IF A BIT PIOI THEN
111247                T:=1
111250             ELSE
111251                T:=UPA1L;
111252             FI
111252             A:=UCORA;  CALL CHLIM; GO FAR EE153;
111255          FI
111255          IF UFLAG BIT RETU THEN
111260             A:="IRETW"; T:=2; CALL CHLIM; GO FAR EE153;
111264          FI
111264
111264          IF UFLAG BIT BTUS OR BIT BFUS OR BIT DIRT THEN
111273              OFLCK; CALL XLOCK
111275              IF BACKGROUND >< 0 GO GBUF                  % RT PROGRAM
111277                 A:=RTREF+"ACT1SEG"=:T; X:=OLDPAG; AD:=UPAR1
111304                 UCORA; CALL CXCFR; GO GBUF;      % CHECK IF SEGMENT IS FIXC'ED
111307                 T:=UFLAG BZERO BTUS; T BZERO BFUS=:UFLAG % NO BUFFER TO/FROM USER
111313                 GO SBU; *)FILL
111324   GBUF:      IF UFLAG BIT DIRT GO EE241
111327              UPAR1;IF A >< 0 GO EE174; A:=D=:UMAXW       % DEVICE BUFFER << 64K
111333              T:=ZTREG; CALL GRBUFF; GO EE131
111336   SBU:       X:=UOUTD; X:=:B; AD=:MEMOP; B:=X; AD=:UBUFF
111343              OFLCK; CALL XUNLOCK;
111345          FI
111345          IF UFLAG BIT BFUS THEN CALL FAR DTFU FI      % DATA FROM USER TO BUFFER
111351
111351          IF UFLAG BIT PIOO OR A BIT PIOI THEN
111356            A:=UPIOD=:D; A:=UPA1L; AD=:UPAR1           % UCLIN BIT MASK + PIO DATA
111362          FI
111362          X:=UOUTD; X:=:B
111364          X.UFUNC=:FUNCP; X.UPAR1=:DATP; B:=:X
111371          T:=ZTREG;  A:=X; * AAA FUNCP; MON 2ABST       %  ABSTRANS
111375
111375          IF A < 0 AND UFLAG NBIT NRER THEN "171"  % RETURN ERRORCODE
111402          ELSE "0" FI
111404          A=:ZAREG
111405          IF UFLAG BIT RETU OR A BIT PIOI THEN        % RETURN PARAMETER OR DATA
111412            X:=UOUTD; X:=:B; AD:=DATP; B:=X           % GET RET.PARAM FROM ABSTR
111416            T:=UFLAG
111417            IF T BIT PIOI THEN X:=UCORA ELSE X:=URETW FI
111424            CALL USALTPIT
111425            IF T BIT PIOI THEN                        % RETURN ONE WORD DATA
111427               A:=D=:X.S0;
111431            ELSE                                      % RETURN DOUBLE WORD PARAM
111432               AD=:X.DS0;
111433            FI
111433            CALL SINALTPIT
111434          FI
111434          IF UFLAG BIT BTUS THEN  CALL FAR DTTU FI    % COPY DATA TO USER BUFFER
111440
111440          IF UFLAG BIT BFUS OR BIT BTUS THEN
111445            OFLCK; CALL XLOCK
111447            T:=ZTREG; CALL RRBUF; CALL ERRFATAL % RELEASE BUFFER
111452            OFLCK; CALL XUNLOCK
111454          FI
111454          GO FINE
111455   EE033: "033"; GO ERR                            % NO SUCH LOGICAL UNIT
111457   EE131:  OFLCK; CALL XUNLOCK; "131"; GO ERR       % NO MORE BUFFER SPACE
111463   EE153: "153"; GO ERR                            % ILLEGAL ADDRESS REF.
111465   EE174: "174"; GO ERR                            % ILLEGAL PARAMETER
111467   EE240: "240"; GO ERR                            % ILLEGAL DEVICE TYPE
111471   EE241:  OFLCK; CALL XUNLOCK; "241";              % SEGMENT NOT CONTIGUOSLY FIXED
111474   ERR:    A=:ZAREG;
111475   FINE:   GO RET
111476   RBUS
111513
111513   SUBR UDTMO
111513   UDTMO:
111513   %===================================================================
111513   %      TIMEOUT ROUTINE FOR UNIVERSAL DMA INTERFACE LEVEL 1
111513   %===================================================================
111513         * LDA  (UD11T          % TIME OUT ROUTINE ON LEVEL 11
111514         * IRW   130 DP
111515         * COPY  SB DA
111516         * IRW   130 DB         % SET BREG TO DATAFIELD
111517         * LDA   (4000
111520         * MST   PID            %ENABLE LEVEL 11
111521         * EXIT                 % RETURN
111522   RBUS
111524
111524   *"8F5UD
"111524   %============================================================================
111524   %            U D R x x
111524   %
111524   % RT-PROGRAMS FOR FAST MON UDMA FROM ND-500
111524   %
111524   @ICR
111524   SUBR URT01,URT02,URT03,URT04,URT05,URT06,URT07,URT08,
111524        URT09,URT10,URT11,URT12,URT13,URT14,URT15,URT16,UFELL;
111524   @CR;
111524   *"8F5UD
"111524
111524   DISP 7                     % SPECIAL DF. FOR UDRXX RT-PROG
111524          INTEGER UR5M                          % ADDRESS TO MESSAGE FROM N500 PROC.
111524          INTEGER POINTER FUNCP                 % FUNCTION
111524          DOUBLE  POINTER MEMOP                 % MEMORY ADDRESS
111524          INTEGER POINTER BLOCP                 % NOT USED
111524          DOUBLE  POINTER NWORP                 % NR OF 16 BITS WORDS
111524   PSID
111524          INTEGER SVB=?,SVT=?,HST=?,FUN=?,SBM=?,CLM=?
111524   UFELL: *2BANK; IOF
111526          A+LUDV=:SVT                            %LOG DEV NO
111530          CALL LOGPH; IF A = 0 THEN CALL XERRF;  FI
111533                      IF D = 0 THEN CALL XERRF;  FI
111536          A:=D.N5RDF=:B; X:=RTREF
111542          CALL BRESERVE; IF A < 0 THEN CALL XERRF;  FI
111545          DO %------------------------------------  FOREVER
111545   L1:       T:=SVT;
111546             RTREF.STATUS BONE 5WAIT =:X.STATUS   % SET INTO
111552             "RWAIT";* IRW MLEVB DP               % I/O WAIT
111554             MLEV  ;* MST PIE; MST PID; ION       % UNTIL .....
111560                                                  % ACTIVATED FROM ND-500-DRIVER
111560             A:=B;  * AAA FUNCP; MON 2ABST; IOF   % ABSTR TO ACTIVATE DRIVER
111564             A=:HST; FUNCP=:FUN; T=:SVT
111570             X:=UR5M; CALL RN5STATUS              % READ MESSAGE STATUS
111572             IF A-WFUDMA >< 0 GO L1               % ND-500 PROC NOT WAITING FOR UDMA
111574             IF FUNCP=0 OR =2  THEN               % CLEAR CACHE ON DMA INPUT
111601               7400=:CLM
111603             ELSE
111604               0=:CLM
111605             FI
111605             IF FUNCP=0 OR A=7 OR A=20 OR A=24 OR A=62 THEN
111623               IF A=0 THEN AD:=NWORP SHZ 1        % WORDS TO BYTE
111626               ELSE        AD:=NWORP
111630               FI
111630               T:=5MBBANK;*AAX 5AP5; STDTX        % STORE RETURN PAR (NO 5)
111633               20=:SBM                            % RETUN PARAMETER (NO 5)
111635             ELSE IF A =54 OR A =56 THEN          % PIO INP. DATA
111644               AD:=NWORP; "0"                     % MOVE TO DATA ARRY
111646               T:=5MBBANK;*AAX 5AP2; STDTX        % STORE RETURN PAR (NO 2)
111651               2=:SBM                             % RETUN PARAMETER (NO 2)
111653             ELSE
111654               0=:SBM; T:=5MBBANK
111656               GO NRET; *)FILL                    % NO RETURN PARAMETER
111670               INTEGER SVB,SVT,HST,FUN,SBM,CLM
111676             FI;FI
111676   NRET:     CALL SLOCK; GO N500ERR               % GET GENERAL LOCK WHILE UPDATING FLAGWORD
111700             T:=5MBBANK; X:=UR5M; *AAX 5MSFL
111703             A:=NOWFL; * BLDA 000 DA              % IF NO WAIT
111705             *LDATX; BSTA 000 DA; STATX; AAX -5MSFL % DON'T UNFIX USER FIXED
111711             CALL SUNLOCK
111712             CALL GCPUDF; CALL ERRFATAL
111714             A:=:B=:SVB                           % B= 500-CPU DATAFIELD
111716   *NNT37=*
111716             CALL TER500; GO N500ERR              % STOPP ND-500
111720             SBM=:D
111722             IF HST < 0 AND FUN >< 20 AND A>< 24 THEN % READ STATUS
111733               "171"; CALL 5EMONICO               % RETURN STATUS TO ND-500 PROC.
111735             ELSE
111736               T:=CLM; CALL 5MONICO               % RETURN STATUS TO ND-500 PROC.
111740             FI
111740             CALL ACTRDY                          % RESTART PROCESS
111741             CALL LOWACT500; SVB=:B               % START ND-500
111744          OD
111745   XERRF: *ION; MON 0; )FILL
111761   N500ERR: CALL RSTARTALL; GO XERRF
111763
111763   *"8UD01+8VI01 8F5UD
"111763   URT01: "0";GO UFELL
111765   *"8UD02+8VI02 8F5UD
"111765   URT02:  1 ;GO UFELL
111767   *"8UD03+8VI03 8F5UD
"111767   RBUS
111772   *"
"111772
111772   *"8DILG
"111772
111772   %============================================================================
111772   %            D I L R T
111772   %
111772   % RT-PROGRAM FOR DISC-LOGGING ON FILE DISC-LOGG:LOGG
111772   %
111772
111772   SUBR DILRT
111772
111772   DILRT: *2BANK
111773          "DFDIL"=:B;
111775          *IOF
111776          DILGFLAG BZERO DILBOK=:DILGFLAG
112001          *ION
112002          "DLPMF"; *MON 2UNFI                         % UNFIX DISC-LOG BUFFER SEGEMENT
112004          -1=:DLMLPHPAGE
112006          DO
112006             DLMLPHPAGE+1=:DLMFPHPAGE+77=:DLMLPHPAGE
112013             "DLPM61"; *MON 61; JMP NXT               % ALLOCATE DISC-LOG BUFFER SEGMENT WITHIN A MEMORY BANK
112016             GO OK
112017   NXT:   WHILE DLMLPHPAGE<<ENDPAGE
112023          OD; GO FAR ERR                              % MEMORY NOT AVAILABLE
112025   *)FILL
112034   INTEGER CCCBUF                                     % BUFFER 1/ BUFFER 2 FLAG
112035   OK:    *IOF
112036          DILGFLAG BONE DILBOK=:DILGFLAG
112041          DILFUNIT SH 6+61=:DALFUNC                   % FUNC=61: WRITE
112045          "DILGS"*5SEGSIZE+SEGSTART=:X; T:=SEGTBANK; *BPAGL@3 LDATX
112053          A SHZ -2                                    % DIV BY 4; PHYS. PAGE
112054          A=:D:=0; AD SH 12=:DDIBADDR                 % PHYS.ADDR OF DISC-LOG BUFFER
112060          A:=D=:DILBPNT                               % PHYS.ADDR WITHIN MEM.BANK
112062          DO
112062   LOOP:     IF T:=DILGFLAG NBIT DILSTART GO OUT          % IF NOT STARTED
112065             IF T BIT 1DILBFULL OR T BIT 2DILBFULL THEN   % ANY DISC-LOG BUFFER FULL?
112071                T BONE DILIABSTR=:DILGFLAG                % YES, MARK TRANSFER GOING ON
112073                AD:=DDIBADDR
112074                IF T BIT 2DILBFULL THEN T:=2000 ELSE T:=0 FI
112101                T=:CCCBUF; D+T; A:=A+C; AD=:DALCMADDR     % PHYS.ADDR OF CURRENT LOG-BUFFER TO TRANSFER
112105                DILDADDR=:DALCDADDR                       % CURRENT MASS STORAGE ADDR
112107                *ION
112110                T:=DILFLOG; "DALM131"; *MON 2ABST
112113                A=:D                                      % TRANSFER STATUS IN D-REG
112114                *IOF
112115                T:=DILGFLAG BZERO DILIABSTR               % MARK THAT TRANSFER IS FINISHED
112117                IF CCCBUF=0 THEN T BZERO 1DILBFULL ELSE T BZERO 2DILBFULL FI
112124                T=:DILGFLAG
112125                IF D<0 GO ERR                             % ERROR IN TRANSFER
112127                AD:=DILLADDR; A=:T; D=:L; AD:=DILDADDR
112133                IF A>>T OR A=T AND D>>=L GO ERR1          % END OF LOG-FILE
112141                T:=2; D+T; A:=A+C; AD=:DILDADDR           % NEXT MASS STORAGE ADDR
112145             ELSE
112146                RTREF.STATUS BONE 5WAIT=:X.STATUS         % WAIT FOR NEXT BUFFER TO BE FULL
112152                "RWAIT"; *IRW MLEVB DP
112154                MLEV; *MST PID; ION
112157             FI
112157          OD
112160   *)FILL
112170
112170   ERR:   *IOF
112171          DILGFLAG BZERO DILSTART BZERO DILBOK=:DILGFLAG
112175          A:=-1
112176          *ION; MON 64                                    % ALL ERRORS EXCEPT END-OF-LOG-FILE
112200   OUT:   *ION
112201          "DLPMF"; *MON 2UNFI
112203          *MON 2RTEX
112204
112204   ERR1:  DILGFLAG BZERO DILSTART BZERO DILBOK=:DILGFLAG
112210          *ION
112211          RX002; *MON 64                                  % END-OF-LOG-FILE
112213          GO OUT
112214   RBUS
112216
112216   *"8STRN+8N500
"112216   %==============================================================================
112216   %      ( R )    3 I N S T R   3 O U T S T
112216   %
112216   % STRING MONITOR CALLS
112216   % I=INSTR(LOG.NO,COREADDR,MAXNO,TERMINATOR)
112216   % I=OUTST(LOG.NO,COREADDR,NUMBER)
112216   SUBR 3INSTR,3OUTST
112216
112216   DISP 24
112216          INTEGER COUN,VAL,DYTYFIELD
112216          INTEGER POINTER LREG
112216          INTEGER ADR=D1,USAPITS=D0,OUSAPIT=D3
112216   PSID
112216   %====================================================================
112216   %      ( R )        C 3 O U T X
112216   %
112216   % LOCAL SUBROUTINE TO CHECK FOR LEGAL DEVICE FOR INSTR/OUTSTR
112216   %
112216   % EXIT:      A=ADDR OF INPUT DATAFIELD
112216   %            D=ADDR OF OUTPUT DATAFIELD
112216   %
112216   INTEGER POINTER PTTNO:=TTNO,PBCHFLAG:=BCHFLAG, PTTIFIELD:=TTIFIELD
112221   C3OUTX: A:=L=:"LREG"
112223          IF BACKGROUND><0 THEN
112225             X:=B+7; *LRB BLEVB           % SAVE REGS INCASE ESCAPE
112230             X:="ESCBLOCK"; *SRB BLEVB
112232             A:=B=:CMDFFIELD
112234             IF D0=1 THEN                 % LOG.DEV=1?
112240                IF PBCHFLAG=0 THEN        % YES, IS IT IN BATCH/MODE?
112242                   A:=PTTNO               % NO, USE LOGICAL DEV OF TERMINAL/TAD
112243                 ELSE
112244                   A:=PTTIFIELD.DFOPP.ROFIL % BATCH/MODE, USE BATCH/MODE OUTPUT FILE
112247                 FI
112247             FI
112247          ELSE
112250             D0                           % RT-PROGR, USE LOG.DEV IN PAR.LISTE
112251          FI; A=:D
112252          IF A/\177700=100 GO FAR ERR2    % NOT ALLOWED ON FILE
112256          A:=D; CALL LOGPH                % GET ADDR OF DATAFIELDS
112260          GO LREG
112261   *)FILL
112267
112267   %==============================================================
112267   %      ( R )     C H E R R
112267   %
112267   % LOCAL SUBROUTINE TO CHECK FOR ERRORS
112267   %
112267   % ENTRY:     X=ACTUAL DATAFIELD ADDR.
112267   %
112267   % RETURN: X=BUFFER ADDR.
112267   %
112267   CHERR: A:=L=:"LREG"
112271          X=:DYTYFIELD                              % X=DF. ADDR
112272          IF X=0 OR X.TYPRING NBIT 5IOBT GO ERR2    % NOT LEGAL ON THIS DEVICE
112276          IF X.RTRES><RTREF THEN 5; GO ERRF FI      % DEVICE NOT RESERVED
112304          IF D2<0 GO ERR; A-,=:COUN                 % NUMBER TO OUTPUT/MAX NUMBER TO INPUT
112310          *IOF
112311          IF X.TYPRING BIT 5SPLITDF THEN            % TERMINAL/TAD
112314             T:="FLAGB"; CALL XGTDFADDR
112316             IF A BIT 5LSTA THEN TER02; GO ERRF FI  % TERMINAL NOT CONNECTED
112322          FI
112322          T:="DERROR"; CALL XGTDFADDR
112324          IF A><0 THEN                              % ANY ERROR OCCURED ON THIS DEVICE?
112325             A\/140000=:ZAREG                       % YES, SET ERROR CODE
112327             A:=0; T:="DERROR"; CALL XSTDFADDR      % CLEAR ERROR INDICATOR
112332             GO FAR RETU
112333          FI; X:=D1                                 % X=BUFFER ADDR
112334          MLEV; *MST PIE; ION
112337          GO LREG
112340
112340   ERR2:  A:=2
112341   ERRF:  A\/140000; GO FERR
112343   ERR:   A:=-1
112344   FERR:  A=:ZAREG; GO FAR RETU
112346   *)FILL
112356
112356
112356   %========================================================
112356   %      ( R )   C S E T B F W I N D O W
112356   %
112356   CSETBFWINDOW:
112356          AD:=DTDFPHPAGE; A:=:D/\1777+"WNDBF*2000"=:B   % B=DF.ADDR IN WINDOW
112363          A:=142000; T:=0; X:="WNDBF+WNDBF+174000"; *STDTX
112367          A:=D=:RTREF.BUFWINDOW
112372          EXIT
112373
112373   %======================================================
112373   %      ( R )     S T D E
112373   %
112373   % SUBROUTINE TO EXECUTE "STDEV"
112373   STDE:  *IOF; IRW BLEVB DB
112375          "4STDE"; *IRW BLEVB DP
112377          BLEV; *MST PID; COPY SD DA
112402          *ION; EXIT
112404
112404   %=======================================================
112404   %      ( R )     4 S T D E
112404   %
112404   % INBT-OUTB LEVEL
112404   4STDE: *IOF; 2BANK
112406          IF TYPRING BIT 5SPLITDF THEN CALL CSETBFWINDOW FI
112412          CALL STDEV; *ION; WAIT
112415          CALL ERRFATAL
112416   *)FILL
112425
112425   %==================================================
112425   %      ( R )     I O T R
112425   %
112425   % SUBROUTINE TO EXECUTE "IOTRANS"
112425   % RETURN: FULL/EMPTY (RT ONLY)
112425   % SKIPRETURN: OK
112425   IOTR:  A=:D; DYTYFIELD; *IOF; IRW BLEVB DB
112431          "BIOTR"; *IRW BLEVB DP
112433          BLEV; *MST PID; COPY SD DA
112436          IF T:=BACKGROUND><0 THEN L-1 FI
112442          *ION; EXIT
112444
112444   %====================================================
112444   %      ( R )     B I O T R
112444   %
112444   % INBT-OUTBT LEVEL:
112444   BIOTR: *IOF; 2BANK
112446          IF TYPRING BIT 5SPLITDF THEN CALL CSETBFWINDOW FI
112452          *IRR ALEVB DA
112453          CALL IOTRANS; GO WWT; *IRW ALEVB DA
112456          *IRR ALEVB DL; AAA 1
112460          IF T:=BACKGROUND><0 THEN A+1 FI
112464          *IRW ALEVB DL
112465   WBIO:  CALL STDEV
112466          *ION; WAIT
112470          CALL ERRFATAL
112471
112471   WWT:   IF BACKGROUND><0 THEN
112473             X:=RTREF
112474             IF TYPRING BIT 5SPLITDF THEN
112477                TDRADDR; A=:D; D:=:B; CALL WDATA; B:=D
112504             ELSE
112505                CALL WDATA
112506             FI; "STUPR"; *IRW MLEVB DP
112510             MLEV; *MST PID
112512          FI; GO WBIO
112513   *)FILL
112521
112521   %===============================================================
112521   %      ( R )   3 I N S T R
112521   %
112521   % MONITOR CALL INSTR:
112521   3INSTR: CALL GET4
112522          CALL FAR C3OUTX                           % FIND DATAFIELD
112523          A=:X; CALL FAR CHERR                      % CHECK FOR LEGAL DEVICE
112525          OLDPAG=:D
112527          X:=ZAREG; CALL DALTON; X.S1; CALL SINALTPIT
112533          A=:ADR                                    % BUFFER ADDR
112534          OLDPAGE/\3600+"NRPIT+ALEVB+ERNG2"=:USAPITS % PCR WHEN ACCESSING USER'S BUFFER
112540          DO        % UNTIL MAX CHAR IS READ OR UNTIL TERMINATOR CHAR IS FOUND
112540                MIN COUN; GO BYP1; GO OUT1
112543   BYP1:        CALL IOTR; GO WEX1; IF =D3 GO TERM1; A SH 10=:VAL
112552                MIN COUN; GO BYP2; GO OUT2
112555   BYP2:        CALL IOTR; GO WEX2; IF =D3 GO TERM2
112562                T:=VAL+A; ADR=:L
112566                USAPITS=:RTREF.ACTPRI; *TRR PCR
112572                T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112577                A=:RTREF.ACTPRI; *ION
112602                MIN ADR; 0/\0
112604          OD
112605   *)FILL
112616
112616   %EXITS FROM LOOP:
112616   OUT2:  T:=VAL; ADR=:L
112621          USAPITS=:RTREF.ACTPRI; *TRR PCR
112625          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112632          A=:RTREF.ACTPRI; *ION
112635   OUT1:  D2=:ZAREG; GO ACTRET
112640
112640   % BUFFER EMPTY(RT ONLY):
112640   WEX2:  T:=VAL; ADR=:L
112643          USAPITS=:RTREF.ACTPRI; *TRR PCR
112647          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112654          A=:RTREF.ACTPRI; *ION
112657          GO WEXX
112660   WEX1:  IF D2+COUN-1=0 GO WTIO
112664   WEXX:  D2+COUN BONE 17=:ZAREG; GO ACTRET
112671   TERM2: A+VAL; GO TERMX
112673   TERM1: A SH 10
112674   TERMX: T:=A; ADR=:L
112677          USAPITS=:RTREF.ACTPRI; *TRR PCR
112703          T=:L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
112710          A=:RTREF.ACTPRI; *ION
112713          D2+COUN+1 BONE 16=:ZAREG; GO ACTRET
112721
112721   % EXIT WITH ACTIVATION OF DEVICE:
112721   ACTRET: DYTYFIELD; CALL FAR STDE
112723   RETU:  *ION
112724          IF BACKGROUND><0 THEN CALL XBMRET FI
112727          GO RET
112730
112730   WTIO:  MLEV; *IOF; MCL PIE
112733          X:=DYTYFIELD:=:B=:D:=RTREF; CALL WDATA; B=:A:=D
112742          CALL FAR STDE
112743          IF BACKGROUND><0 THEN CALL XBMRET FI
112746          ZPREG-1=:ZPREG; GO RETSTUPR
112752   *)FILL
112762
112762   %============================================================
112762   %      ( R )     3 O U T S T
112762   %
112762   % MONITOR CALL OUTST:
112762   3OUTST: CALL GET3
112763          OLDPAG=:D
112765          X:=ZAREG; CALL DALTON; X.S1; CALL SINALTPIT
112771          A=:ADR                                    % USER'S BUFFER ADDRESS
112772          OLDPAGE/\3600+"NRPIT+ALEVB+ERNG2"=:OUSAPITS % PCR WHEN ACCESSING USER'S BUFFER
112776          CALL FAR C3OUTX                           % FIND LOGICAL DEV.NO
112777          IF D=0 GO FAR ERR2                        % D=ADDR OF OUTPUT DF.
113001          IF D.RTRES><RTREF THEN 5; GO FAR ERRF FI  % DEVICE NOT RESERVED
113010          IF X.TYPRING BIT 5SPLITDF GO OSTERM       % IN MICRO.COMMON (TERM & TAD)
113013          IF BACKGROUND=0 THEN                      % IF RT-PROGRAM
113015             IF D2>>X.MAX GO OUTFULL                % TOO MANY CHAR IN CALL
113021             X=:DYTYFIELD
113022             IF A>>X.CFREE GO WTIO                  % NOT YET ENOUGH SPACE IN BUFFER
113025          FI; CALL FAR CHERR                        % CHECK FOR LEGAL DEVICE
113026          DO                    % UNTIL ALL CHARS ARE IN OUTPUT BUFFER
113026                MIN COUN; GO OBYP1; GO OOUT
113031   OBYP1:       ADR=:L; OUSAPITS=:RTREF.ACTPRI; *TRR PCR
113037                T:=L.S0; "NRPIT+ADPIT+ALEVB+ERNG2"; *IOF; TRR PCR
113044                A=:RTREF.ACTPRI; *ION
113047                MIN ADR; 0/\0; A:=T=:VAL SHZ -10
113054                CALL FAR IOTR; GO OUTFULL; MIN COUN; GO OBYP2; GO OOUT
113061   OBYP2:       VAL/\377; CALL FAR IOTR; GO OUTFULL
113065          OD
113066   % EXITS FROM LOOP:
113066   OOUT:  0=:ZAREG; GO FAR ACTRET
113070   OUTFULL: 100000=:ZAREG; GO RET                   % RT ONLY
113073   RBUS
113115   *"
"113115
113115   %==============================================================================
113115   %      ( R )     I P R I V
113115   %
113115   SUBR IPRIV
113115   INTEGER BREG,NBREG,CAREG
113120   IPRIV: CALL GET0
113121          T:=ZTREG; X:=ZXREG; A:=ZDREG=:D
113125          A:=B=:BREG:=ZAREG=:CAREG:=ZBREG=:B:=CAREG
113134          *EXR ST
113135          A=:CAREG:=B=:NBREG:=BREG=:B
113142          A:=NBREG=:ZBREG:=D=:ZDREG
113146          T=:ZTREG; X=:ZXREG; CAREG=:ZAREG
113152          GO RET
113153
113153   RBUS
113155
113155   *"CAMA
"113155

113155   %=====================================================================
113155   %=====================================================================
113155   %                                                                                        %
113155   %                                                                                        %
113155   %            B U F F E R   P O O L     M O N I T O R   C A L L S     %
113155   %                                                                                        %
113155   %                                                                                        %
113155   %=====================================================================
113155   %=====================================================================
113155
113155
113155
113155
113155
113155
113155   SYMBOL SBMAX=100             % MAX NUMBER OF BUFFERS IN PACKET
113155   %
113155   %============================================================================
113155   %         DATA FIELD DESCRIPTORS
113155   %
113155   %============================================================================
113155   % 35.21      P O O L   H E A D
113155
113155   DISP -1
113155   INTEGER WPVER                % VERIFICATION VALUE OF POOL HEAD
113155   SYMBOL SPCOR=125252          % CORRECT VALUE OF WPVER
113155   INTEGER WFREE                % ADDRESS OF FIRST FREE BUFFER, =0 IF EMPTY
113155   INTEGER WNFRE                % NUMBER OF FREE BUFFERS IN POOL
113155   INTEGER WLLIM                % LOWER ADDRESS OF BUFFER POOL
113155   INTEGER WHLIM                % HIGHER ADDRESS OF BUFFER POOL
113155   INTEGER WBFSZ                % BUFFER SIZE , NO. OF WORDS
113155   PSID
113155
113155
113155   %============================================================================
113155   % 35.22      Q U E U E   H E A D
113155
113155   DISP 0
113155   INTEGER WLPAK                % ADDRESS OF LAST PACKET IN QUEUE
113155                                % EQUAL TO QUEUE HEAD IF QUEUE EMPTY
113155   INTEGER WFPAK                % ADDRESS TO FIRST BUFFER IN QUEUE
113155                                % EQUAL TO QUEUE HEAD IF EMPTY
113155   INTEGER WPNUM                % NUMBER OF PACKETS IN QUEUE
113155   INTEGER WPROC                % ADDRESS OF OWNER OF QUEUE
113155   PSID
113155
113155
113155   %============================================================================
113155   % 35.23      P A C K E T   H E A D
113155
113155   %      2.3.1 GENERAL OFFSETS, PACKET HEAD AND WXX
113155   %            TO BE USED WITHIN GLOB-DEF, ONLY !!!
113155
113155   SYMBOL SLHW=400              % MULTIPLIER FOR LEFT HALFWORD
113155   SYMBOL S1QW=10000            % MULTIPLIER FOR 1 QUARTERWORD
113155   SYMBOL S3QW=20               % MULTIPLIER FOR 3 QUARTERWORD
113155   SYMBOL S1OCT=40000           % MULTIPLIER FOR 1 OCTET
113155   SYMBOL S3OCT=2000            % MULTIPLIER FOR 3 OCTET
113155   SYMBOL S5OCT=100             % MULTIPLIER FOR 5 OCTET
113155   SYMBOL S7OCT=4               % MULTIPLIER FOR 7 OCTET
113155   SYMBOL SRHW=1                % MULTIPLIER FOR RIGHT HALFWORD
113155
113155   %============================================================================
113155   % 35.24      GENERAL FIELDS, PACKET HEAD AND WDW'S
113155   %            TO BE USED WITHIN GLOB-DEF ONLY !!!
113155   %
113155   SYMBOL SRHWMASK=377          % RIGHT HALFWORD MASK
113155   SYMBOL SLHWMASK=-SRHWMASK-1  % LEFT HALFWORD MASK
113155   SYMBOL S1QWMASK=17*S1QW      % 1. QUARTER WORD MASK
113155   SYMBOL S2QWMASK=17*SLHW      % 2. QUARTER WORD MASK
113155   SYMBOL S3QWMASK=17*S3QW      % 3. QUARTER WORD MASK
113155   SYMBOL S4QWMASK=17*SRHW      % 4. QUARTER WORD MASK
113155   SYMBOL C1QWMASK=-S1QWMASK-1
113155   SYMBOL C2QWMASK=-S2QWMASK-1
113155   SYMBOL C3QWMASK=-S3QWMASK-1
113155   SYMBOL C4QWMASK=-S4QWMASK-1
113155   %

113155   %============================================================================
113155   % 35.25      ACTUAL PACKET HEAD LAY-OUT
113155   %
113155   DISP SPDISP=0
113155   INTEGER WNBUF                % ADDRESS OF NEXT BUFFER IN PACKET
113155   INTEGER WNPAK                % ADDRESS OF NEXT PACKET IN QUEUE
113155   INTEGER WPOSS                % ADDRESS OF OWNER OF PACKET
113155   INTEGER WDUM                 % DUMMY
113155   INTEGER WTYP,WSCOM=WTYP                          % WORD FOR MESSAGE TYPE &  FORMAT
113155   INTEGER WBC,WSEQ=WBC                             % WORD FOR BYTE COUNT & SEQUENCE CONTROL
113155   INTEGER WDEA,WPRI=WDEA                           % DESTINATION ADDRESS AND PRIORITY
113155          SYMBOL SPRIMASK=3*S1OCT                   % MSG PRIORITY
113155          SYMBOL CPRIMASK=-SPRIMASK-1
113155          SYMBOL SPRISHIFT=-16
113155          SYMBOL CPRISHIFT=-SPRISHIFT
113155   DOUBLE  WDADR=WDEA                               % BOTH ADDRESSES
113155   INTEGER WSCA                                     % SOURCE ADDRESS
113155   PSID
113155   *)KILL SLHW S1QW S3QW S1OCT S3OCT S5OCT S7OCT SRHW
113155   *)KILL SRHWM SLHWM S1QWM S2QWM S3QWM S4QWM
113155   *)KILL C1QWM C2QWM C3QWM C4QWM
113155

113155
113155
113155   % TIME USED BY SINTRAN ROUTINES:
113155   %      GET0 - 52MICS (10-54)   25MICS (10-S-02)
113155   %      ALTON- 68MICS (10-54)   33MICS (10-S-02)
113155   %      ALTOF- 56MICS (10-54)   26MICS (10-S-02)
113155
113155
113155
113155
113155   %=======     G E T F         170
113155   %
113155   % GET A NUMBER OF BUFFERS FROM FREE POOL
113155   % SET RT-PROG ADDRESS IN WPOSS-WORD OF EACH BUFFER
113155   %
113155   % GETF:      GET PARAMETERS(POOLHEAD,NO-OF-BUFFERS-REQUIRED)
113155   %            IF FALSE POOLHEAD OR ILLEGAL NO-OF-BUFFERS-REQUIRED THEN
113155   %                            NON-SKIP-RETURN(-1)
113155   %            ENDIF
113155   %            IF POOLHEAD.WNFRE<NO-OF-BUFFERS-REQUIRED THEN
113155   %                NON-SKIP-RETURN(0)
113155   %            ENDIF
113155   %            POOLHEAD WFREE=:FIRST-BUFFER=:BUFFER
113155   %            FOR COUNT:=2 TO NO-OF-BUFFERS-REQUIRED DO
113155   %                RTREF=:BUFFER.WPOSS; 0=:BUFFER.WNPAK
113155   %                BUFFER.WNBUF=:BUFFER
113155   %            ENDDO
113155   %            BUFFER.WNBUF=:POOLHEAD.WFREE
113155   %            0=:BUFFER.WNBUF
113155   %            POOLHEAD.WNFRE - NO-OF-BUFFERS-REQUIRED=:POOLHEAD.WNFRE
113155   %            SKIP-RETURN(FIRST-BUFFER)
113155   % ENTRY:     X - ADDRESS OF POOL HEAD
113155   %            A - NUMBER OF BUFFERS WANTED
113155   % EXIT:
113155   %      NON-SKIP              A=-4                POOL DESTROYED
113155   %                            A=-1                ILLEGAL PARAMETER VALUE
113155   %                            A=0                 NOT ENOUGH FREE BUFFERS
113155   %      SKIP                  A = ADDRESS OF FIRST BUFFER IN CHAIN
113155   % TIME USED: 326 MICS + 41.5 MICS*N (10-54)      N=NO. OF BUFFERS
113155   %            159 MICS + 20 MICS * N (10-S-02)
113155   %
113155
113155   %============================================================================
113155   % 35.30      U S O X
113155   %
113155   SUBR US0X
113155   INTEGER NUM                  % NUMBER OF BUFFERS REQUIRED
113156   INTEGER LVAR                 % LOCAL VARIABLE
113157   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113160   INTEGER NPOLH                % ADDRESS OF POOL HEAD
113161   INTEGER LLIM                 % LOWER LIMIT OF BUFFER POOL
113162   INTEGER HLIM                 % HIGHER LIMIT OF BUFFER POOL
113163   US0X:  CALL GET0; ZAREG=:NUM; ZXREG=:NPOLH
113170          RTREF=:ICURT
113172          OLDPAG=:D
113174          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113175          NPOLH.WHLIM=:HLIM; X.WLLIM=:LLIM          % SAVE BUFFER POOL LIMITS
113202          IF NPOLH.WPVER><SPCOR OR NUM<=0 OR A>SBMAX THEN A:=-1; GO NSKIP FI
113217          IF X.WNFRE-NUM<0 THEN A:=0; GO NONSK FI   % TOO FEW BUFFERS LEFT
113224          A=:X.WNFRE                                % UPDATE NUMBER OF FREE BUFFERS LEFT
113225          1=:D
113227          A:=X.WFREE=:LVAR                             % FIRST FREE BUFFER
113231          FOR D TO NUM DO
113234            IF A=:X-LLIM<<0 OR HLIM-,+X>>=0 THEN A:=-4; GO NONSK FI
113247            IF X.WNPAK><X THEN A:=-4; GO NONSK ELSE 0=:X.WNPAK FI
113255            ICURT=:X.WPOSS; A:=X.WNBUF
113260          OD
113262          0=:X.WNBUF
113263          A=:NPOLH.WFREE
113265          CALL ALTOFF; LVAR=:ZAREG; MIN ZPREG; 0/\0; GO RET
113273   NONSK:
113273   NSKIP: A=:LVAR
113274          CALL ALTOFF; LVAR=:ZAREG; GO RET; *US0=US0X
113300   RBUS
113306
113306
113306
113306
113306
113306
113306
113306   %========    P U T F         171
113306   %
113306   % RETURN A CHAIN OF BUFFERS TO FREE POOL. ALL BUFFERS MUST CONTAIN
113306   % ADDRESS OF CURRENT RT-PROGRAM IN WPOSS-WORD, AND ZERO IN
113306   % WNPAK-WORD. LAST BUFFER MUST HAVE ZERO IN WNBUF-WORD.
113306   % IT IS CHECKED THAT NUMBER OF BUFFERS DOES NOT EXCEED MAX ALLOWED
113306   % NUMBER. THIS PREVENTS INFINITE LOOP.
113306   %
113306   % PUTF:      GET PARAMETERS(POOLHEAD,PACKET)
113306   %            IF FALSE POOLHEAD OR ILLEGAL PACKET THEN NON-SKIP-RETURN(-1) ENDIF
113306   %            IF ANY-BUF-OF-PACKET.WPOSS><CURR-RT-PROG OR PACKET.WNPAK><0 THEN
113306   %                NON-SKIP-RETURN(0)
113306   %            ENDIF
113306   %            POOLHEAD.WFREE=:LAST-BUFFER-OF-PACKET.WNBUF
113306   %            PACKET=:POLLHEAD.WFREE
113306   %            0=:ALL-PACKET-BUFFERS.WPOSS
113306   %            POOLHEAD.WNFRE+NO-OF-NUFFERS-IN-PACKET=:POOLHEAD.WNFRE
113306   %            SKIP-RETURN
113306   %
113306   %
113306   % ENTRY:     X - ADDRESS OF POOL HEAD
113306   %            A - ADDRESS OF FIRST BUFFER IN CHAIN
113306   % EXIT:
113306   %                            A=-3                TOO LONG CHAIN, DISORDER ?
113306   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM
113306   %                                                OR PACKET BELONGS TO QUEUE
113306   %                            A=-1                ILLEGAL PARAMETER VALUE
113306   %      SKIP                  BUFFER CHAIN PUT IN POOL OK
113306   % TIME USED: 320 MICS + 52 MICS * N (10-54)      N=NO OF BUFFERS IN PACKET
113306   %            154 MICS + 24 MICS * N (10-S-02)
113306
113306   %============================================================================
113306   % 35.31      U S 1 X
113306   %
113306   SUBR US1X
113306   INTEGER IPACK                % ADDRESS OF PACKET TO RELEASE
113307   INTEGER LVAR                 % LOCAL VARIABLE
113310   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113311   INTEGER NPOLH                % ADDRESS OF POOL HEAD
113312   INTEGER LLIM                 % LOWER LIMIT OF BUUFER POOL
113313   INTEGER HLIM                 % HIGHER LIMIT OF BUFFER POOL
113314   US1X:  CALL GET0; ZAREG=:IPACK; ZXREG=:NPOLH
113321          RTREF=:ICURT
113323          OLDPAG=:D
113325          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113326          NPOLH.WLLIM=:LLIM; X.WHLIM=:HLIM
113333          IF NPOLH.WPVER><SPCOR THEN A:=-1; GO NSKIP FI
113342          IF IPACK.WNPAK><0 THEN A:=-2; GO NSKIP FI
113347          1=:D; IPACK=:LVAR     % CHECK BUFFER CHAIN
113353          FOR D TO SBMAX DO
113356            LVAR=:LVAR.WNPAK
113361            IF A=:T-LLIM<<0 OR HLIM-,+T>>=0 THEN A:=-1; GO NSKIP FI
113374            IF LVAR.WPOSS-ICURT><0 THEN A:=-2; GO NSKIP
113402            ELSE 0=:X.WPOSS; FI
113404            IF LVAR.WNBUF=:LVAR=0 GO PEND
113410          OD
113412          A:=-3; GO NSKIP
113414   PEND:  X=:T
113415          NPOLH.WFREE=:T.WNBUF
113421          IPACK=:NPOLH.WFREE
113424          NPOLH.WNFRE+D=:X.WNFRE
113430          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113434   NSKIP: A=:LVAR
113435          CALL ALTOFF; LVAR=:ZAREG; GO RET; *US1=US1X
113441   RBUS
113447
113447
113447
113447
113447
113447   %========   G E T Q          172
113447   %
113447   % GET A PACKET FROM START OF QUEUE
113447   % SET RT-PROG ADDRESS IN WPOSS-WORD OF EACH BUFFER
113447   %
113447   % GETQ:      GET PARAMETER(QUEUEHEAD)
113447   %            IF ILLEGAL QUEUE HEAD THEN NON-SKIP-RETURN(-1) ENDIF
113447   %            IF QUEUE EMPTY THEN NON-SKIP-RETURN(0) ENDIF
113447   %            QUEUEHEAD.WFPAK=:PACKET
113447   %            PACKET.WNPAK=:QUEUEHEAD.WFPAK
113447   %            QUEUEHEAD.WPNUM - 1
113447   %            0=:PACKET.WNPAK
113447   %            QUEUEHEAD.WPROC=:ALL-BUFFERS-OF-PACKET.WPOSS
113447   %            SKIP-RETURN(PACKET)
113447   %
113447   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113447   % EXIT:
113447   %      NON-SKIP              A=-1                ILLEGAL PARAMETER VALUE
113447   %                            A=0                 QUEUE EMPTY
113447   %      SKIP                  A = ADDRESS OF PACKET
113447   % TIME USED: 281 MICS (10-54)                    134 MICS (10-S-02)
113447
113447   %============================================================================
113447   % 35.32      U S X 2
113447   %
113447   SUBR US2X
113447   INTEGER IPACK                % ADDRESS OF FETCHED PACKET
113450   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113451   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113452   US2X:  CALL GET0; ZXREG=:IQH; RTREF=:ICURT
113457          OLDPAG=:D
113461          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113462   GQCOM: IF IQH.WPROC><ICURT THEN A:=-1; GO NSKIP FI
113471          IF X.WPNUM=0 THEN GO NSKIP FI
113474          A:=X.WFPAK=:IPACK
113476          IF A.WNPAK=IQH THEN IQH=:IQH.WLPAK FI
113506          A=:IQH.WFPAK; X.WPNUM-1=:X.WPNUM
113513          A:=IQH.WPROC; X:=IPACK
113516          DO WHILE X><0
113517            A=:X.WPOSS; 0=:X.WNPAK; X:=X.WNBUF
113522          OD
113523          CALL ALTOFF; IPACK=:ZAREG; MIN ZPREG; 0/\0; GO RET
113531   NSKIP: A=:IPACK
113532          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US2=US2X
113536   RBUS
113543
113543
113543
113543
113543
113543
113543
113543
113543   %========    P U T Q         173
113543   %
113543   % PUT A PACKET AT END OF QUEUE. WPOSS-WORD MUST CONTAIN ADDRESS
113543   % OF CALLING RT-PROGRAM. WNPAK-WORD MUST BE ZERO.
113543   %
113543   % PUTQ:      GET PARAMETER(QUEUEHEAD,PACKET)
113543   %            IF PACKET.WPOSS><CURR-RT-PROG THEN NON-SKIP-RETURN(-2) ENDIF
113543   %            IF PACKET.WNPAK><0 THEN NON-SKIP-RETURN(0) ENDIF
113543   %            QUEUEHEAD.WLPAK=:PACKET.WNPAK
113543   %            PACKET=:QUEUEHEAD.WLPAK
113543   %            DO WHILE PACKET><0
113543   %                0=:PACKET.WPOSS; PACKET.WNPAK=:PACKET
113543   %            ENDDO
113543   %            QUEUEHEAD.WPNUM + 1
113543   %            SKIP-RETURN
113543   %
113543   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113543   %            A - ADDRESS OF PACKET
113543   % EXIT:
113543   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM OR
113543   %                                                PACKET BELONGS TO QUEUE
113543   %      SKIP                  PACKET PUT IN QUEUE
113543   % TIME USED:
113543   %      PUTQ: 320 MICS (NORD-10)                  165 MICS (10-S)
113543
113543   %============================================================================
113543   % 35.33      U S X 3
113543   %
113543   SUBR US3X
113543   INTEGER IPACK                % ADDRESS OF PACKET TO PUT IN QUEUE
113544   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113545   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113546   US3X:  CALL GET0; ZAREG=:IPACK; ZXREG=:IQH
113553          RTREF=:ICURT
113555          OLDPAG=:D
113557          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113560          IF IPACK.WPOSS><ICURT OR X.WNPAK><0  THEN A:=-2; GO NSKIP FI
113571          T:=IQH.WLPAK; IPACK=:X.WLPAK; MIN X.WPNUM; A=:T.WNPAK
113600          IQH=:IPACK.WNPAK
113603          X:=IPACK
113604          DO WHILE X><0
113605            0=:X.WPOSS; X:=X.WNBUF
113607          OD
113610          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113614   NSKIP: A=:IPACK
113615          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US3=US3X
113621   RBUS
113626
113626
113626
113626
113626
113626
113626   %========    P R I Q         174
113626   %
113626   % PUT A PACKET IN QUEUE ACCORDING TO PRIORITY, I.E. PACKET IS INSERTED
113626   % AFTER LAST PACKET IN QUEUE WITH EQUAL OR HIGHER PRIORITY.
113626   % PRIORITY VALUE IS FOUND IN PACKET HEAD, WORD AND BITS DEFINED AT SYSTEM
113626   % GENERATION.
113626   % WPOSS-WORD MUST CONTAIN ADDRESS OF CALLING RT-PROGRAM. WNPAK-WORD
113626   % MUST BE ZERO.
113626   %
113626   % PRIQ:      GET PARAMETER(QUEUEHEAD,PACKET)
113626   %            IF ANY-BUF-OF-PACKET.WPOSS><CURR-RT-PROG OR PACKET.WNPAK><0 THEN
113626   %                NON-SKIP-RETURN(-2)
113626   %            ENDIF
113626   %            IF PACKET.PRIOR=0 THEN
113626   %                QUEUEHEAD.WLPAK=:LASTPACKET; QUEUEHEAD=:QPACK
113626   %                GO INSERT
113626   %            ENDIF
113626   %            QUEUEHEAD.WFPAK=:QPACK
113626   %            DO WHILE QPACK><QUEUEHEAD AND QPACK.PRIOR>=PACKET.PRIOR
113626   %                QPACK=:LASTPACKET; QPACK.WNPAK=:QPACK
113626   %            ENDDO
113626   % INSERT:    QPACK=:PACKET.WNPAK; PACKET=:LASTPACKET.WNPAK
113626   %            QUEUEHEAD.WPNUM + 1
113626   %            DO WHILE PACKET><0
113626   %                0=:PACKET.WPOSS; PACKET.WNPAK=:PACKET
113626   %            ENDDO
113626   %            SKIP-RETURN
113626   %
113626   % ENTRY:     X - ADDRESS OF QUEUE HEAD
113626   %            A - ADDRESS OF PACKET
113626   % EXIT:
113626   %      NON-SKIP              A=-2                PACKET NOT WPOSSESSED BY PROGRAM OR
113626   %                                                PACKET BELONGS TO QUEUE
113626   %      SKIP                  PACKET INSERTED IN QUEUE
113626   % TIME USED:
113626   %      PRIQ: PRIOR 0         330 MICS (NORD-10)  170 MICS (10-S)
113626   %                  ><0       320+33*N (NORD-10)  165+15*N (10-S)
113626   %                  ><0       130+33*N (NORD-10)   65+15*N (10-S)
113626   %                            N=NO OF PACKETS AHEAD IN QUEUE+1
113626
113626   %============================================================================
113626   % 35.34      U S X 4
113626   %
113626   SUBR US4X
113626   INTEGER IPACK                % ADDRESS OF PACKET TO SEND
113627   INTEGER ICURT                % ADDRESS OF CURRENT RT-PROG DESCRIPTION
113630   INTEGER IQH                  % ADDRESS OF QUEUE HEAD
113631   INTEGER IPRI                 % PRIORITY OF PACKET
113632   US4X:  CALL GET0; ZAREG=:IPACK; ZXREG=:IQH
113637          RTREF=:ICURT
113641          OLDPAG=:D
113643          CALL DALTON            % ACCESS ALTERNATIVE PAGE TABLE
113644          IF IPACK.WPOSS><ICURT OR X.WNPAK><0 THEN A:=-2; GO NSKIP FI
113655          X.WPRI/\SPRIMASK=:IPRI
113660          X:=IQH=:D
113662          IF IPRI=0 THEN X.WLPAK=:D; GO DIPUT FI
113667          DO WHILE X.WNPAK><IQH AND A.WPRI/\SPRIMASK-IPRI>>=0
113701            X:=D.WNPAK=:D
113704          OD
113705   DIPUT: T:=D.WNPAK; IPACK=:X.WNPAK; T=:A.WNPAK
113713          IF A:=T=IQH THEN IPACK=:IQH.WLPAK FI
113722          MIN IQH.WPNUM
113724          X:=IPACK
113725          DO WHILE X><0
113726            0=:X.WPOSS; X:=X.WNBUF
113730          OD
113731          CALL ALTOFF; MIN ZPREG; 0/\0; GO RET
113735   NSKIP: A=:IPACK
113736          CALL ALTOFF; IPACK=:ZAREG; GO RET; *US4=US4X
113742   RBUS
113750
113750
113750   *"7NDDI
"113750
113750
113750   @DEV 1
