115561   @DEV (S-S-L)RP-P2-TAD:NPL
115561   *"BADAD
"115561

115561   %%%%%%%%%%%%%%%%%%%%%%%%%%%%% RP-P2-TAD %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
115561
115561   %==============================================================================
115561   %       B U F F E R   P O O L   R O U T I N E S
115561   %==============================================================================
115561   %
115561   % (R)   P U T P O O L              (ROUTINE IS DUPLICATED ON MPIT)
115561   %
115561   % ROUTINE TO PUT A BUFFER IN FREE POOL OF OUTPUT DATAFIELD
115561   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
115561   % ENTRY:    AD-REG - BUFFER-ADDRESS
115561   %            X-REG - BUFFER ID
115561   %            B-REG - TAD OUTPUT DATAFIELD
115561   SUBR PUTPOOL
115561   INTEGER XREG
115562   PUTPOOL: *IOF
115563          IF X=0 GO RETU; X=:XREG                   % DUMMY CALL
115565          A=:T; D=:X; AD:=POOLLI; *STDTX            % PUT OLD POOLLI IN NEW BUFFER
115571          X+2; A:=XREG; *STATX                      % PUT BUFFID IN NEW BUFFER
115574          T=:A; X-2=:D; AD=:POOLLI                  % PUT NEW BUFFER IN POOLLI
115600   RETU:  *ION; EXIT
115602   RBUS
115602
115602   %==============================================================================
115602   % (R)   G E T P O O L              (ROUTINE IS DUPLICATED ON MPIT)
115602   %
115602   % ROUTINE TO GET A BUFFER FROM FREE-POOL
115602   % THE ROUTINE EXECUTES IN IOF TO AVOID DOUBLE ACCESSES TO THE POOL
115602   % ENTRY:       B-REG - TAD OUTPUT DATAFIELD
115602   % SKIP RETURN: OK
115602   %              FOLLOWING VARIABLES IN OUTPUT DATAFIELD IS MODIFIED:
115602   %              BUFFID
115602   %              TDTADD
115602   %              TDBTPT
115602   %              REMSIZ
115602   %
115602   % RETURN:      ERROR   A-REG < 0 XMSG ERROR , ELSE POOL EMPTY
115602
115602   SUBR GETPOOL
115602   GETPOOL: *IOF
115603          IF BUFFID=0 THEN
115605             POOLLI; IF A=0 AND D=0 GO NOPOL           % POOL EMPTY
115611             A=:T; D=:X; *LDDTX                        % GET NEXT IN CHAIN
115614             AD=:POOLLI                                % UPDATE POOL POINTER
115615             T=:A; X=:D; *STZTX                        % ENSURE REF&FUNC IS ZERO
115620             AD=:TDTADD; X+2; *LDATX                   % SAVE ADDRESS AND GET BUFFID
115623             A=:BUFFID; BUDIS=:TDBTPT                  % SET BUFFID AND BYTE POINTER
115626             41ITAD.FBSIZ-BUDIS=:REMSIZ                % SET REMAINING SIZE
115632          FI; *ION
115633          EXITA
115634   NOPOL: AD=:TDTADD; 0=:BUFFID=:REMSIZ=:TDBTPT; *ION; EXIT
115642   RBUS
115643
115643   %==============================================================================
115643   % (R)   M O V I T O                (ROUTINE IS DUPLICATED ON MPIT)
115643   %
115643   % ROUTINE TO RELOCATE INPUT BUFFER AS OUTPUT BUFFER
115643   % ENTRY:       B-REG - OUTPUT-DATAFIELD
115643   SUBR MOVITO
115643   MOVITO: 41ITAD.BUFFID=:BUFFID; X.TDTADD=:TDTADD
115650           X.FBSIZ-BUDIS=:REMSIZ; BUDIS=:TDBTPT; 0=:CURMES
115656           A:=0=:D; AD=:X.TDTADD
115661           0=:X.BUFFID=:X.REMBYT=:X.TDBTPT=:X.REMSIZ=:X.CURMES
115666           EXIT
115667   RBUS
115670

115670   %==============================================================================
115670   %       R O U T I N E S   T O   A C T I V A T E   D R I V E R
115670   %==============================================================================
115670   %
115670   % (R)   S N D B U F   S N D W T
115670   %
115670   % ROUTINES TO SEND OUTPUT BUFFER,
115670   % ALWAYS CALLED WITH MONITOR LEVEL DISABLED
115670   % IF SNDWT, PROCESS IS SET IN IO-WAIT
115670   % ENTRY:     B-REG - TAD OUTPUT DATAFIELD
115670   %            A-REG - RESPONSE NO. IF SNDWT
115670   SUBR SNDBUF,SNDWT
115670   SNDWT: *IOF
115671          A=:RSPNUM; 1=:MTOR
115674          RTREF.STATUS BONE 5WAIT=:X.STATUS
115700   SNDBUF:*IOF
115701          IF BUFFID><0 THEN
115703             IF REMSIZ><41ITAD.FBSIZ-4 THEN     % SOMETHING IN OUTPUT BUFFER?
115711                TDRADDR; *IRW LV10B DB          % B = TAD RESIDENT OUTPUT DATAFIELD
115713                "BDROUT"; *IRW LV10B DP         % P = DRIVER OUTPUT ROUTINE
115715                LV10; *MST PID
115717             FI
115717          FI; *ION
115720          EXITA
115721   RBUS
115726
115726   %==============================================================================
115726   % (R)   C B R E R S P
115726   %
115726   % IF TAD, ROUTINE ACTIVATES DRIVER TO SEND ESCAPE-RESPONSE
115726   % ENTRY: B-REG - INPUT-DATAFIELD (OUTSIDE RESIDENT)
115726   % CALLED WITH INTERRUPT OFF
115726   % RETURN EXIT AD1
115726   SUBR CBRERSP
115726   CBRERSP: IF TYPRING NBIT 5BAD THEN EXITA FI
115732           TDRADDR; *IRW LV10B DB     % B = TAD RESIDENT INPUT DATAFIELD
115734           "BERESP"; *IRW LV10B DP    % P = DRIVER ESCAPE-RESPONSE
115736           LV10; *MST PID
115740           EXITA
115741   RBUS
115743
115743   %==============================================================================
115743   % (R)   B D T O U
115743   %
115743   % NORMAL OUTPUT TIMEOUT ROUTINE FOR TAD, CALLED WITH INTERUPT OFF
115743   % ROUTINE SENDS OUTPUT BUFFER AT TIMEOUT
115743   % B = TAD OUTPUT DATAFIELD
115743   SUBR BDTOU
115743   INTEGER POINTER LREG
115744   BDTOU: A:=L=:"LREG"; MLEV; *MCL PIE; ION
115751          CALL BOSTAD; CALL SNDBUF; 0/\0; TTMR=:TMR
115756          MLEV; *IOF; MST PIE
115761          GO LREG
115762   RBUS
115764
115764   %==============================================================================
115764   % (R)  M T D T O U
115764   %
115764   % SPECIAL OUTPUT TIMEOUT ROUTINE FOR TADS WHEN MAIL SYSTEM
115764   % SENDS MESSAGES.
115764   % B = TAD OUTPUT DATAFIELD
115764   SUBR MTDTOU
115764   INTEGER POINTER LREG
115765   MTDTOU: A:=L=:"LREG"; MLEV; *MCL PIE; ION
115772          CALL BOSTAD
115773          IF 41ITAD.PORTNO=0 GO RETU               % NOT CONNECTED ANYMORE
115776          AD:=POOLLI
115777          IF A=0 AND D=0 THEN                       % BUFFER POOL EMPTY
116002             IF BUFFID=0 AND X.BUFFID=0 THEN        % NO BUFFERS IN TAD AT ALL
116006                IF BRCOUNT=0 GO NBACT               % C-T DOES NOT RETURN BUFFERS
116010             FI
116010          FI
116010          "MSNDBUF"; GO CONT                        % SEND MAIL BUFFER DRIVER ROUTINE
116012   NBACT: "MRELBUF"                                 % RELEASE MAIL BUFFER DRIVER ROUTINE
116013   CONT:  *IOF; IRW LV10B DP                        % DRIVER FUNCTION
116015          TDRADDR; *IRW LV10B DB                    % B-REG TAD OUTPUT RES DATAFIELD
116017          LV10; *MST PID; ION                       % SET LEVEL 10
116022   RETU:  "BDTOU"=:"TMSUB"                          % RESET NORMAL TIMEOUT ROUTINE
116024          MLEV; *IOF; MST PIE
116027          GO LREG
116030   RBUS
116036
116036

116036   %==============================================================================
116036   %       M E S S A G E   H E A D E R S   R O U T I N E S
116036   %==============================================================================
116036   %
116036   % (R)  W R M H E A D
116036   %
116036   % ROUTINE TO WRITE MESSAGE HEADER ON EVEN BYTE
116036   %      ENTRY:   A-REG - MESSAGE HEADER
116036   %               B-REG - TAD OUTPUT DATAFIELD
116036   %      RETURN:  EXIT
116036   %
116036   SUBR WRMHEAD
116036   WRMHEAD: A=:D; T:=TDTAFI; X:=TDTALA
116041          IF TDBTPT BIT "0" THEN                    % ODD START, CREATE PAD BYTE
116044             A SHZ -1; X+A; *LDATX
116047             A/\177400; *STATX
116051             MIN TDBTPT; REMSIZ-1=:REMSIZ
116055          FI
116055          X:=TDTALA
116056          TDBTPT SHZ -1; X+A; D=:A; *STATX                    % WRITE IN BUFFER
116063          TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ
116071          EXIT
116072   RBUS
116073
116073   %==============================================================================
116073   % (R)   C R E M E S
116073   %
116073   % ROUTINES TO CREATE MESSAGE-HEADERS IN XMSG BUFFER  (TAD OUTPUT)
116073   %
116073   % ENTRY:     A-REG - MESSAGE TYPE
116073   %            T-REG - REQUIRED I-FIELD SIZE
116073   %            B-REG - TAD OUTPUT DATAFIELD
116073   %
116073   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116073   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116073   %
116073   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116073   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116073   %                                 A-REG: <0  XMSG ERROR CODE
116073   %
116073   SUBR CREMES
116073   INTEGER AREG,TREG; INTEGER POINTER LREG
116076   CREMES: A=:AREG:=L=:"LREG"; T=:TREG
116102          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116106          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116107          IF TDBTPT BIT "0" THEN T+3 ELSE T+2 FI              % ODD OR EVEN START IN BUFFER
116115          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116122          AREG SHZ 10; CALL WRMHEAD                           % WRITE MESSAGE HEADER
116125          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116132          MIN "LREG"; GO LREG
116134   NOPOL: A:=1; GO LREG
116136   RBUS
116140
116140   %==============================================================================
116140   % (R)   G E T M E S                (ROUTINE IS DUPLICATED ON MPIT)
116140   %
116140   % ROUTINE TO FIND NEXT MESSAGE HEADER IN XMSG BUFFER  (TAD INPUT)
116140   % ENTRY:     B-REG - TAD INPUT DATAFIELD
116140   %
116140   % RETURN:    SKIP-RETURN:  OK     A-REG:  MESSAGE-TYPE
116140   %                                 T-REG:  NUMBER OF BYTES IN I-FIELD
116140   %                                 TAD DATAFIELD BUFFER VARIABLES
116140   %                                 REMSIZ,TDBTPT,CURMES,REMBYT ARE UPDATED
116140   %
116140   %            NOSKIP:       ERROR  A-REG:  1  NO INPUT BUFFER
116140   %                                 A-REG:  2  BUFFER IS EMPTY
116140   %                                 A-REG:  3  INCONSISTENCY, MESSAGE BIGGER THAN BUFFER
116140   SUBR GETMES
116140   GETMES: IF BUFFID=0 THEN A:=1; EXIT FI                     % NO BUFFER
116144   TSTSP:  IF REMSIZ<2 THEN T=:A; EXIT FI
116152           T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1
116157           X+A; *LDATX
116161           MIN TDBTPT
116162           IF D BIT "0" THEN                                  % ODD BYTE
116164              IF A/\377=0 THEN REMSIZ-1=:REMSIZ; GO TSTSP FI  % FIRST BYTE FOUND
116172              A=:CURMES; X+1; *LDATX
116175              A SHZ -10; MIN TDBTPT; GO RCHK                  % RETURN AND CHECK
116200           FI
116200           A=:T SHZ -10
116202           IF A=0 THEN
116203              REMSIZ-1=:REMSIZ; GO TSTSP                      % PAD BYTE
116207           FI
116207           A=:CURMES:=T/\377; MIN TDBTPT
116213   RCHK:   IF A>REMSIZ-2 THEN A:=3; EXIT FI                   % INCONSISTENT MESSAGE
116221           A=:T+1-=:REMBYT; X:=REMSIZ-2=:REMSIZ
116230           A:=CURMES; EXITA                                   % MESSAGE FOUND
116232   RBUS
116233
116233   %==============================================================================
116233   % (R)   C R H E E V
116233   %
116233   % ROUTINE LIKE CREMES BUT BYTE COUNTER IS ALSO WRITTEN
116233   % USED WHEN MESSAGE IS COMPLETED BY CALLING ROUTINE
116233   % MESSAGE HEADER IS CREATED ON EVEN BYTE
116233   %
116233   % ENTRY:     A-REG - MESSAGE TYPE
116233   %            T-REG - REQUIRED I-FIELD SIZE
116233   %            B-REG - TAD OUTPUT DATAFIELD
116233   %
116233   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116233   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116233   %
116233   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116233   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116233   %
116233   SUBR CRHEEV
116233   INTEGER AREG,TREG; INTEGER POINTER LREG
116236   CRHEEV: A=:AREG:=L=:"LREG"; T=:TREG
116242          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116246          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116247          IF TDBTPT BIT "0" THEN T+3 ELSE T+2 FI              % ODD OR EVEN START IN BUFFER
116255          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116262          AREG SHZ 10+TREG; CALL WRMHEAD                      % WRITE MESSAGE HEADER
116266          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116273          MIN "LREG" GO LREG
116275   NOPOL: A:=1; GO LREG
116277   RBUS
116301
116301   %==============================================================================
116301   % (R)   C R H E O D
116301   %
116301   % ROUTINE LIKE CREMES BUT BYTE COUNTER IS ALSO WRITTEN
116301   % USED WHEN MESSAGE IS COMPLETED BY CALLING ROUTINE
116301   % MESSAGE HEADER IS CREATED ON ODD BYTE
116301   %
116301   % ENTRY:     A-REG - MESSAGE TYPE
116301   %            T-REG - REQUIRED I-FIELD SIZE
116301   %            B-REG - TAD OUTPUT DATAFIELD
116301   %
116301   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116301   %                                 REMSIZ,CURMES,NOBDIS ARE UPDATED
116301   %
116301   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116301   %                                 A-REG:  2  OUTPUT-BUFFER FULL
116301   %
116301   SUBR CRHEOD
116301   INTEGER AREG,TREG; INTEGER POINTER LREG
116304   CRHEOD: A=:AREG:=L=:"LREG"; T=:TREG
116310          IF BUFFID=0 THEN CALL GETPOOL; GO NOPOL FI          % NO BUFFER
116314          T:=TREG                                             % GET REQUIRED IFIELD SIZE
116315          IF TDBTPT NBIT "0" THEN T+3 ELSE T+2 FI             % ODD OR EVEN START IN BUFFER
116323          IF REMSIZ<T THEN A:=2; GO LREG FI                   % NOT ENOUGH SPACE
116330          IF TDBTPT NBIT "0" THEN A:=0; CALL STORBYT FI       % EVEN START, CREATE PAD BYTE
116335          AREG; CALL STORBYT; TREG; CALL STORBYT              % WRITE TYPE AND BYTE COUNTER
116341          TDBTPT-1=:NOBDIS; AREG=:CURMES                      % UPDATE MESSAGE INFO
116346          MIN "LREG"; GO LREG
116350   NOPOL: A:=1; GO LREG
116352   RBUS
116354
116354
116354   %==============================================================================
116354   % (R)   U P D M B C
116354   %
116354   % ROUTINE TO UPDATE MESSAGE BYTE COUNT
116354   % ENTRY:       A-REG - NUMBER OF BYTES
116354   %              B-REG - TAD OUTPUT DATAFIELD
116354   % SKIP RETURN: OK
116354   % RETURN:      NOT ENOUGH SPACE
116354   SUBR UPDMBC
116354   UPDMBC: A=:D; T:=TDTAFI; X:=TDTALA
116357          IF NOBDIS BIT "0" THEN                    % BYTE COUNT ON ODD BYTE
116362             A SHZ -1; X+A; *LDATX                  % READ BYTE COUNT
116365             A=:T; A/\177400; A:=:T; A/\377
116371             A+D; T=:D; IF A>=400 THEN EXIT FI      % MESSAGE FULL?
116377             A\/D
116400          ELSE                                      % BYTE COUNT ON EVEN BYTE
116401             A SHZ -1; X+A; *LDATX                  % READ BYTE COUNT
116404             A=:T; A/\377; A:=:T; A SHZ -10
116410             A+D; T=:D; IF A>=400 THEN EXIT FI      % MESSAGE FULL?
116416             A SHZ 10; A\/D
116420          FI
116420          T:=TDTAFI; *STATX                         % WRITE BACK BYTE COUNT
116422          EXITA
116423   RBUS
116426

116426   %==============================================================================
116426   %       R O U T I N E S   T O   A C C E S S   D A T A   P A R T
116426   %==============================================================================
116426   %
116426   % (R)   G E T M B C
116426   %
116426   % ROUTINE TO FIND NUMBER OF BYTES IN CURRENT OUTPUT MESSAGE
116426   %
116426   % ENTRY:     B-REG - TAD OUTPUT DATAFIELD
116426   % RETURN:    A-REG - BYTE COUNT
116426   SUBR GETMBC
116426   GETMBC: IF NOBDIS=0 THEN A:=400; EXIT FI
116432           A=:D SHZ -1; T:=TDTAFI; X:=TDTALA; X+A; *LDATX
116440           IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI
116445           EXIT
116446   RBUS
116450
116450   %==============================================================================
116450   % (R)   B Y T P U T
116450   %
116450   % ROUTINE TO PUT A BYTE IN XMSG BUFFER  (TAD OUTPUT)
116450   %
116450   % ENTRY:     A-REG - BYTE
116450   %            B-REG - TAD OUTPUT DATAFIELD
116450   %
116450   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116450   %                                 REMSIZ AND TDBTPT IS UPDATED
116450   %
116450   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116450   %                                 A-REG:  2  OUTPUT BUFFER FULL
116450   %                                 A-REG:  3  MESSAGE FULL
116450   SUBR BYTPUT
116450   INTEGER AREG; INTEGER POINTER LREG
116452   BYTPUT: A/\377=:AREG:=L=:"LREG"
116456          IF BUFFID=0 THEN A:=1; EXIT FI               % OUTPUT BUFFER PRESENT?
116462          IF REMSIZ<=0 THEN A:=2; EXIT FI              % BUFFER FULL?
116467          A:=1; CALL UPDMBC; GO MSFUL                  % UPDATE MESSAGE BYTE COUNT
116472          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116500          IF D BIT "0" THEN                            % DESTINATION ODD BYTE
116502             *LDATX
116503             A/\177400\/AREG
116505          ELSE                                         % DESTINATION EVEN BYTE
116506             AREG SHZ 10
116510          FI
116510          T:=TDTAFI; *STATX                         % PUT BYTE IN BUFFER
116512          REMSIZ-1=:REMSIZ; MIN TDBTPT
116516          MIN "LREG"; GO LREG                       % UPDATE BUFFER COUNTERS AND RETURN
116520   MSFUL: A:=3; GO LREG                             % MESSAGE IS FULL
116522   RBUS
116525
116525   %==============================================================================
116525   % (R)   W O R D P U T
116525   %
116525   % ROUTINE TO PUT A WORD IN XMSG BUFFER  (TAD OUTPUT)
116525   %
116525   % ENTRY:     A-REG - WORD
116525   %            B-REG - TAD OUTPUT DATAFIELD
116525   %
116525   % RETURN:    SKIP-RETURN:  OK     TAD DATAFIELD BUFFER VARIABLES
116525   %                                 REMSIZ AND TDBTPT IS UPDATED
116525   %
116525   %            NOSKIP:       ERROR  A-REG:  1  NO OUTPUT BUFFER PRESENT
116525   %                                 A-REG:  2  OUTPUT BUFFER FULL
116525   %                                 A-REG:  3  MESSAGE FULL
116525   SUBR WORDPUT
116525   INTEGER AREG; INTEGER POINTER LREG
116527   WORDPUT: A=:AREG:=L=:"LREG"
116532          IF BUFFID=0 THEN A:=1; EXIT FI               % OUTPUT BUFFER PRESENT?
116536          IF REMSIZ<=1 THEN A:=2; EXIT FI              % BUFFER FULL?
116544          A:=2; CALL UPDMBC; GO MSFUL                  % UPDATE MESSAGE BYTE COUNT
116547          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116555          IF D BIT "0" THEN                            % ODD START IN BUFFER
116557             *LDATX
116560             A/\177400=:T; AREG
116563             A SHZ -10; A\/T; T:=TDTAFI; *STATX        % WRITE FIRST BYTE
116567             AREG SHZ 10; X+1; *STATX                  % WRITE SECOND BYTE
116573          ELSE                                         % EVEN START IN BUFFER
116574             AREG; *STATX                              % WRITE WORD IN BUFFER
116576          FI
116576          REMSIZ-2=:REMSIZ; MIN TDBTPT; MIN TDBTPT  % UPDATE BUFFER COUNTERS
116603          MIN "LREG"; GO LREG                       % RETURN
116605   MSFUL: A:=3; GO LREG                             % MESSAGE IS FULL
116607   RBUS
116611
116611   %==============================================================================
116611   % (R)   B Y T G E T
116611   %
116611   % ROUTINE TO GET A BYTE IN XMSG BUFFER  (TAD INPUT)
116611   % MUST BE CALLED WITH INTERUPT OFF!
116611   % ENTRY:     B-REG - TAD INPUT DATAFIELD
116611   %
116611   % RETURN:    SKIP-RETURN:  OK     A-REG:  BYTE
116611   %                                 TAD DATAFIELD BUFFER VARIABLES
116611   %                                 REMSIZ,REMBYT ARE UPDATED
116611   %
116611   %            NOSKIP:       ERROR  A-REG:  0  MESSAGE EMPTY
116611   %                                 A-REG:  1  NO INPUT BUFFER PRESENT
116611   %                                 A-REG:  2  BUFFER IS EMPTY
116611   SUBR BYTGET
116611   BYTGET:IF BUFFID=0  THEN A:=1; EXIT FI                % NO INPUT BUFFER
116615          IF REMSIZ<=0 THEN A:=2; EXIT FI                % INPUT BUFFER EMPTY
116622          IF REMBYT=0  THEN EXIT FI                      % MESSAGE EMPTY
116625          MIN REMBYT; GO CONT
116627          A:=0=:CURMES; EXIT                             % MESSAGE EMPTY
116632   CONT:  T:=TDTAFI; X:=TDTALA
116634          TDBTPT=:D SHZ -1; X+A; *LDATX                  % GET WORD WITH BYTE
116641          IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI     % GET WANTED BYTE
116646          T:=REMSIZ-1=:REMSIZ; MIN TDBTPT
116652          EXITA
116653   RBUS
116654
116654   %==============================================================================
116654   % (R)   L O A D B Y T
116654   %
116654   % ROUTINE TO LOAD A BYTE FROM THE XMSG BUFFER ACCORDING TO TDBTPT
116654   % TDBTPT IS INCREMEMENTED
116654   % ENTRY:     B-REG  - TAD-DATAFIELD  INPUT OR OUTPUT
116654   % RETURN:    A-REG  - BYTE   (OTHER REGISTERS IS NOT MODIFIED)
116654   SUBR LOADBYT
116654   INTEGER XREG,TREG,DREG
116657   LOADBYT:
116657          T=:TREG:=D=:DREG; X=:XREG
116663          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A; *LDATX
116672          MIN TDBTPT; IF D BIT "0" THEN A/\377 ELSE A SHZ -10 FI
116700          T:=DREG=:D:=TREG; X:=XREG; EXIT
116705   RBUS
116706
116706   %==============================================================================
116706   % (R)   S T O R B Y T              (ROUTINE IS DUPLICATED IN MPIT)
116706   %
116706   % ROUTINE TO STORE A BYTE IN THE XMSG BUFFER ACCORDING TO TDBTPT
116706   % TDBTPT AND REMSIZ IS UPDATED
116706   % ENTRY:     B-REG  - TAD-DATAFIELD  INPUT OR OUTPUT
116706   %            A-REG  - BYTE
116706   % RETURN:    NO REGISTERS MODIFIED
116706   SUBR STORBYT
116706   INTEGER TREG,AREG,DREG,XREG; TRIPLE TADREG=TREG
116712   STORBYT:
116712          TAD=:TADREG; X=:XREG
116714          T:=TDTAFI; X:=TDTALA; TDBTPT=:D SHZ -1; X+A
116722          IF D BIT "0" THEN
116724             *LDATX
116725             A/\177400=:T; AREG/\377\/T; T:=TDTAFI; *STATX
116734          ELSE
116735             AREG SHZ 10; *STATX
116740          FI
116740          MIN TDBTPT; REMSIZ-1=:REMSIZ
116744          TAD:=TADREG; X:=XREG; EXIT
116747   RBUS
116751

116751   %==============================================================================
116751   %       A U X I L A R Y   R O U T I N E S   F O R   M O N I T O R   C A L L S
116751   %==============================================================================
116751   %
116751   % (R)   R E D O M
116751   %
116751   % ROUTINE TO CAUSE MONITOR CALL TO BE REDONE
116751   % ENTRY:     B = DATAFIELD
116751   %            X = RT-PROGRAM
116751   %            D = WORKING AREA
116751   %            MONITOR LEVEL DISABLED
116751   SUBR REDOM
116751   REDOM:                                             % RESET TAD STACK
116751          D:=:B; ZPREG-1=:ZPREG; D:=:B                % REEXECUTE MONITOR CALL
116756          IF TDRADDR.RTRES-RTREF=0 THEN               % RESERVING PROGRAM?
116762             IF RTREF.STATUS NBIT 5REP AND TDRADDR.ISTATE=0 THEN  % IF NOT 5REP OR NOWAIT
116771                RTREF.STATUS BONE 5WAIT=:X.STATUS
116775                2=:TDRADDR.ISTATE
117000             FI
117000          FI
117000          D=:B; GO RETSTUPR
117002   RBUS
117004
117004   %==============================================================================
117004   % (R)   I E D C H K
117004   %
117004   % ROUTINE TO CHECK IF INPUT IS DONE WHILE DELAYED ESCAPE ACTION IS ON
117004   % ENTRY: B = INPUT-DATAFIELD
117004   % ERROR: EXIT.  A = ERROR-CODE: INPUT DONE IN DELAYED ESCAPE ACTION
117004   % OK:    SKIP RETURN
117004
117004   SUBR IEDCHK
117004   INTEGER DELMASK:=174377  % ZERO 5ESCLOFF, 5WESC, 5WLOC
117005   IEDCHK: IF FLAGB BIT 5ESCLOFF THEN
117010              IF T:=TYPRING BIT 5BAD THEN           %% T A D  ONLY
117013                IF A BIT 5WESC THEN                 %  ESCAPE WAITING
117015                   *IOF                             %
117016                   L=:D; CALL CBRERSP; 0/\0; D=:L   %  SEND-RESPONSE
117022                FI                                  %
117022              FI                                    %%
117022              *IOF
117023              FLAGB/\DELMASK=:FLAGB; *ION
117027              A:=TER00; EXIT
117031           FI
117031           A:=0; EXITA
117033   RBUS
117035
117035   %==============================================================================
117035   % (R)   C N V E R R
117035   %
117035   %      SUBROUTINE TO CONVERT FROM XMSG ERROR
117035   %      TO STANDARD ERROR CODE.
117035   SUBR CNVERR
117035   CNVERR: A-\/XKXXX; EXIT
117040   RBUS
117041

117041   %==============================================================================
117041   %       I O S E T   R O U T I N E S
117041   %==============================================================================
117041   %
117041   % (R)   C T I B A D
117041   %
117041   % INPUT IOSET ROUTINE FOR TAD, CALLED IN IOF
117041   % ENTRY: B = WORKING AREA
117041   %        X = RESIDENT INPUT-DATAFIELD
117041   %        A = CONTROL
117041   SUBR CTIBAD
117041   INTEGER XREG,BREG,TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER POINTER LREG
117047   CTIBAD: TAD=:TADREG; X=:XREG:=:B; X=:BREG:=L=:"LREG"; MLEV; *MCL PIE; ION
117060          CALL BISWTAD
117061          IF PORTNO=0 GO RETU
117063          IF AREG=-1 THEN                    % CLEAR BUFFER
117067             CALL CLIDAT; 0/\0
117071             41OTAD=:B
117073   NXBFF:    7RESE; T:=0; CALL CREMES; GO ECHEC
117077             7RECO; CALL SNDWT; 0/\0; GO RETU                  % SEND RESET AND WAIT FOR RESPONSE
117103   ECHEC:    IF A=2 THEN
117106                IF 41ITAD.BUFFID><0 THEN
117111                   CALL MOVITO; GO NXBFF
117113                FI
117113             FI; GO ORET
117114   ORET:     41ITAD=:B; GO RETU
117117          FI
117117   RETU:  MLEV; *IOF; MST PIE
117122          TAD:=TADREG; X:=BREG=:B:=XREG; GO LREG
117127   RBUS
117136
117136   %==============================================================================
117136   % (R)   C T O B A D
117136   %
117136   % OUTPUT IOSET ROUTINE FOR TAD
117136   % ENTRY: B = WORKING AREA
117136   %        X = RESIDENT OUTPUT-DATAFIELD
117136   %        A = CONTROLL
117136   %        D = PARAMETER
117136   % CALLED WITH INTERUPT OFF
117136   SUBR CTOBAD
117136   INTEGER BREG,XREG,TREG,AREG,DREG; TRIPLE TADREG=TREG; INTEGER POINTER LREG
117144   CTOBAD: TAD=:TADREG; X=:XREG:=:B; X=:BREG:=L=:"LREG"; MLEV; *MCL PIE; ION
117155          CALL BOSWTAD
117156          IF 41ITAD.PORTNO=0 GO RETU
117161          IF AREG=-1 THEN                              % CLEAR BUFFER
117165             CALL CLODAT; 0/\0
117167             IF A=1 THEN
117172                CALL SNDBUF; 0/\0; GO RETU
117175             ELSE
117176                X:=BUFFID; AD:=TDTADD; 0=:BUFFID=:REMSIZ; CALL PUTPOOL
117203                GO RETU
117204             FI
117204          FI
117204          IF A=-2 THEN
117207             CALL SNDBUF; 0/\0; GO RETU             % SEND BUFFER
117212          FI
117212          IF A=23 OR A=24 THEN                      % SYSTEM/USER CONTROLL
117220   NWBUF:    IF BUFFID=0 THEN
117222                CALL GETPOOL; GO NYTRY              % GET NEW BUFFER
117224             FI
117224             IF AREG=23 THEN 7SYCN ELSE 7USCN FI
117233             T:=2; CALL CREMES; GO ECHK
117236             DREG; CALL WORDPUT; GO RETU
117241             IF AREG=23 THEN
117245                IF DREG=1 OR A=13 OR A=17 THEN CALL SNDBUF; 0/\0 FI
117261             ELSE
117262                7ERRS; CALL SNDWT; 0/\0                        % SEND MESSAGE AND WAIT FOR RESPONSE
117265             FI
117265             GO RETU
117266          FI
117266   RETU:  MLEV; *IOF; MST PIE; MST PID
117272          TAD:=TADREG; X:=BREG=:B:=XREG; GO LREG
117277
117277   ECHK:  IF A=1 GO NYTRY
117302          IF A=2 THEN
117305             CALL SNDBUF; GO RETU; GO NWBUF
117310          FI
117310          GO RETU
117311
117311   NYTRY: BREG=:D; RTREF=:X; GO REDOM
117316   RBUS
117332
117332   %=========================================================================
117332   % (R)   C L I D A T
117332   %
117332   % ROUTINE TO REPLACE DATA MESSAGES IN INPUT BUFFER WITH DUMMY
117332   % ENTRY        B-REG - INPUT DATAFIELD
117332   % SKIP RETURN: OK      A-REG = 0  BUFFER IS EMPTY
117332   %                      A-REG = 1  CONTROLL MESSAGES LEFT IN BUFFER
117332   % RETURN:      ERROR   A-REG - XMSG ERROR CODE
117332   SUBR CLIDAT
117332   INTEGER CTRBUF,BUFBP,BREMAI; INTEGER POINTER LREG
117336   CLIDAT: A:=L=:"LREG"; 0=:CTRBUF
117341          IF BUFFID=0 OR REMSIZ=0 GO OKOUT
117346          REMSIZ=:BREMAI; TDBTPT=:BUFBP
117352          IF CURMES=7BDAT THEN
117356             T:=REMBYT-; T-1; TDBTPT+T=:TDBTPT=:BUFBP
117365             REMSIZ-T=:REMSIZ=:BREMAI
117371          FI
117371          DO WHILE REMSIZ>0
117374             CALL GETMES; GO ECHECK; T=:D
117377             IF CURMES=7BDAT THEN
117403                T:=TDTAFI; X:=TDTALA; TDBTPT-2=:L SHZ -1; X+A; *LDATX
117413                IF L BIT "0" THEN
117415                   T:=7DUMM; A/\177400\/T
117420                ELSE
117421                   T:=7DUMM SHZ 10; A/\377\/T
117425                FI
117425                T:=TDTAFI; *STATX
117427             ELSE
117430                1=:CTRBUF
117432             FI
117432             TDBTPT+D=:TDBTPT
117435          OD
117436   EOUT:  BUFBP=:TDBTPT
117440          0=:CURMES=:REMBYT; BREMAI=:REMSIZ
117444   OKOUT: CTRBUF; MIN "LREG"; GO LREG
117447
117447   ECHECK: IF A<0 GO LREG                           % XMSG ERROR CODE
117451          IF A=3 THEN A:=TER01; GO LREG FI          % MESSAGE ERROR
117456          GO EOUT
117457   RBUS
117463
117463   %=========================================================================
117463   % (R)   C L O D A T
117463   %
117463   % ROUTINE TO REPLACE DATA MESSAGES IN OUTPUT BUFFER WITH DUMMY
117463   % ENTRY        B-REG - OUTPUT DATAFIELD
117463   % SKIP RETURN: OK      A-REG = 0  BUFFER IS EMPTY
117463   %                      A-REG = 1  CONTROLL MESSAGES IN BUFFER
117463   % RETURN:      ERROR   A-REG - XMSG ERROR CODE
117463   SUBR CLODAT
117463   INTEGER CTRBUF,BUFBP,AUXBP; INTEGER POINTER LREG
117467   CLODAT: A:=L=:"LREG"; 0=:CTRBUF
117472          IF BUFFID=0 OR REMSIZ=41ITAD.FBSIZ-BUDIS GO OKOUT
117502          TDBTPT=:D=:BUFBP; BUDIS=:TDBTPT
117507   NXTBY: DO WHILE TDBTPT<D
117512             CALL LOADBYT; IF A=0 GO NXTBY; A=:CURMES; CALL LOADBYT; A=:X
117517             IF CURMES=7BDAT THEN
117523                TDBTPT-1=:TDBTPT; A:=7DUMM; CALL STORBYT
117530             ELSE
117531                1=:CTRBUF
117533             FI
117533             TDBTPT+X=:TDBTPT
117536          OD
117537          BUFBP=:TDBTPT
117541   OKOUT: 0=:CURMES=:NOBDIS; CTRBUF; MIN "LREG"; GO LREG
117546   RETU:  GO LREG
117547   RBUS
117552

117552   %==============================================================================
117552   %       R O U T I N E S   T O   G E N E R A T E   M E S S A G E S
117552   %==============================================================================
117552   %
117552   % (R)   B B R E C
117552   %
117552   % ROUTINE TO SEND BREAK AND ECHO MESSAGE FOR TAD
117552   % ENTRY: X = INPUT DATAFIELD
117552   %        D = CONTROLL (1=BREAK, 2=ECHO)
117552   %        MONITOR LEVEL DISABLED
117552   SUBR BBREC
117552   BBREC: A:=L+1=:X."LRSA"; IF X.PORTNO=0 GO RETU
117556          IF X.BRECST<0 THEN A:=-1 FI                   % VALUE WILL BE CONV. TO BYTE FORMAT
117561          IF D=1 THEN CALL BDBREA ELSE CALL BDECHO FI
117567   RETU:  T:=X."LRSA"=:L; EXIT
117572   RBUS
117574
117574   %==============================================================================
117574   % (R)   C B R E C T A
117574   %
117574   % ROUTINE TO COPY BREAK AND ECHO TABLES
117574   % ENTRY:    D-REG  - SOURCE ADDRESS
117574   %           B-REG   - TAD OUTPUT DATAFIELD
117574   % RETURN:   EXIT    TDBTPT, REMSIZ IS UPDATED
117574   %
117574   SUBR CBRECTA
117574   CBRECTA:
117574          TDBTPT SHZ -1+TDTALA
117577          A=:NOCHAR
117600          FOR X:=0 TO 7 DO; X=:XRSA
117605             D.S0; D+1; T:=TDTAFI; X:=NOCHAR; *STATX
117613             MIN NOCHAR
117614          X:=XRSA; OD
117617          TDBTPT+20=:TDBTPT; REMSIZ-20=:REMSIZ
117625          EXIT
117626   RBUS
117626
117626   %==============================================================================
117626   % (R)   B D E C H O
117626   %
117626   % ROUTINE TO SEND ECHO-MESSAGE
117626   % ENTRY:       A-REG = ECHO STRATEGY
117626   %              X-REG = TAD INPUT DATAFIELD
117626   SUBR BDECHO
117626   INTEGER AREG,BREG,MSSIZ; INTEGER POINTER LREG
117632   BDECHO: A=:AREG:=L=:"LREG":=B=:BREG; 41OTAD=:B
117641          IF AREG>0 AND A<7 THEN
117647             IF A=CURECST GO RETU                   % SAME ECHO STRATEGY AS LAST TIME
117652          FI; A=:CURECST                            % SET NEW CURRENT STRATEGY
117653          IF A=7 THEN T:=21 ELSE T:=1 FI; T=:MSSIZ
117662          IF BUFFID=0 THEN
117664             CALL GETPOOL; GO NYTRY
117666          ELSE
117667             IF REMSIZ<T+3 THEN
117673                CALL SNDBUF; GO NYTRY
117675                IF BUFFID=0 GO NYTRY
117677             FI
117677          FI
117677          A:=7ECKM; T:=MSSIZ; CALL CRHEOD; GO RETU            % CREATE MESSAGE HEADER
117703          AREG=:D; CALL STORBYT                               % WRITE ECHO TYPE
117706          IF D=7 THEN                                         % COPY ECHO TABLE
117711             41ITAD+"PECH7"=:D; CALL CBRECTA
117715          FI
117715   RETU:  41ITAD=:X; BREG=:B; GO LREG
117722
117722   NYTRY: 41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM
117731   RBUS
117743
117743   %==============================================================================
117743   % (R)   B D B R E A
117743   %
117743   % ROUTINE TO SEND BREAK-MESSAGE.
117743   % ENTRY:       A-REG = BREAK STRATEGY
117743   %              X-REG = TAD INPUT DATAFIELD
117743   SUBR BDBREA
117743   INTEGER AREG,BREG,MSSIZ,BRSTR; INTEGER POINTER LREG
117750   BDBREA: A=:AREG:=L=:"LREG":=B=:BREG; X=:B
117756          IF AREG>0 AND A<7 THEN
117764             IF A=41OTAD.CURBRST GO RETU                  % SAME BREAK STRATEGY AS LAST TIME
117770          FI; A=:41OTAD.CURBRST                           % SET NEW CURRENT STRATEGY
117772          IF A>7 AND X:=OSVTPN<3 THEN T:=7 ELSE A=:T FI   % FAKE 8 AND 9 IF NOT PROT 3
120004          T=:BRSTR
120005          IF T=X:=7 THEN T:=23 ELSE T:=3 FI; T=:MSSIZ; 41OTAD=:B
120016          IF BUFFID=0 THEN
120020             CALL GETPOOL; GO NYTRY
120022          ELSE
120023             IF REMSIZ<T+3 THEN
120027                CALL SNDBUF; GO NYTRY
120031                IF BUFFID=0 GO NYTRY
120033             FI
120033          FI
120033          A:=7BMMX; T:=MSSIZ; CALL CRHEOD; GO RETU            % CREATE MESSAGE HEADER
120037          BRSTR=:D; CALL STORBYT                              % WRITE BREAK TYPE
120042          TDBTPT SHZ-1; T:=TDTALA+A; 41ITAD.BRKMAX
120050          T=:X:=TDTAFI; *STATX                                % WRITE MAXBREAK
120053          TDBTPT+2=:TDBTPT; REMSIZ-2=:REMSIZ
120061          IF D=7 THEN
120064             IF AREG=11 THEN 41ITAD.BRKTAB ELSE 41ITAD+"PBRK7" FI
120075             A=:D; CALL CBRECTA
120077          FI
120077   RETU:  41ITAD=:X; BREG=:B; GO LREG
120104
120104   NYTRY: 41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM
120113   RBUS
120125
120125   %==============================================================================
120125   % (R)   B T M O D
120125   %
120125   % ROUTINE TO SEND TERMINAL-MODE, CALLED FROM MTERMODE
120125   %
120125   % X = INPUT-DATAFIELD, A = MODE,  MONITOR LEVEL DISABLED
120125   % T = WORKING FIELD IF BMTMOD
120125
120125   SUBR BTMOD
120125   INTEGER WFI
120126   BMTMOD:K:=1; T=:WFI; GO FELL
120131   BTMOD: K:="0"
120132   FELL:  IF T:=X.PORTNO=0 THEN EXITA FI
120136          T:=41OTAD=:B:=L+1=:"LRSA"; A=:XRSA
120143   NXBUF: 7TMOD; T:=1; CALL CREMES; GO ECHEC
120147          A:=XRSA/\377; CALL BYTPUT; GO RETU
120153          CALL SNDBUF; 0/\0
120155   RETU:  GO LRSA
120156   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120164          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120177          GO RETU
120200   RBUS
120210
120210   %==============================================================================
120210   % (R)   C T M O D   C M T M O D
120210   %
120210   % ROUTINE TO SEND TERMINAL-MODE, CALLED FROM TERMODE COMMAND
120210   %
120210   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120210   % T = WORKING FIELD IF CMTERM
120210
120210   SUBR CTMOD,CMTERM
120210   INTEGER WFI
120211   CMTERM:K:=1; T=:WFI; GO FELL
120214   CTMOD: K:="0"
120215   FELL:  T:=L+1=:X."LRSA"
120217          A:=B=:X.XRSA; 41OTAD=:B
120223   NXBUF: 7TMOD; T:=1; CALL CREMES; GO ECHEC; 41ITAD=:B; A:=0
120232
120232   % CAPITAL LETTERS
120232          IF T:=DFLAG BIT 5CAPITAL THEN A BONE "0" FI
120236   % CR DELAY
120236          IF T:=TINFO BIT 5CRDLY THEN A BONE 1 FI
120242   % STOP ON FULL PAGE
120242          IF T:=41OTAD.SCREEN><X:=0 THEN A BONE 2 FI
120250   % LOGGOUT ON MISSING CARRIER
120250          IF T:=FLAGB BIT 5LBLOG   THEN A BONE 3 FI
120254          X:=41OTAD=:B; CALL BYTPUT; GO RETU
120260          CALL SNDBUF; 0/\0
120262   RETU:  X:=41ITAD; X.XRSA=:B; X."LRSA"=:L; EXIT
120270   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120276          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120311          GO RETU
120312   RBUS
120321
120321   %==============================================================================
120321   % (R)   C S T Y P   C M S T Y P
120321   %
120321   % ROUTINE TO SEND TERMINAL TYPE CALLED FROM SET-TERMINAL-TYPE COMMAND
120321   % AND MSTTY MONITOR CALL
120321   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120321   % T = WORKING FIELD IF CMSTYP
120321
120321   SUBR CSTYP,CMSTYP
120321   INTEGER BREG,WFI; INTEGER POINTER LREG
120324   CMSTYP:K:=1; T=:WFI; GO FELL
120327   CSTYP: K:="0"
120330   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120335          X:=B=:BREG; 41OTAD=:B
120341   NXBUF: 7TTYP; T:=2; CALL CREMES; GO ECHEC
120345          41ITAD.CTTYP; CALL WORDPUT; GO RETU
120351   RETU:  X:=41ITAD; BREG=:B; GO LREG
120355   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120363          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120376          GO RETU
120377   RBUS
120406
120406   %==============================================================================
120406   % (R)   C S U M O D
120406   %
120406   % ROUTINE TO SEND UMOD MESSAGE CALLED FROM IOMTY FUNCTION SUNMO
120406   % X = INPUT-DATAFIELD, MONITOR LEVEL DISABLED
120406   % T = WORKING FIELD IF CMSTYP
120406   SUBR CSUMOD
120406   INTEGER BREG
120407   INTEGER POINTER LREG
120410   CSUMOD: IF X.PORTNO=0 OR X.OSVTPN/\377<4 THEN EXIT FI
120420           MLEV; *MCL PIE                           % DISABLE MON LEV.
120422           A:=B=:BREG:=41OTAD=:B:=L=:"LREG"
120430   NXBUF:  7UMOD; T:=2; CALL CREMES; GO ECHEC
120434           X:=BREG; A:=X.D4; CALL WORDPUT; GO OUT   % D4 CONTAINS UMOD STRATEGY
120440           CALL SNDBUF; GO OUT
120442           MIN "LREG"
120443   OUT:    BREG=:B; GO LREG
120446   ECHEC:  IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF FI
120454           IF A=1 THEN
120457              41ITAD=:B; RTREF=:X; BREG=:D;GO REDOM % WAIT FOR BUFFER
120466           FI
120466           GO OUT
120467   RBUS
120477
120477   %==============================================================================
120477   % (R)   C C E S C   C M E S C
120477   %
120477   % ROUTINE CALLED FROM ENABLE/DISABLE-ESCAPE COMMANDS AND MONITOR CALLS
120477   % TO SEND ENABLE/DISABLE ESCAPE
120477   % X = INPUT DATAFIELD, MONITOR LEVEL DISABLED
120477   % T = WORKING FIELD IF CMESC
120477   SUBR CCESC,CMESC
120477   INTEGER BREG,WFI; INTEGER POINTER LREG
120502   CMESC: K:=1; T=:WFI; GO FELL
120505   CCESC: K:="0"
120506   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120513          X:=B=:BREG; 41OTAD=:B
120517   NXBUF: 7CESC; T:=1; CALL CREMES; GO ECHECK
120523          IF 41ITAD.DFLAG BIT 5IESC THEN A:=0 ELSE A:=1 FI
120532          CALL BYTPUT; GO RETU
120534          IF TDRADDR.RTRES=RTREF THEN
120541             7CERS; CALL SNDWT; 0/\0                           % SEND MESSAGE AND WAIT FOR RESPONSE
120544          ELSE
120545             CALL SNDBUF; 0/\0                                 % JUST SEND MESSAGE
120547          FI
120547   RETU:  X:=41ITAD; BREG=:B; GO LREG
120553   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120561          IF A=1 AND K THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120574          GO RETU
120575   RBUS
120605
120605   %==============================================================================
120605   % (R)   C S D A E   C M S D A E
120605   %
120605   % ROUTINE CALLED FROM DEFINE-ESCAPE-CHARACTER COMMAND TO SEND CHANGE.
120605   % X = INPUT DATAFIELD, MONITOR LEVEL DISABLED
120605   SUBR CSDAE,CMSDAE
120605   INTEGER BREG,WFI; INTEGER POINTER LREG
120610   CMSDAE:K:=1; T=:WFI; GO FELL
120613   CSDAE: K:="0"
120614   FELL:  IF X.PORTNO=0 THEN EXITA FI; A:=L+1=:"LREG"
120621          X:=B=:BREG; 41OTAD=:B
120625   NXBUF: 7DESC; T:=1; CALL CREMES; GO ECHECK
120631          41ITAD.CESCP/\377
120634          CALL BYTPUT; GO RETU; CALL SNDBUF; GO RETU
120640   RETU:  41ITAD=:X; BREG=:B; GO LREG
120645   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF; FI
120653          IF A=1 THEN X:=WFI=:D:=41ITAD=:B:=RTREF; GO REDOM FI
120664          GO RETU
120665   RBUS
120675
120675   %==============================================================================
120675   % (R)   B I S I Z    P I S I Z
120675   %
120675   % ROUTINE CALLED FROM IBRSIZ/ISIZE WITH:
120675   % X = INPUT-DATAFIELD, B = WORKING-AREA, MONITOR LEVEL DISABLED
120675   % TO FIND NUMBER OF CHARACTERS LEFT TO READ IN A TAD
120675   % IF TAD INPUT-BUFFER IS EMPTY, A REQUEST FOR ISIZE IS SENT
120675   % TO PARTNER.
120675   %
120675   % SKIP-RETURN: A = NUMBER OF CHARACTERS IN BUFFER
120675   %              X = NUMBER OF CHARACTERS INCLUDING FIRST BREAK  (BISIZ ONLY)
120675   % RETURN:      A = ERROR CODE
120675
120675   SUBR BISIZ,PISIZ
120675   BISIZ: A:=0; GO FELLS             % IBRSIZ (MON 313)
120677   PISIZ: A:=1                       % ISIZE  (MON 66)
120700   FELLS: X:=:B; A=:XRSA; X=:"LRSA"
120703          IF BUFFID><0 THEN                          % INPUT BUFFER PRESENT
120705             IF CURMES=7BDAT THEN                    % DATA-MESSAGE PRESENT
120711   CDATA:       A:=REMBYT-
120713                IF A-1=0 THEN GO CMORE ELSE GO RETU FI
120717             ELSE
120720   CMORE:       CALL GETMES; GO ENDCH               % GET NEXT MESSAGE
120722                IF A=X:=7BDAT THEN                  % DATA MESSAGE
120725                   IF T=0 THEN                      % EMPTY
120727                      GO CMORE
120730                   ELSE
120731                      T=:A; GO RETU                 % NUMBER OF BYTES FOUND
120733                   FI
120733                ELSE
120734                   A:=3; GO ENDCH
120736             FI;FI; GO CMORE
120737
120737   ENDCH:    IF A<0 GO EROUT
120740             IF A=3 THEN
120743                CALL SNDREJ; 0/\0; A:=TER01; GO EROUT
120747             FI
120747          FI
120747
120747   % INPUT-BUFFER IS EMPTY OR NOT PRESENT
120747          41OTAD=:B                       % B = OUTPUT DATAFIELD
120751          IF 41ITAD.BUFFID><0 THEN        % RETURN INPUT BUFFER TO POOL
120754             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.NOBDIS
120760             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL
120764          FI
120764
120764   TAGAI: A:=7ISRQ; T:=0; CALL CREMES; GO BCHEC
120770          IF 41ITAD.XRSA=0 THEN 7ISRS ELSE 7ISRS BONE 17 FI
120777          CALL SNDWT; 0/\0; X."LRSA"=:B; MIN ZPREG; 0/\0; GO RET % SEND MESSAGE AND WAIT FOR RESPONSE
121006
121006   BCHEC: IF A<0 GO EROUT
121007          IF A=2 THEN                     % OUTPUT-BUFFER FULL
121012             CALL SNDBUF; GO EROUT; GO TAGAI
121015          FI
121015          41ITAD=:B; RTREF=:X; "LRSA"=:D
121023          GO REDOM                        % TRY WHEN BUFFERS RETURNED
121024
121024   % CHARACTERS PRESENT IN LOCAL BUFFER, RETURN NUMBER
121024   RETU:  B=:X; T:="LRSA"=:B; X:=X.XRSA;
121030          A=:ZAREG; IF X=0 THEN A=:ZXREG FI
121034          MIN ZPREG; ;0/\0; GO RET
121037
121037   % ERROR RETURN
121037   EROUT: T:="LRSA"=:B; A=:ZAREG; GO RET
121043   RBUS
121057
121057   %==============================================================================
121057   % (R)   B O S I Z
121057   %
121057   % ROUTINE CALLED FROM OSIZE IF TAD
121057   % X = OUTPUT-DATAFIELD
121057   SUBR BOSIZ
121057   BOSIZ: IF X.BUFFID><0 THEN
121061             A:=X.REMSIZ
121062          FI
121062          A=:ZAREG; MIN ZPREG; 0/\0; GO RET
121066   RBUS
121067
121067   %==============================================================================
121067   % (R)   B S C P C
121067   %
121067   % ROUTINE TO PREPARE SENDING OF COMPLETION CODE, CALLED FROM UEADM.
121067   % THE ROUTINE MUST CHECK DATA TO DETERMINE IF THE CURRENT OPERATION
121067   % OF UEADM IS WRITE COMPLETION CODE. IF UEDAT ON SYSTEM-SEGMENT IS
121067   % EQUAL THE ARRAY IN THE USER PARAMETER EXEPT FOR COMPLETION CODE
121067   % FUNCTION 2 IS USED TO SET COMPLETION CODE.
121067
121067   SUBR BSCPC
121067   DISP -177; INTEGER T2SEG,WPNT; PSID
121067   SYMBOL FPART=3,CBC01,CBC02,LPART,AREND=UEMAX
121067   INTEGER POINTER TTIF:=TTIFIELD
121070   BSCPC: A:=L=:TTIF."LRSA"; IF X.PORTNO=0 THEN EXIT FI
121076          WPNT=:D
121100          FOR X:=0 TO FPART DO; X:=:D            % CHANGE IN UEDAT BEFORE COMP.CODE?
121105              T:=T2SEG; CALL GET1L; GO ERR; X+1:=:D
121112              IF A><UEDAT(X) GO NOCOD
121115          OD; A:=D+2=:D
121122          FOR X:=LPART TO AREND DO; X:=:D        % CHANGE IN UEDAT AFTER COMP.CODE?
121127              T:=T2SEG; CALL GET1L; GO ERR; X+1:=:D
121134              IF A><UEDAT(X) GO NOCOD
121137          OD
121141          T:=T2SEG; X:=WPNT+CBC02; CALL GET1L; GO ERR    % COLLECT COMPLETION CODE
121146          A=:D; X-1; CALL GET1L; GO ERR; X:=TTIF:=:B     % --------- " ----------
121154          CALL SNDCP                                     % SEND COMPLETION CODE
121155   RETU:  X."LRSA"=:L; EXIT
121160   ERR:
121160   NOCOD: X:=TTIF; GO RETU
121162   RBUS
121165
121165   %==============================================================================
121165   % (R)   S N D C P
121165   %
121165   % ROUTINE TO SEND COMPLETION CODE CALLED FROM BSCPC
121165   % ENTRY:     AD= COMPLETION CODE
121165   %            B = TAD INPUT DATAFIELD
121165   % RETURN:    EXIT, NO ERRORS RAPPORTED
121165
121165   SUBR SNDCP
121165   INTEGER BREG,CPC1,CPC2,LREG
121171   SNDCP: MLEV; *MCL PIE                            % DISABLE MONTTOR LEVEL
121173          T:=L=:LREG; A=:CPC1:=D=:CPC2; X=:BREG
121201          X:=TDRADDR; CALL XISWTAD                  % SET UP WINDOW IN PIT
121203          41OTAD=:B                                 % B-REG - OUTPUT-DATAFIELD
121205   NXBUF: 7CPCO; T:=4; CALL CRHEEV; GO ECHEC        % CREATE MESSAGE
121211          TDBTPT SHZ -1; T:=TDTAFI; X:=TDTALA+A
121216          CPC1; *STATX
121220          X+1; CPC2; *STATX
121223          TDBTPT+4=:TDBTPT; REMSIZ-4=:REMSIZ
121231          CALL SNDBUF; 0/\0
121233   RETU:  41ITAD=:X:=BREG=:B:=LREG=:L; MLEV; *MST PIE; EXIT
121244   ECHEC: IF A=2 THEN CALL SNDBUF; 0/\0; GO NXBUF FI; GO RETU
121253   RBUS
121261
121261   %==============================================================================
121261   % (R)   N W S T A
121261   %
121261   % ROUTINE TO SEND NOWAIT STATUS, CALLED WITH MONITOR LEVEL DISABLED
121261   % ENTRY:      A = NOWAIT STATUS
121261   %             X = TAD INPUT-DATAFIELD
121261   SUBR NOWTSTA
121261   INTEGER BREG,NWS; INTEGER POINTER LREG
121264   NOWTSTA:A=:D; IF X.PORTNO=0 THEN EXITA FI                  % NOT CONNECTED
121270          A:=L+1=:"LREG":=D; X:=:B=:BREG; A=:NWS
121276   NXBFF: IF A=0 THEN A:=7NOWT ELSE A:=7TNOW FI               % DETERMINE NOWT TYPE
121302          T:=41OTAD=:B; T:=1; CALL CRHEEV; GO ECHK            % CREATE MESSAGE
121307          NWS; CALL STORBYT                                   % WRITE STATUS
121311          CALL SNDBUF; 0/\0; GO RETUO                         % SEND MESSAGE
121314
121314   ECHK:  IF A=1 THEN                                         % NO BUFFER
121317             41ITAD=:B; RTREF=:X; BREG=:D; GO REDOM           % TRY LATER
121326          FI
121326          IF A=2 THEN                                         % NOT ENOUGH SPACE
121331             CALL SNDBUF; GO RETUO
121333             NWS; GO NXBFF                                    % NEXT BUFFER
121335          FI
121335   RETUO: 41ITAD=:B
121337   RETUI: B=:X; BREG=:B; GO LREG
121343   RBUS
121352
121352   %==============================================================================
121352   % (R)   S N D R F I
121352   %
121352   % ROUTINE TO GENERATE AND SEND RFI-MESSAGE.
121352   % CALLED FROM ALL INPUT CALLS WHEN INPUT BUFFER IS EMPTY.
121352
121352   % ENTRY:          B-REG - TAD INPUT DATAFIELD
121352   % SKIP RETURN:    OK
121352   % RETURN:         A-REG - XMSG ERROR CODE
121352   SUBR SNDRFI
121352   INTEGER POINTER LREG
121353   SNDRFI: A:=L=:"LREG"; B=:X=:D; 41OTAD=:B
121361          IF X.TDRADDR.ISTATE<0 THEN                % NOWAIT MODE
121364             IF D.DFLAG BIT 5RQI GO SOUT            % RFI ALREADY SENT, TRY TO SEND OUTPUT
121370          FI
121370          IF BUFFID=0 AND 41ITAD.BUFFID><0 GO USINP % OUTPUT BUFFER PRESENT?
121375          A:=7RFI; T:=0; CALL CREMES; GO NOSPA      % GENERATE MESSAGE
121401          GO SBU
121402
121402   NOSPA: IF A<0 GO RETU                            % XMSG ERROR
121403          IF A=1 GO NOPOL                           % NO BUFFERS IN POOL
121406          CALL SNDBUF; GO RETU                      % OUTPUT BUFFER FULL, SEND
121410          IF BUFFID=0 GO USINP                      % NO BUFFER, USE INPUT
121412          A:=7RFI; T:=0; CALL CREMES; GO RETU       % GENERATE MESSAGE
121416
121416   SBU:   41ITAD.DFLAG BONE 5RQI=:X.DFLAG           % MARK RFI SENT IN INPUT-DATAFIELD
121422   SOUT:  IF 41ITAD.BUFFID><0 THEN
121425             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.REMBYT
121431             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL % RETURN INPUT BUFFER TO POOL
121435          FI
121435          CALL SNDBUF; 0/\0
121437   OKRET: 41ITAD=:B; MIN "LREG"; GO LREG            % OK RETURN
121443
121443   USINP: IF 41ITAD.BUFFID=0 GO NOPOL               % POOL IS EMPTY
121446          CALL MOVITO                               % MOVE INP. BUFF. TO OUTPUT
121447          A:=7RFI; T:=0; CALL CREMES; GO RETU       % GENERATE MESSAGE
121453          CALL SNDBUF; GO RETU                      % SEND MESSAGE
121455          41ITAD.DFLAG BONE 5RQI=:X.DFLAG           % MARK RFI SENT IN INPUT-DATAFIELD
121461          GO OKRET                                  % OK RETURN
121462   RETU:  X:=41ITAD=:B; GO LREG
121465
121465   NOPOL: 41ITAD.DFLAG BZERO 5RQI BONE 5WRQI=:X.DFLAG
121472          GO OKRET                                  % DRIVER SENDS RFI WHEN BUFFER AVAILABLE
121473   RBUS
121501
121501   %==============================================================================
121501   % (R)   S N D R E J
121501   %
121501   % ROUTINE TO GENERATE AND SEND REJECT-MESSAGE.
121501   % IF REJECTED MESSAGE IS DATA, RFI-MESSAGE
121501   % IS ALSO SENDT.
121501
121501   % ENTRY:          B-REG - TAD INPUT DATAFIELD
121501   % SKIP RETURN:    OK
121501   % RETURN:         A-REG - XMSG ERROR CODE
121501   SUBR SNDREJ
121501   INTEGER POINTER LREG
121502   SNDREJ: A:=L=:"LREG":=41OTAD=:B
121506          IF BUFFID=0 AND 41ITAD.BUFFID><0 GO USINP    % OUTPUT BUFFER PRESENT?
121513          IF 41ITAD.CURMES=7BDAT THEN T:=3 ELSE T:=1 FI % INCLUDING RFI?
121523          A:=7REJE; CALL CREMES; GO NOSPA              % GENERATE REJECT
121526          41ITAD.CURMES; CALL BYTPUT; GO RETU          %
121532          A:=7RFI; T:=0; CALL CREMES; GO RETU          % GENERATE RFI
121536          GO SBU
121537
121537   NOSPA: IF A<0 GO RETU                            % XMSG ERROR
121540          CALL SNDBUF; GO RETU                      % OUTPUT BUFFER FULL, SEND
121542          IF BUFFID=0 GO USINP                      % NO BUFFER, USE INPUT
121544          A:=7REJE; T:=1; CALL CREMES; GO RETU      % GENERATE REJECT
121550          41ITAD.CURMES; CALL BYTPUT; GO RETU
121554          IF 41ITAD.CURMES=7BDAT THEN
121561             A:=7RFI; T:=0; CALL CREMES; GO RETU    % GENERATE RFI
121565          FI
121565
121565   SBU:   CALL SNDBUF; GO RETU                      % SEND BUFFER
121567          IF 41ITAD.BUFFID><0 THEN
121572             0=:X.BUFFID=:X.REMSIZ=:X.CURMES=:X.REMBYT
121576             A=:T; AD:=X.TDTADD; T=:X; CALL PUTPOOL % RETURN INPUT BUFFER TO POOL
121602          FI
121602   OKRET: 41ITAD=:B; MIN "LREG"; GO LREG             % OK RETURN
121606
121606   USINP: IF 41ITAD.BUFFID=0 THEN                   % NO BUFFERS AVAILABLE
121611             IF X.CURMES=7BDAT THEN
121615                X.DFLAG BONE 5WRQI=:X.DFLAG         % RFI MUST BE SENT BY DRIVER
121620             FI
121620             GO OKRET                               % REJECT IS NOT POSSIBLE
121621          FI
121621          CALL MOVITO                               % MOVE INP. BUFF. TO OUTPUT
121622          A:=7REJE; T:=1; CALL CREMES; GO RETU      % GENERATE REJECT
121626          41ITAD.CURMES; CALL BYTPUT; GO RETU
121632          IF 41ITAD.CURMES=7BDAT THEN
121637             A:=7RFI; T:=0; CALL CREMES; GO RETU    % GENERATE RFI
121643          FI
121643          CALL SNDBUF; GO RETU                      % SEND BUFFER
121645          GO OKRET                                  % OK RETURN
121646
121646   RETU: X:=41ITAD=:B; GO LREG
121651   RBUS
121661
121661   %==============================================================================
121661   %       I O T R A N S   A N D  I / O   M O N I T O R   C A L L S
121661   %==============================================================================
121661   %
121661   % (R)   B D P U T
121661   %
121661   % OUTPUT IOTRANS ROUTINE FOR TAD.
121661   % CALLED WITH INTERUPT OFF
121661   % ENTRY:        A-REG - BYTE
121661   %               B-REG - TAD OUTPUT DATAFIELD
121661   % SKIP RETURN:  OK
121661   % RETURN:       ERROR-CODE IN DERROR
121661   SUBR BDPUT
121661   BDPUT: A=:LAST:=L=:"LRSA"; X=:XRSA; 0=:TMR
121666          CALL BOSTAD; MLEV; *MCL PIE; ION
121672          IF 41ITAD.PORTNO=0 THEN MIN "LRSA"; GO RETU; FI     % NOT CONNECTED
121677          IF 7BDAT><CURMES THEN
121703   CRMES:    T:=3; CALL CREMES; GO ERR
121706          FI
121706          IF 41ITAD.TINFO NBIT 5UMOD OR X.BSTATE=5BCOM THEN
121716             LAST BZERO 7
121720          ELSE
121721             LAST
121722          FI
121722          CALL BYTPUT; GO ERR
121724          MIN "LRSA" GO RETU                                  % SKIP RETURN OK
121726
121726   ERR:   IF A<0 GO CNXE                                      % ERROR FROM XMSG
121727          IF A=1 GO RETU                                      % WAIT FOR BUFFER
121732          IF A=2 THEN                                         % BUFFER FULL
121735             CALL SNDBUF; GO CNXE
121737             IF BUFFID><0 THEN 7BDAT; GO CRMES FI
121743             GO RETU
121744          FI
121744          IF A=3 THEN 7BDAT; GO CRMES; FI                     % MESSAGE FULL
121751          GO RETU
121752   CNXE:  CALL CNVERR                                         % CONVERT ERROR-CODE
121753   EROUT: A=:DERROR; X:=XRSA; MLEV; *IOF; MST PIE
121760          GO LRSA
121761   RETU:  TTMR=:TMR; X:=XRSA; MLEV; *IOF; MST PIE
121767          LAST; GO LRSA
121771   RBUS
121777
121777   %==============================================================================
121777   % (R)   B D G E T
121777   %
121777   % INPUT IOTRANS ROUTINE FOR TAD.
121777   % CALLED WITH INTERUPT OFF
121777   % ENTRY:        B-REG - TAD INPUT DATAFIELD
121777   % SKIP RETURN:  OK
121777   %               A-REG - BYTE
121777   % RETURN:       ERROR-CODE IN DERROR
121777   SUBR BDGET
121777   BDGET: A:=L=:"LRSA"; X=:XRSA
122002          CALL BISTAD; MLEV; *MCL PIE; ION
122006          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122010          IF PORTNO=0 THEN A:=TER02; GO EROUT; FI   % NOT CONNECTED
122014   BYGET: IF CURMES=7BDAT THEN
122020             CALL BYTGET; GO ERR; A=:LAST; MIN "LRSA"; GO RETU
122025          FI
122025   NXMES: CALL GETMES; GO ERR
122027          IF A=X:=7BDAT THEN
122032             IF T=0 THEN GO NXMES ELSE GO BYGET FI
122036          ELSE
122037             A:=3; GO ERR
122041          FI
122041          GO RETU
122042
122042   ERR:   IF A<0 GO CNXE                                      % XMSG ERROR CODE
122043          IF A=0 GO NXMES                                     % DATA MESSAGE EMPTY
122044          IF A=1 OR A=2 THEN CALL SNDRFI; GO CNXE; GO RETU;FI % BUFFER EMPTY, SEND RFI
122055          IF A=3 THEN                                         % INCONSISTENT MESSAGE
122060             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122064          FI
122064          GO RETU
122065   CNXE:  CALL CNVERR
122066   EROUT: A=:DERROR
122067   RETU:  A=:X:=MLEV; *IOF; MST PIE
122073          X=:A:=XRSA
122075          GO LRSA
122076   RBUS
122107
122107   %==============================================================================
122107   % (R)   B M 8 O U T   B B 8 O U T   B D T C H
122107   %
122107   % BM8OUT (MON 22):
122107   %    MONITOR CALL TO WRITE UP TO 8 BYTES ON A TAD (0 BYTE TERMINATES)
122107   % BB8OUT (MON 24):
122107   %    MONITOR CALL TO WRITE 8 BYTES ON A TAD
122107   %
122107   % CALLED WITH INTERUPT OFF WITH B = OUTPUT-DATAFIELD
122107
122107   SUBR BM8OUT,BB8OUT,BDTCH
122107
122107   % ROUTINE TO CHECK FOR TERMINATION IN DATA
122107   BDTCH:  A=:D
122110           IF X:=XRSA=0 THEN
122113             A SHZ -10; IF A=0 THEN EXIT FI      % FIRST BYTE EMPTY
122116             D=:A; A/\377
122120             IF A=0 THEN A:=D SHZ -10; EXITA FI  % LAST BYTE EMPTY
122124           FI
122124           D=:A; L+1; EXITA
122127
122127   BM8OUT: T:=0; GO FELLS
122131   BB8OUT: T:=1
122132   FELLS: MLEV; *MCL PIE; ION
122135          CALL BOSWTAD; T=:XRSA                     % SET WINDOW
122137          IF 41ITAD.PORTNO=0 GO MOURET; 0=:TMR      % NOT CONNECTED
122144          IF 7BDAT><CURMES THEN                     % CURRENT NOT DATA-MESS
122150   CRMES:    T:=10; CALL CREMES; GO ERR             % RESERVE 10 BYTES
122153          ELSE
122154             IF REMSIZ<12 THEN A:=2; GO ERR FI      % NOT ENOUGH SPACE IN BUFFER
122162             CALL GETMBC                            % GET BYTE COUNT IN CURMES
122163             IF A+10>377 THEN 7BDAT; GO CRMES FI    % NOT ENOUGH SPACE IN MESSAGE
122171          FI
122171
122171   % ENOUGH SPACE IN BUFFER
122171
122171          *IRR ALEVB DA
122172          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DD
122200          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DL
122206          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR; *IRR ALEVB DX
122214          CALL BDTCH; GO OKRET; GO LASBY; CALL WORDPUT; GO ERR
122221
122221   % NORMAL RETURN, BYTES STORED IN BUFFER
122221   OKRET: TTMR=:TMR; GO TAD8RET
122224
122224   % ONE BYTE LEFT TO WRITE IN BUFFER
122224   LASBY: CALL BYTPUT; GO ERR; GO OKRET
122227
122227   % ERRORS FROM CREMES
122227   ERR:   IF A=1 GO RETU                            % WAIT FOR BUFFER
122232          IF A=2 THEN                               % BUFFER FULL
122235             CALL SNDBUF; GO CNXE
122237             IF BUFFID><0 THEN 7BDAT; GO CRMES FI   % NEW BUFFER
122243             GO RETU                                % WAIT FOR BUFFER
122244          FI
122244          GO RETU
122245
122245   CNXE: CALL CNVERR; A=:DERROR
122247   RETU: TTMR=:TMR; MLEV; *IOF; MST PIE
122254         GO TERWDX
122255   RBUS
122272
122272   %==============================================================================
122272   % (R)   B B 4 I N W
122272   %
122272   % MON 63: MONITOR CALL ALWAYS RETURNS 8 BYTES FROM A TAD
122272   % CALLED WITH INTERUPT OFF WITH B = INPUT DATAFIELD
122272
122272   SUBR BB4INW
122272   BB4INW: MLEV; *MCL PIE; ION
122275          CALL BISWTAD                              % SET WINDOW
122276          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122300          IF PORTNO=0 THEN A:=TER02; GO EROUT FI    % NOT CONNECTED
122304   POSDA: IF CURMES><7BDAT THEN                     % NOT DATA MESSAGE
122310   NXMES:    CALL GETMES; GO ERR                    % GET NEW MESSAGE
122312             IF A><X:=7BDAT THEN A:=3; GO ERR FI    % CONTROLL MESSAGE
122317          FI
122317          IF REMBYT=0 OR A=-1 GO NXMES              % CURRENT MESSAGE EMPTY
122324
122324   % DATA-MESSAGE WITH AT LEAST ONE BYTE
122324
122324          DBCOU GOSW BYT1,BYT2,BYT3,BYT4,BYT5,BYT6,BYT7,BYT8
122336
122336   BYT1:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DA
122343          MIN DBCOU
122344   BYT2:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DA
122350          A\/LAST; *IRW ALEVB DA
122352          MIN DBCOU
122353   BYT3:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DD
122360          MIN DBCOU
122361   BYT4:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DD
122365          A\/LAST; *IRW ALEVB DD
122367          MIN DBCOU
122370   BYT5:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DL
122375          MIN DBCOU
122376   BYT6:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DL
122402          A\/LAST; *IRW ALEVB DL
122404          MIN DBCOU
122405   BYT7:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DX
122412          MIN DBCOU
122413   BYT8:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DX
122417          A\/LAST; *IRW ALEVB DX
122421
122421   % ALL CHARACTERS COLLECTED, RETURN TO USER
122421          0=:DBCOU; A:=10; *IRW ALEVB DT
122424          GO TAD8RET
122425
122425   % DETERMINE ACTION ON ERRORS
122425   ERR:   IF A<0 GO CNXE                            % XMSG ERROR
122426          IF A=0 GO NXMES                           % MESSAGE EMPTY
122427          IF A=1 OR A=2 THEN
122435             CALL SNDRFI; GO CNXE; GO RETU          % BUFFER EMPTY, SEND RFI
122440          FI
122440          IF A=3 THEN
122443             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122447          FI
122447          GO RETU
122450
122450   CNXE:  CALL CNVERR
122451   EROUT: A=:DERROR; 0=:DBCOU
122453   RETU:  MLEV; *IOF; MST PIE
122456          GO TERWDX
122457   RBUS
122472
122472   %==============================================================================
122472   % (R)   B B 8 I N P
122472   %
122472   % MON 310: MONITOR CALL RETURNS UP TO 8 BYTES FROM A TAD.
122472   % NUMBER OF BYTES READ IS RETURNED IN T-REG. WHEN LAST
122472   % CHARACTER IS READ FROM BUFFER T BIT 17 IS SET TO INDICATE
122472   % BREAK CHARACTER.
122472   % CALLED WITH INTERUPT OFF WITH B = INPUT DATAFIELD
122472
122472   SUBR BB8INP
122472   BB8INP: MLEV; *MCL PIE; ION
122475          CALL BISWTAD                              % SET WINDOW
122476          CALL IEDCHK; GO EROUT                     % INPUT WHILE DELAYED ESCAPE
122500          IF PORTNO=0 THEN A:=TER02; GO EROUT FI    % NOT CONNECTED
122504          0=:DBCOU                                  % ZERO CHARACTER COUNT
122505   POSDA: IF CURMES><7BDAT THEN                     % NOT DATA MESSAGE
122511   NXMES:    CALL GETMES; GO ERR                    % GET NEW MESSAGE
122513             IF A><X:=7BDAT THEN A:=3; GO ERR FI    % CONTROLL MESSAGE
122520          FI
122520          IF REMBYT=0 OR A=-1 GO NXMES              % CURRENT MESSAGE EMPTY
122525
122525   % DATA-MESSAGE WITH AT LEAST ONE BYTE
122525
122525   BYT1:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DA
122532          MIN DBCOU
122533   BYT2:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DA
122537          A\/LAST; *IRW ALEVB DA
122541          MIN DBCOU
122542   BYT3:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DD
122547          MIN DBCOU
122550   BYT4:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DD
122554          A\/LAST; *IRW ALEVB DD
122556          MIN DBCOU
122557   BYT5:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DL
122564          MIN DBCOU
122565   BYT6:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DL
122571          A\/LAST; *IRW ALEVB DL
122573          MIN DBCOU
122574   BYT7:  CALL BYTGET; GO ERR; A=:LAST SHZ 10; *IRW ALEVB DX
122601          MIN DBCOU
122602   BYT8:  CALL BYTGET; GO ERR; A=:LAST; *IRR ALEVB DX
122606          A\/LAST; *IRW ALEVB DX
122610          MIN DBCOU
122611          IF REMBYT=-1 THEN DBCOU BONE 17=:DBCOU FI % LAST CHARACTER, BREAK
122620
122620   % ALL CHARACTERS COLLECTED, RETURN TO USER
122620   OKRET: A:=DBCOU; 0=:DBCOU; *IRW ALEVB DT
122623          GO TAD8RET
122624
122624   % DETERMINE ACTION ON ERRORS
122624   ERR:   IF A<0 GO CNXE                            % XMSG ERROR
122625          IF A=0 GO NXMES                           % MESSAGE EMPTY
122626          IF A=1 OR A=2 THEN
122634             IF DBCOU><0 THEN                       % CHARACTERS TO RETURN
122636                A BONE 17=:DBCOU; GO OKRET          % MARK FOR BREAK
122641             ELSE
122642                CALL SNDRFI; GO CNXE; GO RETU       % BUFFER EMPTY, SEND RFI
122645             FI
122645          FI
122645          IF A=3 THEN
122650             CALL SNDREJ; GO CNXE; A:=TER01; GO EROUT         % MESSAGE REJECTED
122654          FI
122654          GO RETU
122655
122655   CNXE:  CALL CNVERR
122656   EROUT: A=:DERROR; 0=:DBCOU
122660   RETU:  MLEV; *IOF; MST PIE
122663          GO TERWDX
122664   RBUS
122677
122677   *"-BADAD
"122677   @DEV 1
