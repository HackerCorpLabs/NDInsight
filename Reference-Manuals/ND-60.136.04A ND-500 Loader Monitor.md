## Page 1

# ND-500 Loader/Monitor

ND-60.136.04  
Rev. A

---

## Page 2

# ND-500 Loader/Monitor

ND-60.136.04  
Rev. A

---

## Page 3

# NOTICE

The information in this document is subject to change without notice. Norsk Data A.S assumes no responsibility for any errors that may appear in this document. Norsk Data A.S assumes no responsibility for the use or reliability of its software on equipment that is not furnished or supported by Norsk Data A.S.

The information described in this document is protected by copyright. It may not be photocopied, reproduced or translated without the prior consent of Norsk Data A.S.

Copyright © 1982 by Norsk Data A.S.

---

## Page 4

# PRINTING RECORD

| Printing | Notes       |
|----------|-------------|
| 01/81    | Version 01  |
| 07/81    | Version 02  |
| 01/82    | Version 03  |
| 09/82    | Version 04  |
| 05/83    | Revision A  |

The following pages have been revised or added:  
xiii. 68, 69, 99, 147, 158, 170, 172, 172a, 172b, 173, 190

On page 160 the sub-commands PROC-TAB and HW-SEGM-TAB have been removed.

ND-500 Loader/Monitor  
Publ. No. ND 60.136.04A  
May 1983

Norsk Data A.S  
Graphic Center  
P.O. Box 25, Bogerud  
0621 Oslo 6, Norway

---

## Page 5

# PREFACE

## THE PRODUCT

This manual describes

```
Linkage-Loader  ND-10319 version D  
ND-500 Monitor  ND-10320 version C
```

The ND-500 Monitor is an extension of the Sintran III operating system which provides for program execution on the ND-500 computer. The Linkage-Loader runs as an ND-500 program, while the ND-500 Monitor is an integral part of the Sintran III VSE/500 operating system.

The ND-500 memory management system is described in the ND-500 CPU Reference Manual. However, Sintran III does not utilize the hardware fully, as a process may consist of one domain only.

## THE READER

This manual is written for programmers and operators who want to load and run programs on the ND-500. It also describes the Monitor commands available to the system supervisor for maintaining proper control over ND-500 resources.

## PREREQUISITE KNOWLEDGE

The reader is assumed to have some previous knowledge of the ND-500, the ND-100 and the Sintran III operating system. Depending on the intended use of the ND-500 computer, this may vary from knowing how to compile a simple program with only a rudimentary knowledge of the memory management system (for a programmer with timesharing/background requirements only) to familiarity with the hardware configuration, ND-100 segment file and RT loader structure (for the system supervisor).

Necessary information is found in the following manuals:

| Manual                         | Reference    |
|--------------------------------|--------------|
| ND-500 CPU Reference Manual    | (ND-05.009)  |
| SINTRAN III Reference Manual   | (ND-60.128)  |
| SINTRAN III System Supervisor  | (ND-60.103)  |
| SINTRAN III RT Loader          | (ND-60.051)  |
| SINTRAN III Real Time Guide    | (ND-60.133)  |

ND-60.136.04

---

## Page 6

# THE MANUAL

This manual will give the reader information about how to link relocatable modules to make an executable ND-500 program (domain), and how to execute programs on the ND-500 under the Sintran III operating system.

The manual should be used for reference; it is not intended to be a textbook in loader and monitor use. Each command description is independent of others, and can be read without knowing other commands described. However, the first chapters contain some introductory information about the ND-500 system.

A thorough understanding of the ND-500 memory management system and trap handling is required to fully utilize the ND-500. A detailed description may be found in the ND-500 CPU Reference Manual ND-05.009 chapters 4 and 6.

# CHANGES FROM PREVIOUS VERSION

This manual which is a new version (ND-60.136.04) of the previous (ND-60.136.03 of January 1982) is mainly written to document the changes made in the Linkage-Loader and the ND-500 Monitor in conjunction with the H-version of Sintran III. There are changes in some commands, command parameters and monitor calls, and a few commands, and several monitor calls are added.

ND-60.136.04

---

## Page 7

# TABLE OF CONTENTS

| Section                             | Page |
|-------------------------------------|------|
| 1. INTRODUCTION                     | 3    |
| 1.1. Use of the Linkage-Loader and Monitor | 3    |
| 1.1.1. Compilation                  | 3    |
| 1.1.2. Loading                      | 5    |
| 1.1.3. Execution                    | 6    |
| 1.1.4. Multi-segment domains        | 7    |
| 1.2. Command and parameter format   | 9    |
| 1.3. Command syntax                 | 9    |
| 1.4. Naming rules                   | 10   |
| 1.5. The description file           | 11   |
| 1.6. The function of the Linkage-Loader | 12   |
| 1.7. The function of the Monitor    | 13   |
| 2. MEMORY MANAGEMENT SYSTEM         | 15   |
| 2.1. Logical memory structure       | 15   |
| 2.2. Capabilities                   | 17   |
| 3. TRAPS                            | 21   |
| 3.1. Trap handler calling           | 21   |
| 3.2. Use of trap handlers           | 22   |
| 4. STANDARD EXCEPTION HANDLER LIBRARY | 23   |
| 4.1. ND-500 traps table             | 25   |
| 4.2. The EXCEPT routine             | 26   |

ND-60.136.04

---

## Page 8

# Section

| Section                                     | Page |
|---------------------------------------------|------|
| 4.3. The EXCDEF routine                     | 32   |
| 4.4. The EXCTERM routine                    | 34   |
| 4.5. The PRITRAC routine                    | 35   |
| 4.6. The PRIMESS routine                    | 36   |
| 4.7. The GETMESS/PGETMESS routine           | 37   |
| 4.8. The RDEVAL routine                     | 38   |
| 4.9. The RCURVAL routine                    | 39   |

# 5. COMMUNICATION BETWEEN ND-500 AND ND-100

| Section                                     | Page |
|---------------------------------------------|------|
| 5.1. Monitor calls                          | 41   |
| 5.2. Communicating through the process flags | 41   |
| 5.3. Communicating through RTCOMMON         | 42   |
| 5.4. Communicating through an RT segment    | 42   |
| 5.5. Communicating through files            | 43   |

# 6. LOADER COMMANDS

| Section                                     | Page |
|---------------------------------------------|------|
| 6.1. Domains                                | 44   |
| 6.1.1. SET-DOMAIN                           | 44   |
| 6.1.2. END-DOMAIN                           | 44   |
| 6.1.3. CLEAR-DOMAIN                         | 45   |
| 6.1.4. DELETE-DOMAIN                        | 45   |
| 6.1.5. LIST-DOMAIN                          | 46   |
| 6.1.6. WRITE-DOMAIN-STATUS                  | 46   |
| 6.1.7. RENAME-DOMAIN                        | 46   |
| 6.1.8. COPY-DOMAIN                          | 47   |
| 6.1.9. RELEASE-DOMAIN                       | 48   |
| 6.2. Segments                               | 49   |
| 6.2.1. OPEN-SEGMENT                         | 49   |
| 6.2.2. CLOSE-SEGMENT                        | 51   |
| 6.2.3. LINK-SEGMENT                         | 52   |
| 6.2.4. LIBRARY-SEGMENT-LINK                 | 52   |
| 6.2.5. FORCE-SEGMENT-LINK                   | 52   |
| 6.2.6. APPEND-SEGMENT                       | 53   |

ND-60.136.04

---

## Page 9

# Section

|   |   |
|---|---|
| 6.2.7.  | SET-SEGMENT-NUMBER         | 54 |
| 6.2.8.  | CLEAR-SEGMENT              | 54 |
| 6.2.9.  | DELETE-SEGMENT             | 54 |
| 6.2.10. | RENAME-SEGMENT             | 55 |
| 6.2.11. | LIST-SEGMENT               | 55 |
| 6.2.12. | WRITE-SEGMENT-STATUS       | 55 |
| 6.2.13. | DEFINE-SEGMENT-SIZE        | 56 |

## 6.3. Commands to load NRF code

|   |   |
|---|---|
| 6.3.1. | LOAD-SEGMENT                | 57 |
| 6.3.2. | RELOAD-SEGMENT              | 58 |
| 6.3.3. | LIBRARY-SEGMENT-LOAD        | 58 |
| 6.3.4. | OMITTED-SEGMENT-LOAD        | 59 |
| 6.3.5. | SELECTED-SEGMENT-LOAD       | 59 |
| 6.3.6. | TOTAL-SEGMENT-LOAD          | 60 |

## 6.4. COMMON segments

|   |   |
|---|---|
| 6.4.1. | COMMON-SEGMENT-OPEN         | 61 |
| 6.4.2. | COMMON-SEGMENT-CLOSE        | 62 |
| 6.4.3. | COMMON-SEGMENT-APPEND       | 62 |
| 6.4.4. | COMMON-SEGMENT-NUMBER       | 62 |

## 6.5. Auto-link segments

|   |   |
|---|---|
| 6.5.1. | SET-AUTO-LINK-SEGMENT       | 63 |
| 6.5.2. | DELETE-AUTO-LINK-SEGMENT    | 64 |
| 6.5.3. | LIST-AUTO-LINK-SEGMENTS     | 64 |

## 6.6. Auto-load files

|   |   |
|---|---|
| 6.6.1. | SET-AUTO-LOAD-FILE          | 65 |
| 6.6.2. | DELETE-AUTO-LOAD-FILE       | 66 |
| 6.6.3. | LIST-AUTO-LOAD-FILE         | 66 |

## 6.7. Label and reference handling

|   |   |
|---|---|
| 6.7.1.  | PROGRAM-REFERENCE           | 67 |
| 6.7.2.  | DATA-REFERENCE              | 68 |
| 6.7.3.  | DEFINE-ENTRY                | 68 |
| 6.7.4.  | DEFINE-COMMON               | 69 |
| 6.7.5.  | LIST-ENTRIES-DEFINED        | 69 |
| 6.7.6.  | LIST-ENTRIES-UNDEFINED      | 70 |
| 6.7.7.  | LIST-MAP                    | 70 |
| 6.7.8.  | SYSTEM-ENTRIES-ON           | 70 |
| 6.7.9.  | GLOBAL-ENTRIES              | 71 |
| 6.7.10. | KILL-ENTRIES                | 71 |

## 6.8. Areas shared with ND-100 processes

|   |   |
|---|---|
| 6.8.1. | MATCH-RTCOMMON              | 72 |
| 6.8.2. | MATCH-COMMON-RT-SEGMENT     | 72 |
| 6.8.3. | LINK-RT-PROGRAM             | 73 |

## 6.9. Miscellaneous commands

|   |   |
|---|---|
| 6.9.1. | PAGE-MODE                   | 74 |
| 6.9.2. | LOW-ADDRESS                 | 74 |
|        | HIGH-ADDRESS                | 75 |

ND-60.136.04

---

## Page 10

# Section

| Section | Page |
|---------|------|
| 6.9.4. ENTRY-ROUTINES | 75 |
| 6.9.5. SET-IO-BUFFERS | 76 |
| 6.9.6. LIST-OCTAL | 76 |
| 6.9.7. LIST-SYMBOLIC | 77 |
| 6.9.8. LIST-MODE | 77 |
| 6.9.9. DISASSEMBLE-MODE | 77 |
| 6.9.10. CHECK-SYNTAX-MODE | 78 |
| 6.9.11. RESET | 78 |
| 6.9.12. RENAME-DEFAULT-DIRECTORY-AND-USER | 78 |
| 6.9.13. SUPPRESS-DEBUG-INFORMATION | 79 |
| 6.9.14. COMPUTER-MODE | 79 |

## 6.10. NRF editor

| Section | Page |
|---------|------|
| 6.10.1. NEW-NRF-MODULES | 81 |
| 6.10.2. FETCH-NRF-MODULES | 81 |
| 6.10.3. APPEND-NRF-MODULE | 82 |
| 6.10.4. DELETE-NRF-MODULES | 82 |
| 6.10.5. LIST-NRF-ENTRIES | 83 |
| 6.10.6. LIST-NRF-CODE | 83 |
| 6.10.7. WRITE-NRF-EOF-AFTER-MODULE | 84 |
| 6.10.8. INSERT-NRF-MESSAGE | 84 |
| 6.10.9. PREPARE-NRF-LIBRARY-FILE | 85 |

# 7. COMMANDS AVAILABLE IN THE NLL AND THE MONITOR

Page 86

## 7.1. Utility commands

| Section | Page |
|---------|------|
| 7.1.1. HELP | 86 |
| 7.1.2. LIST-DOMAIN | 86 |
| 7.1.3. OUTPUT-FILE | 87 |
| 7.1.4. RUN | 87 |
| 7.1.5. @ (Sintran-III command) | 87 |
| 7.1.6. CC | 88 |
| 7.1.7. ABORT-BATCH-ON-ERROR | 88 |
| 7.1.8. EXIT | 88 |

## 7.2. Trap handling

| Section | Page |
|---------|------|
| 7.2.1. LOCAL-TRAP-ENABLE | 90 |
| 7.2.2. LOCAL-TRAP-DISABLE | 90 |
| 7.2.3. SYSTEM-TRAP-ENABLE | 91 |
| 7.2.4. SYSTEM-TRAP-DISABLE | 91 |

## 7.3. VALUE-ENTRIES

Page 91

# 8. MONITOR COMMANDS

Page 93

## 8.1. Commands for running an ND-500 program

| Section | Page |
|---------|------|
| 8.1.1. PLACE-DOMAIN | 93 |

ND-60.136.04

---

## Page 11

# Section

| Section | Page |
|---------|------|
| 8.1.2. RECOVER-DOMAIN | 94 |
| 8.1.3. GO | 95 |
| 8.1.4. CONTINUE | 95 |

## 8.2. Standard domains
| Section | Page |
|---------|------|
| 8.2.1. DEFINE-STANDARD-DOMAIN | 96 |
| 8.2.2. DELETE-STANDARD-DOMAIN | 97 |
| 8.2.3. LIST-STANDARD-DOMAINS | 97 |

## 8.3. Input and output
| Section | Page |
|---------|------|
| 8.3.1. OPEN-FILE | 98 |
| 8.3.2. CLOSE-FILE | 99 |
| 8.3.3. LIST-OPEN-FILES | 99 |
| 8.3.4. SET-BLOCK-SIZE | 100 |
| 8.3.5. Error returns | 102 |
| 8.3.6. Direct file transfer with RFILE and WFILE (disk) | 104 |
| 8.3.7. Direct file transfer with MAGTP (magnetic tape) | 105 |
| 8.3.8. Terminal I/O | 106 |

## 8.4. Macro commands
| Section | Page |
|---------|------|
| 8.4.1. DEFINE-MACRO | 107 |
| 8.4.2. Macro subcommands | 108 |
| 2.1. IF-ERROR-MACRO-STOP | 108 |
| 2.2. IF-ERROR-FULL-STOP | 108 |
| 2.3. NOLIST | 108 |
| 2.4. LIST | 108 |
| 8.4.3. EXECUTE-MACRO | 109 |
| 8.4.4. RESUME-MACRO | 110 |
| 8.4.5. ERASE-MACRO | 110 |
| 8.4.6. DUMP-MACRO | 110 |
| 8.4.7. LIST-MACRO | 111 |

## 8.5. Debugging commands
| Section | Page |
|---------|------|
| 8.5.1. DEBUGGER | 112 |
| 8.5.2. SPECIAL-DEBUGGER | 113 |
| 8.5.3. DEBUG-PLACE | 113 |
| 8.5.4. BREAK | 113 |
| 8.5.5. TEMPORARY-BREAK | 114 |
| 8.5.6. STEP | 114 |
| 8.5.7. LOOK-AT commands | 115 |
| 7.1. LOOK-AT-PROGRAM | 118 |
| 7.2. LOOK-AT-DATA | 118 |
| 7.3. LOOK-AT-STACK | 119 |
| 7.3.1. Subcommands PREVIOUS and NEXT | 119 |
| 7.4. LOOK-AT-RELATIVE | 119 |
| 7.5. LOOK-AT-REGISTER | 120 |
| 8.5.8. SET-MEMORY-CONTENTS | 120 |
| 8.5.9. MAIN-FORMAT | 120 |
| 8.5.10. EXTRA-FORMAT | 121 |
| 8.5.11. TRACE | 122 |
| 8.5.12. GUARD | 122 |
| 8.5.13. BRANCH-TRACE | 123 |
| 8.5.14. CALL-TRACE | 123 |

---

## Page 12

# Section

| Section                                             | Page |
|-----------------------------------------------------|------|
| 8.5.15. EXHIBIT-ADDRESS                             | 124  |
| 8.5.16. DEBUG-STATUS                                | 124  |
| 8.5.17. ENABLED-TRAPS                               | 124  |
| 8.5.18. STATUS                                      | 125  |

## 8.5.19. RESET commands                             

| Command              | Page |
|----------------------|------|
| 19.1. RESET-DEBUG    | 125  |
| 19.2. RESET-BREAKS   | 125  |
| 19.3. RESET-LAST-BREAK| 126  |
| 19.4. RESET-TRACE    | 126  |
| 19.5. RESET-GUARD    | 126  |
| 19.6. RESET-CALL-TRACE| 126  |
| 19.7. RESET-BRANCH-TRACE| 126  |

# 8.6. Commands for performance measurement

## 8.6.1. Histogram commands

| Command              | Page |
|----------------------|------|
| 1.1. SET-HISTOGRAM   | 127  |
| 1.2. START-HISTOGRAM | 128  |
| 1.3. STOP-HISTOGRAM  | 128  |
| 1.4. PRINT-HISTOGRAM | 128  |
| 1.5. RELEASE-HISTOGRAM| 128  |

## 8.6.2. Monitor call logging

| Command                  | Page |
|--------------------------|------|
| 2.1. START-MONCALL-LOG   | 129  |
| 2.2. PRINT-MONCALL-LOG   | 129  |
| 2.3. STOP-MONCALL-LOG    | 130  |

## 8.6.3. Process logging

| Command                     | Page |
|-----------------------------|------|
| 3.1. START-PROCESS-LOG-ALL  | 130  |
| 3.2. START-PROCESS-LOG-ONE  | 130  |
| 3.3. PRINT-PROCESS-LOG      | 131  |
| 3.4. PROCESS-LOG-ALL        | 131  |
| 3.5. PROCESS-LOG-ONE        | 131  |
| 3.6. RELEASE-LOG-BUFFER     | 132  |

## 8.6.4. SWAPPING-LOG

| Command         | Page |
|-----------------|------|
| SWAPPING-LOG    | 132  |

## 8.6.5. LIST-EXECUTION-QUEUE

| Command                  | Page |
|--------------------------|------|
| LIST-EXECUTION-QUEUE     | 133  |

# 8.7. Process communication and synchronization

| Section                         | Page |
|---------------------------------|------|
| 8.7.1. Process names and numbers| 134  |
| 8.7.2. SET-PROCESS-NAME         | 134  |

## 8.7.3. Process creation and termination

| Section             | Page |
|---------------------|------|
| 8.7.4. RESTART-PROCESS | 135 |
| 8.7.5. Process communication flags| 135 |

| Section    | Page |
|------------|------|
| 8.7.6. GET-FLAG | 136 |
| 8.7.7. SET-FLAG | 136 |

# 8.8. Memory allocation

| Section                                    | Page |
|--------------------------------------------|------|
| 8.8.1. Demand paging                       | 137  |
| 8.8.2. "Fixing" in memory                  | 137  |
| 8.8.3. Limiting the number of pages in memory | 138 |

## 8.8.4. "Fixing" programs in memory

| Section                                    | Page |
|--------------------------------------------|------|
| 8.8.5. Fixing segments scattered in memory | 139  |

## 8.8.6. Fixing segments in contiguous memory

| Section                                          | Page |
|--------------------------------------------------|------|
| 8.8.7. Fixing segments in an absolute location   | 141  |
| 8.8.8. Fixing segments shared by several processes| 141  |

## 8.8.9. Unfixing a segment

| Section                | Page |
|------------------------|------|
| Unfixing a segment     | 142  |

ND-60.136.04

---

## Page 13

# Section

| Section                                           | Page |
|-----------------------------------------------------|------|
| 8.8.10. The swapping strategy                        | 143  |
| 8.8.11. SET-SEGMENT-LIMITS                           | 145  |
| 8.8.12. FIX-SEGMENT-SCATTERED                        | 146  |
| 8.8.13. FIX-SEGMENT-CONTIGUOUS                       | 146  |
| 8.8.14. FIX-SEGMENT-ABSOLUTE                         | 147  |
| 8.8.15. UNFIX-SEGMENT                                | 147  |
| 8.8.16. RESIDENT-PLACE                               | 147  |

## 8.9. Miscellaneous commands

| Command                                             | Page |
|-----------------------------------------------------|------|
| 8.9.1. AUTOMATIC-ERROR-MESSAGE                       | 148  |
| 8.9.2. RESET-AUTOMATIC-ERROR-MESSAGE                 | 148  |
| 8.9.3. The "Escape" key                              | 148  |
| 8.9.4. TIME-USED                                     | 148  |
| 8.9.5. WHO-IS-ON                                     | 149  |
| 8.9.6. LIST-ACTIVE-PROCESSES                         | 149  |
| 8.9.7. VERSION                                       | 149  |
| 8.9.8. SET-PRIORITY                                  | 149  |

## 8.10. Commands for the System Supervisor

| Command                                             | Page |
|-----------------------------------------------------|------|
| 8.10.1. SET-ND-500-UNAVAILABLE                       | 151  |
| 8.10.2. SET-ND-500-AVAILABLE                         | 151  |
| 8.10.3. STOP-ND-500                                  | 152  |
| **8.10.4. Memory configuration**                     | 152  |
| 4.1. DEFINE-MEMORY-CONFIGURATION                     | 152  |
| 4.2. MEMORY-CONFIGURATION                            | 153  |
| **8.10.5. Memory administration**                    |      |
| 5.1. GIVE-ND-500-PAGES                               | 153  |
| 5.2. TAKE-ND-500-PAGES                               | 154  |
| **8.10.6. Microprogram maintainance**                | 155  |
| 6.1. MICRO-STOP                                      | 155  |
| 6.2. MICRO-START                                     | 155  |
| 6.3. LOAD-CONTROL-STORE                              | 155  |
| 6.4. COMPARE-CONTROL-STORE                           | 156  |
| 6.5. LOOK-AT-CONTROL-STORE                           | 156  |
| **6.5.1. Subcommands EDIT and ORIN**                 | 157  |
| **6.5.2. Subcommands OCTAL and SYMBOLIC**            | 157  |
| **6.5.3. Subcommands GROUP and WORD**                | 157  |
| **8.10.7. LOOK-AT commands**                         | 157  |
| 7.1. LOOK-AT-RESIDENT-MEMORY                         | 157  |
| 7.2. LOOK-AT-PHYSICAL-SEGMENT                        | 158  |
| 7.3. LOOK-AT-HARDWARE                                | 158  |
| **8.10.8. Process management**                       | 159  |
| 8.1. ATTACH-PROCESS                                  | 159  |
| 8.2. LOGOUT-PROCESS                                  | 159  |
| 8.3. ABORT-PROCESS                                   | 159  |
| 8.4. PROCESS-STATUS                                  | 160  |
| **8.10.9. Inspecting system tables**                 | 160  |
| 9.1. LIST-TABLE                                      | 160  |
| 9.2. LIST-ACTIVE-SEGMENTS                            | 161  |
| 9.3. LIST-SEGMENT-TABLE-ENTRY                        | 161  |
| 9.4. LIST-PROCESS-TABLE-ENTRY                        | 161  |
| **8.10.10. Swap files**                              | 162  |
| 10.1. DEFINE-SWAP-FILE                               | 162  |
| 10.2. DELETE-SWAP-FILE                               | 162  |

---

## Page 14

# Section

| | |
|---|---|
| 10.3. LIST-SWAP-FILE-INFO | 163 |
| 10.4. LOAD-SWAPPER | 163 |
| 10.5. START-SWAPPER | 163 |
| 8.10.11. SET-SYSTEM-PARAMETERS | 164 |
| 8.10.12. LIST-SYSTEM-PARAMETERS | 165 |
| 8.10.13. MASTER-CLEAR | 165 |

## 9. SINTRAN-III MONITOR CALLS

167

## 10. THE N500M MONITOR CALL

177

## 11. DESCRIPTION FILE LAYOUT

181

## 12. THE ND RELOCATABLE FORMAT

### 12.1. DESCRIPTION

185

### 12.2. NRF control numbers

186

### 12.3. Summary of NRF control numbers

191

## 13. LINKAGE-LOADER ERROR MESSAGES

193

## 14. ND-500 MONITOR ERROR MESSAGES

202

## 15. EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

218

### 15.1. Executing an ND-500 domain

218

### 15.2. Using libraries

219

### 15.3. Using files

221

### 15.4. Macros

222

### 15.5. Debugging

223

### 15.6. System Supervisor: Installing NLL

225

### 15.7. LIST OF MONITOR COMMANDS

227

### 15.8. LIST OF LINKAGE-LOADER COMMANDS

230

ND-60.136.04

---

## Page 15

# Section

| Section | Page |
|---------|------|
| INDEX   | 233  |

ND-60.136.04

---

## Page 16

# 1. INTRODUCTION

## 1.1. Use of the Linkage-Loader and Monitor

An ND-500 program goes through two main steps before it is ready for execution:

- **compilation**, transforming a human readable program into machine code

- **loading**, combining the user program and subroutines with library routines, and assigning the program a specific position in memory

### 1.1.1. Compilation

The compilation is performed by a compiler specific to the language of the source program: a Fortran compiler, a Pascal compiler, a Planc compiler or a Cobol compiler. The compiler may run in the ND-100, even if the compiled program will be running in the ND-500. More commonly, even the compiler runs in the ND-500.

A compiler running in the ND-500 is operated in exactly the same way as an ND-100 compiler. However, in order to start it, the name of the ND-500 monitor must preceed the compiler name:

```
@ND-500 FORTRAN
```

"ND-500" is (an abbreviation of) the name of the monitor. The monitor is a rather complex system controlling the ND-500 computer, but for the beginner, "ND-500" may be viewed simply as a message to the operating system requesting program execution in the ND-500 rather than the ND-100.

"FORTRAN" is the name of the Fortran compiler. Generally, compilers have the name of the language they compile, followed by the machine the code is made for. The full name of the Fortran compiler is FORTRAN-500, but in most installations, an abbreviation is unambiguous.

A program is compiled with the COMPILE command:

```
@ND-500 FORTRAN
ND-500 ANSI 77 FORTRAN COMPILER - NOVEMBER 24, 1981
FTN: COMPILE TESTPROG,"TESTPROG:LIST","TESTPROG"
```

- CPU TIME USED: 3.2 SECONDS. 750 LINES COMPILED.
- NO MESSAGES
- CODE SIZE=3644 DATA SIZE=403 COMMON SIZE=0 STACK SIZE=654
FTN: EXIT

ND-60.136.04

---

## Page 17

I can't view the content of the image you uploaded. Please provide the text or a description of the page for me to assist you with converting it to Markdown.

---

## Page 18

# Introduction

The default file type of the code file generated by all ND-500 compilers is .NRF, while the default file type of ND-100 compilers is .BRF. Thus, if the same file is compiled for both computers, the code files may be given the same name without causing a name conflict.

## 1.1.2. Loading

After compilation, there is no principal difference between programs and subroutines in different languages, and they are all loaded using the same loader. The loader is called by the command

`@ND-500_LINKAGE-LOADER`

The LINKAGE-LOADER is often simply called NLL, after its prompt NLL:.

NLL will create a program ready for execution. In the ND-500, a program is termed a domain. A domain usually has a name, used when starting execution. It may also be "unnamed" - actually, it then has the standard name SCRATCH-DOMAIN. Any permanent domain should be given a name; each time a file is loaded to an unnamed domain, it will overwrite the previous contents of SCRATCH-DOMAIN. It may, however, be convenient to omit the naming of the domain during the debug phase of a program.

A domain is named before anything is loaded to it, by the NLL command

`NLL: SET-DOMAIN "MY-DOMAIN"`

The double quotes indicate that this is a new domain, used exactly like double quotes to create a new file (however, the domain is not a file). If no double quotes are used, an existing domain will be overwritten. (This is strictly true only for simple use of NLL.)

The code file generated by the compiler is loaded by the command

`NLL: LOAD-SEGMENT TESTPROG`

Several files may be named in the LOAD-SEGMENT command; for example, the main program and subroutines may be compiled separately, to different code files. Also, several LOAD-SEGMENT commands may be used in succession.

After all files required have been loaded, NLL is left through the command

`NLL: EXIT`

A number of operations are performed in the EXIT command; references to the required libraries are set up, the default handling of errors is defined, the appropriate files are updated and the file access on new files set.

---

## Page 19

# Introduction

As mentioned, the domain is not a file, nor is any program file explicitly specified. This does not imply that there are no files used – the loaded code is stored in files manipulated by NLL. These have types :PSEG, :DSEG and :LINK, and (by default) names chosen by NLL. In addition, there is a file called DESCRIPTION-FILE:DESC. For all practical purposes, these files are invisible to the programmer - he will always identify his program by its domain name.

## 1.1.3. Execution

A user domain is started by typing the name of the ND-500 monitor followed by the domain name:

```
@ND-500 DOMAIN-NAME
```

This is exactly like the way a compiler running in the ND-500 is started; "ND-500" is a message informing Sintran that the program is to be executed in the ND-500 computer rather than the ND-100.

Communication with the user through the terminal is exactly as for an ND-100 program, as are file access and access to various devices. Pushing the escape or break key will interrupt the program and return control to Sintran.

The user may also type "ND-500" without following it by a domain name. This will start the monitor, and give control to the command processor of the monitor:

```
@ND-500
ND-500 MONITOR 81.11.14/81.11.04
N500:
```

Execution of a domain may now be started simply by typing its name:

```
N500: DOMAIN-NAME
```

After execution, control returns to the command processor of the monitor, rather than to Sintran, and another domain may be executed. As an alternative to first starting the compiler by @ND-500 FORTRAN, then NLL by @ND-500 LINKAGE-LOADER and finally the program by @ND-500 DOMAIN-NAME, they may be run by the command sequence

```
@ND-500
N500: FORTRAN
FTN: <compiler commands>
FTN: EXIT
N500: LINKAGE-LOADER
NLL: <loader commands>
NLL: EXIT
N500: DOMAIN-NAME
<program input/output to terminal>
N500: EXIT
@ 
```

---

## Page 20

# INTRODUCTION

Even if **execution is interrupted** by the escape or break key, return will be to the monitor. **All files are then kept open**, and **execution** may be resumed by the **CONTINUE command**.

The command processor of the monitor will interpret and execute a large set of commands, described in chapter 8 of this manual. The majority of these are highly specialized commands and commands for the system supervisor.

Regardless of its complexity, a program system is executed simply by stating its name.

## 1.1.4. Multi-segment domains

A set of **subroutines** used in **several domains** will, if **loaded by the LOAD-SEGMENT** command together with the main program, occupy space in each and every domain it is used. In order to **save file space** (and also memory space if the two domains are executed concurrently), these routines may be **grouped together and put on a segment**, a "slice" of the addressing area that may be treated independently of the other slices (segments).

If **only one segment** is used, that segment is usually "unnamed" - it is given a **standard name** by NLL, which may be ignored by the user. A segment used by **several domains should be given a more descriptive name**. This is done by explicitly **opening** a segment (after the domain has been named):

```
NLL: SET-DOMAIN "TWO-SEG-DOMAIN"
NLL: OPEN-SEGMENT "SUBROUTINES", P
```

A new segment is created by enclosing the name in double quotes, as shown above. If the quotes are not included, new information will overwrite what is already loaded to the segment.

"P" **is an attribute code** that allows this segment to be used by other domains as well. Now, the subroutines that are common to several segments are loaded by a LOAD-SEGMENT command:

```
NLL: LOAD-SEGMENT SUBR-FILE
```

When **all common subroutines** have been **loaded** (possibly from several files), the subroutine segment is closed by the command

```
NLL: CLOSE-SEGMENT
```

after which the main program (and possibly non-common subroutines) is loaded as usual. But before the EXIT command, the user should **link the subroutine-segment to the main program** by the command

```
NLL: LINK-SEGMENT SUBROUTINES
```

There may be **more than one subroutine segment**, each of them opened with the OPEN-SEGMENT command and terminated with a CLOSE-SEGMENT, and they should all be listed as parameters to the LINK-SEGMENT command.

ND-60.136.04

---

## Page 21

# Introduction

The complete set of commands for loading a two-segment program is therefore, complete with the response from NLL:

NLL: SET-DOMAIN "TWO-SEGMENTS"  
NLL: OPEN-SEGMENT "SUBROUTINES" P  
NLL: LOAD-SEGMENT SUBR-FILE  
Program: ..........44660B P | Data: ..........17344B D  
NLL: CLOSE-SEGMENT  
Segment no. ..........30 | is linked  
NLL: SET-SEGMENT-NUMBER 2  
NLL: LOAD-SEGMENT MAINPROG  
NLL: LINK-SEGMENT SUBROUTINES  
Segment no. .......... 1 | is linked  
NLL: EXIT  
Segment no. ..........30 | is linked  

(Segment no. 30 contains the Fortran library, and will in most installations be linked automatically, as the example above).

When loading the second and following domain using the routines in the SUBROUTINES segment, the files are already loaded. The OPEN-SEGMENT, LOAD-SEGMENT SUBR-FILE and CLOSE-SEGMENT commands are omitted. Only the main program segment is loaded, followed by the LINK-SEGMENT command (force segment link).

A slight problem occurs with the segment numbers; each segment has a fixed number between 0 and 31, which must be unique within the domain. By default, new segments are given the first number available, starting at 1; thus the SUBROUTINES segment above is number 1. When a segment is created in a new domain that will also be linked to the SUBROUTINES segment, another segment number should be selected for the main program and other segments. This is done by the commands

NLL: SET-DOMAIN "SECOND-DOMAIN"  
NLL: SET-SEGMENT-NUMBER 2  
NLL: LOAD-SEGMENT SECOND-DOMAIN  
Program: ..........766B P | Data: ..........244B D  
NLL: LINK-SEGMENT SUBROUTINES  
Segment no. .......... 1 | is linked  
NLL: EXIT  

If the SUBROUTINES segment will be linked to a high number of main programs, it may be more convenient to set the segment number of the SUBROUTINES segment, leaving segment number 1 (the default value) for the various main segments.

If two or more subroutine segments are used by one domain, they must all have different segment numbers.

---

## Page 22

# INTRODUCTION

## 1.2. Command and parameter format

Normally, the user communicates with NLL and the Monitor through a terminal. The terminal is called the communication device. In a batch or mode job the communication device is the command input file for input and the output file for output.

Information returned from command execution is usually written to the communication device. Such output may be directed to another file or device by the OUTPUT-FILE command. The current file used for output is called the output device, whether this is the same as the communication device or another file.

Commands to NLL and the Monitor may be given in upper or lower case letters. Commands and parameters are terminated by comma, space or carriage return. If required parameters are not supplied, they are prompted for with the names of the parameters. Parameters may be left out by typing two successive commas in the command line, or pressing CR (Carriage Return) in response to the prompt. If a parameter is not supplied, the default value is used if it exists.

Numeric parameters are specified in octal, unless the number is followed by a D, indicating decimal format, or H, indicating hexadecimal format. If a hexadecimal number does not start with a digit, it must be preceeded by a (redundant) leading zero to avoid confusion with alphanumeric symbols.

## 1.3. Command syntax

When describing the commands available in the Monitor and NLL the following rules are applied:

- The command name is used as a section header.
- All parameters are enclosed in < > brackets.
- If a parameter that is asked for has a default value, its name is also enclosed in ( ) brackets.
- The names of optional parameters that are not asked for are enclosed in [ ] brackets.
- If more than one value may be specified the right enclosing bracket is followed by an ellipsis, as in <>...

All command, domain and segment names may be abbreviated as long as they are unambiguous. Most of the command names follow two rules:

- The first word in the command describes the action.
- The second word in the command describes the subject the action is going to be taken upon.

ND-60.136.04

---

## Page 23

# INTRODUCTION

If, for instance, the command HELP is used in the following way:

HELP -SEGMENT

all commands concerning segment manipulation are printed on the output device.

New domains and segments are created by surrounding the name with double quotes ("). Double quotes are only valid in commands with a name as a parameter. These commands are: SET-DOMAIN, OPEN-SEGMENT, and COMMON-SEGMENT-OPEN. If the double quotes are not used, the named object (domain or segment) is assumed to exist.

NLL will prompt for required but missing parameters. Multiple parameters will be asked for the first time, and the full range of Sintran III editing characters is available. If the first character of a command line is '@', the command is taken to be a Sintran III command. The character '&' means that the input line continues on the next line.

In interactive mode, all list output can be temporarily stopped by typing any character on the input device. The output is resumed when another character is typed. In order to terminate the listing, an '!' may be typed.

The ND-500 Monitor is started by typing ND-500-MONITOR in response to the Sintran III prompt. A domain name may follow on the same line, implying a RECOVER-DOMAIN command with this name as parameter. If no domain name was specified on the call line, the ND-500 Monitor will prompt for commands with "N5000: ". The rules for parameter specification are the same as in NLL. Wherever a parameter from a list of valid values is expected, "HELP!" may be written. This will cause the possible choices for the parameter values to be printed on the communications device. (Obviously, this does not apply where an arbitrary string, such as a domain name, may be specified.)

## 1.4. Naming rules

Segments and domains are referred to by name in NLL and the Monitor. The name of a segment is equal to the name of the segment files. The program, data, and symbol files of a segment have the same name, but are distinguished by their types: ;PSEG, ;DSEG and ;LINK respectively. As segment names coincide with file names, the segment name syntax follows the Sintran III file name syntax, and the segment name must be unique in the current user's file catalog. The file type may not be modified.

Domain names may - like segment names - contain alphanumerics and hyphens, and may coincide with segment names. Maximum length is 16 characters, and lower case characters are converted to upper case.

---

## Page 24

# INTRODUCTION

## 1.5. The description file

The *names of segments and domains* are found in a file called `DESCRIPTION-FILE:DESC`. Each named object (*segment or domain*) has an entry in this file, containing all information needed by NLL and the Monitor. For example, the domain entry - one for each domain - contains the name of the domain, a table of the segment files of which the domain consists, information about the relationships to other domains, the size and the start address of the domain, and information relevant to the internal operation of the Monitor.

**Every user of NLL has his own description file, which is created and initialized the first time the user starts NLL.**

Although all domains of a user are described in one file, the same user can access NLL from several terminals simultaneously; NLL will see to it that access conflicts are resolved. If attempts are made to modify the same domain from two terminals simultaneously, one of the users will get an error message.

**A word of warning:**

The contents of the description file at any time reflects the state of the segment and domain definitions of the current user. The user should take great care to never make any modifications to the segment files or the description file, except *through NLL*. Otherwise inconsistencies may arise, and it may be necessary to rebuild the description file, thereby losing all information about previously loaded segments. 

ND-60.136.04

---

## Page 25

# 1.6. The Function of the Linkage-Loader

The output from language processors (compilers, assemblers) is in the form of relocatable modules. The term 'relocatable' means that the modules are not assigned a fixed position, but may be placed anywhere in memory. Modules are not dependent on being placed in any specific sequence.

NLL is a subsystem able to convert relocatable object files in ND Relocatable Format (NRF) created by language subsystems, to independent executable programs, or processes.

A process is a set of instructions to be executed in a sequential manner, and its associated data. The simplest process possible consists of one segment in one domain; a more complex process may consist of up to 32 segments. A segment is built by NLL, on three separate files: one file contains the instructions: the program segment; another contains the data: the data segment; the third contains the names and values of all labels and optional debugging information, and is called the :LINK file.

A domain is an addressing space, divided into segments. Domains and segments are described in detail in the ND-500 CPU Reference manual ND-05.009.

Information about intermodule references, symbols and labels is coded in the file that is output from compilers. The format of this code is such that procedure calls or references to global data are made through symbols, that is, alphanumeric (symbolic) names assigned to an instruction or data item. These symbols are made by the language processor (often based on user assigned names in the source program), and are referred to as 'labels'.

At execution time, references are made to addresses rather than to labels. The conversion from relocatable symbols to machine addresses is done by NLL. NLL will maintain a table, called the loader table, where symbols are entered as they are encountered.

A symbol may refer to a machine address or it may be a data value. If the first occurrence of a symbol is its definition, then the loader will enter the symbol name into the loader table together with the address where it is defined or together with its data value. In either case, the value associated with the symbol is simply called the symbol's value. Whenever a reference to the label is later encountered, the symbolic reference is replaced with the value found in the loader table.

If a reference is made to a label before it has been defined, space is left open in the loaded code for later insertion of its value. The symbol is entered in the loader table, but rather than containing a value of the label, the table contains a reference to where the symbol is used. As soon as a definition of the label is read, the loader will fill in the now defined value wherever a reference has been made.

| Symbol | Description |
|--------|-------------|
| NLL    | Linkage-loader subsystem |
| NRF    | ND Relocatable Format |
| :LINK file | Contains names, values, and debugging info |

---

## Page 26

# INTRODUCTION

If *two* definitions of one label are encountered, the loader cannot distinguish between them, and an error message is issued. In such cases, the first definition of the label always applies.

Before the program is ready for execution, the loader must ensure that all symbolic references are replaced with numeric values/addresses. To achieve this, it may be necessary to load libraries, either by the user or automatically. The loader is able to distinguish between a required and a not required module in a library.

## A note on the terminology:

In this manual, the term 'reference' is used to describe a symbol that has been entered into the loader table, but has not yet been defined. An 'undefined entry' is equivalent to a reference. The term 'label' is used for a symbol which has been assigned a value in the loader table; it may have been referenced or not. A 'defined entry' is equivalent to a label. 'Symbol' is the general term for all symbolic (alphanumeric) names, but is mostly used for names not yet in the loader table.

The term 'loading' is sometimes used in the sense 'bring into memory for execution'. Another interpretation is 'to fetch relocatable program units and link together to an executable program'.

In this manual, as in all ND software, the latter usage is adopted. The bringing of a program into memory for execution will in most cases be completely invisible to the user of the program; he may consider the program file to be directly executable.

In the cases where the program is read into physical memory, different terms are employed to describe this depending on the specific situation, such as 'starting execution' or "'fixing"' a segment'.

## 1.7. The function of the Monitor

The ND-500 computer has no capabilities to communicate directly with the "outer world". Nor does it have an elaborate operating system administering users' processes and system resources.

Such tasks are executed by the ND-100 CPU. The functions performed are manifold; some of the more important ones are:

The user will always communicate with the ND-100 machine. When he enters the Monitor, he enters a program that has the capability of transforming the user requests into orders to the ND-500. For example, when execution of a program is started through the RECOVER-DOMAIN command, the Monitor will open the files required, reserve a scratch area for data that is modified during execution, create a table entry in a system table identifying the user of the system resources and so on. When all administrative work is complete, a message is sent to the ND-500 requesting execution of the program.

ND-60.136.04

---

## Page 27

# Introduction

During execution, the program may request input or output of data, may request system information (such as the time of day etc.) or other services that the operating system provides. Such requests are not handled in the ND-500, but are transferred to the Monitor. The Monitor will initiate an I/O operation, obtain the requested information or perform the operation required, before the result of the request is returned to the program in ND-500.

If an error occurs in the ND-500 and is not taken care of by the user program, the error is reported to the Monitor, and it may take recovery actions, or possibly abort the job with an error message sent to the user. If one program monopolizes the CPU for a certain period of time, the Monitor will intervene, and temporarily suspend the program, letting other programs execute in the meantime.

In the debugging phase of a program, the Monitor may act as a supervisor of the user program, providing the user with commands to inspect and modify the program during execution. As the code required to fetch information about the user program is a part of the Monitor, the program being debugged may be compiled and loaded exactly like a production program. This guarantees that the results produced are unaffected by debugging instructions.

The Monitor also performs a number of system oriented tasks, such as book-keeping of resource usage, preventing unauthorized users from executing privileged functions etc. Because all communication with the ND-500 is channeled through the Monitor, the interface between the user and his program may look exactly as if there were only one CPU (except for the starting of the Monitor). Letting the ND-100 perform all administrative tasks also frees the ND-500 for user programs. The two processors may work in parallel, with the ND-500 executing a user program while the ND-100 prepares the next job.

ND-60.136.04

---

## Page 28

# MEMORY MANAGEMENT SYSTEM

## 2. MEMORY MANAGEMENT SYSTEM

The maximum program size that ND-500 is able to handle is too large to handle as one unit, both for man and machine. A logical subdivision is done by splitting a domain into **segments**, where each segment is of a more manageable size, and the interface between the segments is clearly defined. This subdivision is handled by the machine by its memory management system. The architecture of this system will to some degree affect large programs and programs with special communication requirements.

Understanding the information in this chapter is not required for running most ordinary programs. Nevertheless, it provides the background information necessary in order to understand the use of all commands described in the manual.

### 2.1. Logical memory structure

An ND-500 addressing space is called a DOMAIN. A domain contains an executable program that can be started through the ND-500 Monitor. For practical purposes a domain may be considered equivalent to a program.

The address range of a domain may vary from 2k bytes up to 4 gigabytes, equivalent to a 32 bit address space. Instructions and data are, however, kept fully separated, and, in fact, a domain contains one area for instructions and another for data. These cover the same address range, but as instructions may never be read as data, or data executed as instructions, no conflicts arise.

A domain is divided into SEGMENTS. A domain comprises from one to 32 segments: the uppermost five addressing bits select the segment. The instruction and the data part of the segment (in the program and data areas of the domain) are termed the instruction and the data segment, respectively.

A segment is a set of files, cataloged under the Sintran III file system. The instruction segment and the data segment have the same name, but types :PSEG and :DSEG, respectively. In addition, there is a :LINK file. The :LINK file is not opened when the program is executed but is used during the loading process and by the symbolic debugger. These three files together are called the segment, unless a qualification of program, data or :LINK file is made.

The files may be indexed or contiguous, but will by default be indexed.

A domain consists of a table of segments, and is not a separate entity in the file system. The segment tables for all domains belonging to one user are kept in a file called DESCRIPTION-FILE:DESC.

Domains and segments are referred to by symbolic names. Internally, a numerical index is employed, but the user will not have to be concerned about this index; NLL will obtain the domain or segment number from the description file. The domain name follows the syntax of and may coincide with file names. Domain names are stored solely in.

---

## Page 29

# MEMORY MANAGEMENT SYSTEM

The description file. Segment names are the names of the :PSEG, :DSEG and :LINK files making up the segment. These names are also stored in the description file, where the position in the segment table for the domain determines the segment number.

When required, the domain and segment numbers can be obtained by executing the NLL commands LIST-DOMAIN or LIST-SEGMENT.

The reasons for splitting a domain in several segments are many:

- The more time critical parts of a program may be kept permanently in memory (fixed segments), while other parts may be regular demand segments.

- A segment may be part of several domains. Thus, file space is required for one copy only, rather than including the data or routines (for example the Fortran library) in every domain.

- At run time, the Monitor will recognize a program segment used by several users concurrently, and keep only one copy in memory, thereby reducing swapping.

- Different segments may be given different protection against other users.

- Two programs running concurrently may communicate through a shared data segment (Normally, however, each program would have its own copy of the data segment).

- Program modularization is simplified.

- Modifications of routines or data in one segment will not require a reloading of the whole domain (unless it has been marked as sensitive to modifications).

- No swap file space is required for the program segment; it is read directly from the :PSEG file and never written back. Thus, swap file space is saved and no unnecessary rewrites are performed.

A segment will always be declared in one domain. If other domains need routines or data in this segment, references are defined by linking this segment to the other domain through the NLL command LINK-SEGMENT. The linked segment may also belong to another user, for example user SYSTEM may have a segment with library subroutines that other users may link to.

Linking is possible only if the segment has no external references to other segments in the domain where it was created, unless all these segments are also linked.

ND-500 hardware allows a segment to be used as an "indirect" segment. Call to an indirect segment implies a change of control to another domain, and is used for building a program system consisting of several domains. This mechanism is not used under the Sintran III operating system.

---

ND-60.136.04

---

## Page 30

# MEMORY MANAGEMENT SYSTEM

The indirect segment concept is, however, used for operating system requests: "monitor calls" are calls to routines on a system segment used as an indirect segment. Thus, monitor calls look exactly like regular routine calls, and parameters are transferred through the same mechanisms. By convention (although not by necessity), segment number 31 (octal 37) is used for interfacing to the operating system.

## 2.2. Capabilities

During execution, ND-500 will keep a 16 bit descriptor, called a capability, for each logical segment in use. This capability contains information about access rights, location in physical segments and sharing with other processes.

Each data segment may be individually protected against write access and access to subroutine parameters. If the segment is used concurrently by several processes, the capability will inform the CPU that data accesses should go directly to memory rather than through the cache. This is done to prevent that one process’ updating of a variable is immediately observed by the other processes; the cache is not necessarily cleared when another process gains access to the CPU. Also, accesses to segments shared with processes (RT programs) in the ND-100 bypass the cache.

A program segment is identified as a direct or indirect segment. A direct segment is part of the current domain, while an indirect segment is part of another domain (in Sintran III: in the ND-100). This mechanism is used by the operating system to implement a set of monitor calls: Logically, the routines are addressed within the address space of the current domain, but when such a routine is called, the microprogram will recognize the segment as indirect, and transfer control to the appropriate domain. ND-100 is in this respect considered another domain. The capability contains an explicit indication that the other domain is in another machine.

---

## Page 31

# Memory Management System

## Program Segment Capability

### a) Direct Segment

| 1 bit      | 3 bits     | 12 bits                 |
|------------|------------|-------------------------|
| direct (=0)| unused     | physical segment number |

### b) Indirect Segment

| 1 bit         | 1 bit  | 1 bit   | 8 bits | 5 bits   |
|---------------|--------|---------|--------|----------|
| indirect (=1) | other  | unused  | domain | segment  |

## Data Segment Capability

| 1 bit  | 1 bit  | 1 bit | 1 bit  | 12 bits                 |
|--------|--------|-------|--------|-------------------------|
| write  | parameter shared | unused | physical segment number |

Both data and program segment capabilities also indicate which **physical segment** that is addressed. A physical segment is a part of (physical and virtual) memory; a logical address is translated to a physical address in the physical segment.

Two logically separate segments may map onto the same physical segment. This will appear as the capabilities of the two segments pointing to the same physical segment. The physical segment number is determined when the segment is brought into memory for execution. Sharing a segment in this manner may reduce swapping, and it may be used for communicating data between processes.

When a routine on a program segment is started, the Monitor will normally check whether the physical segment has already been fetched by some other process. If it has, no new copy is required, and the second segment maps onto the physical segment already in memory. (This relies upon program segments being read-only - if any modification (patching) is done to the program segment, the user will receive his own private copy.)

Data segments will not unless explicitly specified be mapped onto the same physical segments, as one process' modification of a location will have an immediate effect for other processes' use of the value. Sharing a physical segment is, however, the most direct way of transferring data between processes. When accessing data in a shared segment, the cache is bypassed in order to ensure data consistency. If multiple CPUs have access to the memory, the multiport will ensure that a write or read operation of one location will not be interrupted by another process. (Higher level protection and synchronizing mechanisms may be implemented in software based on this hardware mechanism.)

---

## Page 32

# MEMORY MANAGEMENT SYSTEM

If a logical data segment is mapped directly onto the file where it is stored (rather than to a copy on a swap file), modifications to the data will be permanent. By using a file as a segment any file may be manipulated; the cataloged file will be directly addressed as a part of the logical address space. Compared to ordinary file access, the overhead is reduced drastically, and addressing can be done easily and directly within the logical address space. Obviously, only one process at a time may modify a permanent file, or the two processes must have agreed upon a synchronization protocol.

---

## Page 33

I can't convert the content since the page is blank.

---

## Page 34

# TRAPS

## 3. TRAPS

Trap conditions are special situations detected by hardware, possibly requiring special handling. Examples of such situations are division by zero, protect violation or illegal index.

Some trap conditions may be completely ignored. Others require some form of handling, while still others are so serious that they are reported directly to the operating system. These three groups are labeled ignorable, non-ignorable and fatal, respectively.

Trap conditions may be handled by a routine in the current domain, or propagated to the ND-100. The presence of a local trap handler routine is signalled by setting the bit in the OTE register (Own Trap Enable) corresponding to the trap condition. This register has one bit for each possible trap condition.

If the OTE bit is cleared, the trap is propagated to the ND-100 if the MTE bit (Mother Trap Enable) is set, signifying that the ND-100 has a trap handler. Otherwise the trap is ignored.

The ND-100 may limit the ND-500 domains' freedom to modify bits in the OTE register (and thereby the handling of the trap condition), by clearing the corresponding bit in the TEMM register (Trap Enable Modification Mask). Fatal traps may never be locally enabled in ND-500.

## 3.1. Trap handler calling

When a trap condition occurs, the calling of a handler is determined by the setting of the MTE and OTE registers. If the affected bit is reset in both registers, no trap handler is called and the trap condition ignored.

If the OTE bit is set, a routine in ND-500 is called. This routine may be written by the user, or may be loaded or linked from a library of standard trap handlers.

If the MTE bit is set and not the OTE bit, ND-100 will take care of the trap condition.

When a trap condition is taken care of in ND-500, the address of the trap handler is found in a table pointed to by the THA (Trap Handler Address) register. The n’th entry in this table contains the address of the handler for the n’th trap condition. One handler may take care of several traps, or each trap condition may be handled by a separate routine.

The routine may perform any operation, including calling subroutines, but if a trap condition occurs during the execution of this routine, the trap is unconditionally reported to ND-100. The reason for this is that the local data area for a trap handler is fixed in the space above the table containing the trap handler start addresses; trap handlers are thus not reentrant.

---

## Page 35

# TRAPS

At the call of the trap handler the local data area will be initialized with information about the trap and the state of the process when the trap occurred. The layout of this information is described in the ND-500 CPU Reference Manual ND-05.009.

## 3.2. Use of trap handlers

Writing a handler for a trap condition will require a familiarity with the instruction set and call mechanisms of the ND-500. Reading the values in the local data area of the trap handler (containing the register block and data about the trap) is most easily done in assembler, but may in principle be done in any language.

Most often the user will want to handle the error on a more abstract level. A standard trap handler library will take care of the low level trap handling, and call an exception handler routine. These will present hardware and software detected errors to the user in a uniform way. The standard routines may perform all the error handling or take care of a subset of errors, they provide mechanisms for entering the address of user written routines into the table of handlers and for setting and resetting bits in the OTE register.

Trap handler routines and enabling/disabling of traps may be defined at load time or before execution is started. These settings act as default values that may be modified by the program at execution time.

The standard library will also provide routines for errors detected by software. Such errors are usually very dependent on the application (for example errors in the correspondence between the IO-list and the FORMAT statement in Fortran), and rely upon instructions generated by the compiler. The standard way of reporting errors that occurred in a routine is to set the K bit in the status register and leave an error code in the I1 register.

The combination of hardware trap handling and handling of software detected errors allows a uniform interface to the environment, regardless of the mechanism used for detecting the error.

The term used to cover both hardware and software detected errors is **exception**, consequently the standard library is termed a **standard exception handler library**.

---

ND-60.136.04

---

## Page 36

# STANDARD EXCEPTION HANDLER LIBRARY

## 4. STANDARD EXCEPTION HANDLER LIBRARY

The term *exception* covers in addition to all defined hardware traps, special situations and errors detected by software. An exception handler is a routine to be activated when an exception occurs, and to take appropriate recovery actions.

A set of standard routines for use with Fortran or Plano has been developed. These are available in a standard library, and will be linked automatically if the user so desires.

For each error condition, the user may determine:

1. The number of times each error message is to be printed.
2. The number of times an error may occur before the program is abnormally terminated.
3. Whether a user-supplied exception handler is to be activated upon detection of an error.
4. Whether traceback of routine stack frames is to be printed when the error occurs or when the program terminates. (In case of traps, this includes a register dump).
5. Printout of error statistics when the program terminates.

The library consists of the following routines:

| Routine  | Description                                                  |
|----------|--------------------------------------------------------------|
| EXCEPT   | Disable/enable handling of specified exception               |
| EXCDEF   | Reset handling of exception to default                       |
| EXCTERM  | Define action to be taken upon program termination           |
| PRITRAC  | Print traceback of routine instances (subroutines)           |
| PRIMESS  | Print error message                                          |
| GETMESS  | Return error text (Fortran)                                  |
| PGETMESS | Return error text (Plano)                                    |
| RDEFVAL  | Read default exception handling parameters values            |
| RCURVAL  | Read current exception handling parameters values            |

In the following descriptions, the header of these routines is described, giving the number and types of the arguments. These routines are supplied with the standard ND Fortran library. Except where designated as returned values, all parameters are read-only input values.

Where routines are used as parameters, the name of the routine is supplied in the actual parameter list. The compiler will generate the appropriate reference to the entry point of the routine.

Traps and exceptions will be handled in the ND-500, providing they are locally enabled. There are default settings for all traps. If no local handling has been specified, or the trap has been disabled, then some traps may be handled as a system trap in the ND-100. The Monitor will then handle the trap in a standard manner, depending on the type of trap. System traps may also be disabled, but the user's right to modify trap handling may be restricted.

ND-60.136.04

---

## Page 37

# STANDARD EXCEPTION HANDLER LIBRARY

Handling of traps may be determined at load time or before execution through the commands LOCAL-TRAP-ENABLE, LOCAL-TRAP-DISABLE, SYSTEM-TRAP-ENABLE and SYSTEM-TRAP-DISABLE. These commands are available both in NLL and the Monitor, and to set default values to be used if no action is taken by the program.

ND-60.136.04

---

## Page 38

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.1. ND-500 traps table

The following is a list of defined hardware traps, their corresponding bit number in the status, OTE, MTE and TEMM registers, exception number, and the name of the trap. For a more detailed explanation, see the ND-500 CPU Reference Manual ND-05.009.

| Bit no. | Exc. no. | Trap name                          | D   | msg | err |
|---------|----------|------------------------------------|-----|-----|-----|
| 9       | 7611B    | OVERFLOW                           | 10  | unl |     |
| 11      | 7613B    | INVALID OPERATION                  | *   | 10  | unl |
| 12      | 7614B    | DIVISION BY ZERO                   | *   | 10  | unl |
| 13      | 7615B    | FLOATING UNDERFLOW                 |     | 10  | unl |
| 14      | 7616B    | FLOATING OVERFLOW                  | *   | 10  | unl |
| 15      | 7617B    | BCD OVERFLOW                       |     | 10  | unl |
| 16      | 7620B    | ILLEGAL OPERAND VALUE              | *   | 10  | unl |
| 17      | 7621B    | SINGLE INSTRUCTION TRAP            | 0   | unl |     |
| 18      | 7622B    | BRANCH TRAP                        | 0   | unl |     |
| 19      | 7623B    | CALL TRAP                          | 0   | unl |     |
| 20      | 7624B    | BREAKPOINT INSTRUCTION TRAP        | 0   | unl |     |
| 21      | 7625B    | ADDRESS TRAP FETCH                 | 0   | unl |     |
| 22      | 7626B    | ADDRESS TRAP READ                  | 0   | unl |     |
| 23      | 7627B    | ADDRESS TRAP WRITE                 | 0   | unl |     |
| 24      | 7630B    | ADDRESS ZERO ACCESS                |     | 10  | unl |
| 25      | 7631B    | DESCRIPTOR RANGE                   |     | 10  | unl |
| 26      | 7632B    | ILLEGAL INDEX                      | *   | 1   | 0   |
| 27      | 7633B    | STACK OVERFLOW                     | *   | 1   | 0   |
| 28      | 7634B    | STACK UNDERFLOW                    | *   | 0   | 0   |
| 29      | 7635B    | PROGRAMMED TRAP                    |     | 10  | unl |
| 30      | 7636B    | DISABLE PROCESS SWITCH TIMEOUT *   |     | 1   | 0   |
| 31      | 7637B    | DISABLE PROCESS SWITCH ERROR  *    |     | 1   | 0   |
| 32      | 7640B    | INDEX SCALING ERROR                |     | 1   | 0   |
| 33      | 7641B    | ILLEGAL INSTRUCTION CODE           | *   | 1   | 0   |
| 34      | 7642B    | ILLEGAL OPERAND SPECIFIER          | *   | 1   | 0   |
| 35      | 7643B    | INSTRUCTION SEQUENCE ERROR         | *   | 1   | 0   |
| 36      | 7644B    | PROTECT VIOLATION                  | *   | 1   | 0   |

The "D" column refers to the default enabling of traps used by the standard exception handler library discussed in the next chapter. "**" indicates that the trap is enabled if the default trap library settings are used.

msg = default maximum number of error messages  
err = default number of exceptions prior to abnormal termination  
unl = unlimited number

ND-60.136.04

---

## Page 39

# 4.2. The EXCEPT routine

The EXCEPT routine is used to modify the current exception handling conditions.

**PLANC specification:**

```
TYPE RTYP = ROUTINE REFERENCE VOID, VOID (INTEGER)
ROUTINE REFERENCE VOID, VOID (INTEGER, INTEGER, RTYP POINTER, &  
         INTEGER, INTEGER, BITS POINTER):  
EXCEPT (EXCNO, EXCFUN, EXCROUT, NOMSG, NOEXC, EXCARR)  
```

\<standard library routine\>

ENDROUTINE

**FORTRAN specification:**

```
SUBROUTINE EXCEPT(EXCNO, EXCFUN, EXCROUT, NOMSG, NOEXC, EXCARR,  
                  EXCNOL, EXCNOH)  
INTEGER EXCNO, EXCFUN, EXCROUT, NOMSG, NOEXC, EXCNOH, EXCNOL  
LOGICAL EXCARR(EXCNOL:EXCNOH)  
```

\<standard library routine\>

END

## Parameter values:

| EXCNO  | Exception number or exception number group: |
|--------|--------------------------------------------|
| 7600B  | default group of traps to be set            |
|        | (see section 4.1)                           |
| 5101B  | LOGICAL array (EXCARR, EXCNOL and EXCNOH must be present, Fortran) |
| 5102B  | BITS POINTER (EXCARR must be present, Planc) |
| 7611B:7644B | specific trap number                  |
| 400B   | all FTN errors                             |
| 401B:457B | specific FTN error                      |
| other  | illegal                                    |

| EXCFUN | Function:                                   |
|--------|---------------------------------------------|
| -1     | disable exception(s) indicated by EXCNO and ignore all other exceptions. Further, the parameters EXCROUT, NOMSG and NOEXC will be ignored. |
| 0      | enable exception(s) indicated by EXCNO as TRUE, set new handler/values, and disable all other exceptions which are indicated as FALSE. For EXCNO values 7611B:7644B or 401B:457B, only the single exception thus specified, is enabled. |
| 1      | enable exception(s) indicated by EXCNO, do not modify handler/values, and ignore all other exceptions. |
| other  | illegal                                     |

ND-60.136.04

---

## Page 40

# STANDARD EXCEPTION HANDLER LIBRARY

## EXCROUT
User defined exception handler routine

| Value | Description |
|-------|-------------|
| > 0   | routine address (supplied by routine name in the source program) |
| 0     | no routine supplied |

## NOMSG
Number of messages allowed before program is aborted

| Value  | Description |
|--------|-------------|
| -1     | any number of messages allowed |
| >= 0   | number of messages allowed (< 2\*\*31-1 ) |
| other  | illegal |

## NOEXC
Number of traps before program is aborted

| Value  | Description |
|--------|-------------|
| -1     | any number of traps allowed |
| >= 0   | number of traps allowed (< 2\*\*31-1 ) |
| other  | illegal |

## EXCARR
LOGICAL array (Fortran) or BITS POINTER (Planc) containing TRUE or FALSE for exceptions to be handled

## EXCNOL
(Fortran) Low limit of EXCARR

## EXCNOH
(Fortran) High limit of EXCARR

The handling of one or several exception conditions may be modified, selected through the EXCNO parameter. If this parameter is 5101B (Fortran) or 5102B (Planc), the EXCARR parameter selects a set of exceptions to be handled. If the EXCFUN parameter is zero and EXCARR is present, the elements set to TRUE in this array will cause the corresponding exception to be enabled, while FALSE will cause it to be disabled. The array EXCARR must be declared as:

```
EXCARR (EXCNOL:EXCNOH) (e.g. EXCTRA (7611B:7644B))
```

The EXCROUT parameter specifies the name of a user supplied routine to be executed when the exception occurs. The routine should conform to the following formal specification:

### In Fortran:

```
SUBROUTINE name(ierno)
INTEGER ierno
.
<user written exception handler>
.
END
```

### In Planc:

```
ROUTINE REFERENCE VOID, VOID (INTEGER): name (ierno)
.
<user written exception handler>
.
ENDROUTINE
```

ND-60.136.04

---

## Page 41

# Standard Exception Handler Library

The parameter `<ierno>` will transfer the error number to the exception handler. If the EXCROUT parameter is zero, the standard exception handler routine from the library is used.

---

## Page 42

# STANDARD EXCEPTION HANDLER LIBRARY

After an error has occurred, the sequence of operations is as follows; the steps marked with an asterisk apply to traps only:

*Note: the details are slightly different in Planc*

1. \* If the exception is a trap, the trap routine is activated.

2. A system provided exception handler is called.

3. This handler updates the occurrence counter for this type of exception and activates the user exception handler if one has been specified.

4. If the traceback condition (see note 1) is true, the system outputs:
   * \- register dump 
   * \- traceback printout

5. If the message occurrence limit (NOMSG) has not been exceeded, or if the traceback condition (see note 1) is true, an error message is printed.

6. If the error count is less than or equal to the allowed number of occurrences for this exception type, control is returned to normal FORTRAN error handling, otherwise, the program is abnormally terminated with error statistics, if specified.

Note that in Fortran the STACK UNDERFLOW trap condition is handled by special software mechanisms and must, in order to ensure correct termination of the I/O activities, always be enabled.

*Note 1: the traceback condition is evaluated by the following expression:*

```
thiserror > 'STACK UNDERFLOW' and
(
  TRACEBACK=2 and
  ( thiserror.NOMSG = unl or
    thiserror.numerrors in 0:thiserror.NOMSG )
)
or
(
  TRACEBACK >= 1 and
  ( thiserror.NOEXC < unl and
    NOT thiserror.numerrors in 0:thiserror.NOEXC )
)
```

where

thiserror.numerrors is the current value of the number of exceptions of this type which have occurred.

---

## Page 43

# EXAMPLES, Fortran

1. Enable DIVISION BY ZERO trap using default exception values:

   ```
   C DIVISION BY ZERO is trap number 7614B
   CALL EXCEPT(7614B,1,0,0,0)
   ```

2. Enable OVERFLOW and allow maximum 2 error messages and 10 overflow errors before abnormal termination. Activate the user defined routine MYROUT each time the overflow trap occurs.

   ```
   CALL EXCEPT(7611B,0,MYROUT,2,10)
   ```

3. Disable error handling for exponential functions, Fortran error numbers 431B, 432B, 433B, 437B:

   ```
   LOGICAL ERRARRAY(431B:437B)
   DATA ERRARRAY/.FALSE.,.FALSE.,.FALSE.,.TRUE., 
                 .TRUE.,.TRUE.,.FALSE./

   CALL EXCEPT(5101B,-1,0,0,0,ERRARRAY,431B,437B)
   ```

---

## Page 44

# STANDARD EXCEPTION HANDLER LIBRARY

## 4. Manipulation of some exception settings.

Assume the following is the current table setting for exceptions:

| exc. no. (octal) | EXCROUT setting | msg | err | setting |
|------------------|-----------------|-----|-----|---------|
| ...              |                 |     |     |         |
| 431              | A               | 10  | unl | enabled |
| 432              | A               | 10  | unl | enabled |
| 433              | A               | 10  | unl | enabled |
| 434              | 0               | 10  | 20  | disabled|
| 435              | 0               | 10  | unl | enabled |
| 436              | 0               | 10  | unl | disabled|
| 437              | 0               | 10  | 50  | enabled |
| ...              |                 |     |     |         |

If the following call were executed,

```
CALL EXCEPT(5101B,0,MYROUT,5,-1,ERRARRAY,431B,437B)
C ERRARRAY as declared in previous example
```

then the table settings would be changed as follows,

| exc. no. (octal) | EXCROUT setting | msg | err | setting |
|------------------|-----------------|-----|-----|---------|
| ...              |                 |     |     |         |
| 431              | A               | 10  | unl | disabled|
| 432              | A               | 10  | unl | disabled|
| 433              | A               | 10  | unl | disabled|
| 434              | MYROUT          | 5   | unl | enabled |
| 435              | MYROUT          | 5   | unl | enabled |
| 436              | MYROUT          | 5   | unl | enabled |
| 437              | 0               | 10  | 50  | disabled|
| ...              |                 |     |     |         |

ND–60.136.04

---

## Page 45

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.3. The EXCDEF Routine

EXCDEF is used to set the default exception handling values for a given set of exceptions. This is functionally equivalent to calling EXCEPT with the default parameter values for each of the traps specified, but is more convenient and relieves the programmer from knowing the defaults.

### PLANC Specification:

ROUTINE REFERENCE VOID, VOID(INTEGER, BITS POINTER):
EXCDEF(EXCNO, EXCARR)

\<standard library routine\>

ENDROUTINE

### FORTRAN Specification:

SUBROUTINE EXCDEF(EXCNO, EXCARR, EXCNCL, EXCNOH)  
INTEGER EXCNO, EXCNCL, EXCNOH  
LOGICAL EXCARR(EXCNOL:EXCNOH)

\<standard library routine\>

END

### Parameter Values:

| Parameter | Description |
|-----------|-------------|
| EXCNO     | Exception number or exception number group: |
|           | 7600B default setting (see section 4.1) |
|           | 5101B LOGICAL array (EXCARR and EXCNOH present, Fortran) |
|           | 5102B BITS POINTER (EXCARR present, Planc) |
|           | 7611B:7644B specific trap number |
|           | 400B all FTN errors |
|           | 401B:457B specific FTN error |
|           | other illegal |
| EXCARR    | LOGICAL array (Fortran) or BITS POINTER (Planc) containing TRUE for exceptions to be handled, FALSE for those that should remain as they are |
| EXCNOL    | (Fortran) Low limit of EXCARR |
| EXCNOH    | (Fortran) High limit of EXCARR |

---

## Page 46

# STANDARD EXCEPTION HANDLER LIBRARY

The EXCARR parameter selects a set of exception conditions, like in the EXCEPT routine. Alternatively, one specific exception may be selected through the EXCNO parameter.

## EXAMPLES, Fortran:

1. Reset handling of all traps and Fortran errors to default:

   ```
   C All traps
   CALL EXCDEF(7600B)
   C All Fortran errors
   CALL EXCDEF(400B)
   C set default program termination conditions
   CALL EXCTERM(0,1,20)
   ```

   This setting is identical to the setting at the beginning of execution of a Fortran program.

2. Reset special error handling for exponential functions, error numbers 431B, 432B, 433B and 437B, but keep possible special handling of other exceptions:

   ```
   LOGICAL ERRARRAY(431B:437B)
   DATA ERRARRAY/.TRUE.,.TRUE.,.TRUE.,.FALSE.,
                 .FALSE.,.FALSE.,.TRUE./
   CALL EXCDEF(5101B,ERRARRAY,431B,437B)
   ```

---

## Page 47

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.4. The EXCTERM routine

EXCTERM may be called to determine the printing of traceback and error statistics information. If it has been called more than once, the last call applies at program termination.

### PLANC specification:

ROUTINE REFERENCE VOID,VOID(INTEGER,INTEGER,INTEGER): &  
EXCTERM(TRACEBACK,PRSTAT,NOLEV)  

\<standard library routine\>  

ENDROUTINE

### FORTRAN specification:

SUBROUTINE EXCTERM(TRACEBACK,PRSTAT,NOLEV)  
INTEGER TRACEBACK,PRSTAT,NOLEV  

\<standard library routine\>  

END

### Parameter value:

| Parameter | Description |
|-----------|-------------|
| TRACEBACK | traceback print, for all errors: |
| 0         | : no traceback (default) |
| 1         | : traceback upon abnormal termination |
| 2         | : traceback upon error |
| other     | : illegal |

| PRSTAT | error statistics print at program termination, for all errors: |
|--------|---------------------------------------------------------------|
| 0      | : no statistics output |
| 1      | : print statistics (default) |
| other  | : illegal |

| NOLEV | maximum number of levels to process when a traceback is provided. |
|-------|------------------------------------------------------------------|
| > 0   | : maximum number of stack levels to print, default 20 |
| other | : not valid |

ND–60.136.04

---

## Page 48

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.5. The PRITRAC Routine

PRITRAC is a utility routine to print a traceback of routine instances (stack frames). The routine is called from a user handler, or automatically upon abnormal termination of the job if traceback has been selected (in the EXCEPT call referring to the exception condition raised).

**PLANC specification:**

ROUTINE REFERENCE VOID, VOID (BOOLEAN READ): PRITRAC (TRAP)

\<standard library routine\>

ENDROUTINE

**FORTRAN specification:**

SUBROUTINE PRITRAC (TRAP)
LOGICAL TRAP

\<standard library routine\>

END

**Parameter value:**

| TRAP | TRUE if called while a trap is being handled. |
|------|-----------------------------------------------|
|      | FALSE should be set for any other condition.  |

Note that the default maximum number of stack levels to be printed is 20.

---

## Page 49

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.6. The PRIMESS routine

The PRIMESS routine will print the error message, corresponding to the parameter value, on the standard output device (unit 1).

**PLANC specification:**

ROUTINE REFERENCE VOID, VOID (INTEGER): PRIMESS(EXCNO)

\<standard library routine\>

ENDROUTINE

**FORTRAN specification:**

SUBROUTINE PRIMESS (EXCNO)  
INTEGER EXCNO

\<standard library routine\>

END

Parameter values:

| Parameter | Description       |
|-----------|-------------------|
| EXCNO     | exception number  |

The parameter (EXCNO) must be in the range 7611B:7644B (traps) or 401B:457B (FORTRAN errors).

---

## Page 50

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.7. The GETMESS/PGETMESS routine

PGETMESS/GETMESS will return the error text corresponding to the specified exception number.

### PLANC specification:

ROUTINE VOID,BYTES POINTER(INTEGER): PGETMESS(EXCNO)

\<standard library routine\>

ENDROUTINE

### FORTRAN specification:

```
FUNCTION GETMESS(EXCNO)
C this function must be declared to be of type character in the
C calling program
INTEGER EXCNO
CHARACTER * 50 GETMESS

<standard library routine>

END
```

### Parameter values:

| Parameter | Description                                                                                  |
|-----------|----------------------------------------------------------------------------------------------|
| EXCNO     | the number of an exception condition                                                         |
| EXCTEXT   | (Fortran; out-value in Planc:) Return parameter containing the error text                    |

EXCNO must be the number of a defined exception condition, in the range 7611B:7644B (traps) or 401B:457B (Fortran error).

ND-60.136.04

---

## Page 51

# 4.8. The RDEFVAL Routine

## PLANC Specification

ROUTINE REFERENCE VOID,VOID (INTEGER, INTEGER WRITE,  
&nbsp;&nbsp;&nbsp;&nbsp;INTEGER WRITE, INTEGER WRITE, INTEGER WRITE,  
&nbsp;&nbsp;&nbsp;&nbsp;INTEGER WRITE, BOOLEAN WRITE):  
RDEFVAL (EXCNO, NOMSG, NOEXC, TRACEB, PRSTAT, NOLEV, ENABL)

\<standard library routine\>

ENDROUTINE

## FORTRAN Specification

SUBROUTINE RDEFVAL (EXCNO, NOMSG, NOEXC, TRACEB, PRSTAT, NOLEV, ENABL)  
LOGICAL ENABL  
INTEGER EXCNO, NOMSG, NOEXC, TRACEB, PRSTAT, NOLEV

\<standard library routine\>

END

## Parameter Values

| Parameter | Description |
|-----------|-------------|
| EXCNO     | Exception number |
| NOMSG     | Default number of messages allowed (returned value) |
| NOEXC     | Default number of exceptions allowed (returned value) |
| TRACEB    | Default (=0) traceback setting (all EXCNOs) (returned value) |
| PRSTAT    | Default (=1) error statistics setting (all EXCNOs) (returned value) |
| NOLEV     | Default (=20) maximum number of levels to be printed during a traceback (returned value) |
| ENABL     | Boolean parameter, TRUE if exception currently is enabled |

RDEFVAL may be called to read the default values of the exception parameters corresponding to a given exception number (EXCNO).

---

## Page 52

# STANDARD EXCEPTION HANDLER LIBRARY

## 4.9. The RCURVAL routine

RCURVAL may be called to read the current values of the exception parameters corresponding to a given exception number (EXCNO).

### PLANC specification:

TYPE RTYP = ROUTINE REFERENCE VOID,VOID (INTEGER)  
ROUTINE REFERENCE VOID,VOID (INTEGER, RTYP POINTER, &  
INTEGER WRITE, INTEGER WRITE, INTEGER WRITE, &  
INTEGER WRITE, INTEGER WRITE, INTEGER WRITE, &  
BOOLEAN WRITE): &  
RCURVAL (EXCNO,EXCROUT,NOMSG,NOEXC,TRACEB,PRSTAT,NOLEV,EXCCOUNT, &  
ENABL)

\<standard library routine\>

ENDROUTINE

### FORTRAN specification:

SUBROUTINE RCURVAL(EXCNO,EXCROUT,NOMSG,NOEXC,TRACEB,PRSTAT,NOLEV,  
+ EXCCOUNT,ENABL)  
LOGICAL ENABL  
INTEGER EXCNO,EXCROUT,NOMSG,NOEXC,TRACEB,PRSTAT,NOLEV,EXCCOUNT

\<standard library routine\>

END

### Parameter values:

| Parameter  | Description |
|------------|-------------|
| EXCNO      | exception number |
| EXCROUT    | address of current user exception handler or zero (supplied as a routine name in the source program) |
| NOMSG      | current number of messages allowed before abnormal termination (returned value) |
| NOEXC      | current number of exceptions allowed before abnormal termination (returned value) |
| TRACEB     | traceback setting (for all EXCNOs), see section 4.4 (returned value) |
| PRSTAT     | status report print upon end of program (for all EXCNOs) (returned value) |
| NOLEV      | current setting of maximum number of levels to be printed during traceback (returned value) |
| EXCCOUNT   | current exception count (returned value) |

ND-60.136.04

---

## Page 53

# STANDARD EXCEPTION HANDLER LIBRARY

ENABL Boolean value, TRUE if exception currently is enabled

Numbers not listed are currently not used. All Fortran errors are default enabled.

**All languages:**

The hardware traps are listed in section 4.1.

ND-60.136.04

---

## Page 54

# COMMUNICATION BETWEEN ND-500 AND ND-100

## 5. COMMUNICATION BETWEEN ND-500 AND ND-100

There are several ways of transmitting information between the ND-500 and the ND-100; the selection of a method depends on the transmission speed required, the requirements and privileges of the sending and the receiving process, and above all, the amount of data to be transmitted.

### 5.1. Monitor calls

This is the simplest and, for the programmer, most direct way of communicating through the operating system mechanisms, or with the operating system itself. A monitor call will look exactly like a regular subroutine call to a routine in an indirect segment. The services provided are the same as in a ND-100 system. Monitor calls are used in connection with semaphores, internal devices, reserving and using external devices, file I/O and for starting and stopping RT programs in the ND-100.

When a monitor call is executed, the ND-500 process is suspended and a twin process in the ND-100 is started to execute the call on behalf of the ND-500 process. Some monitor calls may allow the ND-500 process to continue while the call is executed if the function code is selected accordingly.

The starting and stopping of a ND-100 process is rather time-consuming, and monitor calls should be used for small amounts of data only, or for setting up other communication channels. The overhead is essentially constant regardless of the number of bytes transferred, as long as this number is moderate.

All Sintran III VSE/500 systems are delivered with the OUTST monitor call (MON 162). This is used by the standard libraries, rather than OUTBT. The programmer using monitor calls explicitly is advised to utilize OUTST if possible. OUTST will cause activation of the twin process for each string to be transferred, while OUTBT will activate it for each byte transferred.

### 5.2. Communicating through the process flags

Each process running in ND-500 has two 32 bit words assigned for communication purposes. These are termed the input flag and the output flag. Monitor calls and commands are available to read and write these flags. The flags are not used by the monitor, and may contain any bit pattern the user desires.

The input flag of a process is used for signalling to a running ND-500 process. This flag may be written by an ND-100 process or through commands, and read by the process itself. The output flag is used for returning data or status, and is written by the process. This flag may be read by ND-100 or through commands, but may not be written.

ND-60.136.04

---

## Page 55

# COMMUNICATION BETWEEN ND-500 AND ND-100

There is no queueing - if another value is written in the flag word before it is read, the first value is overwritten.

## 5.3. Communicating through RTCOMMON

This is the fastest method of communication, as reading and writing is directly to the location accessed by the ND-100, and this part of memory is always resident. The only limiting factor is the size of the RTCOMMON area.

The RTCOMMON area is accessed from the ND-500 as a part of the regular memory space. The mapping onto the RTCOMMON is done at load time through the MATCH-RTCOMMON command, used before any loading to the segments is done.

No modification of the size of RTCOMMON should be done after the segments referring to it have been loaded. If such modifications are done, the segments must be reloaded. Segments using RTCOMMON can not, in general, be moved to another machine after loading.

If the RTCOMMON area is used from ND-500, it must be contiguous. In other words, if the system supervisor through the SINTRAN-SERVICE-PROGRAM command DEFINE-RTCOMMON-SIZE expands RTCOMMON beyond what was specified at system generation, this area must be adjacent to the initially allocated area.

## 5.4. Communicating through an RT segment

An ND-100 RT-program may share data with an ND-500 process through a segment in one of the ND-100 SEGFILs. The segment must be fixed in a continuous area in memory before the ND-500 process referring to it is started.

This is the most efficient way of transferring larger amounts of data between the two processors. Access to the area should be protected by semaphores; this is done through monitor calls.

The symbols defined by the ND-100 RT-LOADER are available to the ND-500 process after the MATCH-COMMON-RT-SEGMENT command has been given. This command should be given after these symbols have been defined in the ND-100, but before any loading to the ND-500 segment is done.

If two (or more) ND-100 segments are matched with one ND-500 segment, they must be fixed in memory at physical addresses with a fixed distance equal to the distance between them in ND-500 address space.

---

## Page 56

# COMMUNICATION BETWEEN ND-500 AND ND-100

## 5.5 Communicating through files

All files are common to the two processors, and the same regulations apply to processes running in the two CPUs as to processes running in the same CPU. Files provide for transfer of arbitrarily large amounts of data, but are significantly slower than the other methods.

In order to speed the file access, the file may be opened with direct transfer (open modus 8 or 9). This puts some restrictions on the application program, but allows the transfer to go directly to memory, circumventing a major part of the file system. However, the user must do most of the bookkeeping himself, and the file system provides no structuring of the disk pages. The transfer speed will, however, when the block size is large, approach the hardware speed of the disk.

Programs using direct transfer may also allow a higher number of simultaneously opened files. Direct transfer is also available for magnetic tape.

When direct transfer is used, the Monitor will automatically fix the memory buffer in a contiguous part of memory before the first transfer, and it will remain fixed until the program terminates.  

ND-60.136.04

---

## Page 57

# 6. LOADER COMMANDS

Although the set of commands available in NLL is large, most users need only a couple of them. The most important are

```
SET-DOMAIN    - name an executable domain
LOAD-SEGMENT  - load a file containing relocatable code
EXIT          - return to Sintran III
```

The EXIT command is described in the next chapter.

Various error messages may be returned from NLL during or after command interpretation and execution. These error messages are listed in chapter 13, with short explanations and references to where they may occur.

## 6.1. Domains

### 6.1.1. SET-DOMAIN

`SET-DOMAIN ((domain name))`

`<domain name>` - the name of the domain to be set as the current domain, 1 to 16 alphanumeric characters or hyphen. Default name is SCRATCH-DOMAIN.

The domain with name `<domain name>` is set to be the current domain. The subsequent segment handling, loading, and linking will be done in the current domain. `<domain name>` cannot include the directory and user name; loading may be done only in the domains of the current user.

If a domain is already set when the SET-DOMAIN command is executed, it is closed by an implicit END-DOMAIN.

The default domain name is SCRATCH-DOMAIN. If a LOAD-SEGMENT command is given when there is no current domain, the code will be loaded directly to the swap file, ready for execution. This will delete all information previously loaded, using default names. Thus, a domain to be permanently retained will usually be given another name, to prevent it from being destroyed when default domain name is used.

A user may have a maximum of 256 domains. New domains are specified by enclosing the domain name in double quotes.

ND-60.136.04

---

## Page 58

# Domains

## 6.1.2. END-DOMAIN

**END-DOMAIN**

Finishes operation upon the current domain. END-DOMAIN automatically executes the command CLOSE-SEGMENT. END-DOMAIN will automatically be executed by the commands SET-DOMAIN, and EXIT.

## 6.1.3. CLEAR-DOMAIN

**CLEAR-DOMAIN `<domain name>`**

| `<domain name>` | - the name of the domain to be cleared, 1 to 16 alphanumeric characters or hyphen. |

All segments which the domain `<domain name>` consist of are deleted from the domain. The segment (:PSEG, :DSEG, :LINK) files are retained.

This command may not be executed when a domain is set. The domain is assumed to exist in the description file of the current user. It continues to exist, but no longer comprises any segments.

## 6.1.4. DELETE-DOMAIN

**DELETE-DOMAIN `<domain name>`**

| `<domain name>` | - the name of the domain to be deleted, 1 to 16 alphanumeric characters or hyphen. |

All segments in the domain are deleted, the domain itself is then also deleted. The segment (:PSEG, :DSEG, :LINK) files are retained. This command may not be executed when a domain is set. `<domain name>` cannot be SCRATCH-DOMAIN, and it must belong to the current user.

ND-60.136.04

---

## Page 59

# 6.1.5. LIST-DOMAIN

**LIST-DOMAIN** <<domain name>>

| <domain name> | - the name or abbreviation of names of domains to be listed. Default is all domains created by the current user. |

Writes all domains with names matching <domain name> and their start addresses (if any) on the output device. This command is also available in the Monitor.

This command can only be used to list domains belonging to the current user. To list domains belonging to other users, use the command LIST-SEGMENT, prefixing the <segment name> parameter with the user name in parentheses.

# 6.1.6. WRITE-DOMAIN-STATUS

**WRITE-DOMAIN-STATUS** [<<domain name>>]...

| <domain name> | - the name of the domain about which information is requested. Default is the current domain. |

Prints all the available information about the domain or domains specified. These are assumed to exist in the description file of the current user. If no parameters are given, the current domain-status is printed. Note that during a linking/loading session the domain-entry or the segment-entry is not fully updated until the commands END-DOMAIN and CLOSE-SEGMENT, respectively, are executed.

# 6.1.7. RENAME-DOMAIN

**RENAME-DOMAIN** <old domain name>, <new domain name>

| <old domain name> | - the name of an existing domain |
| <new domain name> | - the new name of the domain, 1 to 16 alphanumeric characters or hyphen. |

Renames the domain <domain name>. The domain is assumed to exist in the description file of the current user.

---

## Page 60

# Domains

## 6.1.8. COPY-DOMAIN

COPY-DOMAIN `<source domain>`, `<destination domain>`

| `<source domain>`      | - the name of the domain to be copied. May be prefixed by directory and/or user name.          |
|------------------------|------------------------------------------------------------------------------------------------|
| `<destination domain>` | - the name of a domain to receive a copy of the `<source domain>`. May **not** be prefixed with directory or user name. |

Copies the entire `<source domain>` to `<destination domain>`. `<source domain>` may be prefixed with a user name or directory:user name in parentheses. If the destination domain already exists, the segments on this domain must have the same names as the segments on the source domain or default names, and they will be overwritten with the segments from `<source domain>`.

If the segments do not exist, they will be created. They will be given the names they have in `<source domain>`, unless these names were default names; the segments then will be given new default names according to the `<destination domain>` number. If the destination domain does not exist, `<destination domain>` must be enclosed in double quotes.

To move a domain from one installation to another, the domain to be moved must be described in a description file being moved with it. The user to which the copying is done must enter NLL to create a description file (if it is not already created) and then copy the domain(s) by prefixing the source domain with the relevant directory and/or user name.

As the description file contains the name of the user, if the Sintran III commands ØRENAME-DIRECTORY and ØRENAME-USER is used, the NLL-command RENAME-DEFAULT-DIRECTORY-AND-USER must be used to update the description file.

Domains making references to RTCOMMON or Sintran III/ND-100 segments should not be copied to other machines.

ND–60.136.04

---

## Page 61

# Domains

## 6.1.9. RELEASE-DOMAIN

**RELEASE-DOMAIN** `<domain name>`

`<domain name>` - the name of the domain to be released

This command is used if an error in the system has occurred (e.g. a system crash) leaving a domain in an open state with no user attached to it. The domain will therefore be unavailable for further use. This may also occur if a loading process was not terminated before a Sintran III command was executed that did not return control to NLL.

RELEASE-DOMAIN will force the domain to be closed even if the user issuing the command is not the one who is using it or has been using it.

RELEASE-DOMAIN should be used with great care, and if used inappropriately it may cause inconsistencies in the description file. In any case, the contents of the released domain must be considered unpredictable, and it should be reloaded before being used again.

ND-60.136.04

---

## Page 62

# Segments

## 6.2. Segments

This section describes commands that manipulate segments as a whole, either before or after the actual load operation. The commands that cause code to be loaded are described in the next section (Commands to load NRF code).

Commands in this section are mainly used in connection with multi-segment domains. The OPEN-SEGMENT command may be used to select a non-default name of the segment, but the rules for default names ensure that segment names never collide. If there is only one segment per domain, the user need not be concerned about segment names at all, and thus, need not use any of the commands in this section. The opening and closing of segments is done automatically.

## 6.2.1. OPEN-SEGMENT

OPEN-SEGMENT ((segment name)), ((segment attributes))

<segment name> - the name of the segment to which subsequent loading should be done, 1 to 16 alphanumeric characters or hyphen. Default is SCRATCH-SEG-01 if current domain is SCRATCH-DOMAIN.

<segment attributes> - a string of the characters CDEMOPRWFN. See below. Default is CW.

Prepares the segment <segment name> for loading, i.e. set <segment name> as the current segment. If the segment does not exist when this command is executed, the segment name must be enclosed in double quotes. If the segment was already contained in the current domain, all old information about the segment is erased. (To add more code to an already loaded segment, use the command APPEND-SEGMENT.)

The scratch domain is used if there is no current domain.

The <attributes> specifies the use of the segment, and consists of a string of option letters. The options are:

| Option | Description |
|-------|-------------|
| R     | Read Only data segment. May not be combined with W. |
| W     | Write allowed data segment. Default value. May not be combined with R. |
| O     | Use original data segment file for swapping. Modifications to data will be permanent. May not be combined with C. |
| C     | Copy data segment to swap file. Default value. May not be combined with O. |

---

## Page 63

# Segments

## E
Empty data segment. The data segment will be dynamically assigned at execution time.

## F
File as segment. The data segment will at execution time be assigned to a file through the FSCNT call (MON 412B).

## P
Shared program segment. May be included in another domain by the command LINK-SEGMENT. Only the program segment will be shared.

This command is only necessary if the segment will be linked to another domain than the current one.

## M
Other Machine. The program segment capability will at execution time indicate that the segment is located in another CPU. Monitor calls which are executed in ND-100 can be defined as an indirect segment in another machine.

## D
Shared Data. A linked segment will by default have only the program segment shared. This attribute declares the data segment as shared. If both program and data segments should be shared, PD must be specified.

## N
No cache. All accesses to locations in this segment should go to main memory, bypassing the cache mechanism. This is particularly useful if the program controls its own DMA transfers from disks or communication channels.

If an NRF file is loaded when there is a current domain (set by SET-DOMAIN) but no current segment (set by OPEN-SEGMENT), an implied command:

```
OPEN-SEGMENT SEGMENT-Dxxx-Syy R
```

is executed, where xxx is the number of the current domain and yy the logical segment number used. If the segment does not exist, it is created.

All information on the segment is deleted. The segment number may be forced by the command SET-SEGMENT-NUMBER; otherwise the first free segment number, starting at 1, is used. If the segment exists, the segment number will be retained.

If an NRF file is loaded when there is neither a current segment nor domain, two implied commands are executed:

```
SET-DOMAIN SCRATCH-DOMAIN,,
OPEN-SEGMENT SCRATCH-SEGMENT-01, CW
```

Code previously loaded to SCRATCH-SEGMENT-01 will be deleted. Thus, to prevent the contents of a segment from being destroyed next time anything is loaded to the segment using the default name, the segment should be explicitly named.

ND-60.136.04

---

## Page 64

# Segments

Note that the default name depends on the domain and segment numbers. Therefore, as long as each program is loaded to a different domain, default segment name may be used in each of the domains without interfering with segments in other domains.

OPEN-SEGMENT automatically executes CLOSE-SEGMENT if a current segment is open and COMMON-SEGMENT-CLOSE if one or more COMMON segments are open.

## 6.2.2. CLOSE-SEGMENT

**CLOSE-SEGMENT [{Y}]**

| \<Y\> | - Y will cause a load map to be written to the output file after all linking and loading is complete. No parameter will suppress generation of a load map. Default is no load map. |

Terminates loading to the current segment. After this command has been executed, there is no current segment.

If the segment was not opened by APPEND-SEGMENT, a trap handler vector is allocated. If there are undefined references, the auto-link segments will automatically be linked. If there are still undefined references, the defined auto-load files (see SET-AUTO-LOAD-FILE) will automatically be loaded. Auto-link segments and auto-load files defined by the current user are first linked/loaded, and then those defined by user SYSTEM.

If there still are undefined references, an error message will be given. In a batch or a mode job all undefined references will be written to the output device and the command will be executed. In interactive mode a warning will be given and the command not executed. The second time the command is given it will always be executed.

The segments will be closed, all labels will be saved on the :LINK file in numerically sorted order, all other necessary information will be saved on the description file, and the correct file access will be set on the files involved. The KILL-ENTRIES and GLOBAL-ENTRIES commands may be used before the segment is closed to restrict the selection of labels saved on the :LINK file.

CLOSE-SEGMENT is automatically executed by END-DOMAIN, SET-DOMAIN, EXIT or OPEN-SEGMENT.

---

## Page 65

# 6.2.3. LINK-SEGMENT

LINK-SEGMENT `<segment name>`

`<segment name>` - the name of the segment to be linked to the current segment. If the segment does not belong to the current user, a user name must be included (even if user SYSTEM).

Links all modules on the segment `<segment name>` to the current segment. Routines and data areas defined on the segments listed will satisfy references on the current segment.

The linking can be done before or after loading the current segment; all symbols defined on the specified segments will be available until loading to the current segment is terminated (by CLOSE-SEGMENT). The `<segment name>` specified must be already loaded segments.

The segments which are linked will be a part of the current domain and must have no external references to other segments if they are also parts of other domains. This means that if the linked segment originally is a part of another domain it cannot, itself, have linked and common segments. It can, however, have indirect segments. Linked segments may have linked segments in the current domain. Logically, a segment linked to more than one domain may be treated as if there were several identical copies of the segment, one in each domain.

There are no restrictions on external references if the linked segments are parts of the current domain. It is also possible to make two-way references between segments within one domain.

If a segment in another domain is linked, the segment number will be the same in the two domains. The segment number must therefore be available when the linking is done, except if the segment has been previously linked - a second LINK-SEGMENT command may be used to define new references since the first linking was done.

# 6.2.4. LIBRARY-SEGMENT-LINK

LIBRARY-SEGMENT-LINK `<segment name>`

`<segment name>` - the name of the segment to be linked to the current segment.

A LINK-SEGMENT command will make all labels in the specified `<segment name>` available in the current domain. This may cause name conflicts, and can make the space requirements for the name table grow very large.

---

## Page 66

# Segments

LIBRARY-SEGMENT-LINK will define only those symbols actually referenced. Otherwise it works exactly as LINK-SEGMENT.

## 6.2.5. FORCE-SEGMENT-LINK

FORCE-SEGMENT-LINK `<segment name>` ...

`<segment name>` - the name of the segment to be linked to the current segment.

If a segment, which already has other linked segments, belongs to a domain other than the one which is the subject of the current load operation, then it is illegal to link that segment. It is however, possible to link the segment by using the command FORCE-SEGMENT-LINK. It is the user's responsibility to link all of the segments involved by explicit use of the command LINK-SEGMENT (FORCE-SEGMENT-LINK or LIBRARY-SEGMENT-LINK).

## 6.2.6. APPEND-SEGMENT

APPEND-SEGMENT `(<segment name>) (<segment attributes>)`

| `<segment name>` | - the name of an existing segment, to which more code will be added. Default is SCRATCH-SEG-01. |
|-------------------|------------------------------------------------------------------------------------------------|
| `<segment attributes>` | - a string of the characters CDEMOPRNWF. Default is the current attributes of the segment. |

This command prepares `<segment name>` for further loading. All previously defined and referenced symbols are available, and the new code can be appended to the old code. `<segment name>` must exist when this command is executed.

`<segment attributes>` have the same meaning as for OPEN-SEGMENT. If a non-default value is specified, the attributes are changed, otherwise the existing attributes will not be modified.

Be aware that only the first 20 characters of a symbol will be saved on the :LINK file, thus, if the symbol name is longer than 20 characters it will not match with the full, un-truncated symbol when loading to the segment is resumed at a later time with this command.

The common and link segments defined when the segment was previously closed are **not** automatically restored, and must be explicitly defined by the user. In order to avoid clearing the common segment, COMMON-SEGMENT-APPEND should be used.

ND-60.136.04

---

## Page 67

# 6.2.7. SET-SEGMENT-NUMBER

**SET-SEGMENT-NUMBER** `(<segment number>)`

| `<segment number>` | - a number in the range 0:37B to be the logical segment number of the next current segment. Default is 1. |

Specifies explicitly the logical segment number for the program segment within a domain. This command can be used in connection with the command OPEN-SEGMENT. If the command SET-SEGMENT-NUMBER is not issued, the first free segment number is used.

In most cases, the user need not be concerned about the segment number used. However, if the next free segment number (i.e. the default segment number) is already used by a segment that will later be linked to the domain, the segment number must be set to another value.

# 6.2.8. CLEAR-SEGMENT

**CLEAR-SEGMENT** `<segment name>`

| `<segment name>` | - the name of an existing segment that is to be cleared. |

The segment `<segment name>` will be cleared and readied for loading new code, i.e. all information about labels, start address, low address, and size is deleted. Pages allocated to the segment files will also be released, but the file will be retained.

# 6.2.9. DELETE-SEGMENT

**DELETE-SEGMENT** `<segment name>`

| `<segment name>` | - the name of an existing segment that is to be removed. |

All information and the files making up the segment `<segment name>` are deleted. The space on the domain which the segment was a part of is released.

This command is not legal if a domain is set, in which case an END-DOMAIN command must be executed before the segment is deleted.

---

## Page 68

# Segments

## 6.2.10. RENAME-SEGMENT

**RENAME-SEGMENT** `<old segment name>`, `<new segment name>`

- `<old segment name>` - the name of an existing segment in the description file of the current user.
- `<new segment name>` - the new name to be given to the segment, 1 to 16 alphanumeric characters or hyphen.

Renames the segment `<segment name>`. If the segment to be renamed is not in the default directory and/or belongs to another user than the current user, the entire directory and user name must be specified unabbreviated and in parentheses as a prefix to `<new segment name>`.

## 6.2.11. LIST-SEGMENT

**LIST-SEGMENT** `(<domain name>), (<segment name>)`

- `<domain name>` - the name or abbreviation of names of the domain to be searched. Default is all domains of the current user.
- `<segment name>` - the name or abbreviation of names of segments to be listed. Default is all segments in the selected domains.

All segment names matching `<segment name>` in the domains with name matching `<domain name>` are written on the output device, together with some segment information. If a list of another user's segments is wanted the segment name must be prefixed by the user name in parentheses. The domain name may not be prefixed by a user name!

This command will list the domain names as well as the segment names.

## 6.2.12. WRITE-SEGMENT-STATUS

**WRITE-SEGMENT-STATUS** `[<segment name>]...`

- `<segment name>` - the name or abbreviation of names about which information is requested. Default is current segment.

Prints all the available information about the segment or segments specified, belonging to the current user or the user specified in parentheses as a prefix to `<segment name>`. No parameter means that the current segment status is printed. Note that the current segment entry is not fully updated before the command CLOSE-SEGMENT is executed.

ND-60.136.04

---

## Page 69

# Segments

## 6.2.13. DEFINE-SEGMENT-SIZE

DEFINE-SEGMENT-SIZE `<program size>`, `<data size>`

| Parameter         | Description                                          |
|-------------------|------------------------------------------------------|
| `<program size>`  | the size of the program segment in bytes.            |
| `<data size>`     | the size of the data segment in bytes.               |

This command defines the size of the scratch segment on the swap file used when no domain or segment is specified before the first load command. Loaded code will be placed directly in (virtual) memory, and the RUN command may be used to start execution. If the segment size has not been defined, 64 pages will be allocated to the data segment, and references to addresses above this (byte address 40000B) will cause a fatal error. If a larger program data area is needed it must be declared before code is loaded.

If an attempt is made to load code or data to higher addresses than the specified maximum, an error message is issued.

ND-60.136.04

---

## Page 70

# Commands to Load NRF Code

## 6.3. Commands to Load NRF Code

NRF files contain code in the format described in chapter 12, produced by language compilers and assemblers.

A file in NRF format may be structured three different ways:

a) Normal, as default output from ASSEMBLER-500, PLANC-500, FORTRAN-500, PASCAL-500, COBOL-500 etc. Modules are located in strict sequential order, and defined labels are indicated by DEF or DDF control numbers.

b) Slow library files, output from the compilers and assembler mentioned above, when compiled/assembled in library mode (refer to the manual for the language in use). Labels defined in the file will appear with LIB control numbers. The term library file refers to a file in this format.

c) Fast library files, as (slow) library files but preceeded by an index table containing the name and byte address within the file of each label defined in the file. This format is obtained by transforming a file in format (b) with the PREPARE-NRF-LIBRARY-FILE command (section 6.10.9.).

The command normally used to load NRF code is LOAD-SEGMENT. The other commands in this chapter are required only if it is necessary to force the loading of a library module that would normally not be loaded, or to prevent a module from being loaded.

## 6.3.1. LOAD-SEGMENT

LOAD-SEGMENT `<file name>`...

| `<file name>` | - the name of a file in NRF format. Default file type is :NRF. |

This command loads the NRF code into the current program segment, data segment, and optional common segments. The current segment is the last one specified in an OPEN-SEGMENT or APPEND-SEGMENT command.

If no current segment or current domain exists, code is loaded directly to memory, and may be executed by the RUN command. If no RUN command is given, the EXIT command will cause the code to be written to a scratch segment in a scratch domain. Default attributes will be used.

If a current domain exists and no segment has been opened with OPEN-SEGMENT, a default segment will be used. See OPEN-SEGMENT.

If the current segment was opened with the command APPEND-SEGMENT rather than LOAD-SEGMENT, and in addition a routine vector was allocated on this segment by the ENTRY-ROUTINES command, the LOAD-SEGMENT command will work like RELOAD-SEGMENT: the new code will be.

---

## Page 71

# 6.3.2. RELOAD-SEGMENT

**RELOAD-SEGMENT \<file name\> ...**

| \<file name\> | - the name of a file in NRF format. Default file type is :NRF. |

This command will load NRF code to a segment like LOAD-SEGMENT, but modules already loaded to the segment will be replaced with the modules with the same identification in \<file name\>. The code loaded to the data segment is not replaced, but a warning message is given. This command should be used after an APPEND-SEGMENT command in order to avoid clearing the segment before loading.

This command is useful while debugging large segments and changes are made in a single or a small number of modules. Loading the entire segment is avoided; only the modules that have actually been modified are reloaded. The new versions of the modules are loaded at the current load address of the segment.

The space occupied by the old version of the module is not released, and it is the responsibility of the user to load the entire segment to clean this up after the debugging phase is complete.

# 6.3.3. LIBRARY-SEGMENT-LOAD

**LIBRARY-SEGMENT-LOAD \<file name\>...**

| \<file name\> | - the name of a file in NRF format. Default file type is :NRF. |

This command will load only modules containing referenced symbols from a file of structure (a), (b) or (c), as described above. For type (b) and (c) the effect will be exactly as with the LOAD-SEGMENT command.

All symbols defined in \<file name\> will be considered library symbols, regardless of whether they are actually defined as such in the :NRF file or not. Thus, NRF modules in the file will be loaded only if there are references that can be defined by loading the module. Modules containing no symbol definitions, definitions of already defined symbols or definitions only of symbols not referenced, will not be loaded. This command allows a file to be used as a library even if it has not been compiled/assembled in library mode.

ND-60.136.04

---

## Page 72

# Commands to Load NRF Code

If an NRF module in `<file name>` contains several symbol definitions, of which one or more are referenced, and others which are already defined, the module is loaded. The **first** definition of the already defined symbols will then apply, but a warning message will inform that a redefinition was attempted.

## 6.3.4. OMITTED-SEGMENT-LOAD

OMITTED-SEGMENT-LOAD `<file name>`, `<entry>`...

| Parameter    | Description                                                                     |
|--------------|---------------------------------------------------------------------------------|
| `<file name>`| the name of a file in NRF format. Default file type is :NRF.                    |
| `<entry>`    | the name of a symbol defined in `<file name>`.                                  |

This command will load all modules of an NRF file of structure (b) and (c) containing any referenced symbol(s), except for those modules containing definitions of the specified ones. These modules will not be loaded during this load operation. (Subsequent load commands may cause these modules to be loaded.)

The `<entry>` does not have to be a library symbol (LIB control number); it will be omitted from loading regardless of symbol definition type.

This command is commonly used to prevent a standard version of a routine from being loaded, in order to load a different non-standard version from another file. If `<entry>` is not defined in `<file name>` or if no symbols are specified, this command will act as LIBRARY-SEGMENT-LOAD.

## 6.3.5. SELECTED-SEGMENT-LOAD

SELECTED-SEGMENT-LOAD `<file name>`, `<entry>`...

| Parameter    | Description                                                                     |
|--------------|---------------------------------------------------------------------------------|
| `<file name>`| the name of a file in NRF format. Default file type is :NRF.                    |
| `<entry>`    | the name of a symbol defined in `<file name>`.                                  |

The complement of OMITTED-SEGMENT-LOAD: this command will load only those modules containing definitions of the specified `<entry>`s from files of structure (b) and (c). Other modules will not be loaded, except those already referenced and undefined. Symbols do not have to be library entries; no modules except those referenced in `<entry>` will be loaded regardless of symbol definition type.

`<entry>` does not have to be referenced prior to the use of this command.

---

## Page 73

# Commands to load NRF code

This command is used to load a selected routine without necessarily loading all routines in the same file, even if these routines are referenced. If the specified symbol is not found in \<file name\>, no action is taken.

## 6.3.6. TOTAL-SEGMENT-LOAD

TOTAL-SEGMENT-LOAD \<file name\>...

| \<file name\> | - the name of a file in NRF format. Default file type is :NRF. |

This command will load all modules of an NRF file of structure (a), (b) or (c) except for those modules already loaded. For structure (a) it will act as LOAD-SEGMENT except for modules already loaded, which will be skipped with no warning message given.

---

## Page 74

# Commands to Load NRF Code

## 6.4. COMMON Segments

Fortran COMMON areas may either be placed in the same segment as other data, or they may be put in their own segment(s). Arguments for using separate COMMON segments are similar to other segmenting: a different protection, memory allocation or sharing is desired for the COMMON segments than for other data areas.

Own data segments for the COMMON areas may be defined by the commands below. These segments will not have corresponding program segments (unless the segments have been previously opened with OPEN-SEGMENT, in which case the existing program segment is ignored). Common segments are special only in the sense that they facilitate selective loading and linking of common blocks.

These commands apply mainly to Fortran programs. Common blocks defined by a Fortran program may be referenced by some languages. A label is defined on a common segment if the NRF language code of the loaded module is FORTRAN and data mode is set (DMO control number, see chapter 12), or if the label has been explicitly defined on a common segment by the DEFINE-ENTRY or the DEFINE-COMMON command.

### 6.4.1. COMMON-SEGMENT-OPEN

**COMMON-SEGMENT-OPEN** (`<segment name>`), (`<attributes>`)

| `<segment name>` | The name of a segment to be used for common areas in subsequent loading. Default name is COMMON-SEGMENT. |
| `<attributes>`   | A string of the letters ROPDMEWCFN. Default is WC. |

Prepare a common-data-segment as an additional current data-segment.

The `<attributes>` have the same meaning as for OPEN-SEGMENT, section 6.2.1., where the option letters are explained.

The default segment when loading a common block is the last one specified in a COMMON-SEGMENT-OPEN command. However, common areas can be placed on any segment by defining the common label on those segments prior to loading the file containing the common block. See the DEFINE-COMMON command (section 6.7.4.).

Each program/data segment pair may have up to three common segments. Any data segment may be opened as a common segment to any program segment. COMMON-SEGMENT-OPEN will clear the segment—if code is to be added to an already loaded common segment or it will be linked to, COMMON-SEGMENT-APPEND should be used.

ND-60.136.04

---

## Page 75

# Commands to Load NRF Code

## 6.4.2. COMMON-SEGMENT-CLOSE

**COMMON-SEGMENT-CLOSE**

Loading to all currently defined common segments is terminated. After this command, there is no current common segment. Loading of common areas may continue, but they will be located in the current data segment unless they were already defined on one of the common segments.

This command is not required before opening a new program segment, common segment or EXIT.

## 6.4.3. COMMON-SEGMENT-APPEND

**COMMON-SEGMENT-APPEND** `(<segment name>)`

| `<segment name>` | - name of an existing segment, to which more common blocks will be added. Default is COMMON-SEGMENT. |

Common blocks defined in NRF files to be loaded will be located after the data already loaded to `<segment name>`. `<segment name>` must exist when the command is executed. The access of the segment is not changed. Only the data segment is affected.

This command may also be used to link a previously loaded common segment to another program segment, as an alternative to LINK-SEGMENT. With respect to the data segment these two commands are identical, but LINK-SEGMENT will also link to a program segment, if it exists. This could cause unintended linking of accidentally synonymous entry points. The COMMON-SEGMENT-APPEND will if used on a normal segment consisting of both a program and a data segment, link to the data segment only.

## 6.4.4. COMMON-SEGMENT-NUMBER

**COMMON-SEGMENT-NUMBER** `<segment number>`

| `<segment number>` | - a number in the range 0:37B to be the logical segment number of the current common segment. Default is 33B. |

Same as SET-SEGMENT-NUMBER except that COMMON-SEGMENT-NUMBER applies to the last common segment specified in a COMMON-SEGMENT-OPEN or COMMON-SEGMENT-APPEND command. The user will normally not be concerned with the segment number used.

ND-60.136.04

---

## Page 76

# Auto-link segments

## 6.5. Auto-link segments

An auto-link segment is linked if there are still undefined references after the specified files are loaded when the CLOSE-SEGMENT command is executed. If undefined references still exist after the auto-link segments defined by the current user have been linked, the auto-link segments defined by SYSTEM are linked. Auto-link segments are linked before the auto-load files are loaded.

Auto-link segments are language sensitive, and will be linked only if one or more module of the language(s) associated with it are already loaded.

### 6.5.1. SET-AUTO-LINK-SEGMENT

SET-AUTO-LINK-SEGMENT `<segment name>`, `<language>` ...

| Parameter     | Description                                                                                        |
|---------------|----------------------------------------------------------------------------------------------------|
| `<segment name>` | The name of a segment to be automatically linked at CLOSE-SEGMENT if undefined references remain. |
| `<language>`  | A combination of FORTRAN, ASSEMBLER, PLANC, COBOL or PASCAL.                                       |

Defines the segment with name `<segment name>` as an auto-link segment. The auto-link segment specified will be valid until the command DELETE-AUTO-LINK-SEGMENT is used. The auto-link segment applies only to the user who has defined it. Auto-link segments defined by user SYSTEM apply to all users; however, after the auto-link segments of that user have been linked.

The `<language>` name may be abbreviated as long as it is unambiguous.

The buffer containing the auto-link segment names can hold a maximum of six entries. This does not include auto-link segments defined by user SYSTEM. If the segment name is abbreviated in this command, it is not expanded before the name is saved. Thus, to avoid ambiguity with segments defined at a later time, the name should not be abbreviated.

It is not checked whether the segment exists at the time when it is defined as an auto-link segment by this command. If the segment is not present when the automatic linking is performed, it is ignored; no error message is issued.

---

## Page 77

# 6.5.2. DELETE-AUTO-LINK-SEGMENT

DELETE-AUTO-LINK-SEGMENT

All the user-defined auto-link segments are deleted permanently. The auto-link segments defined by user SYSTEM will also be removed, but only until NLL is reentered.

After a DELETE-AUTO-LINK-SEGMENT new permanent auto-link segments may be defined with the SET-AUTO-LINK-SEGMENT command.

# 6.5.3. LIST-AUTO-LINK-SEGMENTS

LIST-AUTO-LINK-SEGMENTS

Writes on the output device all the auto-link segments in the sequence they will be linked. Both the user's own and SYSTEM's auto-link segments will be listed.

ND–60.136.04

---

## Page 78

# Auto-load Files

## 6.6. Auto-load Files

An auto-load file is an NRF file which is automatically loaded when the command CLOSE-SEGMENT is executed and any undefined references exist. The auto-load files are loaded _after_ the defined auto-link segments are linked.

The auto-load files will be loaded in the sequence that they are specified. If after loading all the user-defined auto-load files there are still undefined references, the auto-load files of user SYSTEM will be loaded.

The auto-load files are language dependent. Only those files specified as auto-load files for the language used, will be loaded. If a system consists of modules of different languages, auto-load files will be loaded for all languages used, in the order they have been specified with the SET-AUTO-LOAD-FILE command.

### 6.6.1. SET-AUTO-LOAD-FILE

`SET-AUTO-LOAD-FILE <file name>, <language>`

| Parameter   | Description                                                                                                                                                  |
|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<file name>` | The name of a file to be automatically loaded if undefined references remain at CLOSE-SEGMENT.                                                              |
| `<language>` | Combination of FORTRAN, ASSEMBLER, PLANC, COBOL or PASCAL.                                                                                                  |

An auto-load file may be specified with more than one language parameter, indicating that the file should be loaded if routines written in either language have been loaded.

File names defined by the command SET-AUTO-LOAD-FILE, will be stored permanently for the current user, and will only be removed by use of the command DELETE-AUTO-LOAD-FILE.

The buffer containing the auto-load file names can hold a maximum of six entries. This does not include auto-load files defined by user SYSTEM.

ND-60.136.04

---

## Page 79

# Auto-load files

## 6.6.2. DELETE-AUTO-LOAD-FILE

**DELETE-AUTO-LOAD-FILE**

All the auto-load files defined by the current user are deleted permanently. The auto-load files defined by user SYSTEM will also be removed, but only until NLL is reentered.

After a DELETE-AUTO-LOAD-FILE new permanent auto-load files may be defined with the SET-AUTO-LOAD-FILE command.

## 6.6.3. LIST-AUTO-LOAD-FILE

**LIST-AUTO-LOAD-FILE**

Lists all the auto-load files in the sequence that they will be loaded. Both the user's own and SYSTEM's auto-load files will be listed.

ND-60.136.04

---

## Page 80

# Label and reference handling

## 6.7. Label and reference handling

References may be of four kinds:

- a program reference in the program segment. This occurs for example when a routine is called and the routine address is a part of the instruction operand.

- a data reference in the program segment. Any instruction operating on a variable data item will make this kind of reference.

- a program reference in the data segment. If a jump address or subroutine address is found in the data segment (referenced through a general operand specifier, in assembler terms), this occurs.

- a data reference in the data segment. A data value contains the address of another data value, a displacement etc.

If the references can be defined at compile (or assembly) time, the user will not be aware of them. However, if the referenced item is not located within the NRF module of the reference, a symbolic name is associated with it. A value to be given to the symbol may be defined either by another NRF module, or by the user from the terminal.

The user may also make references of all the four kinds mentioned above. This is mainly used for forcing specific library modules to be loaded.

Wherever a numeric parameter is called for in the commands below, this parameter may be a decimal or octal number, or it may be a previously defined symbol (either defined by a command or by loading an NRF module). The symbols #PCLC and #DCLC are available to indicate the current program location counter (load address) and current data location counter, respectively.

### 6.7.1. PROGRAM-REFERENCE

**PROGRAM-REFERENCE \<symbol\>, (\<address\>), (\<space\>)**

<table>
<tr>
<td>\<symbol\></td>
<td>the name of a defined or undefined symbol.</td>
</tr>
<tr>
<td>\<address\></td>
<td>the address where the reference is made in the program segment. Default is 0. Symbolic as well as numerical addresses are legal.</td>
</tr>
<tr>
<td>\<space\></td>
<td>P or D, indicating a symbol defined in the program or the data segment, respectively. Default is P.</td>
</tr>
</table>

If \<symbol\> is not present in the loader table, it will be entered as an undefined program label reference at \<address\>. If \<symbol\> is present but as an undefined reference, \<symbol\> will be referenced once more in the \<address\> specified.

---

## Page 81

# Label and Reference Handling

If `<symbol>` is an already defined label, its value will immediately be put into the `<address>` specified. Otherwise, as soon as it is defined, it will be put into all addresses from where it has been referenced.

Default `<address>` causes no modification of any memory location if the symbol was undefined when the command was given, and is later defined.

## 6.7.2 DATA-REFERENCE

**DATA-REFERENCE** `<symbol>, (<address>), (<space>)`

| Term     | Description |
|----------|-------------|
| `<symbol>` | the name of a defined or undefined symbol. |
| `<address>` | the address where the reference is made in the data segment. Default is 0. Symbolic as well as numerical addresses are legal. |
| `<space>` | P or D, indicating a symbol defined in the program or the data segment, respectively. Default is D. |

If `<symbol>` is not present in the loader table, it will be entered as an undefined data label reference at `<address>`. If `<symbol>` is present but as an undefined reference, `<symbol>` will be referenced once more in the `<address>` specified.

If `<symbol>` is an already defined label, its value will immediately be put into the `<address>` specified. Otherwise, as soon as it is defined, it will be put into all addresses from where it has been referenced.

Default `<address>` causes no modification of any memory location if the symbol was undefined when the command was given and is later defined.

## 6.7.3 DEFINE-ENTRY

**DEFINE-ENTRY** `<label>, (<value>), (<space>)`

| Term     | Description |
|----------|-------------|
| `<label>` | the name of a not yet defined symbol. |
| `<value>` | the value assigned to the label. Default is 0. |
| `<type>` | P or D, representing whether a defined symbol is a program or data symbol, respectively. Default is P. |

`<label>` will be entered into the loader table as a defined symbol. The value will be equal to `<value>`. If the default value is used, no modification of the current load address is done.

If the entry is already defined, an error message is issued.

ND-60.136.04A

---

## Page 82

# Label and Reference Handling

## 6.7.4 DEFINE-COMMON

DEFINE-COMMON `<symbol name>`, `(<size>)`, `(<value>)`

| Parameter     | Description                                                                                            |
|---------------|--------------------------------------------------------------------------------------------------------|
| `<symbol name>` | the name of a common block.                                                                            |
| `<size>`       | the size of the common area to be defined. Default is undefined size.                                  |
| `<value>`      | the value of the common symbol. Default is undefined value, but on the current data segment or last common segment specified. |

The common label will be entered into the loader table as a symbol to define the common data block. If `<value>` is zero, the common label will be allocated from the current data load address. If `<value>` plus `<size>` is larger than the current data load address on the segment where the symbol is being defined, the current data load address is adjusted upwards to this value.

The common block is placed on the current data segment, or if common segments are open, on the last common segment specified in a `COMMON-SEGMENT-OPEN` or `COMMON-SEGMENT-APPEND` command.

Default `<size>` will cause the size to be determined the first time it is defined during loading of code. If the default `<size>` is used, `<value>` may not be specified.

Default `<value>` will cause the actual allocation of the common block to be done at the current load address when a definition of the symbol is loaded from an NRF file. If `<size>` is specified, the common block will have this size regardless of the defined size of the first occurrence of the common block. This can be used to override the limitation that the first definition of a common block must be the largest one.

## 6.7.5 LIST-ENTRIES-DEFINED

LIST-ENTRIES-DEFINED `(<sort criterium>)`

| Parameter     | Description                                   |
|---------------|-----------------------------------------------|
| `<sort criterium>` | NUMERICAL or ALPHABETICAL. Default is NUMERICAL. |

All defined labels together with their values and space (P or D) and the current load address will be written to the output device. The `<sort criterium>` determines whether the list is sorted according to the symbol name or to their numerical value.

If the command SYSTEM-ENTRIES-ON is given before the LIST-ENTRIES-DEFINED command, all entries are listed. Otherwise, only user-defined entries are listed.

---

## Page 83

# 6.7.6. LIST-ENTRIES-UNDEFINED

LIST-ENTRIES-UNDEFINED (<sort criterium>)

<sort criterium> - NUMERICAL or ALPHABETICAL. Default is NUMERICAL

All undefined entries (references) in the loader table, together with their referenced address and space (P or D), will be written on the output device. If a symbol is referenced several places, it is written once for each reference, each with the address of the reference.

The <sort criterium> determines whether the list is sorted according to symbol name or to the numerical address of the references.

# 6.7.7. LIST-MAP

LIST-MAP

Writes the load map on the output device. This includes the addresses of all undefined references followed by the addresses or values of defined labels, both sorted in numerical order.

# 6.7.8. SYSTEM-ENTRIES-ON

SYSTEM-ENTRIES-ON

The command LIST-ENTRIES-DEFINED will not print the system defined labels. System defined labels will have their first character equal to # or [. If a list including system defined entries is desired, the command SYSTEM-ENTRIES-ON must be issued before the command LIST-ENTRIES-DEFINED. When system entries are printed, the language is included. Program entries containing an entry point specifying a fixed data area (INIT, ENTM, ENTF, ENTFN and ENTT instructions) rather than stack allocation will be followed by a slash and the address of the local data area.

LIST-ENTRIES-UNDEFINED will print the referenced system entries without using the command SYSTEM-ENTRIES-ON.

The SYSTEM-ENTRIES-ON command applies to the next LIST-ENTRIES-DEFINED only, and the command must be given every time a list of system defined labels is required.

ND-60.136.04

---

## Page 84

# Label and Reference Handling

## 6.7.9. GLOBAL-ENTRIES

GLOBAL-ENTRIES `<label>` ...

`<label>` - name of symbol to be retained on :LINK file.

The entries in the loader table, except those referred to in this command, are removed from the loader table before the table is written on the :LINK file. This is useful if only a subset of the routines on the segment should be made global. This command must be issued before the segment is closed.

If the GLOBAL-ENTRIES command has not been executed, all entries in the loader table will be retained on the :LINK file. In either case, all symbols will be truncated to 20 characters.

## 6.7.10. KILL-ENTRIES

KILL-ENTRIES `<symbol>` ...

`<symbol>` - the name of an entry to be removed from the loader table.

If present, the symbol(s) specified will be removed from the loader table. The entry may be defined or undefined. This command is used to resolve name conflicts, avoid loader table overflow and to selectively prohibit symbols from being saved on the :LINK file.

ND-60.136.04

---

## Page 85

# 6.8. Areas shared with ND-100 processes

The following commands are used to define sharing of segments with ND-100 processes. The programmer must have experience with ND-100 real time programming in order to utilize these commands, as he is responsible for synchronizing with ND-100 processes and the protection of common areas.

Readers who do not need to communicate with ND-100 processes may skip this section.

## 6.8.1. MATCH-RTCOMMON

MATCH-RTCOMMON

All RT-COMMON labels defined by the RT-LOADER (see the Real Time Guide ND-60.133) will be defined as common labels in the loader table. The addresses are transformed to ND-500 addresses. The RTCOMMON area will start at the next free page boundary in the current common segment if any is defined; otherwise it will be located in the data segment.

The MATCH-RTCOMMON command should be used before the program modules referring to the RT-COMMON area are loaded.

The names of defined labels will be reformatted from the BRF format (6 bits per character) to NRF format (ASCII bytes), addresses will be converted to byte addresses and an offset representing the relative ND-500 address is added.

The MATCH-RTCOMMON command applies to ND-100/ND-500 communication. A domain using RTCOMMON should not be copied to other machines with the COPY-DOMAIN command. The size of RTCOMMON must not be changed after the domain is loaded; that will require reloading. The RTCOMMON area must be contiguous.

## 6.8.2. MATCH-COMMON-RT-SEGMENT

MATCH-COMMON-RT-SEGMENT `<segment number>`

`<segment number>` - the number of an ND-100 segment.

All segment common labels defined by the RT-LOADER on the segment specified will be defined as common labels in the loader table. The MATCH-COMMON-RT-SEGMENT command should be used before the program modules referring to the segment common are loaded.

The MATCH-COMMON-RT-SEGMENT command applies to ND-100/ND-500 communication. A domain making references to ND-100 segments should not be copied to another machine with the COPY-DOMAIN command. A maximum of five ND-100 segments, RTCOMMON inclusive, is available.

ND-60.136.04

---

## Page 86

Areas shared with ND-100 processes

### 6.8.3 LINK-RT-PROGRAM

**LINK-RT-PROGRAM**

Defines the RT programs defined by the RT-LOADER. The command should be used after the program modules referring to the RT program names are loaded. Only RT program names which are referenced in the loader table are defined by the command.

The LINK-RT-PROGRAM command applies to ND-100/ND-500 communication. A domain making references to RT programs should not be copied to another machine with the COPY-DOMAIN command.

ND-60.136.04

---

## Page 87

# 6.9. Miscellaneous commands

## 6.9.1. PAGE-MODE

**PAGE-MODE** \[<P/D>\]

| <P/D> | - P indicating the program segment, D indicating the data segment. Default is both P and D. |

The current load address on the segment (program or data as specified) is rounded up to the next page limit. Thus, the next load command will start loading from an address that is a multiple of 4000B. This is primarily useful in order to allocate data areas for I/O at page limits, thereby optimizing use of the file system.

## 6.9.2. LOW-ADDRESS

**LOW-ADDRESS** (<address>), (<space>)

| <address> | - Address in the range 0:777777777B. Default value is 4. |
| <space> | - P, D or C or combinations of these, indicating program, data or common address, respectively. Default is PD. |

The lower load address for subsequent loading to the current segment is set. If C is specified, the load address is set on the last common-segment specified in a COMMON-SEGMENT-OPEN or COMMON-SEGMENT-APPEND command.

If the load address is set to a higher value than the current load address, a hole may remain in the file if the affected pages have never been assigned to the segment file. If a NO SUCH PAGE condition occurs at execution time, the Monitor will zero fill the page in memory. If the page has been used at an earlier time, the old contents will be used, and may for practical purposes be considered unpredictable.

---

## Page 88

# Miscellaneous Commands

## 6.9.3. HIGH-ADDRESS

**HIGH-ADDRESS** (<address>), (<space>)

| Parameter | Description |
|-----------|-------------|
| `<address>` | address in the range 0:777777777B. Default value is 777777777B. |
| `<space>`  | P, D or C or combinations of these, indicating program, data or common address, respectively. Default is PD. |

This command sets the highest address available on a segment. If any loading above the specified upper high address is attempted, a warning message is issued and the loading process interrupted.

## 6.9.4. ENTRY-ROUTINES

**ENTRY-ROUTINES** (<number of entries>)

| Parameter | Description |
|-----------|-------------|
| `<number of entries>` | the maximum number of routines to be loaded on the current segment. Default is 200B. |

A library segment will at the start of the segment have a "routine vector": when a routine is called from another segment, control goes via this vector - the first element in the vector represents the first routine on the segment, the second element the second routine and so on. If the routines are modified and change their relative position, no relinking of other segments is necessary as long as the routine vector is updated and the routine number stays the same.

This command will allocate space for a routine vector of the specified size, and must be given before any loading to the segment. `<number of entries>` should be at least the maximum number of routines that will be loaded to the segment.

All manipulation of the routine vector is done by NLL, and the user need not be concerned about how the link from other segments is set up.

The entries in the routine vector are initialized to zero, but will be filled in by NLL as code is loaded to the program segment.

---

## Page 89

# Miscellaneous commands

## 6.9.5. SET-IO-BUFFERS

**SET-IO-BUFFERS (<number>)**

| `<number>` | - the number of 2k byte buffers to be used by the Fortran library for sequential I/O for file buffering. Default is 16. |

This command should be used only when a Fortran library segment is created, or for any reason the Fortran library is loaded to the main segment. From ordinary programs, the Fortran library will be linked to the main segment, and the I/O buffers will already have been allocated in the data segment of the library.

The command specifies a number of input/output buffers for more efficient handling of sequential files in Fortran. Two system labels will be defined, at the lower and upper limits of the buffer area, and the current load address will be increased by the size of the buffer area. The total size of all buffers will be `<number>` * 2048 bytes. The user should choose an appropriate number of buffers; the normal number is one for each simultaneously opened sequential file. If a Fortran library segment is being created, 16 buffers should be specified.

The labels defined by this command will be used by the Fortran I/O system to determine the location and the size of the buffer. No other use of the area is made.

## 6.9.6. LIST-OCTAL

**LIST-OCTAL <low address>, <high address>, <space>**

| `<low address>` | - the address from which listing should start. Default is 0. |
| `<high address>` | - the address up to which listing should continue. Default is `<low address>`+200B. |
| `<space>` | - P or D, indicating program or data memory, respectively. Default is D. |

The contents of the locations between `<low address>` and `<high address>` will be written on the output device in octal format, together with the byte address.

---

## Page 90

# Miscellaneous Commands

## 6.9.7. LIST-SYMBOLIC

LIST-SYMBOLIC (<low address>), (<high address>), (<space>)

| Parameter      | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| `<low address>`  | The address from which listing should start. Default is 0.                  |
| `<high address>` | The address up to which listing should continue. Default is `<low address>`+200B. |
| `<space>`        | P or D, indicating program or data segment, respectively. Default is P.     |

The contents of the locations between `<low address>` and `<high address>` will be written on the output device in a disassembled format, together with the byte address.

This command is not allowed in ND-100 or PIOC computer mode.

## 6.9.8. LIST-MODE

LIST-MODE

Everything that is loaded is written on the output device in octal format as it is being read from the NRF file. LIST-MODE will be terminated by DISASSEMBLE-MODE.

## 6.9.9. DISASSEMBLE-MODE

DISASSEMBLE-MODE

Everything that is loaded is written on the output device in disassembled format as it is being loaded from the NRF file. Disassemble-mode will be terminated by LIST-MODE.

This command is not allowed in ND-100 or PIOC computer mode.

---

## Page 91

# Miscellaneous commands

## 6.9.10. CHECK-SYNTAX-MODE

**CHECK-SYNTAX-MODE**

If this command is executed, the following commands up to `EXIT` are checked for syntactic correctness in the command processor only. They will not be executed.

This is helpful for checking a batch or mode job before it is started.

## 6.9.11. RESET

**RESET**

Removes all symbols from the loader table and resets load addresses to the initial low addresses, which is in ND-500 mode 4 for both program, data and common segments, in ND-100 mode 0 for program and data, in PIOC mode 0 for program, 100000B for data.

Observe that NRF code is loaded directly to the segment files. Thus, RESET cannot be used to discard loaded code and revert the segment files to the state they were before loading was started.

## 6.9.12. RENAME-DEFAULT-DIRECTORY-AND-USER

**RENAME-DEFAULT-DIRECTORY-AND-USER** `(<new directory:new user>)`

`(<new directory:new user>)` - the new unabbreviated directory and user name, including parentheses and colon.

If the default directory and/or the user must be renamed with the Sintran III commands @RENAME-DIRECTORY and @RENAME-USER, this command must be used in order to make the domain and segment descriptions in the description file consistent with the new Sintran III names. An exact match with the user and directory name is required, including the parentheses and the colon.

ND-60.136.04

---

## Page 92

# Miscellaneous commands

## 6.9.13. SUPPRESS-DEBUG-INFORMATION

**SUPPRESS-DEBUG-INFORMATION (<ON/OFF>)**

| <ON/OFF> | - ON if debug info should be suppressed, OFF if it should be retained. Default is ON. |

If the parameter is specified as ON, all debug information in subsequently loaded files will be discarded, rather than saved on the :LINK file. If the command is given with the parameter OFF, copying of the debug info to the :LINK file will be resumed (the initial state of NLL).

The primary purpose of this command is to reduce the size of the :LINK file. It may also be used if the Symbolic Debugger will be used, when parts of the system are already completely debugged so that no further debugging of these parts will be done. Suppressing the debug info will then prevent breakpoints, line or routine tracing in the selected parts.

## 6.9.14. COMPUTER-MODE

**COMPUTER-MODE <100/500/PIOC> [<P/D>]**

| <100/500/PIOC> | - either 100 indicating code for the ND-100 computer, 500 indicating code for the ND-500 computer or PIOC indicating code for the Programmable I/O Controller. Initially the NLL is in 500 mode. |

| [<P/D>] | - sets the NLL to Program or Data mode. |

NLL may be set in a mode to load code for the ND-100 computer by specifying COMPUTER-MODE 100. This will change default file type to BRF, and files loaded are assumed to be in BRF format. Program, data and debug information will all be loaded to the :PSEG file, but in the same format as an ordinary ND-100 :PROG file, and may be executed with a $RECOVER command. The :DSEG file is not used.

COMPUTER-MODE PIOC will load code for the MC68000 processor in NRF format. Be aware that although the relocation information is equal to that of the ND-500 the processors have very different instruction sets. The executable code is loaded to the :PSEG file; the :DSEG file will contain the same information in BPUN format that may be read by the RT-LOADER command *READ-BINARY into an ND-100 segment.

COMPUTER-MODE 500 will reset NLL to the initial mode, loading ND-500 code in NRF format into :PSEG, :DSEG and :LINK files.

Certain commands are not legal in 100 or PIOC mode.

ND-60.136.04

---

## Page 93

# Miscellaneous commands

The second parameter (optional), specifies whether the current load is to be of type Program or Data. The default is type Program.

---

## Page 94

# NRF editor

## 6.10. NRF editor

The NRF editor commands manipulate modules of an NRF file, that is, the information delimited by BEG and END control numbers. Control numbers and mnemonics are described in chapter 12. A module is identified by any of the DEF, DDF or LIB symbols defined within it. Modules are treated as indivisible units; specifying one (of several) symbols in a module denotes the entire module.

These commands are mainly used by system supervisors and system programmers who have to maintain libraries of NRF code. A familiarity with the NRF format is desirable in order to use these commands.

## 6.10.1. NEW-NRF-MODULES

NEW-NRF-MODULES `<new modules file>`, `<NRF file>`

| Parameter           | Description                                                                                                                                 |
|---------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| `<new modules file>`| the name of an NRF file containing the new modules to replace the old ones. Default file type is :NRF.                                       |
| `<NRF file>`        | the NRF file to be updated. Default file type is :NRF.                                                                                      |

The NRF modules in `<NRF file>` with the same identification as the NRF modules in the `<new modules file>` will be replaced by the NRF modules in the `<new modules file>`. The various NRF modules in `<NRF file>` will have their same relative position within the file after the NEW-NRF-MODULES command as before. NRF modules in the `<new modules file>` not found in `<NRF file>` will be skipped and a warning message given. NRF modules without symbolic names cannot be replaced.

## 6.10.2. FETCH-NRF-MODULES

FETCH-NRF-MODULES `<source file>`, `<destination file>`  
`(<first module>)`, `(<last module>)`

| Parameter            | Description                                                                                                                                |
|----------------------|--------------------------------------------------------------------------------------------------------------------------------------------|
| `<source file>`      | the name of an NRF file containing the modules to be appended.                                                                             |
| `<destination file>` | the name of an NRF file to be appended to.                                                                                                 |
| `<first module>`     | the first module from the source file to be appended to the destination file. Default is the first module in the source file.               |
| `<last module>`      | the last module from the source file to be appended to the destination file. Default is the last module in the source file.                | 

ND-60.136.04

---

## Page 95

# NRF Editor

The NRF modules in the `<source file>` starting with the `<first module>`, including every module up to the `<last module>` will be appended to `<destination file>` after the last NRF module in the `<destination file>`.

## 6.10.3. APPEND-NRF-MODULE

**APPEND-NRF-MODULE** `<source file>, <destination file> (<after module>)`

| `<source file>`      | the name of an NRF file containing the modules to be appended. |
|----------------------|----------------------------------------------------------------|
| `<destination file>` | the name of an NRF file to be appended to.                     |
| `<after module>`     | the module in the destination file after which the new modules will be appended. Default is after the last module. |

All NRF modules in the `<source file>` will be appended to `<destination file>` after the specified NRF module in the `<destination file>`.

## 6.10.4. DELETE-NRF-MODULES

**DELETE-NRF-MODULES** `<file name>, (<first module>), (<last module>)`

| `<file name>`   | the name of an NRF file. Default file type is :NRF.                  |
|-----------------|---------------------------------------------------------------------|
| `<first module>`| a symbol defined in the first module to be deleted. Default is the first module in the file.  |
| `<last module>` | a symbol defined in the last module to be deleted. Default is the last module in the file.  |

The specified NRF modules will be deleted from `<file name>`. `<first module>` is the first module which will be deleted, and then all NRF modules following and including `<last module>` will be deleted.

ND-60.136.04

---

## Page 96

# NRF editor

## 6.10.5. LIST-NRF-ENTRIES

**LIST-NRF-ENTRIES** `<file name>`

| `<file name>` | - the name of an NRF file. Default file type is :NRF. |

This command will list all DEF, DDF and LIB symbols in `<file name>` on the output device, together with their byte address in the file.

## 6.10.6. LIST-NRF-CODE

**LIST-NRF-CODE** `<file name>, (<first module>), (<last module>)`

| `<file name>`    | - the name of an NRF file. Default file type is :NRF. |
| `<first module>` | - the name of a symbol defined in the file, identifying the first module to be listed. Default is the first module in the file. |
| `<last module>`  | - the name of a symbol defined in the file, identifying the last module to be listed. Default is the last module in the file. |

All NRF information in the specified modules in the `<file name>` will be listed in the following format: location counter, NRF control number, name of NRF control number. In addition symbolic names will be written in ASCII format. Binary information will be written in both disassembled ND-500 format (if program code) and octal format.

---

## Page 97

# 6.10.7. WRITE-NRF-EOF-AFTER-MODULE

**WRITE-NRF-EOF-AFTER-MODULE** `<file name>, (<module>)`

| Parameter    | Description                                                                                                                                                     |
|--------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<file name>`| the name of an NRF file. Default file type is .NRF.                                                                                                             |
| `<module>`   | the name of a symbol defined in the NRF file, identifying the last module still valid. Default is to insert the EOF control number in front of the first module in the file. |

Write the NRF control number 260 (EOF) after the specified NRF module in `<file name>`. If the default value for the parameter `<module>` is used, the EOF byte is written as the first byte on the `<file name>`.

# 6.10.8. INSERT-NRF-MESSAGE

**INSERT-NRF-MESSAGE** `<file name>, (<module>), <message>`

| Parameter    | Description                                                                                   |
|--------------|-----------------------------------------------------------------------------------------------|
| `<file name>`| the name of an NRF file. Default file type is .NRF.                                           |
| `<module>`   | the name of a symbol defined in the file, identifying a module in front of which the message will be located. Default is the first module in the file. |
| `<message>`  | any character string excluding space up to the first carriage return.                        |

This command inserts the message in the NRF `<file name>` before `<module>`. If the file is prepared with the PREPARE-NRF-LIBRARY-FILE command, the default `<module>` is in the front of the address table in `<file name>`.

The specified message will be written on the output device when the file is loaded. If the file is a library file headed by an address table, a message in front of the address table will be written; all other messages (defined by this command) are located outside NRF modules, and will not be written.

In the `<message>`, a dollar sign will be converted to Carriage Return and Line Feed.

ND-60.136.04

---

## Page 98

# NRF editor

## 6.10.9. PREPARE-NRF-LIBRARY-FILE

PREPARE-NRF-LIBRARY-FILE `<file name>`

`<file name>` - the name of an NRF file. Default file type is `:NRF`.

This command will set up an address table in front of `<file name>` containing all LIB symbols together with their byte addresses in `<file name>`. This will convert the file from structure "b", slow library file, to "c", fast library file, as described in the chapter on 'Commands to load NRF code'. `<file name>` must be the output of a compilation with library mode set. If a library is prepared by this command, conditional loading is done much more efficiently.

The address table is invalidated by all commands modifying the contents of the NRF file, and the table must be rebuilt if a sequential search of the file is to be avoided.

---

## Page 99

# 7. COMMANDS AVAILABLE IN THE NLL AND THE MONITOR

These commands may be issued either during the loading of the program, or at run time, before the program is executed. Some of the commands, those defining trap handling, will define defaults if used in NLL. These defaults may be overridden in the Monitor. If the command is given in the Monitor, it applies to the current job only, and will not permanently influence the properties of the segment or domain.

Some commands behave slightly differently in NLL and the Monitor. Such differences are explained under each command.

## 7.1. Utility commands

### 7.1.1. HELP

HELP (\<command name\>)

\<command name\> - any command abbreviation, ambiguous or non-ambiguous. Default is all commands available.

All commands matching \<command name\> are written with their parameters on the output device. Parameters enclosed in brackets [] are optional parameters that will not be prompted for if not supplied.

### 7.1.2. LIST-DOMAIN

LIST-DOMAIN (\<domain name\>)

\<domain name\> - the name or abbreviation of names to be listed. Default is all domains belonging to the current user.

Writes all domains with names matching \<domain name\> and their start addresses (if any) on the output device.

The Monitor allows a user name to be specified in parentheses as a prefix to \<domain name\>; in NLL the LIST-SEGMENT command must be used to list domains and segments belonging to other users.

ND-60.136.04

---

## Page 100

# Utility commands

## 7.1.3. OUTPUT-FILE

OUTPUT-FILE (<file name>)

| `<file name>` | - the name of the file where output is desired. Default is the communication device. |

This command is used to define an output device different from the current one (initially the communication device). Most output will go to `<file name>`, but commands, parameter prompt and error messages will continue to appear on the communication device. The `<file name>` is used as an output device until EXIT or a new OUTPUT-FILE command is given.

## 7.1.4. RUN

RUN

The current domain is started in its start address.

In NLL code may be loaded without specifying a domain and segment, and the code will be loaded directly to (virtual) memory. The RUN command may then be used to execute this code. (See section 15.6.)

In the Monitor, the command must have been preceded with a PLACE-DOMAIN or DEBUG-PLACE command in order to bring the domain into memory. Return will be to the Monitor after execution has completed.

## 7.1.5. @ (Sintran-III command)

@<command>

If a line starts with the `@` character, the remainder of the line is assumed to be a Sintran III command and executed through the COMND monitor call.

Be aware that control will not return to NLL or the monitor after execution of the command if another subsystem or user program was called by the command. Also, if an error occurs during the execution of the command, control will not return to the calling program.

In NLL, if a loading is in progress when the Sintran III command is executed and control does not return, the description file may have been left in an inconsistent state. It may be necessary to use the RELEASE-DOMAIN command to gain access to the segment that was current, and the contents will be unpredictable.

The Monitor will check the command issued before it is submitted to Sintran III, and will allow only a subset of Sintran III commands.

---

## Page 101

# Utility commands

## 7.1.6. CC

CC any text

Comment; whatever follows on the same line as the CC command is ignored and treated as a comment. This command is primarily useful for making comments in a batch or mode job.

## 7.1.7. ABORT-BATCH-ON-ERROR

ABORT-BATCH-ON-ERROR `<ON/OFF>`

| `<ON/OFF>` | - ON if batch jobs should terminate if an error occurs, OFF if only the current command should be terminated. |

If an error occurs in a batch or mode job and this command has been executed with the parameter OFF, only the current command is aborted and the next command in the batch input file is executed. If the command has not been executed or executed with the parameter ON, the entire job is terminated. The error message will be written on the batch output file, and in NLL the commands CLOSE-SEGMENT and END-DOMAIN will be executed (if required).

This command may be specified several times, switching the batch termination on and off before and after critical sequences.

## 7.1.8. EXIT

EXIT

Returns to the Sintran III command processor.

In NLL, if not explicitly done the CLOSE-SEGMENT and END-DOMAIN commands are executed if a segment is opened or a domain set.

In the Monitor this command releases the allocated ND-500 resources. If the buffer used by the histogram and logging commands was reserved, it will be released.

If NLL was started after entering the Monitor, return will be to the Monitor. Otherwise, return will be to Sintran command mode.

In the Monitor, this command is also used to return from the LOOK-AT commands.

---

## Page 102

# Trap Handling

## 7.2. Trap Handling

The ND-500 trap mechanisms may be used to detect and handle exceptional conditions occurring at execution time. The user may optionally specify a routine to take care of the trap, or it may be handled by a standard library routine.

Some of the traps are by default system enabled, others are locally enabled and handled by the library routines. The default settings are discussed in chapter 4., Standard Exception Handler Routines.

The names of the trap conditions and the label of the standard handlers are:

| Trap Name                         | Label      |
|-----------------------------------|------------|
| OVERFLOW                          | #OVERFLW   |
| INVALID-OPERATION                 | #INVALOP   |
| DIVIDE-BY-ZERO                    | #INVALDI   |
| FLOATING-UNDERFLOW                | #FLTUFLW   |
| FLOATING-OVERFLOW                 | #FLTOFLW   |
| BCD-OVERFLOW                      | #BCDOFLW   |
| ILLEGAL-OPERAND-VALUE             | #ILLOPER   |
| SINGLE-INSTRUCTION-TRAP           | #SINGINS   |
| BRANCH-TRAP                       | #BRANCTR   |
| CALL-TRAP                         | #CALLTRA   |
| BREAK-POINT-INSTRUCTION-TRAP      | #BRKPINTR  |
| ADDRESS-TRAP-FETCH                | #ADDRFTC   |
| ADDRESS-TRAP-READ                 | #ADDRREAD  |
| ADDRESS-TRAP-WRITE                | #ADDRWRTE  |
| ADDRESS-ZERO-ACCESS               | #ADDZERO   |
| DESCRIPTOR-RANGE                  | #DESCRIR   |
| ILLEGAL-INDEX                     | #ILLINDX   |
| STACK-OVERFLOW                    | #STKOFLW   |
| STACK-UNDERFLOW                   | #STKUFLW   |
| PROGRAMMED-TRAP                   | #PROGTRA   |
| DISABLE-PROCESS-SWITCH-TIMEOUT    | #DISPSWT   |
| DISABLE-PROCESS-SWITCH-ERROR      | #DISPSWE   |
| INDEX-SCALING-ERROR               | #INXSCAL   |
| ILLEGAL-INSTRUCTION-CODE          | #ILLINCOD  |
| ILLEGAL-OPERAND-SPECIFIER         | #ILOPSPE   |
| INSTRUCTION-SEQUENCE-ERROR        | #INSEQUE   |
| PROTECT-VIOLATION                 | #PVIOLAT   |

---

## Page 103

# 7.2.1. LOCAL-TRAP-ENABLE

**LOCAL-TRAP-ENABLE** `<label>` `<trap condition>` ...

| Parameter         | Description                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------------|
| `<label>`         | - the name of a user written or library exception handler routine. Default is the standard handler in the library for the specified `<trap condition>`.                        |
| `<trap condition>`| - one of the trap names above or an unambiguous abbreviation.                                  |

The bit in the OTE register corresponding to the specified `<trap condition>` will be set, thereby causing the trap condition to be reacted upon if it occurs. The `<trap condition>` parameter must be one or more of the names in the table above. Abbreviations are legal as long as they are non-ambiguous.

The `<label>` is inserted in the table of exception handler routines. This table may contain different labels for each trap condition, or one routine may be used by several traps. The default trap handler has a label as specified in the table above. NLL will cause the standard handlers used to be loaded from the standard library. The Monitor allows the `<label>` to be specified either as an absolute address or as a defined program label. This label must be present in the .LINK file of the segment. If the `<label>` is omitted and an exception handler routine is defined, it is not modified. If no handler was defined, the standard library handler is used. This requires that the standard routine was previously loaded.

The trap handler allocated by NLL is an array located at the most recently modified segment (OPEN-SEGMENT or APPEND-SEGMENT) in the domain.

# 7.2.2. LOCAL-TRAP-DISABLE

**LOCAL-TRAP-DISABLE** `<trap condition>` ...

| Parameter         | Description                                                                                   |
|-------------------|-----------------------------------------------------------------------------------------------|
| `<trap condition>`| - one of the trap names above or an unambiguous abbreviation or ALL.                          |

The bit in the OTE register corresponding to the specified `<trap condition>` is cleared, thereby disabling trap handling for that trap condition. If ALL is specified, all traps will be locally disabled. This is mainly used in order to override the default setting before a new selection of traps is enabled.

The routine defined in the exception handler table is not cleared. If the OTE bit is later set (by program or by using the LOCAL-TRAP-ENABLE command in the monitor before execution is started), the routine defined in the LOCAL-TRAP-ENABLE command acts as the default exception handler. 

ND-60.135.04

---

## Page 104

# Trap handling

## 7.2.3. SYSTEM-TRAP-ENABLE

SYSTEM-TRAP-ENABLE `<trap condition>` ...

`<trap condition>` - one of the trap names above or an unambiguous abbreviation.

The `<trap condition>` specified will be handled by the Monitor residing in the ND-100 when the condition occurs. It will be given a standard treatment, which varies with the kind of trap.

If a local trap handler is defined and the local trap enabled, it will be used rather than the system trap handler. System trap handling is used only for those trap conditions that are locally disabled or have no local trap handling defined.

## 7.2.4. SYSTEM-TRAP-DISABLE

SYSTEM-TRAP-DISABLE `<trap condition>` ...

`<trap condition>` - one of the trap names above or an unambiguous abbreviation.

The `<trap conditions>` specified will not be reacted upon by the system when the condition occurs.

A number of trap conditions may not be system disabled. If a modification of these traps are attempted, an error message is issued and the command ignored.

## 7.3. VALUE-ENTRIES

VALUE-ENTRIES `<label>`...

`<label>` - the name of a defined symbol.

Prints the values of the labels specified on the output device. The value is printed in octal format. The label will also be identified as a program or as a data segment label.

ND-60.136.04

---

## Page 105

I'm sorry. The page provided seems to be blank, so there's no content to convert to Markdown.

---

## Page 106

# MONITOR COMMANDS

## 8. MONITOR COMMANDS

Most commands in this chapter need not be known to the ordinary ND-500 user. The one command used for executing an ND-500 program, the RECOVER-DOMAIN command, is implicit if no match with other commands is found. Thus, in order to start execution of a domain, it is sufficient to give the domain name as a command.

A domain name may also be specified on the same line as the command to start the Monitor. If a domain is executed this way, control will return to Sintran III immediately after execution is complete. Otherwise, the EXIT command must be used in the Monitor.

Various error messages may be returned from the ND-500 Monitor during command and program execution. These error messages are listed in chapter 14, with short explanations and references to where they may occur.

## 8.1. Commands for running an ND-500 program

### 8.1.1. PLACE-DOMAIN

PLACE-DOMAIN <domain name>

| `<domain name>` | - the name of a domain in the description file of the current user or the user specified in parentheses as a prefix to `<domain name>`. |

An executable ND-500 domain is made ready for execution. The specified `<domain name>` is searched for on the description file of the current user. If no match is found, the description file of user SYSTEM is scanned. A user name prefixing `<domain name>` is valid. The syntax is equal to the file system syntax.

If the specified domain is found, some initialization is performed. The start address is moved into the program counter register. The child trap enable register of ND-100, the own trap enable register of the domain and the trap handler address register are initialized. Each logical segment is mapped on a physical segment.

The program segment will normally map directly onto the :PSEG file. Several users may be using the same physical segment, although the segments may be logically different. It is assumed that the program segments are read only. This means that breakpoints cannot be used, and patching is not possible. The DEBUG-PLACE command will permit modifications.

The data segment is initially mapped on the :DSEG file. Upon page fault the required page is read from the file. When modifications are made, the affected pages are not written back to the :DSEG file but to a scratch area on a swap file. This copy is used for later references. Each concurrent user of the data segment has his own copy of modified pages.

---

## Page 107

# Commands for Running an ND-500 Program

pages on the swap file, and is thus independent of other users. The physical segment corresponding to the data segment is therefore a mixture of unmodified pages in the :DSEG file and modified pages in the swap file.

## 8.1.2. RECOVER-DOMAIN

**RECOVER-DOMAIN** `<domain name>`

`<domain name>` - the name of a domain in the description file of the current user, user SYSTEM or if user name specified, of that user.

The PLACE-DOMAIN and RUN commands are performed as one by using the command RECOVER-DOMAIN. The words RECOVER-DOMAIN can be left out. The domain name itself becomes a pseudo command. The procedure for looking up the command or domain is then as follows:

1. A search is made in the list of basic commands. If a match is found, the corresponding command is executed.

2. If no command is found, the list of standard domains are searched (see section 8.2.). If there is any such standard domain, it is started.

3. If the search among the standard domains was unsuccessful, a search is made in the domains of the current user. If a domain with the specified name is found, it is started as with a RECOVER-DOMAIN command.

4. If no domain with the specified name is found, the domains of user SYSTEM are searched. If a domain with a matching name is found, the domain is started.

5. If no domain is found, the specified string is assumed to be a macro name, and a temporary macro is searched for. If any matching macro is found, it is processed. (See section 8.4. for a discussion of macros.)

6. If no match is found among the temporary macros, the name is assumed to be the name of a permanent macro. If a file with the specified string as name and type :MACR exists, it is taken as a permanent macro and processed. The file system will ensure that if a file with the specified name is not found under the current user, the directory of user SYSTEM is searched.

7. If none of the above lead to a successful match, the error message NO SUCH COMMAND OR DOMAIN is printed on the communication device, and no further action will result from the entered input.

If a domain has been given the name of or a legal abbreviation of a command or standard domain, the words RECOVER-DOMAIN may not be left out.

_ND-60.136.04_

---

## Page 108

# Commands for running an ND-500 program

## 8.1.3. GO

GO `<address>`

`<address>` - an address within the domain.

Starts the execution of an ND-500 program at the specified address.

## 8.1.4. CONTINUE

CONTINUE

The execution is restarted at the current program counter. There is one exception: if a program has stopped normally (by MON 0 or a stack underflow trap) the execution is started at the original start address.

If the execution has stopped because of a breakpoint, the original instruction will be restored. If the breakpoint is a permanent breakpoint, a single instruction is performed, and the original instruction is replaced by a breakpoint instruction before the execution is started.

If the execution has stopped because an escape character was typed, the execution will be restarted where it stopped. Files will remain opened after an escape, and the program will continue as if nothing had happened.

ND-60.136.04

---

## Page 109

# 8.2. Standard domains

The search procedure employed when a command is issued will not find domains belonging to user SYSTEM until the name has been ruled out as a monitor command or as the name of a domain belonging to the current user. In particular if the file system is heavily loaded, the opening and reading of the description file may take some time, and increase the system load even more.

To speed the search for commonly used systems, like compilers or the NLL loader, these domains may be defined as **standard domains**. The names of standard domains are entered in a table that is searched by the monitor before the description file of a user is opened. This will reduce startup time.

Standard domain names are stored in a segment used by the monitor, therefore the name table will not survive a cold start (JHENT/22!). After a warm start (masterclear/load), the name table is intact.

Standard domains in many respects resemble "reentrant subsystems" in the ND-100, and essentially, the rules are the same. Standard domains may only be defined and deleted by user SYSTEM, but they may be listed by any user.

## 8.2.1. DEFINE-STANDARD-DOMAIN

**DEFINE-STANDARD-DOMAIN** `<standard domain name> <domain name>`

| Element                  | Description                                                                                           |
|--------------------------|-------------------------------------------------------------------------------------------------------|
| `<standard domain name>` | the name to be used when calling the domain. May be the same as the domain name, but may not include user name. It should not be a legal abbreviation of a monitor command. |
| `<domain name>`          | name of an already loaded domain, belonging to any user                                               |

When any user issues `<standard domain name>`, or an unambiguous abbreviation of it, as a command, `<domain name>` will be started. If the user has a private domain that would otherwise have been started, the name must include the user name in parentheses.

DEFINE-STANDARD-DOMAIN is permitted for user SYSTEM only.

---

## Page 110

# Standard domains

## 8.2.2. DELETE-STANDARD-DOMAIN

DELETE-STANDARD-DOMAIN \<name\>

| \<name\> | - name of an existing standard domain |

The specified standard domain is deleted from the name table of standard domains. The domain will not be deleted, but will no longer be a standard domain.

DELETE-STANDARD-DOMAIN is permitted for user SYSTEM only, and may not be issued while the standard domain is in use.

## 8.2.3. LIST-STANDARD-DOMAINS

LIST-STANDARD-DOMAINS

The names of all standard domains and the segments comprising them are listed on the output device.

This command is permitted for all users.

---

## Page 111

# 8.3. Input and output

In most programs, files are dynamically opened and closed during program execution. In some cases it is desirable to open files explicitly through commands. This occurs in particular where Fortran programs are transported from other machines where all files must be opened through operating system commands prior to program execution, or where transportation to such machines is probable. These commands may, however, be used to open files for programs in any language allowing a file to be identified by its open file number.

The commands below are similar to the Sintran III commands with the same names, but will affect files opened for use by the ND-500.

## 8.3.1. OPEN-FILE

`OPEN-FILE <file name>, <connect file number>, <access mode>`

- `<file name>` - the name of a file to be used by a program. Default file type is :DATA.
- `<connect file number>` - the file number used in the program.
- `<access mode>` - see table below.

Opens a file and connects it to a file number used in the program. If `<connect file number>` is 0 a file number is returned that must be used from the program.

Default number base of `<connect file number>` is the main format - initially octal. If a decimal number is specified, it must be followed by a D. Unit numbers in Fortran programs are decimal.

The opened file will be associated with a Sintran file number, usually ranging from 100B and upwards, in a manner equivalent to ND-100 operation. However, the monitor maintains a connect number table, allowing programs to access the file either through the Sintran file number or through the user selected connect number.

Access modes:

| Mode | Code | Description |
|------|------|-------------|
| W    | 0    | Sequential write (OUTBT, OUTST) |
| R    | 1    | Sequential read (INBT) |
| WX   | 2    | Random read/write (RFILE/WFILE) |
| RX   | 3    | Random read (RFILE) |
| RW   | 4    | Sequential read/write (INBT/OUTBT, OUTST) |
| WA   | 5    | Sequential write append |
| WC   | 6    | Random read/write with read/write access allowed from other users (contiguous files only). |
| RC   | 7    | Random read with read access allowed from other users (contiguous files only). |

ND-60.136.04

---

## Page 112

# Input and Output

| Code | Description                                       |
|------|---------------------------------------------------|
| D    | 8 direct transfer                                 |
| DC   | 9 direct transfer with the file closed, modus 9.  |

WRITE 10 The system will select the access mode RW, WX or D. The most optimal access mode which can be used for the file/device is selected. The following is a list of file/devices and the corresponding access mode selected by the system:

- terminal: RW
- indexed file: WX
- contiguous file: D
- magnetic tape: D

READ 11 The system will select the access mode R, RX or D, as for WRITE access above (For tape reader R access will be selected by the system).

## 8.3.2 CLOSE-FILE

**CLOSE-FILE <connect number>**

<connect number> - the connect number of a file open from a ND-500 program or through the OPEN-FILE command.

Closes a file and disconnects the file number.

<file number> 

- > 0 close the file open with the given number
- = -1 close all files temporarily open
- = -2 close all open files
- = -3 close all files open from the ND-500 program or by the OPEN-FILE command in the Monitor.

## 8.3.3 LIST-OPEN-FILES

**LIST-OPEN-FILES**

Lists all files opened from a ND-500 program or by the OPEN-FILE command in the Monitor. The list will appear on the output device.

Files opened locally in the ND-100 will not be listed.

ND-60.136.04A

---

## Page 113

# 8.3.4. SET-BLOCK-SIZE

**SET-BLOCK-SIZE** `<connect number>` `<block size>`

| Parameter       | Description                                                                                       |
|-----------------|---------------------------------------------------------------------------------------------------|
| `<connect number>` | - the connect number of a file open from a ND-500 program or through the OPEN-FILE command.     |
| `<block size>`  | - default block size in bytes when accessing disk or magnetic tape.                              |

Sets the block size used for I/O transfers to or from disk or magnetic tape. The file may be opened by the OPEN-FILE command or MON OPEN (MON 50B). The block size may be modified by the program by the SETSS monitor call (MON 768).

---

## Page 114

# Input and Output

|       |      |
|-------|------|
| 101   |      |
| ND-60 | 136.04 |

---

## Page 115

# 8.3.5. Error returns

Monitor calls from the ND-500 may return error codes outside the range used by ND-100 and they can take values of 1000B and upwards as below:

| Code (dec.) | Code (oct.) | Error message |
|-------------|-------------|---------------|
| 512         | 1000B       | ND-500 OPEN FILE TABLE IS FULL |
| 513         | 1001B       | FILE IS NEITHER CONTIGUOUS NOR MAG. TAPE |
| 514         | 1002B       | ND-500 OPEN FILE TABLE FOR DIRECT TRANSFER IS FULL |
| 515         | 1003B       | ERROR IN MONITOR CALL |
| 516         | 1004B       | ODD BYTE ADDRESS |
| 517         | 1005B       | ODD BYTECOUNT |
| 518         | 1006B       | TOO BIG BYTECOUNT |
| 519         | 1007B       | BYTECOUNT NOT MODULO SECTOR SIZE IN DIRECT TRANSFER |
| 520         | 1010B       | ADDRESS OUTSIDE FILE LIMITS IN DIRECT TRANSFER |
| 521         | 1011B       | BLOCK ADDRESS NOT MODULO SECTOR SIZE IN DIRECT TRANSFER |
| 522         | 1012B       | HARDWARE STATUS ERROR IN DIRECT TRANSFER |
| 523         | 1013B       | ILLEGAL MONITOR CALL NUMBER |
| 524         | 1014B       | DC ACCESS NOT LEGAL ON MAG. TAPE |
| 525         | 1015B       | WRONG NUMBER OF PARAMETERS IN MON. CALL |
| 526         | 1016B       | BYTE POINTER NOT MODULO SECTOR SIZE IN DIRECT TRANSFER |
| 527         | 1017B       | DATA AREA CANNOT BE PUT IN A 64K SINTRAN III SEGMENT |
| 528         | 1020B       | SEGMENT NOT MODIFYABLE |
| 529         | 1021B       | BYTECOUNT NOT MODULO BLOCK SIZE IN DIRECT TRANSFER |
| 530         | 1022B       | ILLEGAL OPERATION ON FILE CONNECTED TO A SEGMENT |
| 531         | 1023B       | FILE ALREADY CONNECTED TO A SEGMENT |
| 532         | 1024B       | ALL LOGICAL DATA SEGMENTS USED |
| 533         | 1025B       | LOGICAL DATA SEGMENT ALREADY USED |
| 534         | 1026B       | BLOCK SIZE NOT MODULO SECTOR SIZE |
| 535         | 1027B       | ADDRESS OUTSIDE PROGRAM SEGMENT |
| 536         | 1030B       | ADDRESS OUTSIDE DATA SEGMENT |
| 537         | 1031B       | TRYING TO WRITE SEGMENT BACK ON SYSTEM SWAP FILE |
| 538         | 1032B       | ILLEGAL MEMORY TYPE OF SPECIFIED AREA |
| 539         | 1033B       | MAX GLOBAL FIX |
| 540         | 1034B       | ERROR IN ABSOLUTE FIX |
| 541         | 1035B       | OTHER SEGMENTS HAS USER FIXED PAGES IN THE SPECIFIED AREA |
| 542         | 1036B       | OTHER SEGMENTS HAS SYSTEM FIXED PAGES IN THE SPECIFIED AREA |
| 543         | 1037B       | IMPOSSIBLE TO DO FIX CONTIGUOUS BECAUSE OF ALREADY SYSTEM FIXED PAGES |
| 544         | 1040B       | IMPOSSIBLE TO DO FIX CONTIGUOUS BECAUSE OF ALREADY USER FIXED PAGES |
| 545         | 1041B       | NO CONTIGUOUS AREA AVAILABLE BECAUSE OF SYSTEM FIXED OF OTHER SEGMENTS |
| 546         | 1042B       | NO CONTIGUOUS AREA AVAILABLE BECAUSE OF USER FIXED OF OTHER SEGMENTS |
| 547         | 1043B       | IMPOSSIBLE TO DO CONTIGUOUS FIX. AREA GREATER THAN PHYSICAL MEMORY |
| 548         | 1044B       | NOT ENOUGH MEMORY RESERVED BY THE ND-500 |
| 549         | 1045B       | TRYING TO FIX PAGES SHARED WITH A SINTRAN III SEGMENT |
| 550         | 1046B       | SEGMENT NOT IN USE |
| 551         | 1047B       | THE PROCESS HAS NO BEFORE IMAGE LOG SEGMENT |
| 552         | 1050B       | NO SWAP-FILE PART AVAILABLE |

---

## Page 116

# Input and Output

| Code | Error Number | Description                        |
|------|--------------|------------------------------------|
| 553  | 1051B        | SWAPPING SPACE NOT AVAILABLE       |
| 554  | 1052B        | NO FREE PHYSICAL SEGMENT           |
| 555  | 1053B        | SEGMENT NOT MODIFYABLE             |
| 556  | 1054B        | ILLEGAL PROCESS NUMBER             |
| 557  | 1055B        | SWAP DEVICE ERROR                  |
| 558  | 1056B        | PRIVILEGED MONITOR CALL            |
| 559  | 1057B        | ILLEGAL LOGICAL SEGMENT NUMBER     |
| 560  | 1060B        | NO SUCH PROCESS                    |
| 561  | 1061B        | ILLEGAL ADDRESS                    |

These error messages may also be written with the ERMSG monitor call (MON 64B). Explanations of these error messages are found in Chapter 14, which contains all error messages that may be issued by the ND-500 Monitor.

File system error codes known in ND-100 are explained in Sintran III Reference Manual, ND-60.128.

---

## Page 117

# 8.3.6. Direct file transfer with RFILE and WFILE (disk)

Direct file transfer is a feature for optimized disk transfer to the ND-500. It allows very high transmission speeds between disk and memory, moving a maximum of one disk cylinder per request for disk transfer. (One monitor call may cause several disk transfers if the amount of data exceeds one cylinder.)

The file is opened by the OPEN-FILE command, modus D or DC or from the ND-500 program by the monitor call OPEN, modus 8 or 9. In modus 8, the file is kept open; in modus 9 the file is closed during the file transfer.

The modus 9 feature allows the user to work on a larger number of files than the maximum number of files that can be concurrently open in the Sintran III file system.

The standard calls RFILE, WFILE and WAITF are used in the ND-500 program, but there are some limitations to the parameters. See the Sintran III Reference Manual ND-60.128 for a description of these monitor calls.

The actual file transfer is performed by the monitor call ABSTR. The file system is bypassed and the mass storage device may be used in an optimal way.

The monitor calls RMAX and SMAX may be used if the file is opened (modus 8).

The limitations to the use of the standard Sintran III file system are:

- The file must be contiguous.

- Only the monitor calls OPEN, CLOSE, RFILE, WFILE, WAITF, RMAX and SMAX may be used.

- The default logical block size is equal to the hardware sector size.

- The word count in RFILE or WFILE must be a multiple of the hardware sector size of the mass storage device.

- The maximum byte pointer is not updated when DC is used.

- The data area to be transferred to or from must be contiguous in physical memory. (This is, however, automatically done by the Monitor at execution time if required.)

ND-60.136.04

---

## Page 118

# Input and output

## 8.3.7. Direct file transfer with MAGTP (magnetic tape)

Direct file transfer is a feature for optimized magnetic tape transfer to the ND-500. It allows data records of arbitrary size to be transferred, bringing the transmission speed close to the maximum speed of the hardware.

The file is opened by the OPEN-FILE command, modus "D" or from the ND-500 program by the monitor call OPEN, modus 8. The modus "DC" (or 9) may not be used for MAGTP.

The monitor call MAGTP may be used in a standard way from the ND-500, but the actual transfer is performed by the ABSTR monitor call in ND-100 and it goes directly from the interface into the ND-500 memory via the DMA channel. The only limitation to the block size is the maximum size of contiguous physical memory that may be allocated.

---

## Page 119

# 8.3.8. Terminal I/O

When the ordinary monitor calls for terminal I/O, INBT and OUTBT, are used from ND-500 the ND-100 shadow process is activated for each byte transferred, causing a considerable overhead in the ND-100 CPU.

Two monitor calls, DVINST and DVOUTS, are available from the ND-500 for more efficient communication with the terminal. The ND-500 CPU will operate directly on the terminal datafield; the call consumes minimal ND-100 CPU time.

| DVINST | <device no> <max no. of bytes> <no. of bytes returned> <buffer> <break strategy> <echo strategy> |
|--------|---------------------------------------------------------------------------------------------|
| <break table 1> <break table 2> <break table 3> <break table 4> |
| <echo table 1> <echo table 2> <echo table 3> <echo table 4> |

The \<device no> parameter must be the Sintran III file number or device number rather than the connect file number. This is because the translation from connect number to file number takes place in ND-100 routines which are not used by the DVINST call. The Sintran III file number may be obtained by opening the file specifying connect number zero, or it may be obtained through the GTYPR monitor call. In background, the user’s own terminal may be identified by device number 1 (one).

| <break table 1 / 2 / 3 / 4> = bit 0-31 / 32-63 / 64-95 / 96-127 of new break table. |
|------------------------------------------------------------------------------------------------|
| <echo table 1 / 2 / 3 / 4> = bit 0-31 / 32-63 / 64-95 / 96-127 of new echo table. |

Strategies apply if the device is a terminal. If the strategy = 7 the specified break or echo tables are copied to the terminal datafield. If the strategy = 8 the old user-specified tables are used without reading new ones from the user data segment.

The call may be used for file I/O as well, in which case only the first four parameters apply. Input will be terminated when the input buffer is full, or at end of file.

| DVOUTS | <device no> <no. of bytes> <buffer> |
|--------|------------------------------------|

The specified number of bytes are output. \<device no> must be the Sintran III file number or device number, rather than the connect number.

ND-60.136.04

---

## Page 120

# Macro commands

## 8.4. Macro commands

Macros provide a convenient mechanism for executing the same set of commands repeatedly. This is particularly useful for programs requiring certain initialization commands to be given before execution starts, for initialization after a system restart, or for executing a set of debug commands. Each user may in fact build his own set of commands from the elementary commands available in the Monitor.

It is not possible to supply input to a program in a macro body.

Macros may be saved in files, or they may be temporary, vanishing when the Monitor is left.

### 8.4.1. DEFINE-MACRO

DEFINE-MACRO `<macro name>`  
`<macro body>`

END-MACRO

With this command it is possible to compose new commands from the original commands or other macros.

Macros defined by this command are temporary. Permanent macros may be prepared by a text editor on a file. The file must be of type :MACR.

Every line following the DEFINE-MACRO command is taken as the macro body until the END-MACRO is encountered. END-MACRO must be written on a new line.

It is possible within the macro body to define parameters that are replaced by the actual parameters when the macro is called. A parameter is defined by

**PARAMETER** `<parameter name>`, `<default value>`, `<prompting text>`

If spaces or commas should be part of the `<parameter name>`, `<default value>` or `<prompting text>`, they may be enclosed in apostrophes. Otherwise, apostrophes are permitted but not required.

The first actual parameter supplied in the macro call line replaces `<parameter name>` used in the first PARAMETER definition; the second actual parameter replaces `<parameter name>` used in the next PARAMETER definition and so on. Excessive parameters are ignored.

When the macro is called, the parameters which are not specified are asked for by typing the prompting text on the communication device. If the actual parameter is empty the default value is used when expanding the macro.

ND-60.136.04

---

## Page 121

# 8.4.2. Macro subcommands

A monitor call, MACRO (MON 400B), for signalling error return from a program to the Monitor is implemented. There is a flag which is raised when the executing program is terminated by this monitor call or by a trap. The error flag is set to zero when a program is terminated normally.

Two commands may be used within a macro to test the error flag:

## 8.4.2.1. IF-ERROR-MACRO-STOP

IF-ERROR-MACRO-STOP

Causes the currently executing macro to abort if the error flag is set. If the error flag is reset, the processing of the macro continues.

## 8.4.2.2. IF-ERROR-FULL-STOP

IF-ERROR-FULL-STOP

Equal to IF-ERROR-MACRO-STOP except that all active macros are aborted if the error flag is set.

By default, the expansion of the macro is printed on the output device. This printing may be suppressed by

## 8.4.2.3. NOLIST

NOLIST

The printing of macro expansions is suppressed.

## 8.4.2.4. LIST

LIST

The printing of macro expansions to the output file is reinstated. This is the default mode when a macro expansion is started. Macro subcommands may not be abbreviated.

ND-60.136.04

---

## Page 122

# Macro commands

## 8.4.3. EXECUTE-MACRO

**EXECUTE-MACRO** `<macro name>, [<parameters>]...`

| **Element**    | **Description**                                                                                   |
|----------------|---------------------------------------------------------------------------------------------------|
| `<macro name>` | the name of an existing (temporary or permanent) macro.                                           |
| `<parameter>`  | actual parameter to replace a formal parameter in the macro. If several parameters are supplied they are separated by comma or space. The parameter may contain any character except space or comma. |

The macro with the specified name is processed. Formal parameters are substituted with actual parameters. If the actual parameters are not supplied, they are prompted for with \<leading text\> specified in the PARAMETER definition (see the DEFINE-MACRO command).

The words EXECUTE-MACRO can be left out. The procedure used for looking up a command or macro is as follows:

1. A search is made in the list of basic commands. If a match is found, the corresponding command is executed.
2. If no command is found, the list of standard domains are searched (see section 8.2.). If there is any such standard domain, it is started.
3. If the search among the standard domains was unsuccessful, a search is made in the domains of the current user. If a domain with the specified name is found, it is started as with a RECOVER-DOMAIN command.
4. If no domain with the specified name is found, the domains of user SYSTEM are searched. If a domain with a matching name is found, the domain is started.
5. If no domain is found, the specified string is assumed to be a macro name, and a temporary macro is searched for. If any matching macro is found, it is processed. (See section 8.4. for a discussion of macros.)
6. If no match is found among the temporary macros, the name is assumed to be the name of a permanent macro. If a file with the specified string as name and default type :MACR exists, it is taken as a permanent macro and processed. The file system will ensure that if a file with the specified name is not found under the current user, the directory of user SYSTEM is searched.
7. If none of the above lead to a successful match, the error message NO SUCH COMMAND OR DOMAIN is printed on the communication device, and no further action will result from the entered input.

Temporary macros may be defined within permanent macros. Such temporary macros will be erased when the processing of the permanent macro is finished.

ND-60.136.04

---

## Page 123

# Macro Commands

If a macro is given the name of, or a legal abbreviation of a command, a standard domain or a domain belonging to the current user or SYSTEM, EXECUTE-MACRO may not be left out.

Input to the program may not be supplied in a macro body.

## 8.4.4. RESUME-MACRO

**RESUME-MACRO**

The last aborted macro is resumed at the line following the one where the macro was interrupted.

## 8.4.5. ERASE-MACRO

**ERASE-MACRO** `<macro name>...`

`<macro name>` - the name of an existing temporary macro.

The named temporary macros are erased. Permanent macros are erased through the Sintran III command `@DELETE-FILE <macro name>:MACR`.

## 8.4.6. DUMP-MACRO

**DUMP-MACRO** `<macro name>`

`<macro name>` - the name of an existing temporary macro.

The named temporary macro will be written to a file with the name of the macro, i.e. the macro is made permanent and can at a later time be executed by using the macro name as a command. If the file does not exist, it will be created. The default type of the file is `:MACR`.

---

## Page 124

# Macro Commands

## 8.4.7. LIST-MACRO

**LIST-MACRO (<macro name>)**

| <macro name> | - a macro name or abbreviation of names of the macros to be listed. Default is all macros defined. |

The names and contents of the macros with names matching the specified name are listed on the output device.

Only temporary macros are listed. Permanent macros may be listed by the Sintran III command @LIST-FILES <macro name>:MACR, TERMINAL.

ND-60.136.04

---

## Page 125

# 8.5 Debugging commands

Before any debugging commands are used, a program must be moved into the user's virtual memory. This is done by the PLACE-DOMAIN or DEBUG-PLACE command, implicitly by a RECOVER-DOMAIN, or by the DEBUGGER command with the domain name as a parameter. If patches to the program segment are to be done, DEBUG-PLACE or the symbolic DEBUGGER must be used.

After program termination, either normal or error termination, the program is still in the virtual memory space and may be inspected or modified before restart. The program may be restarted by either one of the commands RUN, CONTINUE, GO or STEP, or the symbolic debugger may be activated by DEBUGGER. After error termination, the P register contains the address of the instruction following the last instruction executed. Depending on the kind of error, continuing execution from this address may be meaningless.

## 8.5.1 DEBUGGER

```
DEBUGGER [<domain name>]
```

| `<domain name>` | - the name of the domain to be debugged. Default is the domain currently in memory. |

The symbolic debugger is started with the specified or current domain as the system to be debugged. The commands of the symbolic debugger are documented fully in the manual Symbolic Debugger User's Guide, ND-60.158. Essentially, the available commands are a superset of the commands described below, allowing locations in both program and data memory to be specified by symbolic names rather than addresses.

For symbolic names to be available the program must have been compiled with the DEBUG-MODE option in the compiler turned ON. If the DEBUG-MODE option was off, the symbolic debugger may be used, but no symbolic references can be made.

The debugger is located on the files (SYSTEM)DEBUGGER:PSEG and (SYSTEM)DEBUGGER:DSEG. When started, it will execute as segment number 26D in the user domain; this segment number must not be used by the domain to be debugged.

The DEBUGGER command may be issued at any time during execution. The normal execution may be interrupted by pressing the "escape" key, after which the debugger is started and execution resumed from the interrupt point, now in debug mode.

ND-60.136.04

---

## Page 126

# Debugging Commands

## 8.5.2. SPECIAL-DEBUGGER

**SPECIAL-DEBUGGER** `<file name>`, `<log. segm. no>`, `[<domain name>]`

| Parameter       | Description                                                              |
|-----------------|--------------------------------------------------------------------------|
| `<file name>`   | name of :PSEG and :DSEG files with an alternative version of the symbolic debugger. |
| `<log. segm. no>` | the segment number used by the alternative debugger.                    |
| `<domain name>` | name of the domain to be debugged. Default is the domain currently in memory. |

This command is exactly equal to the DEBUGGER command, but allows the user to specify an alternative debugger, for example, the previous version or a version running on a different segment number.

## 8.5.3. DEBUG-PLACE

**DEBUG-PLACE** `<domain name>`

| Parameter       | Description                                 |
|-----------------|---------------------------------------------|
| `<domain name>` | the name of an existing domain.             |

The program segments as well as the data segments will be copied to the swap file. This allows patches to be done to the program segment. Patches are not permanent. In order to do permanent patches, LOOK-AT-PROGRAM must be used.

Otherwise, this command works exactly like PLACE-DOMAIN.

## 8.5.4. BREAK

**BREAK** `<address>`, `[<count>]`

| Parameter    | Description                                                                                                                      |
|--------------|----------------------------------------------------------------------------------------------------------------------------------|
| `<address>`  | the program address where a breakpoint is to be set.                                                                             |
| `<count>`    | one plus the number of times the breakpoint should be ignored before a break is performed. Default value is 1.                    |

This command sets a breakpoint at the specified address. If a positive number is specified for the count argument, the breakpoint will be passed `<count>`-1 times before reaction.

When the breakpoint is reached, execution terminates and control is passed to the command processor.

ND-60.136.04

---

## Page 127

# Debugging Commands

After a breakpoint has been reached, program or data locations or the registers may be displayed or modified. The display format may be changed at will. Control flow or data location tracing may be initiated and terminated. The next instruction to be executed is by default the instruction pointed to by the P register, but this may be overridden by the GO command or the optional \<execution start> parameter of the STEP command.

When execution is continued by the STEP or CONTINUE command, the original instruction is restored and a single step is performed followed by a reinsertion of the breakpoint. If a non-default execution start address was selected, the original instruction in the break address is not executed, and the breakpoint instruction is retained.

It is possible to set new breakpoints as long as the Monitor has memory space to store information about them. New breakpoints are given a number for identification purposes.

## 8.5.5. TEMPORARY-BREAK

**TEMPORARY-BREAK** \<address>, [\<count>]

- \<address> - the program address where the breakpoint is to be set.
- \<count> - one plus the number of times the breakpoint should be ignored before a break is performed. Default is 1.

Similar to BREAK except that when the breakpoint is reached, the original instruction is permanently restored and will not cause a break next time the instruction is executed.

## 8.5.6. STEP

**STEP** [\<step start>], [\<execution start>], [\<count>]

- \<step start> - the program address where single step execution should start. Default is the current value of the program counter.
- \<execution start> - the program address where execution should start. Default is the current value of the program counter.
- \<count> - one plus the number of times the address specified as \<step start> should be passed before single step execution is started. Default is 1.

ND-60.136.04

---

## Page 128

# Debugging Commands

Single step. If no parameter is given, the instruction pointed to by the program counter is disassembled and shown on the output device. By typing carriage return, this instruction will be executed. The next instruction will then be disassembled and shown on the output device and will be executed when another carriage return is given.

Typing anything else than a single carriage return causes return to the command processor of the Monitor.

If the `<step start>` parameter is given, normal execution is started from the current program counter, and single step is provided when the `<step start>` address is reached. If, in addition, the `<execution start>` parameter is given, the execution is started at the specified address rather than from the current program counter. The `<step start>` address will be passed `<count>` - 1 times before single step is provided; the default value will start single step execution as soon as the indicated `<step start>` address is reached.

This command may be used immediately after a domain has been placed in memory by the PLACE-DOMAIN (or DEBUG-PLACE) command. More commonly it is used when the program is in a temporary halt state after a breakpoint has been detected. A break is then inserted immediately before the program address where the tracing should start. From this point on, single instruction execution is started. If desired the contents of any register or data location may be inspected after each instruction executed. Any intermediate command (other than CR) will require that STEP be respecified in order to continue single step execution. Default parameters to the STEP command will cause the next instruction in sequence to be executed.

## 8.5.7. LOOK-AT Commands

By this set of commands it is possible to display and modify registers and locations in program and data memory.

An address in the current segment is specified by its 27 bit segment relative address. An address in an arbitrary segment may be specified as

`<segment no>` `<segment relative address>`

Generally, modification of program or data is not permanent. The modifications are made on a copy of the original :PSEG or :DSEG file. However, LOOK-AT-PROGRAM will make permanent modifications to the segment.

The LOOK-AT commands have a set of subcommands as follows:

| Command | Description |
| ------- | ----------- |
| cr      | Carriage return causes display of the next item (register, instruction, memory cell). |

---

## Page 129

# Debugging Commands

### EXIT
Return to the Monitor command processor.

### Special notation used with the slash (/, indirect) command:

| Symbol | Description                   |
|--------|-------------------------------|
| m      | address or register name.     |
| n      | number of bytes.              |
| cr     | carriage return.              |

- **m/cr**  
  Take the value of m as the address and display this location.  
  m may also be a register name.

- **/cr**  
  Take the contents of the current location as next address and display this location. If the current location is a register, displaying of the memory is started. Specifying the P or the L register cause the program memory to be displayed, while the rest of the registers cause the data memory to be displayed.

- **m,n/cr**  
  Take the value of m as next address and display n bytes. m may also be a register name.

- **,n/cr**  
  Same as /cr except that n bytes are displayed.

### Dumping of register, memory or segment to file:

- **m,n <output file> cr**  
  Same as m,n/cr except that the output is written to the specified file. The file is closed upon exit from LOOK-AT.

- **,n <output file> cr**  
  Same as ,n/cr except that the output is written to the specified file. The file is closed upon exit from LOOK-AT.

### HELP
Listing of all LOOK-AT subcommands

### n cr
Modifications of memory or registers are done by typing the new value in the current main format (octal, hexadecimal or decimal as set by the MAIN-FORMAT command) followed by carriage return. It is possible to use other formats than the main one by typing B, H or D before the carriage return for octal, hexadecimal or decimal respectively.

### 'XXX' cr
Modifying the data memory or a data segment by ASCII characters may be done by enclosing the ASCII string in quotes.

### CODE
Modification of program memory is possible by the command CODE followed by an ND-500 assembler instruction. The instruction will be assembled and stored starting at the current location. Program memory may also be modified numerically by first typing BY, and thereafter modifying bytes in the main format (See the MAIN-FORMAT command).

---
ND-60.136.04

---

## Page 130

# Debugging Commands

**BREAK**  
Setting a breakpoint in the current address may be done by the BREAK subcommand in LOOK-AT-PROGRAM.

**BYTE**  
**HALFWORD**  
**WORD**  
**FLOAT**  
**DOUBLEFLOAT**  
**ASCII**  
When displaying data memory it is possible to use byte, halfword, word single or double precision float or ASCII characters as a display unit. Changing from one unit to another is done by simply typing BYTE, HALFWORD, WORD, FLOAT, DOUBLEFLOAT, or ASCII.

**PERMIT-DEPOSIT**  
In order to avoid unintended modification of the memory or a register, the command PERMIT-DEPOSIT must be typed before the depositing of a new value can take place.

**EXTRA-FORMAT <format> ...**  
In a LOOK-AT command it is possible to temporarily specify that memory locations shall be displayed in the indicated formats in addition to the main format by the EXTRA-FORMAT command. This command is similar to the global EXTRA-FORMAT command, except that the extra formats are only valid within LOOK-AT.

**ABSOLUTE <address>**  
When relative addresses are displayed (LOOK-AT-STACK and LOOK-AT-RELATIVE), new addresses (number followed by a slash) are taken as relative addresses. However, displaying from an absolute address can be done by the ABSOLUTE command.

**NEW-SEGMENT <segment no>**  
The specified segment number will be set as current segment. Addresses specified without a segment number will be in the new current segment. The segment number is valid only while in LOOK-AT mode, and must be respecified next time LOOK-AT mode is entered.

In a LOOK-AT command it is possible to change to one of the other LOOK-AT commands by typing one of the subcommands below. This is equivalent to EXITing from LOOK-AT and reenter to inspect or modify another area (program, data or registers), but EXTRA-FORMAT need not be respecified, and it is faster. These subcommands are:

| Subcommand | Address/Register |
|------------|------------------|
| DATA       | <address>        |
| PROGRAM    | <address>        |
| REGISTER   | <register name>  |
| <register name> |            |
| STACK      |                  |
| RELATIVE   | <relative to>    |

---

ND-60.136.04

---

## Page 131

# 8.5.7.1. LOOK-AT-PROGRAM

LOOK-AT-PROGRAM `<address>`, `[<domain>]`

| Parameter | Description |
|-----------|-------------|
| `<address>` | the segment address from where inspection should start. |
| `<domain>`  | the name of an existing domain. Default is inspection of the domain currently in memory. |

Displays and modifies program memory or program segments. The display is started at the specified `<address>`.

If `<domain>` is specified, the program segment file is displayed and may be modified. Only one segment may be displayed and modified at a time.

Within the LOOK-AT-PROGRAM command, the subcommand BREAK may be specified, setting a breakpoint at the current address.

If `<domain>` is not specified, the default is the domain currently in memory. The memory image is inspected, rather than the original segment from which it was loaded. If any modifications are made, the domain must have been placed in memory by the DEBUG-PLACE command, otherwise no modification is legal.

# 8.5.7.2. LOOK-AT-DATA

LOOK-AT-DATA `<address>`, `[<domain>]`

| Parameter | Description |
|-----------|-------------|
| `<address>` | the segment address from where inspection should start. |
| `<domain>`  | the name of an existing domain. Default is inspection of the domain currently in memory. |

This command is similar to LOOK-AT-PROGRAM except that the data memory or data segment is involved. Modification is always permitted.

---

## Page 132

# Debugging commands

## 8.5.7.3. LOOK-AT-STACK

**LOOK-AT-STACK**

The current local data field is displayed. This is the memory area pointed to by the current B register, and contains the subroutine call information, such as address local data field of calling routine (PREVB), return address (RETA), number of arguments to the routine (N), the current top of stack (SP) and an auxiliary location for language processes (AUX) not used by hardware. At the next addresses are the addresses of the routine arguments, and the local variables of the routine.

The standard locations are labeled with the symbolic names above. For the argument addresses and the local variables two addresses are given, the global address and the address relative to the start of the local data field.

### 8.5.7.3.1. Subcommands PREVIOUS and NEXT

**PREVIOUS**

Display the previous local data field, i.e., the local data field of the procedure calling the current one. Several PREVIOUS commands may be given, each descending one more level in the call sequence. It is not possible to move beyond the data field of the main program (the lowermost stack frame).

**NEXT**

Display the next local data field, i.e. the local data field of the procedure called by the current one. Valid only after PREVIOUS. It is not possible to move beyond the data field of the routine currently being executed (the uppermost stack frame).

## 8.5.7.4. LOOK-AT-RELATIVE

**LOOK-AT-RELATIVE (<relative to>)**

`<relative to>` - B, R, I1, I2, I3, I4 or a numeric address. Default is R.

Start listing of data memory relative to either the contents of the R, B, I1, I2, I3 or I4 register or an address. Both global and relative address are displayed.

ND-60.136.04

---

## Page 133

# Debugging Commands

## 8.5.7.5. Look-At-Register

**LOOK-AT-REGISTER** `[<register name>]`

`<register name>` - the name of one of the registers. Default is P.

The specified register is displayed in current main format. If carriage return is typed, the next register in the sequence below is displayed. Registers identified as MIC are used by the microprogram and are not available to the user. Register sequence:

- P, L, B, R, I1, I2, I3, I4, 
- A1, A2, A3, A4, E1, E2, E3, E4, 
- ST1, ST2, PS, TOS, LL, HL, THA, CED, 
- CAD, MIC, MIC, MIC, OTE1, OTE2, CTE1, 
- CTE2, MTE1, MTE2, TEMM1, TEMM2

## 8.5.8. Set-Memory-Contents

**SET-MEMORY-CONTENTS** `<from address>, <up to address>, <value>, (<datatype>)`

- `<from address>` - the lower limit for modification of memory.
- `<up to address>` - the upper limit for modification of memory.
- `<value>` - the value to be written in the specified area.
- `<datatype>` - BYTE, HALFWORD, WORD, FLOAT or DOUBLEFLOAT indicating the size and type of the specified `<value>`. Default is WORD.

The data memory is filled with the specified value from the first address specified up to the second specified address, inclusively.

## 8.5.9. Main-Format

**MAIN-FORMAT** `<format>`

`<format>` - OCTAL, HEXADECIMAL or DECIMAL or abbreviation of one of these.

When displaying registers, memory contents, or segments with the LOOK-AT commands, the specified `<format>` is used. When the Monitor is started, octal is used as the main format.

The default MAIN-FORMAT may be modified by using the MAIN-FORMAT command, then leaving the Monitor by the EXIT command. The memory image can then be copied to a file by using the Sintran III command @DUMP. The :PROC file created by the @DUMP command will be equivalent to the existing monitor, but the default MAIN-FORMAT is as specified. 

ND-60.136.04

---

## Page 134

# Debugging Commands

before the @DUMP. Refer to the Sintran III Reference Manual ND-60.128 for a description of the @DUMP command.

## 8.5.10. EXTRA-FORMAT

EXTRA-FORMAT \<format> ...

\<format> - one of the formats listed below or an unambiguous abbreviation of one of them.

With all commands displaying memory or segment contents it is possible to have the locations displayed in various formats in addition to the format specified in the MAIN-FORMAT command. Data and instructions are then displayed in both the format(s) specified in this command as well as the main format. The alternatives are:

| **Format**     | **Description**                                                                                                                                               |
|----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| BYTE           | The displayed location is divided into bytes and they are displayed in the main format.                                                                       |
| HALFWORD       | Similar to BYTE, except halfwords are displayed. This is effective only when displaying words or doublewords as main format.                                   |
| WORD           | Similar to BYTE, except words are displayed. This is effective only when displaying doublewords as main format.                                              |
| FLOAT          | Single precision floating point format.                                                                                                                     |
| DOUBLEFLOAT    | Two consecutive words are displayed in double precision floating point format.                                                                               |
| ASCII          | ASCII format.                                                                                                                                                 |
| OCTAL          | Number base for BYTE, HALFWORD and WORD display.                                                                                                               |
| HEXADECIMAL    | Number base for BYTE, HALFWORD and WORD display.                                                                                                               |
| DECIMAL        | Number base for BYTE, HALFWORD and WORD display.                                                                                                               |

ND-60.136.04

---

## Page 135

# 8.5.11. TRACE

TRACE `<address>`, `<datatype>`

| `<address>` | the address of the variable to be traced (lowermost byte). |
|-------------|------------------------------------------------------------|
| `<datatype>` | BYTE, HALFWORD, WORD, FLOAT or DOUBLEFLOAT or abbreviation of one of these, indicating the size of the data element to be traced. |

Whenever the location starting at the specified address is modified during program execution, its new value is displayed on the output device.

This command uses the low and high limit registers, LL and HL of the ND-500 exclusively, i.e. the previous command using these registers (GUARD or TRACE) will be discontinued.

# 8.5.12. GUARD

GUARD `<address>`, `<datatype>`, `[<limit1>, [<limit2>]]`

| `<address>` | the address of the variable to be guarded (lowermost byte). |
|-------------|-------------------------------------------------------------|
| `<datatype>` | BYTE, HALFWORD, WORD, FLOAT or DOUBLEFLOAT or abbreviation of one of these, indicating the size of the data element to be traced. |
| `<limit1>` | the lower limit of the legal value range or upper limit of prohibited range. |
| `<limit2>` | the upper limit of the legal value range or lower limit of prohibited range. |

If no limits are given, any modification of the location specified in this command causes a guard violation error and gives control back to the command processor whenever the specified "guard area" is modified. The "guard area" starts at `<address>`, and `<datatype>` determines the size, from one to eight bytes.

If one or two limits (forming a legal range) are specified, the new value of the guard area is checked against this range. If the value is outside the range, it is a conditional guard violation and the control is transferred to the command processor. If `<limit1>` < `<limit2>`, then the permitted range is `<limit1>` ≤ n ≤ `<limit2>`. If `<limit1>` > `<limit2>` the new value n is legal if n < `<limit2>` or n > `<limit1>`.

If the variable has a value outside the permitted range at the time the command is given, this is not trapped. The check is made on assignments (store operations) to the variable only.

ND-60.136.04

---

## Page 136

# Debugging commands

If only `<limit1>` is specified, then `<limit2>` is set equal to `<limit1>`, allowing the variable to take the specified value only.

This command will cause a considerable load on the ND-100 if frequent modifications of the guarded area are made.

This command uses the LL and HL registers exclusively to delimit the start address and uppermost address of the guarded variable. The previous command (GUARD or TRACE) using these registers will be discontinued.

## 8.5.13. BRANCH-TRACE

**BRANCH-TRACE** `[<lower address>], [<upper address>]`

| Description | Details |
|-------------|---------|
| `<lower address>` | the lower limit of program area to be traced. |
| `<upper address>` | the upper limit of program area to be traced. |

This command initiates tracing of the program counter upon branch trap conditions. The tracing is written to the output device.

If `<lower address>` and `<upper address>` are specified, tracing is performed only within the specified area. Branches executed outside this area are not listed. If the parameters are omitted, all branches will be listed.

## 8.5.14. CALL-TRACE

**CALL-TRACE** `[<lower address>], [<upper address>]`

| Description | Details |
|-------------|---------|
| `<lower address>` | the lower limit of program area to be traced. |
| `<upper address>` | the upper limit of program area to be traced. |

This command initiates tracing of the program counter upon call trap conditions. The tracing is written to the output device.

If `<lower address>` and `<upper address>` are specified, tracing is performed only within the specified area. Calls executed outside this area are not listed. If the parameters are omitted, all calls will be listed.

All routine calls within the specified area, including run time library routines, are traced.

ND-60.136.04

---

## Page 137

# 8.5.15. EXHIBIT-ADDRESS

**EXHIBIT-ADDRESS <program address>, <data address>, (<data type>)**

- `<program address>` - the instruction that causes the specified variable to be displayed when executed.
- `<data address>` - the address of the variable to be displayed.
- `<data type>` - BYTE, HALFWOR, WORD, FLOAT or DOUBLEFLOAT, indicating the size of the variable to be displayed. Default is WORD.

With this command a breakpoint is set in the specified `<program address>`. When the execution reaches this breakpoint, the `<data address>` and its contents are written to the output device. The data type of the variable may be specified.

Several variables may be traced simultaneously with this command, as long as the Monitor has room for information about the breakpoints.

# 8.5.16. DEBUG-STATUS

**DEBUG-STATUS**

Lists information about previously used debug commands. Enabled traps, breakpoints, and the use of the LL and HL registers are listed.

# 8.5.17. ENABLED-TRAPS

**ENABLED-TRAPS**

Lists the contents of the own trap enable register (OTE) of the current domain and the mother trap enable register. Enabled traps, either in the current domain or in ND-100, are listed on the output device.

ND-60.136.04

---

## Page 138

# Debugging commands

## 8.5.18. STATUS

**STATUS**

Lists the contents of the status register. Some of the status bits have no corresponding bit in the trap enable registers. These bits are always listed with name and value. If other status bits are set, their names and values are listed.

## 8.5.19. RESET commands

In order to clear the effect of previously used debugging commands, the ND-500 Monitor has several reset commands. These are:

### 8.5.19.1. RESET-DEBUG

**RESET-DEBUG**

will clear the effect of all previously used debugging commands.

### 8.5.19.2. RESET-BREAKS

**RESET-BREAKS <break number> ...**

The breakpoints with the specified numbers are removed by using this command. If the last active breakpoint is removed, the breakpoint bit in the ND-500 CTE register is reset.

If no `<break number>` is specified, every active breakpoint is removed permanently by typing RESET-BREAKS. If one or more `<break number>`s are specified, only those breakpoints are removed.

'Breakpoint' includes, in addition to those set by the BREAK command, breakpoints set by the EXHIBIT-ADDRESS command.

---

## Page 139

# Debugging Commands

## 8.5.19.3. RESET-LAST-BREAK

**RESET-LAST-BREAK**

When a breakpoint is encountered during execution, this breakpoint may be removed and the original instruction restored by executing this instruction.

## 8.5.19.4. RESET-TRACE

**RESET-TRACE**

The tracing specified in the TRACE command is discontinued.

## 8.5.19.5. RESET-GUARD

**RESET-GUARD**

The guarding of the area specified in the GUARD command is discontinued.

## 8.5.19.6. RESET-CALL-TRACE

**RESET-CALL-TRACE**

Dumping or comparing with previous dump of routine calls is discontinued.

## 8.5.19.7. RESET-BRANCH-TRACE

**RESET-BRANCH-TRACE**

Dumping or comparing with previous dump of branch conditions is discontinued.

ND-60.136.04

---

## Page 140

# Commands for Performance Measurement

## 8.6. Commands for Performance Measurement

Performance measurement commands serve two main purposes: the HISTOGRAM-commands and MONCALL-LOG commands are used to evaluate one program in order to detect bottlenecks in time critical sequences, while the LOG-commands measure the load on the system in order for the system supervisor to set the system parameters properly.

The histogram and log commands all use the same buffer, and there is only one buffer in the system. Therefore, only one user may use these commands at a time, and he must either release the buffer explicitly or leave the monitor (implicitly releasing the buffer) before any other user may use it.

If a user attempts to execute any of the log or histogram commands while the buffer is in use, an error message is issued.

## 8.6.1. Histogram Commands

### 8.6.1.1. SET-HISTOGRAM

`SET-HISTOGRAM <start address>, <max. address>, (<no. of intervals>)`

| Parameter         | Description                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| `<start address>` | The lower address of the area to be measured.                               |
| `<max. address>`  | The upper address of the area to be measured.                               |
| `<no of intervals>` | The number of equally sized intervals between `<start address>` and `<max address>` in the range 1:64 decimal. Default is 64 decimal. |

This command will reserve and clear the histogram buffer.

A subsequent START-HISTOGRAM will start sampling the accesses to the instruction bank between the `<start address>` and the `<max. address>`. This area is divided into `<no. of intervals>` equally sized intervals. The maximum size of an interval is 32767 bytes.

---

## Page 141

# Commands for Performance Measurement

## 8.6.1.2. START-HISTOGRAM

**START-HISTOGRAM**

The sampling of the program counter will be started. The sampling may be started and stopped any number of times before the histogram is printed. The buffer is not cleared before sampling is started; samples will be added to what is already in the buffer.

Samples are taken every 20 ms.

## 8.6.1.3. STOP-HISTOGRAM

**STOP-HISTOGRAM**

This command stops the histogram sampling.

## 8.6.1.4. PRINT-HISTOGRAM

**PRINT-HISTOGRAM**

This command prints the histogram on the output device. If sampling has been started and stopped several times, the histogram will represent the sum of all samples since SET-HISTOGRAM. The histogram buffer is not cleared by PRINT-HISTOGRAM.

## 8.6.1.5. RELEASE-HISTOGRAM

**RELEASE-HISTOGRAM**

This command releases the histogram buffer. This means that other users may use the HISTOGRAM, the PROCESS-LOG, the MONCALL-LOG and the SWAPPING-LOG commands.

If the buffer is not released through this command, it will automatically be released when the user leaves the Monitor.

---

## Page 142

# Commands for performance measurement

## 8.6.2. Monitor call logging

### 8.6.2.1. START-MONCALL-LOG

START-MONCALL-LOG [<OWN/ALL>]

| Option     | Description                                                                                                                                              |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| <OWN/ALL>  | - if ALL is specified, logging of all monitor calls in the system is started. If OWN is specified, only monitor calls executed by the current process are logged. Default is OWN. |

This command will clear the log buffer, and reserve it for the user issuing the command. All monitor calls executed from the ND-500 will be logged. A count of the number each monitor call has been executed can later be printed.

Roughly speaking, the load on the ND-100 CPU imposed by the ND-500 is proportional to the number of monitor calls executed from ND-500. (Obviously, this general rule applies to CPU load only, not to file system and channel load.) Isolating programs that perform a disproportionate number of monitor calls may help increasing ND-100 throughput.

### 8.6.2.2. PRINT-MONCALL-LOG

PRINT-MONCALL-LOG

A count of monitor calls executed since START-MONCALL-LOG is printed on the output device. Each monitor call number up to 777B is listed with an individual count. Parts of this range is not valid as monitor call numbers, and will always appear with a count of zero.

This command does not release the buffer, nor does it clear it. Further monitor calls will add to the count already in the buffer.

---

## Page 143

# Commands for performance measurement

## 8.6.2.3. STOP-MONCALL-LOG

**STOP-MONCALL-LOG**

The log buffer is released, and no further logging of monitor calls will be done.

Other users may use the HISTOGRAM, the PROCESS-LOG, the MONCALL-LOG and the SWAPPING-LOG commands. If the buffer is not released through this command, it will automatically be released when the user leaves the Monitor.

## 8.6.3. Process logging

### 8.6.3.1. START-PROCESS-LOG-ALL

**START-PROCESS-LOG-ALL**

This command will clear the process-log buffer and reserve it for the user issuing the command.

Logging the CPU usage of the active processes is started. Samples are taken every 20 ms, and the measurements are represented as percents of the total CPU capacity. The result of the logging may be presented by the PRINT-PROCESS-LOG command.

This command is allowed for user SYSTEM only.

### 8.6.3.2. START-PROCESS-LOG-ONE

**START-PROCESS-LOG-ONE <process number>**

`<process number>` - the process identifier found by the WHO-IS-ON command.

Logging of one specified process is started. The percentage of the time spent by the process in the states 1) Idle, 2) Waiting for swapper, 3) Using swapper, 4) In monitor call, 5) Active, and 6) Waiting for CPU, are logged. The 'active' entry (5) is equal to the entry that would appear in the START-PROCESS-LOG-ALL command for the specified process.

This command is allowed for user SYSTEM only.

---

**ND–60.136.04**

---

## Page 144

# Commands for Performance Measurement

## 8.6.3.3. PRINT-PROCESS-LOG

**PRINT-PROCESS-LOG** `<first process>`

- `<first process>` - the lowest numbered process to be printed. Default is 0.

The accumulated measurements from the last START-PROCESS-LOG-ALL or START-PROCESS-LOG-ONE are printed on the output device. The buffer is not cleared, and the logging is continued, adding subsequent measurements to the printed values. In order to clear the buffer, the START-PROCESS-LOG-ALL or START-PROCESS-LOG-ONE should be used to start the next logging period.

This command is allowed for user SYSTEM only.

## 8.6.3.4. PROCESS-LOG-ALL

**PROCESS-LOG-ALL** `<interval>` `<first process>`

- `<interval>` - the time in seconds between each report.
- `<first process>` - the lowest numbered process to be logged. Default is 0.

The logging of CPU usage in percent of total capacity is started and written to the output device every `<interval>` second. The buffer is cleared between each report; displayed results are not cumulative.

A sample is taken every 20 millisecond, and for the report to have a reasonable accuracy, the interval should be at least 10 seconds. The logging is stopped by pressing the escape key.

This command is allowed for user SYSTEM only.

## 8.6.3.5. PROCESS-LOG-ONE

**PROCESS-LOG-ONE** `<process no>` `<interval>`

- `<process no>` - the identifying number of the process, found by the WHO-IS-ON or PROCESS-STATUS command.
- `<interval>` - the time in seconds between each report.

The logging of the specified process is started, and the log printed every `<interval>` seconds. The buffer is cleared between each report; displayed results are not cumulative. The report contains the same measurements as measured by the START-PROCESS-LOG-ONE command.

ND-60.136.04

---

## Page 145

# Commands for performance measurement

A sample is taken every 20 milliseconds, and for the result to have a reasonable accuracy, the interval should be at least 10 seconds.

The logging is stopped by pressing the escape key.

This command is allowed for user SYSTEM only.

## 8.6.3.6. RELEASE-LOG-BUFFER

**RELEASE-LOG-BUFFER**

The buffer used for the SWAPPING-LOG and PROCESS-LOG-commands is released, allowing other users to use these commands, the HISTOGRAM- and MONCALL-LOG-commands.

If the buffer is not released through this command, it will be released when the user leaves the Monitor.

## 8.6.4. SWAPPING-LOG

**SWAPPING-LOG <interval>**

<interval> - the period in seconds between each report.

This command will clear the log buffer and reserve it for the user issuing the command. The buffer is the same as the one used in the PROCESS-LOG, MONCALL-LOG and HISTOGRAM commands, which means that only one user at a time can use any of these commands.

Logging of swapping is started, and will be written to the output device every <interval> seconds. The logging is stopped by pressing the escape key.

Each report will include values for the last interval, the average per interval since logging was started and the total. For each of these, a count of page faults, transfers, the total free space etc. will be listed.

This command is allowed for user SYSTEM only.

ND-60.136.04

---

## Page 146

# Commands for Performance Measurement

## 8.6.5. LIST-EXECUTION-QUEUE

LIST-EXECUTION-QUEUE `<interval>`

| `<interval>` | - time in seconds between each report |

The currently executing program, its priority, the queue of jobs for the ND-500 and their priorities are listed on the output device every `<interval>` seconds.

---

## Page 147

# 8.7. Process communication and synchronization

Processes in the ND-500 may temporarily halt and be restarted by another process through the monitor calls STOPPR, STARTPR and SWITCHP, or through commands.

## 8.7.1. Process names and numbers

A process may be identified by a symbolic name or by a numeric process number. The process number comprises the process index in the range 0 to 31 in the upper half and a 16 bit cycle number in the lower half of a word. Thus process numbers are recycled with very long intervals.

The monitor calls SPRNAME (MON 425B) and GPRNAME (MON 427B) can be used to set and get the process name, respectively. The monitor call GPRNUM (MON 426B) will translate a process name into a process number.

The process name syntax resembles the file name syntax: a user name of up to 16 characters enclosed in parentheses, followed by a user selected name of up to 16 alphanumeric characters or hyphens. The user name is that of the currently logged on user and may not be modified. The user selected name has a default value determined by the terminal in use. If this part of the process name is changed, the previous value is discarded.

## 8.7.2. SET-PROCESS-NAME

SET-PROCESS-NAME <name>

| <name> | - up to 16 alphanumeric characters or hyphen, optionally prefixed by the user name enclosed in parentheses. |

Names the process owned by the terminal from which the command is executed. The specified name will replace the previous name. The name is valid until the user leaves the Monitor or replaces the name with another one.

This command is useful if two or more processes synchronize by starting and stopping each other.

---

## Page 148

# Process Communication

## 8.7.3. Process Creation and Termination

A new process is allocated when a user starts the monitor, and terminates when the user leaves the monitor. If several domains are executed during one monitor session, they are all run under the same process.

A process may also be allocated by an ND-100 RT program using the RESRV function in the N500M monitor call. The process terminates when the RT program executes the RELIS function in N500M. Using the N500M call requires detailed knowledge of how the monitor operates.

## 8.7.4. RESTART-PROCESS

RESTART-PROCESS \<process name\>

\<process name\> - the symbolic name of an existing process.

A process that has halted itself by the STOPPR call (MON 501B) is restarted, or if it is already active, the repeat bit in the process description is set, causing the process to be immediately reactivated if it later executes a STOPPR call.

## 8.7.5. Process Communication Flags

A simple mechanism for communication between an ND-100 process and an ND-500 process is implemented.

To each process two 32 bit words are assigned, the input and output flags. The owner process may read its own input flag and write into its output flag by the monitor calls Read input flag (MON 402B) and Write output flag (MON 403B). When the Monitor is entered, both flags are initially zero. The flag word is not used by the monitor, and may contain any information as determined by the process(es).

A ND-100 program may use the functions RFLAG (100B) and SFLAG (101B) in the Sintran III monitor call N500M (MON 60B) to communicate with an ND-500 process.

From a terminal the same functions are performed by the commands GET-FLAG and SET-FLAG described below.

Note that there is no queueing of flags; if the input flag of a process is modified twice before the owner reads the flag, the first value is lost.

---

## Page 149

# Process communication

## 8.7.6. GET-FLAG

**GET-FLAG** `<process no.>`

`<process no.>`

The output flag (32 bit word) of the specified process is written on the output device in the current main format. If the specified process is connected to a terminal, this command must be given from another terminal.

## 8.7.7. SET-FLAG

**SET-FLAG** `<process no.>` `<value>`

`<value>` - an unsigned value in the range 0:37777777777B.

The specified `<value>` (32 bit word) is written into the input flag of the specified process. If the specified process is connected to a terminal, this command must be given from another terminal.

---

## Page 150

# Memory allocation

## 8.8. Memory allocation

System performance depends on how the active process uses its memory and how the entire available memory is administered. When performance is critical it is possible to allocate memory explicitly to the process by several commands described below.

The total execution time of a process may vary within wide limits, depending on the amount of physical memory that the process is allotted and the allocation strategy employed.

All commands for memory allocation are reserved for user SYSTEM if executed in the Monitor.

Explicit allocation is very rarely needed. Whenever hardware considerations require it (direct transfer files, communication with RTCOMMON or with an ND-100 segment), this will automatically be taken care of by the Monitor at execution time.

In general, physical memory is significantly smaller than the sum of the logical sizes of all processes submitted for execution. Physical memory may even be smaller than the size of each one of the processes.

To overcome space problems, a memory management system is used, mapping the logical address spaces onto physical memory through a translation mechanism. Each logical address space is divided into pages, or blocks of 2k bytes (2048 bytes). Page boundaries will always be at physical addresses which are multiples of 2048 (40008).

## 8.8.1. Demand paging

It is not necessary for all the pages of a segment to be in memory when the process starts executing. If access to a page not in memory is attempted, this is detected by hardware as a page fault, and the running process is suspended until the page has been copied from disk.

Due to the translation mechanism, the page brought into memory may be placed wherever there is room for it. Thus, several users may have fractions of their programs scattered in memory.

Whenever the memory is full, and there is no room for a page that is needed, another page must be removed to free the physical page. If the page to be removed has not been modified (as is normally the case for program segments) the page does not need to be written back. If it has been modified, it must be written back to the disk before another one takes its place in memory. This process is called swapping, and is in the ND-500 performed by a system process called the swapper, running in the ND-500 which, of course, runs independently of any terminal.

The algorithm used to select a page for removal attempts to find the page that has the least probability of being used again, and will roughly speaking pick the page that has remained unused in memory for the longest time.

ND-60.136.04

---

## Page 151

# Memory Allocation

This allocation strategy, called demand paging, is the default strategy used, to achieve optimal utilization of physical memory.

## 8.8.2. "Fixing" in Memory

Certain I/O operations require that the data area to be transferred to or from is located in a contiguous area in memory. The Monitor will recognize such requirements, and will allocate an area before the first I/O transfer is started. The memory area will remain reserved ("fixed") until the program completes execution. The user need not be concerned with this at all, as the operation is completely automatic and transparent.

If several processes use exceedingly large areas for I/O operations requiring the data area to be fixed in memory, this will affect system performance to some degree, as it limits the number of pages available for swapping.

## 8.8.3. Limiting the Number of Pages in Memory

In order to ease the load on the swapper, the user may specify the minimum and maximum number of pages to be kept in memory during execution of the segment. The segment will still be treated as a demand segment, but memory requests from other processes will never cause the number of pages to drop below the specified lower limit. Thus, the number of page faults during execution is reduced. (But the total number of page faults on the system may increase however.)

Initially, at the start of program execution, no pages are in memory. The minimum number of pages does not apply until that number of pages have been brought into memory as a result of page faults. However, none of these pages will be swapped out unless the upper limit is reached.

The maximum number of pages is used to indicate the approximate size of the working set. As soon as the number of pages in memory exceeds this limit, the least recently used pages are marked for swapping.

This can be used with advantage for processes passing through a data set in a sequential manner, or processes having a large amount of initializing code and a small working set as soon as the initialization is done. Although the gain in speed is lower than it would be with fixed allocation, the penalty in reduced performance of the ND-500 system as a whole is far less.

The minimum and maximum number of pages in memory are set by the SET-SEGMENT-LIMITS command.

---

## Page 152

# Memory Allocation

## 8.8.4. "Fixing" Programs in Memory

The suspension of a process while a page transfer takes place makes response time of a process more irregular than if the entire process could be in memory at the same time. Another aspect of swapping is that the busier the CPU gets, the more crowded memory will get (in general), and the more time is spent at swapping.

Ordinary interactive processes, or processes operating on permanently stored data can usually tolerate the delay imposed by demand paging. However, programs interacting with I/O-devices will often depend on short and well defined response times or rely upon data areas being in memory at any time for performing I/O operations.

Processes with such requirements may be exempted from swapping, and be allowed to keep all or some of their pages in memory continuously. If the segment remains in memory even before and after execution, controlled by explicit commands, it is said to be *fixed* in memory. Several degrees of fixing are possible.

Even though part of a segment is declared to be a fixed segment, this does not have to apply to the entire segment. The commands available have parameters for specifying the lower and upper bound of the segment area affected. The remainder of the segment will be treated as a demand segment.

Under normal circumstances, the Monitor will detect the conditions requiring special memory allocation, and perform the allocation at execution time. Thus, the user does not have to be concerned about the commands to perform explicit allocation. For time critical tasks, however, they may be required.

## 8.8.5. Fixing Segments Scattered in Memory

This kind of allocation will scatter pages throughout memory, exactly like demand paging, but these pages will not be candidates for swapping, and will not be removed when the program completes its execution.

Start-up times will be significantly shorter than for demand segments, as the segment will already be in memory and no disk access is required. If the process is restarted after completion before the segment is unfixed, no extra disk accesses are introduced.

The effective memory size available for demand paging processes will be reduced, causing an increased swapping for these segments, but the Monitor is free to place the fixed area wherever seems most suitable at the time the process is submitted for execution.

Fixing a segment scattered in memory is done by the FIX-SEGMENT-SCATTERED command.

---

## Page 153

# Memory allocation

## 8.8.6. Fixing segments in contiguous memory

Some I/O operations, namely all DMA operations, require that the area to be transferred to or from is a contiguous memory area, as the DMA device does not use the translation mechanisms to transform the logical address to a physical one.

In order to permit DMA transfers crossing page boundaries, the affected area may be allocated in a contiguous area in physical memory. Usually this will apply to data areas only, but may be used for any segment.

Program execution will not be any faster than with a fixed scattered segment; the translation mechanism to convert from logical addresses is not bypassed (and consists mostly of tailor made hardware, working at the speed of the CPU, causing no delay in addressing in most cases). The main advantage over fixed scattered is the ability to perform direct transfer file access, see chapter 8.3.6.

Allocating a contiguous area require that the swapper clears a memory area of the requested size without regard to whether the removed pages are active or not. Consequently, the allocation of a contiguous segment is rather costly. Obviously, a contiguous area of the requested size must also be available. If a high number of users request (any kind of) fixed allocation, this is not always the case, and the request is refused.

A system parameter determines the maximum number of pages that may be fixed for the entire system, including areas fixed implicitly by the Monitor. If any of these limits are exceeded, an error message will be returned.

The maximum number of contiguously fixed pages may also be limited by a system parameter.

Observe that when performing DMA through the file system, e.g. to direct transfer files, the fixing is performed automatically by the Monitor, and does not require explicit specification by the user.

Fixing a segment in a contiguous area is done by the FIX-SEGMENT-CONTIGUOUS command, or a FIX-SEGMENT monitor call.

ND–60.136.04

---

## Page 154

# Memory allocation

## 8.8.7. Fixing segments in an absolute location

This allocation strategy is even more demanding on system resources, as it includes an explicit specification of the physical memory area to be used. No further gains in speed can be achieved with absolute fixing in memory, but such allocation may be required when communicating with special I/O devices.

Communication with ND-100 may go through shared memory. In particular, the RT-COMMON area will always be contiguous in a fixed location, and ND-500 processes accessing this area will require that the logical ND-500 addresses map onto the RT-COMMON area. All communication with fixed segments in ND-100 will, however, be taken care of by the Monitor, and the user will not have to be concerned about it.

Fixing a segment in an absolute location is done by the FIX-SEGMENT-ABSOLUTE command.

## 8.8.8. Fixing segments shared by several processes

Obviously, if two processes want to communicate through a data segment, they must access the same physical location when they address the same logical location. If the first process to start execution requests demand paging scattering pages throughout memory, it is impossible for the second process to request contiguous allocation and map to the same addresses. (No kind of fixing is necessary in order to share a segment; it may be a demand segment if fixing is not required for other reasons.)

This also applies to fixed contiguous vs. fixed absolute, or any other combination. The process first bringing the segment into memory must allocate it with the highest grade allocation required by any of the processes accessing the segment. The highest grade allocation is fixed absolute, then follows fixed contiguous, fixed scattered and demand paging as the lowest grade.

If only a part of the segment is fixed, the first process to fix the segment must fix the maximum area requested by any process accessing the segment.

ND-60.136.04

---

## Page 155

# 8.8.9. Unfixing a segment

After the process using a fixed segment completes execution, the segment is not automatically released. The reason for this is that processes using fixed segments are often either periodical or they are restarted as a result of an external event, and the time spent moving the segment into memory would often be too long.

Therefore, a segment must be released explicitly through the UNFIXSEGMENT command or the UNFIX monitor call. If the segment is not unfixed, this will be performed by the Monitor when it is left by the last user to have fixed the segment.

The command will not necessarily have an immediate effect. If there are still one or more processes using the segment, it will not be removed from memory until all of them have completed.

---

## Page 156

# Memory allocation

## 8.8.10. The swapping strategy

A certain knowledge of the swapping strategy is required by the system supervisor in order to set the parameters determining the operation of the swapper. Programmers may also want to know how system software affects the performance of their programs and utilization of the available resources.

When the swapper needs a free memory page it uses the following strategy when selecting the page to take.

1) If there is an absolute free page, it takes it.

2) If no absolute free page exists, the swapper searches the segments that are in the "swap queue" for a page that has not been used (the PGU bit is zero) after any such segment has become a swap candidate (linked into the swap queue). If it finds an unused page, it takes it. If a segment in the swap queue has no page that has not been used, then the segment is removed from the swap queue. A search through the pages of the swap segment is performed twice before the segment is removed. In the first search, unused pages are not taken which have been modified, since this implies an extra disk access. During the second search the swapper does not test for modified (WIP bit), but takes the first page not used. In other words, the strategy is to postpone the "grabbing" of modified pages to avoid the overhead of extra disk access.

3) If the swapper's search of the swap queue is unsuccessful, it then selects one process, and for all segments of this process it clears the PGU bits before linking the segments into the swap queue. The swapper now repeats the process described in 2) above.

The method by which segments become swap segments is an important aspect of the swapping strategy. The swapper counts the number of page faults per segment. When this number becomes equal to a fixed number (a system parameter called CLEAN-SEGMENT-N-PF (the N-PF being the number of page faults)) the PGU bits of the pages belonging to the segment are set to zero. When the number of page faults becomes equal to another system parameter (SWAPOUT-SEGMENT-N-PF) then the page fault count is set to zero and the segment is linked into the swap queue. Good results are obtained if:

| SWAPOUT-SEGMENT-N-PF = CLEAN-SEGMENT-N-PF + X |

and X is in the range 2:7

The swapper has facilities for controlling the swap rate. For each process it counts the time between 20 page faults. The inverse of this is taken as a measure of the swap rate of the process. If the swap rate is greater than the value of an expression whose parameters include the global swap rate and a system parameter (the LOW-PRIORITY)

ND-60.136.04.

---

## Page 157

# Memory Allocation

factor), then the priority is set to 16. This applies only to time-sliced processes. The "swap-rate expression" is so constructed that the higher the LOW-PRIORITY FACTOR is, the higher the probability will be of a process getting a priority of 16.

The swapper will not touch pages fixed in memory, until the last user having fixed the segment unfixes it or logs out. At that time the pages are returned to the freepool.

---

ND-60.136.04

---

## Page 158

# Memory Allocation

## 8.8.11. SET-SEGMENT-LIMITS

**SET-SEGMENT-LIMITS** `<segment no.>, <type>, <min no.of pages>, <max no.of pages>, [process no]`

| Parameter         | Description                                                                                                                                                      |
|-------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<segment no.>`   | the number of an existing segment                                                                                                                                |
| `<type>`          | P or D, indicating program or data segment, respectively.                                                                                                        |
| `<min no.of pages>` | the minimum number of pages of the specified segment to remain in memory throughout process execution.                                                          |
| `<max no.of pages>` | the maximum number of pages of the specified segment to remain in memory throughout process execution.                                                          |
| `<process no>`    | the number of the process to be affected. Default is own process.                                                                                                |

Specifies the minimum number of pages of a segment that must be in memory before execution of instructions on the segment starts, and the maximum number of pages allowed in memory at one time.

When execution of the segment is started, no page of the segment will be a candidate for swapping until the minimum number of pages specified is brought into memory. At no time during the execution will the number of pages in memory be less than the specified minimum.

Normally, due to page faults, the number of pages in memory will increase during the execution of the domain. If this number exceeds the specified maximum, one or more of the pages not used for some time will be marked for swapping.

Pages may be swapped even if the maximum limit has not been reached, but at no time will the number of pages in memory be below the specified minimum.

ND-60.136.04

---

## Page 159

# 8.8.12. FIX-SEGMENT-SCATTERED

FIX-SEGMENT-SCATTERED ((<segment name>), (<type>), (<lower addr>), (<upper addr>))

| Placeholder   | Description                                                                 |
|---------------|-----------------------------------------------------------------------------|
| <segment name>| the name of an existing segment.                                            |
| <type>        | P or D, signifying program or data segment.                                |
| <lower addr>  | the lower boundary of the area to be fixed. Default is the lowest address on the segment. |
| <upper addr>  | the upper boundary of the area to be fixed. Default is the uppermost address of the segment. |

In NLL, the default segment is the current segment. Segment may be specified either by name or by logical segment number.

<lower addr> will be rounded down, <upper addr> will be rounded up to the nearest page boundary. In NLL both may be defined symbols or addresses. The Monitor accepts addresses only.

The segment or part of segment specified is declared to be retained in memory after it has been loaded for execution, until it is explicitly released through the Monitor command UNFIX-SEGMENT. The pages belonging to the segment may be scattered throughout physical memory.

# 8.8.13. FIX-SEGMENT-CONTIGUOUS

FIX-SEGMENT-CONTIGUOUS ((<segment no.>), (<type>), (<lower addr>), (<upper addr>))

| Placeholder   | Description                                                                 |
|---------------|-----------------------------------------------------------------------------|
| <segment no.> | the number of an existing segment.                                          |
| <type>        | P or D, signifying program or data segment.                                |
| <lower addr>  | the lower boundary of the area to be fixed. Default is the lowest address on the segment. |
| <upper addr>  | the upper boundary of the area to be fixed. Default is the uppermost address of the segment. |

<lower addr> will be rounded down, <upper addr> will be rounded up to the nearest page boundary.

The segment or part of segment specified is declared to be allocated in a contiguous area of memory, and to be retained in memory until it is explicitly released through the Monitor command UNFIX-SEGMENT.

---

## Page 160

# Memory Allocation

## 8.8.14 FIX-SEGMENT-ABSOLUTE

**FIX-SEGMENT-ABSOLUTE** (<segment no.>), (<type>), (<phys. addr>), (<lower addr>), (<upper addr>)

| Parameter      | Description                                                                 |
|----------------|-----------------------------------------------------------------------------|
| `<segment no.>`| - the number of an existing segment.                                        |
| `<type>`       | - P or D, signifying program or data segment.                               |
| `<phys. addr>` | - the address in physical memory where the segment should start.            |
| `<lower addr>` | - the lower boundary of the area to be fixed. Default is the lowest address on the segment.     |
| `<upper addr>` | - the upper boundary of the area to be fixed. Default is the uppermost address of the segment.  |

<lower addr> will be rounded down, <upper addr> will be rounded up to the nearest page boundary.

The specified segment or part of segment is declared to be allocated in a contiguous area in memory, starting at the physical address specified. It will remain in memory until explicitly released through the Monitor command UNFIX-SEGMENT.

## 8.8.15 UNFIX-SEGMENT

**UNFIX-SEGMENT** <segment>, <type>

| Parameter  | Description                                                                     |
|------------|---------------------------------------------------------------------------------|
| `<segment>`| - the name of a segment which has previously entirely or in part been fixed in memory through one of the above commands. |
| `<type>`   | - P or D, indicating program or data segment, respectively.                     |

The area occupied by a segment, or part of segment, previously specified as fixed in memory, is unfixed. The freed space may be used by other segments. The command has no effect before every process that has fixed the segment has released or unfixed it.

## 8.8.16 RESIDENT-PLACE

**RESIDENT-PLACE <domain name>**

| Parameter       | Description                                                                                                  |
|-----------------|--------------------------------------------------------------------------------------------------------------|
| `<domain name>` | - the name of a domain in the description file of the current user or the user specified in parentheses as a prefix to <domain name>.  The domain will be placed permanent in memory. The command is used to avoid swapping for processes that require fast execution. Only allowed for user SYSTEM. Only one such process can be run at a time. |

ND-60.136.04A

---

## Page 161

# 8.9. Miscellaneous commands

## 8.9.1. AUTOMATIC-ERROR-MESSAGE

AUTOMATIC-ERROR-MESSAGE

Error messages caused by monitor calls will automatically be written to the communication device. MON 64B (ERMSG) will then be unnecessary after every monitor call in the ND-500.

## 8.9.2. RESET-AUTOMATIC-ERROR-MESSAGE

RESET-AUTOMATIC-ERROR-MESSAGE

Reverses the effect of the AUTOMATIC-ERROR-MESSAGE command.

## 8.9.3. The "Escape" key

By pressing the Escape key during the execution of an ND-500 program the execution is stopped and the control is given to the ND-500 command processor.

No files are closed and no resources released. Execution may be resumed by the CONTINUE command, possibly after executing other monitor commands. If execution is not resumed, resources are released when the user leaves the monitor.

## 8.9.4. TIME-USED

TIME-USED

This command prints the ND-500 and ND-100 CPU time and clock time elapsed from the moment that the ND-500 Monitor was entered.

---

## Page 162

# Miscellaneous commands

## 8.9.5. WHO-IS-ON

**WHO-IS-ON**

A list of users currently logged on the ND-500 is printed on the output device.

## 8.9.6. LIST-ACTIVE-PROCESSES

**LIST-ACTIVE-PROCESSES**

The active processes and their process names are written to the output device. This command will also list processes not owned by a terminal background program.

## 8.9.7. VERSION

**VERSION**

The version numbers of the currently active subsystem (background part of the monitor), system part (Sintran part of the monitor), swapper, and microprogram is written to the output device.

## 8.9.8. SET-PRIORITY

**SET-PRIORITY** `<ND-100 mon call priority>, <max % of ND-100 time>,`  
`<ND-500 priority>, [<process no>]`

| Parameter                  | Description                                                                                                                                   |
|----------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
| `<ND-100 mon call priority>` | the priority of the ND-100 process executing monitor calls on behalf of the ND-500 process, in the range 0:70B. Default is 70B.                |
| `<max % of ND-100 time>`     | the maximum percentage of ND-100 CPU time the ND-100 process may use over a two second period. Default is 50%.                                  |
| `<ND-500 priority>`          | the priority of the ND-500 process, in the range 0:377B. Default is dynamic modification by the time slicing mechanism.                         |
| `<process no>`               | the number of the process to be affected. Default is own process.                                                                              |

ND-60.136.04

---

## Page 163

# Miscellaneous Commands

Whenever an ND-500 process executes Sintran III monitor calls, a twin process running in the ND-100 is started. The required parameters for the call are transferred to this process, and the call is executed in the ND-100 before the results (if any) are returned to the ND-500 process.

When a monitor call is executed, the priority of the ND-100 twin process is determined by the parameter `<ND-100 mon call priority>`.

The `<max % of ND-100 CPU time>` parameter specifies the maximum percentage of ND-100 CPU time the ND-500 process may use over a two second period through its twin process executing monitor calls. If the percentage is exceeded, the `<ND-100 mon call priority>` is reduced to 20B.

Be aware that the measured CPU time spent in monitor call handling includes activity on interrupt level 4 and 1. Other hardware levels (for ND-500 monitor calls: 14, 12, 3 and possibly 11 and 10) are not measured. The measured CPU load will be a smaller or larger fraction of the actual CPU load. The ND-100 may be saturated even though the sum of all "max percentages" is significantly below 100%.

If `<ND-500 priority>` is zero, the process will be time sliced with other processes with priority varying between 20B and 61B. If `<ND-500 priority>` is non-zero, the process will run on a fixed priority as specified. The default handling of the ND-500 process is timeslicing with no fixed priority. A priority specified in the source program is ignored.

This command is allowed for user SYSTEM only.

---

ND-60.136.04

---

## Page 164

# Commands for the System Supervisor

## 8.10. Commands for the System Supervisor

These commands are allowed for user SYSTEM only, and most of them require that no other users are logged in on the ND-500. New users may be prevented from logging in by the command SET-ND-500-UNAVAILABLE.

These commands will interpret and display addresses as octal values regardless of the format set by the MAIN-FORMAT command. However, decimal or hexadecimal addresses may still be entered by trailing the parameter with D or H respectively.

The user RT has no special privileges in the ND-500, and is treated as a regular public user. This applies both to commands and the ND-500 instruction set available. However, monitor calls executed in the ND-100 are treated in the same manner as for ND-100 programs, giving the user RT higher privileges than public users.

## 8.10.1. SET-ND-500-UNAVAILABLE

SET-ND-500-UNAVAILABLE

No user may log on to the ND-500 until the SET-ND-500-UNAVAILABLE command is given. SET-ND-500-UNAVAILABLE must be used before any modification of system parameters is done, to ensure that no user interrupts critical operations. If any command that requires exclusive access to ND-500 is executed, this command is implicitly attempted, and an error message issued only if others are using ND-500. If ND-500 has been implicitly set unavailable, it will be impossible for others to use it until SET-ND-500-AVAILABLE is executed or the user reserving the ND-500 leaves the monitor.

This command will not force a log-out of those already logged in, but will prevent new users from logging on. Logged in users must log out explicitly.

## 8.10.2. SET-ND-500-AVAILABLE

SET-ND-500-AVAILABLE

Other users may now log in. This command has the reverse effect of SET-ND-500-UNAVAILABLE, and should be issued as soon as exclusive use of the ND-500 is no longer required. An implicit SET-ND-500-AVAILABLE is executed when the user setting it unavailable leaves the monitor.

ND-60.136.04

---

## Page 165

# Commands for the System Supervisor

## 8.10.3. STOP-ND-500

STOP-ND-500

The ND-500 CPU is stopped. When a user attempts to start an ND-500 process after this command has been executed, the microcode will automatically be reloaded, the swapper process placed in memory and started ("warm start" of ND-500).

If the ND-500 should be stopped and then started with no need for restarting running jobs, the MICRO-STOP command should be used.

## 8.10.4. Memory Configuration

In an ND-500 computer system, the processors may be connected to either local memory (memory that can be addressed from only one processor) or to a multiport memory system (shared memory). By processor, in this context, is meant the disk, the ND-100 CPU, the ND-500 CPU program channel or the ND-500 data channel.

There are two restrictions which must be noticed when configuring an ND-500 computer system. First, the physical addressing range for program and data memory may not overlap if the memory addressed is not the same physical memory.

Secondly, if the disks have access to a memory cell, it is assumed that the ND-100 CPU also has access to that memory cell, and vice versa.

The ND-500 system has itself limited capability to investigate its own memory configuration. Therefore the memory configuration must be defined by the command DEFINE-MEMORY-CONFIGURATION.

Note: Local ND-500 memory is not legal in the ND-500 multiuser Monitor.

## 8.10.4.1. DEFINE-MEMORY-CONFIGURATION

DEFINE-MEMORY-CONFIGURATION <ND-100 page# for ND-500 phys.addr# 0>

The operating system is given information about the physical memory configuration.

The parameter is ND-100 page number for which the ND-500 physical address is zero, i.e. the difference between the ND-500 and ND-100 physical addresses for the same physical cell in common memory.

The information about the size of the system, and the access to the different memory parts of the system is given as subcommands to this command. The information given by this command is saved and will survive a normal restart ("warm start") of the system.

ND-60.136.04

---

## Page 166

# Commands for the System Supervisor

The subcommands will request the information

- size in number of pages for the memory part

- Does ND-100 have access to the part?

- Does ND-500 have access to the part as program?

- Does ND-500 have access to the part as data?

- Is this the last memory part?

Default is access for both CPUs, both P and D for ND-500.

When Sintran III is restarted by the MACM )HENT / 22! commands ("cold start"), the memory configuration information is lost. For convenience a permanent macro with the memory configuration definition should be made.

## 8.10.4.2. MEMORY-CONFIGURATION

Information about the current memory configuration is printed on the output device.

## 8.10.5. Memory administration

When the ND-500 is started the first time, every page of ND-100/ND-500 shared memory belongs to ND-100. Memory is administered through the commands GIVE-ND-500-PAGES and TAKE-ND-500-PAGES.

### 8.10.5.1. GIVE-ND-500-PAGES

GIVE-ND-500-PAGES <no. of pages>

\<no. of pages\> - the number of pages to be used by ND-500.

The specified number of pages are taken from the ND-100 and released to the ND-500. If ND-500 already has pages, the specified number of pages is added to those ND-500 had previously.

All system tables are located in memory belonging to the ND-100. Thus, the number of pages specified will all be available for user processes.

ND-60.136.04

---

## Page 167

# Commands for the System Supervisor

## 8.10.5.2. TAKE-ND-500-PAGES

**TAKE-ND-500-PAGES** `<no. of pages>`

`<no. of pages>` - the number of pages to be returned to ND-100.

The specified number of pages are taken from the ND-500 and given to the ND-100. The number specified should be less than or equal to the number given to ND-500 previously with the GIVE-ND-500-PAGES command, otherwise the number of pages actually released is returned.

---

## Page 168

# Commands for the System Supervisor

## 8.10.6. Microprogram maintainance

Using these commands require a detailled knowledge of the ND-500 microprogram format and hardware. This chapter is not assumed to give sufficient information; the reader must as a minimum be familiar with Test Micro Program Descriptions for ND-500 (ND-30.103).

### 8.10.6.1. MICRO-STOP

MICRO-STOP

The execution of the ND-500 microprogram is stopped, and may be resumed through the command MICRO-START. The ND-500 will stop completely, but the contents of all registers are retained. It is not necessary to restart programs running in the ND-500.

### 8.10.6.2. MICRO-START

MICRO-START `<address>`

| `<address>` | - the octal control store address where execution of the microprogram should start. |

The execution of the ND-500 microprogram is started at the specified address.

### 8.10.6.3. LOAD-CONTROL-STORE

LOAD-CONTROL-STORE (`<file name>`), (`<start address>`), (`<no. of words>`)

| `<file name>` | - the name of the file from which the microprogram is read. Default is CONTROL-STORE:DATA. |
| `<start address>` | - the octal address where the first microprogram word should be loaded in control store. Default is 0. |
| `<no. of words>` | - the number of words to be compared with the file contents after loading. Default is 20000B (entire control store). |

The ND-500 microprogram is loaded to the control store from the specified file. The first microprogram word on the file is loaded into the control store at the specified start address. Every microprogram word (144 bits, 18 bytes) loaded into successive words.

ND-60.136.04

---

## Page 169

# Commands for the System Supervisor

When the loading is finished, the first words of the file are compared with the corresponding contents of the control store. The number of words to be compared is specified through the `<no. of words>` parameter. If inequality is found, the error message `CONTROL STORE UNSUCCESSFULLY LOADED` is written to the output device.

## 8.10.6.4. COMPARE-CONTROL-STORE

COMPARE-CONTROL-STORE ((<file name>), (<start address>),  
\((<no. of words>), (<max.no. of faults>))

| Parameter        | Description                                                                                                                                                         |
|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<file name>`    | the name where the microprogram is stored. Default is CONTROL-STORE:DATA.                                                                                            |
| `<start address>`| the octal address where the comparison should start. Default is 0.                                                                                                   |
| `<no. of words>` | the number of words to be compared. Default is 20000B (entire control store).                                                                                        |
| `<max.no.of faults>`| the maximum number of inequalities accepted between the file contents and the loaded microprogram before the comparison is aborted. Default is 7 (the number of messages that will fit on a VDU screen). |

The current ND-500 microprogram is compared to the microprogram residing on the the specified file, `<file name>`. The comparison starts at the specified microprogram address, `<start address>`. This word is compared to the first word on the file, etc. Four words will be modified after the microcode is loaded and will always be different.

Upon inequality the address and the two differing control store words are written to the output device. The comparison lasts until `<no. of words>` are compared or `<max. no. of faults>` are found.

## 8.10.6.5. LOOK-AT-CONTROL-STORE

LOOK-AT-CONTROL-STORE (<address>)

| Parameter     | Description                                                               |
|---------------|---------------------------------------------------------------------------|
| `<address>`   | an octal address in control store, range 0:20000. Default is 0.            |

Examine and modify the ND-500 microprogram.

The display is started at the specified `<address>`. One control store word and the corresponding address are displayed on one line. On carriage return, the next control store word is displayed. A control store word consists of 144 bits which are grouped into nine 16 bit words.

ND-60.136.04

---

## Page 170

# Commands for the System Supervisor

The next control store word to be displayed may be specified by typing its address followed by a slash and carriage return.

## 8.10.6.5.1. Subcommands EDIT and ORIN

By default, the control store is disassembled and displayed symbolically. Symbolic modifying of the control store is performed by either the subcommand EDIT or ORIN. By EDIT the current control store word is cleared and the disassembled string is then put into the terminal input buffer. It is then possible to modify the disassembled string by the Sintran III line editing features. At carriage return the modified string is assembled and written into the control store. By ORIN the next terminal input is assembled and a logical OR of the entered instruction and the old contents is stored into the current control store word.

## 8.10.6.5.2. Subcommands OCTAL and SYMBOLIC

By the subcommand OCTAL it is possible to have the control store displayed in octal format. The display is returned to the symbolic mode by typing the command SYMBOLIC.

## 8.10.6.5.3. Subcommands GROUP and WORD

By typing GROUP only one 16 bit word is displayed. On carriage return the next 16 bit word is displayed. Within GROUP modus it is possible to modify the displayed 16 bit word by typing the new octal value followed by a carriage return. By typing WORD the display of nine 16 bit words continues.

## 8.10.7. LOOK-AT commands

### 8.10.7.1. LOOK-AT-RESIDENT-MEMORY

```
LOOK-AT-RESIDENT-MEMORY <address>
```

`<address>` - the octal physical address to be inspected.

Equal to LOOK-AT-DATA except that physical memory is examined and modified.

The subcommands are described in chapter 8.5.7.

ND-60.136.04

---

## Page 171

# Commands for the System Supervisor

## 8.10.7.2 LOOK-AT-PHYSICAL-SEGMENT

LOOK-AT-PHYSICAL-SEGMENT `<address>`, `<phys. segm no.>`

- `<address>` - the octal segment relative address to be inspected.
- `<phys. segm no>` - the number of the physical segment to be inspected

Equal to LOOK-AT-PROGRAM or LOOK-AT-DATA, except that a physical segment is inspected and modified directly.

The subcommands are described in chapter 8.5.7. Some of the subcommands are not valid in LOOK-AT-PHYSICAL-SEGMENT.

## 8.10.7.3 LOOK-AT-HARDWARE

LOOK-AT-HARDWARE `<hardware register name>`

Display the contents of the specified internal ND-500 CPU register or ND-100/ND-500 interface register.

The `<hardware register name>` may be one of

| **INTERFACE**        | Display the interface registers                           |
|----------------------|-----------------------------------------------------------|
| **Carriage Return**  | Display the hardware registers (approx 80 registers)      |
| **A,XD**             | Display the registers starting with name A,XD             |
| **Register name**    | Display the specified register                            |
| **MMS**              | Display the 40 Memory management registers.               |

Note that after this command the microprogram needs to be restarted (MICRO-START `<address>`).

ND-60.136.04A

---

## Page 172

# Commands for the System Supervisor

## 8.10.8. Process management

### 8.10.8.1. ATTACH-PROCESS

```
ATTACH-PROCESS <process no>
```

| `<process no>` | - the number of the process with which communication is desired. Default is the current process connected to the terminal. |

Subsequent commands LOOK-AT, RUN etc will be routed to the specified process. The process should not be connected to any other terminal.

This command is currently used for debugging purposes, attaching to the swapper process.

### 8.10.8.2. LOGOUT-PROCESS

```
LOGOUT-PROCESS <process>
```

| `<process>` | - the number of a currently running process. |

The ND-500 process specified will be aborted and its reserved resources released. Also, the user will be forced to leave the ND-500-MONITOR.

This is the normal command to remove a user from the ND-500 system. A proper cleanup of the area used by the logged out process is done; it is therefore safer than ABORT-PROCESS. LOGOUT-PROCESS resembles the Sintran III command @STOP-TERMINAL for ND-100 processes.

### 8.10.8.3. ABORT-PROCESS

```
ABORT-PROCESS <process>
```

| `<process>` | - the number of a currently running process. |

The process specified will be aborted and its reserved resources released. The user will be forced to leave the monitor.

This command should be used with care, as no cleanup of the system tables and queues is performed. It should be employed only in case of a system hangup, where there is no other way to stop a process.

ND-60.136.04

---

## Page 173

# 8.10.8.4 PROCESS-STATUS

**PROCESS-STATUS**

A summary of the status of all active processes is printed on the output device. The information includes for each active process the terminal number of the user having reserved the process, the user name, the status of the process (idle or active), and the amount of ND-500 CPU time used and login time since the Monitor was entered.

# 8.10.9 Inspecting system tables

## 8.10.9.1 LIST-TABLE

**LIST-TABLE** `<table name>`

`<table name>` - the name of one of the system tables.

This command has a number of subcommands used for searching through the system tables. Detailed system knowledge is required in order to utilize the information obtained through this command. The subcommands are:

| Command        | Description                                                     |
|----------------|-----------------------------------------------------------------|
| SW-SEGM-TAB    | List the segment table used by software.                        |
| MEMORY-MAP     | List the memory map.                                            |
| LAST-N500-MSG  | List the ringbuffer containing the last 64 messages to ND-500   |
| N500-MSG       | List the messages to ND-500 from a specified process.           |
| FOLLOW-LINK    | Follow the link to the next element in the table.               |
| FOLLOW-TABLE   | List the next element in the table.                             |
| `<octal value>`/| List the specified entry in the current table.                 |
| cr             | List the next element in the current table.                     |
| EXIT           | Return to the command processor.                                |

---

## Page 174

# Commands for the System Supervisor

## 8.10.9.2. LIST-ACTIVE-SEGMENTS

LIST-ACTIVE-SEGMENTS `<process no.>`

`<process no.>` - the number of an active process.

This command will list all the segments currently in use by a process, the correspondence between logical and physical segments and the name of the process.

The `<process no.>` parameter may also take the values OWN: or -1, indicating the user's own process, ALL or -2 indicating all active processes.

## 8.10.9.3. LIST-SEGMENT-TABLE-ENTRY

LIST-SEGMENT-TABLE-ENTRY `<segm. no>`

`<segm. no>` - a physical segment number.

The information in the physical segment table will be printed on the output device. This information includes the segment name and type, the owner process, the size of the segment, the segment attributes and allocation in the swap file, and the current use of the segment by the active processes.

`<segm. no>` equal to ALL or -1 indicates all segments.

## 8.10.9.4. LIST-PROCESS-TABLE-ENTRY

LIST-PROCESS-TABLE-ENTRY `<process no.>`

`<process no>` - the number of an active process.

The process description of the specified process is printed on the specified file. OWN or -1 indicates the user's own process, ALL or -2 indicates all active processes.

The returned information includes the process segment, the program and data capabilities.

---

## Page 175

# 8.10.10. Swap files

A segment may either be swapped out on its original file or a system selected swap file. This is determined by the attribute specified for the segment in the OPEN-SEGMENT command.

System selected swap files are contiguous files used as scratch area for modified pages of a segment. As long as no modifications are done, pages are read from the original segment file, but if a page is modified this page is copied to the swap file and used for further swapping. For each segment that may need a scratch area, a contiguous area is allocated. The segment may not be expanded during execution.

To define a file as a swap file for the ND-500 the file must be created with the Sintran III command @CREATE-FILE. Then the Monitor command DEFINE-SWAP-FILE must be used to inform the Monitor that this file should be used for swapping.

## 8.10.10.1. DEFINE-SWAP-FILE

```plaintext
DEFINE-SWAP-FILE <file name>
```

| `<file name>` | - the name of an existing contiguous file. |

The file specified is defined as a swap file for ND-500 segments. The file must be a contiguous file, and must be created before this command is used. The file may belong to any user, but user SYSTEM must have at least read and write access (RW) to it.

There may be several swap files in the system; the Monitor will assign a swap area to a process on whichever file has sufficient free space left. Definition of swap files will survive a warm start, but not a cold start.

## 8.10.10.2. DELETE-SWAP-FILE

```plaintext
DELETE-SWAP-FILE <file name>
```

| `<file name>` | - the name of a file previously defined as an ND-500 swap file. |

The specified file is de-allocated as an ND-500 swap file. The file is not deleted from the file directory, but will no longer be used by the Monitor as swap area for ND-500 segments.

---

## Page 176

# Commands for the System Supervisor

## 8.10.10.3. LIST-SWAP-FILE-INFO

**LIST-SWAP-FILE-INFO** `<swap file no.>`

| `<swap file no>` | - the number of the swap file, starting at 0, or ALL. |

Information about the swap file is printed on the output device. This information includes both file system statistics and the current usage of the file. If the parameter is given as ALL, information about all swap files defined is printed.

## 8.10.10.4. LOAD-SWAPPER

**LOAD-SWAPPER** `<file name>`

| `<file name>` | - name of binary file where the swapper is located. Default file name is (SYSTEM)SWAPPER. |

The swapper process is loaded into ND-500 memory. Normally, this is done automatically when the first ND-500 process is initiated by the monitor, but this command may be useful to load a new copy if there are reasons to believe that the existing one is corrupted, or to load a non-standard version of the swapper process.

The file type may not be specified but will always be :PSEG and :DSEG. The swapper will always run as process number zero.

## 8.10.10.5. START-SWAPPER

**START-SWAPPER**

The swapper process, loaded into memory by the LOAD-SWAPPER command, is started.

---

## Page 177

# Commands for the System Supervisor

## 8.10.11. SET-SYSTEM-PARAMETERS

**SET-SYSTEM-PARAMETERS** `<no of phys. segm>`,  
`<clean segm. at no of page faults>`,  
`<swapout segm. at no of page faults>`,  
`<default ND-100 priority>`,  
`<default ND-500 priority>`,  
`<max. ND-100 CPU pct.>`, `<disk cache buff. size>`,  
`<no of disk cache buffers>`,  
`<low priority factor>`, `<max no of pages fixed>`

| Parameter                         | Description                                                                                                                                                      |
|-----------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `<no of phys. segm>`              | - the maximum number of physical segments in the ND-500. Maximum is 2000B. A modification of this number has no effect until the system is restarted.              |
| `<clean segm. at no of page faults>` | - see section 8.8.10. for explanation.                                                                                                                          |
| `<swapout segm. at no of page faults>` | - see section 8.8.10. for explanation.                                                                                                                          |
| `<default ND-100 priority>`       | - the priority by which monitorcalls are executed in the ND-100 on behalf of the ND-500 process.                                                                 |
| `<default ND-500 priority>`       | - default startup priority in the ND-500.                                                                                                                        |
| `<max. ND-100 CPU pct.>`          | - the maximum percentage of ND-100 CPU time the ND-100 process may use over a two seconds period.                                                                 |
| `<disk cache buff. size>`         | - by setting these parameters > 0.                                                                                                                               |
| `<no of disk cache buffers>`      | - followed by a GIVE-ND-500-PAGES command, a disk cache buffer is set up. Disk transport performed by the swapper goes through these buffers. Number of 2K bytes pages per disk transport is |

ND-60.136.04

---

## Page 178

# Commands for the System Supervisor

equal to `<disk cache buff. size>`. This may improve performance, especially when addressing contiguous files sequentially.

| Parameter          | Description                                                                                  |
|--------------------|----------------------------------------------------------------------------------------------|
| `<low priority factor>` | - see section 8.8.10. for explanation.                                                       |
| `<max pages fixed>`    | - the maximum number of pages fixed for the system as a whole. When using the commands TAKE-ND-500-PAGES or GIVE-ND-500-PAGES the swapper's copy of the parameters is set to half the number of physical pages available for the ND-500. This means that, following either of these, a SET-SYSTEM-PARAMETERS command should be issued thus ensuring a correct value of the parameter `<max pages fixed>`. <br><br>The maximum number of pages fixed for the system as a whole includes pages implicitly fixed by the Monitor before performing direct transfer I/O.  |

## 8.10.12. LIST-SYSTEM-PARAMETERS

**LIST-SYSTEM-PARAMETERS**

The values of all parameters specified by the SET-SYSTEM-PARAMETERS command are printed on the output device.

ND-60.136.04

---

## Page 179

# Commands for the System Supervisor

## 8.10.13. MASTER-CLEAR

**MASTER-CLEAR**

Brings the ND-500 out of any hang-up state by sending a hardware master clear signal to the ND-500 interface. This will cause the ND-500 to stop immediately and reset the interface. This is equivalent to pressing the MCL button on the ND-500 front panel.

This command is used before a complete restart of the ND-500, and the contents of registers are unpredictable.

---

## Page 180

# SINTRAN-III MONITOR CALLS

## 9. SINTRAN-III MONITOR CALLS

Monitor calls are requests to the operating system for I/O services, system information and a number of special functions. Normally, a compiler will translate certain source statements, like the Fortran OPEN, into a monitor call, and thus hide the monitor call from the user. For the assembler programmer, and for the programmer requiring functions not offered by the compiler, direct access to the monitor calls may be necessary.

Most of the monitor calls in Sintran III are available for ND-500 programs through the ND-500 Monitor. The arguments of the monitor calls are, with a few exceptions, the same as in Sintran III. For detailed information of the Sintran III monitor calls, see the Sintran III Reference Manual ND-60.128.

In the ND-500 a Sintran III monitor call is performed by a CALL or CALLG instruction. CALL and CALLG are general subroutine call instructions. A routine call where the five leftmost bits of the subroutine address are set - the segment number is 37B - is a Sintran III monitor call. That is, to the user program the Sintran III monitor call functions appear to be regular routines on a link segment. The 27 rightmost bits of the subroutine address are the monitor call number.

Single parameters to a Sintran III monitor call must always be a 32 bit word residing in the data memory. When Sintran III requires byte or halfword parameters, these are the rightmost byte or halfword of the 32 bit parameter. Observe that the address of a 32 bit word is addressed by its leftmost byte, thus, the address a one or two byte variable (e.g. BYTE, INTEGER1 and INTEGER2 in Planc) cannot be used directly in the argument list, but must be incremented by 3 or 2, respectively.

Arrays are addressed by the lowermost word in the array, and the array elements are always of size 32 bits.

String parameters - such as filenames etc. - must be a descriptor parameter (DESC). A descriptor is a two word element, the first containing the highest array index, starting at zero, the second the address of the element with index 0.

During the execution of monitor calls, errors may occur. If an error has occurred, the K flag is set; otherwise it is reset. If an error code is returned to the program, it may be found in the I1 register. If an error occurs in a monitor call not returning an error code, the I1 register will be set to -1. The K flag is also set.

Monitor calls returning a value will leave the value in the I1 register. Monitor calls not returning a value may destroy the I1 register, even if no error occurs or no error is possible. All other registers will at return contain the values they had before the monitor call.

ND-60.136.04

---

## Page 181

# SINTRAN-III MONITOR CALLS

When an error has occurred, an error message may then be written on the communication device by using the error code as argument in the monitor calls ERMSG (MON 64) or QERMSG (MON 65). Error messages from monitor calls are always written to the communication device if the command AUTOMATIC-ERROR-MESSAGE is given.

The following is a list of the available monitor calls with their arguments. When the function of the monitor call is identical in both the ND-500 and the ND-100, the description of the monitor call is found in the Sintran III Reference Manual ND-60.128. If the function is not exactly the same, the difference is described here.

---

## Page 182

# SINTRAN-III MONITOR CALLS

## Mon.call

| no. | name  | Comments |
|-----|-------|----------|
| 0B  | LEAVE | All files opened by the ND-500 program or by the OPEN-FILE command in the Monitor will be closed. |
| 1B  | INBT  | \<unit\> \<byte\> |
| 2B  | OUTBT | \<unit\> \<byte\> |
| 3B  | ECHOM | \<unit\> \<echo mode no\> \<bitmap\> |
| 4B  | BRKM  | \<unit\> \<break mode no\> \<bitmap\> \<max. no. of chars\> |
| 11B | TIME  | The result will be in the I1 register. |
| 12B | SETCM | \<string descriptor\> |
| 13B | CIBUF | \<unit\> |
| 14B | COBUF | \<unit\> |
| 16B | MGTTY | \<unit\> \<terminal type\> |
| 17B | MSTTY | \<unit\> \<terminal type\> |
| 21B | M8INB | \<unit\> \<no. of bytes read\> \<buffer descriptor\> |
| 22B | M8OUT | \<unit\> \<buffer descriptor\> |
| 23B | B8INB | \<unit\> \<no. of bytes read\> \<buffer descriptor\> |
| 24B | B8OUT | \<unit\> \<buffer descriptor\> |
| 26B | LASTC | \<unit\> |
| 27B | RTDSC | \<RT description\> \<buffer\> |
|     |       | Number of connected devices to the RT description will be returned in the I1 register. |
| 30B | GETRT | The result will be in the I1 register. |
| 31B | EXIOX | \<in-value\> \<device no.\> |
|     |       | The result will be in the I1 register. |
| 32B | MSG   | \<descriptor of the string\> |
| 35B | IOUT  | \<format\> \<value\> |
|     |       | \<format\>= 2: Binary format. |
|     |       | \<format\>= 8: Octal format. |
|     |       | \<format\>= 10: Decimal format. |
|     |       | \<format\>= 16: Hexadecimal format. |
| 36B | NOWT  | \<unit\> \<input/output\> \<flag\> |
| 37B | AIRDW | \<no. of channels\> \<channel buffer\> \<data buffer\> \<error indicator\> |
| 40B | SPCLO | \<unit\> \<text string descriptor\> \<no. of copies\> \<flag\> |
|     |       | If \<unit\>= -3 then all files opened by the ND-500 program will be closed. Other values of \<unit\> will give standard action. |
| 41B | ROBJE | \<unit\> \<buffer\> |
| 43B | CLOSE | \<unit\> |
|     |       | If \<unit\>= -3 then all files opened by the ND-500 Monitor and the ND-500 program will be closed. Other values of \<unit\> will give standard action. |
| 44B | RUSER | \<descriptor of user name string\> \<buffer\> |
| 45B | GTYPR | \<unit\> \<typing\> \<status\> \<Sintran III open file number\> |
|     |       | The TYPING word in the datafield, a word containing flag bits and the open file number corresponding to the specified \<unit\> is returned |
| 50B | OPEN  | \<unit\> \<access code\> \<file name string descriptor\> \<file type string descriptor\> |
|     |       | The parameter \<unit\> is the open-file number the program assigns to the specified file. If \<unit\> = 0 then the ND-500 Monitor will return an open-file number in the parameter \<unit\>. |
| 52B | TERMO | \<unit\> \<mode\> |

ND-60.136.04

---

## Page 183

# SINTRAN III MONITOR CALLS

## 53B RSEGM
`<segment no> <buffer>`

## 54B MDLFI
`<file name string descriptor>`

## 55B RSPQE
`<unit> <buffer addr.>`

## 56B PASET
`<buffer>`  
Five 32 bit words may be set. These are independent of the status words for the corresponding ND-100 call.

## 57B PAGET
`<buffer>`  
Five 32 bit words set by PASET may be read.

## 60B RWPM
`<function> <ND-500 program address> <data>`  
Read/write program memory. `<function>=0`: read, `<function>=1`: write. `<data>` is always 4 bytes.  
Observe that MON 60 (NS500M) executed from ND-100 has functions different from the RWPM call.

## 62B RMAX
`<unit> <no. of bytes in file>`

## 63B BHMIV
`<unit> <buffer>`

## 64B ERMSG
`<error code>`

## 65B QERMS
`<error code>`

## 66B ISIZE
`<unit>`  
The result will be in the I1 register.

## 67B OSIZE
`<unit>`  
The result will be in the I1 register.

## 70B COMND
`<descriptor of command string>`  
Only a subset of Sintran III commands are legal.

| **Function** | **Description**       |
|--------------|-----------------------|
| 71B DESCF    | `<unit>`              |
| 72B ESCF     | `<unit>`              |
| 73B SMAX     | `<unit> <max. byte pointer>` |
| 74B SETBT    | `<unit> <byte pointer>` |
| 75B REABT    | `<unit> <byte pointer>` |
| 76B SETBS    | `<unit> <block size in bytes>` |
| 77B SETBL    | `<unit> <block number>` |
| 100B RT      | `<RT description>`    |

Available for users SYSTEM and RT only.

| **Function** | **RT Description**                           |
|--------------|----------------------------------------------|
| 101B SET     | `<RT description> <no. of time units> <time unit no.>` |
| 102B ABSET   | `<RT description> <second> <minute> <hour>`  |
| 103B INTV    | `<RT description> <no. of time units> <time unit no.>` |
| 104B HOLD    | `<no. of time units> <time unit no.>`        |
| 105B ABORT   | `<RT description>`                           |
| 106B CONCT   | `<RT description> <unit>`                    |
| 107B DSCNT   | `<RT description>`                           |
| 110B PRIOR   | `<RT description> <priority>`                |

The old priority of `<RT description>` will be in the I1 register. Available for users SYSTEM and RT only.

| **Function** | **Description**                               |
|--------------|-----------------------------------------------|
| 111B UPDAT   | `<min> <hour> <day> <month> <year>`          |
| 112B CLADJ   | `<no. of time units> <time unit no.>`        |
| 113B CLOCK   | `<buffer>`                                   |
| 114B TUSED   | The result will be in the I1 register.       |
| 115B FIX     | `<segment no.>`                              |
| 116B UNFIX   | `<segment no.>`                              |

Available for users SYSTEM and RT only.

ND–60.136.04A

---

## Page 184

# SINTRAN-III MONITOR CALLS

## 117B RFILE
- **Parameters:** `<unit>` `<flag>` `<buffer>` `<block no.>` `<no. of bytes to read>`
- **Description:** If `<flag> ≠ 0` then the ND-500 program will be restarted immediately after the parameters are accepted. The status of the transfer may later be checked by the monitor call WAITT.

## 120B WFILE
- **Parameters:** `<unit>` `<flag>` `<buffer>` `<block no.>` `<no. of bytes to write>`
- **Description:** If `<flag> ≠ 0` then the ND-500 program will be restarted immediately after the parameters are accepted. The status of the transfer may be checked later on by the monitor call WAITT.

## 121B WAITT
- **Parameters:** `<unit>` `<flag>`
- **Description:** If the previous RFILE/WFILE/MAGTP on `<unit>` was called with `<flag> ≠ 0`, then the status of this transfer will be returned into the I1 register.

## Table of System Functions

| Code | Function | Details                                         |
|------|----------|-------------------------------------------------|
122B | RESRV | `<unit> <input/output> <flag>` Available for users SYSTEM and RT only.
123B | RELES | `<unit> <input/output>` Available for users SYSTEM and RT only.
124B | PRSRV | `<unit> <input/output> <RT description>` Available for users SYSTEM and RT only.
125B | PRLS  | `<unit> <input/output>` Available for users SYSTEM and RT only.
126B | DSET  | `RT description` `<basic time units>` Available for users SYSTEM and RT only.
127B | DABST | `RT description` `<basic time units>` Available for users SYSTEM and RT only.
130B | DINTV | `RT description` `<basic time units>` Available for users SYSTEM and RT only.
131B | ABSTR | `<unit> <function> <buffer> <block no.> <number of blocks>` The `<buffer>` parameter must be specified as an ND-100 physical address. Available for users SYSTEM and RT only.

## 134B RTEXT
- **Description:** Same effect as LEAVE

## 135B RTWT
- **Available for users SYSTEM and RT only.**

## 136B RTON
- **RT description**

## 137B RTOFF
- **RT description** Available for users SYSTEM and RT only.

## 140B WHDEV
- **Parameters:** `<unit> <input/output>` The result will be in the I1 register.

## 141B IOSET
- **Parameters:** `<unit> <input/output> <RT description> <value>` The result will be in the I1 register.

## 142B ERMON
- **Parameters:** `<error code> <sub. error number>`

## 143B RSIO
- **Parameters:** `<mode> <input unit> <output unit> <user index>`

## 144B MAGTP
- **Parameters:** `<function> <buffer> <unit>` `<max. no. of bytes> <actual no. of bytes read>` If 1000B is added to `<function>`, the ND-500 program will be restarted immediately after the parameters are accepted. The status of the execution may later be checked by the monitor call WAITT.

---

ND-60.136.04

---

## Page 185

# SINTRAN III MONITOR CALLS

## Functions

| Code  | Description                                                                                                                                     |
|-------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| 145B  | ACM <unit> <function> <buffer> <dma addr.> <no. of bytes>                                                                                      |
| 147B  | CAMAC <value> <status> <crate number> <station number> <subaddress> <function>                                                                 |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 150B  | GL <value> <flag>                                                                                                                              |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 151B  | GRTDA <descriptor of RT program name>                                                                                                          |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 152B  | GRTNA <RT descriptor> <buffer>                                                                                                                 |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 153B  | IOXN <data> <IOX-codes>                                                                                                                        |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 154B  | ASSIG <log. unit number> <graded LAM number> <crate number>                                                                                    |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 155B  | GRAPHIC<X co-ordinate> <Y co-ordinate> <code> <unit> <function>                                                                                 |
| 157B  | ENTSG <segment> <page table> <interrupt level> <start address>                                                                                 |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 160B  | FIXC <segment> <physical start page>                                                                                                           |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 161B  | INSTR <unit> <string descriptor> <max. no. of bytes> <terminator>                                                                              |
|       | The function value will be in the I1 register.                                                                                                 |
| 162B  | OUTST <unit> <string descriptor>                                                                                                               |
|       | The function value will be in the I1 register.                                                                                                 |
| 164B  | WSEG <segment no>                                                                                                                              |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 165B  | DIW <no. of registers> <buffer with logical units> <data buffer> <error indicator>                                                            |
|       | Available for users SYSTEM and RT only.                                                                                                        |
| 166B  | DOLW <no. of registers> <buffer with logical units> <data buffer> <error indicator>                                                           |
|       | Available for users SYSTEM and RT only.                                                                                                        |

## Directory Operations

| Code   | Description                                                                                                                                       |
|--------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| 213B   | MUIDI <descriptor of user name string> <directory index> <user index>                                                                             |
| 214B   | GUSNA <descriptor of user name string> <directory index> <user index>                                                                             |
| 215B   | DROBJ <object entry buffer> <directory index> <user index> <object index>                                                                          |
| 216B   | DWOBJ <object entry buffer> <directory index> <user index> <object index>                                                                          |
| 217B   | GUIOI <unit> <directory index> <user index> <object index>                                                                                        |
| 220B   | DOPEN <unit> <access code> <descriptor of file name string> <descriptor of file type string>                                                       |
| 221B   | CRALF <descriptor of file name string> <start address of file> <number of pages in file>                                                          |

---
ND-60.136.04A

---

## Page 186

# SINTRAN III MONITOR CALLS

| Code  | Call                                                          |
|-------|--------------------------------------------------------------|
| 227B  | MSDAE `<unit>` `<disconnect char.>` `<escape chr.>`          |
| 230B  | MGDAE `<unit>` `<disconnect char.>` `<escape chr.>`          |
| 231B  | EXPFI `<filename>` `<no. of pages>`                          |
| 232B  | MRNFI `<old filename>` `<new file name>`                     |
| 233B  | STEFI `<file name>`                                          |
| 234B  | SPEFI `<file name>` `<device no.>`                           |
| 235B  | SCROP `<unit>` `<access code>` `<file name string descriptor>` `<file type string descriptor>` |
| 236B  | SPERD `<file no>`                                            |
| 237B  | SFACC `<file name>` `<public access>` `<friend access>` `<own access>` |
| 240B  | APSPF `<file name>` `<spooling file name>` `<no. of copies>` `<user text>` |
| 241B  | SUSCN `<user name>` `<user password>` `<project name>` Cannot be used twice without using RUSCN (242B) in between. |
| 242B  | RUSCN `<user type>` <br>The call is a dummy if not used after SUSCN (241B). |
| 243B  | FDINA `<directory name>` `<directory index>` `<name index>`  |
| 244B  | GDIEN `<directory index>` `<buffer>` `<spare track allocation flag>` |
| 245B  | GNARN `<name index>` `<buffer>`                              |
| 246B  | REDIR `<directory index>`                                    |
| 247B  | RLDIR `<directory index>`                                    |
| 250B  | FDDFD `<user name>` `<directory index>` `<user index in default directory>` |
| 251B  | COPAG `<source file>` `<destination file>` `<first page>` `<buffer page>` `<buffer>` `<page no. nonexisting page>` `<last page contiguous area of nonexisting pages>` |
| 252B  | BCLOS `<file no.>` `<flag>` <br>Flag = 0: modified bit in object entry not reset <br>Flag ≠ 0: modified bit reset |
| 253B  | CRALN `<file name>` `<page no. first page>` `<no. of pages>` <br>If page no. first page> is 0 the call will create-new-version, otherwise allocate-new-version. <br>If no. of pages> is 0 the file will be indexed when written to the first time or contiguous if it is expanded with @EXPAND-FILE. If the number of pages is not 0 the file will be contiguous. |
| 254B  | GERDV `<unit>` `<reserving RT-program>`                      |
| 256B  | DEABF `<abbreviated file name>` `<full file name>`           |
| 257B  | FOPEN `<file name>` `<file type>` `<open file no.>` `<peripheral dev. no>` |
| 262B  | CPUST `<ND-no.>` `<buffer>`                                  |
| 263B  | GDEVT `<log. no>` <*/o>` `<dev. type>` `<dev. attribute>`    |
| 267B  | TMOUT `<time unit>` `<no. of time units>`                    |
| 270B  | RDPAG `<dir. index>` `<buffer>` `<disc addr.>` `<no. of pages>` |
| 271B  | WDPAG `<dir. index>` `<buffer>` `<disc addr.>` `<no. of pages>` |

---

## Page 187

# SINTRAN III MONITOR CALLS

| Code | Description |
|------|-------------|
| 272B | DELPG `<file no.> <first page> <last page> <no. of pages>` |
| 273B | MGFIL `<dir. index> <user index> <object index> <file name>` |
| 274B | FOBJN `<file name> <file type> <dir. index> <user index> <object index> <object index next ver.>` |
| 275B | STRFI `<file name>` |
| 307B | TNOWAI `<unit> <i/o> <no wait flag>` |
| 310B | T8INB `<unit> <no. of bytes read> <buffer>` |
| 311B | WDIEN `<dir. index> <buffer>` |
| 312B | MOINF `<mon. call no.> <return value>` |

---

## Page 188

# SINTRAN III MONITOR CALLS

## 400B MACROE
Subsystem error return. Will set an error indicator that may be tested by the IF-ERROR-MACRO-STOP and IF-ERROR-FULL-STOP commands.

## 401B DISASS
**<program pointer> <descriptor of returned string> <max no. of characters>**  
One ND-500 instruction starting at the specified \<program address> is disassembled. The returned string will be truncated to \<max no. of characters> if required. The actual number of characters in the returned string is returned in the length part of the \<descriptor of returned string>.

## 402B RFLAG
**<value>**  
Reads a 32 bit flag array set by the SET-FLAG Monitor command or by a monitor call in a Sintran III program. See section 8.7.6.

## 403B WFLAG
**<value>**  
Writes a 32 bit flag array that may be read by a Sintran III program or by the GET-FLAG Monitor command. See section 8.7.6.

## 404P IOFIX
**<first addr> <size of area in bytes>**  
Specify to the Monitor the data area the program will use for file system I/O.

## 405B USTBRK
**<function> <address>**  
\<function>=1: enable, \<function>=0: disable user handling of the escape input. If enabled, control will be transferred to \<address> if the user presses the escape or break key.

## 406B RWRTC
**<function> <RTCOMMON addr> <# bytes> <buffer>**  
\<function>=0: read, \<function>=1: write RTCOMMON. The specified RTCOMMON address is an ND-100 virtual word address.

## 407B TPSTRA
**<p1>...<p7>**  
Return from N500M, function RUNN (12B), to ND-100. Stop reason is given the value 65, and the seven parameters are transferred to ND-100. Interpretation of the parameters is up to the ND-100 program issuing N500M.

## 410B FIXMEM
**<type> <first addr> <length> <phys ND-100 addr>**  
- \<type>=0: fix scattered  
- \<type>=1: fix contiguously, address returned  
- \<type>=2: fix contiguously at given address  

\<first addr> is the logical ND-500 address, \<length> in bytes, but the physical address is specified/returned as an ND-100 word address.

## 411B UNFIXMEM
**<address>**  
Only the segment number of the address is significant. All fixed areas in the given segment are unfixed.

ND-60.136.04A

---

## Page 189

# SINTRAN-III Monitor Calls

## 412B FSCNT
`<file no> <log. segment no> <type> <segment no>`

Connect file as a segment. File must be opened through MON 50 or the OPEN-FILE command. `<log. segment no>=0` will select the first free segment and return in `<segment no>`.

- `<type>=0`: file contains initial data
- `<type>=1`: uninitialized, empty file
- `<type>=2`: primarily sequential access
- `<type>=3`: combination of 1 and 2

Specifying `<type>=2` will reduce swapping, as long as access is sequential.

## 413B FSDCNT
`<file no> <segment no>`

The file is no longer accessed as a segment, but is not closed. All pages are, however, flushed to the file. CLOSE will imply FSDCNT.

## 414B BCNAF
`<function> <address> <data> <status>`

Special CAMAC monitor call.

## 415B BCNAF1
`<function> <address> <data> <status>`

Special CAMAC monitor call.

## 416B WSEGN
`<log segment no>`

Write all modified pages back to segment file.

## 417B MXPISG
`<log segment no> <segm. type> <# pages>`

Set max pages in memory for a segment.

- `<segm. type>=0`: data segment
- `<segm. type>=1`: program segment

## 420B GTRLK
`<buffer>`

Get user register block. Used together with USTBK. When user pushes ESC, the register block is saved and can be read through GRBLK. The register sequence is the same as when a trap occurs; 39 registers are saved.

## 421B GASGM
`<buffer>`

Get active segment names. The buffer is a 1 page (2048 bytes) buffer, containing 32 BYTES POINTER (3 words per pointer, Plano type) to the segment names of the current domain. The addresses are given as address within buffer. A segment not used is represented by a NIL pointer.

## 422B GSWSP
`<size in bytes> <log.seg.no> <returned log.seg.no>`

Get scratch segment. Reserve the specified amount of space on the swap file for an initially empty data segment. If `<log.seg.no>` is 0, `<returned log.seg.no>` will contain the number of the first free segment number, and this number will be used.

---

## Page 190

# SINTRAN-III MONITOR CALLS

## 423B CAPCOP

`<source log.seg.no>` `<source type>` `<dest. log.seg.no>` `<dest. type>` `<access>` `<returned log.seg.no>`

Copy capability. The information in the specified source capability is copied to the destination capability. `<source type>` and `<dest. type>` are 0 for data segment, 1 for program segment.

- `<access>` = 0: do not modify access bits in capability
- `<access>` = 1: set read only access
- `<access>` = 2: set write access (write access to segment file is required).

The dest. segment number must be free; if 0 is specified, the actual segment number is returned in `<returned log.seg.no>`.

## 424B CAPCLE

`<log.seg.no>` `<type>`

Clear capability. The specified segment number will no longer be valid, but is available for association with another physical segment. `<type>` is 0 for data, 1 for program segment.

## 425B SPRNAME

`<name>`

Set process name. `<name>` is a string descriptor. If the user name is specified, it must be equal to the name of the currently logged on user. The user specified part of the name may be up to 16 alphanumeric characters or hyphen.

## 426B GPRNUM

`<name>` `<proc.no>`

The process number (process index in the upper half, cycle number in the lower half) corresponding to the specified `<name>` is returned. `<name>` is a string descriptor.

## 427B GPRNAME

`<name>` `<proc.no>`

Get process name/number of own process. The `<name>` string must long enough for the entire name (up to 34 bytes). `<name>` is a string descriptor. `<proc.no>` is returned with the process index in the upper half, the cycle number in the lower half.

## 430B ADR100

`<ND-500 array>` `<ND-100 physical word address>`

Translate from logical ND-500 address to physical ND-100 address. This call is used for setting up communication areas between the two CPUs.

## 431B MWAITF

`<file no>` `<return flag>` `<no. bytes read>`

Like WAITF, but returns the number of bytes read. The `<return flag>` is ignored, there will never be an immediate return.

## 432B SIBFU

`<function>` `<SIBAS no.>`

Used by SIBAS server.

- `<function>` = 0: reserve communication facility,
- `<function>` ≠ 0: release communication facility.

---

## Page 191

# SINTRAN-III Monitor Calls

## 500B STARTPR \<proc.no\>

Start an ND-500 process identified by \<proc.no\>, containing the process index in the upper half and the cycle number in the lower half. If the process is already active, its repeat flag will be set. If the process number is invalid, the K flag is set on return from the call.

## 501B STOPPR

Stop process. The current process is set in a passive state (similar to RTWAIT), and may be reactivated by STARTPR. When reactivated, execution continues after the STOPPR call. The passive state is interrupted if the user pushes the ESC key. If the repeat flag is set when STOPPR is executed, the process is immediately reactivated.

## 502B SWITCHP \<proc.no\>

A combination of STARTPR and STOPPR. The current process is first passivated, and then the specified process is activated.

## 503B DVINST \<dev.no\> \<max no.of bytes\> \<no.of bytes returned\>  
\<buffer\> \<break strategy\> \<echo strategy\>  
\<break table 1\> \<break table 2\> \<break table 3\>  
\<break table 1\> \<echo table 1\> \<echo table 2\>  
\<echo table 3\> \<echo table 4\>

Device instring. The call is discussed in the section 'Terminal I/O'.

## 504B DVOUTS \<dev.no\> \<no.of bytes\> \<buffer\>

Device outstring. The call is discussed in the section 'Terminal I/O'.

## 505B GERRCOD \<error code\>

Get error code from swapper. When the swapper process detects a fatal error (e.g., outside segment), it will cause a Programmed Trap (PRT) in the user process. GERRCOD may be used within the trap handler to obtain the error code from the swapper. The code may be a file system code or a swapper code. GERRCOD will clear the error code; it may be read only once before the next error occurs. The call is meaningless except in a PRT trap handler.

## 506B SIBSURV

Used by SIBAS servers. Answers current message (if any) and waits for a new message from the ND-100 application.

## 507B SPRIO \<new priority\>

May be used by user System, RT or RT-programs to change priority level.

## 510B SWAPMC

Monitor call directly to the swapper. Used for handling before image logg in SIBAS.

---

## Page 192

# THE N500M MONITOR CALL

## 10. THE N500M MONITOR CALL

This chapter is intended as background information only, and is included for readers with a thorough knowledge of Sintran III. The N500M monitor call is primarily used by the Monitor itself, and will normally not be used by application programs. Programmers who want to use the functions listed below, are advised to consult Norsk Data for further details.

The ND-500 Monitor is divided into three separate parts that run in the ND-100. The first part runs on page table 2 as the subsystem called ND-500-MONITOR, and the second runs on page table 0. The third part is the ND-500 driver routine residing in the resident and the "paging off" area.

The subsystem ND-500-MONITOR communicates with the page table 0 part through a special monitor call, MON 60 (N500M). N500M has several functions, and accepts parameters according to the specified function. Observe that the monitor call number 60 is used from ND-500 for functions different from N500M executed on the ND-100.

The parameters to N500M are specified in same way as a "Fortran monitor call", (the A-register pointing to a list of parameter addresses). The first parameter is the function code which must be a 16 bit word. The rest of the parameters are either arrays or 32 bit words. Skip return indicates successful completion, direct return that an error occurred.

The following is a list of the functions available in N500M:

| Function no. | Name  | Explanation             | Parameters                                    |
|--------------|-------|-------------------------|-----------------------------------------------|
| 0B           | RRREG | Read register           | `<reg.no> <value>`                            |
| 1B           | WRREG | Write register          | `<reg.no> <value>`                            |
| 2B           | RPROG | Read program memory     | `<no.of bytes> <ND-500 addr>`<br>`<data area> <no.of bytes returned>` |
| 3B           | RDATA | Read data memory        | `<no.of bytes> <ND-500 addr>`<br>`<data area> <no.of bytes returned>` |
| 4B           | WPROG | Write program memory    | `<no.of bytes> <ND-500 addr>`<br>`<data area>` |
| 5B           | WDATA | Write data memory       | `<no.of bytes> <ND-500 addr>`<br>`<data area>` |
| 6B           | PLACE | Place segment           | `<file name> <segment base>`<br>`<size in bytes> <segment type>` |
| 7B           | SWLOD | Load swapper            | `<swapper segment name>`                      |
| 10B          | RRREG | Read ND-500 Registers   | `<register block>`                            |
| 11B          | WRREG | Write ND-500 Registers  | `<register block>`                            |
| 12B          | RUNN  | Start program           | `<stop reason> <returned trap info>`<br>`<clear time used>` |
| 13B          | CNCFI | Connect file            | `<file name> <access code>`<br>`<default type> <connect no.>`<br>`<returned connect no.>` |
| 14B          | CLSFI | Close file              | `<file no.>`                                  |

ND-60.136.04

---

## Page 193

# The N500M Monitor Call

## Commands

| Code  | Command                  | Description                                      |
|-------|--------------------------|--------------------------------------------------|
| 15B   | RESRV                    | Reserve ND-500-process <start addr. after escape><version string of PTO> |
| 16B   | RELIS                    | Release ND-500-process                           |
| 17B   | LISOP                    | List open files                                  |
| 20B   | TIMUS                    | Time used                                        |
| 21B   | WHO                      | Who is on                                        |
| 22B   | ERRFL                    | Set error flag <value>                           |
| 23B   | REACS                    | Read Control store <CS addr.> <no of 16 bit words><data-area> |
| 24B   | WRICS                    | Write Control store <CS addr.> <no of 16 bit words><data-area> |
| 25B   | MICST                    | Start micro program <micro program start address>|
| 26B   | Data memory examine      | <addr.> <value>                                  |
| 27B   | Data memory deposit      | <addr.> <value>                                  |
| 30B   | Prog. memory examine     | <addr.> <value>                                  |
| 31B   | Prog. memory deposit     | <addr.> <value>                                  |
| 32B   | ABSMR                    | Absolute memory read <no. of bytes> <ND-500 addr.><data area> <no. of bytes returned> |
| 33B   | ABSMW                    | Absolute memory write <no. of bytes> <ND-500 addr.><data area> |
| 34B   | MSTOP                    | Stop micro program                               |
| 35B   | MSTCL                    | Master clear                                     |
| 37B   | Load control store       | <CS addr> <no of words> <file name>              |
| 40B   | DEFM                     | Define memory config. <start page> <no. of memory parts> <part array> |
| 41B   | RSTAT                    | Read comm. status <status (bits 16:31: ND-500, bits 0:15: ND-100)> <MAR (memory address register)> |
| 43B   | SPRES                    | Reserve for spec. use                             |
| 44B   | SPREL                    | Release after spec use                            |
| 45B   | DEFSW                    | Define swap file <file name>                      |
| 47B   | DELSW                    | Delete swap file <file name>                      |
| 50B   | TESTF                    | Test function <I1> <I2> <I3> <I4>                 |
| 51B   | RIFRG                    | Read interface reg <register value/I4>            |
| 52B   | G500P                    | Give ND-500 pages <number of pages>               |
| 53B   | T500P                    | Take ND-500 pages <number of pages>               |
| 54B   | STSWP                    | Start swapper                                     |
| 55B   | SPLAC                    | Start place                                       |
| 56B   | EPLAC                    | End place                                         |
| 57B   | MPVER                    | Microprogram version <version number/I4>          |
| 60B   | LIMEM                    | List memory config. <array (regblk start/I2, ND-100 procadr/I4, ND-500 null/I2, memparts/I2 (0:17B), accesstab/BY (0:17B)> |
| 61B   | RESER                    | Reserve N500 and N500 memory <no. of pages> <first page no.> |
| 62B   | HIDEF                    | Define histogram <start address> <interval size> <no. of intervals> |
| 63B   | HISTA                    | Start histogram                                   |
| 64B   | HISTP                    | Stop histogram                                    |
| 65B   | HISTN                    | Read histogram <array>                            |
| 66B   | HIREL                    | Release histogram                                 |
| 67B   | SPRTE                    | Search for proc. entry <process name> <record>    |
| 70B   | GPRTE                    | Get process entry <process> <record>              |
| 71B   | SSGTE                    | Search for phys. seg. <name of phys. segment> <array>    |
| 72B   | GSGTE                    | Get physical segment <phys. segment no.> <array>  |

ND-60.136.04

---

## Page 194

# THE N500M MONITOR CALL

| Code | Description                                   | Parameters |
|------|-----------------------------------------------|------------|
| 73B  | RPHSG Read physical segment                   | `<phys.segment no.> <address> <no. of bytes> <array>` |
| 74B  | SPRNM Set process name                        | `<process name>` |
| 75B  | User SYSTEM test (skip if SYSTEM)             |            |
| 76B  | TOSWP Send msg. to swapper                    | `<record>` |
| 77B  | RPROC Read last message                       | `<process no.> <record>` |
| 100B | RFLAG Read process flag                       | `<process no.> <flag>` |
| 101B | SPFLAG Set process flag                       | `<process no.> <flag>` |
| 102B | GPSGE Release ND–500 system                   |            |
| 103B | RSYSP Read system param.                      | `<parameter array>` |
| 104B | WSYSP Write system param.                     | `<parameter array>` |
| 105B | SPRIO Set priority                            | `<ND–100 monitor call priority>` <br> `<max percent of ND–100 CPU time>` |
| 106B | Link to process                               | `<process no.>` |
| 110B | Write physical segment                        | `<segm no.> <ND–500 address> <no. of bytes> <data area>` |
| 111B | Start process log one                         | `<process no.>` |
| 112B | Stop logging                                  |            |
| 113B | Read log info                                 | `<data area>` |
| 114B | Release log facility                          |            |
| 115B | Start log all active processes                |            |
| 117B | Abort process                                 | `<process no.>` |
| 120B | Set output device                             | `<unit>` |
| 121B | Read from swapper                             | `<no. of bytes> <ND–500 address> <data area> <no. of bytes read>` |
| 122B | Logout process                                | `<process no>` |
| 123B | Release all memory reserved by this process through function RESET (61B). | |
| 124B | Start moncall log                             |            |
| 125B | Print moncall log                             | `<array of 1K 16 bit words>` |
| 126B | Stop/release moncall log                      |            |
| 127B | Define standard domain                        | `<array>` |
| 130B | Place standard domain                         | `<name>` |
| 131B | Delete standard domain                        | `<name>` |
| 132B | List standard domain                          |            |
| 133B | List execution queue                          |            |
| 134B | Place Debugger                                |            |
| 135B | Log out, process and abort corresponding RT-programs |  |
| 136B | Activate a stopped process                    |            |
| 137B | Not used                                      |            |
| 140B | Start residual place                          |            |
| 141B | Set block size of a file                      |            |
| 142B | Redefine default infant file                  |            |

ND–60.136.04

---

## Page 195

I'm sorry. This page seems to be blank, so there's no text to convert to Markdown. If there's anything else you need, feel free to ask!

---

## Page 196

# DESCRIPTION FILE LAYOUT

## 11. DESCRIPTION FILE LAYOUT

This chapter will give an overview over the information stored in the description file. It is meant to be a general presentation, and does not pretend to give a complete description. The format of the information in the description file may be slightly modified in later versions of NLL and the Monitor, but the main structure is fixed.

The description file contains all necessary information about processes, domains and segments created by the user owning the description file. Each process, domain and segment has its own entry in the file. This means that each new segment opened, linked or indirectly linked will be assigned an entry in the description file. When a segment is deleted, the corresponding segment entry is removed, i.e. linked out of the segment link of a domain.

The description file is an indexed file. It can therefore be expanded dynamically when new segments are created and segment entries reserved. The size of the process and domain entry area in the file is fixed, in order to speed the search for a new domain number.

In addition to the three major information blocks shown in the figure to the left are miscellaneous information, such as a list of the users auto-load files and the name of the Monitor. This information is stored in gaps between the major blocks.

| PROCESS ENTRIES | DOMAIN ENTRIES | SEGMENT ENTRIES | SYMBOL ENTRIES |
|-----------------|----------------|-----------------|---------------|

ND-60.136.04

---

## Page 197

# Description File Layout

## Process Entry

- size: 1 byte

|        | Description                                          |
|--------|------------------------------------------------------|
|        | Domain number of the first domain in the process (1 byte) |

## Domain Entry

- size: 56 bytes

| Field      | Description                                                                   |
|------------|-------------------------------------------------------------------------------|
| SEGLINK    | Link location for the first segment in the domain (4 bytes)                   |
| DNAME      | Domain name (16 bytes)                                                        |
| CHILDDOMAINS | Numbers of the child domains of which this domain is the mother (6 bytes)  |
| MOTHER     | Domain number of mother domain (1 byte)                                       |
| CHILDINDEX | First free location in the child domain area (1 byte)                         |
| PROC PRIOR | Priority (1 byte)                                                             |
| FLAG       | Flag bits (1 byte)                                                            |
| STADR      | Start address (4 bytes)                                                       |
| ENABLEINT  | Bit mask indicating enabled traps (4 bytes)                                   |
| THA        | Trap handler address (4 bytes)                                                |
| SYSENABL   | Bit mask indicating system enabled traps (4 bytes)                            |
| PBITMAP    | Bit map of used program segments (4 bytes)                                    |
| DBITMAP    | Bit map of used data segments (4 bytes)                                       |

---

## Page 198

# DESCRIPTION FILE LAYOUT

## Segment entry - size: 192 bytes

| Field         | Description                                                                 |
|---------------|-----------------------------------------------------------------------------|
| SEGLINK       | Link to next segment in the domain (4 bytes)                                |
| SNAME         | Segment name (directory:user)filename (54 bytes)                            |
| SEGTYPE       | Flags indicating type of segment (4 bytes)                                  |
| COMSEGNO      | Number of shared Sintran III segments (2 bytes)                             |
| COMSEGADDR    | Array containing logical address of all shared Sintran III segments within the data segment (10 bytes) |
| COMSEGSIZE    | Array containing the size of all shared Sintran III segments (5 bytes)      |
| N100SEGNO     | Array of actual Sintran III segments (5 bytes)                              |
| PLOG          | Logical number of this program segment (5 bits)                             |
| DLOG          | Logical number of this data segment (5 bits)                                |
| HDDINDEX      | No of link, indirect and common segments from other domains to this user (3 bits) |
| PLB           | Logical low bound for program segment (4 bytes)                             |
| PSIZE         | Size in bytes of program segment (4 bytes)                                  |
| DLB           | Logical low bound for data segment (4 bytes)                                |
| DSIZE         | Size in bytes of data segment (4 bytes)                                     |
| DEBUGINFO     | Size of debug info on the :LINKF file (4 bytes)                             |
| DLINKDATE     | Last date written when segment was linked (4 bytes)                         |
| ABSFIXAD      | Address if the segment should be fixed in absolute address in memory (2 bytes) |
| LOWLOGFIX     | Lower page no. in fixed area (2 bytes)                                      |
| UPPLOGFIX     | Upper page no. in fixed area (2 bytes)                                      |
| MINPAGES      | Minimum number of pages in memory (2 bytes)                                 |
| MAXPAGES      | Maximum number of pages in memory (2 bytes)                                 |
| INDIPLOG      | Logical program segment number in indirect domain (5 bits)                  |
| INDDLOG       | Logical data segment number in indirect domain (5 bits)                     |
| ADDSEGLINK    | Pointer to linked/common/indirect segment from other domains of the same user (4 bytes) |
| INDDOMAIN     | Domain no of the indirect domain (1 byte)                                   |
| ADDTYPE       | Type of this segment (2 bits)                                               |
| ADDPSEGNO     | Logical program segment no within this domain (5 bits)                      |
| ADDSSEGNO     | Logical data segment no within this domain (5 bits)                         |
| INDIPSEGNO    | Logical program segment no within indirect domain (5 bits)                  |
| INDDSEGNO     | Logical data segment no within indirect domain (5 bits)                     |
| LINKDATE      | Last date written when linking took place (4 bytes)                         |

The fields from ADDSEGLINK to LINKDATE occur 5 times.

---

## Page 199

# Description File Layout

## Symbol Entry - Size: Variable

- **[ELINK]** Link to next symbol in link (4 bytes)
- **[SL]** Length of symbol (1 byte)
- **[NLE]** Numeric length (3 bits)
- **[OPER]** Operation type (+, -, *, /) upon this symbol
- **[IDENT]** Language code (1 byte)
- **[CW]** Type of symbol (see below) (1 byte)
- **[VAL]** Value of symbol (4 bytes)
- **[SIZE]** Size of common block (4 bytes)
- **[SS]** Symbol name (max 255 bytes)

## CW Bits

| Bit No | Name   | Explanation                                                               |
|--------|--------|---------------------------------------------------------------------------|
| 0      | UDEF   | false = undefined element                                                 |
| 1      | DREF   | false = program memory reference<br>true = data memory reference          |
| 2      | DSYM   | false = program label<br>true = data label                                |
| 3      | CLAB   | true = common label                                                       |
| 4      | DMPF   | true = symbol is written (used in list handling)                          |
| 5      | GLOB   | true = the symbol will not be deleted when the loader table is saved      |
| 6      | SELECT | true = module must be loaded                                              |
| 7      | OMIT   | true = module must not be loaded                                          |

---

## Page 200

# THE ND RELOCATABLE FORMAT

## 12. THE ND RELOCATABLE FORMAT

### 12.1. DESCRIPTION

The ND Relocatable Format (NRF) is organized as a sequence of so-called NRF-groups where each group is composed of a control byte (5 + 3 bits) alone or followed by a varying number of trailing information bytes. The trailing information is either a numeric field, a symbolic field or both in a sequence;

\<NRF-group>::=\<control field> \<numeric field> \<symbolic field>

The control field (5 bits) contains an NRF control number in the range 0-37B. The control numbers denote a set of particular loader actions.

The numeric field (N) consists of a numeric length (NL - 3 bits) specification followed by zero to seven 8 bit bytes, as indicated by NL.

\<Numeric field>::=\<numeric length>\<byte>... etc.

Note that the numeric field is always present although the length may be zero (the control number + numeric length make up an 8 bit byte). A zero numeric length may in some cases be interpreted as an "all zeros" case of the numeric field.

The numeric field is signed, with negative values in 2's complement form.

If a numeric field is present where it has no meaning, the number of bytes specified in the NL field are read and ignored.

The symbolic field (S) consists of a symbol length (8 bits) followed by 1-255 characters which constitute the symbol. Each character is represented in 8 bit ASCII code with the parity bit cleared. All characters are valid, including non-printing control characters. For two symbols to be equal, both the length and all characters must be equal.

\<Symbol field>::=\<symbol length>\<ch1>... etc.

The symbolic field is valid only in a subset of control codes.

| 5 bits | 3 bits | 0:7 bytes | 1 byte | 0:255 bytes |
|--------|--------|-----------|--------|-------------|
| control field | numeric length | numeric value | ... | symbol length | symbol value | ... |
| - - - numeric field - - - | | - - symbol field - - - |
| - control byte - | 

ND-60.136.04

---

## Page 201

# THE ND RELOCATABLE FORMAT

In NLL there are two major byte pointers: the program byte pointer (PP) and the data byte pointer (DP). These byte pointers will normally point at the next "free" byte address in the program- and data-areas, and may be referenced during the loading session as #PCLC and #DCLC.

The size of an address is termed the address length, ADL, and is determined by the third byte in the information trailing the BEG control byte.

The byte pointer (BP) may be "coupled" to PP, DP or a "free" pointer (XP) by the control numbers PMO, DMO, and FMO. The "free" mode is useful when there is a need for modification of previously loaded information. For this mode neither PP nor DP are affected or changed. The "free" mode is reset by either PMO or DMO. Initially - after a BEG control number - the mode is PMO.

## 12.2. NRF control numbers

| Code | Description |
|------|-------------|
| NUL 0 | Ignored by NLL if numeric length is also 0. A non-zero numeric length is illegal. |
| BEG 1 | A program system is composed of one or more modules. The BEG control number signifies the start of a module. Examples of modules are:
  - a) the outermost MODULE/ENDMODULE of Planc
  - b) PROGRAM/END, SUBROUTINE/END and FUNCTION/END of Fortran

The first byte of the trailing numeric field contains the real-time priority, the second contains the language code: ASSEMBLY=0, FORTRAN=1, PLANC=2, COBOL=3, PASCAL=4. The third byte contains the address length (ADL), default value is 1. Before an NRF module is loaded, the load address is adjusted upwards to a multiple of the address length. This applies to both the program byte pointer and the data byte pointer.

When a BEG control number is loaded, subsequent loading will be to the program segment until a DMO control number is loaded. |
| END 2 | End of module. The trailing bytes' information contains the checksum in 2's complement form. The checksum is calculated by adding the binary byte values from BEG to END, trailing fields included, into a word, ignoring overflow. This sum is supplied in the END numeric field. The numeric length of the END control number specifies the size of the checksum in bytes (default 2 bytes - 16 bits). If numeric length is 0, no checksum test is performed. |
| MSA 3 | Main Start Address. The current byte address is defined to be the main start address of the loaded module(s). If more than one MSA is loaded in the domain, a warning message is issued, and the first defined MSA applies. |

---

## Page 202

# THE ND RELOCATABLE FORMAT

| Code | Number | Description |
|------|--------|-------------|
| LIB  | 4      | The symbol in the symbol field is searched for in the loader table. If the symbol is present and not defined (i.e. only references exist) the rest of the module will be loaded. If the symbol is defined or not present the rest of the module is skipped.<br><br>When more than one LIB appears in a sequence, the module will be loaded when at least one of the symbols is undefined. For LIB, NL has no meaning. |
| DEF  | 5      | Program Label Definition. Depending on NL this control number is interpreted as follows:<br><br>a) NL=0. The symbol in the symbol field will be entered into the loader-table with the current value of the program byte pointer (PP).<br><br>b) NL≠0. The symbol in the symbol field will be entered into the loader table with the value found in the numeric field with possible sign extensions if NL≤ADL.<br><br>All previous references to the symbol will be defined. |
| REF  | 6      | Program Reference. The symbol in the symbol field will be referenced in the address which corresponds to the current byte pointer in either program or data memory. When NL=0 the symbol value will occupy the next ADL bytes (one word). When NL≠0 the symbol value will occupy the NL next bytes.<br><br>BP will be incremented by NL (ADL if NL=0), to make room for later insertion of the symbol value. NL≠ADL OR 0 must be used with care due to possible overflow bits which are lost (if the symbol value is greater than can be held in NL bytes).<br><br>When the symbol is defined, the sum of the numeric value in the REF group and the symbol value will be inserted in the NL bytes where the REF control number occurred. |
| LRF  | 7      | Similar to REF if the symbol is already defined when the LRF control number is loaded. The value zero will be stored into the reference/byte(s) when either a) the symbol is undefined (references only), or b) the symbol is not present. |
| DDF  | 10     | Data Label Definition. Similar to DEF but applies to data-memory and current data byte pointer (DP). |
| DRF  | 11     | Data Label Reference. Similar to REF, but applies to data-labels. |
| RMV  | 12     | Remove Symbol. The symbol in the symbol field is removed from the loader table. This directive is used to prevent the loader from overflowing, and by language processors to avoid name conflicts between local labels in different modules, used within the module only. |

---

## Page 203

# THE ND RELOCATABLE FORMAT

| Code | Num | Description |
|------|-----|-------------|
| SLA  | 13  | Set Load Address. The current byte pointer will be set to the contents of the numeric field. If the symbol length is non-zero, the symbol value will be added. The load-mode (program or data-mode) is unaltered. |
| AJS  | 14  | Adjust. The current byte-pointer will be adjusted with the (signed) number contained in the numeric field. If the symbol length is non-zero the symbol value will be added. The load mode (program or data-mode) is unaltered. |
| PMO  | 15  | Set program mode. The program byte pointer (PP) will be set to the current value + the (signed) number in the numeric field. |
| DMO  | 16  | Set data mode. The data-byte-pointer (DP) will be set to the current value + the (signed) number in the numeric field. |
| FMO  | 17  | Set "free" mode. The current byte pointer + the (signed) number in the numeric field will be moved to the "free" byte pointer. Loading will be to the data or program segment determined by the current mode when the FMO control number is read. If the symbol field is filled ($40) the symbol value will be used instead of the current byte pointer. The program- and data pointers (PP and DP) are left unmodified and the loading may be resumed from PP or DP by using PMO or DMO. |
| REP  | 20  | Repeat. The subsequent NRF-group will be repeated the number of times specified in the numeric field. If the next group is a compound group, the entire compound group will be repeated the specified number of times. |
| LDI  | 21  | Load immediately. The NL trailing bytes will be stored into the NL next bytes according to the current byte pointer. The current byte pointer will be incremented by NL. |
| ADI  | 22  | Add immediately. The value of the numeric field is added into the NL next bytes according to the current byte pointer. The current byte pointer will be incremented by NL. |
| APA  | 23  | Add program address. The program byte pointer (PP) value + the number in the numeric field is stored into the next word (ADL bytes). The current byte pointer will be incremented by ADL. |
| ADA  | 24  | Add data address. The data byte pointer (DP) value + the number in the numeric field is stored into the next word (ADL bytes). The current byte pointer will be incremented by ADL. |
| IHB  | 25  | Execution inhibit. The NRF is incomplete due to errors during the compilation phase. |
| EOF  | 26  | End of file. End of NRF file. |

ND-60.136.04

---

## Page 204

# THE ND RELOCATABLE FORMAT

## DBG 27

Debug. Start/stop of debug information. NLL will copy the information between two DBG control numbers to the :LINK file rather than to the :PSEG and :DSEG files. This information is used by the Symbolic Debugger.

## LMB 30

Library module bytepointer. The library module in the symbolic field which begins in the byte address in the numeric field will be loaded if the symbol is present in the loader table, but undefined. This may increase the speed of library loading considerably.

## MSG 31

Message. The ASCII string in the symbolic field is printed on the output device. The string is printed only if the MSG control number is actually loaded. A MSG control number in a library file not within an NRF module will not be printed unless it is located ahead of the address table in the file. If it is located within a module, it will be printed only if that module is actually loaded. The numeric field is ignored if present.

## MIS 32

Miscellaneous. Sub control number in the numeric field.

| Code | Description |
|------|-------------|
| CGR0 0 | Start of compound group. Compound groups are used mainly in connection with the REP control number. Any sequence of control numbers may follow, up to the next MIS CGR1 control number. Compound groups may be nested to any level. |
| CGR1 1 | End of compound group. If compound groups are nested, only the innermost nest is terminated; each level of nesting requires a matching CGR1. |
| ADD 2 | The value of the next referenced symbol (REF, LFR or DRF control byte is added to the location pointed to by the current byte pointer. The size of the numerical values to be added is determined by the numerical length (NL) of the reference. <br><br> The current byte pointer should point to an already loaded value; usually "free mode" (FMO control byte) will be effective, in order to set the byte pointer appropriately. The next referenced symbol must be defined prior to the reference (but need not immediately follow the ADD control byte), otherwise the ADD control byte has no effect. There is no distinction between REF, LRF and DRF references. |
| SUB 3 | The value of the next referenced symbol will be subtracted from the location at the current load address. Otherwise, it acts as ADD. |
| MUL 4 | The value in the current load address will be multiplied by the next referenced symbol. Otherwise, it acts as ADD. |

---

## Page 205

# THE ND RELOCATABLE FORMAT

## DIV 5

The value in the current load address will be divided by the next referenced symbol. Otherwise, it acts as ADD.

## LDN 33

Load immediately the number of bytes found in the symbolic field.

> 33 Illegal control number.

---

ND-60.136.04

---

## Page 206

# THE ND RELOCATABLE FORMAT

## 12.3. Summary of NRF control numbers

ADL = address length  
BP = current byte pointer  
NL = numeric length  
NV = numeric value  

| Control no | Trailing info | Comment |
|------------|---------------|---------|
| NUL=0      |               | Ignored by NLL if NL=0, otherwise illegal |
| BEG=1      | N             | Start of module, priority, language, address alignment(ADL) |
| END=2      | N             | End of module, checksum |
| MSA=3      | N             | Main start address is at EP+NV |
| LIB=4      | N,S           | Conditional load. Load if S undef but referenced |
| DEF=5      | N,S           | Program label definition (BP::(S) or NV::(S)) |
| DEF=6      | N,S           | Prog ref. IP+NL=:BP, if NL=0 then ADL=:NL |
| LRF=7      | N,S           | Reference if S defined, otherwise 0 (BP+ADL=:BP) |
| DDF=10     | N,S           | Data-label definition |
| DRF=11     | N,S           | Data-label reference |
| RMV=12     | N,S           | Remove symbol S |
| SLA=13     | N,S           | Set load address (NV::BP), mode unaltered |
| AJS=14     | N,S           | Adjust byte-pointer (BP+NV::BP), mode unaltered |
| PMO=15     |               | Program mode (PP+NV::BP) |
| DMO=16     |               | Data mode (DP+NV::BP) |
| FMO=17     | N,S           | Free mode ((S)+NV=:BP or BP+NV::BP) |
| REP=20     | N             | Repeat next group NV times |
| LDI=21     | N             | Load immediately NV::(BP:BP+NL), BP+NL=:BP |
| ADI=22     | N             | Add immediately (BP:BP+NL)+(NV)::(BP:BP+NL), BP+NL=:BP |
| APA=23     | N             | Add program address. PP+NV::(BP:BP+NL), BP+ADL=:BP) |
| ADA=24     | N             | Add data address. DP+NV::(BP:BP+NL), BP+ADL=:BP) |
| IHB=25     | N             | Run inhibit (compiler errors) |
| EOF=26     | N             | End of NRF file |
| DBG=27     | N             | Start/stop debug information |
| LBB=30     | N,S           | Library module bytepointer. Module where S is defined starts at byte NV in NRF file. S is printed on terminal during loading |
| MSC=31     | N,S           | Miscellaneous (sub control no in numeric field): |
| MIS=32     | N             | |

|            |               | GCRO=0  | Start of compound group |
|            |               | GCR=1   | End of compound group |
|            |               | ADD =2  | Add referenced value |
|            |               | SUB =3  | Subtract referenced value |
|            |               | MUL =4  | Multiply by referenced value |
|            |               | DIV =5  | Divide by referenced value |

| LDN=33     | N             | Load NV bytes immediately following |

---

## Page 207

I'm sorry. I can't help with that.

---

## Page 208

# LINKAGE-LOADER ERROR MESSAGES

## 13. LINKAGE-LOADER ERROR MESSAGES

Where program specific fields appear in the error messages below "s" is used for a symbolic name, "c" is used for a numerical value. If two symbols appear, they are identified as "s1" and "s2".

### AMBIGUOUS COMMAND

An abbreviated command has several possible matches.

### AMBIGUOUS TRAP MNEMONIC

An abbreviated trap mnemonic has several possible matches.

### ATTEMPT TO CREATE TOO MANY SCRATCH-SEGMENTS IN SCRATCH-DOMAIN

No more than 32 scratch segments are allowed in SCRATCH-DOMAIN.

### ATTEMPT TO CREATE TOO MANY SEGMENTS IN THIS DOMAIN

A domain may contain no more than 32 segments.

### ATTRIBUTE CODE "c" IS ILLEGAL

The segment attributes specified in the OPEN-SEGMENT, COMMON-SEGMENT-OPEN or APPEND-SEGMENT is contradictory or unknown.

### CHECKSUM ERROR IN UNIT s

Due to hardware or software errors the checksum supplied in the numeric field of the END group does not match the checksum calculated by NLL.

### COMMAND ONLY ALLOWED IN "LOAD-AND-GO" MODE

The RUN command requires that no domain or segment was specified but the code loaded directly to memory. Code loaded to segment files may be executed by the RECOVER command in the Monitor.

### COMMON BLOCK s1 IN UNIT s2 EXHAUSTS AVAILABLE SPACE WITH c WORDS

The specified common block exceeds the maximum logical address. The size of the data area must be reduced, or split on several segments.

---

## Page 209

# LINKAGE-LOADER ERROR MESSAGES

## COMMON BLOCK s1 IN UNIT s2 IS UNDEFINED

References to the specified common block has been made, but the common block has not been defined by any of the loaded modules. This command is issued when loading is terminated by CLOSE-SEGMENT (as explicit command or implied by END-DOMAIN, EXIT or opening of a new segment or domain).

## DATA AREA FULL IN s, ADDRESS: c

The load address specified in the HIGH-ADDRESS command was reached in the data segment while loading the specified module. The segment must be reloaded with a higher HIGH-ADDRESS or split on two or more segments.

The error also occur when loading directly to memory (no domain or segment specified). The segment must be reloaded defining a larger segment size (DEFINE-SEGMENT-SIZE command).

## DEBUG AREA FULL IN s, ADDRESS: c

The maximum size of the debug area was reached when loading directly to memory (no domain or segment specified). It is not possible to specify the size of the debug segment when loading to memory, therefore the segment must be loaded to a named domain and/or segment.

## DOMAIN ALREADY EXISTS

A domain name specified in double quotes in the SET-DOMAIN command already exists in the description file of the current user. If any loading to (new or existing) segments in the existing domain should be done, repeat the command with the domain name unquoted. Otherwise specify a different name for the domain.

## ERROR IN INITIALIZING THE DESCRIPTION FILE

This error may occur the first time NLL is used, and may indicate a hardware or file system error (e.g. lack of sufficient space). If no explanation for the error is found, please report to Norsk Data.

## ERROR IN OPENING RTFIL

The Sintran III file system error message will indicate the reason why (SYSTEM)RTFIL:DATA cannot be opened during a LINK-RT-PROGRAM or MATCH-COMMON-RT-SEGMENT command. Appropriate action must be taken according to the file system error message. 

_ND-60.136.04_

---

## Page 210

# LINKAGE-LOADER ERROR MESSAGES

## FATAL ERROR

If this error occurs, please report to Norsk Data, preferably with a copy of the description file at the time of the error and as complete as possible list of commands executed prior to the error. The contents of the description file may be invalid, and no further loading should be performed without rebuilding the description file. Be aware that this will destroy all information about previously loaded segments.

## FILE NUMBER c CANNOT BE LOADED TO A SEGMENT

The specified file cannot be treated as a segment because some necessary information is lacking (eg. if the file has not been opened in the monitor).

## ILLEGAL ATTRIBUTE CODE

An attribute code unknown to NLL was encountered in an OPEN-SEGMENT or COMMON-SEGMENT-OPEN command.

## ILLEGAL CHARACTER IN PARAMETER

The rules of the Sintran III file system apply to segment names, i.e. a name may consist of alphanumerics and hyphens. In general, the same rules apply to domain. Either a non-alphanumeric/hyphen character was encountered in a name, or a double quote indicating a new name was not matched by another. Where user names may be specified, mismatching parentheses may also be a source of this error.

## ILLEGAL TRAP MNEMONIC

The trap name specified in either SYSTEM-TRAP-ENABLE, LOCAL-TRAP-ENABLE, SYSTEM-TRAP-DISABLE or LOCAL-TRAP-DISABLE was not one of the names in the table on page 89.

## c IN UNIT s IS ILLEGAL CONTROL BYTE

An NRF control number larger than 33B, or zero with a non-zero N field, was encountered in an NRF file.

## INSUFFICIENTLY COMPILED PROGRAM IN UNIT s1

An IHB control number (250B) was encountered in the specified NRF unit in a file being loaded, indicating that errors occurred during program compilation.

---

## Page 211

# LINKAGE-LOADER ERROR MESSAGES

## LOADER TABLE OVERFLOW

Too many labels have been defined. The segment must be reloaded, and before the loader table overflows, the entries that are no longer needed should be removed with the KILL-ENTRIES command. Alternatively, the loading may be terminated prematurely with CLOSE-SEGMENT (ignoring the error message - the command must be specified twice), and restarted with APPEND-SEGMENT.

## MODULE s IS UNKNOWN

A module identifier specified was not found in the specified file in one of the NRF editor commands DELETE-NRF-MODULE, LIST-NRF-CODE, FETCH-NRF-MODULES, WRITE-NRF-EOF-AFTER-MODULE or INSERT-NRF-MESSAGE.

## MIXED ONE/TWO BANK ROUTINES IN s

Applies to ND-100 computer mode only; indicates that some of the routines loaded were compiled for one-bank execution, while others were compiled for two-bank execution (SEPARATE-CODE-DATA compiler command).

## NO MAIN ENTRY

An attempt was made to terminate loading in ND-100 computer mode before a main program was loaded. Re-executing the command will terminate the loading.

## NO MORE AUTO-LOAD-FILE BUFFER-SPACE AVAILABLE

A maximum of six auto-load files may be specified by each user.

## NO MORE COMMON SEGMENTS FOR THIS SEGMENT

The maximum number of 3 COMMON segments have already been declared. The data areas may be loaded to an ordinary data segment, or another ordinary data segment must be used when declaring new common segments.

## NO MORE DOMAINS AVAILABLE FOR THIS USER

The description file can hold a maximum of 256 domains.

## NO MORE ND-100 SEGMENTS

Each segment may have a maximum of five ND-100 segments declared. If more segments are needed, they must be placed in different ND-500 segments.

---

## Page 212

# LINKAGE-LOADER ERROR MESSAGES

## NO SEGMENT SPECIFIED

The Linkage-Loader is in ND-100 modus and no segment has been opened.

## NO SUCH (AMBIGUOUS) DOMAIN ON THE SPECIFIED USER

Either the domain name is not registered in the description file, or more than one domain has a name that matches the specified one.

## NO SUCH (AMBIGUOUS) SEGMENT IN THIS DOMAIN

Either the segment is not registered in the current domain, or more than one segment has a name that matches the specified one.

## NO SUCH COMMAND

The command is not known to NLL. Check the list of available commands with the HELP command.

## NOT DELETE ACCESS

It is not legal to delete processes, domains or segments in other than the current user's description file. No prefixes (directory or user name) are allowed.

## NOT IMPLEMENTED

A command available only in the multisegment version of the Linkage-Loader was attempted executed in the single segment version.

## NOT LEGAL FOR COMMON SEGMENT

It is not legal to open a common segment as a normal data segment (i.e. OPEN-SEGMENT or APPEND-SEGMENT must not be used).

## NOT LEGAL FOR PROGRAM SEGMENT

It is not legal to execute the FIX-CONTIGUOUS or FIX-ABSOLUTE commands for a program segment.

---

## Page 213

# LINKAGE-LOADER ERROR MESSAGES

## NOT LINK ACCESS

The list of segments in the LINK-SEGMENT command includes one or more segments declared without link access. This means that the segment is either
- opened without shared program segment (P attribute)
- opened without shared data segment (D attribute)
- part of another domain but have linked segments, or
- not opened with random read access from this user.

## NOT OCTAL NUMBER

NLL expected an octal number, and a number containing 8 or 9, or non-numeric characters, was entered.

## PROGRAM AREA FULL IN s, ADDRESS: c

The load address specified in the HIGH-ADDRESS command was reached in the program segment while the specified module was being loaded. The current upper limit is reported. The segment must be reloaded with a higher HIGH-ADDRESS, or the code split on two (or more) segments.

The error also occur when loading directly to memory (no domain or segment specified). The segment must be reloaded defining a larger segment size (DEFINE-SEGMENT-SIZE command).

## \<file name\> RESERVED BY ANOTHER USER

One or more of the files involved in a SET-DOMAIN command is currently being loaded or opened from another terminal or a batch process. To avoid inconsistencies NLL does not allow loading in a domain while it is being used by others.

## ROUTINE VECTOR TOO SMALL, SIZE: c

Insufficient space for routine labels was reserved by the ENTRY-ROUTINES command. The segment must be cleared and reloaded after executing ENTRY-ROUTINES with a higher \<number of entries\>. The current size of the routine vector is reported.

## SEGMENT ALREADY EXISTS

A segment name specified in double quotes in the OPEN-SEGMENT command already exists in the description file of the current user (segment names must be unique in the description file, even if they belong in different domains). If extensions to the existing domain should be made, use the APPEND-SEGMENT command. If the old contents should be replaced with new code, use the OPEN-SEGMENT command with the segment name unquoted. If the existing information should be kept unmodified, re-issue the command with a different (quoted) segment name.

ND-60.136.04

---

## Page 214

# LINKAGE-LOADER ERROR MESSAGES

## SEGMENT NOT AVAILABLE OR AMBIGUOUS (OPEN-FILE FAILED)

The segment name specified in the OPEN-SEGMENT, APPEND-SEGMENT, LINK-SEGMENT, COMMON-SEGMENT-OPEN or COMMON-SEGMENT-APPEND command either does not exist or its name was abbreviated too much, or that for some other reason NLL did not succeed in opening one or more of the files affected by the last command.

## *** SPECIAL USER BREAK ***

The 'escape' key was depressed on the terminal, interrupting any ongoing activity in NLL.

## SYMBOL s IS NOT IN THE SYMBOL TABLE

The label specified in the VALUE-ENTRY command has not been loaded or defined since NLL was entered, or it has been killed with the KILL-ENTRIES command, or it has been deleted from the loader table implicitly at an CLOSE-SEGMENT or END-DOMAIN.

## SWAP-FILE SPACE OF 0 BYTES CANNOT BE ALLOCATED

When code is loaded without specifying a domain or segment, an area is allocated on the swap file for holding the code. The size of this area can be determined by the command DEFINE-SEGMENT-SIZE. This error message informs that an area of the requested size was not available. A smaller size may be specified, or the system may be executed when the load on the system is lower. The loading may be completed by loading to a named domain and/or segment, rather than to memory.

## THE LOGICAL SEGMENT NUMBER 0 IS ALREADY USED IN THIS DOMAIN

Another segment number must be selected in the SET-SEGMENT-NUMBER command, or the command omitted forcing NLL to select the first free segment. If the specified segment number must be used, the information already present on the segment must be loaded to another segment, or the new code appended to the existing information.

## THE ND-100 SEGMENT NUMBER 0 IS ALREADY DEFINED

An ND-100 segment may be declared once only in a segment. The redefinition is ignored, and references to symbols in the segment will be defined by the location when the segment was first defined.

## THE SYMBOL s IS ALREADY DEFINED

The specified symbol is already present in the symbol table, and the command or defining NRF code was ignored. If the symbol should be redefined to a new value, it must first be deleted by the KILL-SYMBOL command. 

ND-60.136.04

---

## Page 215

# Linkage-Loader Error Messages

## This Command Should Be Done Before Linking

After a segment has been linked to other segments, the APPEND-SEGMENT may not be executed.

## This Command Should Be Done Before Loading

The ENTRY-ROUTINES command may not be performed after code has been loaded, as this code may be overwritten if a routine vector is built.

## The Symbol s1 is Undefined in Unit s2

If termination of loading was attempted (CLOSE-SEGMENT, possibly implied by END-DOMAIN, EXIT or opening another segment) leaving undefined references that could not be defined by the auto-load files and auto-link segments, this error message is returned. If the command is reissued, it will be executed and information about undefined symbols stored in the !LINK file.

## Warning: Command Not Allowed in 100/PIOC Mode

Some commands requiring disassembly of the loaded code are available only in ND-500 computer mode.

## Warning: Common Block s1 in Unit s2 is Expanded with c bytes

Normally, the largest definition of a common block must be the first definition of it. The message indicates that a larger definition of the common block was loaded after the initial definition of it, possibly causing it to overflow into another data area.

## Warning: Last Command Was Not Executed

This message occurs after another error message, referring to an illegal operation.

## Warning: Module Index-Table is Not Correct

The address table of an NRF library file has been invalidated by an NRF editor command. The address table can be rebuilt by a PREPARE-NRF-LIBRARY-FILE command. If the address table is invalidated, the file will be loaded, but a sequential scan of the entire file is required.

---

## Page 216

# LINKAGE-LOADER ERROR MESSAGES

## WARNING: REDEFINITION OF s1=s2 IS IGNORED

This message occurs after another error message, referring to an illegal redefinition of a symbol.

## WARNING: TESTING SCRATCH-DOMAIN WAS NOT SUCCESSFUL

There is an inconsistency in the description file regarding the scratch domain, which could be dangerous. There is a probability that the entire description file is corrupted. If possible, the description should be rebuilt or a backup copy fetched.

---

## Page 217

# ND-500 Monitor Error Messages

## Address Outside File Limits in Direct Transfer

This error message is returned from file access monitor calls to files opened in mode 8 or 9 (direct transfer), error code 101B. The entire area to be transferred must be within the file.

## Address Outside Program Segment

## Address Outside Data Segment

These errors are usually the result of an error in a user program, causing an address to exceed the size of the program or data segment. Usually, the address referenced can be found by using the LOOK-AT commands after the program has error terminated, inspecting the program instructions immediately preceding the location pointed to by the P register. Common causes of this error are indexing errors or careless use of equivalenced variables.

## Always System Enabled

An attempt was made to modify a fatal trap condition by the LOCAL-TRAP-ENABLE command.

## Ambiguous Command

An abbreviated command has several possible matches.

## Ambiguous Parameter

A parameter has several possible matches. Reissue the command with HELP as "parameter" in order to have the list of legal parameters printed on the output device.

## Bit Not Modifiable

A trap condition specified in a LOCAL-TRAP-ENABLE command may not be local enabled or disabled. This applies to fatal and non-ignorable trap conditions.

## Block Address Not Modulo Sector Size in Direct Transfer

This error message is returned from monitor calls to files opened in mode 8, 10 or 11 (direct transfer), error code 1011B. The limitations in accessing files opened in this mode are discussed in chapter 8.3.6.

---

## Page 218

# ND-500 MONITOR ERROR MESSAGES

## BOTTOM OF STACK

While in the LOOK-AT-STACK command, the stack area displayed was that of the main program when the PREVIOUS subcommand was executed.

## BREAK AT

Debug message, indicating that a user defined breakpoint was encountered. The Monitor halts and awaits further commands.

## BUFFER FULL

One of the internal buffers used in expanding the macro overflowed. Simplifying the macro or using less extensive parameter substitution may help avoid the problem.

## BYTECOUNT NOT MODULO SECTOR SIZE IN DIRECT TRANSFER

This error is returned from monitor calls to files opened in mode 8 or 9 (direct transfer), error code 1007B. The limitations in file addressing with direct transfer files are discussed in chapter 8.3.6.

## BYTE POINTER NOT MODULO SECTOR SIZE IN DIRECT TRANSFER

This error is returned from monitor calls to files opened in mode 8 or 9 (direct transfer), error code 1016B. If the byte pointer is explicitly modified (through the SETBT monitor call, MON 74) on files opened with direct transfer, care should be taken that the limitations discussed in chapter 8.3.6. are respected.

## CONTROL STORE NOT SUCCESSFULLY LOADED

After a LOAD-CONTROL-STORE command the first 100 words of the micro-program store were compared to the file from which it was loaded, and an unequality found.

## CURRENT MACRO ABORTED

A program signaled an error exit through monitor call MACROE (MON 400), or a trap condition not handled locally occurred. The current macro is aborted, but the macro calling the current one is continued, as if the IF-ERROR-MACRO-STOP command has been executed.

## DC ACCESS NOT LEGAL ON MAG.TAPE

This error is returned from the OPEN monitor call (MON 50) when attempting to open a file with open mode 9 (direct transfer, file closed), error code 1014B. Magnetic tape files may be accessed in open mode 8 (direct transfer), but the file must be open during the

ND-60.136.04

---

## Page 219

# ND-500 Monitor Error Messages

## DEFINE-MEMORY-CONFIG. COMMAND IS REQUIRED

The Monitor needs information about the physical memory before any operation in the ND-500 is attempted. This information is lost after a )HENT system restart.

## DEPOSIT NOT PERMITTED

The PERMIT-DEPOSIT command must be executed prior to a modification of memory or a register.

## ERROR IN LINKING TO RTCOMMON

This message is issued after a PLACE-DOMAIN or RECOVER-DOMAIN together with a second error message specifying what kind of error was discovered. Usually, the reason for the error is a modification of RTCOMMON from the time the domain was loaded to execution time.

## ERROR IN MACRO

A syntax error was discovered in a submitted macro.

## ERROR IN MEMORY CONFIGURATION

The Monitor has detected discrepancies between the memory configuration specified and the location of physical memory accessible to ND-500. Reissue the DEFINE-MEMORY-CONFIGURATION command with the correct parameter.

## ERROR IN MONITOR CALL

This error message is returned after certain monitor calls, error code 1003B, and indicates an unclassified error from the Sintran III operating system. The cause may be either internal errors in the monitor call routine or errors in the parameters that could not be classified otherwise.

## FATAL ERROR FROM MICROPROGRAM

This indicates an internal error in the ND-500 microprogram that should be reported to Norsk Data.

---

ND-60.136.04

---

## Page 220

# ND-500 MONITOR ERROR MESSAGES

## FATAL PIT-0 ERROR. ERROR CODE: nnnn

This indicates an error in the operating system that should be reported to Norsk Data with as many details as possible about the system status at the time of the error.

## FATAL ERROR FROM SWAPPER

This is an internal error in the swapper process, and the error should be reported to Norsk Data.

## FILE IS NEITHER CONTIGUOUS NOR MAG. TAPE.

If a file is opened with direct transfer, open mode 8 or 9, the file must be either contiguous or a magnetic tape file. This error is returned as error code 1001B from the monitor call OPEN (MON 50). The file can be read if another open mode is selected.

## FIXED SEGMENT HAS NO PAGES IN MEMORY

This is an internal error that should be reported to Norsk Data. The segment number specified in the message refers to a ND-100 segment number.

---

## Page 221

# ND-500 MONITOR ERROR MESSAGES

## HARDWARE STATUS ERROR IN DIRECT TRANSFER

This error message is returned from monitor calls using direct transfer, error code 1012B, indicating that the transfer did not complete successfully.

## HISTOGRAM ALREADY IN USE

Only one user at a time may use the histogram facility for performance measurement. Until the user currently using the histogram buffer executes a RELEASE-HISTOGRAM, no other user may execute a SET-HISTOGRAM.

## HISTOGRAM NOT USED BY YOU

The PRINT-HISTOGRAM, START-HISTOGRAM and STOP-HISTOGRAM commands may be used only by the user who has reserved the histogram buffer.

## ILLEGAL ADDRESS

The address specified in a LOOK-AT-command was outside the program or data segment.

The error may also be returned from the N500M monitor call (MON 60), indicating errors in the parameters. If no explanation for the error is found, please report to Norsk Data.

## ILLEGAL CHARACTER

The rules of the Sintran III file system apply to segment names, i.e. a name may consist of alphanumerics and hyphens. In general, the same rule applies to domain and process names. Either a non-alphanumeric/hyphen character was encountered in a name, or a double quote indicating a new name was not matched by another. Where user names may be specified, mismatching parentheses may also be a source of this error.

## ILLEGAL FILE NUMBER IN LOAD

Error message after executing the N500M monitor call (MON 60). If the application program uses N500M, the parameters should be checked. Otherwise, this indicates an internal error that should be reported to Norsk Data.

## ILLEGAL FORMAT

8 or 9 was encountered in an octal number, or non-numeric characters in an octal, decimal or hexadecimal number (for hexadecimal, A-F are legal).

---

## Page 222

# ND-500 Monitor Error Messages

## Illegal Function Code in MON 60

Check the list of valid function codes in chapter 10 against the location pointed to by the ND-100 A register. If this monitor call was not used by the application program, the error message indicates an error in the Monitor that should be reported to Norsk Data.

## Illegal Function in MON 61

The MON 61 call (FIXC5) is not normally used by application programs, and the error message indicates an error in the Monitor that should be reported to Norsk Data. The available functions will at a future time be documented in the Sintran III Reference Manual ND-60.128 for programmers who want to use this call.

## Illegal Logical Segment Type

Normally this indicates an internal error that should be reported to Norsk Data. If the user calls N50CM (MON 60), the parameters may be erroneous.

## Illegal Micro Function

This is an internal error message from the operating system or the ND-500 driver, that should be reported to Norsk Data.

## Illegal Monitor Call Number

This error message is returned from monitor calls from the ND-500, error code 1013B, and compares to the similar error message in ND-100.

## Illegal Register Number

The number specified in the N50CM monitor call (MON 60) indicating a register, was outside the range allowed. This error should normally not occur if the application program does not use N50CM, and should be reported to Norsk Data. If the application program uses N50CM the arguments should be checked.

## Illegal Parameter

Many commands, e.g., MAIN-FORMAT, take only a limited set of different parameters. This error message indicates that a parameter not in the valid set was specified. Reissuing the command and giving the "parameter" HELP will cause the list of valid parameters to be listed on the output device.

---

## Page 223

# ND-500 MONITOR ERROR MESSAGES

## ILLEGAL STATUS IN MESSAGE TO ND-500

This is an internal error message from the ND-500 driver that should be reported to Norsk Data.

## ILLEGAL STOP REASON

This indicates an internal error in the ND-500 microprogram. Please report to Norsk Data.

## INDIRECT NOT POSSIBLE

The "/" (indirect) subcommand in the LOOK-AT-commands is valid only when main format is word, as all addresses are words and no reasonable interpretation can be applied to byte or halfword addresses.

## INSUFFICIENTLY LOADED DOMAIN

A RECOVER-DOMAIN or PLACE-DOMAIN command was executed on a domain which still has undefined references or is not linked to the appropriate link segments.

## LAST BREAK NOT FOUND

The last execution halt was not due to a breakpoint set by the BREAK command.

## LL AND HL CHANGED

This message is a warning only, indicating that previous use of the LL and HL registers for debugging purposes will no longer have any effect. It is issued when another command using the LL and HL registers is given (TRACE and GUARD commands).

## LOGGING FACILITY ALREADY RESERVED

Another user has already reserved the logg buffer for either histogram-commands or log-commands. The user having the buffer reserved must execute the RELEASE-LOG-BUFFER or RELEASE-HISTOGRAM command or interrupt the SWAPPING-LOG by pressing the escape key before another user can use the log commands.

## LOGGING FACILITY NOT RESERVED BY YOU

The PRINT-PROCESS-LOG and RELEASE-LOG-BUFFER commands are valid only after the log buffer has been reserved for the current user through the START-PROCESS-LOG-ALL or the START-PROCESS-LOG-ONE command.

---

## Page 224

# ND-500 Monitor Error Messages

## MACRO STACK ERROR

Macro calls were too deeply nested or recursive. The problem will usually be avoided by breaking down a complicated call sequence into a simpler one, with fewer levels. If the error persists, contact Norsk Data and keep a listing of all macros in use when the error occurred.

## MACRO(S) ABORTED

A program signalled an error exit through monitor call MACROE (MCN 400), or a trap condition not handled locally occurred. The current macro, including the macro(s) calling the current one, is aborted, as if the IF-ERROR-FULL-STOP command has been executed.

## MEMORY NOT AVAILABLE FOR ND-500 SEGMENT

If an explicit request for memory allocation was issued, the request could not be satisfied. This occurs when segments are shared with ND-100 or RTCOMMON.

## ND-500 DMA ERROR

A hardware error has occurred in the DMA transfer to or from the ND-500. Consult the system supervisor; or if the error persists, call Norsk Data.

## ND-500 INTERFACE ERROR

A hardware error has occurred in the ND-100/ND-500 interface. Consult the system supervisor; or if the error persists, call Norsk Data.

## ND-500 OPEN FILE TABLE FOR DIRECT TRANSFER IS FULL

This error message is returned from the OPEN monitor call (MON 50), error code 1002B. The message indicates that the number of files opened with open mode 8 or 9, direct transfer, exceeds the maximum determined at system generation time. If there is room in the open file table for files opened with other access modi, one or more of the direct transfer files may be accessed in other modi, otherwise the number of concurrently opened files must be reduced.

## ND-500 OPEN FILE TABLE IS FULL

This error message is returned from the OPEN monitor call (MON 50), error code 1000B. The message indicates that the total number of files open exceeds the allowed maximum. The limit is a system generation parameter, and sets a limit on the number of files opened with DC access (open mode 9). For files opened with other access modes, the Sintran III limitation of 16 files still applies.

---

## Page 225

# ND-500 MONITOR ERROR MESSAGES

## ND-500 POWER FAIL

A power failure response was received from the ND-500 interface, indicating that power has not been turned on to ND-500, or some serious hardware problem has occurred.

## ND-500 RESERVED FOR SPECIAL USE

The SET-ND-500-UNAVAILABLE command has been issued. Other users will have to wait until the SET-ND-500-AVAILABLE command is issued.

## ND-500 STOPPED

The microprogram in the ND-500 is not running, and must be restarted by the system supervisor before any programs can be run.

## ND-500 TIMEOUT

The ND-500 computer does not respond to requests from ND-100. Consult the system supervisor; if the error persists, call Norsk Data.

## NO FREE PHYSICAL SEGMENT

The pool of physical segments is empty, and the job has to be run when the load on the system is lower. The number of physical segments is a system generation parameter.

## NO FREE SWAP FILE ENTRY

The Monitor has run out of table space for the swap file entries, and the job must be rerun when the load on the system is lower. The table space available is a system generation parameter.

## NO MEMORY AVAILABLE FOR ND-500 BUFFERS

There is no memory available for ND-500 buffers in memory bank 0-3 (each process needs 1K 16 bit words). Consult the system supervisor.

## NO MORE BUFFER AREA

The number of macros, breakpoints and other debug commands requiring information to be kept in memory is exceedingly large. The most common cause for this error message is a "wild" recursive macro call generating temporary macros or breakpoints. If this is not the case, some macros must be deleted by ERASE-MACRO or breaks reset by RESET-BREAKS.

---

ND-60.136.04

---

## Page 226

# ND-500 Monitor Error Messages

## No ND-500 Process Available

When an ND-500 job is submitted, a free process is allocated from a pool of available processes. This error message indicates that the pool is empty, and the job cannot start until a process is freed. The number of processes is a system generation parameter, and may be less than the number of terminals in the system, which means that not all terminals can run ND-500 jobs at the same time.

## No Page Available for the Context Block

It is impossible to allocate memory to the ND-500 context blocks and segment table. This is caused either by an error in the memory configuration or because no free memory for ND-500. This error occurs only when the ND-500 is initially started or after a reconfiguring of memory.

## No RTCCOMMON Defined

References have been made to the RTCCOMMON area, which is non-existent on the machine. NLL will not allow references to RTCCOMMON if it not defined, but a modification of the size or removal of RTCCOMMON between the time of loading and execution time will cause errors to occur. Domains with references to RTCCOMMON should under no circumstances be moved to another machine.

## No Such Command

The command is not known to the ND-500 Monitor. Check the list of available commands with the HELP command.

## No Such Command or Domain

The command specified is not known to the ND-500 Monitor, and is not found as a domain name in the description file of the current user.

## No Such Domain

A domain name specified in a RECOVER-DOMAIN command is unknown in the description file of the current user.

## No Such Macro

The macro name specified in the EXECUTE-MACRO command is not found in the list of temporary macros or as a permanent :MACR file.

---

## Page 227

# ND-500 MONITOR ERROR MESSAGES

## NO SUCH SEGMENT

An unknown segment name was specified as a parameter. If there is any doubt with regard to which segments are available, use the NLL command LIST-SEGMENT, or use the Sintran III command @LIST-FILES. (Be aware, however, that a file is not necessarily a segment file even though its type is :PSEG or :DSEG!)

## NO SWAP FILE PART AVAILABLE

The Monitor has run out of table space for swap file parts. The job will have to be rerun after the load on the swap file has decreased.

## NO WELL DEFINED PROGRAM IN MEMORY

A RUN, CONTINUE or GO command was specified before any PLACE, DEBUG-PLACE or RECOVER-DOMAIN command was executed.

## NOT EXISTING BREAKPOINT

The breakpoint number specified in RESET-BREAK is unknown to the system.

## NOT IMPLEMENTED

An attempt was made to use a feature that is not yet available in the monitor but will be implemented at a later stage.

## NOT IN SEGMENT MODE

It is not possible to switch to another LOOK-AT-command from the LOOK-AT-PHYSICAL-SEGMENT command.

## NOT REQUIRED ACCESS TO SEGMENT

One of the segments in the domain that was started or placed in memory does not have the required file system access rights. The default access will permit other users to execute the code on a program segment, but not to modify it. If the data segment is swapped from the original file, the file access of the data segment must also be set to RW (read and write) for other users to execute the domain(s) containing the segment. The access is modified through the Sintran III @SET-FILE-ACCESS command.

## NUMERIC INPUT NOT ALLOWED IN DISASSEMBLE MODE

When in a LOOK-AT-command in disassemble mode, numeric deposit cannot be done. Change to a numeric MAIN-FORMAT in order to patch numerically.

ND-60.136.04

---

## Page 228

# ND-500 MONITOR ERROR MESSAGES

## ODD BYTE ADDRESS

This error is returned from file access monitor calls, error code 1004B.

## ODD BYTECOUNT

This error is returned from file access monitor calls, error code 1005B.

## OTHER USERS ALREADY LOGGED ON N500

Some of the system supervisor commands require exclusive access to ND-500. The SET-ND-500-UNAVAILABLE command will not force a logout of the users already logged on; these must be logged out explicitly before the system supervisor commands are used.

## POWER FAIL DETECTED IN LOADING CS

A power failure occurred during the loading of the microprogram to the control store. The loading of the control store must be restarted from the beginning.

## POWER OFF

No response from ND-500. If power to the ND-500 is turned on, a hardware error has occurred and service should be called for.

## POWER UP AFTER POWER FAIL

This is an informative message to explain possible delays while the control store is being loaded and the Monitor initialized.

## RTCOMMON NOT CONTIGUOUS

The RTCOMMON area may not be fractioned when shared with an ND-500 segment. This is usually detected at load time, and if the error occurs at run time it indicates modification of RTCOMMON after the affected segment has been loaded.

## RTCOMMON SIZE DOES NOT MATCH THE ACTUAL RTCOMMON SIZE

This occurs after a PLACE-DOMAIN or RECOVER-DOMAIN (implicit or explicit), indicating that modification of RTCOMMON has been made after the linking of the domain took place. The affected segments must be reloaded and the domain relinked.

---

## Page 229

# ND-500 Monitor Error Messages

## RTCOMMON Specified in Domain

This occurs after a PLACE-DOMAIN or RECOVER-DOMAIN (implicit or explicit). In general, any modification of the size or redefinition of RTCOMMON invalidates previously loaded domains using RTCOMMON. If an attempt is made in NLL to load segments referring to RTCOMMON is a system where there is none, an error message is issued at load time.

## RTCOMMON's Physical Address Does Not Match the Physical Address of the Domain

This error message is issued at PLACE-DOMAIN or RECOVER-DOMAIN, and indicates that RTCOMMON has been modified since the domain using it was loaded. The segments containing RTCOMMON references must be reloaded and the domain relinked before the domain can be executed.

## Segment Fixed But Not Contiguously

Segments shared between the ND-100 and the ND-500 must be fixed contiguously in memory. The number indicated in the message refers to the ND-100 segment number.

## Segment Fixed in Wrong Physical Address

If an ND-500 segment is shared with more than one ND-100 segment or RTCOMMON, the physical address of the ND-100 segments cannot be modified after loading of the domain.

## Shared Segment Outside ND-500 Memory

The segment shared between ND-100 and ND-500 is placed in private ND-100 memory located below ND-500 address zero. The segment must be released and fixed in an address accessible to ND-500.

## Shared Segment Does Not Overlap ND-500 Segment

Modification of the ND-100 segment or explicit setting of load addresses may cause parts of the ND-100 segment to be located beyond the limits of the ND-500 segment. The ND-500 segment must be reloaded.

## Shared Segment Fixed, But Not Contiguously

A segment shared between ND-100 and ND-500 has been fixed scattered in memory. The segment must be unfixed and fixed in a contiguous area before the ND-500 process will run.

---

ND-60.135.04

---

## Page 230

# ND-500 Monitor Error Messages

## Segment Not Modifiable

An attempt was made to modify a segment declared as a read-only segment. Default segment attributes will make the program segment read-only, while pages in the data segment will if they are modified be copied to a swap file. This may be modified by using non-default segment attributes.

## Swap File Already Defined

The `<file name>` in the DEFINE-SWAP-FILE command is already defined as an ND-500 swap file.

## Swap File Is In Use

The DELETE-SWAP-FILE command may not be executed while an ND-500 process has its swap area allocated in the specified `<file name>`.

## Swap File Is Not Contiguous Mass Storage File

The `<file name>` in the DEFINE-SWAP-FILE command is indexed, or it is not a mass storage (disk) file.

## Swap File Not Found

The `<file name>` specified in the DELETE-SWAP-FILE command is not an ND-500 swap file, or the file name in the DEFINE-SWAP-FILE is unknown under.

## Swapping Space Not Available

A large enough continuous area for the segments requiring swap file space was not available. The job must be rerun after other jobs have released enough space to fit in the rejected segment(s).

## Too Big Bytecount

This error message is returned from file access monitor calls, error code 1006B, indicating that the specified byte count is larger than can be represented in 16 bits. This is a limitation in the ND-100 file access monitor calls, where the byte count is in number of 16 bit words, represented in a single (16 bit) integer.

## Too Big Data Segment

The sum of the start address and the length of the data segment gives an address above 77777777777 (27 bits address space).

---

## Page 231

# ND-500 MONITOR ERROR MESSAGES

## TOO BIG HISTOGRAM INTERVAL

The highest histogram interval allowed is 32767 bytes. Use a higher `<number of channels>` (if less than maximum) or a smaller range from `<start address>` to `<max address>`.

## TOO BIG PROGRAM SEGMENT

The sum of the start address and the length of the program segment gives an address above 777777777B (27 bits address space).

## TOO BIG VALUE

A numeric constant exceeding the legal range for the data type in question (e.g. a byte value >255) was entered. If it is desirable to enter the larger value, the main format should be changed to halfword or word as appropriate.

## TOO MANY SHARED AREAS

The Monitor has run out of table space to store information about segments shared between ND-100 and ND-500. The job will have to be rerun at a time when the load on the system is lower. The size of the tables is a system generation parameter.

## TOP OF STACK

While in the LOOK-AT-STACK command, the stack area was that of the currently executing procedure when the NEXT subcommand was executed.

## TRYING TO LINK TO A DEMAND SEGMENT

This occurs after PLACE-DOMAIN or RECOVER-DOMAIN. A demand segment may not be shared between ND-100 and ND-500. Normally, this is discovered at load time by NLL, but if the error occurs at run time it indicates that modifications have later been done to the ND-100 segment.

## TRYING TO LINK TO A NON-EXISTING SINTRAN III SEGMENT

This occurs when ND-500 shares a segment with ND-100 and the segment has been cleared in the ND-100 SEGFL after the loading took place. The segment must be rebuilt and the ND-500 domain reloaded/relinked.

## UNKNOWN BREAK AT nnnn

A break instruction was encountered in the program segment. Breaks used for debugging purposes must be under full control by the Monitor; i.e. they should be inserted by the BREAK or TEMPORARY-BREAK commands.

ND-60.136.04

---

## Page 232

# ND-500 Monitor Error Messages

## UNKNOWN TRAP

This indicates an error in the ND-500 micro-program. Please report to Norsk Data.

## WRONG NUMBER OF PARAMETERS IN MONITOR CALL

This error is returned from ND-500 monitor calls, error code 1015, and indicates that either excessive or insufficient parameters were transmitted.

---

## Page 233

# 15. EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

The examples shown in this chapter are relatively small and incomplete as problem solutions. The intention is to give the beginner a certain familiarity with ND-500 operation and give a general impression of the user/Monitor interface.

In the examples, abbreviations of commands are used to some degree, to show how a more experienced user will write the commands. In some cases, all parameters are supplied in the command line, in other cases NLL or the Monitor prompts for them after CR is pressed. Remember that some parameters will not be prompted for if not supplied, rather, a default value is used. User input is always _underlined_.

NLL is available both as an ND-500 program and as an ND-100 program. In most examples, the ND-500 version is used, but the user interface is exactly the same for the ND-100 version.

## 15.1. Executing an ND-500 domain

Most compilers and the loader will execute on the ND-500 and must be started through the Monitor. This can be done in two ways:

Either, the domain name may be given as a parameter to the Monitor at the time of the call. To start the compiler FORTRAN, executing in ND-500:

```
@ND-500-MONITOR FORTRAN
$ <Fortran compiler commands>
$EX
@
```

Or the monitor may be started first, after which the domain is started by typing its name:

```
@ND-500-MONITOR
N500: FORTRAN
$ <Fortran compiler commands>
$EX
N500: EX
@
```

The two methods are essentially equivalent, but if the domain name was a parameter to the Monitor, control will return to Sintran III rather than to the Monitor upon program exit. Calling the Monitor first is used mainly if other monitor commands should be given before or after the domain is executed.

In most installations, the name of the Monitor may be abbreviated and still be unambiguous. The following is a complete example of compiling a Pascal program, loading it and executing it, all programs executing in the ND-500, and the name of the Monitor is abbreviated to ND-500:

ND-60.136.04

---

## Page 234

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

```
@ND-500 PASCAL
PASCAL/ND-500 VERSION A 81-05-08
$COM PASPROG,,''PASPROG''

  NO ERRORS
  1 NON-STANDARD WARNINGS
  0.34 SECONDS COMPILATION TIME
```

```
$EX

@ND-500 LINK
ND-Linkage-Loader 81.07.14
NLL:SET-DOMAIN "PASCAL-TEST"
NLL:OP-SEGM "SEGMENT-ONE",,
NLL:LOAD PASPROG PASCAL-LIB
Program............450 P    Data:..........352 D
Program..........16644 P    Data:.........402420 D
NLL:EX
```

```
@ND-500 PASCAL-TEST

I execute, therefore I am.

I have been executed, therefore I am not.

@
```

## 15.2. Using libraries

A user may find it tiresome to specify loading of a library every time he loads a program, if that library is not specified as an auto-load library by user SYSTEM. A user may also have his own libraries; containing for example mathematical or statistical routines.

In the following example, all auto-load files are deleted in order to make sure no obsolete entries remain in the table of auto-load files. PLANC-LIB is then defined as an auto-load file for Planc programs. This would not be necessary if user SYSTEM had defined it as an auto-load file, unless the user wants to force loading of the libraries in another sequence.

For both Planc and Fortran the user's own STAT-LIB is defined as auto-load file. On this file is built a routine table by the PREPARE-NRF-LIBRARY-FILE command, in order to increase the speed of loading, and the identifying text STAT-LIB-JULY-1981 is inserted at the top of the file.

Finally, the defined auto-load files are listed, in order to confirm that the file names are correct. The version of the loader executing in the ND-500 is used, therefore the Linkage-Loader is called up through the Monitor:

```
ND-60.136.04
```

---

## Page 235

# Examples of Linkage-Loader and Monitor Usage

```
@END-500 LINKAGE-LOADER
ND-Linkage-Loader 81.07.14
NLL:DELETE-AUTO-LOAD-FILE
NLL:SET-AUTO-LOAD (SYSTEM)PLANC-LIB PLA
NLL:SET-AUTO-LOAD STAT-LIB PLA
NLL:SET-AUTO-LOAD STAT-LIB FOR
NLL:PREP-NRF-LIB STAT-LIB
NLL:INSERT-NRF-MESSA STAT-LIB,,STAT-LIB-JULY-1981$
NLL:LIST-AUTO-LOAD
(PACK-ONE-1:SYSTEM)PLANC-LIB - PLANC
(PACK-ONE-1:PROJECT)STAT-LIB - PLANC
(PACK-ONE-1:PROJECT)STAT-LIB - FORTRAN
NLL:EX
```

Now assume that the routines F22 and F23 in STAT-LIB have been recompiled to the file UPDATES. The new modules should replace the old ones in the library, and the routines should be reloaded to the domain DOMANE (without reloading the entire segment). The segment in DOMANE has the name SEG-X. The new versions of F22 and F23 use another routine in STAT-LIB that was not previously loaded, therefore STAT-LIB is automatically loaded at EXIT (which implies execution of an CLOSE-SEGMENT), and the identification of the library is printed:

```
@END-500 LINKER
ND-Linkage-Loader 81.07.14
NLL:NEW-NRF-MODULES UPDATES STAT-LIB
NLL:CC REBUILD MODULE INDEX TABLE:
NLL:PREP-NRF-LIB STAT-LIB
NLL:CC THE PREP-OPERATION DESTROYS THE MESSAGE!
NLL:INSERT-NRF-MESSA STAT-LIB,,STAT-LIB-JULY-1981$
NLL:SET-DOMAIN DOMANE
NLL:APP-SEG SEG-X,
NLL:RELOAD-SEG UPDATES
Program:..........46714 P  Data:..........73466 D
NLL:EX
```

ND-60.136.04

---

## Page 236

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

## 15.3. Using files

DOMANE accesses two files, one for random input as file number 10, another for sequential output as file number 12. The input file REC:DATA is contiguous, and the record size is 1024 bytes, thus the file may be accessed in the direct transfer open mode. The output file REPORT:LIST is an ordinary sequential file and is opened with Write access:

```
@ND-500
ND-500 MONITOR 81.05.21/81.05.15
N500:OPEN-FILE REC 10 D
N500:OPEN-FILE REPORT:LIST 12 W
N500:DOMANE
N500:EXIT
@
```

ND-60.136.04

---

## Page 237

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

## 15.4. Macros

DOMANE is executed often, always using the same output file, but with different input files. In order to reduce the number of commands required to execute the program, a macro called XQT is defined and saved as a permanent macro. When executed, it will request the input file name, but supply all other parameters automatically:

```
@ND-500
ND-500 MONITOR 81.05.21/81.05.15
N500:DEF-MAC XQT
PARAMETER INFILE,NO-DEFAULT,Input-file:
OPEN-FILE INFILE 10 D
OPEN-FILE REPORT:LIST 12 W
DOMANE
EXIT
END-MACRO
N500:DUMP-MAC XQT
N500:EX
@
```

```
@ND-500
ND-500 MONITOR 81.05.21/81.05.15
N500:XQT
Input-file=NEW
N500: OPEN-FILE NEW 10 D
N500: OPEN-FILE REPORT:LIST 12 W
N500: DOMANE
N500: EXIT

@
```

Observe that the user did not enter the commands to open the files and start the domain, but these commands are always echoed to the output device.

ND-60.136.04

---

## Page 238

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

## 15.5. Debugging

The following Planc program fragment:

```
MODULE PLCTEST
    REAL PRECISION(15) ARRAY: ARR(1:10)
    REAL PRECISION(15): TOTAL
    INTEGER ARRAY: STACK(0:100)
    INTEGER: I

    PROGRAM: SUM
    INITSTACK STACK

    DO WHILE I<10
        TOTAL+ARR(I)=: TOTAL
        I+1=: I
    ENDDO

ENDROUTINE
ENDMODULE
```

will provoke a PROTECT VIOLATION error message from the Monitor if loaded to a segment using default values. After compilation and loading to domain PLCTEST:

```
@ND-500 PLCTEST

PROTECT VIOLATION
AT PROGRAM ADDRESS 4OB

@
```

In order to catch the error, the program is placed in memory, using the DEBUG-PLACE command in order to permit modifications. Then single step execution is started, and one instruction at a time is executed by pressing CR.

```
@ND-500-MONITOR
ND-500 MONITOR 81.05.21/81.05.15
N500:DEB-PLA
DOMAIN: DOMANE
N500: STEP

P 10000000044B: INIT 00000000134B, +00000000024B, 000624B
P 10000000021B: W COMP2 0000000760B, 12B
P 10000000030B: IF >= G0 0482-→01000000072B
P 10000000032B: D1:= 00000000124B
P 10000000040B: W1:= 00000000760B
P 10000000046B: D1 + 37777777774B(W1)
```

PROTECT VIOLATION  
AT PROGRAM ADDRESS 40B

N500:

---

ND-60.136.04

---

## Page 239

# Examples of Linkage-Loader and Monitor Usage

Obviously, something went wrong when access to an array element was attempted. The index value was loaded from address 760, and this value is inspected:

## N500: Look-at-Data
**Address:** 760  
D 760B: 0B EX

A base address of 37777777774B and a displacement of 0 will generate an access to a negative segment address. This is certainly not legal, as we then "overflow" into another segment (in our case, a non-existing one). The intention was to let the index variable run from 1 to 10, rather than from 0 to 9, and we therefore deposit the initial value 1 (old initial value: 0) in location 760, and we modify the upper limit of the test from 12B to 13B:

## N500: Look--Data 760

| D 000000760B | 0 | PERMIT-DEP |
|--------------|---|------------|
| D 00000760B  | 0 | 1          |
| D 00000764B  | 0 | EX,,       |

## N500: Look--Prog 21

| P 10000000021B: W COMP2 00000000760B, 12B PER |
|-----------------------------------------------|
| P 10000000021B: W COMP2 00000000760B, 12B BYTE|
| P 10000000021B: 56B                           |
| P 10000000022B: 304B                          |
| P 10000000023B: 0B                            |
| P 10000000024B: 0B                            |
| P 10000000025B: 1B                            |
| P 10000000026B: 360B                          |
| P 10000000027B: 12B 13                        |
| P 100000000303: 314B EX                       |

N500:

Now, the modified version of DOMANE in memory may be started by a RUN command.

## N500: Run

N500: EX

@  

ND-60.136.04

---

## Page 240

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

## 15.6. System Supervisor: Installing NLL

The first time NLL is installed, user SYSTEM should define auto-link segments to be used if a user attempts to close a segment while undefined references exist. Usually, the run time libraries for different languages are loaded to a segment named LIBRARY-DOMAIN, but if an installation makes heavy use of other special libraries, for example a collection of mathematical or statistical functions, it may be convenient to load even this library to the library segment.

Different run time libraries may be loaded to different segments, but as long as no symbol conflicts occur, they may all be put on the same segment. This will reduce the probability of segment number conflicts.

When a library segment is created, all traps should be locally disabled, in order to inhibit the automatic allocation of a trap handler vector.

Because default segment numbers grow from low to high, autolink segments should preferably be numbered from above. The system supervisor may also choose to define the :NRF files as library files. If, for example, a user defined auto-load file (loaded after the linking has been performed) makes further references to a standard library, the reference will be defined by the automatically loaded files.

If an entered command is not in the command list, is not the name of a domain belonging to the user issuing the command, and is not the name of a temporary or permanent macro, the domains of user SYSTEM will be searched. ND-500 systems such as compilers running on the ND-500 and the ND-500 version of NLL is usually a domain belonging to SYSTEM. Such systems are delivered either as a domain that should be copied by COPY-DOMAIN, or as an NRF file that should be loaded like another program. The example below shows how PASCAL is loaded.

In order to speed the search for a compiler or other standard system, all such domains owned by SYSTEM should also be defined as standard-domains.

```
@ND-500 LINKAGE-LOADER
ND Linkage-Loader 80.05.18
NLL: SET-AUTO-LOAD (SYSTEM)FORTRAN-LIB FORTRAN
* The 'DESCRIPTION-FILE' will now be initialized
NLL: SET-DOMAIN "LIBRARY-DOMAIN"
NLL: SET-SEGMENT-NUMBER 29
NLL: OPEN-SEGMENT "PLANC-LIB", P
NLL: LOCAL-TRAP-DISABLE ALL
NLL: ENTRY-ROUTINES 400
NLL: TOTAL-SEGMENT-LOAD PLANC-LIB
NLL: SET-SEGMENT-NUMBER 30
NLL: OPEN-SEGMENT "FORTRAN-LIB", P
NLL: LOCAL-TRAP-DISABLE ALL
NLL: ENTRY-ROUTINES 500
NLL: SET-IO-BUFFERS 16
```

ND-60.136.04

---

## Page 241

# Examples of Linkage-Loader and Monitor Usage

NLL: TOTAL-SEGMENT-LOAD FORTRAN-LIB  
NLL: SET-AUTO-LOAD (SYSTEM)PLANC-LIB PLANC  
NLL: SET-AUTO-LOAD (SYSTEM)NAG FORTRAN  
NLL: END-DOMAIN  
NLL: PREPARE-NRF-LIBRARY: NAG  
NLL: SET-AUTO-LINK FORTRAN-LIB FORTRAN  
NLL: SET-AUTO-LINK PLANC-LIB PLANC  
NLL: SET-DOMAIN LINKAGE-LOADER  
NLL: APPEND-SEGMENT LINKAGE-LOADER,,  
NLL: LIBRARY-SEGMENT-LINK (SYS) FORTRAN-LIB, PLANC-LIB  
% Additional defined AUTO-LINK segments used by the command RUN.  
NLL: END-DOMAIN  
NLL: EXIT  

The System supervisor should also ensure that all terminals that will be using ND-500 systems have a 128 Kw background segment. This can be charged by the Sintran III command

```
@CHANGE-BACKGROUND-SEGMENT-SIZE <term no.> 128
```

`<term no.>` can be found by the `@WHO` command. The segment size information is lost after a "cold start" (`)HENT / 22!`), but the command to change it may be included in the HENT-MODE file.

If the installation runs the accounting system, the `@START-ACCOUNTING` command may be used to log ND-100 and ND-500 CPU time, terminal time, mass storage transfers and number of spooling pages printed. The last parameter of the command, `<ND-500>` is used in ND-500 systems only, and is answered with Y if resources used by ND-500 should be logged, N otherwise.

---

## Page 242

# Examples of Linkage-Loader and Monitor Usage

## 15.7. List of Monitor Commands

This section lists all the monitor commands which appear in the "help-list".

```
| Command                                 |
|-----------------------------------------|
| ABORT-BATCH-ON-ERROR <ON/OFF>           |
| ABORT-PROCESS <NO>                      |
| ATTACH-PROCESS <PROCESS NO>             |
| AUTOMATIC-ERROR-MESSAGE                 |
| BRANCH-TRACE <START>,<MIN TRACE>,<MAX TRACE> |
| BREAK <ADDRESS>,[<COUNT>]               |
| CACHE-MODE <PROGRAM CACHE MODE>,<DATA CACHE MODE> |
| CALL-TRACE <START>,<MIN TRACE>,<MAX TRACE> |
| CC                                      |
| CLOSE-FILE <CONNECT NUMBER>             |
| COMPARE-CONTROL-STORE <FILE NAME>,<START ADDRESS>,<NO. OF WORDS>,<MAX NO. OF FAULTS> |
| CONTINUE                                |
| DEBUG-PLACE <DOMAIN>                    |
| DEBUG-STATUS                            |
| DEBUGGER [<DOMAIN>]                     |
| DEF-INE-MACRO <NAME>                    |
| DEFINE-MEMORY-CONFIGURATION <N100 PAGE NO FOR N500C PHYS. ADR. ZERO> |
| DEFINE-STANDARD-DOMAIN <STANDARD DOMAIN NAME>,<DOMAIN NAME> |
| DEFINE-SWAP-FILE <NAME>                 |
| DELETE-STANDARD-DOMAIN <NAME>           |
| DELETE-SWAP-FILE <NAME>                 |
| DUMP-MACRO <NAME>                       |
| ENABLED-TRAPS                           |
| ERASE-MACRO <NAMES>                     |
| EXECUTE-MACRO <NAME>,{<PARAMETERS>}     |
| EXHIBIT-ADDRESS <ADDRESS IN PROGRAM>,<ADDRESS OF VARIABLE>,<DATATYPE> |
| EXIT                                    |
| EXTRA-FORMAT <FORMAT>                   |
| FIX-SEGMENT-ABSOLUTE <SEGMENT NUMBER>,<TYPE(P OR D)>,<L ADR>,<H ADR>,<PH SP> |
| FIX-SEGMENT-CONTIGUOUS <SEGMENT NUMBER>,<TYPE(P OR D)>,<LOW ADDRESS>,<HIGH ADDRESS> |
| FIX-SEGMENT-SCATTERED <SEGMENT NUMBER>,<TYPE(P OR D)>,<LOW ADDRESS>,<HIGH ADDRESS> |
| GET-FLAG <PROCESS NUMBER>               |
| GIVE-ND-500-PAGES <NO. OF PAGES>        |
| GO <ADDRESS>                            |
| GUARD <ADDRESS>,<DATATYPE>,[<LIMITS>]   |
| HELP <COMMAND>                          |
| LIST-ACTIVE-PROCESSES                   |
| LIST-ACTIVE-SEGMENTS <PROCESS NO>       |
| LIST-DOMAIN <DOMAIN NAME>               |
| LIST-EXECUTION-QUEUE <INTERVAL>         |
| LIST-MACRO <NAMES>                      |
| LIST-OPEN-FILES                         |
| LIST-PROCESS-TABLE-ENTRY <PROCESS NO>   |
| LIST-SEGMENT-TABLE-ENTRY <PHYSICAL SEGMENT NO> |
| LIST-STANDARD-DOMAINS                   |
| LIST-SWAP-FILE-INFO <SWAP FILE NO>      |
| LIST-SYSTEM-PARAMETERS                  |
| LIST-TABLE <NAME>                       |
| LOAD-CONTROL-STORE <FILE NAME>,<START ADDRESS>,<NO. OF WORDS> |
```

ND-60.136.04

---

## Page 243

# Examples of Linkage-Loader and Monitor Usage

- **LOAD-SWAPPER** `<FILE NAME>`
- **LOCAL-TRAP-DISABLE** `<TRAP CONDITION>`
- **LOCAL-TRAP-ENABLE** `<LABEL>,<TRAP CONDITION>`
- **LOGOUT-PROCESS** `<NO>`
- **LOOK-AT-CONTROL-STORE** `<ADDRESS>`
- **LOOK-AT-DATA** `<ADDRESS>,[<DOMAIN>]`
- **LOOK-AT-FILE** `<ADDRESS>,<FILE NAME>`
- **LOOK-AT-HARDWARE** `<REGISTER NAME>`
- **LOOK-AT-PHYSICAL-SEGMENT** `<ADDRESS>,<SEGMENT NO>`
- **LOOK-AT-PROGRAM** `<ADDRESS>,[<DOMAIN>]`
- **LOOK-AT-REGISTER** `<X>`
- **LOOK-AT-RELATIVE** `<RELATIVE TO>`
- **LOOK-AT-RESIDENT-MEMORY** `<ADDRESS>`
- **LOOK-AT-STACK**
- **MAIN-FORMAT** `<FORMAT>`
- **MASTER-CLEAR**
- **MEMORY-CONFIGURATION**
- **MICRO-START** `<ADDRESS>`
- **MICRO-STOP**
- **OPEN-FILE** `<FILE NAME>,<CONNECT FILE NUMBER>,<ACCESS>`
- **OUTPUT-FILE** `<NAME>`
- **PLACE-DOMAIN** `<DOMAIN>`
- **PRINT-HISTOGRAM**
- **PRINT-MONCALL-LOG**
- **PRINT-PROCESS-LOG** `<FIRST PROCESS>`
- **PROCESS-LOG-ALL** `<INTERVAL>,<FIRST PROCESS>`
- **PROCESS-LOG-ONE** `<PROCESS NO>,<INTERVAL>`
- **PROCESS-STATUS**
- **RECOVER-DOMAIN** `<DOMAIN>`
- **RELEASE-HISTOGRAM**
- **RELEASE-LOG-BUFFER**
- **RESET-AUTOMATIC-ERROR-MESSAGE**
- **RESET-BRANCH-TRACE**
- **RESET-BREAKS** `[BREAK NUMBER]`
- **RESET-CALL-TRACE**
- **RESET-DEBUG**
- **RESET-GUARD**
- **RESET-LAST-BREAK**
- **RESET-TRACE**
- **RESIDENT-PLACE** `<DOMAIN>`
- **RESTART-PROCESS** `<PROCESS NAME>`
- **RESUME-MACRO**
- **RUN**
- **SET-BLOCK-SIZE** `<FILE NUMBER>,<SIZE(IN BYTES)>`
- **SET-FLAG** `<PROCESS NUMBER>,<VALUE>`
- **SET-HISTOGRAM** `<START ADDRESS>,<MAX ADDRESS>,<NO. OF INTERVALS>`
- **SET-MEMORY-CONTENTS** `<FROM ADDRESS>,<UP TO ADDRESS>,<VALUE>,<DATATYPE>`
- **SET-ND-500-AVAILABLE**
- **SET-ND-500-UNAVAILABLE**
- **SET-PRIORITY** `ND-100 MON. CALL PRTY.>,<MAX.% ND-100 CPU TIME>,<ND-500 PRTY.>,[<PROCESS NO.>]`
- **SET-PROCESS-NAME** `<NAME>`
- **SET-SEGMENT-LIMITS** `<SEGMENT NUMBER>,<TYPE>,<MIN NO. OF PAGES>,<MAX NO. OF PAGES>,[<PROCESS NO>]`
- **SET-SYSTEM-PARAMETERS** `<NO. OF PHYSICAL SEGMENTS><MAXM. NO. PAGES FIXED>`
- **SPECIAL-DEBUGGER** `<FILE NAME>,<LOGICAL SEGMENT NUMBER>,[<DOMAIN>]`
- **START-HISTOGRAM**
- **START-MONCALL-LOG** `<OWN/ALL>`
- **START-PROCESS-LOG-ALL**

ND-60.136.04

---

## Page 244

# Examples of Linkage-Loader and Monitor Usage

```
START-PROCESS-LOG-ONE <PROCESS NO>
START-SWAPPER
STATUS
STEP [<FROM ADDRESS>, [START ADDRESS], [COUNT>)]
STOP-HISTOGRAM
STOP-MONCALL-LOG
STOP-ND-500
STOP-ND-500
SWAPPING-LOG (<INTERVAL>)
SYSTEM-TRAP-DISABLE <TRAP CONDITION>
SYSTEM-TRAP-ENABLE <TRAP CONDITION>
TAKE-ND-500-PAGES <NO. OF PAGES>
TEMPORARY-BREAK <ADDRESS>,{<COUNT>} 
TIME-USED
TRACE <ADDRESS>,[<DATATYPE>]
UNFIX-SEGMENT <SEGMENT NUMBER>,<TYPE (P OR D)>
VALUE-ENTRIES <ENTRIES>
VERSION
WHO-IS-ON
```

---

## Page 245

# EXAMPLES OF LINKAGE-LOADER AND MONITOR USAGE

## 15.8. LIST OF LINKAGE-LOADER COMMANDS

This section lists all the linkage-loader commands which appear in the "help-list".

- ABORT-BATCH-ON-ERROR `<ON/OFF>`
- APPEND-NRF-MODULE `<SOURCE-FILE>,<DESTINATION-FILE>,<AFTER-MODULE>`
- APPEND-SEGMENT `<SEGMENT-NAME>,<SEGMENT-ATTRIBUTES>`
- CC
- CHECK-SYNTAX-MODE
- CLEAR-DOMAIN `<DOMAIN-NAME>`
- CLEAR-SEGMENT `<SEGMENT-NAME>`
- CLOSE-SEGMENT `[<X>]`
- COMMON-SEGMENT-APPEND `<SEGMENT-NAME>`
- COMMON-SEGMENT-CLOSE
- COMMON-SEGMENT-NUMBER `<SEGMENT-NUMBER>`
- COMMON-SEGMENT-OPEN `<SEGMENT-NAME>,<SEGMENT-ATTRIBUTES>`
- COMPUTER-MODE `<COMPUTER-TYPE(100/500/PIOC)>,[<X>]`
- COPY-DOMAIN `<SOURCE-DOMAIN>,<DESTINATION-DOMAIN>`
- DATA-REFERENCE `<NAME>,<ADDRESS>,<P/D>`
- DEFINE-COMMON `<NAME>,<COMMON-SIZE>,<VALUE>`
- DEFINE-ENTRY `<ENTRY>,<VALUE>,<P/D>`
- DEFINE-SEGMENT-SIZE `<PROGRAM-SEGMENT(BYTES)>,<DATA-SEGMENT(BYTES)>`
- DELETE-AUTO-LINK-SEGMENT
- DELETE-AUTO-LOAD-FILE
- DELETE-DOMAIN `<DOMAIN-NAME>`
- DELETE-NRF-MODULES `<FILE>,<FIRST-MODULE>,<LAST-MODULE>`
- DELETE-SEGMENT `<SEGMENT-NAME>`
- DELETE-SUBPROCESS `<PROCESS-NAME>`
- DISASSEMBLE-MODE
- END-DOMAIN
- ENTRY-ROUTINES `<NUMBER-OF-ROUTINES>`
- EXIT
- FETCH-NRF-MODULES `<SOURCE-FILE>,<DESTINATION-FILE>,<FIRST-MODULE>,<LAST-MODULE>`
- FIX-SEGMENT-ABSOLUTE `<SEGMENT-NAME>,<P/D>,<PHYSICAL-ADDRESS>,<L-A>,<U-A>`
- FIX-SEGMENT-CONTIGUOUS `<SEGMENT-NAME>,<P/D>,<LOW-ADDRESS>,<UPPER-ADDRESS>`
- FIX-SEGMENT-SCATTERED `<SEGMENT-NAME>,<P/D>,<LOW-ADDRESS>,<UPPER-ADDRESS>`
- FORCE-SEGMENT-LINK `<SEGMENT-NAME>`
- GLOBAL-ENTRIES `<ENTRIES>`
- HELP `<COMMAND>`
- HIGH-ADDRESS `<ADDRESS>,<P/D/C>`
- INSERT-NRF-MESSAGE `<FILE-NAME>,<BEFORE-MODULE>,<MESSAGE>`
- KILL-ENTRIES `<ENTRIES>`
- LIBRARY-SEGMENT-LINK `<SEGMENT-NAME>`
- LIBRARY-SEGMENT-LOAD `<FILE-NAME>`
- LINK-RT-PROGRAM
- LINK-SEGMENT `<SEGMENT-NAME>`
- LIST-AUTO-LINK-SEGMENTS
- LIST-AUTO-LOAD-FILE
- LIST-DOMAIN `<DOMAIN-NAME>`
- LIST-ENTRIES-DEFINED `[<X>]`
- LIST-ENTRIES-UNDEFINED `[<X>]`
- LIST-MAP
- LIST-MODE
- LIST-NRF-CODE `<SOURCE-FILE>,<FIRST-MODULE>,<LAST-MODULE>`

ND-60.136.04

---

## Page 246

# Examples of Linkage-Loader and Monitor Usage

- LIST-NRF-ENTRIES `<FILE-NAME>`
- LIST-OCTAL `<LOWER-ADDRESS>,<UPPER-ADDRESS>,<P/D>`
- LIST-SEGMENT `<DOMAIN-NAME>,<SEGMENT-NAME>`
- LIST-SYMBOLIC `<LOWER-ADDRESS>,<UPPER-ADDRESS>,<P/D>`
- LOAD-SEGMENT `<FILE-NAME>`
- LOCAL-TRAP-DISABLE `<TRAP-CONDITION>`
- LOCAL-TRAP-ENABLE `<LABEL>,<TRAP-CONDITION>`
- LOW-ADDRESS `<ADDRESS>,<P/D/C>`
- MATCH-COMMON-RI-SEGMENT `<SEGMENT-NUMBER>`
- MATCH-RTCOMMON
- NEW-NRF-MODULES `<NEW-MODULE-FILE>,<FILE>`
- OMITTED-SEGMENT-LOAD `<FILE-NAME>,<ENTRIES>`
- OPEN-SEGMENT `<SEGMENT-NAME>,<SGMENT-ATTRIBUTES>`
- OUTPUT-FILE `<FILE-NAME>`
- PAGE-MODE `[<>]`
- PREPARE-NRF-LIBRARY-FILE `<LIBRARY-FILE-NAME>`
- PROGRAM-REFERENCE `<ENTRY>,<ADDRESS>,<P/D>`
- RELEASE-DOMAIN `<DOMAIN-NAME>`
- RELOAD-SEGMENT `<FILE-NAME>`
- RENAME-DEFAULT-DIRECTORY-AND-USER `<<NEW-DIRECTORY:NEW-USER>>`
- RENAME-DOMAIN `<OLD-DOMAIN-NAME>,<NEW-DOMAIN-NAME>`
- RENAME-SEGMENT `<OLD-SEGMENT-NAME>,<NEW-SEGMENT-NAME>`
- RESET
- RUN `[<>]`
- SELECTED-SEGMENT-LOAD `<FILE-NAME>,<ENTRIES>`
- SET-AUTO-LINK-SEGMENT `<SEGMENT-NAME>,<LANGUAGE>`
- SET-AUTO-LOAD-FILE `<FILE-NAME>,<LANGUAGE>`
- SET-DOMAIN `<DOMAIN-NAME>`
- SET-IO-BUFFERS `<NO. OF BUFFERS>`
- SET-MONITOR-NAME `<MONITOR-NAME>`
- SET-SEGMENT-LIMITS `<SEGMENT-NAME>,<P/D>,<MINIMUM>,<MAXIMUM>`
- SET-SEGMENT-NUMBER `<SEGMENT-NUMBER>`
- SET-SUBPROCESS `<SUB-PROCESS NAME>,<PRIVILEGES>`
- SUPPRESS-DEBUG-INFORMATION `<ON/OFF>`
- SYSTEM-ENTRIES-ON
- SYSTEM-TRAP-DISABLE `<TRAP-CONDITION>`
- SYSTEM-TRAP-ENABLE `<TRAP-CONDITION>`
- TOTAL-SEGMENT-LOAD `<FILE-NAME>`
- VALUE-ENTRIES `<ENTRIES>`
- WRITE-DOMAIN-STATUS `[<>]`
- WRITE-NRF-EOF-AFTER-MODULE `<FILE>,<AFTER-MODULE>`
- WRITE-SEGMENT-STATUS `[<>]`

ND-60.136.04

---

## Page 247

I'm sorry, I cannot process the request as the page does not contain any recognizable text content to convert.

---

## Page 248

# Index

## A

| Topic                             | Page(s)     |
|-----------------------------------|-------------|
| abbreviating command              | 202         |
| abbreviating segment name         | 199         |
| abbreviation command name         | 9, 108, 110 |
| abbreviation domain name          | 193         |
| ABORT-BATCH-ON-ERROR command      |             |
| description                       | 88          |
| aborting batch job                | 88          |
| aborting macro                    | 108, 110, 203 |
| ABORT-PROCESS command             |             |
| description                       | 159         |
| absolute allocation               | 147         |
| absolute fixing                   | 42, 141     |
| ABSTR monitor                     | 104         |
| ABSTR monitor call                | 105         |
| access conflicts                  | 197         |
| access link                       | 11          |
| access mode                       | 198         |
| access right                      | 98          |
| active process                    | 17          |
| active users                      | 130, 159    |
| actual parameter                  | 149, 151    |
| ADA, NRF control number           | 107, 109    |
| add                               | 188         |
| data address                      | 188         |
| immediately                       | 188         |
| program address                   | 188         |
| adding code to segment            | 53          |
| additional data segment           | 61          |
| address alignment                 | 186         |
| address overlap                   | 152         |
| address range                     | 15          |
| address table                     | 84, 85, 189 |
| address translation               | 200         |
| addressing space                  | 72, 137, 140|
| ADDRESS-TRAP-FETCH                | 12          |
| ADDRESS-TRAP-READ                 | 89          |

---

## Page 249

# Index

ADDRESS-TRAP-WRITE  
... 89.

ADDRESS-ZERO-ACCESS  
... 89.

ADI, NRF control number  
... 188.

adjust  
... 188.

administrating memory  
... 153.

AJS, NRF control number  
... 188.

allocation in memory  
... 137.

alphanumeric label  
... 12.

ambiguous  

| | |
|---|---|
| command | 193. |
| domain name | 197. |
| label name | 13. |
| segment name | 197. |

APA, NRF control number  
... 188.

appending NRF module  
... 82.

APPEND-NRF-MODULES command  

| | |
|---|---|
| description | 82. |

APPEND-SEGMENT command  

| | |
|---|---|
| description | 53. |
| reference | 49, 57, 196, 198-200. |

architecture  
... 15.

ASCII  

| | |
|---|---|
| characters | 116. |
| format | 185. |

assembler  
... 63, 65.

assembling library  
... 59, 85.

Assembly  
... 186.

at, commercial (å)  
... 87.

ATTACH-PROCESS command  

| | |
|---|---|
| description | 159. |
| attribute code | 195, 198. |

attributes  
... 49, 53, 61.

auto link segment  
... 63-65.

auto load file  
... 51, 65, 66, 196.

automatic  

| | |
|---|---|
| allocation | 137. |
| fixing | 43, 104. |

AUTOMATIC-ERROR-MESSAGE command  

| | |
|---|---|
| description | 148. |
| reference | 148, 168. |

---

B B B B B B B B B B B B B B B B B B B B B B B B B B B

batch  

| | |
|---|---|
| job | 9, 51, 78, 88. |
| process | 198. |

BCD-OVERFLOW trap  
... 89.

BEG  

| | |
|---|---|
| control | 186. |
| NRF control number | 81, 185. |

block  

| | |
|---|---|
| address | 104, 202. |
| size | 104. |

---

## Page 250

# Index

body of macro .............................. 107, 110.  
BRANCH-TRACE command  
description .............................. 123.  
reference ................................ 126.  
BRANCH-TRAP .................................. 89.  
break, escape .............................. 199.  
BREAK command  
description ................................ 113.  
number ..................................... 125.  
reference ............................. 114, 125, 216.  
...................................... 93, 95, 113, 114, 124, 203, 208, 216.  
BREAK-POINT-INSTRUCTION-TRAP ............... 89.  
BRF format ................................. 72.  
buffer histogram ........................... 127.  
buffer space autoload file .................. 196.  
byte  
format ..................................... 121.  
parameter .................................. 167.  
pointer ............................. 186, 188, 203.  

---

C C C C C C C C C C C C C C C C C C C C C C C C  

cache ........................................ 17, 18.  
call  
instruction ............................... 167.  
mechanism ................................... 22.  
called routine .............................. 119.  
CALLG instruction ........................... 167.  
calling routine ............................. 119.  
CALL-TRACE command  
description ................................ 123.  
reference .................................. 126.  
CALL-TRAP .................................... 89.  
capability ............................... 17, 49.  
indirect .................................... 147.  
cataloged file .............................. 19.  
CC description ............................... 88.  
CGR0, NRF control number .................... 189.  
CGR1, NRF control number .................... 189.  
characters legal in names ................... 195.  
checksum ............................... 186, 193.  
CHECK-SYNTAX-MODE command  
description .................................. 78.  
child, trap enable ...................... 93, 124.  
cleaning  
interval .................................... 165.  
segment ..................................... 165.  
CLEAR-DOMAIN command  
description .................................. 45.  
reference .................................... 45.  
clearing  
histogram buffer ......................... 127, 128.  
process log buffer ....................... 130, 131.

---

## Page 251

# Index

## CLEAR-SEGMENT Command
- description ................................................ 54.

## Clock
- time ........................................................ 148.

## Close
- segment .................................................... 48.

## CLOSE-FILE Command
- description ................................................ 99.

## CLOSE-SEGMENT Command
- description ................................................ 51.
- implicit ................................................. 45, 88.
- reference ................................... 46, 55, 63, 65, 196, 199.

## Closing
- file ........................................................ 95.

## COBOL
- ......................................................... 63, 65, 186.

## Command
- ............................................................... 9, 109.
- abbreviation .......................................... 193, 202.
- input file ................................................... 9.
- list ......................................................... 86.
- output file ................................................... 9.
- syntax ...................................................... 78.
- terminator ................................................... 9.

## Comment
- .............................................................. 88.

## Commercial at (@)
- .............................................................. 87.

## Common

| Block   | Label | Segment                               |
|---------|-------|---------------------------------------|
| 61, 62, 69, 146. | 72.   | 53, 54, 57, 61, 62, 74, 75.       |

## COMMON-SEGMENT-APPEND Command
- description ................................................ 62.
- reference .................................. 53, 57, 61, 62, 199.

## COMMON-SEGMENT-CLOSE Command
- description ................................................ 62.

## COMMON-SEGMENT-NUMBER Command
- description ................................................ 62.

## COMMON-SEGMENT-OPEN Command
- description ................................................ 61.
- reference ............................. 57, 61, 62, 74, 195, 199.

## Communication
- ........................................... 16, 18, 41, 72, 73, 135, 137, 141, 216.
- device ....................................................... 9, 87.
- ND-100 ................................. 135, 194, 204, 211, 213, 214, 216.
- process ........................................................ 16.

## COMND Monitor Call
- .............................................................. 87.

## COMPARE-CONTROL STORE Command
- description ................................................ 156.

## Compilation
- error ...................................................... 195.
- errors ..................................................... 188.

## Compiling Library
- ..................................................... 59, 85.

## Compound
- group ....................................................... 189.
- NRF group ................................................... 188.

---

## Page 252

# Index

## conditional loading
85, 187, 189

## configuration, memory
152

## connecting file
98

## contiguous
- **allocation**  
  146, 147
- **file**  
  15, 104, 162, 205, 215
- **fixing**  
  140

## CONTINUE command
- **description**  
  95
- **reference**  
  114, 212

## control
- **byte**  
  185
- **characters**  
  185
- **number**  
  185, 195
- **store**  
  155, 156, 203, 213

## control number mnemonic
83

## COPY-DOMAIN command
- **description**  
  47
- **reference**  
  72, 73

## copying
- **domain**  
  211
- **program segment**  
  113

## CPU
- **time**  
  148, 150
- **usage**  
  130, 131

## crash system
48

## create user
47

## creating segment
47, 50

## CTE register
93, 124

## current
- **byte pointer**  
  187, 188
- **data location counter**  
  67
- **data segment**  
  62
- **domain**  
  17, 44-46, 49, 57

- **load address**  
  69, 74, 75
- **program location counter**  
  67, 95, 115
- **segment**  
  49-51, 55, 57, 146, 147
- **user**  
  44-46, 55, 63, 93, 194, 198

---

## D
- data
  - **address**  
    124
  - **byte pointer**  
    186, 188
  - **channel**  
    152
  - **exchange**  
    141, 141
  - **file**  
    10
  - **memory**  
    118, 120, 167
  - **mode**  
    61, 187, 188

---

## Page 253

# Index

## Segment
- 12, 15, 49, 57, 62, 67-69, 74, 75, 118, 146, 162, 194, 206, 215.

## Transfer
- 18.

## Transmission
- 41.

## Data Address, Add
- 188.

## Data Label
| Definition | Reference |
|------------|-----------|
| 187.       | 187.      |

## DATA-REFERENCE Command
| Description |
|-------------|
| 68.         |

## DBG, NRF Control Number
- 189.

## DCLC (Data Current Location Counter)
| Number   | 67, 186.         |

## DDF, NRF Control Number
| Number   | 81, 83, 187.     |

## Debug Information
- 12, 189.

## Debugger
- 15.

## Debugging
- 112, 125, 159, 203, 208.

## DEBUG-PLACE Command
| Description | Reference |
|-------------|-----------|
| 113.        | 212.      |

## DEBUG-STATUS Command
| Description |
|-------------|
| 124.        |

## Decimal
| Format      | Number |
|-------------|--------|
| 120, 121, 151. | 67.   |

## DEF, NRF Control Number
- 81, 83, 187.

## Default
| Attributes   | 57.          |
| Directory    | 47.          |
| Domain Name  | 12, 44, 46.  |
| Flag Values  | 135.         |
| Macro Parameter | 107, 109. |
| Main Format  | 120.         |
| Memory Allocation | 86.      |
| Segment Name | 12, 57, 62, 146, 147. |
| Segment Number | 54.        |
| Trap Handler | 22, 86.      |
| Value        | 9.           |

## Define Label
- 12.

## DEFINE-COMMON Command
| Description | Reference |
|-------------|-----------|
| 69.         | 61.        |

## Defined
| Entry       | Symbol |
|-------------|--------|
| 70.         | 67, 91, 146, 147, 187. |

## DEFINE-ENTRY Command
| Description | Reference |
|-------------|-----------|
| 68.         | 61.        |

## DEFINE-MACRO Command
| Description | Reference |
|-------------|-----------|
| 107.        | 109.      |

---

## Page 254

# Index

## DEFINE-MEMORY-CONFIGURATION command
- description .......................... 152.
- reference ............................ 204.

## DEFINE-SWAP-FILE command
- description .......................... 162.
- reference ............................ 162, 215.

## defining common block
- ...................................... 61.

## definition
- ...................................... 58, 59, 83.

## delete
- access ............................... 197.
- segment .............................. 45.

## DELETE-AUTO-LINK-SEGMENT command
- description .......................... 64.
- reference ............................ 63.

## DELETE-AUTO-LOAD-FILE command
- description .......................... 66.
- reference ............................ 65.

## DELETE-DOMAIN command
- description .......................... 45.

## DELETE-NRF-MODULES command
- description .......................... 82.

## DELETE-SEGMENT command
- description .......................... 54.

## DELETE-SWAP-FILE command
- description .......................... 162.
- reference ............................ 215.

## deleting macro
- ...................................... 110.

## demand
- paging ............................... 137.
- segment .............................. 216.

## description file
- ...................................... 46-48, 93, 181, 194, 196.

## NRF
- description file, inconsistency ...... 185.

## DESCRIPTION=FILE:DESC
- ...................................... 11, 15.

## descriptor
- ...................................... 167.

## DESCRIPTOR-RANGE trap
- ...................................... 89.

## destination
- domain ............................... 47.
- file .................................. 62.

## destroying I1 register content
- ...................................... 167.

## difference, physical address
- ...................................... 152.

## direct
- segment ............................... 16, 17.
- transfer .............................. 43, 98, 104, 105, 137, 140, 165, 202, 203, 205, 206, 209, 213.

## directory
- default ............................... 47.
- name ................................. 44.

## DISABLE-PROCESS-SWITCH-ERROR trap
- ....................................... 89.

## DISABLE-PROCESS-SWITCH-TIMEOUT trap
- ....................................... 89.

## disabling trap
- ....................................... 22.

## disassemble
- ...................................... 115, 212.

## disassembled listing
- ...................................... 77, 83.

---

## Page 255

# Index

## DISASSEMBLE-MODE command
- description .................................... 77.
- disconnecting file ............................. 99.

## disk
- access ......................................... 202.
- file ........................................... 215.
- pack ........................................... 47.

## display
- control store .................................. 156.
- hardware register .............................. 158.
- microprogram ................................... 156.

## DIVIDE-BY-ZERO trap
- ................................................ 89.

## DMA
- ................................................ 105.
- operation ...................................... 140, 209.

## DMO, NRF control number
- ................................................ 61, 186, 188.

## domain
- ................................................ 12, 15, 44, 109, 196.
- current ........................................ 45.
- destination .................................... 47.
- entry .......................................... 11, 46, 181, 182.

## execution
- ................................................ 93.

## information
- ................................................ 46.

## name
- ................................................ 10, 15, 44-46, 48, 55, 93, 113, 118, 197, 206, 211.

## new
- ................................................ 194.

## number
- ................................................ 15, 50, 181.

## source
- ................................................ 47.

## transportation
- ................................................ 42.

## double
- definition ..................................... 59.
- quote .......................................... 194, 195, 206.
- quotes ......................................... 10, 44, 49, 198.

## double float format
- ................................................ 121.

## DRF, NRF control number
- ................................................ 187.

## DSEG
- ................................................ 10, 15.
- file ........................................... 212.

## DUMP-MACRO command
- description .................................... 110.

---

E E E E E E E E E E E E E E E E E E E E E E E E E

## EDIT subcommand
- description .................................... 157.

### elapsed
- clock time ..................................... 148.
- CPU time ....................................... 148.

## empty parameter
- ................................................ 107.

## ENABLED-TRAPS command
- description .................................... 124.
- enabling trap .................................. 22, 90.

## END
- NRF control number ............................. 81, 193.
- of file ........................................ 188.

---

## Page 256

# Index

## END-DOMAIN command
- description ................................ 45.
- implicit .................................... 44, 45, 88.
- reference .................................. 46, 54, 199.

## END-MACRO command
- description ................................ 107.
- end of NRF file ............................. 84.

## ENTRY-ROUTINES command
- description ................................ 75.
- reference .................................. 198, 200.

## EOF
- control byte ............................... 188.
- NRF control number ......................... 84.

## ERASE-MACRO command
- description ................................ 110.
- reference .................................. 210.

## ERMSG monitor call
- ............................................ 103, 148, 168.

## error
- ............................................ 22, 148, 88.
- code ....................................... 22, 102, 167.
- compilation ................................ 188, 195.
- condition .................................. 21.
- DMA ........................................ 209.
- exit ....................................... 203.
- interface .................................. 209.
- internal ................................... 205-207.
- message .................................... 23, 148.
- microprogram ............................... 217.
- monitor call ............................... 167.
- return ..................................... 102.
- termination ................................ 108, 209.

## escape
- character .................................. 95.
- key ........................................ 132, 148, 199.

## examining
- control store .............................. 156.
- microprogram ............................... 156.
- physical memory ............................ 157.
- physical segment ........................... 158.
- resident memory ............................ 157.
- stack ...................................... 216.

## EXCDEF routine
- ............................................ 32.

## EXCEPT routine
- ............................................ 26.

## exception
- ............................................ 22.

## exception handler library
- ............................................ 22, 23.

## exchanging data
- ............................................ 141.

## exclusive use
- ............................................ 151.

## executable program
- ............................................ 15.

## EXECUTE-MACRO command
- description ................................ 109.
- implicit ................................... 94.
- reference .................................. 211.

## executing
- domain ..................................... 95.
- microprogram ............................... 155.
- program .................................... 87.

## execution
- ............................................ 93.
- inhibit .................................... 188.

---

## Page 257

# Index

## interrupt
- 148

## time
- 12, 22, 49, 137, 139, 145, 146, 204

## EXHIBIT-ADDRESS command
- description: 124
- reference: 125

## EXIT command
- description: 88
- reference: 45, 62, 87, 115, 120

## expandable data segment
- 162

## explicit
- fixing: 165
- logout: 151
- memory allocation: 137, 209

## external device
- 41

## EXTRA-FORMAT command
- description: 121
- within LOCK-AT: 117

---

| F | F | F | F | F | F | F | F | F | F | F | F | F | F | F | F | F | F |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|

## fatal
- error: 195
- trap: 21, 202

## FETCH-NRF-MODULES command
- description: 82

## file
- 43, 65, 74
- catalog: 10, 162
- closing: 95, 99
- handling: 76
- limits: 202
- name: 57–59, 98
- number: 98, 99, 206
- open: 209
- opening: 98, 99

## file access monitor call
- 102, 215

## file system error codes
- 103

## filling data memory
- 120

## fixed
- memory: 42
- priority: 150
- segment: 104, 139, 146, 147

## fixing
- automatic: 43
- contiguously: 214
- explicitly: 165
- implicitly: 165
- memory: 165
- scattered: 214
- segment: 205

## FIX-SEGMENT-ABSOLUTE command
- description: 147
- reference: 141

---

## Page 258

# Index

## FIX-SEGMENT-CONTIGUOUS command
- description: 146.
- reference: 140.

## FIX-SEGMENT-SCATTERED command
- description: 146.
- reference: 139.

### flag
- flag: 136.
- queuing: 135.

### flags for communication
- communication: 135.

### float format
- format: 121.

### FLOATING-OVERFLOW trap
- FLOATING-OVERFLOW: 89.

### FLOATING-UNDERFLOW trap
- FLOATING-UNDERFLOW: 89.

### floppy disk
- floppy disk: 47.

### FMO, NRF control number
- control number: 186, 188.

## FORCE-SEGMENT-LINK command
- description: 53.

### forcing logout
- logout: 151.

### formal parameter
- formal parameter: 109.

### format in LOOK-AT commands
- LOOK-AT commands: 120, 121.

## Fortran
- Fortran: 23, 63, 65, 186.
  - COMMON: 61, 62, 69, 146.
  - file number: 98.
  - monitor call: 177.
  - program: 76.

### free
- byte pointer: 186.
- mode: 188.
- freeing physical memory: 147.
- free pool: 165.

### function code
- function code: 207.

---

G G G G G G G C G G C G G G C G G G C G G C G G G C G G

## GET-FLAG command
- description: 136.
- reference: 135.

## GIVE-ND-500-PAGES command
- description: 153.
- reference: 153, 154.

### global symbol
- symbol: 71.

## GLOBAL-ENTRIES command
- description: 71.

## GO command
- description: 95.
- reference: 208, 212.

## GROUP subcommand
- description: 157.

## GUARD command
- description: 122.
- reference: 122, 126, 208.

### guard violation trap
- trap: 122.

---

## Page 259

# Index

## H

| Item                             | Page Numbers          |
|----------------------------------|-----------------------|
| halfword                         |                       |
| format                           | 121.                  |
| parameter                        | 167.                  |
| handler, trap                    | 21.                   |
| hangup state                     | 166.                  |
| hardware                         |                       |
| error                            | 206.                  |
| master clear                     | 166.                  |
| registers                        | 158.                  |
| sector size                      | 104.                  |
| hardware detected error          | 22.                   |
| HELP                             |                       |
| description                      | 86.                   |
| in LOOK-AT                       | 116.                  |
| reference                        | 10, 197, 202, 207, 211. |
| HE?NT                            |                       |
| MACM command                     | 153, 204.             |
| hexadecimal                      | 9.                    |
| format                           | 120, 121, 151.        |
| HIGH-ADDRESS command             |                       |
| description                      | 75.                   |
| reference                        | 194, 198.             |
| high limit register              | 122-124, 208.         |
| histogram                        |                       |
| buffer                           | 206.                  |
| commands                         | 127, 206.             |
| interval                         | 216.                  |
| HISTOGRAM commands               |                       |
| description                      | 127, 128.             |
| reference                        | 130, 132.             |
| HL register                      | 122, 123, 208.        |
| hole                             | 74.                   |

## I

| Item                             | Page Numbers          |
|----------------------------------|-----------------------|
| I registers                      | 119.                  |
| I1                               |                       |
| register                         | 22, 167.              |
| register contents destroyed      | 167.                  |
| IF-ERROR-FULL-STOP subcommand    |                       |
| description                      | 108.                  |
| reference                        | 209.                  |
| IF-ERROR-MACRO-STOP subcommand   |                       |
| description                      | 108.                  |
| reference                        | 203.                  |
| ignorable trap                   | 21.                   |
| ignoring comment                 | 88.                   |
| IHB, NRF control number          | 188, 195.             |
| illegal                          |                       |
| address                          | 206.                  |
| character                        | 206.                  |

---

## Page 260

# Index

| Topic                                | Page(s)  |
|--------------------------------------|----------|
| NRF control number                   | 190, 195 |
| format                               | 206      |
| parameter                            | 207      |
| ILLEGAL-INDEX trap                   | 89       |
| ILLEGAL-INSTRUCTION-CODE trap        | 89       |
| ILLEGAL-OPERAND-SPECIFIER trap       | 89       |
| ILLEGAL-OPERAND-VALUE trap           | 89       |
| immediate                            |          |
| add                                  | 188      |
| load                                 | 188      |
| implicit                             |          |
| CLOSE-SEGMENT                        | 45, 88   |
| END-DOMAIN                           | 44, 45, 88 |
| EXECUTE-MACRO                        | 94       |
| fixing                               | 165      |
| OPEN-SEGMENT                         | 50       |
| RECOVER-DOMAIN                       | 10, 94, 109 |
| SET-DOMAIN                           | 44, 50   |
| symbol deletion                      | 199      |
| inconsistencies, description file    | 198, 87  |
| inconsistency                        | 48       |
| indexed file                         | 15       |
| INDEX-SCALING-ERROR trap             | 89       |
| indirect                             | 208      |
| capability                           | 47       |
| segment                              | 16, 17, 41 |
| INDIRECT-SEGMENT command             |          |
| reference                            | 54       |
| information domain                   | 46       |
| inhibit execution                    | 188      |
| initialization                       | 138      |
| of trap handler data field           | 22       |
| initializing                         |          |
| data memory                          | 120      |
| error                                | 194      |
| input                                |          |
| flag                                 | 135      |
| program                              | 110      |
| INSERT-NRF-MESSAGE command           |          |
| description                          | 84       |
| inspecting data or program           | 115      |
| instruction set                      | 22       |
| INSTRUCTION-SEQUENCE-ERROR trap      | 89       |
| interactive                          | 10, 51, 139 |
| interface                            | 166      |
| error                                | 209      |
| register                             | 158      |
| intermodule reference                | 12       |
| internal                             |          |
| device                               | 41       |
| error                                | 205-208  |
| register                             | 158      |
| system table                         | 160      |
| interrupt                            | 95, 148, 151 |
| macro                                | 110      |
| INVALID-OPERATION trap               | 89       |

---

## Page 261

# Index

## I/O
- buffer . . . . . . . . . . . . . . . . . . . . 76.

---

## J
- job termination . . . . . . . . . . . . . . . . 88.

---

## K
- K bit . . . . . . . . . . . . . . . . . . . . . 22.
- K flag . . . . . . . . . . . . . . . . . . . . 167.
- KILL-ENTRIES command
  - description . . . . . . . . . . . . . . . . . 71.
  - reference . . . . . . . . . . . . . . . . . . 196, 199.

---

## L
- label . . . . . . . . . . . . . . . . . . . . . 9, 12, 54, 61, 67-71, 75, 83, 91.
  - definition . . . . . . . . . . . . . . . . . . 12, 187.
  - language . . . . . . . . . . . . . . . . . . . 63, 65.
    - code . . . . . . . . . . . . . . . . . . . . 61, 186.
    - sensitivity . . . . . . . . . . . . . . . . 63, 65.
  - layout of description file . . . . . . . . . . 181.
  - LBB, NRF control number . . . . . . . . . . . 189.
  - LDL, NRF control number . . . . . . . . . . . 188.
  - least recently used . . . . . . . . . . . . . 137.
  - legal
    - character . . . . . . . . . . . . . . . . . 195.
    - range . . . . . . . . . . . . . . . . . . . 122.
  - length of symbol . . . . . . . . . . . . . . 185.
  - LIB, NRF control number . . . . . . . . . . . 59, 81, 83, 85, 187.
  
- library . . . . . . . . . . . . . . . . . . . . 13, 81.
  - file . . . . . . . . . . . . . . . . . . . . 84, 35, 189.
  - loading . . . . . . . . . . . . . . . . . . . 189.
  - module . . . . . . . . . . . . . . . . . . . 67, 187, 189.
  - routine . . . . . . . . . . . . . . . . . . . 16.
  - symbol . . . . . . . . . . . . . . . . . . . 58, 59.
  - trap . . . . . . . . . . . . . . . . . . . . 22.

- LITERARY-SEGMENT-LINK command
  - description . . . . . . . . . . . . . . . . . 52.

- LIBRARY-SEGMENT-LOAD command
  - description . . . . . . . . . . . . . . . . . 58.
  - reference . . . . . . . . . . . . . . . . . . 59.

- limitations, direct transfer . . . . . . . . . 104.
- line editing . . . . . . . . . . . . . . . . . 157.
- LINK
  - access . . . . . . . . . . . . . . . . . . . 198.
  - file . . . . . . . . . . . . . . . . . . . . 10, 15, 53, 71, 189.
  - segment . . . . . . . . . . . . . . . . . . . 12, 49, 53, 167, 208.

---

## Page 262

# Index

linked segment  
.......................... 54  

linking  
.......................... 16, 23, 61, 63, 64, 200  

## LINK-RI-PROGRAM command

| Description | Reference  |
|-------------|------------|
| 73          | 194        |

## LINK-SEGMENT command

| Description | Reference           |
|-------------|---------------------|
| 52          | 49, 53, 54, 198, 199|

## LIST-ACTIVE-SEGMENTS command

| Description |
|-------------|
| 161         |

## LIST-AUTO-LINK-SEGMENTS command

| Description |
|-------------|
| 64          |

## LIST-AUTO-LOAD-FILE command

| Description |
|-------------|
| 66          |

## LIST-DOMAIN command

| Description | Reference  |
|-------------|------------|
| 46          | 16         |

## LIST-ENTRIES-DEFINED command

| Description | Reference |
|-------------|-----------|
| 69          | 70        |

## LIST-ENTRIES-UNDEFINED command

| Description |
|-------------|
| 70          |

## LIST-FILES SINTRAN III command

| Description |
|-------------|
| 212         |

## LIST-MACROS command

| Description |
|-------------|
| 111         |

## LIST-MAP command

| Description |
|-------------|
| 70          |

## LIST-MODE command

| Description |
|-------------|
| 77          |

## LIST-NRF-CODE command

| Description |
|-------------|
| 83          |

## LIST-NRF-ENTRIES command

| Description |
|-------------|
| 83          |

## LIST-OCTAL command

| Description |
|-------------|
| 76          |

## LIST-OPEN-FILES command

| Description |
|-------------|
| 99          |

## LIST-PROCESS-TABLE-ENTRY command

| Description |
|-------------|
| 161         |

## LIST-SEGMENT command

| Description | Reference      |
|-------------|----------------|
| 55          | 16, 46, 212    |

## LIST-SYMBOLIC command

| Description |
|-------------|
| 77          |

## LIST-SYSTEM-PARAMETERS command

| Description |
|-------------|
| 165         |

## LIST-TABLE command

| Description |
|-------------|
| 160         |

LL register  
.......................... 122-124, 206  

load  

| Address | Immediately | Map | Mode | Time |
|---------|-------------|-----|------|------|
| 78, 186, 187 | 188         | 70  | 187  | 22   |

---

## Page 263

# Index

## LOAD-CONTROL-STORE command
- description ....................................... 155.
- reference ......................................... 203.
- loader table ...................................... 12, 67-73, 78, 167, 189, 196, 199.
- loader table overflow ............................. 71.
- loading ........................................... 49, 50, 57, 58, 77, 200.
  - conditional ..................................... 187.

## LOAD-SEGMENT command
- description ....................................... 57.
- reference ......................................... 44.

## Local
- data field ........................................ 119.
- memory ............................................ 152.
- trap handling ..................................... 21, 90.

## LOCAL-TRAP-DISABLE command
- description ....................................... 93.
- reference ......................................... 195.

## LOCAL-TRAP-ENABLE command
- description ....................................... 90.
- reference ......................................... 195, 202.

## Location counter
- ................................................... 83.

## Logging
- ................................................... 208.
- all processes ..................................... 130.
- in ................................................ 151.
- one process ....................................... 130.

## Logical
- address ........................................... 18.
- addressing ........................................ 17.
- address space ..................................... 19.
- segment ........................................... 17, 93, 207.
- segment number .................................... 54, 146, 147.
- size .............................................. 137.

## Login
- ................................................... 151.

## Logout
- ................................................... 142, 151, 213.

## LOGOUT-PROCESS command
- description ....................................... 159.

## LOOK-AT command
- description ....................................... 115.
- reference ......................................... 88, 120, 159, 206, 208, 212.
- subcommands ....................................... 156.

## LOOK-AT-CONTROL-STORE command
- description ....................................... 156.

## LOOK-AT-DATA command
- description ....................................... 118.
- reference ......................................... 157, 158.

## LOOK-AT-HARDWARE command
- description ....................................... 158.

## LOOK-AT-PHYSICAL-SEGMENT command
- description ....................................... 158.
- reference ......................................... 113, 212.

## LOOK-AT-PROGRAM command
- description ....................................... 118.
- reference ......................................... 158.

---

## Page 264

# Index

## LOOK-AT-REGISTER command
- description .................................... 120.

## LOOK-AT-RELATIVE command
- description .................................... 119.

## LOOK-AT-RESIDENT-MEMORY command
- description .................................... 157.

## LOOK-AT-STACK command
- description .................................... 119.
- reference ...................................... 203, 216.

## low address
- ................................................ 54.

## LOW-ADDRESS command
- description .................................... 74.

## lower case
- ................................................ 9, 10.

## low limit register
- ................................................ 122-124, 208.

## LRF, NRF control number
- ................................................ 187.

---

### M

## MACM, HENT command
- ................................................ 153.

## MACR
- ................................................ 94.
- file ........................................... 107, 109, 110, 211.

## macro
- abortion ....................................... 209.
- body ........................................... 110, 209.
- commands ....................................... 107.
- delete ......................................... 110.
- error .......................................... 209.
- expansion ...................................... 203.
- listing ........................................ 111.
- name ........................................... 94.
- parameter ...................................... 107.
- permanent ...................................... 109, 110.
- saving ......................................... 110.
- temporary ...................................... 94, 109, 110.

## magtape
- ................................................ 43, 105, 203, 205.

## MAGTP monitor call
- ................................................ 105.

## main
- format ......................................... 121, 216.
- program ........................................ 119, 203.

## MAIN-FORMAT command
- description .................................... 120.
- reference ...................................... 116, 151, 207, 212.

## mapping
- ................................................ 137.

## MASTER-CLEAR command
- description .................................... 166.

## MATCH-COMMON-RT-SEGMENT command
- description .................................... 72.
- reference ...................................... 42, 194.

## MATCH-RT-COMMON command
- description .................................... 72.
- reference ...................................... 42.

## maximum
- auto load file ................................. 196.

---

## Page 265

# Index

## byte pointer
- 104.

## domains
- 44, 196.

## pages in memory
- 145.

## segment
- 193.

## memory
- **administration**: 153.
- **allocation**: 137, 145, 146, 209.
- **configuration**: 152, 204.
- **image**: 118, 120.
- **management system**: 137.
- **part**: 152.

## memory allocation, default
- 86.

## memory management register
- 158.

## message
- **during loading**: 189.
- **NRF**: 84.

## MIC register
- 120.

## micro program
- 155, 156, 203, 208, 210, 213.
- 204, 217.

## error
- 204, 217.

## maintanence
- 155.

## registers
- 120.

## version
- 149.

## MICRO-START command
- **description**: 155.
- **reference**: 155.

## MICRO-STOP command
- **description**: 155.

## minimum pages in memory
- 145.

## MIS, NRF control number
- 189.

## miscellaneous
- 189.

## MMS (Memory Management System)
- 15, 137.

## mnemonic, trap
- 195.

## mode job
- 9, 51, 78, 88.

## modifying
- **data location**: 122.
- **data or program**: 115.
- **flag**: 135.
- **hardware register**: 158.
- **interface register**: 158.
- **memory**: 204.
- **micro program**: 157.
- **physical memory**: 157.
- **physical segment**: 158.
- **register**: 204.
- **resident memory**: 157.
- **system parameters**: 151.

## modularization
- 16.

## module
- 4, 13, 58, 59, 61, 63, 65, 81, 84, 186.

## index table
- 200.

## library
- 200.

## modus opern
- 187.

## MON 60 NSOOM
- 209.

## MON 61 FIXC5
- 177.
- 207.

---

## Page 266

# Index

MON 64 ERMSG . . . . . . . . . . . . . . . . . . . . . . . . . . 168  
MON 65 QERMS . . . . . . . . . . . . . . . . . . . . . . . . . . . 168  
monitor call . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17, 41, 42, 102, 104, 150, 167, 204,  

- arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 167, 168  
- ERMSG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148  
- N500M . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135, 206  
- number . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207  
- parameter . . . . . . . . . . . . . . . . . . . . . . . . . . . 217  
- priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150  
- mother, trap enable . . . . . . . . . . . . . . . 21  
- moving domain . . . . . . . . . . . . . . . . . . . . . . . . 47  
- MSA, NRF control number . . . . . . . . . . . . . 186  
- MSG, NRF control number . . . . . . . . . . . . 189  
- MTE register . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21  
- multiple definition . . . . . . . . . . . . . . . . . . . 59  
- multiport memory . . . . . . . . . . . . . . . . . . . . 18, 152  
- multisegment loader . . . . . . . . . . . . . . . . . . 197  

---

N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N N  

N500M monitor call . . . . . . . . . . . . . . . . . . 135, 177, 206, 207  

### name

- conflicts . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12  
- domain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71, 44, 45, 195, 206  
- process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206  
- segment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206  
- syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195, 206  
- trap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10  
- naming  

  | NRF module | 81  |  
  |------------|-----|  
  | rule       | 10  |  

### ND-100

- communication . . . . . . . . . . . . . . . . . . . . . . . 72, 73, 135, 137, 165, 194, 204, 211, 213  

- CPU . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152  
- monitor call . . . . . . . . . . . . . . . . . . . . . . . . . . 150  
- monitor calls . . . . . . . . . . . . . . . . . . . . . . . . . . 151  
- private memory . . . . . . . . . . . . . . . . . . . . . . 214  
- segment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42, 47, 137, 214, 216  
- segment number . . . . . . . . . . . . . . . . . . . . . . . 205  

### ND-500

- driver . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177, 207, 208  
- interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166  

### ND Relocatable Format (NRF)

- negative values . . . . . . . . . . . . . . . . . . . . . . 185  
- nested compound group . . . . . . . . . . . . . 189  

### new

- domain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 44, 194  
- NRF modules . . . . . . . . . . . . . . . . . . . . . . . . . 81  
- segment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10, 49

---

## Page 267

# Index

## segment name
. . . . . . . . . . . . . . . . . . . . . . . . . . . 55

## NEW-NRF-MODULES command
- **description**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

## NEXT command
- **description**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
- **reference**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

## non-demand
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

## non-ignorable trap
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

## non-printing characters
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 185

## non-reentrant trap handler
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

## normal termination
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

## NRF (ND Relocatable Format)
- **code**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
- **NRF control number**
  . . . . . . . . . . . . . . 59, 81, 83
- **control numbers**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
- **control number table**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
- **editor**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
- **file**
  . . . . . . . . . . . . 50, 57–59, 65, 77, 81, 84, 85, 195

## format
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 72, 185

## group
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 185

## library
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 13, 81

## library file
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

## message
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

## module
- . . . . . . . . . . . . . . . . . . . . 67, 81, 92, 84

## symbol
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

## NRF file maintainance
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

## NRF group repetition
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 138

## NUL, NRF control number
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 186

## number of physical segments
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 164

## numeric
- **field**
  . . . . . . . . . . . . . . . . . . . . 185, 187
- **format**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
- **length**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
- **parameter**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
- **value**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 216

---

| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

## object file
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

## octal
- . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
- **description**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
- **format**
  . . . . . . . . . . . . . . . . . . . . 120, 121, 151

## listing
- . . . . . . . . . . . . . . . . . . . . . . . . 76, 77, 83

## number
- . . . . . . . . . . . . . . . . . . . . . . . . 67, 198

## OMITTED-SEGMENT-LOAD command
- **description**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
- **reference**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

## omitting
- **EXECUTE-MACRO**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 110
- **RECOVER-DOMAIN**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

## open
- **file**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 98, 99
- **file table**
  . . . . . . . . . . . . . . . . . . . . . . . . . . . 209

---

## Page 268

# Index

mode ..................................... 205.  
modus .................................... 209.  
monitor call ............................. 104, 203, 205, 209.  

segment .................................. 48.  
OPEN-FILE command  
description .............................. 98.  
reference ................................ 104, 105.  

OPEN-SEGMENT command  
description .............................. 49.  
implicit .................................. 50.  
reference ................................ 50, 54, 57, 61, 195, 198, 199.  

operating  
system ................................... 17, 41, 152.  
system error ............................. 205.  
optimizing file access ................... 104.  
optional parameter ....................... 9, 86.  
ORIN subcommand  
description .............................. 157.  
OTE register ............................. 21, 22, 90, 124.  
other  
users .................................... 197, 198.  
other users segment ...................... 55.  
OUTBT monitor call ....................... 41.  
output  
device ................................... 9.  
flag ..................................... 135.  
OUTPUT-FILE command  
description .............................. 87.  
reference ................................ 9.  

OUTST monitor call ....................... 41.  
OVERFLOW ................................  
loader table ............................. 89, 186, 187.  
.......................................... 196.  
overhead monitor call .................... 41.  
overriding defaults ...................... 86.  
own trap enable .......................... 21, 93, 124.  

---

| P    | P    | P    | P    | P    | P    | P    | P    | P    | P    | P    | P    | P    | P    |
|------|------|------|------|------|------|------|------|------|------|------|------|------|------|

page ..................................... 137.  
boundary ................................ 146, 147.  
fault ................................... 137, 138, 145.  
index table .............................. 205.  
number ................................... 152.  
table .................................... 177.  
pages, giving to ND-500 .................. 153.  
paging off area .......................... 177.  
parameter ................................ 107.  
access ................................... 17.  
addresses ................................ 177.  
command .................................. 86.  
reference ................................ 109.  
terminator ............................... 9.  
abbreviation ............................. 202.  
parentheses .............................. 195, 206.

---

## Page 269

# Index

### Parity
- 185

### Pascal
- 63, 65, 186

### Patching
- 93, 113, 118

#### Microprogram
- 212

### PATCH-MEMORY Command
#### Reference
- 157

### PCLC 
- 88

### Percentage CPU Time
- 67, 186

### Performance
- 150

### Measurement
- 143

### Permanent
- 127

#### Breakpoint
- 95
  
#### Macro
- 107, 109-111, 211

### PERMIT-DEPOSIT Subcommand
#### Description
- 117

#### Reference
- 204

### Physical
#### Address
- 18, 141, 147, 152, 214

#### Addressing Range
- 152

#### Memory
- 104, 137, 145, 146, 152, 157, 204

#### Segment
- 17, 18, 93, 158, 164, 210

### PLACE Reference
- 212

### PLACE-DOMAIN Command
#### Description
- 93

#### Reference
- 94, 113, 204, 213, 214, 216

### Plane
- 23, 63, 65, 186

### PMO, NRF Control Number
- 186, 188

### Pointer
- 186

### Porting Domains
- 42

### Power Failure
- 210, 213

### Predefined Symbols
- 53

### PREPARE-NRF-LIBRARY-FILE Command
#### Description
- 85

#### Reference
- 57, 84, 200

### Prepreferenced Symbols
- 53

### PREVIOUS Subcommand
#### Description
- 119

#### Reference
- 203

### PRIMESS Exception Library Routine
- 36

### PRINT-HISTOGRAM Command
#### Reference
- 206

#### Description
- 128

### PRINT-PROCESS-LOG Command
#### Description
- 131

#### Reference
- 130, 208

### Priority, Monitor Call
- 150

### PRITRAC Exception Library Routine
- 35

### Private Memory
- 152

### Privilege
- 44

### Procedure Call
- 123

---

## Page 270

# Index

## Process
- abortion ............. 159
- communication ........ 135, 136, 159
- entry ................ 181, 182
- flag ................. 136
- name ................. 136, 206
- number ............... 130, 136, 159
- priority ............. 150
- suspension ........... 41, 137

## PROCESS-LOG-ALL Command
- description .......... 131

## PROCESS-LOG Commands
- reference ............ 130, 131

## PROCESS-LOG-ONE Command
- description .......... 131

## PROCESS-STATUS Command
- description .......... 160
- reference ............ 131

## Processor
- ...................... 152

## Program
- abort ................ 23
- address .............. 113, 124
- byte pointer ......... 186-188
- channel .............. 152
- file ................. 10
- input ................ 110
- label ................ 67
- memory ............... 118
- mode ................. 187, 188
- reference ............ 187
- segment .............. 12, 15, 17, 54, 57, 67, 68, 74, 75, 93, 113, 118, 146, 198, 206, 216
- termination .......... 209

## Program Address, Add
- ...................... 188

## Program Counter, Sampling
- ...................... 128

## PROGRAMMED-TRAP
- ...................... 89

## PROGRAM-REFERENCE Command
- description .......... 67

## Prompt
- ...................... 9

## PROTECT-VIOLATION
- ...................... 89

## PSEG
- ...................... 10, 15, 162
- file ................. 212

---

## Q
- QERMS monitor call ... 168
- queuing flags ........ 135
- quote ................ 194, 198, 206
- double ............... 195

---

## Page 271

# Index

---

## R

| Topic                                    | Page(s)            |
|------------------------------------------|--------------------|
| R register                               | 119.               |
| random access                            | 198.               |
| read                                     |                    |
| access                                   | 198.               |
| input flag                               | 135.               |
| output flag                              | 135.               |
| read only                                |                    |
| data segment                             | 49.                |
| segment                                  | 93.                |
| re-building description file             | 11.                |
| RECOVER-DOMAIN command                   |                    |
| description                              | 94.                |
| implicit                                 | 10, 109.           |
| reference                                | 204, 208,          |
|                                          | 211–214, 216.      |
| redefining trap handling                 | 202.               |
| redefinition                             | 59.                |
| reentrant program segment                | 16.                |
| REF, NRF control number                  | 187.               |
| reference                                | 58, 59, 65, 67,    |
|                                          | 70, 73, 187.       |
| undefined                                | 51, 63.            |
| register                                 |                    |
| LOOK-AT                                  | 120.               |
| sequence                                 | 120.               |
| relative                                 |                    |
| addresses                                | 119.               |
| LOOK-AT                                  | 119.               |
| RELEASE-DOMAIN command                   |                    |
| description                              | 48.                |
| reference                                | 87.                |
| RELEASE-HISTOGRAM command                |                    |
| description                              | 128.               |
| reference                                | 206.               |
| RELEASE-LOG-BUFFER command               |                    |
| description                              | 132.               |
| reference                                | 208.               |
| releasing                                |                    |
| fixed segment                            | 142.               |
| segment                                  | 147.               |
| reloading segment                        | 196, 198.          |
| RELOAD-SEGMENT command                   |                    |
| description                              | 58.                |
| relocatable                              |                    |
| symbol                                   | 4.                 |
| removable disk                           | 12.                |
| remove                                   | 47.                |
| NRF module                               | 82.                |
| symbol                                   | 71, 187.           |
| RENAME-DEFAULT-DIRECTORY-AND-USER command|                    |
| description                              | 78.                |
| RENAME-DOMAIN command                    |                    |
| description                              | 46.                |

---

## Page 272

# Index

## RENAME-FILE command
- SINTRAN command . . . . . . . . . . . . . . . . . . 55.

## RENAME-SEGMENT command
- description . . . . . . . . . . . . . . . . . . . . 55.
- REP, NRF control number . . . . . . . . . . . . 188, 189.
- repeat NRF group . . . . . . . . . . . . . . . . . . 188.
- replacing NRF modules . . . . . . . . . . . . . . . 81.
- required parameter . . . . . . . . . . . . . . . . . 9.
- reserved segment . . . . . . . . . . . . . . . . . . 48.
- reserving swapping log buffer . . . . . . . . . . . 132.

## RESET command
- description . . . . . . . . . . . . . . . . . . . . 78.

## RESET-AUTOMATIC-ERROR-MESSAGE command
- description . . . . . . . . . . . . . . . . . . . . 148.

## RESET-BRANCH-TRACE command
- description . . . . . . . . . . . . . . . . . . . . 126.

## RESET-BREAKS command
- description . . . . . . . . . . . . . . . . . . . . 125.
- reference . . . . . . . . . . . . . . . . . . . 210, 212.

## RESET-CALL-TRACE command
- description . . . . . . . . . . . . . . . . . . . . 126.

## RESET-DEBUG command
- description . . . . . . . . . . . . . . . . . . . . 125.

## RESET-GUARD command
- description . . . . . . . . . . . . . . . . . . . . 126.

## RESET-LAST-BREAK command
- description . . . . . . . . . . . . . . . . . . . . 126.
- reference . . . . . . . . . . . . . . . . . . . . . 208.

## RESET-TRACE command
- description . . . . . . . . . . . . . . . . . . . . 126.

## resetting interface
- . . . . . . . . . . . . . . . . . . . . . . . . . . 166.

## resident
- area . . . . . . . . . . . . . . . . . . . . . . . . 177.
- memory . . . . . . . . . . . . . . . . . . . . 42, 157.

## resource utilization
- . . . . . . . . . . . . . . . . . . . . . . . . . . 143.

## restarting
- domain . . . . . . . . . . . . . . . . . . . . . . 95.
- system . . . . . . . . . . . . . . . . . . . . . . 204.

## restoring instruction
- . . . . . . . . . . . . . . . . . . . . . . . . 95, 114.

## RESUME-MACRO command
- description . . . . . . . . . . . . . . . . . . . 110.

## RFILE monitor call
- . . . . . . . . . . . . . . . . . . . . . . . . . . 104.

## rights
- . . . . . . . . . . . . . . . . . . . . . . . . . . 44.

## RMAX monitor call
- . . . . . . . . . . . . . . . . . . . . . . . . . . 104.

## RMV, NRF control number
- . . . . . . . . . . . . . . . . . . . . . . . . . . 187.

## routine
- call . . . . . . . . . . . . . . . . . . . . 17, 41, 123.
- vector . . . . . . . . . . . . . . . . . . 75, 198, 200.

## RT
- loader . . . . . . . . . . . . . . . . . . . . 72, 73.
- program ND-100 . . . . . . . . . . . . . . . . 41, 73.
- segment ND-100 . . . . . . . . . . . . . . . 42, 72.
- user . . . . . . . . . . . . . . . . . . . . . . . 152.
- RTCOMMON
  - . . . . . . . . . . . . . . 42, 47, 72, 137, 141, 165, 204, 211, 213, 214.

## modification
- . . . . . . . . . . . . . . . . . . . . . . . . . . 213.

---

## Page 273

# Index

| Topic                       | Pages                     |
|-----------------------------|---------------------------|
| size                        | 213                       |
| RT-FIL                      | 194                       |
| RT-LOADER                   | 42                        |
| RUN command                 |                           |
| description                 | 87                        |
| reference                   | 94, 159, 208, 212         |
| runtime errors              | 148                       |

---

# S

| Topic                       | Pages                     |
|-----------------------------|---------------------------|
| S field                     | 185                       |
| sampling                    |                           |
| CPU usage                   | 130, 131                  |
| program counter             | 126                       |
| saving macro                | 110                       |
| scattered                   |                           |
| fixing                      | 139                       |
| pages                       | 146                       |
| scratch                     |                           |
| domain                      | 49                        |
| segment                     | 193                       |
| SCRATCH-DOMAIN              | 44, 45, 50, 193           |
| SCRATCH-SEGMENT-01          | 50                        |
| search procedure            | 94, 109                   |
| sector size                 | 202, 203                  |
| SEGTIL                      | 42, 216                   |
| segment                     |                           |
| cleaning                    | 165                       |
| delete                      | 45                        |
| entry                       | 11, 46, 55, 181, 183      |
| file                        | 10, 12, 15, 54            |
| information                 | 54, 55                    |
| layout                      | 198, 200                  |
| limit                       | 138, 145, 198, 206        |
| maximum                     | 193                       |
| name                        | 15, 49, 53-55, 61-63, 118, 146, 147, 197, 198, 206, 212 |

| Topic                       | Pages                     |
|-----------------------------|---------------------------|
| name syntax                 | 10                        |
| number                      | 15, 54, 62, 146, 147, 167, 214 |
| physical                    | 93                        |
| re-loading                  | 198                       |
| shared                      | 47, 194                   |
| size                        | 54, 215, 216              |
| table                       | 11                        |
| type                        | 207                       |
| unavailable                 | 48                        |
| segmenting                  | 16                        |
| segment number, ND-100      | 205                       |
| segment, maximum            | 193                       |
| SELECTED-SEGMENT-LOAD command|                           |

---

## Page 274

# Index

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 59               |
| selective loading                     | 59               |
| semaphore                             | 41, 42           |
| separation, code data                 | 15               |
| sequence, registers                   | 120              |
| set load address                      | 187              |

## SET-AUTO-LINK-SEGMENT command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 63               |
| reference                             | 64               |

## SET-AUTO-LOAD-FILE command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 65               |
| reference                             | 51, 66           |

## SETBT monitor call

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| reference                             | 203              |

## SET-DOMAIN command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 44               |
| implicit                              | 44               |
| reference                             | 50, 198          |

## SET-FLAG command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 136              |
| reference                             | 135              |

## SET-HISTOGRAM command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 127              |
| reference                             | 128, 206         |

## SET-TO-BUFFERS command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 76               |

## SET-MEMORY-CONTENTS command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 120              |

## SET-ND-500-AVAILABLE command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 151              |
| reference                             | 151, 210, 213    |

## SET-ND-500-UNAVAILABLE command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 151              |
| reference                             | 151, 210         |

## SET-PRIORITY command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 150              |

## SET-SEGMENT-LIMITS command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 145              |
| reference                             | 138              |

## SET-SEGMENT-NUMBER command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 54               |
| reference                             | 50, 62           |

## SET-SYSTEM-PARAMETERS command

| Description                           | Page(s)          |
|---------------------------------------|------------------|
| description                           | 164              |
| reference                             | 165              |

## Miscellaneous

| Topic                                 | Page(s)          |
|---------------------------------------|------------------|
| setting K flag                        | 167              |
| shared memory                         | 152, 153         |
| shared segment                        | 16-18, 47, 72, 141, 147, 165, 194, 214, 216 |
| sign extension                        | 11               |
| simultaneous access                   | 187              |
| single step                           | 114              |
| stepping                              | 115              |
| SINGLE-INSTRUCTION-TRAP               | 89               |
| single segment loader                 | 197              |

---

## Page 275

# Index

SINTRAN  
command .......................................... 41, 88.  
file system ...................................... 195.  
line editing ..................................... 157.  
MACM ............................................. 153.  
monitor call ..................................... 150, 167.  

## SINTRAN commands  
description ...................................... 87.  
DUMP ............................................. 120.  
RENAME-FILE ...................................... 55.  
RENAME-USER ...................................... 47.  
size  
common-block .................................. 69.  
I/O buffer ................................... 76.  
SLA NRF control number ................. 187.  
slash (/) ...................................... 208.  
LOOK-AT ..................................... 115.  
SMAX monitor call .......................... 104.  
software detected errors .................... 22.  

## Source  
domain .......................................... 47.  
file ............................................... 82.  
space ........................................... 67-70, 74-76.  
stack ........................................... 119, 203.  
examining .................................... 216.  
frame .......................................... 119.  
STACK-OVERFLOW trap .................... 89.  
STACK-UNDERFLOW trap ................. 29, 89.  
standard trap handler ......................... 21, 90.  
start address ................................... 11, 46, 54, 87, 93, 95, 186, 215, 216.  

## START-HISTOGRAM command  
description ...................................... 128.  
reference ......................................... 127, 206.  

## Starting  
execution ....................................... 87.  
micro program ................................. 155.  
monitor .......................................... 10.  

## START-PROCESS-LOG-ALL command  
description ...................................... 130.  
reference ......................................... 130, 131.  

## START-PROCESS-LOG-ONE command  
description ...................................... 130.  
reference ......................................... 131.  

## Startup time  
...................................................... 139.  

## STATUS command  
description ...................................... 125.  
register ............................................ 125.  

## STEP command  
description ...................................... 115.  
reference ......................................... 114.  

## STOP-HISTOGRAM command  
description ...................................... 128.  
reference ......................................... 206.  

## Stopping  
micro program ................................. 155.

---

## Page 276

# Index

| Topic                                           | Page Numbers        |
|-------------------------------------------------|---------------------|
| ND-500                                          | 166, 210            |
| output                                          | 10                  |
| process                                         | 159                 |
| program execution                               | 148                 |
| string parameter                                | 167                 |
| structure, description file                     | 181                 |
| sub control number NRF                          | 189                 |
| subroutine                                      | 186                 |
| address                                         | 167                 |
| call                                            | 123, 167            |
| subsystem version                               | 149                 |
| supervisor commands                             | 151                 |
| suppress loading                                | 59                  |
| suspending process                              | 41                  |
| swap                                            |                     |
| file                                            | 16, 19, 149, 162, 164, 210, 212, 215 |
| queue                                           | 143                 |
| segment                                         | 143                 |
| swapper                                         | 143, 205            |
| process                                         | 137                 |
| version                                         | 149                 |
| swapping                                        |                     |
| strategy                                        | 49, 137, 145, 162, 215 |
| SWAPPING-LOG command                            | 143                 |
| description                                     | 132                 |
| reference                                       | 127, 128, 130, 132  |
| symbol                                          | 59, 67, 68, 71, 83, 187 |
| defined                                         | 146, 147            |
| definition                                      | 83                  |
| entry                                           | 184                 |
| global                                          | 71                  |
| length                                          | 53, 185             |
| name                                            | 12                  |
| remove                                          | 187                 |
| truncation                                      | 71                  |
| value                                           | 12, 91, 187         |
| symbolic                                        |                     |
| debugger                                        | 15                  |
| field                                           | 185                 |
| listing                                         | 77                  |
| name                                            | 15                  |
| SYMBOLIC subcommand                             |                     |
| description                                     | 157                 |
| synchronizing mechanism                         | 18                  |
| syntax                                          |                     |
| commands                                        | 78                  |
| name                                            | 10                  |
| system                                          |                     |
| crash                                           | 48                  |
| parameters                                      | 132, 140, 143, 151, 164, 165, 210, 211 |

---

## Page 277

# Index

## Performance
- 127, 138, 139, 143

## Restart
- 152, 204

## Saturation
- 210-212, 215, 216

## Segment
- 17

## Supervisor
- 143, 210, 213

## Table
- 153

## User
- 130, 131, 150, 151

## Version
- 149

## System Defined Autoload File
- 51

## SYSTEM-ENTRIES-ON Command
- Description: 70
- Reference: 69

## System Selected Swapfile
- 162

## System Supervisor Commands
- 151

## SYSTEM-TRAP-DISABLE Command
- Description: 91
- Reference: 195

## SYSTEM-TRAP-ENABLE Command
- Description: 91
- Reference: 195

---

### T T T T T T T T T T T T T T T T T T T T T T T

## Table Overflow
- 196

## TAKE-ND-500-PAGES Command
- Description: 153, 154

## Taking Memory Pages
- 153

## Pages from ND-500
- 154

## TEMM Register
- 21

## Temporary Macro
- 94, 107, 109-111, 211

## TEMPORARY-BREAK Command
- Description: 114
- Reference: 216

## Terminal Process Communication
- 135

## Terminating Job
- 88

## Terminator
- 9

## Test Checksum
- 186

## THA Register
- 21, 22, 93

## Time Slicing
- 150

## Time Critical Operations
- 151

## Routine Timeout
- 16

## Timeout
- 210

## TIME-USED Command
- Description: 148

## TOTAL-SEGMENT-LOAD Command
- Description: 60

## TRACE Command
- Description: 122
- Reference: 123, 126, 208

## Traceback
- 23

---

## Page 278

# Index

## Tracing
- tracing .............................................. 124

## Translation Mechanism
- translation mechanism ............................... 137

## Transmission Data
- transmission data .................................... 41

## Transporting Domain
- transporting domain .................................. 47

## Trap
- trap ............................................... 21-23, 124
  - bit ................................................ 25
  - condition ...................................... 203, 209
  - Enable Modification Mask ........................... 21
  - handler ..................................... 21, 202, 209
  - Handler Address .................................... 21
  - library ............................................ 22
  - mnemonic ...................................... 25, 195
  - name ........................................... 25, 195
  - propagation ........................................ 21
  - table .............................................. 25

- trap handler address .................................. 93
- trap handling, default ................................ 86
- truncating symbol ..................................... 71
- twin process .................................... 141, 150
- two's complement ............................... 185, 186

---

## U

- unavailable, ND-500 .................................. 151
- unconditional load .................................... 59

## Undefined
- reference ................................... 51, 63, 208
- references ........................................... 65
- symbol ....................................... 187, 189

## Unfixing Segment
- unfixing segment ..................................... 142

## UNFIX-SEGMENT Command
- description .......................................... 147
- reference .................................. 142, 146, 147

- unpredictable contents ................................ 74

## Updating
- domain entry .......................................... 46
- segment entry ......................................... 46

## User

- break ................................................ 199
- fixing ............................................... 165
- interrupt ............................................ 148
- name ................................... 44, 47, 55, 93, 195

- processes ............................................ 153
- RT ................................................... 151
- SYSTEM ....................... 63-66, 93, 94, 109, 130, 131, 150, 151, 162

## User Defined

- auto link segment ..................................... 64
- auto load file ........................................ 51
- entries ............................................... 69
- user written trap handler .......................... 21, 23

---

## Page 279

## V

### VALUE-ENTRY command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91.
- reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199.

### vector routines
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198.

### VERSION command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149.

## W

### WAITF monitor call
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104.

### warning
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11.

### WFILE monitor call
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104.

### WHO-IS-ON command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149.
- reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131.

### word
- count . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104.
- format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121.

### WORD subcommand
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157.
- working set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138.

### write
- access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17.
- input flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135.
- output flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135.

### WRITE-DOMAIN-STATUS command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46.

### WRITE-NRF-EOF-AFTER-MODULE command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84.

### WRITE-SEGMENT-STATUS command
- description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55.

### writing trap handler
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22.

### written in page
- . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137.

## Z

### zero
- fill . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74, 75.
- physical address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152.

---

## Page 280

## SEND US YOUR COMMENTS!!!

Are you frustrated because of unclear information in this manual? Do you have trouble finding things? Why don’t you join the Reader's Club and send us a note? You will receive a membership card — and an answer to your comments.

Please let us know if you
- find errors
- cannot understand information
- cannot find information
- find needless information

Do you think we could improve the manual by rearranging the contents? You could also tell us if you like the manual!

## HELP YOURSELF BY HELPING US!!

| Manual name: | ND-500 Loader/Monitor |
|--------------|-----------------------|
| Manual number: | ND-60.136.04A |

What problems do you have? (use extra pages if needed)  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  

Do you have suggestions for improving this manual?  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  
___________________________________________________________________  

| Your name:  | Date:          |  
| ----------- | -------------- |  
| Company:    | Position:      |  
| Address:    |                |  

What are you using this manual for?  
___________________________________________________________________  

**NOTE!**  
This form is primarily for documentation errors. Software and system errors should be reported on Customer System Reports.

| Send to:          | Norsk Data A.S                                              |  
|-------------------|-------------------------------------------------------------|  
|                   | Documentation Department                                    |  
|                   | P.O. Box 25, Bogerud                                        |  
|                   | Oslo 6, Norway                                              |  

Norsk Data’s answer will be found on reverse side.

---

## Page 281

# Answer from Norsk Data

______________________________________________________________

______________________________________________________________

______________________________________________________________

______________________________________________________________

______________________________________________________________

______________________________________________________________

## Answered by

____________________________________________________  **Date** ______________

---

Norsk Data A.S  
Documentation Department  
P.O. Box 25, Bogerud  
Oslo 6, Norway

---

## Page 282

# Systems that put people first

ND

---

