# SINTRAN III Monitor Call: InByte
# Octal: 1B
# Extracted from: Monitor Calls.md (ND-860228.2 EN)

octal: 1B
name: InByte
short_names: []
description: 'Reads one byte from a character device, e.g. a terminal or an opened
  file. If the device is a word-oriented device, one word is read. This monitor call
  can be used on most input devices.


  - Bit 7 is a parity bit if terminal or file input. IOMultiFunction may change this.

  - The program waits if there is no bytes in the input buffer of the device. You
  can change this with NoWaitSwitch or TerminalNoWait.

  - The pointer to the next byte is incremented when you read from a mass-storage
  file.

  - Input from card readers are converted to ASCII characters. Use DeviceControl to
  read the 12-bit card columns.

  - Background programs may read from logical device number 0. This is the SINTRAN
  III command buffer. You may read parameters following the program name this way.
  Break and echo are both set to 1. Normal SINTRAN III command editing is available.
  All letters are converted to uppercase. You may control this with IOMultiFunction.

  - Appendix F contains an ASCII table.'
notes: []
see_also:
- In8AndFlag
- InUpTo88Bytes
- In8Bytes
- InString
- InputString
- In4x2Bytes
- and OutByte
references: []
parameters:
- name: ⟶
  type: Logical device number. See appendix B. Use 1 for your own terminal.
  io: I
  description: ''
- name: ←
  type: The read byte.
  io: I
  description: ''
- name: ←
  type: Standard Error Code. See appendix A.
  io: I
  description: ''
examples:
  pascal:
    available: true
    code: '```

      DeviceNumber, ReturnValue : INTEGER2;

      ...

      InByte(DeviceNumber, ReturnValue);

      IF ErrCode <> 0 THEN ...

      ```'
    notes: ''
  cobol:
    available: true
    code: '```

      01 DeviceNumber COMP.

      01 ReturnValue COMP.

      01 ErrCode COMP.

      ...

      MONITOR-CALL "InByte" USING DeviceNumber, ReturnValue.

      CALL "CbError" USING ErrCode.

      IF ErrCode NOT = 0 GO ...

      ```'
    notes: ''
  fortran:
    available: true
    code: '```

      INTEGER DeviceNumber, ReturnValue

      ...

      Monitor Call(''InByte'', DeviceNumber, ReturnValue)

      IF (ErrCode .NE. 0) THEN ...

      ```'
    notes: ''
  planc:
    available: true
    code: "```\nINTEGER: DeviceNumber, ReturnValue\n..\nON ROUTINEERROR DO\n   IF\
      \ ErrCode > 0 THEN ..\nENDON\nMonitor_Call('InByte', DeviceNumber, ReturnValue)\n\
      ```"
    notes: ''
  assembly_500:
    available: true
    code: '```

      DeviceNumber: W BLOCK 1

      ReturnValue: W BLOCK 1

      ErrCode: W BLOCK 1

      InByte: EQU 37B9 + 1B


      CALLG InByte, 2, DeviceNumber, ReturnValue

      IF'' K GO ERROR


      ERROR W1.. ErrCode %ErrorCode in W1 register.

      ```'
    octal_definition: 37B9 + 1B
    notes: ''
  mac:
    available: true
    code: '```

      LDT DEVNO %Logical device number.

      MON 1    %Monitor call InByte.

      JMP ERROR %Error return from monitor call.

      STA BYTE  %Normal return, store byte read.


      ERROR.    %Error number in register A.


      DEVNO.

      BYTE. 0

      ```


      | ND-100 and ND-500 | All users | All programs |'
    mon_number: 1
    notes: ''
compatibility:
  platforms:
    nd100: false
    nd500: true
  users:
  - All users
  programs:
  - All programs
  notes: ''
errors:
  returns_error: false
  error_codes: []
  error_reference: ''
source:
  document: SINTRAN III Monitor Calls (ND-860228.2 EN)
  page: 319
  line: 14357
  scan_date: '2020'
  scanned_by: Jonny Oddene for Sintran Data
extraction:
  date: '2025-01-06'
  version: '1.0'
  validated: false
  ocr_corrected: false
  ocr_notes: ''
